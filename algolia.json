[{"content":"Dgraph实验室自2015年成立以来一直是Go语言的用户。五年过去了，200K行的Go代码，我们很高兴地告诉大家，我们仍然相信Go是并且仍","lvl0":"使用jemalloc在Go中手动管理内存","lvl1":["Go"],"lvl2":"摘要","objectID":"7ce769a911965f5440a5bbe8b13dddab","tags":["Go","CGO"],"url":"/post/%E4%BD%BF%E7%94%A8jemalloc%E5%9C%A8go%E4%B8%AD%E6%89%8B%E5%8A%A8%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98/"},{"content":"前言 我们以下面的程序为例，先使用四种不同的方式来介绍如何观察 GC，并在后面的问题中通过几个详细的例子再来讨论如何优化 GC。 1 2 3 4 5 6 7 8 9","lvl0":"Go语言观察GC的几种方式","lvl1":["Go"],"lvl2":"摘要","objectID":"6f7983b2c4a3a7a30aac11cc2ca60b40","tags":["Go"],"url":"/post/go%E8%AF%AD%E8%A8%80%E8%A7%82%E5%AF%9Fgc%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"content":"前言 让我们从一个简单的程序开始，注册prom处理程序并监听8080端口： 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;github.com/prometheus/client_golang/prometheus/promhttp\u0026#34; ) func main() { http.Handle(\u0026#34;/metrics\u0026#34;, promhttp.Handler()) log.Fatal( http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) } 当你点击","lvl0":"探索Prometheus的Go客户端指标","lvl1":["prometheus"],"lvl2":"摘要","objectID":"c5babab9a49d8c2ccd4ce483a80d0e4f","tags":["prometheus"],"url":"/post/%E6%8E%A2%E7%B4%A2prometheus%E7%9A%84go%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8C%87%E6%A0%87/"},{"content":"优化的范围 Latency numbers every programmer should know 我们的性能优化主要聚焦在应用、Go 标准库、Go runtime。 大多数优化集中在应用代码 极少部分在标准库和 runtime. Benchmark 逃逸分析 用","lvl0":"Go语言性能调优指南","lvl1":["调优"],"lvl2":"摘要","objectID":"668648e9642477c5982d6c0649daf194","tags":["调优"],"url":"/post/go%E8%AF%AD%E8%A8%80%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%8C%87%E5%8D%97/"},{"content":"性能测试 专有名词 1、吞吐量（Requests per second） 概念：服务器并发处理能力的量化描述，单位是reqs/s，指的是某个并发用户数下单","lvl0":"性能测试工具wrk介绍","lvl1":["测试"],"lvl2":"摘要","objectID":"bcbd0ed799a66d68cc767bbcbcd92a56","tags":["wrk"],"url":"/post/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7wrk%E4%BB%8B%E7%BB%8D/"},{"content":"哈希算法 下面简单介绍下几种比较常用的加密哈希算法： MD5 MD5 即 Message-Digest Algorithm 5（信息-摘要算法 5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一","lvl0":"哈希算法与哈希表","lvl1":["算法"],"lvl2":"摘要","objectID":"5264e477cf290ac3172f7546a83eb2bc","tags":null,"url":"/post/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%B8%8E%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"content":"前言 Go 的运行时能够直接接触到操作系统内核级的同步原语，note 和 mutex 分别是 Go 运行时实现的一次性通知机制和互斥锁机制， 其实现是操作系统特定的，这","lvl0":"运行时同步原语源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"65025f31bd491559b46f72b6c2058f2c","tags":["Go源码"],"url":"/post/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"什么是操作系统 操作系统是资源的管理器，其管理的资源均进行了抽象 磁盘抽象:文件夹 内存抽象:虚拟内存 CPU 抽象:时间片 分级保护域-protectio","lvl0":"Go中的系统调用","lvl1":["Go"],"lvl2":"摘要","objectID":"ab1c55887ed41694ebb9ff92b7999dbd","tags":["Go"],"url":"/post/go%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"},{"content":"Go netpoller的问题 Go netpoller 的设计不可谓不精巧、性能也不可谓不高，配合 goroutine 开发网络应用的时候就一个字：爽。因此 Go 的网络编程模式是及其简洁高效","lvl0":"Go的Reactor模型的网络框架gnet介绍","lvl1":["Go"],"lvl2":"摘要","objectID":"858126f739aea7d6dd5a933a7484ef7d","tags":["Go"],"url":"/post/go%E7%9A%84reactor%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6gnet%E4%BB%8B%E7%BB%8D/"},{"content":"编译过程 词法分析(Lexical Analysis) 语法分析(Syntax Analysis) 可参考网站: https://astexplorer.net/ 语义分析(Semantic Analysis) 在抽象语法树 AST 上做类型检查 中间代码(SS","lvl0":"Go代码的编译与反编译","lvl1":["Go"],"lvl2":"摘要","objectID":"ca36ecf1befa5936ff7a0952180f265a","tags":["Go"],"url":"/post/go%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%8D%E7%BC%96%E8%AF%91/"},{"content":"Go和IO Go 是一种高性能的编译性语言，天然支持高并发，语言级别封装协程，号称可以支持成千上万，十万，甚至百万的协程并发。这个量级远不是线程可","lvl0":"Go的IO库介绍","lvl1":["Go"],"lvl2":"摘要","objectID":"63069944ab1fad38e83485a8a57e643d","tags":["Go"],"url":"/post/go%E7%9A%84io%E5%BA%93%E4%BB%8B%E7%BB%8D/"},{"content":"流量染色 服务规模越来越大，增加速度越来越快，需求指数性增加，大家都需要一个环境。比如一个集群一千个容器，如果三个小组各开发一个项目，想并行开","lvl0":"全链路灰度方案设计","lvl1":["架构"],"lvl2":"摘要","objectID":"3b955dab819b93e69129b1fdd5954472","tags":["架构"],"url":"/post/%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"},{"content":"前言 在阿里淘宝 双 11 的过程中，长期以来都是在生产环节做全链路压测的，通过实践我们发现在生产环境中做压测，实际上会和一个 IT 组织的结构、成熟度、流","lvl0":"全链路压测方案设计","lvl1":["架构"],"lvl2":"摘要","objectID":"5a0f2041f70a0346095a1ac401c76725","tags":["架构"],"url":"/post/%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"},{"content":"前言 对于了解一门语言来说，会关心我们在函数调用的时候，参数到底是传的值，还是引用？ 其实对于传值和传引用，是一个比较古老的话题，做研发的都有这","lvl0":"Go参数传递是传值还是传引用","lvl1":["Go"],"lvl2":"摘要","objectID":"f81d38a45422cdc53f77c5d3f75294e6","tags":["Go"],"url":"/post/go%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%98%AF%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E4%BC%A0%E5%BC%95%E7%94%A8/"},{"content":"无限缓存的channel拥有下面的特性： 不会阻塞write。 它总是能处理write的数据，或者放入到待读取的channel中，或者放入到缓存","lvl0":"Go如何实现无限缓存的channel","lvl1":["Go"],"lvl2":"摘要","objectID":"a1d36e6eee4362f86de372901a935bfe","tags":["Go"],"url":"/post/go%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E7%BC%93%E5%AD%98%E7%9A%84channel/"},{"content":"协议限制 文档 RFC7504 明确指出Header的定义： 1 2 3 4 5 6 7 8 9 10 11 12 8.1.2. HTTP Header Fields HTTP header fields carry information as a series of key-value pairs. For a listing of registered HTTP headers, see the \u0026#34;Message Header Field\u0026#34; registry maintained at \u0026lt;https://www.iana.org/assignments/ message-headers\u0026gt;. Just as in HTTP/1.x, header","lvl0":"HTTP协议的header的大小写问题","lvl1":["HTTP"],"lvl2":"摘要","objectID":"2a7d896ef0197025f6f62282a20035a3","tags":["HTTP"],"url":"/post/http%E5%8D%8F%E8%AE%AE%E4%B8%ADheader%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98/"},{"content":"如何在函数内部修改一个指针（参数或接收者）指向，使其值的改变能反映在函数外部？ 直接上代码，这样可以么？ 1 2 3 4 5 6 7 8 9 type ArgType struct { A string b int } func","lvl0":"Go如何在函数内修改指针指向","lvl1":["Go"],"lvl2":"摘要","objectID":"337da8a0b9eb77f428bf86fd8883f1e8","tags":["Go"],"url":"/post/go%E5%A6%82%E4%BD%95%E5%9C%A8%E5%87%BD%E6%95%B0%E5%86%85%E4%BF%AE%E6%94%B9%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91/"},{"content":"什么是 zerolog zerolog 包提供了一个专门用于 JSON 输出的简单快速的 Logger。 zerolog 的 API 旨在为开发者提供出色的体验和令人惊叹的性能。其独特的链式 API 允许通过避免内","lvl0":"zerolog源码剖析","lvl1":["Go"],"lvl2":"摘要","objectID":"f6371b0c4e41886510c782b2e486c6bf","tags":["Go"],"url":"/post/zerolog%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"前言 虽然 golang 没有内置的 queue，但它还是提供了很多强大的数据结构，那有没有可以直接拿过来当 queue 来使的呢？有的，且至少有两个选项。强调一句，我们","lvl0":"Go如何实现栈和队列","lvl1":["Go"],"lvl2":"摘要","objectID":"72ff0a578874d0a5df2f23b1e5abbb08","tags":["Go"],"url":"/post/go%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"content":"什么是embed 在Golang 1.16版本中，新增了一个大家期待已久的特性//go:embed,它的作用就是可以在Go语言应用程序中包含任何","lvl0":"Go的embed介绍","lvl1":["Go"],"lvl2":"摘要","objectID":"686e6da7710305fcabb07555285da038","tags":["embed"],"url":"/post/go%E7%9A%84embed%E4%BB%8B%E7%BB%8D/"},{"content":"函数式编程 函数式编程是很多语言正在支持或已经支持的日渐流行的编程范式。Go 已经支持了其中一部分的特性，比如头等函数和更高阶功能的支持，使函数","lvl0":"Go的函数式编程","lvl1":["Go"],"lvl2":"摘要","objectID":"dada3fd8765abcb0efe41d8a93717262","tags":["Go"],"url":"/post/go%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"content":"简介 处理大量并发是 Go 语言的一大优势。语言内置了方便的并发语法，可以非常方便的创建很多个轻量级的 goroutine 并发处理任务。相比于创建多个线程，gorou","lvl0":"Go协程池ants介绍","lvl1":["Go"],"lvl2":"摘要","objectID":"692850e574bd415442b3d024fdf0e3b8","tags":["Go"],"url":"/post/go%E5%8D%8F%E7%A8%8B%E6%B1%A0ants%E4%BB%8B%E7%BB%8D/"},{"content":"前言 本节会介绍 Go 语言的哈希的实现原理，哈希是除了数组之外，最常见的数据结构。几乎所有的语言都会有数组和哈希表两种集合元素，有的语言将数组实现","lvl0":"基本数据结构map源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"463760258f257c14413c048f42f94059","tags":["Go源码"],"url":"/post/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84map%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"array 数组和切片是 Go 语言中常见的数据结构，很多刚刚使用 Go 的开发者往往会混淆这两个概念。数组作为最常见的集合在编程语言中是非常重要的，除了数组之外","lvl0":"基本数据结构array,slice,string源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"e32f7ae2c904f226af1c7e42aa3fb3b0","tags":["Go源码"],"url":"/post/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84arrayslicestring%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"前言 函数是 Go 语言的一等公民，掌握和理解函数的调用过程是我们深入学习 Go 无法跳过的，本节将从函数的调用惯例和参数传递方法两个方面分别介绍函数的执","lvl0":"函数调用源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"d3a803329e94590c02914397c81daee7","tags":["Go源码"],"url":"/post/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"interface Go 语言中的接口是一组方法的签名，它是 Go 语言的重要组成部分。使用接口能够让我们写出易于测试的代码，然而很多工程师对 Go 的接口了解都非常有限，也","lvl0":"interface和reflect源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"fcf80d55d4ef3a16f74c667a01b0d679","tags":["Go源码"],"url":"/post/interface%E5%92%8Creflect%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"前言 本节将分析 Go 语言中两个经常成对出现的两个关键字 — panic 和 recover。这两个关键字与上一节提到的 defer 有紧密的联系，它们都是 Go 语言中的内置函数","lvl0":"基本原语panic和recover源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"d1f6d1c657b62b387b8f797cc59b45e7","tags":["Go源码"],"url":"/post/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E8%AF%ADpanic%E5%92%8Crecover%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"前言 很多现代的编程语言中都有 defer 关键字，Go 语言的 defer 会在当前函数返回前执行传入的函数，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源","lvl0":"基本原语defer源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"bf2d9bf533a5c741e921fd9d31ded83d","tags":["Go源码"],"url":"/post/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E8%AF%ADdefer%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"前言 当我们想要在 Go 语言中初始化一个结构时，可能会用到两个不同的关键字 — make 和 new。因为它们的功能相似，所以初学者可能会对这两个关键字的作用感","lvl0":"基本原语make和new源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"deab917ef7eff37e0a246c9cfc7ce355","tags":["Go源码"],"url":"/post/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E8%AF%ADmake%E5%92%8Cnew%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"前言 作为公司代码委员会 golang 分会的理事，我 review 了很多代码，看了很多别人的 review 评论。发现不少同学 code review 与写出好代码的水平有待提高。在这里，想分享一下我的","lvl0":"如何做CodeReview","lvl1":["Go规范"],"lvl2":"摘要","objectID":"22a324c0dac675cfa2bb59ebf1fc683b","tags":["Go规范"],"url":"/post/%E5%A6%82%E4%BD%95%E5%81%9Acodereview/"},{"content":"Code review 在座的各位有谁把 code review 作为日常工作的一部分？【整个房间举起了手，鼓舞人心】。好的，为什么要进行 code review ？【有人高呼“阻止不良代码”】 如果代码审","lvl0":"Go语言面向对象设计","lvl1":["Go规范"],"lvl2":"摘要","objectID":"87094565cf329deb04c9361cc0a8d814","tags":["Go规范"],"url":"/post/go%E8%AF%AD%E8%A8%80%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/"},{"content":"反射 Reflection（反射）是新实现的旗舰特性。与 reflect 包提供 Go 类型和值的视图相似，protoreflect 包根据 protocol buffer 类型系统提供值的视图。","lvl0":"Protobuf如何使用动态反射","lvl1":["protobuf"],"lvl2":"摘要","objectID":"eef88dcc28410d86f2823635dea4b74e","tags":["protobuf"],"url":"/post/protobuf%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%8F%8D%E5%B0%84/"},{"content":"前言 Protocol Buffers（protobuf）是Google推出的高效，静态类型，语言无关的数据序列化格式。我们在Envoy代理中使用protob","lvl0":"Protobuf如何传递动态参数","lvl1":["protobuf"],"lvl2":"摘要","objectID":"728a459a62d4a33b1e24a4ba4d84074b","tags":["protobuf"],"url":"/post/protobuf%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0/"},{"content":"汇编 循环是所有编程语言都有的控制结构，除了使用经典的三段式循环之外，Go 语言还引入了另一个关键字 range 帮助我们快速遍历数组、切片、哈希表以及 Channel 等","lvl0":"基本原语for和range源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"b1dc40b1598d7478b8395273d0edabd5","tags":["Go源码"],"url":"/post/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E8%AF%ADfor%E5%92%8Crange%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"初衷 今天要聊的库就是 github.com/huandu/go-assert，是我在几年前突发奇想实现的库。当时有一个「痒点」：写 Go 测试用例的","lvl0":"go-assert库介绍","lvl1":["Go"],"lvl2":"摘要","objectID":"d6f670a0ef0fe1ed19dde1e201840e44","tags":["Go"],"url":"/post/go-assert%E5%BA%93%E4%BB%8B%E7%BB%8D/"},{"content":"背景 这个库是 github.com/huandu/go-clone，主要用途是对任意的 Go 结构进行深拷贝，创造一个内容完全相同的副本，得到的值可","lvl0":"Go的深拷贝库:go-clone","lvl1":["Go"],"lvl2":"摘要","objectID":"05eb171527117929c7c15a03b20eb43e","tags":["Go"],"url":"/post/go%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%BA%93go-clone/"},{"content":"Go 项目做的比较大(主要说代码多，参与人多)之后，可能会遇到类似下面这样的问题： 程序老是半夜崩，崩了以后就重启了，我也醒不来，现场早就丢了，不","lvl0":"无人值守的自动dump","lvl1":["Go"],"lvl2":"摘要","objectID":"df51c72380c26f56da0efaf572e2b10c","tags":["Go"],"url":"/post/%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E7%9A%84%E8%87%AA%E5%8A%A8dump/"},{"content":"前言 前段时间，某同学说某服务的容器因为超出内存限制，不断地重启，问我们是不是有内存泄露，赶紧排查，然后解决掉，省的出问题。我们大为震惊，赶紧","lvl0":"Go应用为什么VSZ占用过高","lvl1":["Go"],"lvl2":"摘要","objectID":"b70217ad718244967d912d2c5df14456","tags":["Go"],"url":"/post/go%E5%BA%94%E7%94%A8%E4%B8%BA%E4%BB%80%E4%B9%88vsz%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98/"},{"content":"前言 最近我在回顾思考（写 PPT），整理了现状，发现了这个问题存在多时，经过一番波折，最终确定了元凶和相对可行的解决方案，因此也在这里分享一下","lvl0":"为什么容器内存占用居高不下，频频 OOM","lvl1":["k8s"],"lvl2":"摘要","objectID":"3a24d05b5e4b8e21e003f9491c46393d","tags":["k8s"],"url":"/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%B9%E5%99%A8%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%B1%85%E9%AB%98%E4%B8%8D%E4%B8%8B%E9%A2%91%E9%A2%91-oom/"},{"content":"Kubernetes中日志重要性 通常日志最基础的作用是记录程序的运行轨迹，在此之上会衍生出非常多的功能，例如线上监控、告警、运营分析、安全分","lvl0":"K8s的日志采集实践","lvl1":["k8s"],"lvl2":"摘要","objectID":"47e3a7dda2ea92a397ce99cb2c0256bd","tags":["k8s"],"url":"/post/k8s%E7%9A%84%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%AE%9E%E8%B7%B5/"},{"content":"zstd Zstandard是一种实时压缩算法，提供高压缩率。它提供了非常广泛的压缩/速度权衡，同时由非常快速的解码器提供支持。实现了高性能压缩算法","lvl0":"Go如何使用zstd压缩算法","lvl1":["Go"],"lvl2":"摘要","objectID":"69a37c07e270d2fb2e06eb382b742e34","tags":["Go","zstd"],"url":"/post/go%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8zstd%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"},{"content":"我有一个Deployment使用Downward API公开 POD ID的对象。这很好用。但是，我想设置另一个环境变量，日志路径，参考 POD ID。但是，","lvl0":"K8s如何在环境变量中引用其他环境变量","lvl1":["k8s"],"lvl2":"摘要","objectID":"d95db89cad908e7712b390d00f44947f","tags":["k8s"],"url":"/post/k8s%E5%A6%82%E4%BD%95%E5%9C%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%AD%E5%BC%95%E7%94%A8%E5%85%B6%E4%BB%96%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"content":"创建软链接 ln -s [源文件或目录] [目标文件或目录] 例如： 当前路径创建test 引向/var/www/test 文件夹 ln –s /var/www/test test 创建/var/tes","lvl0":"Linux的ln命令介绍","lvl1":["Linux"],"lvl2":"摘要","objectID":"10a3eca589847f8848c18da4a384b102","tags":["Linux"],"url":"/post/linux%E7%9A%84%E9%93%BE%E6%8E%A5%E5%8A%9F%E8%83%BD/"},{"content":"首先来说说SHA1加密 SHA-1（英语：Secure Hash Algorithm 1，中文名：安全散列算法1）是一种密码散列函数，美国国家安全局设计，并由美国国家标准","lvl0":"Go中如何实现hmac算法","lvl1":["Go"],"lvl2":"摘要","objectID":"49fb22a45bf306315e76f60081b22437","tags":["Go"],"url":"/post/go%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0hmac%E7%AE%97%E6%B3%95/"},{"content":"我有一个使用字符串作为键和值的映射。我有一个key数组，用于指定map的顺序。 我想将该映射序列化为JSON，但要保持数组上定义的顺序。 我想将","lvl0":"使用特定顺序输出map的json编码","lvl1":["Go"],"lvl2":"摘要","objectID":"a584231453460beca2a7711dad7ff85e","tags":["Go"],"url":"/post/%E4%BD%BF%E7%94%A8%E7%89%B9%E5%AE%9A%E9%A1%BA%E5%BA%8F%E8%BE%93%E5%87%BAmap%E7%9A%84json%E7%BC%96%E7%A0%81/"},{"content":"对称加密算法 对称加密算法 是应用较早的加密算法，又称为 共享密钥加密算法。在 对称加密算法 中，使用的密钥只有一个，发送 和 接收 双方都使用这个密钥对数","lvl0":"常用加密签名算法介绍","lvl1":["算法"],"lvl2":"摘要","objectID":"29a46b37367822f91903c21ec5b27757","tags":["算法"],"url":"/post/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/"},{"content":"1 通用类 I. 代码实现 1.1 内存管理 1.2 文件操作 1.3 系统接口 1.4 通信安全 1.5 敏感数据保护 1.6 加密解密 1.7 正则表达式 2 后台类 I. 代码实现 1.1 输入校验 1.2 SQL操作 1.3 网络","lvl0":"腾讯Go安全指南","lvl1":["Go"],"lvl2":"摘要","objectID":"07006496c1a932cfff21a45b40829a40","tags":["Go"],"url":"/post/%E8%85%BE%E8%AE%AFgo%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97/"},{"content":"前言 由计算机网络系统组成的分布式系统，若想协调一致进行：IT行业的“整点开拍”、“秒杀”、“Leader选举”，通信行业的“同步组网”之类业","lvl0":"计算机网络时间同步技术原理介绍","lvl1":["算法"],"lvl2":"摘要","objectID":"228ac2768b22896970b47564138c4b4e","tags":["算法"],"url":"/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/"},{"content":"前言 随着Internet网的广泛应用，信息安全问题日益突出，系统间的接口交互，每个请求都有可能被抓取到数据、被伪造请求去获取数据或者攻击服务","lvl0":"API接口安全设计方案","lvl1":["架构"],"lvl2":"摘要","objectID":"1ed0d853b19fa5c4d853efe1797d201e","tags":["架构"],"url":"/post/api%E6%8E%A5%E5%8F%A3%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/"},{"content":"CyclicBarrier允许一组 goroutine 彼此等待，到达一个共同的执行点。同时，因为它可以被重复使用，所以叫循环栅栏。具体的机制是，大家都在栅栏前","lvl0":"扩展并发原语CyclicBarrier源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"d53e5899a9d3d744061334f408be56e8","tags":["Go源码"],"url":"/post/%E6%89%A9%E5%B1%95%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcyclicbarrier%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"SingleFlight SingleFlight 是 Go 开发组提供的一个扩展并发原语。它的作用是,在处理多个 goroutine 同时调用同一个函数的时候,只让一个 goroutine 去调用这个函数,等到这个 goroutine 返回结果的时候,","lvl0":"扩展并发原语SingleFlight源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"6d2ec7cfb5d5346b6615f7e9752b4135","tags":["Go源码"],"url":"/post/%E6%89%A9%E5%B1%95%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADsingleflight%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"信号量 信号量的概念是荷兰计算机科学家 Edsger Dijkstra 在 1963 年左右提出来的,广泛应用在不同的操作系统中。在系统中,会给每一个进程一个信号量,代表每个进程目前","lvl0":"扩展并发原语Semaphore源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"0154e3f13612f7af83fff872c903a583","tags":["Go源码"],"url":"/post/%E6%89%A9%E5%B1%95%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADsemaphore%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"前言 Go 官方文档里专门介绍了 Go 的 内存模型,你不要误解这里的内存模型的含义,它并不是指 Go 对象的内存分配、内存回收和内存整理的规范,它描述的是并发","lvl0":"Go中的happens-before","lvl1":["Go"],"lvl2":"摘要","objectID":"8f780eeecbc7a01cf29ee85bd39f03b3","tags":["Go"],"url":"/post/go%E4%B8%AD%E7%9A%84happens-before/"},{"content":"前言 Delve 是一个 go 语言的第三方调试器，github 地址是： https://github.com/go-delve/delve 。 Delve 是 GDB 调试器的有效替代品。与 GDB 相比，它能更高的理解 Go 的运行时，数据结构以及表达式。","lvl0":"使用Delve工具调试Go程序","lvl1":["Go"],"lvl2":"摘要","objectID":"ef99930e7ce1471fdce33e5197d2880a","tags":["Delve"],"url":"/post/%E4%BD%BF%E7%94%A8delve%E5%B7%A5%E5%85%B7%E8%B0%83%E8%AF%95go%E7%A8%8B%E5%BA%8F/"},{"content":"Why Redis \u0026amp;\u0026amp; Lua 分布式限流本质上是一个集群并发问题，Redis + Lua 的方案非常适合此场景： Redis 单线程特性，适合解决分布式集群的并发问题 Redis 本身支持 Lua 脚本执","lvl0":"如何用Go实现分布式限流","lvl1":["Go"],"lvl2":"摘要","objectID":"6827bae5cc2f534ccd4e8e4efe8f1474","tags":["Go"],"url":"/post/%E5%A6%82%E4%BD%95%E7%94%A8go%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81/"},{"content":"应用场景 Channel 的应用场景分为五种类型。 数据交流: 当作并发的 buffer 或者 queue,解决生产者 - 消费者问题。多个 goroutine 可以并发当作生产者(Producer)","lvl0":"Channel使用实践","lvl1":["Go"],"lvl2":"摘要","objectID":"d828c9483617fbf2f177f1f5e3ddd09b","tags":["Go"],"url":"/post/channel%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/"},{"content":"atomic 原理 在现在的系统中,write 的地址基本上都是对齐的(aligned)。 比如,32 位的操作系统、CPU 以及编译器,write 的地址总是 4 的","lvl0":"并发原语atomic源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"b36e397904c5d4db53800aeeb5089878","tags":["Go源码"],"url":"/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADatomic%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"Context 上下文 context.Context Go 语言中用来设置截止日期、同步信号，传递请求相关值的结构体。上下文与 Goroutine 有比较密切的关系，是 Go 语言中独特的设计，在其他编程语言中我们","lvl0":"并发原语context源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"47aa7c5307bcdc21a9761bf5e80a7142","tags":["Go源码"],"url":"/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcontext%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"前言\u0008 sync.Pool 数据类型用来保存一组可独立访问的临时对象。请注意这里的“临时”这两个字,它说明了 sync.Pool 这个数据类型的特点,也就是说,它池化的对象会在未来","lvl0":"并发原语Sync-Pool源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"572eddd3a7fa821cd6b684e066239749","tags":["Go源码"],"url":"/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADsync-pool%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"Map Go 内建的 map 类型不是线程安全的,所以 Go 1.9 中增加了一个线程安全的 map,也就是 sync.Map。但是,我们一定要记住,这个 sync.Map 并不是用来替换内建","lvl0":"并发原语Sync-Map源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"64f868b3af982dd6275035db1d29f22e","tags":["Go源码"],"url":"/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADsync-map%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"Once 很多人认为实现一个 Once 一样的并发原语很简单,只需使用一个 flag 标记是否初始化过即可,最多是用 atomic 原子操作这个 flag,但是,这个实现有一个很大的问","lvl0":"并发原语sync-Once源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"d97be82dcf3a917f368fb74439487935","tags":["Go源码"],"url":"/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADsync-once%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"Cond 标准库中的 Cond 并发原语初始化的时候,需要关联一个 Locker 接口的实例,一般我们使用 Mutex 或者 RWMutex。 首先,Cond 关联的 Locker 实例可以通过 c.L 访问,它","lvl0":"并发原语Cond源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"9e4b6f188c1bef64a296f8507692ba3b","tags":["Go源码"],"url":"/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcond%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"WaitGroup sync.WaitGroup 可以达到并发 Goroutine 的执行屏障的效果，等待多个 Goroutine 执行完毕。 sync.WaitGroup 结构体中只包含两个成员变量： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27","lvl0":"并发原语WatiGroup源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"eb6f15985aecb115744e6efcdfa3f7ab","tags":["Go源码"],"url":"/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwatigroup%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"Mutex Go 语言的 sync.Mutex 由两个字段 state 和 sema 组成。其中 state 表示当前互斥锁的状态，而 sema 是用于控制锁状态的信号量。 1 2 3 4 type Mutex struct { state int32 sema uint32 } 状态 互斥锁的状态比较复","lvl0":"并发原语sync-Mutex和sync-RWMutex源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"3d1f5a86435d06d32fbf047c81fb1aa3","tags":["Go源码"],"url":"/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADsync-mutex%E5%92%8Csync-rwmutex%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"安装 1 go get -u go.uber.org/atomic@v1 旧版导入路径 从v1.5.0开始，导入路径go.uber.org/atomic是使用此软件包的唯一受支持的方式。如果您使用的是G","lvl0":"比atomic更方便的库:uber Atomic","lvl1":["Go"],"lvl2":"摘要","objectID":"7a491025d3e9f6675b198cfe056f5781","tags":["Go"],"url":"/post/%E6%AF%94atomic%E6%9B%B4%E6%96%B9%E4%BE%BF%E7%9A%84%E5%BA%93uber-atomic/"},{"content":"前言 队列(queue)是非常常用的一个数据结构，它只允许在表的前端（head）进行出队(dequeue)操作，而在表的后端（tail）进行入","lvl0":"如何用Go完成无锁队列","lvl1":["Go"],"lvl2":"摘要","objectID":"187c8391994c99c9bbb963b254d79a7e","tags":["Go"],"url":"/post/%E5%A6%82%E4%BD%95%E7%94%A8go%E5%AE%8C%E6%88%90%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/"},{"content":"sync.Pool的坑 内存泄漏 取出来的 bytes.Buffer 在使用的时候，我们可以往这个元素中增加大量的 byte 数据，这会导致底层的 byte slice 的容量可能会变得很大。这个时候","lvl0":"字节缓冲池:bytebufferpool","lvl1":["Go"],"lvl2":"摘要","objectID":"5781f9c35dc1debf1e55e109874e476a","tags":["bytebufferpool"],"url":"/post/%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B1%A0bytebufferpool/"},{"content":"如何使用 context context 使用起来非常方便。源码里对外提供了一个创建根节点 context 的函数： 1 func Background() Context background 是一个空的 context， 它不能被取消，没有值，也没有超时时","lvl0":"context使用实践","lvl1":["Go"],"lvl2":"摘要","objectID":"54c11300dd2a5866525777cb4768f025","tags":["Go"],"url":"/post/context%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/"},{"content":"介绍 程序包backoff实现了用于重试操作的backoff算法。 使用重试功能可重试可能失败的操作。如果重试不满足您的需求，请将功能复制/粘贴","lvl0":"Go实现backoff算法","lvl1":["Go"],"lvl2":"摘要","objectID":"22426de6f49c41d5c04618d533040244","tags":["backoff"],"url":"/post/go%E5%AE%9E%E7%8E%B0backoff%E7%AE%97%E6%B3%95/"},{"content":"故障时有发生 每当一个服务或系统调用另一个服务或系统时，都可能会发生故障。造成故障的因素可能多种多样。它们包括服务器、网络、负载均衡器、软件、","lvl0":"超时、重试和抖动回退","lvl1":["架构"],"lvl2":"摘要","objectID":"3208583022b2c83ca546e4a79f2bf137","tags":["架构"],"url":"/post/%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95%E5%92%8C%E6%8A%96%E5%8A%A8%E5%9B%9E%E9%80%80/"},{"content":"当我们连接到一个失败的后端时，通常希望不要立即重试(以避免泛滥的网络或服务器的请求)，而是做某种形式的指数backoff。 我们有几个参数： INITIAL_BACKOFF","lvl0":"GRPC的重试机制","lvl1":["GRPC"],"lvl2":"摘要","objectID":"4f135d850e30d6c04f5a9286876b3ab1","tags":["GRPC"],"url":"/post/grpc%E7%9A%84%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/"},{"content":"源码分析 我们发现，不仅是 Go gRPC 服务之间超时可以传递（如果你拿到上游的 ctx 继续往下透传的话）。Go 和 Java 服务之间，超时也会随着调用链传递。那么 gRPC 的超","lvl0":"GRPC的超时机制","lvl1":["GRPC"],"lvl2":"摘要","objectID":"3d426552340c355ec21448fe8e8eed06","tags":["GRPC"],"url":"/post/grpc%E7%9A%84%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6/"},{"content":"指数退避算法是适用于网络应用的标准错误处理策略，使用这种策略时，客户端会定期重试失败的请求，并不断增加各次请求之间的延迟时间。客户端应对发送","lvl0":"backoff指数退避算法","lvl1":["算法"],"lvl2":"摘要","objectID":"8e306cc11eff23a9698e343ead8bf159","tags":["backoff"],"url":"/post/backoff%E6%8C%87%E6%95%B0%E9%80%80%E9%81%BF%E7%AE%97%E6%B3%95/"},{"content":"对于许多 golang 开发者来说，考虑到性能，最佳实践是系统地使用指针而非结构体副本。 我们将回顾两个用例，来理解使用指针而非结构体副本的影响。 数据分配密","lvl0":"我应该用指针替代结构体的副本吗","lvl1":["Go"],"lvl2":"摘要","objectID":"abe3cd12d039b42304a5bd16d33b62e9","tags":["Go"],"url":"/post/%E6%88%91%E5%BA%94%E8%AF%A5%E7%94%A8%E6%8C%87%E9%92%88%E6%9B%BF%E4%BB%A3%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%89%AF%E6%9C%AC%E5%90%97/"},{"content":"CPU Affinity 熟系 Linux 后台开发的朋友都知道 CPU 亲和性（CPU Affinity）。CPU Affinity 是一种调度属性，它可以将单个进程绑定到一个或一组 CPU 上。 在 SMP（S","lvl0":"容器环境的GOMAXPROCS","lvl1":["k8s"],"lvl2":"摘要","objectID":"d2df009a043985f9176a97de5a447948","tags":["k8s"],"url":"/post/%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84gomaxprocs/"},{"content":"介绍 Health checks用于探测服务器是否能够处理rpc请求。客户端到服务器的运行状况检查可以通过点对点或某些控制系统进行。服务器可能未准备好接受","lvl0":"GRPC的健康检查","lvl1":["GRPC"],"lvl2":"摘要","objectID":"1c986112d68f41db4ead76f966678470","tags":["GRPC"],"url":"/post/grpc%E7%9A%84%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/"},{"content":"快速使用 先安装： 1 go get github.com/spf13/cast 后使用： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/cast\u0026#34; ) func main() { // ToString fmt.Println(cast.ToString(\u0026#34;leedarjun\u0026#34;)) // leedarjun fmt.Println(cast.ToString(8)) // 8 fmt.Println(cast.ToString(8.31)) // 8.31 fmt.Println(cast.ToString([]byte(\u0026#34;one time\u0026#34;))) //","lvl0":"Go的类型转换库cast","lvl1":["Go"],"lvl2":"摘要","objectID":"b4fcbfa04cc9d61648603cbd6cc59de4","tags":["cast","Go"],"url":"/post/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%BA%93cast/"},{"content":"简介 mapstructure用于将通用的map[string]interface{}解码到对应的 Go 结构体中，或者执行相反的操作。很多时候，解","lvl0":"Go的map转struct库mapstructure","lvl1":["mapstructure"],"lvl2":"摘要","objectID":"cb80d2fc475616dc51796f5c98d59c94","tags":["mapstructure"],"url":"/post/go%E7%9A%84map%E8%BD%ACstruct%E5%BA%93mapstructure/"},{"content":"背景 最近在做一个 web 版的展示大屏，前端靠 HTTP(S)+JSON 和后端交互，部分图形是密集的地理点位和时间序列，HTTP 返回数据量较大，公网上加载速度不佳。 调研 考虑","lvl0":"Gin的gzip中间件nanmu42-gzip","lvl1":["Gin"],"lvl2":"摘要","objectID":"c9a4fb9fa4eae2af028b97ebdb723ee8","tags":["gzip","Gin"],"url":"/post/gin%E7%9A%84gzip%E4%B8%AD%E9%97%B4%E4%BB%B6nanmu42-gzip/"},{"content":"前言 我们知道一般无论是 CDN 还是 服务端的接口(nginx 配置gzip以优化站点资源加载速度)，在响应返回的时候，都会配置 gzip 来压缩响应数据，以达到","lvl0":"Go在http开启gzip","lvl1":["Go"],"lvl2":"摘要","objectID":"d891eeb6edd5ba60bef419ef6e6bfd96","tags":["gzip","Go"],"url":"/post/go%E5%9C%A8http%E5%BC%80%E5%90%AFgzip/"},{"content":"Content-Encoding \u0026amp; Accept-Encoding Accept-Encoding 和 Content-Encoding 是 HTTP 中用来对「采用何种编码格式传输正文」进行协定的一对头部字段。它的工作原理是这样：浏览器发送请求时，通过 Accept-Encoding 带上自己支持的内容编","lvl0":"HTTP协议中的Content-Encoding","lvl1":["HTTP"],"lvl2":"摘要","objectID":"26124821e672b6b14728d1f7aca02be8","tags":["HTTP"],"url":"/post/http%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84content-encoding/"},{"content":"背景 通常而言，服务发布平台的构建部署的流程（镜像部署除外）会经过构建（同步代码 -\u0026gt; 编译 -\u0026gt; 打包 -\u0026gt; 上传）、部署（下载包 -\u0026gt; 解压到目标机器 -\u0026gt; 重启服务）","lvl0":"压缩算法在构建部署的优化","lvl1":[],"lvl2":"摘要","objectID":"b1405e512651807a27dc21357f0fcb45","tags":[""],"url":"/post/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E5%9C%A8%E6%9E%84%E5%BB%BA%E9%83%A8%E7%BD%B2%E7%9A%84%E4%BC%98%E5%8C%96/"},{"content":"介绍 我们称 Zstandard 或 Zstd 是一种快速的无损压缩算法，是针对 zlib 级别的实时压缩方案，以及更好的压缩比。它由一个非常快的熵阶段，由 Huff0 和 FSE 库提供。这个项目是作","lvl0":"Zstd压缩算法介绍","lvl1":["zstd"],"lvl2":"摘要","objectID":"0fce23b3fdb6c003cd7e2ce8f8b3cd9b","tags":["zstd"],"url":"/post/zstd%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/"},{"content":"DEFLATE \u0026amp; INFLATE 当你键入 tar -zcf src.tar.gz src, 就可以将 src 下的所有文件打包成一个 tar.gz 格式的压缩包. 这里的 \u0026ldquo;tar\u0026rdquo; 是归档格式, 将多个文件组合成一个文件; 而 \u0026ldquo;gz\u0026rdquo; 指的就是 gzip 压缩格式,","lvl0":"DEFLATE压缩算法原理","lvl1":["DEFLATE"],"lvl2":"摘要","objectID":"087dcfaef327ca3e72f20386f4a04d20","tags":["DEFLATE"],"url":"/post/deflate%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"},{"content":"前言 无论使用何种编程语言，json格式的数据已被广泛应用，不论是数据的传输还是存储，在很多应用场景下，你可能想进一步地压缩JSON字符串的长","lvl0":"常用的JSON压缩算法","lvl1":["算法"],"lvl2":"摘要","objectID":"1f09f21d40cfe8d28571132b1ad45018","tags":["JSON"],"url":"/post/%E5%B8%B8%E7%94%A8%E7%9A%84json%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"},{"content":"序列化与反序列化 有些时候，我们希望给数据结构或对象拍个“快照”，或者保存成文件，或者传输给其他应用程序。比如，在神经网络训练过程中，我们会将","lvl0":"Protobuf编解码原理","lvl1":["protobuf"],"lvl2":"摘要","objectID":"aad2716da09c9709b3231f7f82a178fb","tags":["protobuf"],"url":"/post/protobuf%E7%BC%96%E8%A7%A3%E7%A0%81%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/"},{"content":"背景 Protobuf 是目前非常主流的二进制序列化格式，GRPC 默认使用 Protobuf v3 格式，下面是 Protobuf 消息定义的例子： 1 2 3 4 5 6 7 8 9 10 11 # proto2message Account { required string name = 1; # 必需 optional double","lvl0":"区分Protobuf中缺失值和默认值","lvl1":["protobuf"],"lvl2":"摘要","objectID":"b94f13a1b96330082146bae06896bc87","tags":["protobuf"],"url":"/post/%E5%8C%BA%E5%88%86protobuf%E4%B8%AD%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%92%8C%E9%BB%98%E8%AE%A4%E5%80%BC/"},{"content":"概述 软件包fieldmaskpb包含google / protobuf / field_mask.proto的生成类型。 FieldMask消息表示一组符号字段路径","lvl0":"Protobuf的FieldMaskPb","lvl1":["protobuf"],"lvl2":"摘要","objectID":"0b6cb6719117ca254cf8f2e72f2e3488","tags":["protobuf"],"url":"/post/protobuf%E7%9A%84fieldmaskpb/"},{"content":"Any Any 包含任意序列化的消息以及描述序列化消息类型的URL。 JSON格式 Any值的JSON表示使用反序列化的嵌入式消息的常规表示，并带有一个@t","lvl0":"Proto常见第三方类型介绍","lvl1":["protobuf"],"lvl2":"摘要","objectID":"5402721830bf96754cfdbbcd2c403b6f","tags":["protobuf"],"url":"/post/proto%E5%B8%B8%E8%A7%81%E7%AC%AC%E4%B8%89%E6%96%B9%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/"},{"content":"本页确切描述了protocol buffer编译器为任何给定的协议定义生成的Go代码。突出显示了proto2和proto3生成的代码之间的任何","lvl0":"proto生成Go代码指南","lvl1":["protobuf"],"lvl2":"摘要","objectID":"147e732d16c7e9018f60bf82db818c13","tags":["protobuf"],"url":"/post/proto%E7%94%9F%E6%88%90go%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97/"},{"content":"语言指南 定义消息类型 先来看一个非常简单的例子。假设你想定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、你感兴趣的查询结果所在的","lvl0":"Proto3语言指南","lvl1":["protobuf"],"lvl2":"摘要","objectID":"000ed5e866d39195483f6d97ad3caace","tags":["protobuf"],"url":"/post/proto3%E8%AF%AD%E8%A8%80%E6%8C%87%E5%8D%97/"},{"content":"otel func GetTextMapPropagator 1 func GetTextMapPropagator() propagation.TextMapPropagator GetTextMapPropagator返回全局TextMapPropagator。如果未设置任何内容，则返回No-Op Tex","lvl0":"opentelemetry使用介绍","lvl1":["opentelemetry"],"lvl2":"摘要","objectID":"af6ce782d5af87a138fa20009e375792","tags":["opentelemetry"],"url":"/post/opentelemetry%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"},{"content":"前言 如果我们在使用网络系统，那么可能会非常关心延迟问题。在面对一组服务器时，我们需要思考选择哪种负载均衡算法。如果可以直观了解不同负载均衡器","lvl0":"常见负载均衡算法的比较","lvl1":["算法"],"lvl2":"摘要","objectID":"26d58743f8495c38c049dd71dd375ea0","tags":["负载均衡"],"url":"/post/%E5%B8%B8%E8%A7%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/"},{"content":"如果我们在使用网络系统，那么可能会非常关心延迟问题。在面对一组服务器时，我们需要思考选择哪种负载均衡算法。如果可以直观了解不同负载均衡器配置","lvl0":"几种常见负载均衡算法的性能比较","lvl1":["算法"],"lvl2":"摘要","objectID":"3ef9330677c9dab40448503085c9b0e3","tags":["算法"],"url":"/post/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"},{"content":"概述 Package errors 提供了简单的错误处理原语。 Go中的传统错误处理习惯用法大致类似于 1 2 3 if err != nil { return err } 当将其递归应用于调用堆栈时，将导致错误报告，而","lvl0":"pkg-errors使用介绍","lvl1":["Go"],"lvl2":"摘要","objectID":"0fb99b978e197f57925049c62f2d1731","tags":["Go"],"url":"/post/pkg-errors%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"},{"content":"前言 Hystrix-Go 熔断算法的算法核心是：当请求失败比率达到一定阈值之后，熔断器开启，并休眠一段时间（由配置决定），这段休眠期过后，熔断器将处于半开状态，","lvl0":"Google SRE弹性熔断算法实现","lvl1":["Go"],"lvl2":"摘要","objectID":"4923c6e5bc056434337ee7a50e3696e8","tags":["Go","SRE"],"url":"/post/google-sre%E5%BC%B9%E6%80%A7%E7%86%94%E6%96%AD%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"},{"content":"优化基础镜像 优化基础镜像的方法就是选用合适的更小的基础镜像，常用的 Linux 系统镜像一般有 Ubuntu、CentOs、Alpine，其中Alpine","lvl0":"如何编写Docker镜像","lvl1":["Docker"],"lvl2":"摘要","objectID":"1e5b09c7243eda7991fc1ed40ac5a653","tags":["Docker"],"url":"/post/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99docker%E9%95%9C%E5%83%8F/"},{"content":"示例应用 首先贴出代码例子，我们假设要构建一个 http 服务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { fmt.Println(\u0026#34;Server Ready\u0026#34;) router :=","lvl0":"如何构建Go的镜像","lvl1":["Docker"],"lvl2":"摘要","objectID":"e099aa1bce5d79a170e6ce84b8299255","tags":["docker","go"],"url":"/post/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BAgo%E7%9A%84%E9%95%9C%E5%83%8F/"},{"content":"Dockerfile参考（Dockerfile reference） Docker可以通过读取Dockerfile中的指令自动构建镜像。 Dock","lvl0":"Dockerfile参考","lvl1":["Docker"],"lvl2":"摘要","objectID":"4fe6928d80ed6cde94c36285a2c6a9fa","tags":["Docker"],"url":"/post/dockerfile%E5%8F%82%E8%80%83/"},{"content":"背景 很多刚刚接触 gRPC 的用户，通常会惊讶于 Kubernetes 默认提供的负载均衡对于 gRPC 来说无法实现开箱即用的效果。比如，将一个简单的基于 Node.js 实现的 gRPC 微服务部署在 Kubernetes 后","lvl0":"Grpc在k8s集群中的负载均衡","lvl1":["k8s"],"lvl2":"摘要","objectID":"e0d7e510128dd8a6fb959c3cc572c953","tags":["k8s"],"url":"/post/grpc%E5%9C%A8k8s%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"content":"概述 一般情况下，我们的系统对外暴露HTTP/HTTPS的接口，内部使用rpc(GRPC)通讯，这时GRPC在服务之间通过service访问，","lvl0":"Nginx Ingress如何负载grpc","lvl1":["k8s"],"lvl2":"摘要","objectID":"69266fbff6fcef98949046c188ade425","tags":["k8s"],"url":"/post/nginx-ingress%E5%A6%82%E4%BD%95%E8%B4%9F%E8%BD%BDgrpc/"},{"content":"调试器设置 调试器会使用要以下这些配置, 在通常情况下, 你不需要更改或者修改他们中的任何一项, 但是需要看一看。 go.gopath. 查看GOPATH in VS Code go.inferGopath, 查看GO","lvl0":"Vscode如何调试Go代码","lvl1":["vscode"],"lvl2":"摘要","objectID":"0aef60087f1cef0fe65406a2e44e0c78","tags":["Go"],"url":"/post/vscode%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95go%E4%BB%A3%E7%A0%81/"},{"content":"HTTP 超文本传输协议（Hypertext Transfer Protocol、HTTP 协议）是今天使用最广泛的应用层协议，1989 年由 Tim Berners-Lee 在 CERN 起草的协议已经成为了","lvl0":"net-http源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"729421b6b3ccbffc1edf4a83fe07956c","tags":null,"url":"/post/net-http%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"前言 伪共享的非标准定义为：缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行","lvl0":"内存模型与伪共享","lvl1":["Go"],"lvl2":"摘要","objectID":"7092284a4a58fd0ea5ef1bd4211b51de","tags":["伪共享"],"url":"/post/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E4%BC%AA%E5%85%B1%E4%BA%AB/"},{"content":"P2C算法 介绍 常见的Load balance算法想必大家都不陌生，Random、Round-robin、Least connection、Con","lvl0":"负载均衡P2C+EWMA算法","lvl1":["算法"],"lvl2":"摘要","objectID":"1a2d5f55d76c64fb46d53e299351f2d9","tags":["算法"],"url":"/post/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1p2c+ewma%E7%AE%97%E6%B3%95/"},{"content":"负载均衡的方法 构建高可用、高性能的通信服务，通常采用服务注册与发现、负载均衡和容错处理等机制实现。根据负载均衡实现所在的位置不同，通常可分为","lvl0":"GRPC的服务发现与负载均衡","lvl1":["GRPC"],"lvl2":"摘要","objectID":"feb7220e31332222fc31502f1a16f9d9","tags":["GRPC"],"url":"/post/grpc%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"content":"基本概念 ClientConn 对象是连接管理的入口，表示到服务端的一个逻辑的连接，会做名字解析、负载均衡、KeepAlive 等连接管理方面的操作，是个线程安全的","lvl0":"GRPC的ClientConn源码剖析","lvl1":["GRPC"],"lvl2":"摘要","objectID":"7aa53c7e7cce1cd9a725de688d564a47","tags":["GRPC"],"url":"/post/grpc%E7%9A%84clientconn%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"虽然使用读写锁可以提供线程安全的 map,但是在大量并发读写的情况下,锁的竞争会非常激烈。锁是性能下降的万恶之源之一。 在并发编程中,我们的一条","lvl0":"Go实现分片锁:orcaman-concurrent-map","lvl1":["Go"],"lvl2":"摘要","objectID":"9f10ce440e98ec6235a3fc019d674c38","tags":["Go"],"url":"/post/go%E5%AE%9E%E7%8E%B0%E5%88%86%E7%89%87%E9%94%81orcaman-concurrent-map/"},{"content":"channel hchan Go 语言的 Channel 在运行时使用 runtime.hchan 结构体表示。我们在 Go 语言中创建新的 Channel 时，实际上创建的都是如下所示的结构： 实现 Channel 的结构并不神秘，本质上就是一个 mutex 锁","lvl0":"基本原语channel\u0026select源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"430c364c2b2470be0e392cf806bc6984","tags":["Go源码"],"url":"/post/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E8%AF%ADchannel%E5%92%8Cselect%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"前言 在 git 的使用中，一种最佳实践是使用格式化的 commit 信息，这样方便自动化工具进行处理，可以快速生成 Release Notes，甚至可以直接对接 CI 工具进行更进一步","lvl0":"规范化git-commit信息","lvl1":["git"],"lvl2":"摘要","objectID":"0cdc5c1551a9be8bc738ffedc50ed052","tags":["git"],"url":"/post/%E8%A7%84%E8%8C%83%E5%8C%96git-commit%E4%BF%A1%E6%81%AF/"},{"content":"前言 Go 使编写测试非常简单。实际上，测试工具是内置在标准工具链里的，你可以简单地运行 go test 来运行你的测试，无需安装任何额外的依赖或任何别的东西。","lvl0":"Go中的测试技巧","lvl1":["Go"],"lvl2":"摘要","objectID":"6dc50929e5a31cb3496bb076726f7910","tags":["Go"],"url":"/post/go%E4%B8%AD%E7%9A%84%E6%B5%8B%E8%AF%95%E6%8A%80%E5%B7%A7/"},{"content":"math/rand 包 math/rand 包实现了伪随机数生成器 主要方法 （1）func Seed(seed int64) 设置随机种子，不设置则默认Seed(1) （2）func Int() int 返回一个非负的伪随机int值","lvl0":"Go如何生成随机数","lvl1":["Go"],"lvl2":"摘要","objectID":"5a20f84af8d91a1d59bf12a1fadc84e3","tags":["Go"],"url":"/post/go%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"content":"前言 Go语言可以通过go/build包里定义的tags和命名约定来让Go的包可以运行不同的代码。 在源代码里添加标注，通常称之为编译标签（bu","lvl0":"Go的条件编译","lvl1":["Go"],"lvl2":"摘要","objectID":"b66193d318e909817f73adfb5290a135","tags":["Go"],"url":"/post/go%E7%9A%84%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/"},{"content":"前言 说到Golang中应用最广泛的web框架，恐怕非gin-gonic/gin莫属了。在服务中，如果它依赖的后端服务出现异常，我们希望错误能","lvl0":"如何实现gin的timeout-Middleware","lvl1":["Gin"],"lvl2":"摘要","objectID":"086dd488f4e740f6ebeecbad68562ee6","tags":["Gin"],"url":"/post/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0gin%E7%9A%84timeout-middleware/"},{"content":"go doc go doc命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。 所谓Go语言的程","lvl0":"Godoc介绍","lvl1":["Go"],"lvl2":"摘要","objectID":"375668a5baed10a9711c9f8a085e7450","tags":["godoc"],"url":"/post/godoc%E4%BB%8B%E7%BB%8D/"},{"content":"简介 YAML 是 \u0026ldquo;YAML Ain\u0026rsquo;t a Markup Language\u0026rdquo;（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\u0026ldquo","lvl0":"Yaml语法介绍","lvl1":["yaml"],"lvl2":"摘要","objectID":"314682104e92f69c05f23b035d255468","tags":["yaml"],"url":"/post/yaml%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D/"},{"content":"设计原理 栈区的内存一般由编译器自动进行分配和释放，其中存储着函数的入参以及局部变量，这些参数会随着函数的创建而创建，函数的返回而消亡，一般不","lvl0":"Go的栈空间管理源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"fffabb82dd17f400df9e66c4f3898894","tags":["Go源码"],"url":"/post/go%E7%9A%84%E6%A0%88%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"背景 在业务快速增长中，前期只是验证模式是否可行，初期忽略程序发布重启带来的暂短停机影响。当模式实验成熟之后会逐渐放量，此时我们的发布停机带来","lvl0":"Go服务的优雅关闭与重启","lvl1":["Go"],"lvl2":"摘要","objectID":"d398fa8f2137b7f4c7e7a177de592918","tags":["Go"],"url":"/post/go%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BC%98%E9%9B%85%E5%85%B3%E9%97%AD%E4%B8%8E%E9%87%8D%E5%90%AF/"},{"content":"信号 信号是事件发生时对进程的通知机制。有时也称之为软件中断。信号与硬件中断的相似之处在于打断了程序执行的正常流程，大多数情况下，无法预测信号","lvl0":"Go中的信号处理","lvl1":["Go"],"lvl2":"摘要","objectID":"c64a52c19c88dca447bc3c7b2bb81f7f","tags":["Go"],"url":"/post/go%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"content":"ErrGroup ErrGroup是 Go 官方提供的一个同步扩展库。我们经常会碰到需要将一个通用的父任务拆成几个小任务并发执行的场景，其实，将一个大的任务拆成几","lvl0":"扩展并发原语ErrGroup源码剖析","lvl1":["Go"],"lvl2":"摘要","objectID":"fb4f00b43f0f0fb35ba90288358e993f","tags":["Go","errgroup"],"url":"/post/%E6%89%A9%E5%B1%95%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADerrgroup%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"数据竞争与竞态条件 数据竞争 定义：①多个线程对于同一个变量、②同时地、③进行读/写操作的现象并且④至少有一个线程进行写操作。（也就是说，如果所","lvl0":"Go中的Data-Race","lvl1":["Go"],"lvl2":"摘要","objectID":"693970ca1186f7931dbca19077117776","tags":["Go"],"url":"/post/go%E4%B8%AD%E7%9A%84data-race/"},{"content":"垃圾分类 垃圾分为以下两类: 语义垃圾(semantic garbage)—有的被称作内存泄露 语义垃圾指的是从语法上可达(可以通过局部、全局变量引","lvl0":"Go的垃圾回收源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"669fde967b2735e50cbb43b1b9723915","tags":["Go源码"],"url":"/post/go%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"前言 如果某个 G 执行时间过长，其他的 G 如何才能被正常的调度？ 这便涉及到有关调度的两个理念：协作式调度与抢占式调度。 协作式和抢占式这两个理念解释","lvl0":"Go调度器的协作与抢占","lvl1":["Go源码"],"lvl2":"摘要","objectID":"76e79be9f405e86a2c1655fbaaeed1cb","tags":["Go源码"],"url":"/post/go%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E5%8D%8F%E4%BD%9C%E4%B8%8E%E6%8A%A2%E5%8D%A0/"},{"content":"前言 我们已经知道了 Go 运行时调度以 Goroutine 的方式调度了所有用户态代码。 每个 Goroutine 都有可能在不同的线程上重新被执行。 那么如果用户态的某个 Goroutine 需要接收系统信号","lvl0":"Go的信号处理源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"0574934bc36e347919c755b8763fa195","tags":["Go源码"],"url":"/post/go%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"设计原理 内存管理的三个角色: Mutator:fancy(花哨的) word for application，其实就是你写的应用程序，它会不断地修改对象的引用","lvl0":"Go的内存分配源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"879ecb2d64057b0414072b601ce64485","tags":["Go源码"],"url":"/post/go%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"用户空间与内核空间 现代操作系统都是采用虚拟存储器，那么对 32 位操作系统而言，它的寻址空间（虚拟存储空间）为 4G（2 的 32 次方）。操作系统的核心是","lvl0":"Linux的网络IO模型","lvl1":["Linux编程"],"lvl2":"摘要","objectID":"8cf236b7d13babdbdbc499e255d497c6","tags":null,"url":"/post/linux%E7%9A%84%E7%BD%91%E7%BB%9Cio%E6%A8%A1%E5%9E%8B/"},{"content":"runtime Go 语言是一⻔有 runtime 的语言，那么 runtime 是什么? 可以认为 runtime 是为了实现额外的功能，而在程序运行时自动 加载/运行的一些模块。 Go 语言的 runtime 包括: 这些模块中，","lvl0":"Go进程的生命周期源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"9b327ef48ace16247d9873015302aba0","tags":["Go源码"],"url":"/post/go%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"导言 Go 基于 I/O multiplexing 和 goroutine scheduler 构建了一个简洁而高性能的原生网络模型(基于 Go 的 I/O 多路复用 netpoller )，提供了 goroutine-per-connection 这样简单的网络编程模式。在这种模式下，开发者使用的","lvl0":"Go的网络轮询器源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"9c54f6b3a9c45b64147e1a4a6c1dd788","tags":["Go源码"],"url":"/post/go%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BD%AE%E8%AF%A2%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"设计原理 Go 语言的系统监控起到了很重要的作用，它在内部启动了一个不会中止的循环，在循环的内部会轮询网络、抢占长期运行或者处于系统调用的 Goroutine 以及触","lvl0":"Go的sysmon源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"2eee13133b764823091a899e072559fd","tags":["Go源码"],"url":"/post/go%E7%9A%84sysmon%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"Variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var ( // ErrUnsupportedFormat occurs when the `format` passed to Tracer.Inject() or // Tracer.Extract() is not recognized by the Tracer implementation. ErrUnsupportedFormat = errors.New(\u0026#34;opentracing: Unknown or unsupported Inject/Extract format\u0026#34;) // ErrSpanContextNotFound occurs when the `carrier` passed to // Tracer.Extract() is valid and uncorrupted but","lvl0":"Opentracing包解析","lvl1":["opentracing"],"lvl2":"摘要","objectID":"3ac0563e4066a38fd6be4be51f57c908","tags":["opentracing"],"url":"/post/opentracing%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"content":"了解一下http2和h2c (HTTP/2 over TCP,HTTP/2 without TLS)。 http/1.1 的服务器 我们经常会在代码中启动一个http服务器，最简单的http/1.1服务器如下所示： 1 2","lvl0":"Http2与h2c","lvl1":["http"],"lvl2":"摘要","objectID":"8b80562fcf67b299f9fe2b86c9a1a7a6","tags":["http"],"url":"/post/http2%E4%B8%8Eh2c/"},{"content":"业务场景 我们会有这样的需求：在不同的文件夹中定义了不同的 proto 文件，这些不同的文件夹可能是一些不同的 gRPC 服务。因为不想重复定义某一个 message","lvl0":"Protobuf的import功能","lvl1":["protobuf"],"lvl2":"摘要","objectID":"907897a87586bd8f7b28fd699afb874c","tags":["protobuf"],"url":"/post/protobuf%E7%9A%84import%E5%8A%9F%E8%83%BD/"},{"content":"grpc基于HTTP/2 grpc的client和server通信是基于HTTP/2，client发出的消息是HTTP/2协议格式，serve","lvl0":"GRPC如何支持HTTP","lvl1":["GRPC"],"lvl2":"摘要","objectID":"809ed5ba106e281cab6b9bea1becc36c","tags":["GRPC"],"url":"/post/grpc%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81http/"},{"content":"概观 Afero 是一个文件系统框架,提供与任何文件系统的简单,统一和通用的交互 API。作为提供接口,类型和方法的抽象层，Afero 具有非常干净的接口和","lvl0":"Go的文件系统抽象系统:Afero","lvl1":["Go"],"lvl2":"摘要","objectID":"b3107c1c99025d710d2d81955ae9113d","tags":["Go"],"url":"/post/go%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%BD%E8%B1%A1%E7%B3%BB%E7%BB%9F-afero/"},{"content":"编译时类型断言来检查接口 作为一个热身，来看一个在 Go 中熟知的编译期断言：接口满意度检查。 在这段代码中，var _ stringWriter = W{}行确保类型 W 是一个 st","lvl0":"Go的类型断言","lvl1":["Go"],"lvl2":"摘要","objectID":"607289e98151cf01d192436df2f1aeec","tags":["Go"],"url":"/post/go%E7%9A%84%E7%BC%96%E8%AF%91%E6%9C%9F%E6%96%AD%E8%A8%80/"},{"content":"wire是 Google 开源的一个依赖注入工具。它是一个代码生成器，并不是一个框架。我们只需要在一个特殊的go文件中告诉wire类型之间的依赖关系，它会","lvl0":"依赖注入:Wire包介绍","lvl1":["Go"],"lvl2":"摘要","objectID":"f8157492ae2d2454a46c500a34ff7f9a","tags":["Go"],"url":"/post/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5wire%E5%8C%85%E4%BB%8B%E7%BB%8D/"},{"content":"依赖倒置原则 要了解控制反转( Inversion of Control ), 我觉得有必要先了解软件设计的一个重要思想：依赖倒置原则（Dependency Inversion Principle ）。 什么是依赖倒置原则？","lvl0":"控制反转（IoC）与依赖注入（DI）","lvl1":["设计模式"],"lvl2":"摘要","objectID":"aafa6880f585ffe5271a23888a61f8b4","tags":["设计模式"],"url":"/post/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACioc%E4%B8%8E%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5di/"},{"content":"架构 如上图所示，Jaeger 主要由以下几部分组成。 Agent（客户端代理） jaeger的agent，是一个监听在 UDP 端口上接收 span 数据的网络守护","lvl0":"分布式链路跟踪工具:Jaeger","lvl1":["Jaeger"],"lvl2":"摘要","objectID":"31216af595c81e58798e0bb0c4dad0b6","tags":["Jaeger"],"url":"/post/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA%E5%B7%A5%E5%85%B7jaeger/"},{"content":"介绍 要查看支持的Linter列表以及启用/禁用的Linter： 1 golangci-lint help linters 默认情况下启用Linter: govet -Vet检查Go源代码并报告可疑构造，例","lvl0":"Golangci Lint配置介绍","lvl1":["golangci-lint"],"lvl2":"摘要","objectID":"5f0e2cab9d516c13e1910e923d89571c","tags":["golangci-lint"],"url":"/post/golangci-lint%E9%85%8D%E7%BD%AE%E4%BB%8B%E7%BB%8D/"},{"content":"介绍 在过去的十年中， Go的errors are values的理念在编码实践中运行得也很良好。尽管标准库对错误处理的的支持很少（只有errors.N","lvl0":"Go1 13的错误处理","lvl1":["Go"],"lvl2":"摘要","objectID":"51a13569153524d7f3e01e6771b10694","tags":["Go"],"url":"/post/go1-13%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"},{"content":"指导原则 我们要谈论在一个编程语言中的最佳实践，那么我们首先应该明确什么是“最佳”。如果您们听了我昨天那场讲演的话，您一定看到了来自 Go 团队的 Russ","lvl0":"Go语言实践:编写可维护的程序的建议","lvl1":["Go规范"],"lvl2":"摘要","objectID":"060852621cb0ee321759616498762b79","tags":["Go规范"],"url":"/post/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%B7%B5%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BB%BA%E8%AE%AE/"},{"content":"当前页面收集了在 Go 代码审核期间的常见意见，以便一个详细说明能被快速参考。这是一个常见错误的清单，而非综合性的风格指南。 你也可以将它作为是 Effective Go","lvl0":"Go代码审查建议","lvl1":["Go规范"],"lvl2":"摘要","objectID":"328dd106b807fe33485c52e9181f8d11","tags":["Go规范"],"url":"/post/go%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E5%BB%BA%E8%AE%AE/"},{"content":"注释 可以通过 /……/ 或者 // ……增加注释， //之后应该加一个空格。 如果你想在每个文件中的头部加上注释，需要在版权注释和 Package前面加一个","lvl0":"Go编码建议","lvl1":["Go规范"],"lvl2":"摘要","objectID":"4a2d461449ba445356a9bf9726c7f434","tags":["Go规范"],"url":"/post/go%E7%BC%96%E7%A0%81%E5%BB%BA%E8%AE%AE/"},{"content":"Overview Ristretto是一种快速的，固定大小的内存中高速缓存，同时关注吞吐量和命中率性能。您可以轻松地将Ristretto添加到现有系统，并将","lvl0":"TinyLFU缓存:ristretto","lvl1":["Go"],"lvl2":"摘要","objectID":"e4d185e417aef7a2bea688b85e16a150","tags":["Go","ristretto"],"url":"/post/tinylfu%E7%BC%93%E5%AD%98ristretto/"},{"content":"func Marshal 1 func Marshal(v interface{}) ([]byte, error) Marshal 返回v的MessagePack编码。 Example Code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type Item struct { Foo string } b, err := msgpack.Marshal(\u0026amp;Item{Foo: \u0026#34;bar\u0026#34;}) if err != nil { panic(err) } var item Item err = msgpack.Unmarshal(b, \u0026amp;item)","lvl0":"序列化:vmihailenco-Msgpack","lvl1":["Go"],"lvl2":"摘要","objectID":"a913addf9786997773979a178f39b2e9","tags":["Go","messagepack"],"url":"/post/%E5%BA%8F%E5%88%97%E5%8C%96vmihailenco-msgpack/"},{"content":"介绍 MessagePack是一种高效的二进制序列化格式。它允许您像JSON一样在多个语言之间交换数据。但是，它更快并且更小。小整数被编码为一","lvl0":"序列化:MessagePack介绍","lvl1":["MessagePack"],"lvl2":"摘要","objectID":"43e9bce9e99ac9e633839fe6fbf94f9d","tags":["MessagePack"],"url":"/post/%E5%BA%8F%E5%88%97%E5%8C%96messagepack%E4%BB%8B%E7%BB%8D/"},{"content":"Go-advice 中文版本 Go 箴言 Go 之禅 代码 并发 性能 模块 构建 测试 工具 Misc Go-advice 中文版本 Go 箴言 不要通过共享内存进行通信，通过通信共享内存 并发不是并行 通道编排；互斥体序","lvl0":"Go Advice","lvl1":["规范"],"lvl2":"摘要","objectID":"a85daca6a604353e2d2ac15022b9eaa7","tags":["Go"],"url":"/post/go-advice/"},{"content":"Uber Go 语言编码规范 Uber 是一家美国硅谷的科技公司，也是 Go 语言的早期 adopter。其开源了很多 golang 项目，诸如被 Gopher 圈熟知的 zap、jaeger 等。20","lvl0":"Uber的Go语言编码规范","lvl1":["Go规范"],"lvl2":"摘要","objectID":"d08566ef9c0101b4464e5d8bdaca7d38","tags":["Go规范"],"url":"/post/uber%E7%9A%84go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"content":"W-TinyLFU 我们有三种常见的缓存驱逐策略： FIFO:先进先出，在这种淘汰算法中，先进入缓存的会先被淘汰。这种可谓是最简单的了，但是会导致我们命中率很低","lvl0":"缓存驱逐算法:W-TinyLFU","lvl1":["cache"],"lvl2":"摘要","objectID":"e4dca9f5dbff8bd79d9995723eac53b1","tags":["cache"],"url":"/post/%E7%BC%93%E5%AD%98%E9%A9%B1%E9%80%90%E7%AE%97%E6%B3%95w-tinylfu/"},{"content":"设计BigCache的初衷 bigcache的作者也不是想当然的开发一个库，而且项目遇到了需求。需求如下： 支持http协议 支持 10K RPS (5k 写，5k 读","lvl0":"Bigcache优化技巧","lvl1":["cache"],"lvl2":"摘要","objectID":"dcd2f2da6b04c8dfc042ea4cae42cad8","tags":["Go","cache"],"url":"/post/bigcache%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/"},{"content":"前言 在大部分业务系统中，都会使用诸如 Redis、Memcached 等远程缓存，一方面可以避免自身进程内存占用过大而导致的 OOM 或 GC 问题，另一方面","lvl0":"Go中如何实现高性能本地缓存","lvl1":["cache"],"lvl2":"摘要","objectID":"18436fdb348340f7d43781f4fb676b70","tags":["cache","GO"],"url":"/post/go%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/"},{"content":"存储(store) 首先，当你准备缓存一些数据时，你必须选择缓存的存储方式：简单的直接放进内存？使用 Redis 或者 Memcache？或者其它某种形式的","lvl0":"Gocache:一个功能齐全且易于扩展的Go缓存库","lvl1":["Go"],"lvl2":"摘要","objectID":"413c9f3b890f58d19795ee3bcb78eb0b","tags":["Go","gocache"],"url":"/post/gocache%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E9%BD%90%E5%85%A8%E4%B8%94%E6%98%93%E4%BA%8E%E6%89%A9%E5%B1%95%E7%9A%84go%E7%BC%93%E5%AD%98%E5%BA%93/"},{"content":"PromQL PromQL 是 Prom 中的查询语言，提供了简洁的、贴近自然语言的语法实现时序数据的分析计算。 表达式（Expression）是其中承载数据计算逻辑的部分，对","lvl0":"Prometheus的PromQL实现分析","lvl1":["Prometheus"],"lvl2":"摘要","objectID":"5066a70cfd798ea0d60bcde051e1f3eb","tags":["Prometheus","Go"],"url":"/post/prometheus%E7%9A%84promql%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"},{"content":"整体结构分析 无论是 Prom 拉取 (pull) 数据，还是客户端主动推送 (push) 数据，都可以从 Collector 获取 Metric 的定义，UML 图描述了 Go 客户端中主要结构和接口之间的关系。 Collector pro","lvl0":"Prometheus的GoClient分析","lvl1":["Prometheus"],"lvl2":"摘要","objectID":"5889068b6b7a37aaa1a8dbf838850ffa","tags":["Prometheus","Go"],"url":"/post/prometheus%E7%9A%84goclient%E5%88%86%E6%9E%90/"},{"content":"在 HTTP API 中使用 PromQL Prometheus 当前稳定的 HTTP API 可以通过 /api/v1 访问。 API 响应格式 Prometheus API 使用了 JSON 格式的响应内容。 当 API 调用成功后将会返回 2xx 的 HTTP 状态码。 反之，当 API 调用失败时","lvl0":"在HTTPAPI中使用PromQL","lvl1":["prometheus"],"lvl2":"摘要","objectID":"6355dd1309c261df0c6c2dfc0c6421c2","tags":["prometheus"],"url":"/post/%E5%9C%A8httpapi%E4%B8%AD%E4%BD%BF%E7%94%A8promql/"},{"content":"PromQL 内置函数 Prometheus 提供了其它大量的内置函数，可以对时序数据进行丰富的处理。某些函数有默认的参数，例如：year(v=vector(time()) i","lvl0":"Prometheus的内置函数","lvl1":["prometheus"],"lvl2":"摘要","objectID":"628950084c182262cafb845c347aa3df","tags":["prometheus"],"url":"/post/prometheus%E7%9A%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},{"content":"存储 Prometheus 2.x 默认将时间序列数据库保存在本地磁盘中，同时也可以将数据保存到任意第三方的存储服务中。 本地存储 Prometheus 采用自定义的存储格式将样本数据保存在本","lvl0":"Prometheus的数据存储","lvl1":["prometheus"],"lvl2":"摘要","objectID":"72602847fb0219534c83afb19ed1d5ec","tags":["prometheus"],"url":"/post/prometheus%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"content":"Counter（计数器） Counter 类型代表一种样本数据单调递增的指标，即只增不减，除非监控系统发生了重置。例如，你可以使用 counter 类型的指标来表示服务的请","lvl0":"prometheus的四种指标类型","lvl1":["prometheus"],"lvl2":"摘要","objectID":"f478813b226ab329b049f2a1f1435f19","tags":["prometheus"],"url":"/post/promethues%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%8C%87%E6%A0%87%E7%B1%BB%E5%9E%8B/"},{"content":"prometheus包 概述 普罗米修斯软件包是仪器仪表的核心。它为度量代码提供度量原语以进行监视。它还提供了Metric注册表。子包允许通过H","lvl0":"Prometheus的client_golang","lvl1":["Prometheus"],"lvl2":"摘要","objectID":"1fc2fdc9f054a99178e052c1efb607b5","tags":["Prometheus","Go"],"url":"/post/prometheus%E7%9A%84client_golang/"},{"content":"简介 jennifer支持所有的 Go 语法和特性，可以用它来生成任何 Go 语言代码。 快速使用 先安装： 1 go get github.com/dave/jennifer 今天我们换个思路来介绍jennifer这个","lvl0":"Go的代码生成库:jennifer","lvl1":["Go"],"lvl2":"摘要","objectID":"b49e4b8d381374a0040568e26b4fa644","tags":["Go"],"url":"/post/go%E7%9A%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%BA%93jennifer/"},{"content":"Cobra提供简单的接口来创建强大的现代化CLI接口，比如git与go工具。Cobra同时也是一个程序, 用于创建CLI程序 功能 简易的子命令行","lvl0":"Go命令行库Cobra的使用","lvl1":["Go"],"lvl2":"摘要","objectID":"45330fc7f654191d7fb1803447372480","tags":["Go","Cobra"],"url":"/post/go%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%93cobra%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"content":"概述 MongoDB使客户端能够批量执行写操作。批量写入操作会影响单个集合。MongoDB允许应用程序确定批量写入操作所需的可接受的确认级别。","lvl0":"MongoDB的批量写操作","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"0ddef13cadc1a73c80c287e9569008fe","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E6%89%B9%E9%87%8F%E5%86%99%E6%93%8D%E4%BD%9C/"},{"content":"本文简单介绍一下Go语言在1.11版本之后推出的go mod使用私有仓库时遇到的问题。 直接使用go get 直接使用go get ...添加私有仓库依赖时，会","lvl0":"Go将Private仓库用作module依赖","lvl1":["Go"],"lvl2":"摘要","objectID":"7fb7aaf0c96943bbd859555d17669997","tags":["Go"],"url":"/post/go%E5%B0%86private%E4%BB%93%E5%BA%93%E7%94%A8%E4%BD%9Cmodule%E4%BE%9D%E8%B5%96/"},{"content":"索引合并 索引合并访问方法可以在查询中对一个表使用多个索引,对它们同时扫描，并且合并结果(intersect/union)。 此访问方法合并来自","lvl0":"MySQL的索引合并","lvl1":["MySQL"],"lvl2":"摘要","objectID":"8e541f59aa640802da6523ae92ac6c4b","tags":["MySQL"],"url":"/post/mysql%E7%9A%84%E7%B4%A2%E5%BC%95%E5%90%88%E5%B9%B6/"},{"content":"缓存穿透 什么是缓存穿透 正常情况下，查询的数据都存在，如果请求一个不存在的数据，也就是缓存和数据库都查不到这个数据，每次都会去数据库查询，这种","lvl0":"缓存穿透、缓存击穿、缓存雪崩","lvl1":["redis"],"lvl2":"摘要","objectID":"aa9bda6ea34c4b56682e212352ba8983","tags":["redis"],"url":"/post/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/"},{"content":"任何一种数据库都有各种各样的日志，MongoDB也不例外。MongoDB中有4种日志，分别是系统日志、Journal日志、oplog主从日志","lvl0":"MongoDB的四种日志","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"d2e3ac8cef2f265e13386c16b420f02c","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%97%A5%E5%BF%97/"},{"content":"示例system.profile文档 下面显示了在system.profile集合中找到的一些示例文档，这些文档可 用于独立运行： 以下文档sys","lvl0":"MongoDB的数据库探查器输出","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"46d970b68480ac9f89f5d7527be29eb8","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E6%8E%A2%E6%9F%A5%E5%99%A8%E8%BE%93%E5%87%BA/"},{"content":"前言 数据库事件探查器收集有关针对正在运行的mongod实例执行的数据库命令的详细信息。这包括CRUD操作以及配置和管理命令。探查器将其收集的","lvl0":"MongoDB的探查器配置","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"5e0fec5acfbfee16c089e35fe7933ec2","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E6%8E%A2%E6%9F%A5%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"content":"一、键值设计 1. key名设计 (1)【建议】: 可读性和可管理性 以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id","lvl0":"Redis开发规范","lvl1":["redis"],"lvl2":"摘要","objectID":"403fe00ade6c62081fa3525b8f2274e7","tags":["redis"],"url":"/post/redis%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"},{"content":"流水线 1 2 3 4 5 6 7 8 9 10 11 12 13 pipe := rdb.Pipeline() incr := pipe.Incr(\u0026#34;pipeline_counter\u0026#34;) pipe.Expire(\u0026#34;pipeline_counter\u0026#34;, time.Hour) // Execute // // INCR pipeline_counter // EXPIRE pipeline_counts 3600 // // using one rdb-server roundtrip. _, err := pipe.Exec() fmt.Println(incr.Val(), err) 上面的代码也可以写成下面的形式: 1 2 3 4 5 6 7 var","lvl0":"go-redis的常用操作总结","lvl1":["go-redis"],"lvl2":"摘要","objectID":"ad7b33d8f682cdc5b3e73fa15ef507cc","tags":["go-redis"],"url":"/post/go-redis%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"},{"content":"聚合管道 MongoDB聚合管道包括阶段。每个阶段在文档通过管道时都会对其进行转换。流水线阶段不需要为每个输入文档都生成一个输出文档。例如，某","lvl0":"MongoDB的聚合管道","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"b1a08b89562cfdae7aea53334c7357cd","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E8%81%9A%E5%90%88%E7%AE%A1%E9%81%93/"},{"content":"count 定义 此页面记录了mongoshell方法，并且 没有引用MongoDB Node.js驱动程序（或任何其他驱动程序）方法。对于相应的Mongo","lvl0":"MongoDB的单用途聚合","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"6a6a486734ff143fc11e5b53c20f3ded","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E5%8D%95%E7%9B%AE%E7%9A%84%E8%81%9A%E5%90%88/"},{"content":"前言 聚合操作处理数据记录并返回计算结果。聚合操作将来自多个文档的值组合在一起，并且可以对分组的数据执行各种操作以返回单个结果。MongoDB","lvl0":"MongoDB的聚合操作","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"f4b85aae13452c3630596eacde6a15cc","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C/"},{"content":"日期 所述mongo外壳提供了各种方法来返回日期，无论是作为一个字符串或作为Date对象： Date() 以字符串形式返回当前日期的方法。 new Date()构造","lvl0":"MongoShell中的数据类型","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"5785b5619249ee712f65261b11bc561d","tags":["MongoDB"],"url":"/post/mongoshell%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"content":"$ $运算符标识要更新的数组中的元素，而无需显式指定数组中元素的位置。 消歧 要通过读取操作$投影或返回数组元素，请参阅投影运算符。 要更新数组中的","lvl0":"MongoDB的数组更新运算符","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"a25cc13a0cdff1ddafe08cfafbeff0b5","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"content":"$currentDate $ currentDate运算符将字段的值设置为当前日期，可以是Date或时间戳。默认类型为日期。 $currentDate的形式为： 1 { $currentDate: {","lvl0":"MongoDB的字段更新运算符","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"d5e32af17da1772c88416ea89cd67c6d","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"content":"$ (projection) 定义 $运算符\u0026lt;array\u0026gt;将查询结果中的内容限制为仅包含与查询文档匹配的第一个元素。 当您在选定文档中只需要一个特定的数组元素","lvl0":"MongoDB的投影运算符","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"81c2cf7b1b71bde2e80beef8feb021dd","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E6%8A%95%E5%BD%B1%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"content":"$all 在$all选择的文件，其中一个字段的值是包含所有指定元素的数组。要指定$all表达式，请使用以下原型： 1 { \u0026lt;field\u0026gt;: { $all: [ \u0026lt;value1\u0026gt; , \u0026lt;value2\u0026gt; ... ] } } 特性 等效于","lvl0":"MongoDB的数组查询运算符","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"4491936aa571f7ffd4d4169760a2e15d","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E6%95%B0%E7%BB%84%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"content":"$expr 允许在查询语言中使用聚合表达式。 $expr 具有以下语法： 1 { $expr: { \u0026lt;expression\u0026gt; } } 参数可以是任何有效的聚合表达式。有关更多信息，请参见表达式。 特性 $expr可","lvl0":"MongoDB的评估查询运算符","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"a452322db02405431992f20ead702dff","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E8%AF%84%E4%BC%B0%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"content":"$exists 语法：{ field: { $exists: \u0026lt;boolean\u0026gt; } } 如果\u0026lt;boolean\u0026gt;为true，则$exists匹配包含该字段的文档，包括字段值为的文档 null。如果\u0026","lvl0":"MongoDB的元素查询运算符","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"4cf3bb7139e753f6e5e86aa9ce9a4166","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E5%85%83%E7%B4%A0%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"content":"$and 语法：{ $and: [ { \u0026lt;expression1\u0026gt; }, { \u0026lt;expression2\u0026gt; } , ... , { \u0026lt;expressionN\u0026gt; } ] } $and在一个或多个表达式（例如\u0026lt;expression1\u0026gt;，\u0026lt;expressio","lvl0":"MongoDB的逻辑查询运算符","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"0325f981b14ee4cb93d95d610b73e5d2","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E9%80%BB%E8%BE%91%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"content":"比较/排序顺序 比较不同BSON类型的值时，MongoDB使用以下比较顺序，从最低到最高： MinKey（内部类型） 空值 数字（整数，整数，双精度","lvl0":"MongoDB的比较查询运算符","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"9a630a9eee7ffcfe9cc882c0b5ae0563","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E6%AF%94%E8%BE%83%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"content":"db.collection.findAndModify（） 定义 findAndModify()方法具有以下形式： 1 2 3 4 5 6 7 8 9 10 11 12 13 db.collection.findAndModify({ query:","lvl0":"MongoDB的findAndModify","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"789a5ed74352ee51df920c1dc17bbbee","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84findandmodify/"},{"content":"db.collection.explain（） 评估查询的性能 inventory包含以下文档的集合： 1 2 3 4 5 6 7 8 9 10 { \u0026#34;_id\u0026#34; : 1, \u0026#34;item\u0026#34; : \u0026#34;f1\u0026#34;, type: \u0026#34;food\u0026#34;, quantity: 500","lvl0":"MongoDB查询性能分析","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"7d176e202d6b4da3032915ace18e44fe","tags":["MongoDB"],"url":"/post/mongodb%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"content":"创建索引来支持查询 对于常见的查询，请创建索引。如果查询搜索多个字段，请创建一个复合索引。扫描索引比扫描集合快得多。索引结构小于文档参考，并按","lvl0":"MongoDB优化查询性能","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"ba7caa8859fe38d68dc76e50432db797","tags":["MongoDB"],"url":"/post/mongodb%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD/"},{"content":"示例集合 此页面使用以下MongoDB Go驱动程序功能： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43","lvl0":"MongoDB的删除操作","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"0667d84d2dd8cd191cbbb49e7e835401","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/"},{"content":"示例集合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66","lvl0":"MongoDB的更新操作","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"84659ab75b21e17609844ac1c5dd6850","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C/"},{"content":"示例集合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 docs := []interface{}{ bson.D{ {\u0026#34;item\u0026#34;, \u0026#34;journal\u0026#34;}, {\u0026#34;qty\u0026#34;, 25}, {\u0026#34;size\u0026#34;, bson.D{ {\u0026#34;h\u0026#34;, 14},","lvl0":"MongoDB的查询操作","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"63b4936999afac6197c63377c65788dc","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C/"},{"content":"何谓同步远程分支？ 有下面几种情况， 本地有新分支，远程仓库没有。 远程仓库有新分支，本地没有。 本地删除了分支，远程也想删除。 远程删除了分支，本地","lvl0":"Git同步远程仓库分支","lvl1":["Git"],"lvl2":"摘要","objectID":"c124dd4d155766b620b5eda8f68047d4","tags":["Git"],"url":"/post/git%E5%90%8C%E6%AD%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%88%86%E6%94%AF/"},{"content":"创建collection 如果该集合当前不存在，则插入操作将创建该集合。 插入一个文档 Collection.InsertOne 将单个文档插入到集合中。 以下示例将一个新文档插入到inv","lvl0":"MongoDB的插入操作","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"47ae83a0e49704550284654ffbb5e59f","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/"},{"content":"JSON风格指南 版本：0.9 英文版：https://google.github.io/styleguide/jsoncstyleguide.","lvl0":"JSON风格指南","lvl1":["规范"],"lvl2":"摘要","objectID":"decf0d354f9503ba4cefc63dc7ecb358","tags":["JSON"],"url":"/post/json%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/"},{"content":"理解架构 名称 REST，即Representational State Transfer的缩写。我对这个词组的翻译是\u0026quot;表现层状态转化\u0026quot;","lvl0":"RESTful API设计规范","lvl1":["架构"],"lvl2":"摘要","objectID":"48e1f4b5db2d6cc50e926a1cc9092b5d","tags":["REST"],"url":"/post/restful-api%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/"},{"content":"Topic 与 Tag 最佳实践 在RocketMQ中，Topic 与 Tag 都是业务上用来归类的标识，区分在于 Topic 是一级分类，而 Tag 可以理解为是二级分类。您可通过本文了解","lvl0":"Rocketmq的最佳实践","lvl1":["rocketmq"],"lvl2":"摘要","objectID":"a9dc39318c6b3e1d7e639a6d00b2ca5a","tags":["rocketmq"],"url":"/post/rocketmq%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"content":"设计思路 RocketMQ消息轨迹，主要跟踪消息发送、消息消费的轨迹，即详细记录消息各个处理环节的日志，从设计上至少需要解决如下三个核心问题：","lvl0":"Rocketmq的消息轨迹","lvl1":[],"lvl2":"摘要","objectID":"d69dcc4319a66aff55fcb7db6409008b","tags":[""],"url":"/post/rocketmq%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%A8%E8%BF%B9/"},{"content":"namespace 1 2 3 if p.options.Namespace != \u0026#34;\u0026#34; { msg.Topic = p.options.Namespace + \u0026#34;%\u0026#34; + msg.Topic } 生产者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package main","lvl0":"Rocketmq的namespace","lvl1":["rocketmq"],"lvl2":"摘要","objectID":"282fe6a9e0501fe49ab78cb6cc0792a8","tags":["rocketmq"],"url":"/post/rocketmq%E7%9A%84namespace/"},{"content":"什么是ACL? RocketMQ在4.4.0版本开始支持ACL。ACL是access control list的简称，俗称访问控制列表。访问控制，基本上会涉及","lvl0":"Rocketmq的ACL机制","lvl1":["rocketmq"],"lvl2":"摘要","objectID":"3f0e79a1a40004d5162358f56bbcd60f","tags":["rocketmq"],"url":"/post/rocketmq%E7%9A%84acl%E6%9C%BA%E5%88%B6/"},{"content":"生产者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2/primitive\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2/producer\u0026#34;","lvl0":"Rocketmq客户端的拦截器","lvl1":["rocketmq"],"lvl2":"摘要","objectID":"f58ef4a0f8dfdeb942527f3d79c99aa8","tags":["rocketmq"],"url":"/post/rocketmq%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"content":"负载均衡 要做负载均衡，必须知道一些全局信息，也就是一个ConsumerGroup里到底有多少个Consumer，知道了全局信息，才可以根据某","lvl0":"rocketmq的消费负载均衡","lvl1":["rocketmq"],"lvl2":"摘要","objectID":"2b1df685e4c7ee042fb9a9e9b45b8147","tags":["rocketmq"],"url":"/post/rocketmq%E7%9A%84%E6%B6%88%E8%B4%B9%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"content":"架构设计 消息中间件的设计思路一般基于主题的订阅发布机制，消息生产者（ Producer）发送某一主题的消息到消息服务器，消息服务器负责该消息的","lvl0":"路由中心NameServer","lvl1":["rocketmq"],"lvl2":"摘要","objectID":"d1b5af78c867dcef22c3ebaf034a5253","tags":["rocketmq"],"url":"/post/%E8%B7%AF%E7%94%B1%E4%B8%AD%E5%BF%83nameserver/"},{"content":"前言 RmqClient是客户端各种类型的Consumer和Producer的底层类。这个类首先从NameServer获取并保存各种配置信息，","lvl0":"RmqClient源码分析","lvl1":["rocketmq"],"lvl2":"摘要","objectID":"719f064807ca3ad0a0e5b1fc70da3687","tags":["rocketmq"],"url":"/post/rmqclient%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"content":"整体流程 NewPushConsumer 创建pushConsumer对象.配置负载均衡策略. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39","lvl0":"PushConsumer源码分析","lvl1":["rocketmq"],"lvl2":"摘要","objectID":"6bd0bb79cb1ce7f3387b5c67ab083432","tags":["rocketmq"],"url":"/post/pushconsumer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"content":"在Broker端进行消息过滤，可以减少无效消息发送到Consumer，少占用网络带宽从而提高吞吐量。Broker端有三种方式进行消息过滤。 消","lvl0":"rocketmq的消息过滤机制","lvl1":["rocketmq"],"lvl2":"摘要","objectID":"a6220bd0938773e977c32adcfd66267b","tags":["rocketmq"],"url":"/post/rocketmq%E7%9A%84%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4%E6%9C%BA%E5%88%B6/"},{"content":"事务消息 RocketMQ的事务消息，是指发送消息事件和其他事件需要同时成功或同时失败。比如银行转账，A银行的某账户要转一万元到B银行的某账户","lvl0":"rocketmq的事务消息","lvl1":["rocketmq"],"lvl2":"摘要","objectID":"5546b43914827806c7f3ec3219e3cb1a","tags":["rocketmq"],"url":"/post/rocketmq%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/"},{"content":"定时消息 定时消息是指消息发送到Broker后，并不立即被消费者消费而是要等到特定的时间后才能被消费，RocketMQ并不支持任意的时间精度，","lvl0":"rocketmq的定时消息","lvl1":["rocketmq"],"lvl2":"摘要","objectID":"35de8404329879ef02ea7ca738e28157","tags":["rocketmq"],"url":"/post/rocketmq%E7%9A%84%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF/"},{"content":"顺序消息 RocketMQ支持局部消息顺序消费，可以确保同一个消息消费队列中的消息被顺序消费，如果需要做到全局顺序消费则可以将主题配置成一一个","lvl0":"rocketmq的顺序消息","lvl1":["rocketmq"],"lvl2":"摘要","objectID":"0af759a11b658b14570b62f97b1dacfc","tags":["rocketmq"],"url":"/post/rocketmq%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF/"},{"content":"实际运行中的系统，难免会遇到重新消费某条消息、跳过一段时间内的消息等情况。这些异常情况的处理，都和Offset有关。 首先来明确一下Offse","lvl0":"Rocketmq中的offset","lvl1":["rocketmq"],"lvl2":"摘要","objectID":"29ef8b787755db727d853fa08f67b00c","tags":["rocketmq"],"url":"/post/rocketmq%E4%B8%AD%E7%9A%84offset/"},{"content":"前言 RocketMQ支持3种消息发送方式:同步(sync)、异步(async)、单向 (oneway) 同步:发送者向MQ执行发送消息API时,同步等待,直到","lvl0":"rocketmq的消息发送","lvl1":["rocketmq"],"lvl2":"摘要","objectID":"3481f7f85534646edd3641ee72ae793d","tags":["rocketmq"],"url":"/post/rocketmq%E7%9A%84%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/"},{"content":"概述 消息消费以组的模式开展，一个消费组内可以包含多个消费者，每一个消费组可订阅多个主题，消费组之间有集群模式与广播模式两种消费模式。集群模式","lvl0":"rocketmq的消息消费","lvl1":["rocketmq"],"lvl2":"摘要","objectID":"237bde8655741f680a782e92a2b91e35","tags":["rocketmq"],"url":"/post/rocketmq%E7%9A%84%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9/"},{"content":"准备工作 在搭建之前，我们需要做一些准备工作，这里我们需要使用 docker 搭建服务，所以需要提前安装 docker。此外，由于 rocketmq 需要部署 broker 与 nameserver ，考虑到分开","lvl0":"基于docker搭建rocketmq环境","lvl1":["rocketmq"],"lvl2":"摘要","objectID":"79295a777e2b802c3c1a3b1aad325a0d","tags":["rocketmq"],"url":"/post/%E5%9F%BA%E4%BA%8Edocker%E6%90%AD%E5%BB%BArocketmq%E7%8E%AF%E5%A2%83/"},{"content":"预置条件 我们需要下面准备工作： 安装protobuf: 1 2 3 4 5 6 7 8 9 mkdir tmp cd tmp git clone https://github.com/google/protobuf cd protobuf ./autogen.sh ./configure make make check sudo make install 安装插件 1 2 go get -u github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway go get -u github.com/micro/protobuf/protoc-gen-go Greeter Service 例子","lvl0":"Go-Micro使用:实现GRPC网关","lvl1":["Go-Micro"],"lvl2":"摘要","objectID":"61dd4b94e94afcea019992b4c58b73c3","tags":["Go-Micro"],"url":"/post/go-micro%E4%BD%BF%E7%94%A8%E5%AE%9E%E7%8E%B0grpc%E7%BD%91%E5%85%B3/"},{"content":"日志中间件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65","lvl0":"Go-Micro使用:客户端中间件","lvl1":["Go-Micro"],"lvl2":"摘要","objectID":"649de47146b8c43786fc7bbb9a0d03c5","tags":["Go-Micro"],"url":"/post/go-micro%E4%BD%BF%E7%94%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"content":"proto hello.proto 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 syntax = \u0026#34;proto3\u0026#34;; package go.micro.srv.greeter; service Say { rpc Hello(Request) returns (Response) {} } message Request { string name = 1; } message Response { string msg = 1; } 执行命令: 1 protoc --proto_path=. --micro_out=. --go_out=. hello.proto 生成代码: hello.pb.go: 1 2 3 4 5","lvl0":"Go-Micro使用:构建GRPC服务端与客户端","lvl1":["Go-Micro"],"lvl2":"摘要","objectID":"26059593bf125609bcccb6ca34335274","tags":["Go-Micro"],"url":"/post/go-micro%E4%BD%BF%E7%94%A8%E6%9E%84%E5%BB%BAgrpc%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"content":"服务注册 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package main import ( \u0026#34;github.com/micro/go-micro/v2/registry\u0026#34; \u0026#34;github.com/micro/go-micro/v2/registry/etcd\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/micro/go-micro/v2/web\u0026#34; ) type Say struct{} func (s *Say) Anything(c *gin.Context) { log.Print(\u0026#34;Received Say.Anything","lvl0":"Go-Micro使用:HTTP服务注册与发现","lvl1":["Go-Micro"],"lvl2":"摘要","objectID":"137bef352583e3f5cfcc4e05f3b567f1","tags":["Go-Micro"],"url":"/post/go-micro%E4%BD%BF%E7%94%A8http%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package main import ( \u0026#34;log\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/micro/go-micro/v2/web\u0026#34; ) type Say struct{} func (s *Say) Anything(c *gin.Context) { log.Print(\u0026#34;Received Say.Anything API request\u0026#34;) c.JSON(200, map[string]string{ \u0026#34;message\u0026#34;: \u0026#34;Hi, this is the Greeter","lvl0":"Go-Micro使用:构建HTTP服务","lvl1":["Go-Micro"],"lvl2":"摘要","objectID":"eef9dbb2c2e688a6d146ed89063fc988","tags":["Go-Micro"],"url":"/post/go-micro%E4%BD%BF%E7%94%A8%E6%9E%84%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1/"},{"content":"前言 如果你是一个 Go 开发者，go-kit 为开发者提供了一套抽象，包和接口，这样你实现的服务就可以标准化。 我想开始一个使用 go-kit 工具的深入教程。我们","lvl0":"GoKit脚手架:GoKit-CLI","lvl1":["GoKit"],"lvl2":"摘要","objectID":"6bdd5748b1abd288ef762f060a93a026","tags":["GoKit"],"url":"/post/gokit%E8%84%9A%E6%89%8B%E6%9E%B6gokit-cli/"},{"content":"为什么要使用分片集群？ 数据容量日益增大，访问性能日渐降低，怎么破？ 新品上线异常火爆，如何支撑更多的并发用户？ 单库已有10TB数据，恢复需要1","lvl0":"MongoDB分片集群机制及原理","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"9a7ccacf349c881f276a57b17d39acba","tags":["MongoDB"],"url":"/post/mongodb%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"content":"复制集的作用 MongoDB复制集的主要意义在于实现服务高可用. 它的实现依赖于两个方面的功能： 数据写入时将数据迅速复制到另一个独立节点上. 在接","lvl0":"MongoDB复制集机制及原理","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"492dc621c9775122c4345adbeba68df5","tags":["MongoDB"],"url":"/post/mongodb%E5%A4%8D%E5%88%B6%E9%9B%86%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"content":"前言 当涉及MongoDB时，一个经常被问到的问题是“我如何在MongoDB中为我的应用程序构造模式（schema）？”老实说，这要看情况而定","lvl0":"MongoDB的模式构建","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"424dd653cd22131b16a469bab685adf7","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E6%A8%A1%E5%BC%8F%E6%9E%84%E5%BB%BA/"},{"content":"三部曲 MongoDB文档模型设计三部曲为基础建模,工况细化,套用设计模式: 基础建模 找到对象:根据概念模型或者业务需求推导出逻辑模型 明确关系:","lvl0":"MongoDB的文档模型设计三部曲","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"cc7c20f212a2d841fc07cd0c38b42947","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E6%96%87%E6%A1%A3%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E4%B8%89%E9%83%A8%E6%9B%B2/"},{"content":"Session Session 是 MongoDB 3.6 版本引入的概念，引入这个特性主要就是为实现多文档事务做准备。Session 本质上就是一个「上下文」。 在以前的版本，MongoDB 只","lvl0":"MongoDB的事务实现解析","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"0e669d07aa98a2b89dec7f01fde7e772","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90/"},{"content":"前言 MongoDB虽然已经在4.2开始全面支持了多文档事务，但并不代表大家应该毫无节制地使用它。相反，对事务的使用原则应该是：能不用尽量不用","lvl0":"MongoDB的事务机制介绍","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"d44ecd590102778905bdf7c549352e02","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D/"},{"content":"综述 在读取数据的过程中我们需要关注以下两个问题 从哪里读？关注数据节点位置 什么样的数据可以读？关注数据的隔离性 第一个问题是是由 readPreference 来解決 第二个问","lvl0":"MongoDB的ReadConcern","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"8f9d1b20d812481ace5d58608a16722b","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84readconcern/"},{"content":"WriteConcern write Concern 決定一个写操作落到多少个节点上オ算成功。包括以下3个字段: { w: \u0026lt;value\u0026gt;, j: \u0026lt;boolean\u0026gt;, wtimeout: \u0026lt;number\u0026gt; } MongoDB支持的WriteConncern选项如下 w选项","lvl0":"MongoDB的WriteConcern","lvl1":["MongoDB"],"lvl2":"摘要","objectID":"6e1dafb06cb9cfc584dfec6d0477d508","tags":["MongoDB"],"url":"/post/mongodb%E7%9A%84writeconcern/"},{"content":"kingshard SQL黑名单功能介绍 应用场景介绍 在kingshard开源之后，有用户多次提到能不能在kingshard中加入SQL黑名单机制，让kings","lvl0":"Kingshard的SQL黑名单功能介绍","lvl1":["Kingshard"],"lvl2":"摘要","objectID":"a1ca6acb881eea538be2189f7dedcde3","tags":["Kingshard"],"url":"/post/kingshard%E7%9A%84sql%E9%BB%91%E5%90%8D%E5%8D%95%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/"},{"content":"如何使用ks+lvs实现完美集群 前言 很多ks的用户会问到ks如何配合LVS做流量切换?ks如何配合keepalived做高可用?ks如何做到","lvl0":"Kingshard集群与监控","lvl1":["Kingshard"],"lvl2":"摘要","objectID":"090860a5f94e4ea828afff6eb30aa02e","tags":["Kingshard"],"url":"/post/kingshard%E9%9B%86%E7%BE%A4%E4%B8%8E%E7%9B%91%E6%8E%A7/"},{"content":"管理端命令 kingshard的管理端口复用了工作端口，通过特定的关键字来标示，目前支持对后端DB常用的管理操作。kingshard支持了多用","lvl0":"Kingshard管理端介绍","lvl1":["Kingshard"],"lvl2":"摘要","objectID":"c74724b996b6868cf095a739be71038a","tags":["Kingshard"],"url":"/post/kingshard%E7%AE%A1%E7%90%86%E7%AB%AF%E4%BB%8B%E7%BB%8D/"},{"content":"应用场景 现在很多互联网公司还是在大量使用MySQL来存储各种类型的关系型数据。随着访问量和数据量的增长，开发者不得不考虑一些MySQL相关的","lvl0":"Kingshard使用指南","lvl1":["Kingshard"],"lvl2":"摘要","objectID":"c6de84a838cea35d94dfb9fe174bc8e5","tags":["Kingshard"],"url":"/post/kingshard%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"content":"kingshard简介 kingshard是一个由Go开发高性能MySQL Proxy项目，kingshard在满足基本的读写分离的功能上，致力","lvl0":"Kingshard架构设计和功能实现","lvl1":["Kingshard"],"lvl2":"摘要","objectID":"9e1de81f1edd5767c11fc0144ee70252","tags":["Kingshard"],"url":"/post/kingshard%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"},{"content":"什么是二维码 二维条码是指在一维条码的基础上扩展出另一维具有可读性的条码，使用黑白矩形图案表示二进制数据，被设备扫描后可获取其中所包含的信息。","lvl0":"Go生成和识别二维码","lvl1":["Go"],"lvl2":"摘要","objectID":"bd3e9173e3f0945186c25c8aef4b657b","tags":["go"],"url":"/post/go%E7%94%9F%E6%88%90%E5%92%8C%E8%AF%86%E5%88%AB%E4%BA%8C%E7%BB%B4%E7%A0%81%E4%B8%8E%E6%9D%A1%E5%BD%A2%E7%A0%81/"},{"content":"service.go 1 2 3 4 5 6 7 8 9 10 11 12 13 type Service interface { Status(ctx context.Context) (string, error) } type statusService struct{} func NewService() Service { return statusService{} } func (statusService) Status(ctx context.Context) (string, error) { return \u0026#34;ok\u0026#34;, nil } endpoints.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type statusRequest struct{} type statusResponse","lvl0":"GoKit使用:结合Gin框架","lvl1":["GoKit"],"lvl2":"摘要","objectID":"8f4a8b2fd148c23d94292d8eade05414","tags":["Gokit"],"url":"/post/gokit%E4%BD%BF%E7%94%A8%E7%BB%93%E5%90%88gin%E6%A1%86%E6%9E%B6/"},{"content":"架构 基于Go kit的应用程序体系结构包含三个主要组件： Transport Endpoint Service Transport 当您构建基于微服务的分布式系统时，服务通常使用诸如HTTP或gRPC之类的具体","lvl0":"GoKit使用:三层架构","lvl1":["GoKit"],"lvl2":"摘要","objectID":"17c95071bd92989324f2fa4e40e3f7d7","tags":["Gokit"],"url":"/post/gokit%E4%BD%BF%E7%94%A8%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/"},{"content":"分支提交错误 有时我们会遇到这种情况：我们从develop 分支新建一个名为feat/home 分支去做A功能，然后由于一些其他原因A 功能需要延后","lvl0":"Git撤销操作总结","lvl1":["Git"],"lvl2":"摘要","objectID":"6b5cc353807c696be3f290d2c942528b","tags":["Git"],"url":"/post/git%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"},{"content":"软件产品环境 一个软件产品从开发到用户使用都涉及哪些环境？ 开发环境、测试环境、回归环境、预发布环境、生产环境。 下面说说我个人对这些环境的理解：","lvl0":"服务发布策略","lvl1":["软件工程"],"lvl2":"摘要","objectID":"1278b555804f99779b380075c47bda8b","tags":["软件工程"],"url":"/post/%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E7%AD%96%E7%95%A5/"},{"content":"简介 Gitflow是一个基于feature分支管理的版本发布方案。它是由Vincent Driessen设计研发，开源项目地址gitflow-","lvl0":"Git工作流:Git-Flow","lvl1":["Git"],"lvl2":"摘要","objectID":"4217e41ef507a862a8fdfbc68672ad1d","tags":["Git"],"url":"/post/git%E5%B7%A5%E4%BD%9C%E6%B5%81git-flow/"},{"content":"工作流 WorkFlow 的字面意思，工作流，即工作流程。在分支篇里，有说过这样的话：因为有分支的存在，才构成了多工作流的特色。事实的确如此，因为项目开发中，","lvl0":"Git工作流对比","lvl1":["Git"],"lvl2":"摘要","objectID":"ef1f0f6bf92a2bf1daa98f841bccb9cd","tags":["Git"],"url":"/post/git%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AF%B9%E6%AF%94/"},{"content":"背景 在游戏开发过程中,设计资源占用了很大一部分空间. 像png,psd等文件是二进制(blob)的,体积也很庞大. 但git的diff/patc","lvl0":"Git LFS操作指南","lvl1":["Git"],"lvl2":"摘要","objectID":"e8aa8dddf4a8a2564b82506d8ee681bb","tags":["Git","LFS"],"url":"/post/git-lfs%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/"},{"content":"介绍 让 Go 更强大的原因之一莫过于它的 GODEBUG 工具，GODEBUG 的设置可以让 Go 程序在运行时输出调试信息，可以根据你的要求很直观的看到你想要的调度器或","lvl0":"Go调试器:GODEBUG","lvl1":["Go调优"],"lvl2":"摘要","objectID":"c92e625af6ef4aae23551526ba355a1d","tags":["Go"],"url":"/post/go%E8%B0%83%E8%AF%95%E5%99%A8godebug/"},{"content":"Stack Trace表示堆栈跟踪，这是一个或多个堆栈帧的有序的集合。在程序出现panic的时候你会看到控制台有Stack Trace信息打印出来。 介绍","lvl0":"堆栈跟踪:Stack-Trace","lvl1":["Go调优"],"lvl2":"摘要","objectID":"3f7514ae38b4eeae22ab0efc55c99ac5","tags":["Go"],"url":"/post/%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AAstack-trace/"},{"content":"trace 你有没有考虑过，你的goroutines是如何被go的runtime系统调度的？是否尝试理解过为什么在程序中增加了并发，但并没有给它带来更","lvl0":"Go性能分析工具trace介绍","lvl1":["Go调优"],"lvl2":"摘要","objectID":"a9c913b878ff4f724e53700790bcca8d","tags":["Go"],"url":"/post/go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7trace%E4%BB%8B%E7%BB%8D/"},{"content":"前言 关于Go的内存泄露有这么一句话不知道你听过没有： 10次内存泄露，有9次是goroutine泄露。 我所解决的问题，也是goroutine泄","lvl0":"Pprof实战:解决内存泄露","lvl1":["Go调优"],"lvl2":"摘要","objectID":"85a7aef258b3f8f98d7e17ac9fdac49b","tags":["Go"],"url":"/post/pprof%E5%AE%9E%E6%88%98%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"},{"content":"前言 如果要说在 golang 开发过程进行性能调优，pprof 一定是一个大杀器般的工具。但在网上找到的教程都偏向简略，难寻真的能应用于实战的教程。这也无可","lvl0":"Pprof实战:从零开始排查炸弹程序","lvl1":["Go调优"],"lvl2":"摘要","objectID":"a30e7f40c217d949444b4ef6eca7ca7c","tags":["Go"],"url":"/post/pprof%E5%AE%9E%E6%88%98%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8E%92%E6%9F%A5%E7%82%B8%E5%BC%B9%E7%A8%8B%E5%BA%8F/"},{"content":"背景 在Scala Days 2011，Robert Hundt 发表了一篇名为 Loop Recognition in C++/Java/Go/Scala 的论文。 该论文实现了一种特定的循环查找算法，例如您可以在C++，Go，Jav","lvl0":"Pprof实战:Profiling Go Programs","lvl1":["Go调优"],"lvl2":"摘要","objectID":"e47798736d7c5f4c41e0463d3c16a2b7","tags":["Go"],"url":"/post/pprof%E5%AE%9E%E6%88%98profiling-go-programs/"},{"content":"这里使用火焰图复现 logger 100% CPU 问题。 先看现象， 用 wrk 压测 logger 1 wrk -t1 -c100 -d30 --script=post.lua \u0026#39;http://127.0.0.1:4500/marco/log\u0026#39; 查看 CPU 占用情况 采集 30s 的 CPU profile 火焰图 图中红色标记部分 startSink 函数中 runtime.selectgo 消耗了大量 CPU，","lvl0":"Pprof实战:利用火焰图优化代码","lvl1":["Go调优"],"lvl2":"摘要","objectID":"edc6277df0c0cd22890df1b33e682c0c","tags":["Go"],"url":"/post/pprof%E5%AE%9E%E6%88%98%E5%88%A9%E7%94%A8%E7%81%AB%E7%84%B0%E5%9B%BE%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/"},{"content":"简介 Go 运行时的分析接口存在于 runtime/pprof 包中。 runtime/pprof 是一个非常低级的工具，由于历史原因，不同类型 profile 的接口并不统一,而且使用起来还不是太方便，例如：输出数据","lvl0":"Pprof替代库:pkg Profile","lvl1":["Go调优"],"lvl2":"摘要","objectID":"777ea482ab528d9d308f4fafc1293846","tags":["Go"],"url":"/post/pprof%E6%9B%BF%E4%BB%A3%E5%BA%93pkg-profile/"},{"content":"示例代码 我们写一个程序来计算单词数量： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;unicode\u0026#34; ) func","lvl0":"pprof实战:利用runtime-pprof优化代码","lvl1":["Go调优"],"lvl2":"摘要","objectID":"e8c559771deb6c2df2856938bf6cc628","tags":["Go"],"url":"/post/pprof%E5%AE%9E%E6%88%98%E5%88%A9%E7%94%A8runtime-pprof%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/"},{"content":"将多个小对象合并成一个大的对象 减少不必要的指针间接引用，多使用copy引用 例如使用bytes.Buffer代替*bytes.Buffer，因","lvl0":"Go优化建议","lvl1":["Go规范"],"lvl2":"摘要","objectID":"a9ba55d272a94e30d5c22791b85c1954","tags":["Go"],"url":"/post/go%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE%E6%B1%87%E6%80%BB/"},{"content":"示例代码:数独 sodoku.go: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62","lvl0":"pprof实战:结合benchmark优化代码","lvl1":["Go调优"],"lvl2":"摘要","objectID":"6051e53aadfdbd2858f1a1e176241333","tags":["Go"],"url":"/post/pprof%E5%AE%9E%E6%88%98%E7%BB%93%E5%90%88benchmark%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/"},{"content":"简介 什么是pprof 代码上线前，我们通过压测可以获知系统的性能，例如每秒能处理的请求数，平均响应时间，错误率等指标。这样，我们对自己服务的性","lvl0":"Go性能分析工具pprof介绍","lvl1":["Go调优"],"lvl2":"摘要","objectID":"f8347bfaeafc84236649aa174125fdfa","tags":["Go"],"url":"/post/go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7pprof%E4%BB%8B%E7%BB%8D/"},{"content":"go test 命令参数 Go 测试工具 go test，包括各种子命令、参数之类的内容。你可以通过 go test -h 查看帮助信息。 其基本形式是： 1 go test [build/test flags] [packages] [build/test flags \u0026amp; test binary flags] 执行 go","lvl0":"Go中的testing包解析","lvl1":["Go标准库"],"lvl2":"摘要","objectID":"a4cb91dfb410283033e3b4b04774a14a","tags":["Go","testing"],"url":"/post/go%E4%B8%AD%E7%9A%84testing%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"content":"Constants DefaultRemoteAddr是默认的远端地址。如果ResponseRecorder未显式的设置该属性，RemoteAddr方法就会返","lvl0":"Package:httptest(1.13)","lvl1":["Go标准库"],"lvl2":"摘要","objectID":"30f8d3d177329d0926c89c07ecf1d8c5","tags":["Go标准库"],"url":"/post/packagehttptest1.13/"},{"content":"简介 httpexpect基本上，是一组基于HTTP请求和基于HTTP的断言( 例如HTTP响应和负载)，位于net/HTTP和几个实用程序包之","lvl0":"RESTAPI测试框架:httpexpect","lvl1":["Go测试"],"lvl2":"摘要","objectID":"8e49a91cea2f785bfc08ac4a92aedd51","tags":["Go","httpexpect"],"url":"/post/restapi%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6httpexpect/"},{"content":"简介 sqlmock是一个实现sql/driver的模拟库。它有一个唯一的目的:在测试中模拟任何sql驱动程序行为，而无需真正的数据库连接。它","lvl0":"Sql模拟库:go-sqlmock","lvl1":["Go测试"],"lvl2":"摘要","objectID":"9aba344ad373f1ff8d04d288c2685093","tags":["Go","go-sqlmock"],"url":"/post/sql%E6%A8%A1%E6%8B%9F%E5%BA%93go-sqlmock/"},{"content":"介绍 gomonkey 是 golang 的一款打桩框架，目标是让用户在单元测试中低成本的完成打桩，从而将精力聚焦于业务功能的开发。gomonkey 接口友好，功能强大，目前","lvl0":"打桩框架:gomonkey","lvl1":["Go测试"],"lvl2":"摘要","objectID":"6cd7bb5a4c61880a7983d47741e6b6ae","tags":["Go","gomonkey"],"url":"/post/%E6%89%93%E6%A1%A9%E6%A1%86%E6%9E%B6gomonkey/"},{"content":"前言 我们已经知道： 全局变量可通过GoStub框架打桩 过程可通过GoStub框架打桩 函数可通过GoStub框架打桩 interface可通过Go","lvl0":"猴子补丁:monkey","lvl1":["Go测试"],"lvl2":"摘要","objectID":"42110d1a5889693be057a1f10539012b","tags":["Go","monkey"],"url":"/post/%E7%8C%B4%E5%AD%90%E8%A1%A5%E4%B8%81monkey/"},{"content":"序言 GoMock是由Golang官方开发维护的测试框架，实现了较为完整的基于interface的Mock功能，能够与Golang内置的tes","lvl0":"interface的mock:gomock","lvl1":["Go测试"],"lvl2":"摘要","objectID":"fa6981f1ca42a6287c66fbd807a6486a","tags":["Go","gomock"],"url":"/post/interface%E7%9A%84mockgomock/"},{"content":"简介 gostub用于在测试中添加变量，并在测试运行后重置原始值。 这可以用于对静态变量和静态函数进行打桩。要打桩静态变量，请使用stub函数：","lvl0":"变量与函数打桩:gostub","lvl1":["Go测试"],"lvl2":"摘要","objectID":"5f34087924d7d08a9ecb8b80868b6f9a","tags":["Go","gostub"],"url":"/post/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E6%89%93%E6%A1%A9gostub/"},{"content":"前言 “测试金字塔”是一个比喻，它告诉我们要把软件测试按照不同粒度来分组。它也告诉我们每个组应该有多少测试。虽然测试金字塔的概念已经存在了一段","lvl0":"测试金字塔实战","lvl1":["软件工程"],"lvl2":"摘要","objectID":"3e4119a160f7d4c8bb7392cc91752d9e","tags":["测试金字塔"],"url":"/post/%E6%B5%8B%E8%AF%95%E9%87%91%E5%AD%97%E5%A1%94%E5%AE%9E%E6%88%98/"},{"content":"GoConvey简介 GoConvey是一款针对Golang的测试框架，可以管理和运行测试用例，同时提供了丰富的断言函数，并支持很多 Web 界面特性","lvl0":"使用goconvey简化BDD单元测试","lvl1":["Go测试"],"lvl2":"摘要","objectID":"a676097047f6bf640e757bac2c2bc410","tags":["Go","goconvey"],"url":"/post/%E4%BD%BF%E7%94%A8goconvey%E7%AE%80%E5%8C%96bdd%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"content":"简介 testify的功能包括： Easy assertions Mocking Testing suite interfaces and functions assert 该assert软件包提供了一些有用的方法，使您可以在Go中编写更好的测试代码。 打印友好，易于","lvl0":"使用testify简化TDD测试","lvl1":["Go测试"],"lvl2":"摘要","objectID":"2e9d4d6adcb262841972e6dd063d35c4","tags":["Go","testify"],"url":"/post/%E4%BD%BF%E7%94%A8testify%E7%AE%80%E5%8C%96tdd%E6%B5%8B%E8%AF%95/"},{"content":"前言 GJSON是一个Go包，它提供了一种快速，简单的方法来从json文档中获取值。它具有诸如单行检索，点符号路径，迭代和解析json行之类的","lvl0":"Go语言快速解析JSON:gjson","lvl1":["Go"],"lvl2":"摘要","objectID":"fadf9cc640a5f7f58343018870c3b354","tags":["gjson"],"url":"/post/go%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E8%A7%A3%E6%9E%90jsongjson/"},{"content":"前言 如果你关注软件开发最佳实践方面的话题，你肯定听说过测试驱动开发(TDD - Test Driven Development) 和行为驱动开发(BDD - Behavior Driven Development)。这篇","lvl0":"TDD与BDD","lvl1":["软件工程"],"lvl2":"摘要","objectID":"38023c367c819fb7c8958e8c4429e680","tags":["TDD","BDD"],"url":"/post/tdd%E4%B8%8Ebdd/"},{"content":"快速使用 先安装： 1 go get github.com/go-playground/validator/v10 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/go-playground/validator/v10\u0026#34; ) type User struct { Name string `validate:\u0026#34;min=6,max=10\u0026#34;` Age int `validate:\u0026#34;min=1,max=100\u0026#34;` } func main() { validate := validator.New() u1 := User{Name: \u0026#34;lidajun\u0026#34;, Age: 18} err := validate.Struct(u1) fmt.Println(err)","lvl0":"Go中的参数验证:validator","lvl1":["GO"],"lvl2":"摘要","objectID":"fac2b7ce7a763d5e9b803358727ce90d","tags":["validator","GO"],"url":"/post/go%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81validator/"},{"content":"标准库 package validator import \u0026ldquo;gopkg.in/go-playground/validator.v9\u0026rdquo; Package validator 基于标签对结构和单个字段实现值验证. 它还可以处理嵌套结构的跨字段和跨结构验证，并具有深入研究任何类型的数组和映射的能力。 查","lvl0":"package:validator.v9","lvl1":["Go标准库"],"lvl2":"摘要","objectID":"0f4a8f3a56b177d0749ecfcb4ed2986b","tags":["Go标准库","validator"],"url":"/post/packagevalidator.v9/"},{"content":"做 Web 应用程序时，经常需要对用户上传的文件类型做一下检查，比如判断上传的是否是 png 、gif、jpg 等图片类型，还是 pdf。并针对不同的类型做一些","lvl0":"Go语言检测一个文件的类型","lvl1":["Go"],"lvl2":"摘要","objectID":"872972af1ee13d20a266b44c554222a7","tags":["Content-Type"],"url":"/post/go%E8%AF%AD%E8%A8%80%E6%A3%80%E6%B5%8B%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B/"},{"content":"Content-Disposition Content-Disposition 有两种应用场景。 用在HTTP响应头中 场景一是用在HTTP的响应头中，指示响应的内容该以何种形式展示。是以内联的形式（即网页或者页面的一部","lvl0":"Header:Content-Disposition","lvl1":["HTTP"],"lvl2":"摘要","objectID":"eaa7e51ab154ca36fabb9e76f7bbcecd","tags":["Content-Disposition","HTTP"],"url":"/post/headercontent-disposition/"},{"content":"XSS 攻击的介绍 在开始本文之前，我们先提出一个问题，请判断以下两个说法是否正确： XSS 防范是后端 RD（研发人员）的责任，后端 RD 应该在所有用户提交数据","lvl0":"如何防止XSS攻击","lvl1":["网络"],"lvl2":"摘要","objectID":"d5c448eb225aee826a24b13ede01bfc4","tags":["XSS"],"url":"/post/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2xss%E6%94%BB%E5%87%BB/"},{"content":"CSRF攻击 CSRF漏洞的发生 相比XSS，CSRF的名气似乎并不是那么大，很多人都认为CSRF“不那么有破坏性”。真的是这样吗？ 接下来有请小","lvl0":"如何防止CSRF攻击","lvl1":["网络"],"lvl2":"摘要","objectID":"d25d0b6e87f41a6212570f728480a971","tags":["CSRF"],"url":"/post/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2csrf%E6%94%BB%E5%87%BB/"},{"content":"jwt-go 编写jwt工具 我们需要编写一个jwt的工具，我们在pkg下的util目录新建jwt.go，写入文件内容： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17","lvl0":"如何在Go中使用JWT","lvl1":["Go"],"lvl2":"摘要","objectID":"d96c30798ad777ba2dc7a40db503ba34","tags":["Go","JWT"],"url":"/post/%E5%A6%82%E4%BD%95%E5%9C%A8go%E4%B8%AD%E4%BD%BF%E7%94%A8jwt/"},{"content":"需求 给定一个xxxx-xx-xx日期，计算为星期几。 设定 1 2 3 4 int y; //年 int m; //月 int d; //日 int w; //周几 从 公元0年1月1日星期日 开始 推导 对","lvl0":"判断星期几:基姆拉尔森计算公式","lvl1":["算法"],"lvl2":"摘要","objectID":"dc6e04df1d2020d8d89ca0675b5ae51d","tags":null,"url":"/post/%E5%88%A4%E6%96%AD%E6%98%9F%E6%9C%9F%E5%87%A0%E5%9F%BA%E5%A7%86%E6%8B%89%E5%B0%94%E6%A3%AE%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F/"},{"content":"概述 点赞功能在很多系统中都有，但别看功能小，想要做好需要考虑的东西还挺多的。 点赞、取消点赞是高频次的操作，若每次都读写数据库，大量的操作会影","lvl0":"点赞系统的设计","lvl1":["架构"],"lvl2":"摘要","objectID":"75df1d92a8f81e9e4fc511e3f78f07dc","tags":["架构"],"url":"/post/%E7%82%B9%E8%B5%9E%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/"},{"content":"swagger Swagger是一个简单但功能强大的API表达工具。它具有地球上最大的API工具生态系统，数以千计的开发人员，使用几乎所有的现代编程语言，","lvl0":"Go如何生成swagger文档","lvl1":["Go"],"lvl2":"摘要","objectID":"6f6b2c0b687129737e6d050873318a69","tags":["go-swagger"],"url":"/post/go%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90swagger%E6%96%87%E6%A1%A3/"},{"content":"引言 我们在使用Golang（Go语言）开发的过程中，会通过经常通过调试的方式查找问题的原因，解决问题，尤其是当遇到一个很棘手的问题的时候，就","lvl0":"Go强大的调试日志打印工具:go:Spew","lvl1":["Go"],"lvl2":"摘要","objectID":"4a9896a9afcbd9ba490a1ac5d912d446","tags":["Go"],"url":"/post/go%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%B0%83%E8%AF%95%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E5%B7%A5%E5%85%B7go-spew/"},{"content":"Go-Python 环境配置 Python ：确保Python正确安装，所谓正确安装，就是在系统中能找到libpython.so(dylib)，找到Python.h。一般l","lvl0":"Go调用Python","lvl1":["Go"],"lvl2":"摘要","objectID":"2fc295ea9374647b8379a937cd43fe0e","tags":["Go"],"url":"/post/go%E8%B0%83%E7%94%A8python/"},{"content":"执行:Do与Go 同步执行，直接调用Do方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48","lvl0":"hystrix-go源码剖析","lvl1":["Go"],"lvl2":"摘要","objectID":"d3eda706db03f74b04f4c8392380983f","tags":["hystrix"],"url":"/post/hystrix-go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"主要逻辑 Allow Allow 方法的调用链：lim.Allow() bool → lim.AllowN(time.Now(), 1) → lim.reserveN(now, n, 0).ok，因此 reserveN 方法的实现很关键 1 2 3 4 5 6 7 8 9 10 11 12 // Allow is shorthand for AllowN(time.Now(), 1). func (lim *Limiter)","lvl0":"time-rate源码剖析","lvl1":["Go"],"lvl2":"摘要","objectID":"a33a0a7bbcc5461bceeb3d69537d2b3e","tags":["Go"],"url":"/post/time-rate%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"限流 在开发中我们可能会遇到接口访问频次过高，这时候就需要做流量限制，你可能是用的 Nginx 这种 Web Server 来控制也可能是用了一些流行的类库实现。在分布式系统","lvl0":"单机限流算法总结","lvl1":["架构"],"lvl2":"摘要","objectID":"e97994762363ab913a039ee6604fc5e1","tags":["限流"],"url":"/post/%E5%8D%95%E6%9C%BA%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"content":"引言 熔断器是当依赖的服务已经出现故障时，为了保证自身服务的正常运行不再访问依赖的服务，防止雪崩效应.Hystrix断路器的工作原理是： 熔断器","lvl0":"Go中的熔断器:hystrix-Go","lvl1":["GO"],"lvl2":"摘要","objectID":"c1d51fd781a65d9b894706a07d3fc508","tags":["hystrix","go"],"url":"/post/go%E4%B8%AD%E7%9A%84%E7%86%94%E6%96%AD%E5%99%A8hystrix-go/"},{"content":"为什么需要关闭? 1 2 3 4 5 6 7 Body io.ReadCloser The http Client and Transport guarantee that Body is always non-nil, even on responses without a body or responses with a zero-length body. It is the caller\u0026#39;s responsibility to close Body. The default HTTP client\u0026#39;s Transport does not attempt to reuse HTTP/1.0 or HTTP/1.1 TCP connections (\u0026#34;keep-alive\u0026#34;) unless the Body is read to","lvl0":"为什么Response.Body需要被关闭","lvl1":["Go"],"lvl2":"摘要","objectID":"af478d410c9c0af70bda8c6eab3e17e1","tags":["Go"],"url":"/post/%E4%B8%BA%E4%BB%80%E4%B9%88response.body%E9%9C%80%E8%A6%81%E8%A2%AB%E5%85%B3%E9%97%AD/"},{"content":"服务端trace 增加trace代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //创建zipkin上报管理器 reporter := http.NewReporter(\u0026#34;http://localhost:9411/api/v2/spans\u0026#34;) //运行结束，关闭上报管理器的f","lvl0":"GoKit使用:链路追踪Zipkin","lvl1":["GoKit"],"lvl2":"摘要","objectID":"c4e98f9ea18b9e42ecb39af1b0132104","tags":["Gokit"],"url":"/post/gokit%E4%BD%BF%E7%94%A8%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AAzipkin/"},{"content":"引言 目前，几乎所有的研发人员每天都在跟API打交道：后端为实现业务不停的生产API，前端为实现产品功能不停的调用API。API已经成为前端与","lvl0":"GoKit使用:监控功能","lvl1":["GoKit"],"lvl2":"摘要","objectID":"fd8472cf0cd409d642d815df290e11de","tags":["Gokit"],"url":"/post/gokit%E4%BD%BF%E7%94%A8%E7%9B%91%E6%8E%A7%E5%8A%9F%E8%83%BD/"},{"content":"引言 限流器，从字面上理解就是用来限制流量，有时候流量突增(可预期的比如“双11”，不可预期的微博的热门话题等)，会将后端服务压垮，甚至直接宕","lvl0":"Go中的限流器time-rate","lvl1":["Go"],"lvl2":"摘要","objectID":"fcc7aa4a274c09e3425db24d9e35e628","tags":["Go"],"url":"/post/go%E4%B8%AD%E7%9A%84%E9%99%90%E6%B5%81%E5%99%A8time-rate/"},{"content":"限流 限流实现 gokit 基于go包 golang.org/x/time/rate 内置了一种实现. 本次实现基于gokit内建的类型endpoint.Middleware，该类型实际上是一个func","lvl0":"GoKit使用:熔断与限流","lvl1":["GoKit"],"lvl2":"摘要","objectID":"f5ebfa40671cc62bcef8fadc67496196","tags":["Gokit"],"url":"/post/gokit%E4%BD%BF%E7%94%A8%E7%86%94%E6%96%AD%E4%B8%8E%E9%99%90%E6%B5%81/"},{"content":"基础日志 Gokit有自身的基础日志模块,配置如下: 1 2 3 4 5 6 var logger log.Logger { logger = log.NewLogfmtLogger(os.Stderr) //错误输出到控制台 logger = log.With(logger, \u0026#34;ts\u0026#34;, log.DefaultTimestampUTC) logger = log.With(logger, \u0026#34;caller\u0026#34;, log.DefaultCaller) } 如果我们想要加入通用日","lvl0":"GoKit使用:日志功能","lvl1":["GoKit"],"lvl2":"摘要","objectID":"a7e5c128bd1db2211ed92bb7b09985de","tags":["Gokit"],"url":"/post/gokit%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD/"},{"content":"server 服务注册: 1、连接注册中心 2、注册当前服务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48","lvl0":"GoKit使用:注册发现","lvl1":["GoKit"],"lvl2":"摘要","objectID":"109f40cb15075dbb9b5c90c7963158e4","tags":["Gokit"],"url":"/post/gokit%E4%BD%BF%E7%94%A8%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0/"},{"content":"heap heap包提供了对任意类型（实现了heap.Interface接口）的堆操作。（最小）堆是具有“每个节点都是以其为根的子树中最小值”属性的","lvl0":"container包解析(1.13)","lvl1":["Go标准库"],"lvl2":"摘要","objectID":"bc3dc1aacc9d357e6111574fff89f6ba","tags":["Go标准库"],"url":"/post/container%E5%8C%85%E8%A7%A3%E6%9E%90-1-13/"},{"content":"引言 在软件系统中，“在一段时间后执行一个任务” 的需求比比皆是。比如： 客户端发起 HTTP 请求后，如果在指定时间内没有收到服务器的响应，则自动断开连接","lvl0":"Go实现层级时间轮","lvl1":["Go"],"lvl2":"摘要","objectID":"8ddb6a6db8283677a9f168f26a0ea856","tags":["Go","时间轮"],"url":"/post/go%E5%AE%9E%E7%8E%B0%E5%B1%82%E7%BA%A7%E6%97%B6%E9%97%B4%E8%BD%AE/"},{"content":"数据类型对应关系 时间类型的转换 修改DSN 构建 DSN 时增加 loc 指定时区，并区增加对时间的解析。打印出来的 uri： 1 xiaoju:@tcp(127.0.0.1:3306)/test?charset=utf8\u0026amp;loc=Asia%2FShanghai\u0026amp;parseTime=true 后面的 parseTime 必须要有，用法如下： 这样","lvl0":"Golang如何获取MySQL的各类型数据","lvl1":["Go"],"lvl2":"摘要","objectID":"8951695821f840b33fb646631f461acb","tags":["Go","Mysql"],"url":"/post/golang%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96mysql%E7%9A%84%E5%90%84%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE/"},{"content":"问题 看这样一个例子： 1 2 3 4 5 6 7 8 9 10 11 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { str := \u0026#34;/some/key\u0026#34; fmt.Println(strings.TrimLeft(str, \u0026#34;/some\u0026#34;)) } 1 2 3 key Program exited. 上例有正确返回,再看一例: 1 2 3 4 5 6 7 8 9 10 11 package main import","lvl0":"Go中TrimLeft和TrimPrefix的区别","lvl1":["Go"],"lvl2":"摘要","objectID":"2d5fb7b4e8a21d12ff7a54b04dddc0f0","tags":["Go"],"url":"/post/go%E4%B8%ADtrimleft%E5%92%8Ctrimprefix%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"content":"定时器:timer time包中有两个函数可以帮我们初始化 time.Timer （类型） 在高性能场景下，不应该使用time.After，而应该使用New.Time","lvl0":"Go的timer和ticker用法","lvl1":["Go"],"lvl2":"摘要","objectID":"209c0b75ffc093b027fbda9d966b57b6","tags":["Go"],"url":"/post/go%E7%9A%84timer%E5%92%8Cticker%E7%94%A8%E6%B3%95/"},{"content":"前言 准确的时间对于任何一个正在运行的应用非常重要，但是在分布式系统中我们很难保证各个节点的绝对时间一致，哪怕通过 NTP 这种标准的对时协议也只能把","lvl0":"Go的timer源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"9820307d6adc97f5462f2e25d8d1cbe3","tags":["Go","计时器"],"url":"/post/go%E7%9A%84timer%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"Linux内核时钟系统和定时器实现 Linux 2.6.16之前，内核只支持低精度时钟，内核定时器的工作方式： 系统启动后，会读取时钟源设备(RTC, HP","lvl0":"Linux内核时钟系统和定时器实现","lvl1":["Linux内核"],"lvl2":"摘要","objectID":"e8d2f29b02151696fe502c582006e134","tags":["定时器"],"url":"/post/linux%E5%86%85%E6%A0%B8%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0/"},{"content":"理解定时器 很多场景会用到定时器，例如 使用 TCP 长连接时，客户端需要定时向服务端发送心跳请求。 财务系统每个月的月末定时生成对账单。 双 11 的 0 点，定时","lvl0":"单机定时器的实现方案","lvl1":["架构"],"lvl2":"摘要","objectID":"282e697905d4573a1d85171e39801191","tags":["定时器"],"url":"/post/%E5%8D%95%E6%9C%BA%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"},{"content":"导语 异步任务，是每一位开发者都遇到过的技术名词，在任何一个稍微复杂的后台系统中，异步任务总是无法避免的，而任务队列由于其松耦合、易扩展的特性","lvl0":"异步任务队列:machinery源码剖析","lvl1":["machinery"],"lvl2":"摘要","objectID":"6da26995c872c1e5edde7fa0a80cf473","tags":["machinery"],"url":"/post/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97machinery%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"Config machinery的配置结构体是config包中的Config类型,具体结构如下: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Config holds all configuration for our program type Config struct {","lvl0":"异步任务队列:machinery使用方法","lvl1":["machinery"],"lvl2":"摘要","objectID":"7289a5d60ad83979d637c82d6c918e1b","tags":["machinery"],"url":"/post/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97machinery%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"content":"引言 在开发中，往往会遇到一些关于延时任务的需求。例如\u0008 生成订单30分钟未支付，则自动取消 生成订单60秒后,给用户发短信 对上述的任务，我们给一","lvl0":"分布式延时任务方案","lvl1":["架构"],"lvl2":"摘要","objectID":"5ef9aa0c424a1fb39b77661e0908e482","tags":["分布式","延时任务"],"url":"/post/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%96%B9%E6%A1%88/"},{"content":"背景 在开发过程中，往往需要系统执行一些定时的任务，例如我们需要将数据进行迁移，又或者需要做一些数据的离线统计工作，这些都需要定时任务来进行处","lvl0":"Dcron:基于一致性哈希算法实现分布式定时任务","lvl1":["Go"],"lvl2":"摘要","objectID":"0135cffb54df4580a45c12b24125901d","tags":["Go","分布式","Dcron"],"url":"/post/dcron%E5%9F%BA%E4%BA%8E%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"content":"Cron表达式 基本cron格式: 1 2 3 4 5 6 7 8 # cron格式說明 # ┌──分鐘（0 - 59） # │ ┌──小時（0 - 23） # | │ ┌──日（1 - 31","lvl0":"cron库源码剖析","lvl1":["cron"],"lvl2":"摘要","objectID":"e93f0835fd39e7404e6b6ba37bb6d169","tags":["cron"],"url":"/post/cron%E5%BA%93%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68","lvl0":"Groupcache的一致性哈希算法","lvl1":["groupcache"],"lvl2":"摘要","objectID":"d2edccec7a6282f711305e88b9800082","tags":["groupcache"],"url":"/post/groupcache%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"},{"content":"Maglev一致性哈希算法 Maglev哈希算法来自 Google ， 在其2016年发布的一篇论文中[1]， 介绍了自2008年起服役的网络负载均衡器Magl","lvl0":"一致性哈希算法-Maglev算法","lvl1":["算法"],"lvl2":"摘要","objectID":"9bc7cde50e1048d887d44668fc547687","tags":["一致性哈希"],"url":"/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95-maglev%E7%AE%97%E6%B3%95/"},{"content":"算法内容 对于分布式存储系统，当一个节点失效时，我们并不期望它被移除，而是使用备份节点替换它，或者将它恢复起来，因为我们不期望丢掉它上面的数据","lvl0":"一致性哈希算法-跳跃一致性哈希法","lvl1":["算法"],"lvl2":"摘要","objectID":"c252998843950606bf97af2f315da07b","tags":["一致性哈希"],"url":"/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95-%E8%B7%B3%E8%B7%83%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E6%B3%95/"},{"content":"哈希环法的神秘面纱 哈希环法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而哈希环法是对$2^{32}$取模，什么意思呢","lvl0":"一致性哈希算法-哈希环法","lvl1":["算法"],"lvl2":"摘要","objectID":"116aed0afd34d86e1039f26b7d8994ab","tags":["一致性哈希"],"url":"/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C%E7%8E%AF%E6%B3%95/"},{"content":"如何代理一个简单的kvdb？ 假如我们有一个简单的kvdb (key-value-database)， 它支持两个简单的操作： 由于单节点系统的服务","lvl0":"一致性哈希算法概论","lvl1":["算法"],"lvl2":"摘要","objectID":"29319a56643c6dd9d1e480e8ee9c3218","tags":["一致性哈希"],"url":"/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA/"},{"content":"现代编程语言，大都在标准库中包含了随机库。例如，C++ 在 C++11 标准中添加了 random 头文件，提供了现代的随机库；Python 则有 random。C++11","lvl0":"梅森旋转算法与伪随机数","lvl1":["算法"],"lvl2":"摘要","objectID":"ffbb35559a94151898df7c177e1a556f","tags":["梅森","随机数"],"url":"/post/%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95%E4%B8%8E%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"content":"公式定义 在离散数据及其应用中，如果 那么，称a模m同余b（或者称模m时，a等价于b），可以记为 而线性同余式就可以这样表示： 线性同余发生器与上面","lvl0":"线性同余法与伪随机数","lvl1":["算法"],"lvl2":"摘要","objectID":"0b80e422d55e577471c6647adfc07973","tags":["线性同余","随机数"],"url":"/post/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%B3%95%E4%B8%8E%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"content":"介绍 go generate命令是go 1.4版本里面新添加的一个命令，当运行go generate时，它将扫描与当前包相关的源代码文件，找出所有包含","lvl0":"go generate介绍","lvl1":["go"],"lvl2":"摘要","objectID":"4d5e583500325a7f96cbd2a469e7d7d0","tags":null,"url":"/post/go-generate%E4%BB%8B%E7%BB%8D/"},{"content":"","lvl0":"乐观锁与悲观锁解析","lvl1":["架构"],"lvl2":"摘要","objectID":"b847ccf6638035a38714da7e4a28e1e7","tags":null,"url":"/post/%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%E8%A7%A3%E6%9E%90/"},{"content":"数据不一致性 并发操作带来的数据不一致性包括丢失修改、不可重复读和读“脏”数据。 产生上述三类数据不一致性的主要原因是并发操作破坏了事务的隔离性","lvl0":"事务的隔离机制解析","lvl1":["架构"],"lvl2":"摘要","objectID":"2966ffbe3e550ca717afdc7d7e1221e7","tags":null,"url":"/post/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/"},{"content":"产生死锁的必要条件 互斥使用：进程对其申请的资源进行排他控制，其他申请资源的进程必须等待。 不可剥夺：占用资源的进程只能自己释放资源，不能被其他","lvl0":"分布式系统的死锁处理","lvl1":["架构"],"lvl2":"摘要","objectID":"e1ac3dc315ff0ef4133427f6b65b1840","tags":["分布式"],"url":"/post/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/"},{"content":"ACID和CAP定理中都有C，代表Consistent一致性，很多人容易将这两个C混为一谈，其实这两个一致性是有区别的。这里可以区分成“内部","lvl0":"理解CAP和ACID的一致性","lvl1":["架构"],"lvl2":"摘要","objectID":"a2d1ef9b44713d78320d5101ffec647d","tags":["分布式"],"url":"/post/%E7%90%86%E8%A7%A3cap%E5%92%8Cacid%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/"},{"content":"ACID 事务具有4个特性：原子性（Atomicity)、一致性（Consistency)、隔离性（Isolation)和持续性（Durabilit","lvl0":"ACID理论与BASE理论","lvl1":["架构"],"lvl2":"摘要","objectID":"e5cc9c73f361518d4aed421e2ad959f1","tags":null,"url":"/post/acid%E7%90%86%E8%AE%BA%E4%B8%8Ebase%E7%90%86%E8%AE%BA/"},{"content":"集中式系统 在学习分布式之前，先了解一下与之相对应的集中式系统是什么样的。 集中式系统用一句话概括就是：一个主机带多个终端。终端没有数据处理能力","lvl0":"初识分布式系统","lvl1":["架构"],"lvl2":"摘要","objectID":"5046045adc390f05b1e8663126dbe703","tags":["分布式"],"url":"/post/%E5%88%9D%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"},{"content":"定义 CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partiti","lvl0":"分布式理论:CAP定理","lvl1":["架构"],"lvl2":"摘要","objectID":"f83bf3746471cb1b4c99151d58941151","tags":["分布式"],"url":"/post/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA-cap%E5%AE%9A%E7%90%86/"},{"content":"单实例Redis 一个Go的实现：https://github.com/bsm/redislock (基于go-redis) 使用方法: 1 2 3 4 5","lvl0":"用redis实现分布式锁","lvl1":["redis"],"lvl2":"摘要","objectID":"fc05c8ec680499c21241f3db1314dbb0","tags":["redis"],"url":"/post/%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"content":"MVCC MVCC（Multi-version Cocurrent Control）即多版本并发控制技术，多用于数据库中的事务管理，其基本思想是保存一个数据的多个历史版","lvl0":"etcd的MVCC","lvl1":["etcd"],"lvl2":"摘要","objectID":"f35e01f6c38791e617058e635be107a3","tags":null,"url":"/post/etcd%E7%9A%84mvcc/"},{"content":"事务机制 序列化（访问序列化） 像etcd这类分布式一致性系统时常要处理非常多的来自不同并发客户端的并发请求。尽管有众多并发的读和写，原子性依然","lvl0":"etcd的事务机制","lvl1":["etcd"],"lvl2":"摘要","objectID":"2a163be507de9aed1f8b21af81b14830","tags":null,"url":"/post/etcd%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/"},{"content":"选举 etcd的选举则需要在我们熟悉它的一系列基本概念后，调动我们充分的想象力： 1、MVCC，key存在版本属性，没被创建时版本号为0； 2、C","lvl0":"用eTcd实现选举","lvl1":["etcd"],"lvl2":"摘要","objectID":"25e0626bf9610c5218ab752c0d174f13","tags":null,"url":"/post/%E7%94%A8etcd%E5%AE%9E%E7%8E%B0%E9%80%89%E4%B8%BE/"},{"content":"从 etcd2 到 etcd3 etcd 最早是被设计用来解决 CoreOS 升级时机器的协调问题的。现在它被用于分布式网络、服务发现、配置管理、任务调度和负载均衡等服务中。原始设计的部","lvl0":"etcd2和3的区别","lvl1":["etcd"],"lvl2":"摘要","objectID":"953fc68528940043eaa40810a2d1010e","tags":null,"url":"/post/etcd2%E5%92%8C3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"content":"Etcd的v3版本官方client里有一个concurrency的包，里面实现了分布式锁和选主。本文分析一下它是如何实现的。 分布式锁 在cod","lvl0":"用Etcd实现分布式锁","lvl1":["etcd"],"lvl2":"摘要","objectID":"79e0653786e79a09a2cbaa78a012c9e7","tags":null,"url":"/post/%E7%94%A8etcd%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"content":"为何需要分布式锁 一般我们使用分布式锁有两个场景: 效率:使用分布式锁可以避免不同节点重复相同的工作，这些工作会浪费资源。比如用户付了钱之后有可","lvl0":"分布式锁的实现","lvl1":["架构"],"lvl2":"摘要","objectID":"1c34894304d528697ecb4df01a9fb004","tags":["分布式"],"url":"/post/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"content":"简介 Excelize 是 Go 语言编写的用于操作 Office Excel 文档类库，基于 ECMA-376 Office OpenXML 标准。可以使用它来读取、写入由 Microsoft Excel™ 2007 及以上版本创建的 XLSX 文档。相比较其他的开源类","lvl0":"Golang读写Excel","lvl1":["Go"],"lvl2":"摘要","objectID":"84c45d7ffa6399614e2aa461dc4b6fea","tags":["Go","Excel"],"url":"/post/golang%E8%AF%BB%E5%86%99excel/"},{"content":"很多人对这个问题的第一反应可能是，它是一个键值存储仓库，却没有重视官方定义的后半句，用于配置共享和服务发现。 A highly-available key value store for shared configuration and service discovery. 实际上，e","lvl0":"etcd：从应用场景到实现原理的全方位解读","lvl1":["etcd"],"lvl2":"摘要","objectID":"3367c90923727e4645eceab1c039690e","tags":null,"url":"/post/etcd%E4%BB%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E7%9A%84%E5%85%A8%E6%96%B9%E4%BD%8D%E8%A7%A3%E8%AF%BB/"},{"content":"ETCD ETCD是用于共享配置和服务发现的分布式，一致性的KV存储系统。ETCD是CoreOS公司发起的一个开源项目，授权协议为Apache。 核心","lvl0":"Go如何操作etcd","lvl1":["etcd"],"lvl2":"摘要","objectID":"a588149f7ca9d462a729b1b33ba144ed","tags":null,"url":"/post/go%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9Cetcd/"},{"content":"etcdv3目录结构 1 2 3 4 5 6 7 8 ├── client.go 客户端 ├── doc.go ├── example_test.go ├── instancer.go 服务实例 ├── instancer_test.go ├── integration_test.go ├── registrar.go 注册器 └── registrar_test.go 目录中主要的是这三个","lvl0":"GoKit源码:服务注册与发现","lvl1":["GoKit"],"lvl2":"摘要","objectID":"1b75d3b61cf34d92d2ce8195ed4f0b02","tags":["GoKit","etcd"],"url":"/post/gokit%E6%BA%90%E7%A0%81%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0/"},{"content":"对于一些数据量较大的系统，数据库面临的问题除了查询效率低下，还有就是数据入库时间长。特别像报表系统，每天花费在数据导入上的时间可能会长达几个","lvl0":"MySQL批量SQL插入性能优化","lvl1":["Mysql"],"lvl2":"摘要","objectID":"d739237400d85181437bba881f1919ef","tags":null,"url":"/post/mysql%E6%89%B9%E9%87%8Fsql%E6%8F%92%E5%85%A5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"content":"这是之前遇到的一道面试题，后来也确实在工作中实际遇到了。于是记录一下，如何（优雅的）比较两个未知结构的json。 假设，现在有两个简单的jso","lvl0":"如何优雅地比较两个未知结构的JSON","lvl1":["Go"],"lvl2":"摘要","objectID":"73244a54167484ca6819acf1be19580c","tags":null,"url":"/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E6%9C%AA%E7%9F%A5%E7%BB%93%E6%9E%84%E7%9A%84json/"},{"content":"看到标题，第一反应，map肯定秒杀slice啊，我当时也是这么想的，毕竟前者的查询复杂度是O(1)，后者是O(n)。 1 2 3 4 5 6 7 8 9 10 11 12","lvl0":"Go中的map和slice查询性能对比","lvl1":null,"lvl2":"摘要","objectID":"7b2c6ac2b46fe6554a0e8d98b7bb1b36","tags":null,"url":"/post/go%E4%B8%AD%E7%9A%84map%E5%92%8Cslice%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"content":"思路 开发中经常会遇到需要比较两个slice或map包含的元素是否完全相等的情况，一般来说有两个思路： reflect比较的方法 循环遍历比较的方","lvl0":"Go中的slice和map的比较方法","lvl1":["Go"],"lvl2":"摘要","objectID":"a775ca5de3bca2e4c6dfd115df0534c6","tags":["slice","map"],"url":"/post/go%E4%B8%AD%E7%9A%84slice%E5%92%8Cmap%E7%9A%84%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95/"},{"content":"类型不确定 在不确定类型需要反射的时候，DeepEqual是我们不可不用的强大工具。 比如： 1 2 3 4 5 6 7 func main(){ m1:=map[string]interface{}{\u0026#34;a\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;b\u0026#34;:2, \u0026#34;c\u0026#34;:3}; m2:=map[string]interface{}{\u0026#34;a\u0026#34;:1, \u0026#34;c\u0026#34;:\u0026#34;3\u0026#34;, \u0026#34;b\u0026#34;:2}; fmt.Println(`reflect.DeepEqual(m1[\u0026#34;a\u0026#34;],m2[\u0026#34;a\u0026#34;]`,reflect.DeepEqual(m1[\u0026#34;a\u0026#34;],m2[\u0026#34;a\u0026#34;])); fmt.Println(`reflect.DeepEqual(m1[\u0026#34;b\u0026#34;],m2[\u0026#34;b\u0026#34;]`,reflect.DeepEqual(m1[\u0026#34;b\u0026#34;],m2[\u0026#34;b\u0026#34;])); } 执行结果： 1 2 3","lvl0":"Go中的interface{}比较方法","lvl1":["Go"],"lvl2":"摘要","objectID":"f046c9206bd8bb5da65b584fdd8eec9c","tags":["interface"],"url":"/post/go%E4%B8%AD%E7%9A%84interface-%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95/"},{"content":"规则 不同类型的值不会深度相等 Values of distinct types are never deeply equal. 1 2 3 4 5 6 7 8 9 10 type S1 struct { Field int } type S2 struct { Field int } func main() { fmt.Println(reflect.DeepEqual(S1{1}, S2{1})) } 对应输出false 当两个数组的元素对","lvl0":"DeepEqual浅析","lvl1":["Go"],"lvl2":"摘要","objectID":"d0009d4a77c77a39a5c884971a094fb5","tags":["Go"],"url":"/post/deepequal%E6%B5%85%E6%9E%90/"},{"content":"HTTPS简介 日常生活中，我们上网用的最多的应用层协议就是HTTP协议了，直至目前全世界的网站中大多数依然只支持HTTP访问。 使用Go创建一","lvl0":"Go和HTTPS","lvl1":["Go"],"lvl2":"摘要","objectID":"dae17595098eaf2cf933970214edd4ef","tags":["Go","HTTPS"],"url":"/post/go%E5%92%8Chttps/"},{"content":"初始化 使用 map 的时候需要注意，你需要显式地初始化才能对 map 进行操作. 1 2 var m map[string]string m[\u0026#34;a\u0026#34;]=\u0026#34;sssss\u0026#34; 上面的代码会报 panic: assignment to entry in nil map ，必须用内建的 make() 函数才行. 1 2 m:=make(map[string]string) m[\u0026#34;a\u0026#34;]=\u0026#34;sssss\u0026#34; key","lvl0":"Go的map使用实践","lvl1":["Go"],"lvl2":"摘要","objectID":"5bea1a6293fcb18f0ed62b1454ab8aac","tags":["Go"],"url":"/post/go%E7%9A%84map%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/"},{"content":"概念 首先区分几个概念：变量可比较，可排序，可赋值 可赋值 规范里面对赋值是这么定义的：https://golang.org/ref/spec#A","lvl0":"Go中的内置类型比较","lvl1":["Go"],"lvl2":"摘要","objectID":"c838bfcfbfa7d6cdf9622c7ecc0d9258","tags":["Go"],"url":"/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83/"},{"content":"浮点数计算不精确 浮点数与整数计算 先看两个case 1 2 3 4 5 6 7 // case1: 135.90*100 ==== // float32 var f1 float32 = 135.90 fmt.Println(f1 * 100) // output:13589.999 // float64 var f2 float64 = 135.90 fmt.Println(f2 * 100) // output:13590 浮点数在单精度下, 13","lvl0":"Go语言的浮点数计算","lvl1":["Go"],"lvl2":"摘要","objectID":"151783829d72690883e869e72c943914","tags":["Go"],"url":"/post/go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97/"},{"content":"在计算机系统的发展过程中，业界曾经提出过许多种实数的表达方法，比较典型的有相对于浮点数（Floating Point Number）的定点数（Fixed","lvl0":"IEEE 754浮点数标准详解","lvl1":["杂谈"],"lvl2":"摘要","objectID":"d7e95d1ec6010734e8c37120a35f1b4d","tags":null,"url":"/post/ieee-754%E6%B5%AE%E7%82%B9%E6%95%B0%E6%A0%87%E5%87%86%E8%AF%A6%E8%A7%A3/"},{"content":"为什么没有? 我们知道go语言math包里面定义了min/max函数，但是是float64类型的，而并没有整数类型的min/max。 go语言的","lvl0":"go语言为什么没有min/max(int, int)函数","lvl1":["Go"],"lvl2":"摘要","objectID":"e927fd66c6250a0a6f6159d5de12de6b","tags":["Go"],"url":"/post/go%E8%AF%AD%E8%A8%80%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89min-max-int-int-%E5%87%BD%E6%95%B0/"},{"content":"前言 认证和授权，其实吧简单来说就是:认证就是让服务器知道你是谁，授权就是服务器让你知道你什么能干，什么不能干，认证授权俩种方式：Sessio","lvl0":"cookie-session机制与JWT机制对比","lvl1":["架构"],"lvl2":"摘要","objectID":"9957324e9132a668cb7cf12deece2b91","tags":["鉴权"],"url":"/post/cookie-session%E6%9C%BA%E5%88%B6%E4%B8%8Ejwt%E6%9C%BA%E5%88%B6%E5%AF%B9%E6%AF%94/"},{"content":"go mod 命令 1 2 3 4 5 6 7 8 download download modules to local cache (下载依赖的module到本地cache)) edit edit go.mod from tools or scripts (编辑go.mod文件) graph print module requirement graph (打印模块依","lvl0":"Go Modules 浅析","lvl1":["Go"],"lvl2":"摘要","objectID":"ab59d0a12694dbd514fd8c27fa6b3ac3","tags":["Go","Modules"],"url":"/post/go-modules-%E6%B5%85%E6%9E%90/"},{"content":"func Copy 1 func Copy(dst, src Value) int Copy将src的内容复制到dst，直到dst已填满或src已用完为止。它返回复制的元素数。Dst和src必须具有类型的Sl","lvl0":"reflect包解析","lvl1":["Go标准库"],"lvl2":"摘要","objectID":"7100f8b0ea375dd7c6d63bab1258a927","tags":["Go标准库"],"url":"/post/reflect%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"content":"介绍 数据处理大致可以分成两大类：联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Proc","lvl0":"OLTP与OLAP的介绍","lvl1":["杂谈"],"lvl2":"摘要","objectID":"a4651a61d9948dc692af9dae3aff4ba2","tags":null,"url":"/post/oltp%E4%B8%8Eolap%E7%9A%84%E4%BB%8B%E7%BB%8D/"},{"content":"创建main 创建文件main.go并导入bson，mongo和mongo/options包： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main","lvl0":"mongo-go-driver使用总结","lvl1":["Go"],"lvl2":"摘要","objectID":"ba9a93e6ae213816419cc7b4e515e7ae","tags":["Go","MongoDB"],"url":"/post/mongo-go-driver%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"content":"先看一段代码: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main var X interface{} type T struct{} func F() { type T struct{} X = T{} } func G() { type T struct{} _ = X.(T) } func main() { F() G() } 我们总是可以说“来","lvl0":"types from different packages 问题浅析","lvl1":["Go"],"lvl2":"摘要","objectID":"c37358e7c23a7d198d5cc5cc97893cb1","tags":["Go","interface"],"url":"/post/types-from-different-packages-%E9%97%AE%E9%A2%98%E6%B5%85%E6%9E%90/"},{"content":"协程 进程时代 最初的计算机上面没有操作系统，更别提进程、线程和协程了。 后来，现代化的计算机有了操作系统，每个程序都是一个进程，但是操作系统在一","lvl0":"Go的调度器源码剖析","lvl1":["Go源码"],"lvl2":"摘要","objectID":"05d2bf65218c15b843038c52e626436b","tags":["Go源码"],"url":"/post/go%E7%9A%84%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"问题来源 简单来说就是企图在一个事务中开启多个协程执行并发查询,会出现busy buffer的问题 接下来这篇文章将尝试深入探讨产生 busy buffer 的根本原因","lvl0":"为什么不要在单个sql.Tx中使用协程","lvl1":["Go"],"lvl2":"摘要","objectID":"5143c5adb40a953936b00fcf7e46e1e2","tags":["Go","Mysql"],"url":"/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E5%9C%A8%E5%8D%95%E4%B8%AAsql.tx%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B/"},{"content":"事实上你可以使用SetMaxOpenConns（）、SetMaxIdleConns（）和SetConnmaxLifetime（）方法。来配置","lvl0":"配置sql.DB获得更好的性能","lvl1":["Go"],"lvl2":"摘要","objectID":"bc5a0f8571829c7d29e746ceaeb5aef6","tags":["Go","Mysql"],"url":"/post/%E9%85%8D%E7%BD%AEsql-db%E8%8E%B7%E5%BE%97%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%80%A7%E8%83%BD/"},{"content":"简介 今日在查看锁超时的设置时，看到show variables like \u0026lsquo;%timeout%';语句输出结果中的十几种超时参数时突然想整理一下，不知道大家","lvl0":"MySQL各种超时参数的含义","lvl1":["Mysql"],"lvl2":"摘要","objectID":"06dd8bec26b67be778fd3d1605d10b98","tags":null,"url":"/post/mysql%E5%90%84%E7%A7%8D%E8%B6%85%E6%97%B6%E5%8F%82%E6%95%B0%E7%9A%84%E5%90%AB%E4%B9%89/"},{"content":"UUID UUID的全称是universally unique identifier，全局唯一认证，它是一个128比特的数字，用来辨认计算机系统中的信息。术语GU","lvl0":"UUID算法介绍","lvl1":["算法"],"lvl2":"摘要","objectID":"d7d9b8b3aa877a24d335815b29b994fe","tags":null,"url":"/post/uuid%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/"},{"content":"MySQL主键设计原则 MySQL主键应当是对用户没有意义的 所有涉及到业务的字段，无论它看上去是否唯一，都决不能用作主键。例如，用户表的Ema","lvl0":"Mysql主键设计","lvl1":["Mysql"],"lvl2":"摘要","objectID":"cc9d008d32633cb1a83e089d9ff9d659","tags":null,"url":"/post/mysql%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1/"},{"content":"TP=Top Percentile，Top百分数，是一个统计学里的术语，与平均数、中位数都是一类。 TP50、TP90和TP99等指标常用于系统性能监控场","lvl0":"TP50、TP90、TP99、TP999解释","lvl1":["杂谈"],"lvl2":"摘要","objectID":"7979003d3a7661de7e90b0e70d0d2997","tags":null,"url":"/post/tp50tp90tp99tp999%E8%A7%A3%E9%87%8A/"},{"content":"Leaf-segment Leaf-segment方案，在使用数据库的方案上，做了如下改变： 原方案每次获取ID都得读写一次数据库，造成数据库压力大。改为利用prox","lvl0":"分布式ID生成:leaf算法浅析","lvl1":["算法"],"lvl2":"摘要","objectID":"8bd6be81a9a7e64058aed4a1a254c834","tags":["分布式"],"url":"/post/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90-leaf%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/"},{"content":"背景 在我们的业务需求中通常有需要一些唯一的ID，来记录我们某个数据的标识: 某个用户的ID 某个订单的单号 某个信息的ID 通常我们会调研各种各样的","lvl0":"分布式ID生成方案简单总结","lvl1":["架构"],"lvl2":"摘要","objectID":"62f177663e917c76caca9f17d418b633","tags":["分布式"],"url":"/post/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/"},{"content":"snowflake 大部分分布式系统中，对一些互斥资源通常需要一个集群唯一的ID，比如消息id，订单号等。而且很多业务需求往往要求这些ID必须具有先后顺序，以","lvl0":"分布式ID生成:snowflake算法浅析","lvl1":["算法"],"lvl2":"摘要","objectID":"67e621c06e5f2a7e54063508bcf8acba","tags":["分布式","snowflake"],"url":"/post/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90-snowflake%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/"},{"content":"etcdctl v2 v3 etcd2和etcd3是不兼容的，两者的api参数也不一样，详细请查看 etcdctl -h 。 可以使用api2 和 api3 写入 etcd3 数据，但是需要注意，使用不同的a","lvl0":"etcdctl命令操作","lvl1":["etcd"],"lvl2":"摘要","objectID":"9a46cb2299a7ac847f9f77184c8c039a","tags":null,"url":"/post/etcdctl%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/"},{"content":"集群配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66","lvl0":"etcd部署与配置","lvl1":["etcd"],"lvl2":"摘要","objectID":"8c1d6ba7b20b7bc0ddc958c23cccb005","tags":null,"url":"/post/etcd%E9%83%A8%E7%BD%B2%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"content":"DSN 数据源名称具有通用格式，例如PEAR DB使用它，但没有类型前缀（可选部分用方括号标记）： 1 [username[:password]@][protocol[(address)]]/dbname[?param1=value1\u0026amp;...\u0026amp;paramN=valueN] DSN最完整的形式： 1 username:password@protocol(address)/dbname?param=value 除databasena","lvl0":"Go中mysql驱动的DSN解析","lvl1":["Go"],"lvl2":"摘要","objectID":"ce10effb13d0d2d95b8cf1b3424702bd","tags":["Go","Mysql"],"url":"/post/go%E4%B8%ADmysql%E9%A9%B1%E5%8A%A8%E7%9A%84dsn%E8%A7%A3%E6%9E%90/"},{"content":"defer防止panic 利用 Commit() 之后 Rollback() 不会真正执行的特性,可以在创建tx时使用defer防止panic出现没有释放tx 1 2 3 4 5 6 7 8 9 10 11 12","lvl0":"Golang事务使用的正确方法","lvl1":["Go"],"lvl2":"摘要","objectID":"13ab5de264009f33c11b6159a9e92bbf","tags":["Go","Mysql"],"url":"/post/golang%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%96%B9%E6%B3%95/"},{"content":"简介 println是一种内置于语言中的函数。它位于规范的Bootstrapping部分。 当前实现提供了几个在引导期间有用的内置函数。记录这些","lvl0":"println与fmt.Println","lvl1":["Go"],"lvl2":"摘要","objectID":"27081668154ad873e19ca94fdd631f59","tags":["Go"],"url":"/post/println%E4%B8%8Efmt-println/"},{"content":"定义 nil 为预声明的标示符，定义在builtin/builtin.go， 1 2 3 4 5 6 7 8 9 // nil is a predeclared identifier representing the zero value for a // pointer, channel, func, interface, map, or slice type. // Type must be a pointer,","lvl0":"Go中的nil解析","lvl1":["Go"],"lvl2":"摘要","objectID":"62e4c9a1f68bfd2717042154a9fe4d2b","tags":["Go"],"url":"/post/go%E4%B8%AD%E7%9A%84nil%E8%A7%A3%E6%9E%90/"},{"content":"golang是强类型语言，在赋值和解析过程中需要先定义好数据类型，否在会报类型错误，下面总结在处理数据库表时遇到字段为空或零值的情况 场景 假如","lvl0":"Go处理数据库的NULL","lvl1":["Go"],"lvl2":"摘要","objectID":"2d69c7e0e569eb7037c18e604486ea42","tags":["Go","Mysql"],"url":"/post/go%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84null/"},{"content":"一、背景 说起应用分层，大部分人都会认为这个不是很简单嘛 就controller，service, mapper三层。看起来简单，很多人其实并没有","lvl0":"优秀的代码都是如何分层的？","lvl1":["架构"],"lvl2":"摘要","objectID":"5d2ae27c066b885b9a8b61c5104f6c96","tags":null,"url":"/post/%E4%BC%98%E7%A7%80%E7%9A%84%E4%BB%A3%E7%A0%81%E9%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%86%E5%B1%82%E7%9A%84/"},{"content":"MySQL 相比起简单的锁表，事务提供了更好的并发性能，但同时也带来更大的复杂性，如隔离级别，mvcc，死锁等。网上关于事务隔离级别的介绍遍地都是，就","lvl0":"Go语言MySQL中如何为单个事务设置隔离级别","lvl1":["Go"],"lvl2":"摘要","objectID":"51d10666e06ecbf6711278cf06099b84","tags":["Go"],"url":"/post/go%E8%AF%AD%E8%A8%80mysql%E4%B8%AD%E5%A6%82%E4%BD%95%E4%B8%BA%E5%8D%95%E4%B8%AA%E4%BA%8B%E5%8A%A1%E8%AE%BE%E7%BD%AE%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"},{"content":"简介 NATS是一个开源、轻量级、高性能的分布式消息中间件，实现了高可伸缩性和优雅的Publish/Subscribe模型，使用Golang语","lvl0":"NATS:高性能轻量级消息队列浅析","lvl1":["NATS"],"lvl2":"摘要","objectID":"0d608c9e1e5ce87b72e1f0fa1c5968b7","tags":["NATS"],"url":"/post/nats-%E9%AB%98%E6%80%A7%E8%83%BD%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%B5%85%E6%9E%90/"},{"content":"简介 基本的NATS服务器专为高性能和简洁而设计，它不会为通过NATS发布的消息提供持久性存储。缺乏对消息的持久存储对于许多分布式系统来说都是","lvl0":"NATS Streaming浅析","lvl1":["NATS"],"lvl2":"摘要","objectID":"7938543e4f2c9d8f3f70f39798f126b1","tags":["NATS"],"url":"/post/nats-streaming%E6%B5%85%E6%9E%90/"},{"content":"NSQ组件 NSQ 是由四个重要组件构成： nsqd：一个负责接收、排队、转发消息到客户端的守护进程 nsqlookupd：管理拓扑信息并提供最终一致性","lvl0":"NSQ:异步消息队列浅析","lvl1":["NSQ"],"lvl2":"摘要","objectID":"8627d00ceb9151c2a02440a8a881b72b","tags":["NSQ"],"url":"/post/nsq-%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%B5%85%E6%9E%90/"},{"content":"根据“墨菲定律”，我们编写的后台的服务都有出现crash的可能，一种情况是Go的后台服务我们经常也会遇到panic的情况。出问题不可怕，我们","lvl0":"Go中捕获panic信息到日志文件中","lvl1":["Go"],"lvl2":"摘要","objectID":"b6bf307c75faf62992f26e14b54a8ff3","tags":["Go"],"url":"/post/go%E4%B8%AD%E6%8D%95%E8%8E%B7panic%E4%BF%A1%E6%81%AF%E5%88%B0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E4%B8%AD/"},{"content":"Linux终端输出颜色 开发工作中经常见到终端中各种命令输出的彩色文字，例如 ls 命令就以不同颜色表示文件的不同类型。 而在我们自己写的程序输出的信","lvl0":"Go语言在Linux终端输出彩色字符","lvl1":["Go"],"lvl2":"摘要","objectID":"f5fa08feb89217faf5e3f0b3c8bc3907","tags":["Go"],"url":"/post/go%E8%AF%AD%E8%A8%80%E5%9C%A8linux%E7%BB%88%E7%AB%AF%E8%BE%93%E5%87%BA%E5%BD%A9%E8%89%B2%E5%AD%97%E7%AC%A6/"},{"content":"简介 一个Go语言字符串是一个任意字节的常量序列。Go语言的字符串类型在本质上就与其他语言的字符串类型不同。 Java的String、C++的s","lvl0":"Golang的单引号、双引号与反引号","lvl1":["Go"],"lvl2":"摘要","objectID":"470387990b0e25976f1c5aae4bc635eb","tags":["Go"],"url":"/post/golang%E7%9A%84%E5%8D%95%E5%BC%95%E5%8F%B7%E5%8F%8C%E5%BC%95%E5%8F%B7%E4%B8%8E%E5%8F%8D%E5%BC%95%E5%8F%B7/"},{"content":"错误类型解析 error 接口 Go 继承了 C，以返回值为错误处理的主要方式。但与 C 不同的是，在 Go 的惯用法中，返回值不是整型等常用返回值类型（errno），而","lvl0":"更优雅的Go错误处理","lvl1":["Go"],"lvl2":"摘要","objectID":"23ac9682d9e9c045fbd382f1d0a6b6ab","tags":["Go"],"url":"/post/%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84go%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"},{"content":"func new 1 func new(Type) *Type 内建函数new分配内存。其第一个实参为类型，而非值。其返回值为指向该类型的新分配的零值的指针。 在调用new函数时，将类型名作为参","lvl0":"Go中的内置函数","lvl1":["Go"],"lvl2":"摘要","objectID":"4c685a20a92b7585374dae52066e1121","tags":["Go"],"url":"/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},{"content":"包context定义了上下文类型，它跨API边界和进程之间承载截止日期、取消信号和其他请求范围的值。 对服务器的传入请求应创建context，","lvl0":"context包解析(1.11)","lvl1":["Go标准库"],"lvl2":"摘要","objectID":"4942f8d7434ab2f639addb15022530fe","tags":["Go标准库"],"url":"/post/context%E5%8C%85%E8%A7%A3%E6%9E%90-1-11/"},{"content":"神奇的日期 刚接触Golang时，阅读代码的时候总会在代码中发现这么一个日期， 1 2006-01-02 15:04:05 刚看到这段代码的时候，我当时想：这个人好随便啊，随便写一个","lvl0":"神奇的2006-01-02 15:04:05","lvl1":["Go"],"lvl2":"摘要","objectID":"2e2e36073d645b4cd3ea1245a949f1c8","tags":["Go"],"url":"/post/%E7%A5%9E%E5%A5%87%E7%9A%842006-01-02-15-04-05/"},{"content":"func Float64s 1 func Float64s（a [] float64） Float64s按递增顺序对一\u0008组切片的float64进行排序（非数值被视为小于其他值）。 1 2","lvl0":"sort包解析(1.11)","lvl1":["Go标准库"],"lvl2":"摘要","objectID":"07b48e7373c4a80af198ac0fdcd3fe29","tags":["Go标准库"],"url":"/post/sort%E5%8C%85%E8%A7%A3%E6%9E%90-1-11/"},{"content":"类型转换和类型断言 Go语言的类型转换和类型断言: 类型转换在编译期完成，包括强制转换和隐式转换 类型断言在运行时确定，包括安全类型断言和非安全类","lvl0":"Go中接口的类型转换与判断","lvl1":["Go"],"lvl2":"摘要","objectID":"9a2f1c8b5618977d4e4490ced2e40f26","tags":["Go"],"url":"/post/go%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%88%A4%E6%96%AD/"},{"content":"隐型转换 转换是T（x）形式的表达式，其中T是类型，x是可以转换为类型T的表达式。 1 Conversion = Type \u0026#34;(\u0026#34; Expression [ \u0026#34;,\u0026#34; ] \u0026#34;)\u0026#34; . 如果类型以operator *或\u0026lt;","lvl0":"Go中的内置类型转换","lvl1":["Go"],"lvl2":"摘要","objectID":"290fc2d8fbc913276ec589bec3fac64d","tags":["Go"],"url":"/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"content":"代码1： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path/filepath\u0026#34; ) func main() { dir, err := filepath.Abs(filepath.Dir(os.Args[0])) if err != nil { log.Fatal(err) } fmt.Println(dir) } 代码2： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34;","lvl0":"Go中获取程序所在目录","lvl1":["Go"],"lvl2":"摘要","objectID":"4733b51bc3dfa7e4021915e49dd8e4f2","tags":null,"url":"/post/go%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F%E6%89%80%E5%9C%A8%E7%9B%AE%E5%BD%95/"},{"content":"万物皆文件 UNIX 的一个基础设计就是\u0026quot;万物皆文件\u0026quot;(everything is a file)。我们不必知道一个文件到底映射成什么，操","lvl0":"Go中文件及文件夹相关操作","lvl1":["Go"],"lvl2":"摘要","objectID":"feee96d375e4e7a45924def88d70fc4a","tags":null,"url":"/post/go%E4%B8%AD%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"},{"content":"重入锁 接下来,我们来讨论“重入”这个问题。在说这个问题前,我先解释一下个概念,叫“可重入锁”。 当一个线程获取锁时,如果没有其它线程拥有这个锁","lvl0":"Go实现重入锁","lvl1":["Go"],"lvl2":"摘要","objectID":"b16057769de9fc98453e1fd7a78a6018","tags":["Go"],"url":"/post/go%E5%AE%9E%E7%8E%B0%E9%87%8D%E5%85%A5%E9%94%81/"},{"content":"什么是可变参数函数？ 可变参数函数即其参数数量是可变的 —— 0 个或多个。声明可变参数函数的方式是在其参数类型前带上省略符（三个点）前缀。 译者注：","lvl0":"Go语言的可变参数详解","lvl1":["Go"],"lvl2":"摘要","objectID":"57c220d62312a1260fb56d1ab0af7c04","tags":["Go"],"url":"/post/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/"},{"content":"一般Go语言同时使用多个channel的方法是使用select/case语句配合\u0026lt;-操作符，比如 1 2 3 4 5 6 select { case \u0026lt;- chan1: // do something case \u0026lt;- chan2: // do","lvl0":"GO中使用select实现带优先级的channel队列","lvl1":["Go"],"lvl2":"摘要","objectID":"99c56f600e11bd769bfe1712782cfbdb","tags":null,"url":"/post/go%E4%B8%AD%E4%BD%BF%E7%94%A8select%E5%AE%9E%E7%8E%B0%E5%B8%A6%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84channel%E9%98%9F%E5%88%97/"},{"content":"type Cond Cond实现了一个条件变量，一个等待或宣布事件发生的goroutines的集合点。 每个Cond都有一个相关的Locker L（通常是* Mu","lvl0":"package:sync(1.13)","lvl1":["Go标准库"],"lvl2":"摘要","objectID":"ef5c5a23251997c6487580d2e2517caf","tags":["Go标准库"],"url":"/post/packagesync1.13/"},{"content":"Golang 中的函数跟 C 的一样，是个代码块，由于golong中函数也是类型,它可以像其他类型那样赋值给一个变量。 在 Golang 中，你不能这样做： 1 2 3 4 5 func foobar() {","lvl0":"在GO中用名字调用函数","lvl1":["Go"],"lvl2":"摘要","objectID":"fa9e315dd9b96df3ff399e900021440d","tags":["Go"],"url":"/post/%E5%9C%A8go%E4%B8%AD%E7%94%A8%E5%90%8D%E5%AD%97%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/"},{"content":"背景 问题代码如下： 1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;fmt\u0026#34; func main() { s := []byte(\u0026#34;\u0026#34;) s1 := append(s, \u0026#39;a\u0026#39;) s2 := append(s, \u0026#39;b\u0026#39;) //fmt.Println(s1, \u0026#34;==========\u0026#34;, s2) fmt.Println(string(s1), \u0026#34;==========\u0026#34;, string(s2)) } // 出现个让我理解不了的现象, 注释时候输出是 b ========== b //","lvl0":"append的陷阱","lvl1":["Go"],"lvl2":"摘要","objectID":"b7cc4ff0926116e21721f323c6a9b913","tags":["Go","逃逸机制","slice"],"url":"/post/append%E7%9A%84%E9%99%B7%E9%98%B1/"},{"content":"常量 这些预定义的版式用于Time.Format和Time.Parse函数。用在版式中的参考时间是： 1 Mon Jan 2 15:04:05 MST 2006 对应的Unix时间是1136","lvl0":"time包解析(1.11)","lvl1":["Go标准库"],"lvl2":"摘要","objectID":"4e1ed4bd66237325c0abbdc3d314bcef","tags":["Go标准库"],"url":"/post/time%E5%8C%85%E8%A7%A3%E6%9E%90-1-13/"},{"content":"因为在使用gin框架，在配置路由的时候需要手动配置，如下: 1 2 r.GET(\u0026#34;/page\u0026#34;,controller.Page) r.GET(\u0026#34;/index\u0026#34;,controller.Index) 其中controller是包名，如果在controller包中再增加方法，","lvl0":" Gin实现自动注册路由","lvl1":["Gin"],"lvl2":"摘要","objectID":"417b3f1968cdb7ae26a14cca026b8493","tags":["Gin"],"url":"/post/gin%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%86%8C%E8%B7%AF%E7%94%B1/"},{"content":"连接与连接池 database/sql database/sql是golang的标准库之一，它提供了一系列接口方法，用于访问关系数据库。它并不会提供数据库特有的方法，","lvl0":"database-sql包源码剖析","lvl1":["Go"],"lvl2":"摘要","objectID":"c0cd9a4cedce7612e522ae5afdf16c57","tags":["Go","Mysql"],"url":"/post/database-sql%E5%8C%85%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"content":"连接Mysql数据库，在有一定量的查询结果以后，会出先too many connection的错误。 google了一下，很多文章都建议修改MySql的","lvl0":"Go连接MySql数据库too many connections错误解决","lvl1":["Go"],"lvl2":"摘要","objectID":"0719f7c66254531e4582f50cb2bb7fad","tags":["Go","Mysql"],"url":"/post/go%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93too-many-connections%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"},{"content":"Variables 对于已经返回到连接池的连接执行的任何操作，都会返回ErrConnDone。 1 var ErrConnDone = errors.New(\u0026#34;sql: connection is already closed\u0026#34;) 当QueryRow方法没有返回一个row时，调","lvl0":"database/sql包解析(1.11)","lvl1":["Go标准库"],"lvl2":"摘要","objectID":"c1bab5db9814bd3ec538ba8d02c1369c","tags":["Go标准库"],"url":"/post/database-sql%E5%8C%85%E8%A7%A3%E6%9E%90-1-11/"},{"content":"如何控制goroutine的数量 用什么方法控制goroutine的数量？ 要在每一次执行go之前判断goroutine的数量，如果数量超了，就","lvl0":"如何优雅地控制goroutine","lvl1":["Go"],"lvl2":"摘要","objectID":"c8eb6950a78e232ee66abcb33f0a9ed5","tags":null,"url":"/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E6%8E%A7%E5%88%B6goroutine/"},{"content":"闭包 在函数编程中经常用到闭包，闭包是什么？它是怎么产生的及用来解决什么问题呢?先给出闭包的字面定义：闭包是由函数及其相关引用环境组合而成的实","lvl0":"Golang中的闭包","lvl1":["Go"],"lvl2":"摘要","objectID":"7d7875c3a1ff0064fdcafef558a4978d","tags":null,"url":"/post/golang%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/"},{"content":"TCP的长连接与短连接 Server和Client建立通讯后，确保连接的及时断开就非常重要。否则，多个客户端长时间占用着连接不关闭，是非常可怕","lvl0":"Go实现HTTP长连接和短连接","lvl1":["Go"],"lvl2":"摘要","objectID":"f97a61fb637b33e5c3efcc5bd67e2a63","tags":["Go"],"url":"/post/go%E5%AE%9E%E7%8E%B0http%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5/"},{"content":"HTTP协议与TCP/IP协议的关系 HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题","lvl0":"HTTP中的长连接与短连接","lvl1":["HTTP"],"lvl2":"摘要","objectID":"7b99d93632fd76dcc81448f9b6ece6e5","tags":null,"url":"/post/http%E4%B8%AD%E7%9A%84%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5/"},{"content":"Go语言规范中规定了可寻址(addressable)对象的定义, For an operand x of type T, the address operation \u0026amp;x generates a pointer of type *T to x. The operand must be addressable, that is, either a variable, pointer indirection, or slice indexing operation; or a field","lvl0":"Go中的可寻址详解","lvl1":["Go"],"lvl2":"摘要","objectID":"5eb734607d409351e7e7f8d7d7ed32d8","tags":null,"url":"/post/go%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%AF%BB%E5%9D%80%E8%AF%A6%E8%A7%A3/"},{"content":"空对象 空对象是个神奇的东西。它指的是没有字段的结构类型。 1 type Q struct{} 不占用空间,长度为0 1 2 var s struct{} fmt.Println(unsafe.Sizeof(s)) // prints 0 如果结构体中仅有一个空结构字段,那么结","lvl0":"空结构体struct{}解析","lvl1":["Go"],"lvl2":"摘要","objectID":"cd387a67c48ac8abbeeba60670134b92","tags":null,"url":"/post/%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93struct-%E8%A7%A3%E6%9E%90/"},{"content":"几天前，我写了一篇文章来说明golang中channel的使用规范。在reddit和HN，那篇文章收到了很多赞同，但是我也收到了下面几个关于","lvl0":"如何优雅地关闭Go channel","lvl1":["Go"],"lvl2":"摘要","objectID":"4b8f627db08a1eb3bfbeb1bcd398615d","tags":["Go"],"url":"/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%85%B3%E9%97%ADgo-channel/"},{"content":"切片 append函数 append主要用于给某个切片（slice）追加元素,只要slice定义后就可以使用append,不需要先初始化. 如果该","lvl0":"Go切片数组字符串使用实践","lvl1":["Go"],"lvl2":"摘要","objectID":"b7b6617e99431e558aa14d6bd1a46de3","tags":["Go"],"url":"/post/go%E5%88%87%E7%89%87%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/"},{"content":"指针类型 在正式介绍 unsafe 包之前，需要着重介绍 Go 语言中的指针类型。 举一个例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; func double(x int) { x += x } func main() { var a = 3 double(a) fmt.Println(a)","lvl0":"Go中unsafe使用实践","lvl1":["Go"],"lvl2":"摘要","objectID":"e3283923c728a6e80244324cd152a618","tags":["Go"],"url":"/post/go%E4%B8%ADunsafe%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/"},{"content":"问题 比如我们有一个log文件，运行了几年，有100G之大。按照我们之前的操作可能代码会这样写： 1 2 3 4 5 6 7 func ReadFile(filePath string) []byte{ content, err := ioutil.ReadFile(filePath) if err != nil { log.Println(\u0026#34;Read error\u0026#34;) }","lvl0":"Golang 超大文件读取的两个方案","lvl1":["Go"],"lvl2":"摘要","objectID":"dfcb321cf5ae03299ceaad3152044a8e","tags":["Go"],"url":"/post/golang-%E8%B6%85%E5%A4%A7%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%A1%88/"},{"content":"ioutil.WriteFile 1 2 // 写入[]byte类型的data到filename文件中，文件权限为perm func WriteFile(filename string, data []byte, perm os.FileMode) error 示例: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import","lvl0":"Go中写文件的方式比较","lvl1":["Go"],"lvl2":"摘要","objectID":"6ebc9405d130e1ae81d1a0fdf73d23ae","tags":["Go"],"url":"/post/go%E4%B8%AD%E5%86%99%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83/"},{"content":"使用golang语言去读取一个文件默认会有多种方式，这里主要介绍以下几种。 ioutil.ReadFile 1 2 //读取文件内容，并返回[]byte数据和错误信息。err ==","lvl0":"Go中读文件的方式比较","lvl1":["Go"],"lvl2":"摘要","objectID":"e8beacc73183cad8b362a94f407c8249","tags":["Go"],"url":"/post/go%E4%B8%AD%E8%AF%BB%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83/"},{"content":"实现方法 1. 直接使用运算符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func BenchmarkAddStringWithOperator(b *testing.B) { hello := \u0026#34;hello\u0026#34; world := \u0026#34;world\u0026#34; for i := 0; i \u0026lt; b.N; i++ { _ = hello + \u0026#34;,\u0026#34; + world } } func BenchmarkAddMoreStringWithOperator(b *testing.B) { hello := \u0026#34;hello\u0026#34; world := \u0026#34;world\u0026#34; for i","lvl0":"寻找高效的字符串拼接方法","lvl1":["Go"],"lvl2":"摘要","objectID":"44638f7fd7e476e67853f4dc331fb317","tags":["Go"],"url":"/post/%E5%AF%BB%E6%89%BE%E9%AB%98%E6%95%88%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%96%B9%E6%B3%95/"},{"content":"func Compact func Compact(dst *bytes.Buffer, src []byte) error 将src删除空格符号,并附加到dst中 func HTMLEscape func HTMLEscape(dst *bytes.Buffer, src []byte) HTMLEscape 函数将json编码的src中的\u0026lt;、\u0026gt;、\u0026amp;、U+20","lvl0":"json包解析","lvl1":["Go标准库"],"lvl2":"摘要","objectID":"dcf2806c07dcafbd4a823783774d8d41","tags":["Go标准库"],"url":"/post/json%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"content":"开源Json库性能分析 Json 作为一种重要的数据格式，具有良好的可读性以及自描述性，广泛地应用在各种数据传输场景中。Go 语言里面原生支持了这种数据","lvl0":"开源Json库性能分析","lvl1":["Go"],"lvl2":"摘要","objectID":"97a8688a58c5f3a3bdf9a4371878cf81","tags":["Json"],"url":"/post/%E5%BC%80%E6%BA%90json%E5%BA%93%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"content":"问题描述: 今天学习 Golang 文件操作实践时，当我创建一个文件（夹）出现文件权限与我代码设置不一致的问题 以下为我创建文件夹的代码： 1 2 3 4 5 6 func main() { err","lvl0":"Go中新建文件的权限与设置不符的原因与解决方案","lvl1":["Go"],"lvl2":"摘要","objectID":"32f7ae721f6f8b001252f4d19a740606","tags":["Go"],"url":"/post/go%E4%B8%AD%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E7%9A%84%E6%9D%83%E9%99%90%E4%B8%8E%E8%AE%BE%E7%BD%AE%E4%B8%8D%E7%AC%A6%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"content":"当运行下面的代码时： 1 2 3 4 5 6 7 8 9 cmd := exec.Command(\u0026#34;find\u0026#34;, \u0026#34;/\u0026#34;, \u0026#34;-maxdepth\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;-exec\u0026#34;, \u0026#34;wc\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;{}\u0026#34;, \u0026#34;\\\\\u0026#34;) var out bytes.Buffer cmd.Stdout = \u0026amp;out err := cmd.Run() if err != nil { fmt.Println(err) return } fmt.Println(\u0026#34;Result: \u0026#34; + out.String()) 我得到这个错误： 1 exit status 1 解决方案是使用","lvl0":"如何运行exec.Command时输出详细错误信息","lvl1":["Go"],"lvl2":"摘要","objectID":"f58b149378f14cfa4d40b10f50224137","tags":["Go"],"url":"/post/%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8Cexec-command%E6%97%B6%E8%BE%93%E5%87%BA%E8%AF%A6%E7%BB%86%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF/"},{"content":"umask命令用来设置限制新建文件权限的掩码。当新文件被创建时，其最初的权限由文件创建掩码决定。用户每次注册进入系统时，umask命令都被执","lvl0":"umask命令解析","lvl1":["Shell"],"lvl2":"摘要","objectID":"db3eedd5ad806ccab5aa95962d626902","tags":null,"url":"/post/umask%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/"},{"content":"telnet telnet是windows标准服务，可以直接用；如果是linux机器，需要安装telnet. 用法: telnet ip port 1）先用telnet连接不存在的","lvl0":"linux端口连通性测试","lvl1":["Shell"],"lvl2":"摘要","objectID":"f6c71b410bda12a21027c88d3f222f4e","tags":["Shell"],"url":"/post/linux%E7%AB%AF%E5%8F%A3%E8%BF%9E%E9%80%9A%E6%80%A7%E6%B5%8B%E8%AF%95/"},{"content":"介绍 Supervisor是一个进程控制系统。 它是一个C/S系统,服务端是supervisord进程，控制端使用supervisorctl来进","lvl0":"supervisor安装与相关配置","lvl1":["工具"],"lvl2":"摘要","objectID":"580abe7b559589726ff2ccce45d2ab4e","tags":["supervisor"],"url":"/post/supervisor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"},{"content":"在 Linux 系统之下若想要查询发行版名称与版本的资讯有许多种方法，而不同的 Linux 发行版适用的方式也不同，以下整理了一些常见的方法。 查询 Linux 发行版与版本 Linux 发","lvl0":"如何查看linux版本","lvl1":["Linux"],"lvl2":"摘要","objectID":"214fc41fec5b9b420401077874e425cd","tags":["Linux"],"url":"/post/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8Blinux%E7%89%88%E6%9C%AC/"},{"content":"文件数可以从三个维度限制:分别为操作系统限制,shell限制,以及进程限制. 查看进程占用的句柄数 查看当前shell下的文件句柄数限制: ulimit -a 查","lvl0":"Linux:too many open files问题及解决方式","lvl1":["Linux"],"lvl2":"摘要","objectID":"8d99192d7822a66ca2b16e4acf2fb9f0","tags":["Linux"],"url":"/post/linux-too-many-open-files%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/"},{"content":"我们知道，HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样： 1 2 3","lvl0":"四种常见的POST提交数据方式","lvl1":["HTTP"],"lvl2":"摘要","objectID":"00ef2d4ce9d7456e03e5ec2512f016f3","tags":["HTTP"],"url":"/post/%E5%9B%9B%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84post%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E6%96%B9%E5%BC%8F/"},{"content":"func EqualFold 1 func EqualFold(s, t string) bool 判断两个utf-8编码字符串（将unicode大写、小写、标题三种格式字符视为相同）是否相同。 1 2 3 4 5 6 7 Example fmt.Println(strings.EqualFold(\u0026#34;Go\u0026#34;, \u0026#34;go\u0026#34;)) Output: true func HasPrefix 1","lvl0":"strings包解析","lvl1":["Go标准库"],"lvl2":"摘要","objectID":"21c25a99a6fe82f4a9692d50802bf555","tags":["Go标准库"],"url":"/post/strings%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"content":"Constants const IntSize = intSize IntSize是int或uint类型的字位数。 Variables var ErrRange = errors.New(\u0026quot;value out of range\u0026quot;) ErrRange表示超出目标类型表示范围。 var ErrSyntax = errors.New(\u0026quot;invalid syntax\u0026quot;) ErrSynta","lvl0":"strconv包解析","lvl1":["Go标准库"],"lvl2":"摘要","objectID":"b125847d08bd3d19232981d8b4f14f23","tags":["Go标准库"],"url":"/post/strconv%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"content":"Linux包含了多种文件压缩工具。虽然听上去不错，但这实际上经常会在用户下载文件时造成混淆。表4-7列出了Linux上的文件压缩工具。 gzi","lvl0":"tar命令详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"d14684b79eeb465830f6e8e169ba102b","tags":["Shell"],"url":"/post/tar%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"content":"jobs jos 命令用于显示 Linux 中的任务列表及任务状态，包括后台运行的任务。该命令可以显示任务号及其对应的进程号。其中，任务号是以普通用户的角度进行的，而","lvl0":"后台模式详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"7b4f891f70cd08d7699fde3b5d98a718","tags":["Shell"],"url":"/post/%E5%90%8E%E5%8F%B0%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"},{"content":"一、什么是SSH？ Secure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）所制定；SSH为一项创建在应用层和传输","lvl0":"SSH原理与运用","lvl1":["Shell"],"lvl2":"摘要","objectID":"bfab220361f99ef357d14777f0107bee","tags":["Shell"],"url":"/post/ssh%E5%8E%9F%E7%90%86%E4%B8%8E%E8%BF%90%E7%94%A8/"},{"content":"Linux scp命令 Linux scp命令用于Linux之间复制文件和目录。 scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件","lvl0":"scp命令详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"d33a0718194f8b6789850071085506fa","tags":["Shell"],"url":"/post/scp%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"content":"正则表达式 正则表达式是一种进行模式匹配和文本操纵的复杂而又强大的工具。虽然正则表达式比纯粹的文本匹配效率低，但是 它却更灵活。按照它的语法规则","lvl0":"regexp包解析","lvl1":["Go标准库"],"lvl2":"摘要","objectID":"ca1d7e340d2e888043e840576cb432e4","tags":["Go标准库"],"url":"/post/regexp%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"content":"概观 Package os为操作系统功能提供了一个平台无关的接口。虽然错误处理类似于 Go，但设计类似 Unix，失败的调用返回类型错误的值而不是错误号。错误中","lvl0":"os包解析","lvl1":["Go标准库"],"lvl2":"摘要","objectID":"1793c57949de37715c9c0d6bfb6cc685","tags":["Go标准库"],"url":"/post/os%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"content":"概观 包 exec 执行外部命令。它包装了 os.StartProcess ，以便重新映射 stdin 和 stdout ，使用管道连接 I/O 并进行其他调整。 与来自 C 和其他语言的“系统”库调用不同，os/exec 包","lvl0":"os:exec包解析","lvl1":["Go标准库"],"lvl2":"摘要","objectID":"72fbfb263f2c2412a7a72d0f4bb58c13","tags":["Go标准库"],"url":"/post/os-exec%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"content":"func PathEscape 1 func PathEscape(s string) string PathEscape转义字符串，以便可以安全地放置在URL路径段中。 根据需要用％XX序列替换特殊字符（包括/） func PathUnescape 1 func PathUnescape(s string) (string, error)","lvl0":"package:url(1.13)","lvl1":["Go标准库"],"lvl2":"摘要","objectID":"cbd295e205e58afd3d46c76b4eaa1d6f","tags":["Go标准库"],"url":"/post/packageurl1.13/"},{"content":"type File 1 2 3 4 5 6 type File interface { io.Reader io.ReaderAt io.Seeker io.Closer } File是一个接口，实现了对一个multipart信息中文件记录的访问。它的内容可以保持在内存或者硬盘中，","lvl0":"multipart包解析","lvl1":["Go标准库"],"lvl2":"摘要","objectID":"19b0dd7cc9952d036bb1f1f5784b3f13","tags":["Go标准库"],"url":"/post/multipart%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"content":"概论 lsof命令用于查看你进程打开的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。是十分方便的系统监视工具，","lvl0":"lsof命令详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"2b03371f6c31964201ec7a204e80fb01","tags":["Shell"],"url":"/post/lsof%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"content":"kill命令 kill命令用来删除执行中的程序或工作。kill可将指定的信息送至程序。预设的信息为SIGTERM(15),可将指定程序终止。若","lvl0":"kill命令详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"e9fb4a258d4cc649483794c51e81eda8","tags":["Shell"],"url":"/post/kill%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"content":"Variables var EOF = errors.New(\u0026quot;EOF\u0026quot;) EOF当无法得到更多输入时，Read方法返回EOF。当函数一切正常的到达输入的结束时，就应返回EOF。如果在一个结构化数据流中EO","lvl0":"io包解析","lvl1":["Go标准库"],"lvl2":"摘要","objectID":"aadd14694de3f70a1bd914c8e2c34400","tags":["Go标准库"],"url":"/post/io%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"content":"Variables var Discard io.Writer = devNull(0) Discard是一个io.Writer接口，对它的所有Write调用都会无实际操作的成功返回。 func NopCloser func NopCloser(r io.Reader) io.ReadCloser NopCloser用一","lvl0":"ioutil包解析","lvl1":["Go标准库"],"lvl2":"摘要","objectID":"6af502b7deb45903342d188de3b69be9","tags":["Go标准库"],"url":"/post/ioutil%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"content":"预设值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 const ( StatusContinue = 100 StatusSwitchingProtocols = 101 StatusOK = 200 StatusCreated = 201 StatusAccepted = 202 StatusNonAuthoritativeInfo = 203 StatusNoContent = 204 StatusResetContent","lvl0":"http包解析","lvl1":["Go标准库使用"],"lvl2":"摘要","objectID":"927fe870e55730261033c3d6213ed2a9","tags":["Go标准库使用"],"url":"/post/http%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"content":"交叉编译 通俗地讲就是在一种平台上编译出能运行在体系结构不同的另一种平台上的程序，比如在PC平台（X86 CPU）上编译出能运行在以ARM为内核","lvl0":"Go的交叉编译","lvl1":["Go"],"lvl2":"摘要","objectID":"9370d4f476f6daa4da966a0cb4c9f87a","tags":["Go"],"url":"/post/go%E7%9A%84%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"},{"content":"客户端:发送请求 http.Get GET请求的数据会附在URL之后(就是把数据放置在HTTP协议头中), ?分割URL和传输数据，参数之间以\u0026amp;相连. G","lvl0":"Go中的HTTP操作总结","lvl1":["Go"],"lvl2":"摘要","objectID":"b551f30526e64115c846d5cb4f5b0a65","tags":["Go","HTTP"],"url":"/post/go%E4%B8%AD%E7%9A%84http%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"},{"content":"编码 数据结构map json源于javascript的对象结构，golang中直接对应其数据结构，可是golang的map也是key-valu","lvl0":"Go中的Json编解码总结","lvl1":["Go"],"lvl2":"摘要","objectID":"d3b9c37cc3f02aad0171776df240f64a","tags":["Json"],"url":"/post/go%E4%B8%AD%E7%9A%84json%E7%BC%96%E8%A7%A3%E7%A0%81%E6%80%BB%E7%BB%93/"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70","lvl0":"Gin源码剖析:gin","lvl1":["Gin"],"lvl2":"摘要","objectID":"c2dcb66488c769ddf148e15967ad9267","tags":["Gin"],"url":"/post/gin%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-gin/"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70","lvl0":"Gin源码剖析:context","lvl1":["Gin"],"lvl2":"摘要","objectID":"e7731edbe76acf79240afa403e056df3","tags":["Gin"],"url":"/post/gin%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-context/"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70","lvl0":"Gin源码剖析:auth","lvl1":["Gin"],"lvl2":"摘要","objectID":"09268a0a6b2d7f45a3b7ddbb477787b7","tags":["Gin"],"url":"/post/gin%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-auth/"},{"content":"Printing verb： 通用： 1 2 3 4 5 %v 值的默认格式表示 %+v 类似%v，但输出结构体时会添加字段名 %#v 值的Go语法表示 %T 值的类型的Go语法表示 %% 百分号 布尔值","lvl0":"fmt包解析","lvl1":["Go标准库"],"lvl2":"摘要","objectID":"49405850a23eef3203dfec7d52c3fa46","tags":["Go标准库"],"url":"/post/fmt%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"content":"Constants 1 2 3 4 const ( // 用于缓冲一个token，实际需要的最大token尺寸可能小一些，例如缓冲中需要保存一整行内容 MaxScanTokenSize = 64 * 1024 ) Variables 1 2 3 4 5 6 var ( ErrInvalidUnreadByte","lvl0":"bufio包解析","lvl1":["Go标准库"],"lvl2":"摘要","objectID":"00945bd704db2877e8451ee9ea543623","tags":["Go标准库"],"url":"/post/bufio%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"content":"1 01背包问题 1.1 题目 1.2 基本思路 1.3 优化空间复杂度 1.4 初始化的细节问题 1.5 一个常数优化 1.6 小结 01背包问题是最基本的背包问题，它包含了背包问题中设计状","lvl0":"背包九讲","lvl1":["算法"],"lvl2":"摘要","objectID":"c8341002cb26386a5accdb86f84e8cbc","tags":null,"url":"/post/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/"},{"content":"LeetCode 310. Minimum Height Trees For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels. Format The graph contains n nodes which","lvl0":"查找二叉树的中心节点","lvl1":["解题报告"],"lvl2":"摘要","objectID":"323cefea2d427cb6d19eaf27e6503384","tags":["BFS"],"url":"/post/%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BF%83%E8%8A%82%E7%82%B9/"},{"content":"背景知识： 守护进程是脱离终端并在后台运行的进程，执行过程中信息不会显示在终端上并且也不会被终端发出的信号打断。 操作步骤： 创建子进程，父进程退","lvl0":"守护进程详解","lvl1":null,"lvl2":"摘要","objectID":"12b546381beda7fee703fff594ff0775","tags":null,"url":"/post/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E8%AF%A6%E8%A7%A3/"},{"content":"简介 每一个进程是资源分配的基本单位。进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。实际上在","lvl0":"多进程模型详解","lvl1":["Linux编程"],"lvl2":"摘要","objectID":"4ab90e1c87413257d22f4ccde76f1fa6","tags":null,"url":"/post/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"},{"content":"同一主机上的进程通信方式 UNIX进程间通信方式: 包括管道(PIPE), 有名管道(FIFO), 和信号(Signal) System V进程通信方式：包括信号","lvl0":"进程间通信方式(IPC)总结","lvl1":["Linux编程"],"lvl2":"摘要","objectID":"b9b015fa60325e17cb1ef138ece45330","tags":null,"url":"/post/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8Fipc%E6%80%BB%E7%BB%93/"},{"content":"ifconfig host和nslookup route","lvl0":"ifconfig和route和nslookup和host命令详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"f8186b15e6fa4d6995c9096241d204f2","tags":null,"url":"/post/ifconfig%E5%92%8Croute%E5%92%8Cnslookup%E5%92%8Chost%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"content":"ps 当程序运行在系统上时，我们称之为进程(process)。想监测这些进程，需要熟悉ps命令的用法。 默认情况下，ps命令并不会提供那么多的信息","lvl0":"top和ps和pgrep命令详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"6ea52db86e4c88c154690f126a2af705","tags":null,"url":"/post/top%E5%92%8Cps%E5%92%8Cpgrep%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"content":"","lvl0":"列出1小时内占用CPU最多的10个进程","lvl1":["Shell"],"lvl2":"摘要","objectID":"224e498aa349019b8364670dfeede494","tags":null,"url":"/post/%E5%88%97%E5%87%BA1%E5%B0%8F%E6%97%B6%E5%86%85%E5%8D%A0%E7%94%A8cpu%E6%9C%80%E5%A4%9A%E7%9A%8410%E4%B8%AA%E8%BF%9B%E7%A8%8B/"},{"content":"","lvl0":"找出指定目录中最大的10个文件","lvl1":["Shell"],"lvl2":"摘要","objectID":"120e3cd9896753a70885eaeed8b4b8bd","tags":null,"url":"/post/%E6%89%BE%E5%87%BA%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%8410%E4%B8%AA%E6%96%87%E4%BB%B6/"},{"content":"基本内容 你会经常需要在大文件中找一行数据，而这行数据又埋藏在文件的中间。这时并不需要手动 翻看整个文件，用grep命令来帮助查找就行了。gre","lvl0":"grep命令详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"3f00e4109a088b8d9641ec2e25746246","tags":null,"url":"/post/grep%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"content":"wc命令可以对对数据中的文本进行计数。默认情况下，它会输出3个值: 文本的行数 文本的词数 文本的字节数 通过将文本文件重定向到wc命令，你立刻就可","lvl0":"wc命令详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"ff35ddc43983e03534322d6b69ed3a0b","tags":null,"url":"/post/wc%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"content":"简介 当査看上千行的大文件时，我们可不会用cat命令把整个文件内容给打印出来。相反，我们 只会査看文件的一小部分内容（例如文件的前10行或后10","lvl0":"head与tail命令详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"c218880af26402b50f1cf56162d407f3","tags":null,"url":"/post/head%E4%B8%8Etail%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"content":"简介 同文本文件打交道时，总避不开排序，那是因为对于文本处理任务而言，排序（sort)可以起到不小的作用。sort命令能够帮助我们对文本文件和","lvl0":"sort和uniq命令详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"98f6e16fba356bd400beaca39294c77a","tags":null,"url":"/post/sort%E5%92%8Cuniq%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"content":"简介 find是UNIX/Linux命令行工具箱中最棒的工具之一。这个命令对编写shell脚本很有帮助，但是多数人由于对它缺乏认识，并不能有效","lvl0":"find命令详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"1190d7e714e3ce0506c71fa25ed6bfbb","tags":null,"url":"/post/find%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"content":"bash shell会跟踪你用过的命令。你可以唤回这些命令 并重新使用。 要查看最近用过的命令列表，可以输入不带选项的history命令。 你可以设置保存","lvl0":"history命令详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"c00c567d990ca287442eb8566d836cb8","tags":null,"url":"/post/history%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"content":"alias命令别名允许你为常用的命令(及其参数)创建另一 个名称，从而将输入量减少到最低。 要查看当前可用的别名，使用alias命令以及选项-p","lvl0":"alias命令详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"139f87348c2b40442060eb353044ca1d","tags":null,"url":"/post/alias%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"content":"数组变量 环境变量有一个很酷的特性就是，它们可作为数组使用。数组是能够存储多个值的变量。这 些值可以单独引用，也可以作为整个数组来引用。 要给某个","lvl0":"数组和关联数组","lvl1":["Shell"],"lvl2":"摘要","objectID":"27c30565298b9222a6a0da068f05ad3f","tags":null,"url":"/post/%E6%95%B0%E7%BB%84%E5%92%8C%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84/"},{"content":"头文件: #include \u0026lt;iterator\u0026gt; 函数原型: 1 2 template \u0026lt;class Container\u0026gt; back_insert_iterator\u0026lt;Container\u0026gt; back_inserter (Container\u0026amp; x); 用法: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47","lvl0":"back_inserter()用法","lvl1":["STL"],"lvl2":"摘要","objectID":"f4c3f7f56b03240c219f77dafd6c1024","tags":null,"url":"/post/-stdcopy%E5%92%8Cstdback_inserter%E7%94%A8%E6%B3%95/"},{"content":"df(Disk Free) df命令直接读取分区的超级块信息获取分区使用情况。它的数据是基于分区元数据的，所以只能针对整个分区。由于df直接读取超级块，所以运行速度","lvl0":"df和du命令详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"9ee8ab571bf7ad54089879b6f48f6747","tags":null,"url":"/post/df%E5%92%8Cdu%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"content":"echo echo是用于终端打印的基本命令。 在默认情况下，echo会将一个换行符追加到输出文本的尾部。可以使用标志-n来忽略结尾的换行符。 $ echo \u0026quot;Welcome to Bash\u0026quot;","lvl0":"echo命令与printf命令详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"9750a9b38bea995908d7909c17e584ba","tags":null,"url":"/post/echo%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"content":"虚函数和纯虚函数有以下方面的区别。 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖","lvl0":"虚函数与纯虚函数的区别","lvl1":["C++"],"lvl2":"摘要","objectID":"bfe3d9f8b98244e6776828aa63ba019e","tags":null,"url":"/post/%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"content":"“野指针”不是NULL指针，而是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，i","lvl0":"野指针及其危害","lvl1":["C++"],"lvl2":"摘要","objectID":"b4903b88093085b3a465d9a479c2ff9a","tags":null,"url":"/post/%E9%87%8E%E6%8C%87%E9%92%88%E5%8F%8A%E5%85%B6%E5%8D%B1%E5%AE%B3/"},{"content":"指针的比较 数组用作比较,自动退化为指向首元素的指针. 对指针指向字符串的修改 非常量指针在初始化可以指向字符串常量. 上面的代码中，node1和n","lvl0":"指向常量字符串的指针","lvl1":["C++"],"lvl2":"摘要","objectID":"31d89bf24c86b6c280fe55bffd073343","tags":null,"url":"/post/%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8C%87%E9%92%88/"},{"content":"这里需要明白类函数是如何被编译以及如何被执行的。 对于类成员函数而言，并不是一个对象对应一个单独的成员函数体，而是此类的所有对象共用这个成员函","lvl0":"类函数与this指针","lvl1":["C++"],"lvl2":"摘要","objectID":"05dd9c049780d371ba01197aeae2b523","tags":null,"url":"/post/%E7%B1%BB%E5%87%BD%E6%95%B0%E4%B8%8Ethis%E6%8C%87%E9%92%88/"},{"content":"C++可以给函数定义默认参数值。在函数调用时没有指定与形参相对应的实参时，就自动 使用默认参数。 默认参数的语法与使用： 在函数声明或定义时，直接","lvl0":"C++中的默认参数","lvl1":["C++"],"lvl2":"摘要","objectID":"10349f334a87aa8670fd2211da918ea6","tags":null,"url":"/post/c-%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/"},{"content":"如果编译器在编译cpp文件，那么_Cplusplus就会被定义，如果是一个c文件在被编译，那么_STDC_就会被定义。_STDC_是预定义宏","lvl0":"如何判断一段程序是由C编译还是由C++编译","lvl1":["C++"],"lvl2":"摘要","objectID":"05331413110cf21a177cc9b5e541b73a","tags":null,"url":"/post/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E6%AE%B5%E7%A8%8B%E5%BA%8F%E6%98%AF%E7%94%B1c%E7%BC%96%E8%AF%91%E8%BF%98%E6%98%AF%E7%94%B1c-%E7%BC%96%E8%AF%91/"},{"content":"","lvl0":"如何建立和理解非常复杂的声明","lvl1":["C++"],"lvl2":"摘要","objectID":"0934cc6510db2655d827ea9e211892e0","tags":null,"url":"/post/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%90%86%E8%A7%A3%E9%9D%9E%E5%B8%B8%E5%A4%8D%E6%9D%82%E7%9A%84%E5%A3%B0%E6%98%8E/"},{"content":"采用构造函数与静态构造变量结合的方法实现。首先在类中定义一个静态成员变量，然后在构造函数里面打印该静态变量的值，并对静态变量进行自增操作，同","lvl0":"不用流程控制语句,如何打印1~1000的数","lvl1":["C++"],"lvl2":"摘要","objectID":"df33cd737da1e650fe7bac8eb72b5406","tags":null,"url":"/post/%E4%B8%8D%E7%94%A8%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5-%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B01-1000%E7%9A%84%E6%95%B0/"},{"content":"同一个数可以通过不同的方式表达出来，对于函数的访问，变量的赋值除了直接对变量赋值以外，还可以通过绝对内存地址进行参数赋值与函数调用。 1) 通过地","lvl0":"通过绝对内存地址进行参数赋值与函数调用","lvl1":["C++"],"lvl2":"摘要","objectID":"d954a87fd1033bed08fd6504105c3c5f","tags":null,"url":"/post/%E9%80%9A%E8%BF%87%E7%BB%9D%E5%AF%B9%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8C%E5%8F%82%E6%95%B0%E8%B5%8B%E5%80%BC%E4%B8%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"},{"content":"对0值取反，不同位数下的0值取反，其结果不一样。例如，在32位机器下，按位取反运算，结果为1111111111111111111111111","lvl0":"不用sizeof(),如何判断操作系统是16位还是32位","lvl1":["解题报告 "],"lvl2":"摘要","objectID":"ece9677388bed268be699be03a25d716","tags":["Bit Manipulation"],"url":"/post/%E4%B8%8D%E7%94%A8sizeof-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF16%E4%BD%8D%E8%BF%98%E6%98%AF32%E4%BD%8D/"},{"content":"当表达式中存在有符号类型和无符号类型时，所有的操作数都自动转换成无符号类型。 例一 运行如下程序： 1 2 3 4 5 #include \u0026lt;stdio.h\u0026gt;int main() unsigned int i=3; printf(\u0026#34;\u0026#34;%u\\n,i*-1); return 0; 程序输出结果： 4294967293 在","lvl0":"包含无符号数的计算","lvl1":["C++"],"lvl2":"摘要","objectID":"a512f070b88d763520449a9e40854cfb","tags":null,"url":"/post/%E5%8C%85%E5%90%AB%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97/"},{"content":"","lvl0":"利用位运算计算数的绝对值","lvl1":["解题报告 "],"lvl2":"摘要","objectID":"73dacde8055c3b7040b4bf4029c35915","tags":["Bit Manipulation"],"url":"/post/%E5%88%A9%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E8%AE%A1%E7%AE%97%E6%95%B0%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%80%BC/"},{"content":"","lvl0":"实现位运算求两个数的平均值","lvl1":["解题报告 "],"lvl2":"摘要","objectID":"b41663fdc4d69a180fa7d0bb3fb5e9ef","tags":["Bit Manipulation"],"url":"/post/%E5%AE%9E%E7%8E%B0%E4%BD%8D%E8%BF%90%E7%AE%97%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC/"},{"content":"struct (结构体）与union (联合体）是C语言中两种不同的数据结构，两者都是常见的复合结构，其区别主要表现在以下两个方面： 结构体与联合体虽然都是","lvl0":"struct和union的区别","lvl1":["C++"],"lvl2":"摘要","objectID":"d55acda59f00c337d7da443db3969979","tags":null,"url":"/post/struct%E5%92%8Cunion%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"content":"typedef与define都是替一个对象取一个别名，以此来增强程序的可读性，但是它们在使用和作用上也存在着以下几个方面的不同： 1) 原理不同。","lvl0":"typedef和define的区别","lvl1":["C++"],"lvl2":"摘要","objectID":"06c0f074ad2d8b9409b3be79d92d2b79","tags":null,"url":"/post/typedef%E5%92%8Cdefine%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"content":"通过改变符号位判断。把A进行一个位运算，将最高位置1,判断是否大于0。 程序示例如下： 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt;int main() { unsigned A = 10; A = A|(1\u0026lt;\u0026lt;31); if(A \u0026gt; 0) pri","lvl0":"如何判断一个变量是有符号数还是无符号数","lvl1":["解题报告"],"lvl2":"摘要","objectID":"2d60a386ff1c571cddd78e0b25bbc8c2","tags":null,"url":"/post/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%98%AF%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E8%BF%98%E6%98%AF%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0/"},{"content":"转载:https://coolshell.cn/articles/10478.html C++ 的一个常见面试题是让你实现一个 String 类，限于时间，不可能","lvl0":"string类的一种正确写法","lvl1":["C++"],"lvl2":"摘要","objectID":"9411d023c45aab339fd7e442d4375403","tags":null,"url":"/post/string%E7%B1%BB%E7%9A%84%E4%B8%80%E7%A7%8D%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95/"},{"content":"在windows下，栈地址是向低地址扩展的数据结构，是一块连续的内存区域。栈顶的地址和栈的最大容量是系统预先规定好的，在windows下，栈","lvl0":"栈空间的最大值是多少?","lvl1":["C++"],"lvl2":"摘要","objectID":"9e6d5bbe955a7ee701f15a59e80adea8","tags":null,"url":"/post/%E6%A0%88%E7%A9%BA%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E6%98%AF%E5%A4%9A%E5%B0%91/"},{"content":"转载http://blog.csdn.net/fengbingchun/article/details/51168728 C++中的关键字ex","lvl0":"解析“explicit”","lvl1":["C++"],"lvl2":"摘要","objectID":"1a265d32987ab70e315f93720d79bce9","tags":null,"url":"/post/%E8%A7%A3%E6%9E%90explicit/"},{"content":"为了访问其他编译单元（如另一代码文件）中的变量或对象，对普通类型（包括基本数据类、结构和类），可以利用关键字extern，来使用这些变量或对","lvl0":"解析\"export\"","lvl1":["C++"],"lvl2":"摘要","objectID":"b17a7f77f70a439cbbe24738e65bb718","tags":null,"url":"/post/%E8%A7%A3%E6%9E%90export/"},{"content":"以++操作为例，对于变量a, ++a表示取a的地址，增加它的内容，然后把值放在寄存器 中；a++表示取a的地址，把它的值装入寄存器，然后增加内存","lvl0":"前置运算符和后置运算符的区别","lvl1":["C++"],"lvl2":"摘要","objectID":"13d3871de26e6a476dbb4bcc56235492","tags":null,"url":"/post/%E5%89%8D%E7%BD%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E5%90%8E%E7%BD%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"content":"","lvl0":"C语言中操作符的优先级总结","lvl1":["C++"],"lvl2":"摘要","objectID":"19dce6c27ee4b57d2344ed01a943068e","tags":null,"url":"/post/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%80%BB%E7%BB%93/"},{"content":"指针可以随时指向任意类型的内存块，而数组可以在静态存储区被创建。例如，全局数组 可以在栈上被创建。从原理与定义上看，虽然指针与数组表示的是不同","lvl0":"数组和指针的区别","lvl1":["C++"],"lvl2":"摘要","objectID":"58cb0817aae1dcc914f335b1c913c380","tags":null,"url":"/post/%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"content":"题目: 给定一个整型数组arr,数组中的每个值都为正数，表示完成一幅画作需要的时间，再给定一个整数num表示画匠的数量，每个画匠只能画连在一起","lvl0":"画匠问题","lvl1":["解题报告"],"lvl2":"摘要","objectID":"9f1a3d105ad01eba4153b1169170a6f3","tags":["DP"],"url":"/post/%E7%94%BB%E5%8C%A0%E9%97%AE%E9%A2%98/"},{"content":"题目: 举例: 解析: map[i][j]的意义为i个棋子扔j次最多搞定的楼数。 0 1 2 3 4 5 6 7 8 9 10 -\u0026gt;次数 1 0 1 2 3 4 5 6 7 8 9 10 2 0 1","lvl0":"丢棋子问题","lvl1":["解题报告"],"lvl2":"摘要","objectID":"ae03c4e41a68ed1c397da51fdfa086dd","tags":["DP"],"url":"/post/%E4%B8%A2%E6%A3%8B%E5%AD%90%E9%97%AE%E9%A2%98/"},{"content":"LeetCode 4. Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 解","lvl0":"两个排序数组中的查找问题","lvl1":["解题报告"],"lvl2":"摘要","objectID":"96a844f749d0175c0c5db8e820bd31c9","tags":["Binary Search","heap"],"url":"/post/%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98/"},{"content":"题目: 要求: 消息流最终会吐出全部的1〜N当然最终也会打印完所有的要求接收和打印1~N的整个过程,时间复杂度为O(N)的。 解析: 1 2 3 4 5 6 7","lvl0":"一种消息接收并打印的结构设计","lvl1":["解题报告"],"lvl2":"摘要","objectID":"97a9601daf3d0e9c3407c24b72ee6d55","tags":["Design"],"url":"/post/%E4%B8%80%E7%A7%8D%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%E5%B9%B6%E6%89%93%E5%8D%B0%E7%9A%84%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"},{"content":"题目: 给定一个长度为N且没有重复元素的数组air和一个整数n,实现函数等概率随机打印arr中的M个数。 要求: 相同的数不要重复打印。 时间复杂度","lvl0":"从N个数中等概率打印M个数","lvl1":["解题报告"],"lvl2":"摘要","objectID":"bdfbea6f2cc2e323b27782cfa1a7238d","tags":["Random"],"url":"/post/%E4%BB%8En%E4%B8%AA%E6%95%B0%E4%B8%AD%E7%AD%89%E6%A6%82%E7%8E%87%E6%89%93%E5%8D%B0m%E4%B8%AA%E6%95%B0/"},{"content":"题目: 给定一个正数数组arr,其中所有的值都为整数，以下是最小不可组成和的概念： 把arr每个子集内的所有元素加起来会出现很多值，其中最小的记","lvl0":"正整数数组的最小不可组成和","lvl1":["解题报告"],"lvl2":"摘要","objectID":"b0a73437e7a82a3ccab9af946c59216b","tags":["背包DP"],"url":"/post/%E6%AD%A3%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E4%B8%8D%E5%8F%AF%E7%BB%84%E6%88%90%E5%92%8C/"},{"content":"题目: 要求: 如果paths长度为N，请达到时间复杂度为O(N),额外空间复杂度为0(1)。 解析: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22","lvl0":"路径数组变为统计数组","lvl1":["解题报告"],"lvl2":"摘要","objectID":"07f9b088c5b66278ed7caae776c0d191","tags":["Array"],"url":"/post/%E8%B7%AF%E5%BE%84%E6%95%B0%E7%BB%84%E5%8F%98%E4%B8%BA%E7%BB%9F%E8%AE%A1%E6%95%B0%E7%BB%84/"},{"content":"题目: 解析: 1 2 3 4 5 6 7 8 9 10 public static double randXPowerK(int k) { if (k \u0026lt; 1) { return 0; } double res = -1; for (int i = 0; i != k; i++) { res = Math.max(res, Math.random()); } return res; }","lvl0":"调整[0,x)区间上的数出现的频率","lvl1":["解题报告"],"lvl2":"摘要","objectID":"360e0880dd1674aa3792454d97122b2a","tags":["Random"],"url":"/post/%E8%B0%83%E6%95%B40x%E5%8C%BA%E9%97%B4%E4%B8%8A%E7%9A%84%E6%95%B0%E5%87%BA%E7%8E%B0%E7%9A%84%E9%A2%91%E7%8E%87/"},{"content":"题目: 给定一个长度为N的整型数组arr,可以划分成左右两个部分，左部分为arr[O..K],右部分为arr[K+1..N-1], K可以取值的","lvl0":"最大的leftMax与rightMax之差的绝对值","lvl1":["解题报告"],"lvl2":"摘要","objectID":"ce108b8a802e07dbcde559e84d6b1e70","tags":null,"url":"/post/%E6%9C%80%E5%A4%A7%E7%9A%84leftmax%E4%B8%8Erightmax%E4%B9%8B%E5%B7%AE%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%80%BC/"},{"content":"题目: 哈希表常见的三个操作是put、get和containsKey,而且这三个操作的时间复杂度为O(1)。现在想加一个setAll功能，就是","lvl0":"设计有setAll功能的哈希表","lvl1":["解题报告"],"lvl2":"摘要","objectID":"516abe24785ab77603a293e9e349384c","tags":null,"url":"/post/%E8%AE%BE%E8%AE%A1%E6%9C%89setall%E5%8A%9F%E8%83%BD%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"content":"算法简介 在不知道文件总行数的情况下，如何从文件中随机的抽取一行？ 首先想到的是我们做过类似的题目吗?当然，在知道文件行数的情况下，我们可以很容","lvl0":"蓄水池算法","lvl1":["解题报告"],"lvl2":"摘要","objectID":"808b042e32b2554a7f50b318803dbd37","tags":null,"url":"/post/%E8%93%84%E6%B0%B4%E6%B1%A0%E7%AE%97%E6%B3%95/"},{"content":"题目: 请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折i次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从","lvl0":"折纸问题","lvl1":["解题报告"],"lvl2":"摘要","objectID":"110e15906f9fabac7344a6b8eebdf83a","tags":["递归"],"url":"/post/%E6%8A%98%E7%BA%B8%E9%97%AE%E9%A2%98/"},{"content":"accumulate 介绍 template \u0026lt;class InputIterator, class T\u0026gt; T accumulate (InputIterator first, InputIterator last, T init); template \u0026lt;class InputIterator, class T, class BinaryOperation\u0026gt; T accumulate (InputIterator first, InputIterator last, T init, BinaryOperation binary_op); 1 2 3 4 5 6 7 8 9 template \u0026lt;class InputIterator, class T\u0026gt; T accumulate (InputIterator first, InputIterator last, T init) { while (first!=last) { init = init + *first; // or: init=binary_op(init,*first) for the binary_op","lvl0":"numeric库操作总结","lvl1":["STL"],"lvl2":"摘要","objectID":"583e8cdce2555ff50ed19bf1a1a73223","tags":null,"url":"/post/numeric-%E5%BA%93%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"},{"content":"hashtable的数据结构 bucket所维护的linked list，并不采用STL的list或slist，而是自行维护上述的hashtab","lvl0":"数据结构:unordered_map、unordered_set","lvl1":["STL"],"lvl2":"摘要","objectID":"a98ce882fabe0e0b6291f0112c5bad79","tags":null,"url":"/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-unordered-mapunordered-set/"},{"content":"set et的特性是，所有元素都会根据元素的键值自动被排序。set的元素不像map那样可以同时拥有实值（m/m)和键值，set元素的键值就是实值，","lvl0":"数据结构:set、multiset、map、multimap","lvl1":["STL"],"lvl2":"摘要","objectID":"0797f985fbb111fd75bb2edb9729d3d7","tags":null,"url":"/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-setmultisetmapmultimap/"},{"content":"list 概述 相较于vector的连续线性空间，list就显得复杂许多，它的好处是每次插入或删除一个元素，就配置或释放一个元素空间。因此，list对","lvl0":"数据结构:list、forward_list","lvl1":["STL"],"lvl2":"摘要","objectID":"7606ef780107bc26dcdd56a7948fd00c","tags":null,"url":"/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-listforward-list/"},{"content":"deque 概述 vector是单向开口的连续线性空间，deque则是一种双向开口的连续线性空 间。所谓双向开口，意思是可以在头尾两端分别做元素的插人和删","lvl0":"数据结构:deque、stack、queue","lvl1":["STL"],"lvl2":"摘要","objectID":"8a8381ca56b140d93301829419f357ad","tags":null,"url":"/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-dequestackqueue/"},{"content":"vector 概述 vector的数据安排以及操作方式，与array非常相似。两者的唯一差别在于 空间的运用的灵活性。array是静态空间，一旦配置了就不能","lvl0":"数据结构:vector、priority_queue","lvl1":["STL"],"lvl2":"摘要","objectID":"1b5c003b8bb9a3c7d44935549d15decf","tags":null,"url":"/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-vectorpriority-queue/"},{"content":"Allocator 一般而言，我们所习惯的C++内存配置操作和释放操作是这样的: class Foo {}； Foo* pf = new Foo； // 配置内存，然后构造对象 delete pf； //将对象析构，然后","lvl0":"空间配置器Allocator","lvl1":["STL"],"lvl2":"摘要","objectID":"55659aa6adf6344d8093fe306560ddb3","tags":null,"url":"/post/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8allocator/"},{"content":"判断一个点是否在矩形内部 题目: 在二维坐标系中，所有的值都是double类型那么一个矩形可以由4个点来代表:（x1,y1)为最左的点、（x2,","lvl0":"判断点是否在图形内部","lvl1":["解题报告"],"lvl2":"摘要","objectID":"914e0cd497654df2437675c27645d010","tags":["ath"],"url":"/post/%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%9B%BE%E5%BD%A2%E5%86%85%E9%83%A8/"},{"content":"LeetCode 172. Factorial Trailing Zeroes Given an integer n, return the number of trailing zeroes in n!. Note: Your solution should be in logarithmic time complexity. 解析： 这个问题很简单。 因为所有的尾随0来自因子5 2。 计算包含的2和5组成的pair的个数","lvl0":"阶乘相关问题","lvl1":["解题报告"],"lvl2":"摘要","objectID":"9363fff3b6bd3622b7780113f39412f0","tags":["Math"],"url":"/post/%E9%98%B6%E4%B9%98%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"},{"content":"malloc()函数 malloc的全称是memory allocation，中文叫动态内存分配。 extern void *malloc(unsigned int num_bytes); 说明： 分配长度为num_bytes字","lvl0":"malloc/free的用法详解","lvl1":["C++ "],"lvl2":"摘要","objectID":"db5362eedce52dec854d53d948144d5b","tags":null,"url":"/post/malloc-free%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"content":"题目一 给定一个等概率随机产生1〜5的随机函数rand1To5如下： public int randlTo5() { return (int) (Math.random() * 5) + 1; } 除此之外，不能使用任何额外的随机机制，请用rand","lvl0":"从5随机到7随机及其扩展","lvl1":["解题报告"],"lvl2":"摘要","objectID":"1776c06d7678f95a1e17b8a6c0a31959","tags":["Math"],"url":"/post/%E4%BB%8E5%E9%9A%8F%E6%9C%BA%E5%88%B07%E9%9A%8F%E6%9C%BA%E5%8F%8A%E5%85%B6%E6%89%A9%E5%B1%95/"},{"content":"题目: 给定一个无序整型数组arr,找到数组中未出现的最小正整数。 解析: 1 2 3 4 5 6 7 8 9 10 11 12 13 public static int missNum(int[] arr) { int l = 0; int r = arr.length; while (l \u0026lt; r) { if (arr[l] ==","lvl0":"数组中未出现的最小正整数","lvl1":["解题报告"],"lvl2":"摘要","objectID":"517c953bb8ce5b6c3904c7757d49904f","tags":["Array"],"url":"/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%AA%E5%87%BA%E7%8E%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0/"},{"content":"题目: 有N个长度不一的数组，所有的数组都是有序的，请从大到小打印这N个数组整体最大的前K个数。 例如，输入含有N行元素的二维数组可以代表N个一","lvl0":"打印N个数组整体最大的Top K","lvl1":["解题报告"],"lvl2":"摘要","objectID":"f20a9b69b7745a83562628496bab1a08","tags":["Array","Heap"],"url":"/post/%E6%89%93%E5%8D%B0n%E4%B8%AA%E6%95%B0%E7%BB%84%E6%95%B4%E4%BD%93%E6%9C%80%E5%A4%A7%E7%9A%84top-k/"},{"content":"题目: 解析: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public static int getLessIndex(int[] arr) { if (arr == null || arr.length == 0) { return -1; // no exist } if (arr.length == 1 || arr[0] \u0026lt; arr[1]) { return 0; } if (arr[arr.length - 1] \u0026lt; arr[arr.length","lvl0":"在数组中找到一个局部最小的位置","lvl1":["解题报告"],"lvl2":"摘要","objectID":"d5a6ede8e488f69ab2cc9d02f359b0c7","tags":["Binary Search"],"url":"/post/%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E5%B1%80%E9%83%A8%E6%9C%80%E5%B0%8F%E7%9A%84%E4%BD%8D%E7%BD%AE/"},{"content":"LeetCode 238. Product of Array Except Self Given an array of n integers where n \u0026gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Solve it without division and in O(n). For example, given [1,2,3,4], return [24,12,8,6]. Follow up: Could you solve it with constant space complexity? (Note: The output array does not count as extra","lvl0":"不包含本位置值的累乘数组","lvl1":["解题报告"],"lvl2":"摘要","objectID":"2634c512712cfcec3978fa2da1f41e20","tags":["Array"],"url":"/post/%E4%B8%8D%E5%8C%85%E5%90%AB%E6%9C%AC%E4%BD%8D%E7%BD%AE%E5%80%BC%E7%9A%84%E7%B4%AF%E4%B9%98%E6%95%B0%E7%BB%84/"},{"content":"题目: 给定一个长度为N的整型数组arr,其中有N个互不相等的自然数1〜N,请实现arr的排序，但是不要把下标0〜N-1位置上的数通过直接赋值","lvl0":"下标与数值相关联的排序","lvl1":["解题报告"],"lvl2":"摘要","objectID":"bc867b81fffd084dbcc2a111e99ad09e","tags":["Sort"],"url":"/post/%E4%B8%8B%E6%A0%87%E4%B8%8E%E6%95%B0%E5%80%BC%E7%9B%B8%E5%85%B3%E8%81%94%E7%9A%84%E6%8E%92%E5%BA%8F/"},{"content":"题目: 解析: 下面介绍一种时间复杂度为O(NlogN)、额外空间复杂度为O(N)的方法，这是一种在归并排序的过程中，利用组间在进行合并时产生小","lvl0":"计算数组的小和","lvl1":["解题报告"],"lvl2":"摘要","objectID":"a1702d291259ea4f53c5aafbc149f491","tags":["Merge Sort"],"url":"/post/%E8%AE%A1%E7%AE%97%E6%95%B0%E7%BB%84%E7%9A%84%E5%B0%8F%E5%92%8C/"},{"content":"当你写一个 catch 子句时，必须确定让异常通过何种方式传递到 catch 子句里。你可以 有三个选择:与你给函数传递参数一样，通过指针(by pointer)，通过","lvl0":"用引用方式捕捉异常","lvl1":null,"lvl2":"摘要","objectID":"eb26931c4c8ee98221864a1649fba3a3","tags":null,"url":"/post/%E7%94%A8%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8D%95%E6%8D%89%E5%BC%82%E5%B8%B8/"},{"content":"从语法上看，在函数里声明参数与在 catch 子句中声明参数几乎没有什么差别: 1 2 3 4 5 6 7 8 9 10 11 class Widget { ... }; void f1(Widget w); void f2(Widget\u0026amp; w); void f3(const Widget\u0026amp; w); void f4(Widget *pw); void f5(const Widget *pw); catch (Widget w) ...","lvl0":"“抛出exception”与“传递参数”或“调用虚函数”之间的区别","lvl1":["C++"],"lvl2":"摘要","objectID":"d3fd1bfde1e578753b9f42c2467e9694","tags":null,"url":"/post/%E6%8A%9B%E5%87%BAexception%E4%B8%8E%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E6%88%96%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"content":"类继承的最重要的特性是你可以通过基类指针或引用来操作派生类。这样的指针或引用具有行为的多态性，就好像它们同时具有多种形态。C++允许你通过基","lvl0":"不要以多态方式处理数组","lvl1":["C++"],"lvl2":"摘要","objectID":"3dcfef3bce142bbec7114abf1dc13fe1","tags":null,"url":"/post/%E4%B8%8D%E8%A6%81%E4%BB%A5%E5%A4%9A%E6%80%81%E6%96%B9%E5%BC%8F%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84/"},{"content":"使用析构函数防止资源泄漏 定义一个类 class ALA { public: virtual void processAdoption() ; ... }; 函数循环遍历 dataSource 内的信息，处理它所遇到的每个项目。唯一要记住的一 点是在每次循环结尾处删除","lvl0":"利用构造函数和析构函数防止泄漏资源","lvl1":["C++"],"lvl2":"摘要","objectID":"292a5ba87c303bc6b18a9deabca9a58d","tags":null,"url":"/post/%E5%88%A9%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E9%81%BF%E5%85%8D%E6%B3%84%E6%BC%8F%E8%B5%84%E6%BA%90/"},{"content":"兼容性 许多年来，你一直担心编制程序时一部分使用 C++一部分使用 C，就如同在全部用 C 编 程的年代同时使用多个编译器来生成程序一样。没办法多编译器","lvl0":"如何在同一程序中混合使用C++和C","lvl1":["C++"],"lvl2":"摘要","objectID":"a6deb8a35a57ecb9885a9d56c6d5c54a","tags":null,"url":"/post/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%90%8C%E4%B8%80%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8c-%E5%92%8Cc/"},{"content":"修饰全局变量与函数 static修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是extern外部声明也不可以。","lvl0":"解析“static”","lvl1":["C++"],"lvl2":"摘要","objectID":"23a83dddd7f9b885abe6fc3feabcb0ec","tags":null,"url":"/post/%E8%A7%A3%E6%9E%90static/"},{"content":"重载 重载是指函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。在同一可访问区域内被声","lvl0":"重载和覆盖的区别","lvl1":["C++"],"lvl2":"摘要","objectID":"de0771bc26a7436bb55fff48d4398d3d","tags":null,"url":"/post/%E9%87%8D%E8%BD%BD%E5%92%8C%E8%A6%86%E7%9B%96%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"content":"一.特殊元素和特殊位置优先策略 二.相邻元素捆绑策略 三.不相邻问题插空策略 四.定序问题倍缩空位插入策略 五.重排问题求幂策略 六.环排问题线排策略","lvl0":"排列组合的解法总结","lvl1":["杂谈"],"lvl2":"摘要","objectID":"7e40bffa0f56acfe22fdfbca2fc0ba14","tags":null,"url":"/post/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E7%9A%84%E8%A7%A3%E6%B3%95%E6%80%BB%E7%BB%93/"},{"content":"返回一个 reference to *this。 关于赋值，有趣的是你可以把它们写成连锁形式： int x, y, z; x = y - z = 15; //赋值连锁形式 同样有趣的是，赋值采用右结合律，所","lvl0":"operator=的正确写法","lvl1":["C++"],"lvl2":"摘要","objectID":"9434c4c9100bdfb32d8664e2439ab664","tags":null,"url":"/post/operator-%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95/"},{"content":"假设你有个class继承体系，用来塑模股市交易如买进、卖出的订单等等。这样的交易一定要经过审计，所以每当创建一个交易对象，在审计日志（aud","lvl0":"绝不在构造和析构过程中调用virtual函数","lvl1":["C++"],"lvl2":"摘要","objectID":"57798f471e41bf40e9e28ca41c50e88d","tags":null,"url":"/post/%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0/"},{"content":"析构函数 在有两种情况下会调用析构函数。第一种是当对象在正常状态下被销毁,也就是当它离开了它的生存空间或是被明确的删除。第二种是当对象被异常处","lvl0":"析构函数详解","lvl1":["C++"],"lvl2":"摘要","objectID":"22f3431fbf1857e7a36d48786293be79","tags":null,"url":"/post/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"},{"content":"如果某编译单元内的某个non-local static对象的初始化动作使用了另一编译单元内的某个non-local static对象，它所用到的","lvl0":"跨编译单元的初始化次序问题浅析","lvl1":["C++"],"lvl2":"摘要","objectID":"9f66661711da495673ea4405862a22d9","tags":null,"url":"/post/%E8%B7%A8%E7%BC%96%E8%AF%91%E5%8D%95%E5%85%83%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%AC%A1%E5%BA%8F%E9%97%AE%E9%A2%98%E6%B5%85%E6%9E%90/"},{"content":"原因 单纯常量 const与define enum与define 函数宏 表达式形式的宏定义一例： #define ExpressionName(Var1,Var2) ((Var1)+(Var2))*((Var1)-(Var2)) 为什么要取代这种形式呢，且听我道来： 首先谈一下","lvl0":"尽量以 const, enum, inline 替换 #define","lvl1":["C++"],"lvl2":"摘要","objectID":"5af3374b382f587f500e2938e750516d","tags":null,"url":"/post/%E5%B0%BD%E9%87%8F%E4%BB%A5-const-enum-inline-%E6%9B%BF%E6%8D%A2-define/"},{"content":"对于内置变量的自动初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;stdio.h\u0026gt;#define CONST 100 int *p1; int a[2]; int b; static int c; main() { int d; static int e; int f[2]; int *p2; printf(\u0026#34;CONST=%d\\n\u0026#34;,CONST); printf(\u0026#34;a[0]=%d\\n\u0026#34;,a[0]); //printf(\u0026#34;*p1=%d\\n\u0026#34;,*p1); printf(\u0026#34;b=%d\\n\u0026#34;,b); printf(\u0026#34;c=%d\\n\u0026#34;,c); printf(\u0026#34;d=%d\\n\u0026#34;,d); printf(\u0026#34;e=%d\\n\u0026#34;,e); printf(\u0026#34;f[0]=%d\\n\u0026#34;,f[0]); printf(\u0026#34;*p2=%d\\n\u0026#34;,*p2); } 输出：","lvl0":"C++变量的自动初始化","lvl1":["C++"],"lvl2":"摘要","objectID":"ff32c9166c2f1be247a16e9c73b53be8","tags":null,"url":"/post/c-%E5%8F%98%E9%87%8F%E7%9A%84%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"content":"成员初始化列表 何谓初始化列表 与其他函数不同，构造函数除了有名字，参数列表和函数体之外，还可以有初始化列表，初始化列表以冒号开头，后跟一系列以","lvl0":"构造函数与成员初始化列表详解","lvl1":["C++"],"lvl2":"摘要","objectID":"447637738678415eed171b1adf64834a","tags":null,"url":"/post/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"content":"未排序正数数组中累加和为给定值的最长子数组长度 题目: 给定一个数组arr,该数组无序，但每个值均为正数，再给定一个正数k,求arr的所有子数组","lvl0":"未排序数组中累加和为定值的最长子数组","lvl1":["解题报告"],"lvl2":"摘要","objectID":"abed01beccb03e245665e3b3fa0e9c54","tags":["Array","滑动窗口"],"url":"/post/%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84/"},{"content":"题目: 先给出可整合数组的定义。如果一个数组在排序之后，每相邻两个数差的绝对值都为1，则该数组为可整合数组。例如，[5,3,4,6,2]排序之","lvl0":"最长的可整合子数组的长度","lvl1":["解题报告"],"lvl2":"摘要","objectID":"06c46aa243a9f2d1c97a4e07ea07aceb","tags":["Array"],"url":"/post/%E6%9C%80%E9%95%BF%E7%9A%84%E5%8F%AF%E6%95%B4%E5%90%88%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6/"},{"content":"题目: 给定一个无序数组air,求出需要排序的最短子数组长度。 例如：arr = [1，5, 3，4，2, 6，7]返回4，因为只有[5，3, 4，2]需","lvl0":"需要排序的最短子数组长度","lvl1":["解题报告"],"lvl2":"摘要","objectID":"a60458063dd2f7a1eadf426725695e7a","tags":["Array"],"url":"/post/%E9%9C%80%E8%A6%81%E6%8E%92%E5%BA%8F%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6/"},{"content":"LeetCode 215. Kth Largest Element in an Array Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. For example, Given [3,2,1,5,6,4] and k = 2, return 5. Note: You may assume k is always valid, 1 ≤ k ≤ array’s length. 解析：求第K","lvl0":"找到无序数组中的第k个数","lvl1":["解题报告"],"lvl2":"摘要","objectID":"8ce3e30d291d67205b677e4811df77b7","tags":["Heap","BFPRT"],"url":"/post/%E6%89%BE%E5%88%B0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%95%B0/"},{"content":"题目: 解析: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public static void printMatrixZigZag(int[][] matrix) { int tR = 0; int tC = 0; int dR = 0; int dC = 0; int endR = matrix.length - 1; int endC = matrix[0].length","lvl0":"“之”字形打印矩阵","lvl1":["解题报告"],"lvl2":"摘要","objectID":"b57bf1386beffcb83411439be7f9403e","tags":["Array"],"url":"/post/%E4%B9%8B%E5%AD%97%E5%BD%A2%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"},{"content":"LeetCode 461. Hamming Distance The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. 解析：利用异或来求出不同的位，然后取出每一个1. 1 2 3 4 5 6 7 8 9 10 11 class Solution {","lvl0":"汉明距离","lvl1":["解题报告 "],"lvl2":"摘要","objectID":"3065dd7ae18dd5a2c5af14fec86d1e22","tags":["Bit Manipulation"],"url":"/post/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"},{"content":"题目: 给定两个32位整数a和b,可正、可负、可0。不能使用算术运算符，分别实现a和b的加减乘除运算。如果给定的a和b执行加减乘除的某些结果本","lvl0":"只用位运算不用算术运算实现整数的加减乘除运算","lvl1":["解题报告"],"lvl2":"摘要","objectID":"92e4331fb9bb85f2f1dbd963da77009a","tags":["it Manipulation"],"url":"/post/%E5%8F%AA%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B8%8D%E7%94%A8%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E6%95%B4%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97/"},{"content":"题目: 给定两个32位整数a和b，返回a和b中较大的。不用任何比较判断。包括等于号. 解析: 第一种方法。得到a-b的值的符号，就可以知道是返回a","lvl0":"不用任何比较判断找出两个数中较大的数","lvl1":["解题报告"],"lvl2":"摘要","objectID":"df76668cd9eef6952a6c63bbdf414b9f","tags":["it Manipulation"],"url":"/post/%E4%B8%8D%E7%94%A8%E4%BB%BB%E4%BD%95%E6%AF%94%E8%BE%83%E5%88%A4%E6%96%AD%E6%89%BE%E5%87%BA%E4%B8%A4%E4%B8%AA%E6%95%B0%E4%B8%AD%E8%BE%83%E5%A4%A7%E7%9A%84%E6%95%B0/"},{"content":"题目: 如何不用任何额外变量交换两个整数的值？ 解析: 如果给定整数a和b,用以下三行代码即可交换a和b的值。 a = a ^ b; b = a ^ b; a = a ^ b; 如何理","lvl0":"不用额外变量交换两个整数的值","lvl1":["解题报告"],"lvl2":"摘要","objectID":"80bce73d2a4ab4754dfb99efc6ef5620","tags":["it Manipulation"],"url":"/post/%E4%B8%8D%E7%94%A8%E9%A2%9D%E5%A4%96%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E5%80%BC/"},{"content":"题目: 新类型字符的定义如下： 新类型字符是长度为1或者2的字符串。 表现形式可以仅是小写字母,例如”e\u0026quot;;也可以是大写字母+小写字母,","lvl0":"找到被指的新类型字符","lvl1":["解题报告"],"lvl2":"摘要","objectID":"2a0b2334999687aa34484470beb7bee0","tags":["Two Pointers"],"url":"/post/%E6%89%BE%E5%88%B0%E8%A2%AB%E6%8C%87%E7%9A%84%E6%96%B0%E7%B1%BB%E5%9E%8B%E5%AD%97%E7%AC%A6/"},{"content":"LeetCode 179. Largest Number Given a list of non negative integers, arrange them such that they form the largest number. For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330. Note: The result may be very large, so you need to return a string instead of an integer. 解析： 把所有数全部转换成字符串，方便","lvl0":"拼接字符串产生字典顺序最小的字符串","lvl1":["解题报告"],"lvl2":"摘要","objectID":"4e6f66fbf37a8e3731dbd5c29e831834","tags":["reedy"],"url":"/post/%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A7%E7%94%9F%E5%AD%97%E5%85%B8%E9%A1%BA%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"content":"LeetCode 459. Repeated Substring Pattern 给定一个非空字符串检查，如果它可以通过取其子字符串并将子字符串的多个副本附加在一起构造。 您可以假定给定字符串仅由小写英文字母组成，","lvl0":"字符串匹配","lvl1":["解题报告"],"lvl2":"摘要","objectID":"f9120ba5ae77e2d456613c40e29be4df","tags":["KMP"],"url":"/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"},{"content":"添加最少字符使字符串整体都是回文字符串 题目: 给定一个字符串str,如果可以在str的任意位置添加字符，请返回在添加字符最少的 情况下，让str","lvl0":"构造回文字符串","lvl1":["解题报告"],"lvl2":"摘要","objectID":"43606ea29961323288a3c8b05cf63958","tags":["KMP","Backtracking","区间DP"],"url":"/post/%E6%9E%84%E9%80%A0%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"content":"题目: 给定一个字符串数组strs，再给定两个字符串str1和str2,返回在strs中str1与str2的 最小距离，如果str1或str2为","lvl0":"数组中两个字符串的最小距离","lvl1":["解题报告"],"lvl2":"摘要","objectID":"8601db45da1ba026f42f26810abd1b84","tags":["String"],"url":"/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/"},{"content":"字符串的替换 题目: 给定一个字符类型的数组chas[], chas右半区全是空字符，左半区不含有空字符。现 在想将左半区中所有的空格字符替换成\u0026q","lvl0":"字符串的调整与替换","lvl1":["解题报告"],"lvl2":"摘要","objectID":"122b7d0c5d1e9e8b7c088fe094feb1e4","tags":["String"],"url":"/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%B0%83%E6%95%B4%E4%B8%8E%E6%9B%BF%E6%8D%A2/"},{"content":"题目: 给定一个字符串数组strs[],在sirs中有些位置为null,但在不为null的位置上，其字符串是按照字典顺序由小到大依次出现的。再","lvl0":"在有序但含有空的数组中查找字符串","lvl1":["解题报告"],"lvl2":"摘要","objectID":"36fd55b2b1eacdf26b3dd879a2e000aa","tags":["String","Binary Sort"],"url":"/post/%E5%9C%A8%E6%9C%89%E5%BA%8F%E4%BD%86%E5%90%AB%E6%9C%89%E7%A9%BA%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"content":"题目: 给定三个字符串str、from和to,把str中所有from的子串全部替换成to字符串，对 连续出现from的部分要求只替换成一个to字","lvl0":"替换字符串中连续出现的指定字符串","lvl1":["解题报告"],"lvl2":"摘要","objectID":"aee999f23ef5a79b47858b7322e4e229","tags":["String"],"url":"/post/%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E8%BF%9E%E7%BB%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"content":"题目: 给定一个字符串str和一个整数如果str中正好有连续的yt个•0\u0026rsquo;字符出现时，把k个 连续的'0’字符去除，返回处理后的字符","lvl0":"去掉字符串中连续出现k个0的子串","lvl1":["解题报告"],"lvl2":"摘要","objectID":"c3a36a5447bd0fcde859887dd4ce7415","tags":["String"],"url":"/post/%E5%8E%BB%E6%8E%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E8%BF%9E%E7%BB%AD%E5%87%BA%E7%8E%B0k%E4%B8%AA0%E7%9A%84%E5%AD%90%E4%B8%B2/"},{"content":"题目: 给定一个字符串stn求其中全部数字串所代表的数字之和。 忽略小数点字符，例如\u0026quot;A1.3\u0026quot;,其中包含两个数字1和3。 如","lvl0":"字符串中数字子串的求和","lvl1":["解题报告"],"lvl2":"摘要","objectID":"3523ab1f014b257344b041cf367dc374","tags":["String"],"url":"/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%95%B0%E5%AD%97%E5%AD%90%E4%B8%B2%E7%9A%84%E6%B1%82%E5%92%8C/"},{"content":"LintCode Coins in a Line II 有 n 个不同价值的硬币排成一条线。两个参赛者轮流从左边依次拿走 1 或 2 个硬币，直到没有硬币为止。计算两个人分别拿到的硬币总价值，价值","lvl0":"排成一条线的博弈问题","lvl1":["解题报告"],"lvl2":"摘要","objectID":"c14a568e48c2b1946917450070dbdb1b","tags":["Math","博弈DP"],"url":"/post/%E6%8E%92%E6%88%90%E4%B8%80%E6%9D%A1%E7%BA%BF%E7%9A%84%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/"},{"content":"LeetCode 150. Evaluate Reverse Polish Notation Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Some examples: [\u0026quot;2\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;+\u0026quot;, \u0026quot;3\u0026quot;, \u0026quot;*\u0026quot;] -\u0026gt; ((2 + 1) * 3) -\u0026gt; 9 [\u0026quot;4\u0026quot;, \u0026quot;13\u0026quot;, \u0026quot;5\u0026quot;, \u0026quot;/\u0026quot;, \u0026quot;+\u0026quot;] -\u0026gt; (4 + (13 / 5)) -\u0026gt; 6 解析：用栈来模拟运","lvl0":"公式字符串求值","lvl1":["解题报告"],"lvl2":"摘要","objectID":"14ed9282af3a119a736b6058ac8e72f9","tags":["Stack","String"],"url":"/post/%E5%85%AC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B1%82%E5%80%BC/"},{"content":"数字字符串转换为字母组合的种数 给定一个字符串str, str全部由数字字符组成，如果str中某一个或某相邻两个字符组 成的子串值在1〜26之间，","lvl0":"字符串切分","lvl1":["解题报告"],"lvl2":"摘要","objectID":"bf5b16345e6ab2076e7ab595e13f5f17","tags":["DP"],"url":"/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E5%88%86/"},{"content":"LeetCode 97. Interleaving String Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. For example, Given: s1 = “aabcc”, s2 = “dbbca”, When s3 = “aadbbcbcac”, return true. When s3 = “aadbb","lvl0":"字符串交错组成","lvl1":["解题报告"],"lvl2":"摘要","objectID":"7ee1f0b6ab55f0738d7946ef71472c76","tags":["DP"],"url":"/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A4%E9%94%99%E7%BB%84%E6%88%90/"},{"content":"最长公共子序列 题目: 给定两个字符串str1和str2,返回两个字符串的最长公共子序列。 解析: 如果str1的长度为M，str2的长度为N,生成","lvl0":"最长公共子序列/子串","lvl1":["解题报告"],"lvl2":"摘要","objectID":"bd9ca8630311d7ef4e141658b68b0ee5","tags":["DP"],"url":"/post/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E5%AD%90%E4%B8%B2/"},{"content":"题目 给定数组arr，arr中所有的值都为正数且不重复。每个值代表一种面值的货币，每种 面值的货币可以使用任意张，再给定一个整数aim代表要找的","lvl0":"一道题了解动态规划","lvl1":["算法"],"lvl2":"摘要","objectID":"c9b1b72f0c2ee3e5f02153e4d1f9bbc0","tags":null,"url":"/post/%E4%B8%80%E9%81%93%E9%A2%98%E4%BA%86%E8%A7%A3%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"content":"题目: 现在有一种新的二叉树节点类型如下： public class Node { public int value; public Node left; public Node right; public Node parent; public Node(int data) { this.value = data; } 该结构比普通二叉树节点结构多了一个指向父节点的par","lvl0":"在二叉树中找到一个节点的后继节点","lvl1":["解题报告"],"lvl2":"摘要","objectID":"09c69093205aeffab731519132b5793e","tags":["Tree"],"url":"/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9/"},{"content":"LeetCode 110. Balanced Binary Tree Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 解析：dfs求每个节点的高度，在求高度的同时判断当前","lvl0":"判断二叉树的类型","lvl1":["解题报告"],"lvl2":"摘要","objectID":"d8c4d7767d70f660a85848b5401de9b4","tags":["BST"],"url":"/post/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%B1%BB%E5%9E%8B/"},{"content":"LeetCode 99. Recover Binary Search Tree Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Note: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? 解析： 中序遍历二叉树，出现的节点的值会升序排序，如果有两","lvl0":"调整搜索二叉树中两个错误的节点","lvl1":["解题报告"],"lvl2":"摘要","objectID":"f1e6b13e5c1936764264782972dbcf9d","tags":["Tree","BST"],"url":"/post/%E8%B0%83%E6%95%B4%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E8%8A%82%E7%82%B9/"},{"content":"查找二叉树中的最大搜索二叉子树 给定一棵二叉树的头节点head,己知其中所有节点的值都不一样，找到含有节点最多 的搜索二叉子树，并返回这棵子树的","lvl0":"查找二叉树中的搜索二叉树","lvl1":["解题报告"],"lvl2":"摘要","objectID":"88bd8d6a4519fe1d667014af19eb340d","tags":["Tree","DFS","BST"],"url":"/post/%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E5%AD%90%E6%A0%91/"},{"content":"题目: 二叉树可以用常规的三种遍历结果来描述其结构，但是不够直观，尤其是二叉树中有 重复值的时候，仅通过三种遍历的结果来构造二叉树的真实结构更是","lvl0":"如何较为直观地打印二叉树","lvl1":["解题报告"],"lvl2":"摘要","objectID":"9d6b468b6a9cf9f3d97db8676248947c","tags":["Tree"],"url":"/post/%E5%A6%82%E4%BD%95%E8%BE%83%E4%B8%BA%E7%9B%B4%E8%A7%82%E5%9C%B0%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"content":"题目 给定一棵二叉树的头节点head,按照如下两种标准分别实现二叉树边界节点的逆时针打印。 标准一： 头节点为边界节点。 叶节点为边界节点。 如果节点","lvl0":"打印二叉树的边界节点","lvl1":["解题报告"],"lvl2":"摘要","objectID":"96c5b322e0cd8f76c38e69a0d900e2c1","tags":["Tree"],"url":"/post/%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BE%B9%E7%95%8C%E8%8A%82%E7%82%B9/"},{"content":"题目: 一个环形单链表从头节点head幵始不降序，同时由最后的节点指回头节点。给定这样一个环形单链表的头节点head和一个整数num，请生成节","lvl0":"向有序的环形单链表插入新节点","lvl1":["解题报告 "],"lvl2":"摘要","objectID":"f71eff7499e3d156513536392ff9d60f","tags":["Linked List"],"url":"/post/%E5%90%91%E6%9C%89%E5%BA%8F%E7%9A%84%E7%8E%AF%E5%BD%A2%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%96%B0%E8%8A%82%E7%82%B9/"},{"content":"删除无序单链表中值重复出现的点 给定一个无序单链表的头节点head,删除其中值重复出现的节点。 例如：1-\u0026gt;2-\u0026gt;3-\u0026gt;3-\u0026","lvl0":"删除无序单链表中值重复出现的点","lvl1":["解题报告"],"lvl2":"摘要","objectID":"e792b9869e5234d4ab4f3acb202c1e04","tags":["Linked List"],"url":"/post/%E5%88%A0%E9%99%A4%E6%97%A0%E5%BA%8F%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%BC%E9%87%8D%E5%A4%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E7%82%B9/"},{"content":"题目 对于一个没有重复元素的整数数组，请用其中元素构造一棵MaxTree，MaxTree定义为一棵二叉树，其中的节点与数组元素一一对应，同时对","lvl0":"构造数组的MaxTree","lvl1":["解题报告"],"lvl2":"摘要","objectID":"27c55b36034da03b8d1c3a6f3051902b","tags":["单调栈"],"url":"/post/%E6%9E%84%E9%80%A0%E6%95%B0%E7%BB%84%E7%9A%84maxtree/"},{"content":"一个栈中元素的类型为整型，现在想将该栈从顶到底按从大到小的顺序排序，只许申 请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。如","lvl0":"用一个栈实现另一个栈的排序","lvl1":["解题报告"],"lvl2":"摘要","objectID":"7d0aee2976fde1db2d71a008b3be4b72","tags":["单调栈"],"url":"/post/%E7%94%A8%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%88%E7%9A%84%E6%8E%92%E5%BA%8F/"},{"content":"题目: 宠物、狗和猫的类如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Pet { private String type ; public Pet(String type) { this.type = type ; } public String getPetType() { return this.type ; } } public class Dog extends Pet{ public","lvl0":"猫狗队列","lvl1":["解题报告"],"lvl2":"摘要","objectID":"257c3a4e3c65721221b18344d2349b95","tags":["Design","Queue"],"url":"/post/%E7%8C%AB%E7%8B%97%E9%98%9F%E5%88%97/"},{"content":"题目: 一个栈依次压入1、2、3、4、5,那么从栈顶到栈底分别为5、4、3、2、1。将这个栈 转置后，从栈顶到桟底为1、2、3、4、5,也就是实","lvl0":"如何仅用递归函数和栈操作逆序一个栈","lvl1":["解题报告"],"lvl2":"摘要","objectID":"59f47073290c11a990eed1f93dc43612","tags":["Stack","递归"],"url":"/post/%E5%A6%82%E4%BD%95%E4%BB%85%E7%94%A8%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88%E6%93%8D%E4%BD%9C%E9%80%86%E5%BA%8F%E4%B8%80%E4%B8%AA%E6%A0%88/"},{"content":"","lvl0":"汉诺塔问题分析","lvl1":["解题报告"],"lvl2":"摘要","objectID":"bf9bffaa17b0b637d2e7abe02214b987","tags":["Stack","Design"],"url":"/post/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"},{"content":"嵌入式SQL的处理过程 嵌入式SQL是将SQL语句嵌入程序设计语言中，被嵌入的程序设计语言，如C、C++、 Java等称为宿主语言，简称主语言。","lvl0":"嵌入式SQL入门","lvl1":["MySQL"],"lvl2":"摘要","objectID":"3db167fcf5f770d59fdcfc9f27dcb0a2","tags":null,"url":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8Fsql%E5%85%A5%E9%97%A8/"},{"content":"实体之间的联系 (1) 两个实体型之间的联系 ### 一对一联系（1:1) 如果对于实体集乂中的每一个实体，实体集S中至多有一个（也可以没有）实体与之 联系，反","lvl0":"E-R模型与关系模型","lvl1":null,"lvl2":"摘要","objectID":"09b9f6a1219cb54562fa4493efb22874","tags":null,"url":"/post/e-r%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/"},{"content":"存取方法 存取方法是快速存取数据库中数据的技术。数据库管理系统一般提供多种存取方法。常用的存取方法为索引方法和聚簇（clustering)方法","lvl0":"索引和聚簇浅析","lvl1":["MySQL"],"lvl2":"摘要","objectID":"74648b9a94134ca3c3e86c4383c91838","tags":null,"url":"/post/%E7%B4%A2%E5%BC%95%E5%92%8C%E8%81%9A%E7%B0%87%E6%B5%85%E6%9E%90/"},{"content":"函数依赖 函数依赖和别的数据依赖一样是语义范畴的概念，只能根据语义来确定一个函数依赖。例如，姓名一年龄这个函数依赖只有在该部门没有同名人的条件","lvl0":"数据库的规范化","lvl1":["MySQL"],"lvl2":"摘要","objectID":"209554487b302f6d9ce324177f884a12","tags":null,"url":"/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96/"},{"content":"介绍 数据库的完整性（integrity )是指数据的正确性（correctness)和相容性（compat- ability )。数据的正确性是指数据是符合现","lvl0":"数据库完整性浅析","lvl1":["MySQL"],"lvl2":"摘要","objectID":"75ff62a484d9bc74aaa7f64af297213d","tags":null,"url":"/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E6%B5%85%E6%9E%90/"},{"content":"简介 视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库中只存放视图的定义，而不存放视图对应的数据，这些数据仍存放","lvl0":"视图详解","lvl1":["MySQL"],"lvl2":"摘要","objectID":"b6774fb2de2571800bb9e2dc884b3164","tags":null,"url":"/post/%E8%A7%86%E5%9B%BE%E8%AF%A6%E8%A7%A3/"},{"content":"介绍 数据查询是数据库的核心操作。SQL提供了 SELECT语句进行数据查询，该语句具有 灵活的使用方式和丰富的功能。其一般格式为 SELECT [ALL丨DI","lvl0":"SQL语句:DML语句-数据查询","lvl1":["MySQL"],"lvl2":"摘要","objectID":"a6ff308b74641b46bd0cf8187c1cfed2","tags":null,"url":"/post/sql%E8%AF%AD%E5%8F%A5-dml%E8%AF%AD%E5%8F%A5-%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/"},{"content":"1.插入记录 插入元组 表创建好后，就可以往里插入记录了，插入记录的基本语法如下: INSERT INTO tablename (field1,field2,......fieldn) VALUES(value1,value2,......valuesn); 例如，向表 emp 中插入以下记录:ename 为 zzx1，h","lvl0":"SQL语句:DML语句-数据更新","lvl1":["MySQL"],"lvl2":"摘要","objectID":"1c6515437ac2090229d7b5cfefc4e03b","tags":null,"url":"/post/sql%E8%AF%AD%E5%8F%A5-dml%E8%AF%AD%E5%8F%A5-%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0/"},{"content":"SQL中使用GRANT和REVOKE语句向用户授予或收回对数据的操作权限。GRANT语句向用户授予权限，REVOKE语句收回已经授予用户的权","lvl0":"SQL语句:DCL语句","lvl1":null,"lvl2":"摘要","objectID":"30e7c077ff0df8320c7c56a5f57a393d","tags":null,"url":"/post/sql%E8%AF%AD%E5%8F%A5-dcl%E8%AF%AD%E5%8F%A5/"},{"content":"DDL 是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的 操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不","lvl0":"SQL语句:DDL语句","lvl1":["MySQL"],"lvl2":"摘要","objectID":"082c6905a3a08fe5107d27ae8089b6ca","tags":null,"url":"/post/sql%E8%AF%AD%E5%8F%A5-ddl%E8%AF%AD%E5%8F%A5/"},{"content":"定义 正则表达式是你所定义的模式模板(pattern template)，Linux工具可以用它来过滤文本。Linux 工具(比如sed编辑器或g","lvl0":"正则表达式详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"ca37852f0cd5d4cdf39a3b36fa0252e8","tags":null,"url":"/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/"},{"content":"要实现这个效果(先显示最后一行，最 后显示第一行)，你得利用保持空间做一些特别的铺垫工作。 你得像这样使用模式空间: (1) 在模式空间中放置一行; (2) 将","lvl0":"一行sed实现文本翻转","lvl1":["Shell"],"lvl2":"摘要","objectID":"e916277103bdf65dd99f0bed81c9ec03","tags":null,"url":"/post/%E4%B8%80%E8%A1%8Csed%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BF%BB%E8%BD%AC/"},{"content":"介绍 虽然sed编辑器是非常方便自动修改文本文件的工具，但其也有自身的限制。通常你需要一 个用来处理文件中的数据的更高级工具，它能提供一个类编程","lvl0":"gawk编辑器详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"a7f842c77772da36c7013e2b7af6d8b6","tags":null,"url":"/post/gawk%E7%BC%96%E8%BE%91%E5%99%A8%E8%AF%A6%E8%A7%A3/"},{"content":"多行命令 sed编辑器包含了三个可用来处理多行文本的特殊命令。 N:将数据流中的下一行加进来创建一个多行组(multiline group)来处理","lvl0":"sed编辑器进阶","lvl1":["Shell"],"lvl2":"摘要","objectID":"c7d2a54505a2c4a87dcc081b549fd22c","tags":null,"url":"/post/sed%E7%BC%96%E8%BE%91%E5%99%A8%E8%BF%9B%E9%98%B6/"},{"content":"介绍 sed编辑器被称作流编辑器(stream editor)，和普通的交互式文本编辑器恰好相反。在交互式 文本编辑器中(比如vim)，你可以用键","lvl0":"sed编辑器入门","lvl1":["Shell"],"lvl2":"摘要","objectID":"9294935d69e207931a2848b8643734a5","tags":null,"url":"/post/sed%E7%BC%96%E8%BE%91%E5%99%A8%E5%85%A5%E9%97%A8/"},{"content":"基本的脚本函数 函数是一个脚本代码块，你可以为其命名并在代码中任何位置重 用。要在脚本中使用该代码块时，只要使用所起的函数名就行了(这个过程称为","lvl0":"shell脚本中的函数使用","lvl1":["Shell"],"lvl2":"摘要","objectID":"eb6f3cf6aa420a0c60205f5e95ddece1","tags":null,"url":"/post/shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/"},{"content":"Linux系统提供了多个在预选时间运行脚本的方法:at命令和cron表。每个方法都使用不同的技 术来安排脚本的运行时间和频率。 at命令来计划执","lvl0":"定时运行作业","lvl1":["Shell"],"lvl2":"摘要","objectID":"7e205eb4afdac3b1c72d411d9d03826b","tags":null,"url":"/post/%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%E4%BD%9C%E4%B8%9A/"},{"content":"定义 date命令是显示或设置系统时间与日期。 很多shell脚本里面需要打印不同格式的时间或日期，以及要根据时间和日期执行操作。延时通常用于脚","lvl0":"date命令详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"6154012dbf6e12a6f255955c4b6a22b2","tags":null,"url":"/post/date%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"content":"作业控制 在作业停止后， Linux系统会让你选择是终止还是重启。你可以用kill命令终止该进程。要重启停止的进程需要 向其发送一个SIGCONT","lvl0":"作业控制、调整nice值","lvl1":["Shell"],"lvl2":"摘要","objectID":"eedc73c45cd0a811bdd2141deb83223d","tags":null,"url":"/post/%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6%E8%B0%83%E6%95%B4nice%E5%80%BC/"},{"content":"处理信号 Linux系统和应用程序可以生成超过30个信号。下表列出了在Linux编程时会遇到的最常见的Linux系统信号。 默认情况下，bash","lvl0":"shell对信号的处理","lvl1":["Shell"],"lvl2":"摘要","objectID":"a98a55ddfd8d125712c308344c8232b5","tags":null,"url":"/post/shell%E5%AF%B9%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86/"},{"content":"创建临时文件 Linux系统有特殊的目录，专供临时文件使用。Linux使用/tmp目录来存放不需要永久保留的 文件。大多数Linux发行版配置了","lvl0":"创建临时文件和目录","lvl1":["Shell"],"lvl2":"摘要","objectID":"6f25500a5704baae6234754767caaeda","tags":null,"url":"/post/%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/"},{"content":"打印全部堆栈 Stack trace是指堆栈回溯信息，在当前时间，以当前方法的执行点开始，回溯调用它的方法的方法的执行点，然后继续回溯，这样就可以跟踪整","lvl0":"Go的堆栈打印","lvl1":["Go"],"lvl2":"摘要","objectID":"dd436bc12d8ea6556136fcd4df9243e3","tags":["Go"],"url":"/post/go%E7%9A%84%E5%A0%86%E6%A0%88%E6%89%93%E5%8D%B0/"},{"content":"标准文件描述符 Linux系统将每个对象当作文件处理。这包括输入和输出进程。Linux用文件描述符(file descriptor)来标识每个文","lvl0":"输入输出重定向","lvl1":["Shell"],"lvl2":"摘要","objectID":"e243f5d1d040ec616bcbf758055538fd","tags":null,"url":"/post/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/"},{"content":"尽管命令行选项和参数是从脚本用户处获得输入的一种重要方式，但有时脚本的交互性还需 要更强一些。比如你想要在脚本运行时问个问题，并等待运行脚本的","lvl0":"利用read获取用户输入","lvl1":["Shell"],"lvl2":"摘要","objectID":"65a66596931f902b650d4860a1bdc5b2","tags":null,"url":"/post/%E5%88%A9%E7%94%A8read%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/"},{"content":"基本方法 表面上看，命令行选项也没什么特殊的。在命令行上，它们紧跟在脚本名之后，就跟命令行 参数一样。实际上，如果愿意，你可以像处理命令行参数一","lvl0":"脚本对命令行选项的处理方法","lvl1":["Shell"],"lvl2":"摘要","objectID":"c6f6e31da27e991289aee3b21b778c9f","tags":null,"url":"/post/%E8%84%9A%E6%9C%AC%E5%AF%B9%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/"},{"content":"命令行参数 向shell脚本传递数据的最基本方法是使用命令行参数。命令行参数允许在运行脚本时向命令行添加数据。 $ ./addem 10 30 读取参数 bash shell会将","lvl0":"命令行参数和特殊参数","lvl1":["Shell"],"lvl2":"摘要","objectID":"ed649ee1bbe1912e44d5292cd46d143a","tags":null,"url":"/post/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%92%8C%E7%89%B9%E6%AE%8A%E5%8F%82%E6%95%B0/"},{"content":"while命令 while命令允许定义一个要测试 的命令，然后循环执行一组命令，只要定义的测试命令返回的是退出状态码0。它会在每次迭代的 一开始测","lvl0":"循环命令while、until、break、continue详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"f44fec78fd2e8a8318e0c0a671e5ceed","tags":null,"url":"/post/%E5%BE%AA%E7%8E%AF%E5%91%BD%E4%BB%A4whileuntil%E8%AF%A6%E8%A7%A3/"},{"content":"for命令 bash shell提供了for命令，允许你创建一个遍历一系列值的循环。每次迭代都使用其中一个值来执行已定义好的一组命令。下面是bash s","lvl0":"循环命令for详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"a336f2560ffb582026f09fc9fc8155e5","tags":null,"url":"/post/%E5%BE%AA%E7%8E%AF%E5%91%BD%E4%BB%A4for%E8%AF%A6%E8%A7%A3/"},{"content":"退出状态码 定义 shell中运行的每个命令都使用退出状态码(exit status)告诉shell它已经运行完毕。退出状态 码是一个0~255的整","lvl0":"if-then的测试功能","lvl1":["Shell"],"lvl2":"摘要","objectID":"e45d5f0617ed282bf8d4d62853547acc","tags":null,"url":"/post/if-then%E7%9A%84%E6%B5%8B%E8%AF%95%E5%8A%9F%E8%83%BD/"},{"content":"expr命令 expr命令允许在命令行上处理数学表达式，但是特别笨拙。 许多expr命令操作符在shell中另有含义(比如星号)。当它们出现在在","lvl0":"通过shell进行数学运算","lvl1":["Shell"],"lvl2":"摘要","objectID":"62f96a326a457af0d36155c9d7cb1c56","tags":null,"url":"/post/%E9%80%9A%E8%BF%87shell%E8%BF%9B%E8%A1%8C%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97/"},{"content":"文件权限 ls命令可以用来查看Linux系统上的文件、目录和设备的权限。 输出结果的第一个字段就是描述文件和目录权限的编码。这个字段的第一个字符","lvl0":"文件权限解析","lvl1":["Shell"],"lvl2":"摘要","objectID":"617f7d32a1b5f1d3303396e023a6cc4e","tags":null,"url":"/post/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E8%A7%A3%E6%9E%90/"},{"content":"Linux 的安全性 Linux安全系统的核心是用户账户。每个能进入Linux系统的用户都会被分配唯一的用户账 户。用户对系统中各种对象的访问权限取决于他","lvl0":"用户账户和组管理","lvl1":["Shell"],"lvl2":"摘要","objectID":"139505ce92f5a2e2c2eda10fcd193e58","tags":null,"url":"/post/%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7%E5%92%8C%E7%BB%84%E7%AE%A1%E7%90%86/"},{"content":"启动shell 在你登入Linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。这些 文件叫作启动文件或环境文件。","lvl0":"定位系统环境变量","lvl1":["Shell"],"lvl2":"摘要","objectID":"26821b657fc08e1cc0960973a8511d66","tags":null,"url":"/post/%E5%AE%9A%E4%BD%8D%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"content":"什么是环境变量 bash shell用一个叫作环境变量(environment variable)的特性来存储有关shell会话和工作环境的信息(这也是","lvl0":"环境变量的使用","lvl1":["Shell"],"lvl2":"摘要","objectID":"cd42a1decf9d1000dc35dc81009f92b7","tags":null,"url":"/post/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"content":"外部命令 外部命令，有时候也被称为文件系统命令，是存在于bash shell之外的程序。它们并不是shell 程序的一部分。外部命令程序通常位于/","lvl0":"Shell的內建命令","lvl1":["Shell"],"lvl2":"摘要","objectID":"027576591a7baf598e9095f0b13bc8e7","tags":null,"url":"/post/shell%E7%9A%84%E5%85%A7%E5%BB%BA%E5%91%BD%E4%BB%A4/"},{"content":"创建子shell 在CLI提示符后输入/bin/bash命令或其他等效的bash命令时，会创建一个新的shell程序。 这个shell程序被称为","lvl0":"Shell的父子关系","lvl1":["Shell"],"lvl2":"摘要","objectID":"b7f0cd16985a7beb1416132003baa935","tags":null,"url":"/post/shell%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB/"},{"content":"挂载存储媒体 mount命令 Linux上用来挂载媒体的命令叫作mount。默认情况下，mount命令会输出当前系统上挂载的设备列表. mount","lvl0":"磁盘空间命令","lvl1":["Shell"],"lvl2":"摘要","objectID":"f97dc7f7634ae192084165be5effcd9c","tags":null,"url":"/post/%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E5%91%BD%E4%BB%A4/"},{"content":"遍历目录 在Linux文件系统上，可以使用切换目录命令cd将shell会话切换到另一个目录。cd命令的格 式非常简单: cd destination cd命令可接受单个参数","lvl0":"基本的Shell命令(一)","lvl1":["Shell"],"lvl2":"摘要","objectID":"704ccb24bd594d4351d65348fb628d3e","tags":null,"url":"/post/%E5%9F%BA%E6%9C%AC%E7%9A%84shell%E5%91%BD%E4%BB%A4%E4%B8%80/"},{"content":"欧拉函数 欧拉函数用希腊字母φ表示,φ(N)表示N的欧拉函数. 对φ(N)的值,我们可以通俗地理解为小于N且与N互质的数的个数(包含1). 欧拉函","lvl0":"欧拉函数浅析","lvl1":["算法"],"lvl2":"摘要","objectID":"5832e71add5c54c6a376963bff5268b3","tags":null,"url":"/post/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90/"},{"content":"辗转相除法 辗转相除是求两个数的最大公约数的。 要证这个定理成立，只需要证明 gcd(a, b) = gcd(b, a % b) 就行了 证明：令a % b = r, 所以a = k * b + r, 所以r = a -","lvl0":"GCD、扩展GCD和中国剩余定理","lvl1":["算法"],"lvl2":"摘要","objectID":"086368b112f5022a7ebfc8a39049f01c","tags":null,"url":"/post/gcd%E6%89%A9%E5%B1%95gcd%E5%92%8C%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"},{"content":"快速幂 题目:Implement pow(x, n). 解析：快速幂，此处需要判断边界值n，如果n为-2^31，那么需要另外设置一个long long变量存储其相反","lvl0":"矩阵快速幂解析","lvl1":["算法"],"lvl2":"摘要","objectID":"f28dc368c3ab42f80099f83c498959ae","tags":null,"url":"/post/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E8%A7%A3%E6%9E%90/"},{"content":"Prim 基本思想 Prim算法根据点进行求解. 对于图G而言，V是所有顶点的集合；现在，设置两个新的集合U和T，其中U用于存放G的最小生成树中的顶点，","lvl0":"最小生成树算法总结","lvl1":["算法"],"lvl2":"摘要","objectID":"1b1809d4e3f1c737cec3c5dd2ef09b7e","tags":null,"url":"/post/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"content":"进程的三种基本状态 （1）就绪状态：进程已获得除CPU外的所有必要资源，只等待CPU时的状态。一个系统会将多个处于就绪状态的进程排成一个就绪队","lvl0":"基本进程状态和PV操作浅析","lvl1":["OS"],"lvl2":"摘要","objectID":"795830015072af0d7d5ec450cb03eca6","tags":null,"url":"/post/%E5%9F%BA%E6%9C%AC%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%92%8Cpv%E6%93%8D%E4%BD%9C%E6%B5%85%E6%9E%90/"},{"content":"在multimap中，同一个键关联的元素必然相邻存放。基于这个事实，就可以将某个键对应的值一一输出。 使用find和count函数。count","lvl0":"multimap中查找方法","lvl1":["STL"],"lvl2":"摘要","objectID":"49a589d779a148dc438b944618b58dfe","tags":null,"url":"/post/multimap%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95/"},{"content":"BFS 4. 举例 题目: 用一个整型矩阵matrix表示一个网络，1代表有路，0代表无路，每一个位置只要不越界，都有上下左右4个方向，求从最左上角到最右","lvl0":"最短路径算法总结","lvl1":["算法"],"lvl2":"摘要","objectID":"31070dd8ea179b16aad9f5840ab0b7d2","tags":null,"url":"/post/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"content":"如果问题中各数据的范围明确，那么无穷大的设定不是问题，在不明确的情况下，很多程序员都取0x7fffffff作为无穷大，因为这是32-bit i","lvl0":"为什么把无穷大INF设置成0x3f3f3f3f?","lvl1":["解题报告"],"lvl2":"摘要","objectID":"500e4ba96bc1063daaf52b4ce709bb10","tags":null,"url":"/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%8A%E6%97%A0%E7%A9%B7%E5%A4%A7inf%E8%AE%BE%E7%BD%AE%E6%88%900x3f3f3f3f/"},{"content":"为了更有效地转发ip数据报和提高交付成功的机会，在网际层使用了网际控制报文协 议 ICMP (Internet Control Message Protocol) 。ICMP 允许主机或路由器报告差错情况和提供有关异常","lvl0":"ICMP协议详解","lvl1":["网络"],"lvl2":"摘要","objectID":"f540c12152690dc8371f10faac78a581","tags":null,"url":"/post/icmp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"content":"IP地址与MAC地址 在学习IP地址时，很重要的一点就是要弄懂主机的IP地址与硬件地址的区别。 从层次的角度看，物理地址是数据链路层和物理层使用","lvl0":"ARP协议详解","lvl1":["网络"],"lvl2":"摘要","objectID":"22293e60b0e2b47b39a377926b13acbc","tags":null,"url":"/post/arp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"content":"IPv4 (1) 版本:占4位，指IP协议的版本。通信双方使用的IP协议的版本必须一致。目 前广泛使用的IP协议版本号为4 (即IPv4)。 (2) 首部长度:占4位","lvl0":"IP协议头详解","lvl1":["网络"],"lvl2":"摘要","objectID":"25ffe7960b6af8134bf78b96b7b72c56","tags":null,"url":"/post/ip%E5%8D%8F%E8%AE%AE%E5%A4%B4%E8%AF%A6%E8%A7%A3/"},{"content":"概述 用户数据报协议UDP只在IP的数据报服务之上增加了很少一点的功能，这就是复用和 分用的功能以及差错检测的功能。UDP的主要特点是： UDP是","lvl0":"UDP协议详解","lvl1":["网络"],"lvl2":"摘要","objectID":"f532c79d13c5d2b92f32800afd91a1aa","tags":null,"url":"/post/udp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"content":"IP协议概述 网际协议IP是TCP/IP体系中两个最主要的协议之一[STEV94][COME06][FORO10],也 是最重要的因特网标准协议","lvl0":"IP协议详解","lvl1":["网络"],"lvl2":"摘要","objectID":"a43373cca16a57dcf650e97075f7ef0c","tags":null,"url":"/post/ip%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"content":"非修改序列操作 for_each 1 2 template \u0026lt;class InputIterator, class Function\u0026gt; Function for_each (InputIterator first, InputIterator last, Function fn); 1 2 3 4 5 6 7 8 9 template\u0026lt;class InputIterator, class Function\u0026gt; Function for_each(InputIterator first, InputIterator last, Function fn) { while (first!=last) { fn (*first); ++first; } return fn; // or, since C++11: return move(fn); } all_of 1 2 3 4 5 6 7 8 9","lvl0":"algorithm库操作总结","lvl1":["STL"],"lvl2":"摘要","objectID":"6a9e5dafbb14bc54000169ea471b6514","tags":null,"url":"/post/algorithm%E5%BA%93%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"},{"content":"转载:http://www.cnblogs.com/guihailiuli/p/4154416.html 要计算机产生一个随机数不像扔色子一样","lvl0":"rand()和srand()函数总结","lvl1":["STL"],"lvl2":"摘要","objectID":"b71c8753c786d4ae35cc6a141aa1e383","tags":null,"url":"/post/rand-%E5%92%8Csrand-%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/"},{"content":"一、静态库与动态库 通常情况下，对函数库的链接是放在编译时期（compile time）完成的。所有相关的对象文件（object file）与牵涉","lvl0":"静态链接和动态链接区别浅析","lvl1":["C++"],"lvl2":"摘要","objectID":"415c28d7b42e08d97fee1a54789d2604","tags":null,"url":"/post/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%8C%BA%E5%88%AB%E6%B5%85%E6%9E%90/"},{"content":"常用函数:","lvl0":"cctype库操作总结","lvl1":["STL"],"lvl2":"摘要","objectID":"4e88edec917d2a628c17e9b6b2f292d5","tags":null,"url":"/post/cctype%E5%BA%93%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"},{"content":"首先，不推荐使用[]来判断key是否存在，因为使用操作符[]会向map容器里插入一个元素。 map的operator[]重载大致是这样一个内容","lvl0":" 如何判断map容器的key是否存在 ","lvl1":["C++"],"lvl2":"摘要","objectID":"2b165069306a2c7a9d64c9c139decf26","tags":null,"url":"/post/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADmap%E5%AE%B9%E5%99%A8%E7%9A%84key%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/"},{"content":"功能 在所有的预处理指令中，#pragma 指令可能是最复杂的了，它的作用是设定编译器的状态或者是指示编译器完成一些特定的动作。 #pragma指","lvl0":"#pragma 预处理指令浅析","lvl1":["C++"],"lvl2":"摘要","objectID":"efae5bdb35aa9183733ade8b5f62ed21","tags":null,"url":"/post/pragma-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%E6%B5%85%E6%9E%90/"},{"content":"几乎所有程序员的第一堂课都是学习helloworld程序，下面我们先来重温一下经典的C语言helloworld。 1 2 3 4 5 6 7 /* hello.c */ #include \u0026lt;stdio.h\u0026gt; int main()","lvl0":"C语言程序可以没有main函数","lvl1":["C++"],"lvl2":"摘要","objectID":"d1b7d552b6d941845516f52d1ee7ddbc","tags":null,"url":"/post/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E5%8F%AF%E4%BB%A5%E6%B2%A1%E6%9C%89main%E5%87%BD%E6%95%B0/"},{"content":"头文件的作用 头文件的作用主要表现为以下两个方面： 通过头文件来调用库功能。出于对源代码保密的考虑，源代码不便（或不准）向用户公布，只要向用户提","lvl0":"C++ 中头文件（.h）和源文件（.cc）","lvl1":["C++"],"lvl2":"摘要","objectID":"9fec06c3b0d6e946c945ef520e760eac","tags":null,"url":"/post/c-%E4%B8%AD%E5%A4%B4%E6%96%87%E4%BB%B6-h%E5%92%8C%E6%BA%90%E6%96%87%E4%BB%B6-cc/"},{"content":"向上取整ceil() double ceil (double x); float ceil (float x); long double ceil (long double x); double ceil (T x); // additional overloads for integral types 向上取整,返回大于等于x的值. 示例: 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; /* printf */#include \u0026lt;math.h\u0026gt; /*","lvl0":"math库数值处理函数总结","lvl1":["STL"],"lvl2":"摘要","objectID":"3a935890fff6d25874511a8923a6b9ab","tags":null,"url":"/post/%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/"},{"content":"函数原型 int sscanf( string str, string fmt, mixed var1, mixed var2 ... ); int scanf( const char *format [,argument]... ); 返回值 一般使用scanf函数时都是为某个变量赋值，不考虑它的返回值。但是任何函数都是需要返回的","lvl0":"scanf()和sscanf()详解","lvl1":["C++"],"lvl2":"摘要","objectID":"93a5b5cf5f8bc54201daee7aec44a031","tags":null,"url":"/post/scanf%E5%92%8Csscanf%E8%AF%A6%E8%A7%A3/"},{"content":"map是用来存放\u0026lt;key, value\u0026gt;键值对的数据结构，可以很方便快速的根据key查到相应的value。假如存储学生和其成绩（假","lvl0":"map排序相关讨论","lvl1":["STL"],"lvl2":"摘要","objectID":"4327342fbdfcc3ca08f7c84edb284073","tags":null,"url":"/post/map%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E8%AE%A8%E8%AE%BA/"},{"content":"题目: n 个数字（0,1,…,n-1）形成一个圆圈，从数字 k 开始，每次从这个圆圈中删除第 m 个数字（第一个 为当前数字本身，第二个为当前数字的下一","lvl0":"约瑟夫环","lvl1":["解题报告"],"lvl2":"摘要","objectID":"36afe1c54e536276e45b20c42f6c6182","tags":null,"url":"/post/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"},{"content":"要实现读写锁，首先要知道读写锁的特性，除了“读者可并发，写者要排它”之外还要考虑避免写者饥饿的问题。综合考虑后可以讲读写锁的实现总结为一下四","lvl0":"使用互斥锁、条件变量实现读写锁 ","lvl1":["Linux编程"],"lvl2":"摘要","objectID":"e14879247facf71f52ea955a18d1fee3","tags":null,"url":"/post/%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E9%94%81/"},{"content":"一、哈夫曼树的定义 什么是哈夫曼树？ 让我们先举一个例子。 判定树： 在很多问题的处理过程中，需要进行大量的条件判断，这些判断结构的设计直接影响着程","lvl0":"哈弗曼树详解","lvl1":["算法"],"lvl2":"摘要","objectID":"f0e3babe21d080c1ec2c3749d8375124","tags":null,"url":"/post/%E5%93%88%E5%BC%97%E6%9B%BC%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"content":"main函数前 main函数执行之前，主要就是初始化系统相关资源： 1.设置栈指针 2.初始化static静态和global全局变量，即data段","lvl0":"main函数执行前、后执行的代码","lvl1":["C++"],"lvl2":"摘要","objectID":"ed0f370682228fddaa464e03a51186d2","tags":null,"url":"/post/main%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%89%8D%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81/"},{"content":"单线程 在单线程下，下面这个是常见的写法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template\u0026lt;typename T\u0026gt; class Singleton { public: static T\u0026amp; getInstance() { if (!value_) { value_ = new T(); } return *value_; } private: Singleton(); ~Singleton(); static T* value_;","lvl0":"Singleton的相关实现","lvl1":["OOP"],"lvl2":"摘要","objectID":"313c33773c2665a7d751d551337ac209","tags":null,"url":"/post/singleton%E7%9A%84%E7%9B%B8%E5%85%B3%E5%AE%9E%E7%8E%B0/"},{"content":"string与char数组的转换 string转char数组 使用c_str函数 string a=\u0026quot;hello world\u0026quot;; const char* ch=a.c_str(); 注意: c_str函数的返回值是const char*的","lvl0":"string与其他类型间的转换","lvl1":["STL"],"lvl2":"摘要","objectID":"2f953c7b19f79b1710b1bde182aa6f22","tags":null,"url":"/post/string%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"content":"构造函数 empty (1) explicit unordered_map ( size_type n = /* see below */, const hasher\u0026amp; hf = hasher(), const key_equal\u0026amp; eql = key_equal(), const allocator_type\u0026amp; alloc = allocator_type() ); explicit unordered_map ( const allocator_type\u0026amp; alloc ); range (2) template \u0026lt;class InputIterator\u0026gt; unordered_map ( InputIterator first, InputIterator last, size_type n = /* see below */, const hasher\u0026amp; hf = hasher(), const key_equal\u0026amp; eql = key_equal(), const allocator_type\u0026amp; alloc","lvl0":"unordered_map操作总结","lvl1":["STL"],"lvl2":"摘要","objectID":"ed406ba9dd40ccf862188126c89c8f52","tags":null,"url":"/post/unordered-map%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"},{"content":"#构造函数 empty (1) explicit unordered_set ( size_type n = /* see below */, const hasher\u0026amp; hf = hasher(), const key_equal\u0026amp; eql = key_equal(), const allocator_type\u0026amp; alloc = allocator_type() ); explicit unordered_set ( const allocator_type\u0026amp; alloc ); range (2) template \u0026lt;class InputIterator\u0026gt; unordered_set ( InputIterator first, InputIterator last, size_type n = /* see below */, const hasher\u0026amp; hf = hasher(), const key_equal\u0026amp; eql = key_equal(), const allocator_type\u0026amp;","lvl0":"unordered_set操作总结","lvl1":["STL"],"lvl2":"摘要","objectID":"12f056a3a6720674197ec60724efbfa6","tags":null,"url":"/post/unordered-set%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"},{"content":"set 构造函数 empty (1) explicit set (const key_compare\u0026amp; comp = key_compare(), const allocator_type\u0026amp; alloc = allocator_type()); explicit set (const allocator_type\u0026amp; alloc); range (2) template \u0026lt;class InputIterator\u0026gt; set (InputIterator first, InputIterator last, const key_compare\u0026amp; comp = key_compare(), const allocator_type\u0026amp; = allocator_type()); copy (3) set (const set\u0026amp; x); set (const set\u0026amp; x, const allocator_type\u0026amp; alloc); move (4) set (set\u0026amp;\u0026amp; x); set (set\u0026amp;\u0026amp; x, const allocator_type\u0026amp; alloc); initializer list (5)","lvl0":"set和multiset操作总结","lvl1":["STL"],"lvl2":"摘要","objectID":"37b4878b3df8c395bd4703081cd4af76","tags":null,"url":"/post/set%E5%92%8Cmultiset%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"},{"content":"map 构造函数 empty (1) explicit map (const key_compare\u0026amp; comp = key_compare(), const allocator_type\u0026amp; alloc = allocator_type()); explicit map (const allocator_type\u0026amp; alloc); range (2) template \u0026lt;class InputIterator\u0026gt; map (InputIterator first, InputIterator last, const key_compare\u0026amp; comp = key_compare(), const allocator_type\u0026amp; = allocator_type()); copy (3) map (const map\u0026amp; x); map (const map\u0026amp; x, const allocator_type\u0026amp; alloc); move (4) map (map\u0026amp;\u0026amp; x); map (map\u0026amp;\u0026amp; x, const allocator_type\u0026amp; alloc); initializer list (5)","lvl0":"map和multimap操作总结","lvl1":["STL"],"lvl2":"摘要","objectID":"54e0eaeeb875a1eb70a69cc82fd52cfb","tags":null,"url":"/post/map%E5%92%8Cmultimap%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"},{"content":"stack queue priority_queue priority_queue 对于基本类型的使用方法相对简单。他的模板声明带有三个参数: priority_queue\u0026lt;Type, Container, Functional\u0026gt; 其中Type 为数据类型， Container 为保存数据的容器，Functional 为元","lvl0":"stack,queue,priority_queue操作总结","lvl1":["STL"],"lvl2":"摘要","objectID":"cf4815dff2506fef2dc65eb408601cb1","tags":null,"url":"/post/stack-queue-priority-queue%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"},{"content":"构造函数 default (1) explicit forward_list (const allocator_type\u0026amp; alloc = allocator_type()); fill (2) explicit forward_list (size_type n); explicit forward_list (size_type n, const value_type\u0026amp; val, const allocator_type\u0026amp; alloc = allocator_type()); range (3) template \u0026lt;class InputIterator\u0026gt; forward_list (InputIterator first, InputIterator last, const allocator_type\u0026amp; alloc = allocator_type()); copy (4) forward_list (const forward_list\u0026amp; fwdlst); forward_list (const forward_list\u0026amp; fwdlst, const allocator_type\u0026amp; alloc); move (5) forward_list (forward_list\u0026amp;\u0026amp; fwdlst); forward_list (forward_list\u0026amp;\u0026amp; fwdlst, const allocator_type\u0026amp; alloc);","lvl0":"forward_list操作总结","lvl1":["STL"],"lvl2":"摘要","objectID":"93f3092500ee12dc51a2fa62469508fe","tags":null,"url":"/post/forward-list%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"},{"content":"deque操作和vector操作基本相同 构造函数 default (1) explicit deque (const allocator_type\u0026amp; alloc = allocator_type()); fill (2) explicit deque (size_type n); deque (size_type n, const value_type\u0026amp; val, const allocator_type\u0026amp; alloc = allocator_type()); range (3) template \u0026lt;class InputIterator\u0026gt; deque (InputIterator first, InputIterator last, const allocator_type\u0026amp; alloc = allocator_type()); copy (4) deque (const deque\u0026amp;","lvl0":"deque操作总结","lvl1":["STL"],"lvl2":"摘要","objectID":"405168fb3ce37e50e0643c662fe2ba66","tags":null,"url":"/post/deque%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"},{"content":"构造函数 default (1) explicit list (const allocator_type\u0026amp; alloc = allocator_type()); fill (2) explicit list (size_type n); list (size_type n, const value_type\u0026amp; val, const allocator_type\u0026amp; alloc = allocator_type()); range (3) template \u0026lt;class InputIterator\u0026gt; list (InputIterator first, InputIterator last, const allocator_type\u0026amp; alloc = allocator_type()); copy (4) list (const list\u0026amp; x); list (const list\u0026amp; x, const allocator_type\u0026amp; alloc); move (5) list (list\u0026amp;\u0026amp; x); list (list\u0026amp;\u0026amp; x, const allocator_type\u0026amp; alloc); initializer","lvl0":"list操作总结","lvl1":["STL"],"lvl2":"摘要","objectID":"36540e85583cc06ff8a10ce44b98789c","tags":null,"url":"/post/list%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"},{"content":"vector容器的相关操作和string非常相似. 构造函数 default (1) explicit vector (const allocator_type\u0026amp; alloc = allocator_type()); fill (2) explicit vector (size_type n); vector (size_type n, const value_type\u0026amp; val, const allocator_type\u0026amp; alloc = allocator_type()); range (3) template \u0026lt;class InputIterator\u0026gt; vector (InputIterator first, InputIterator last, const allocator_type\u0026amp; alloc = allocator_type());","lvl0":"vector操作总结","lvl1":["STL"],"lvl2":"摘要","objectID":"9a6d2835f4b711f6e80f7bd50f8c4fad","tags":null,"url":"/post/vector%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"},{"content":"基本区别 调用reverse_iterator的base()成员函数可以得到“与之相对应的”iterator，但是这句话实际上并没有说明真正的","lvl0":"reverse_iterator的用法","lvl1":["STL"],"lvl2":"摘要","objectID":"183ab44396b2bc25a725961f1cff0fe7","tags":null,"url":"/post/reverse_iterator%E7%9A%84%E7%94%A8%E6%B3%95/"},{"content":"转载： http://blog.csdn.net/bladelyer/article/details/8505912. http://blog.csdn.net/andyelvis/article/details/4529592 原理解释 相信很多人都遇到过这样的例子： 1 2 3 string str; while( cin \u0026gt;\u0026gt; str ) cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; flush; 似乎，大多数初学者都不明白【cin \u0026raquo; str】怎么可以作为whi","lvl0":"流对象为什么可以作为条件表达式？","lvl1":["C++"],"lvl2":"摘要","objectID":"fb60b48fd8c4d517655e51d4ee6c889d","tags":null,"url":"/post/cin-out%E6%B5%81%E5%AF%B9%E8%B1%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"content":"算法目标 kmp算法完成的任务是：给定两个字符串O和f，长度分别为n和m，判断f是否在O中出现，如果出现则返回出现的位置。常规方法是遍历a的每","lvl0":"KMP算法详解","lvl1":["算法"],"lvl2":"摘要","objectID":"d8537ddf07f2634abee979ee9093d6ef","tags":null,"url":"/post/kmp%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"content":"八大排序算法总结 排序算法稳定性 假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中","lvl0":"八大经典排序算法","lvl1":["算法"],"lvl2":"摘要","objectID":"55175575fa3a87875b401ad5ccded01a","tags":null,"url":"/post/%E5%85%AB%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"content":"二叉树的定义 二叉树是每个节点最多有两个子树的树结构。它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。 二","lvl0":"二叉树的类型","lvl1":["算法"],"lvl2":"摘要","objectID":"6754f0dece11a61a41df48e69c151a5f","tags":null,"url":"/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%B1%BB%E5%9E%8B/"},{"content":"计数排序与位图排序 计数排序(Counting sort)是一种稳定的线性时间排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组","lvl0":"位图排序","lvl1":["算法"],"lvl2":"摘要","objectID":"f35cddc1f0d7578c4f55ec811993d64a","tags":["量数据"],"url":"/post/%E4%BD%8D%E5%9B%BE%E6%8E%92%E5%BA%8F/"},{"content":"有序数组 以下两种方法都可以适用于数组中数据重复的情况。 长度相似 采用二路归并法来进行求解交集 对于数组A,B分别以i,j从头遍历数组。如果当前位","lvl0":"求两个数组的交集","lvl1":["解题报告"],"lvl2":"摘要","objectID":"fb76074b0c1e622797d908f7e5e1bae3","tags":["Array","Hash"],"url":"/post/%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"},{"content":"N\u0026lt;=10 • O(N!) • 全排列枚举 N\u0026lt;=15 • O(2^N) • 01规划 • 状压dp N\u0026lt;=50 • O(N^4) • 枚举一个矩形(x,y),(x+w,y+h) N\u0026lt;=100 • O(N^3) • Floyd求任意两点最短路 • 高斯消元 N\u0026lt;=1000","lvl0":"根据数据范围选择解题方法","lvl1":["算法"],"lvl2":"摘要","objectID":"706bbc01353b46515de1ad470ce59239","tags":null,"url":"/post/%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E9%80%89%E6%8B%A9%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95/"},{"content":"转载： http://www.cnblogs.com/QG-whz/p/5167238.html. http://blog.csdn.net/sp_programmer/article/details/41812787. 定义 AVL树又称为高度平衡的二叉搜索树。它能保持二叉树的高度平衡，尽量降低二叉树的高度，减少树的平均搜索长度。 性质 AVL树本质上还","lvl0":"AVL树详解","lvl1":["算法"],"lvl2":"摘要","objectID":"2c6fb4c5906a06da6c9243be5dc0aab0","tags":null,"url":"/post/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"content":"转载： http://www.cnblogs.com/skywang12345/p/3245399.html http://blog.csdn.net/v_july_v/article/details/6105630 简介 红黑树并不追求“完全平衡”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。 红黑树能够以O(lgn) 的时间复","lvl0":"红黑树详解","lvl1":["算法"],"lvl2":"摘要","objectID":"fe278c019173f64d013b2dd5e82a4d65","tags":["黑树"],"url":"/post/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"content":"转载：http://blog.csdn.net/v_july_v/article/details/7382693 前言 一般而言，标题含有“秒杀","lvl0":"海量数据处理总结","lvl1":["算法"],"lvl2":"摘要","objectID":"3951a4cca4e7b2d0b2ee955ab0317117","tags":["量数据"],"url":"/post/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/"},{"content":"前言 动态查找树主要有：二叉查找树（Binary Search Tree），平衡二叉查找树（Balanced Binary Search Tree），红黑树(Red-Black Tree )，","lvl0":"从B树、B+树、B*树谈到R树","lvl1":["算法"],"lvl2":"摘要","objectID":"898e8ef96b39680f760a973920854373","tags":["量数据"],"url":"/post/%E4%BB%8Eb%E6%A0%91b-%E6%A0%91b-%E6%A0%91%E8%B0%88%E5%88%B0r%E6%A0%91/"},{"content":"转载：http://blog.csdn.net/v_july_v/article/details/6685894 什么是Bloom Filter Bloom Filt","lvl0":"认识布隆过滤器","lvl1":["算法"],"lvl2":"摘要","objectID":"95ae57cf4812fa632d96359486036a7d","tags":["量数据"],"url":"/post/%E8%AE%A4%E8%AF%86%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"content":"介绍 HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。今天普遍使用的一个版本——HTTP 1.1。 HTTP协议（HyperTe","lvl0":"深入理解HTTP协议","lvl1":["网络"],"lvl2":"摘要","objectID":"f36a1673d891c411c69a662f3e8a4d99","tags":["TTP"],"url":"/post/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3http%E5%8D%8F%E8%AE%AE/"},{"content":"相对于SOCKET开发者,TCP创建过程和折除过程是由TCP/IP协议栈自动创建的.因此开发者并不需要控制这个过程.但是对于理解TCP底层运","lvl0":"TCP连接管理浅析","lvl1":["网络"],"lvl2":"摘要","objectID":"c852a8ac78c8ddc0e2287a305d3bb81f","tags":null,"url":"/post/tcp%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E6%B5%85%E6%9E%90/"},{"content":"RST简介 RST标示复位、用来异常的关闭连接。 发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓冲区中的包，发送RST。 而接收端","lvl0":"TCP连接中的RST","lvl1":["网络"],"lvl2":"摘要","objectID":"426ef700b97a1409bb3041809fa49851","tags":null,"url":"/post/tcp%E8%BF%9E%E6%8E%A5%E4%B8%AD%E7%9A%84rst/"},{"content":"应用层常用协议 DNS:域名系统（TCP和UDP） DNS同时占用UDP和TCP端口53 DNS：域名系统。DNS是因特网使用的命名系统，用来把便","lvl0":"网络常用协议","lvl1":["网络"],"lvl2":"摘要","objectID":"ceaeed9e901fa5645db983b33ec29a78","tags":["议"],"url":"/post/%E7%BD%91%E7%BB%9C%E5%B8%B8%E7%94%A8%E5%8D%8F%E8%AE%AE/"},{"content":"域名系统概述 域名系统DNS(Domain Name System)是因特网使用的命名系统，用来把便于人们使用的机器名字转换成为IP地址。域名系统其实就","lvl0":"DNS原理总结及其解析过程详解","lvl1":["网络"],"lvl2":"摘要","objectID":"03fc9726c5cebc5c7e97b60a438c113f","tags":["NS"],"url":"/post/dns%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93%E5%8F%8A%E5%85%B6%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"},{"content":"差错控制 TCP使用差错控制来提供可靠性。差错控制包括以下的一些机制： 检测和重传受到损伤的报文段、 重传丢失的报文段、 丢弃重传的报文段并重传该报","lvl0":"TCP差错控制浅析","lvl1":["网络"],"lvl2":"摘要","objectID":"7317064c570de657b9d2f2a242c92e9c","tags":null,"url":"/post/tcp%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%E6%B5%85%E6%9E%90/"},{"content":"MTU与MSS与SMSS MTU：maximum transmission unit，最大传输单元，由硬件规定，如以太网的MTU为1500字节。 MSS：maximum segment","lvl0":"TCP流量控制浅析","lvl1":["网络"],"lvl2":"摘要","objectID":"47ffeb179edffab50ff08294d8e7ad9e","tags":null,"url":"/post/tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%B5%85%E6%9E%90/"},{"content":"拥塞的发生与不可避免 拥塞发生的主要原因在于网络能够提供的资源不足以满足用户的需求，这些资源包括缓存空间、链路带宽容量和中间节点的处理能力。由","lvl0":"TCP拥塞控制浅析","lvl1":["网络"],"lvl2":"摘要","objectID":"a5438bcce2ed54a405e116431a0b5759","tags":null,"url":"/post/tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%B5%85%E6%9E%90/"},{"content":"转载：http://blog.csdn.net/ns_code/article/details/32343979 前言 对于每个TCP连接，TC","lvl0":"TCP中的四大定时器","lvl1":["网络"],"lvl2":"摘要","objectID":"25beb10bffa6b8caf14cdc06e9228ee3","tags":null,"url":"/post/tcp%E4%B8%AD%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%AE%9A%E6%97%B6%E5%99%A8/"},{"content":"打开网页的原理 作为一个软件开发者，你一定会对网络应用如何工作有一个完整的层次化的认知，同样这里也包括这些应用所用到的技术：像浏览器，HTTP","lvl0":"当你输入一个网址的时候，实际会发生什么?","lvl1":["网络"],"lvl2":"摘要","objectID":"cbd744b9baf34f1209efe5112e9b4a5a","tags":["TTP"],"url":"/post/%E5%BD%93%E4%BD%A0%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E6%97%B6%E5%80%99%E5%AE%9E%E9%99%85%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/"},{"content":"CDN的全称Content Delivery Network，(缩写：CDN)即内容分发网络。 CDN是一个经策略性部署的整体系统，从技术上全面解决由于网络带宽","lvl0":"CDN的实现原理","lvl1":["网络"],"lvl2":"摘要","objectID":"e04b1ca75802249406647d3894879cf4","tags":null,"url":"/post/cdn%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"content":"粘包原因 TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都","lvl0":"TCP粘包问题","lvl1":["网络"],"lvl2":"摘要","objectID":"2e5be0dada43c4046c6e9c38c9ef63c3","tags":null,"url":"/post/tcp%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/"},{"content":"TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。一个TCP报文段分为 首部和数据两部分，而TCP的全部功能都体现在它首部中各字段的","lvl0":"TCP协议头详解","lvl1":["网络"],"lvl2":"摘要","objectID":"5a68e5f76e72dce921177f545a567ef8","tags":null,"url":"/post/tcp%E5%8D%8F%E8%AE%AE%E5%A4%B4%E8%AF%A6%E8%A7%A3/"},{"content":"名词解释 公有IP地址：也叫全局地址，是指合法的IP地址，它是由NIC（网络信息中心）或者ISP(网络服务提供商)分配的地址，对外代表一个或多","lvl0":"网络地址转换NAT原理及应用","lvl1":["网络"],"lvl2":"摘要","objectID":"96cdf243861ff4f4143794c60b5cfb8e","tags":null,"url":"/post/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2nat%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"},{"content":"转载：http://www.cnblogs.com/2myroad/articles/3881042.html DDoS攻击基础 DDoS（Di","lvl0":"DDoS攻击原理","lvl1":["网络"],"lvl2":"摘要","objectID":"131b687d2f0b907820d196502b717f2d","tags":null,"url":"/post/ddos%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86/"},{"content":"性能 性能优化有三个层次： 系统层次 算法层次 代码层次 系统层次关注系统的控制流程和数据流程，优化主要考虑如何减少消息传递的个数；如何使系统的负载更","lvl0":"常见性能优化思路","lvl1":[" 软件工程 "],"lvl2":"摘要","objectID":"cfb1a857e18a6bd4a66c7587a647e090","tags":null,"url":"/post/%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/"},{"content":"一、功能性：是指当软件在指定条件下使用，软件产品满足明确和隐含要求功能的能力。 适合性：是指软件产品与指定的任务和用户目标提供一组合适的功能的","lvl0":"软件质量特性","lvl1":["软件工程 "],"lvl2":"摘要","objectID":"baf87b2d0dda0ddab699ae339ba104da","tags":null,"url":"/post/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%89%B9%E6%80%A7/"},{"content":"前面讲到了 libevent 实现多线程的方法，然而在多线程的环境中注册信号事件，还是有一些情况需要小心处理，那就是不能在多个 libevent 实例上注册信号事件。依然冠名追","lvl0":"libevent源码剖析(十三)","lvl1":["Libevent"],"lvl2":"摘要","objectID":"00ae643d205b0452ce88b7890a03a676","tags":null,"url":"/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%81%E4%B8%89/"},{"content":"Libevent本身不是多线程安全的，在多核的时代，如何能充分利用CPU的能力呢，这一节来说说如何在多线程环境中使用libevent，跟源代","lvl0":"libevent源码剖析(十二)","lvl1":["Libevent"],"lvl2":"摘要","objectID":"dbedd66f3dd032eb326638f20c8733da","tags":null,"url":"/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%81%E4%BA%8C/"},{"content":"为了支持定时器，Libevent必须和系统时间打交道，这一部分的内容也比较简单，主要涉及到时间的加减辅助函数、时间缓存、时间校正和定时器堆的","lvl0":"libevent源码剖析(十一)","lvl1":["Libevent"],"lvl2":"摘要","objectID":"9e60c0c842df6b61342b86c54d731090","tags":null,"url":"/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%81%E4%B8%80/"},{"content":"Libevent的核心是事件驱动、同步非阻塞，为了达到这一目标，必须采用系统提供的I/O多路复用技术，而这些在Windows、Linux、U","lvl0":"libevent源码剖析(十)","lvl1":["Libevent"],"lvl2":"摘要","objectID":"3cb1fb41fd224e5a15f4bb9ad8041138","tags":null,"url":"/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%81/"},{"content":"现在再来详细分析libevent中I/O事件和Timer事件的集成，与Signal相比，Timer事件的集成会直观和简单很多。Libeven","lvl0":"libevent源码剖析(九)","lvl1":["Libevent"],"lvl2":"摘要","objectID":"3cefc96c0ec772dd739e5a0b0472bf5e","tags":null,"url":"/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B9%9D/"},{"content":"现在我们已经了解了libevent的基本框架：事件管理框架和事件主循环。上节提到了libevent中I/O事件和Signal以及Timer事","lvl0":"libevent源码剖析(八)","lvl1":["Libevent"],"lvl2":"摘要","objectID":"be2f37ecc30944d3d25b5d65e5378191","tags":null,"url":"/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%85%AB/"},{"content":"现在我们已经初步了解了libevent的Reactor组件——event_base和事件管理框架，接下来就是libevent事件处理的中心部","lvl0":"libevent源码剖析(七)","lvl1":["Libevent"],"lvl2":"摘要","objectID":"ba4fba85233f110eaaa2c0115775e1e2","tags":null,"url":"/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%83/"},{"content":"前面已经对libevent的事件处理框架和event结构体做了描述，现在是时候剖析libevent对事件的详细处理流程了，本节将分析libe","lvl0":"libevent源码剖析(六)","lvl1":["Libevent"],"lvl2":"摘要","objectID":"a8afcf5e3ffb97f0cec2c677c69a41fd","tags":null,"url":"/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%85%AD/"},{"content":"对事件处理流程有了高层的认识后，本节将详细介绍libevent的核心结构event，以及libevent对event的管理。 1 libeven","lvl0":"libevent源码剖析(五","lvl1":["Libevent"],"lvl2":"摘要","objectID":"4cf7105b4acc3e279ead99bc45414ad2","tags":null,"url":"/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%BA%94/"},{"content":"1 前言 详细分析源代码之前，如果能对其代码文件的基本结构有个大概的认识和分类，对于代码的分析将是大有裨益的。本节内容不多，我想并不是说它不重要","lvl0":"libevent源码剖析(四)","lvl1":["Libevent"],"lvl2":"摘要","objectID":"0f992a7c0d6a83e8f3bc09b32795a4ed","tags":null,"url":"/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%9B%9B/"},{"content":"1 前言 学习源代码该从哪里入手？我觉得从程序的基本使用场景和代码的整体处理流程入手是个不错的方法，至少从个人的经验上讲，用此方法分析libev","lvl0":"libevent源码剖析(三)","lvl1":["Libevent"],"lvl2":"摘要","objectID":"779c92c3c135dbb336cca6201aedc59c","tags":null,"url":"/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%89/"},{"content":"前面讲到，整个libevent本身就是一个Reactor，因此本节将专门对Reactor模式进行必要的介绍，并列出libevnet中的几个重","lvl0":"libevent源码剖析(二)","lvl1":["Libevent"],"lvl2":"摘要","objectID":"3309b4828ad07433d9a08e5fce998897","tags":null,"url":"/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%BA%8C/"},{"content":"1 前言 Libevent是一个轻量级的开源高性能网络库，使用者众多，研究者更甚，相关文章也不少。写这一系列文章的用意在于，一则分享心得；二则对","lvl0":"libevent源码剖析(一)","lvl1":["Libevent"],"lvl2":"摘要","objectID":"cde8878f18826e4f43abc25ad1fb5d1a","tags":null,"url":"/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%80/"},{"content":"转载：http://www.cnblogs.com/jeakeven/p/5402095.html 一、概念 SQL (Structured Query Language) 数据库，指关系型数据库。主","lvl0":"SQL 和 NoSQL 的区别","lvl1":["Linux编程 "],"lvl2":"摘要","objectID":"149d3baa1093dc7b48a6a0617b9cd18a","tags":null,"url":"/post/sql-%E5%92%8C-nosql-%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"content":"转载：http://blog.csdn.net/szchtx/article/details/42834391 一、定义 大端模式（Big End","lvl0":"大端模式和小端模式转化及网络字节序","lvl1":["Linux编程 "],"lvl2":"摘要","objectID":"3aaa4bb0c84bbcc7b4877aca4980c7db","tags":null,"url":"/post/%E5%A4%A7%E7%AB%AF%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F%E8%BD%AC%E5%8C%96%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F/"},{"content":"基本定义 可重入函数可以做这样的基本定义：重入意味着这个函数可以重复进入，可以被并行调用，可以被中断，它只使用自身栈上的数据变量，它不依赖于任","lvl0":"可重入函数与不可重入函数的区别","lvl1":["Linux编程 "],"lvl2":"摘要","objectID":"812c289e813bf6af400f4e1ee9adcc92","tags":null,"url":"/post/%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0%E4%B8%8E%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"content":"概述 如何控制并发是数据库领域中非常重要的问题之一，不过到今天为止事务并发的控制已经有了很多成熟的解决方案，而这些方案的原理就是这篇文章想要介","lvl0":"浅谈数据库并发控制","lvl1":["架构"],"lvl2":"摘要","objectID":"31af4e1d46e99eeeb5f40aadbb6d3b7a","tags":null,"url":"/post/%E6%B5%85%E8%B0%88%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"content":"转载：http://www.cnblogs.com/alex09/articles/4380115.html 三大基本特性 三大特性是：封装,继","lvl0":"面向对象三大基本特性,五大基本原则","lvl1":["OOP"],"lvl2":"摘要","objectID":"cb9b54e1293cdc574edef759ea6f32e8","tags":null,"url":"/post/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7-%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"},{"content":"分区和目录 Linux的文件结构是单个的树状结构.可以用tree进行展示。 在Ubuntu下安装tree（sudo apt-get install tree）,并可通过命令来","lvl0":"Linux文件系统浅析","lvl1":["Linux内核"],"lvl2":"摘要","objectID":"177b7a8f47d4992da4bbe57342026ef9","tags":null,"url":"/post/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%B5%85%E6%9E%90/"},{"content":"基本概念 实际用户ID（RUID） 用于标识一个系统中用户是谁，一般是在登录之后，就被唯一确定的，就是登陆的用户的uid 有效用户ID（EUID）","lvl0":"设置用户ID位，保存设置用户ID，有效用户ID，实际用户ID","lvl1":["Shell"],"lvl2":"摘要","objectID":"8b34d09028a2c3daca0ab67e68f95450","tags":null,"url":"/post/%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7id%E4%BD%8D%E4%BF%9D%E5%AD%98%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7id%E6%9C%89%E6%95%88%E7%94%A8%E6%88%B7id%E5%AE%9E%E9%99%85%E7%94%A8%E6%88%B7id/"},{"content":"系统调用 系统调用，英文名system call，每个操作系统都在内核里有一些内建的函数库，这些函数可以用来完成一些系统系统调用把应用程序的请求","lvl0":"带缓存IO和不带缓存IO","lvl1":["Linux内核"],"lvl2":"摘要","objectID":"925ebc608e9a665de1068714bba88942","tags":null,"url":"/post/%E5%B8%A6%E7%BC%93%E5%AD%98io%E5%92%8C%E4%B8%8D%E5%B8%A6%E7%BC%93%E5%AD%98io/"},{"content":"简介 Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。 输出信","lvl0":"netstat命令详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"d03a0efebd081ed40dc4fdb06e1a3dbf","tags":null,"url":"/post/netstat%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"content":"共享资源 正文段. 程序的代码 数据段。程序的全局内存。包括全局变量和静态变量: 全局变量它是与具体某一函数无关的，所以也与特定线程无关；因此也是共","lvl0":"多线程之间共享哪些资源？","lvl1":["Linux编程"],"lvl2":"摘要","objectID":"89e10d160841faa02b3ad7b682519aee","tags":null,"url":"/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E5%93%AA%E4%BA%9B%E8%B5%84%E6%BA%90/"},{"content":"两者联系 子进程得到父进程的数据空间，堆和栈的副本，但是两者是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程","lvl0":"父子进程的联系","lvl1":["Linux编程"],"lvl2":"摘要","objectID":"773c7824e199e4c55b90dbf725ce9256","tags":null,"url":"/post/%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%81%94%E7%B3%BB/"},{"content":"在多线程环境下，产生的信号是传递给整个进程的，一般而言，所有线程都有机会收到这个信号，进程在收到信号的的线程上下文执行信号处理函数，具体是哪","lvl0":"linux多线程信号处理","lvl1":["Linux编程"],"lvl2":"摘要","objectID":"fc2b268bd305e4d015142f18cb7d3d66","tags":null,"url":"/post/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"content":"地址 相关概念 物理地址 内存是由若干个存储单元组成的，每个存储单元有一个编号，这种编号可唯一标识一个存储单元，称为内存地址（或物理地址）。我们可","lvl0":"Linux系统内存管理","lvl1":["Linux内核"],"lvl2":"摘要","objectID":"2d96a651040fd4501f9a992b8dd84c12","tags":null,"url":"/post/linux%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"content":"常见的扫描类型有以下几种： 秘密扫描是一种不被审计工具所检测的扫描技术。 它通常用于在通过普通的防火墙或路由器的筛选（filtering）时隐藏","lvl0":"常见的端口扫描类型及原理","lvl1":["Linux内核"],"lvl2":"摘要","objectID":"80ec50925e25a3154d00fc3d21856295","tags":null,"url":"/post/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"content":"TCP连接的关闭有两个方法close和shutdown，这篇文章将尽量精简的说明它们分别做了些什么。 为方便阅读，我们可以带着以下5个问题来阅","lvl0":"解析shutdown()和close()","lvl1":["Linux编程"],"lvl2":"摘要","objectID":"1ef778610be32fdae5035e123c152b4f","tags":null,"url":"/post/%E8%A7%A3%E6%9E%90shutdown-%E5%92%8Cclose/"},{"content":"当调用closesocket关闭套接字时，SO_LINGER将决定系统如何处理残存在套接字发送队列中的数据。处理方式无非两种：丢弃或者将数据","lvl0":"SOCKETOPT-SO_LINGER选项","lvl1":["Linux编程"],"lvl2":"摘要","objectID":"2c4552076410fe9e48afe6a3a4238538","tags":null,"url":"/post/socketopt-so-linger%E9%80%89%E9%A1%B9/"},{"content":"简介 一般来说，一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。 这个套接字选项通知内核","lvl0":"SO_REUESADDR和SO_REUSEPORT","lvl1":["Linux编程"],"lvl2":"摘要","objectID":"50948ed82b175925abd7cecb555e92c0","tags":null,"url":"/post/socketopt-so-reuesaddr%E9%80%89%E9%A1%B9/"},{"content":"TCP协议中有长连接和短连接之分。短连接在数据包发送完成后就会自己断开，长连接在发包完毕后，会在一定的时间内保持连接，即我们通常所说的Kee","lvl0":"TCP长连接详解","lvl1":["网络"],"lvl2":"摘要","objectID":"397fda5934306f3a7f9026bc5db2a2cb","tags":null,"url":"/post/tcp%E9%95%BF%E8%BF%9E%E6%8E%A5%E8%AF%A6%E8%A7%A3/"},{"content":"介绍 open：系统调用，返回的是文件描述符，即文件句柄，是文件在文件描述副表里的索引。 fopen：C语言库函数，返回的是一个指向文件结构的指","lvl0":"open/read/write和fopen/fread/fwrite的区别","lvl1":["Linux编程"],"lvl2":"摘要","objectID":"83b81ffa8879083386d7ae2fd874e8a2","tags":null,"url":"/post/open-read-write%E5%92%8Cfopen-fread-fwrite%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"content":"FILE文件指针 C语言中使用文件指针做为I/O的句柄。文件指针指向进程用户区中的一个被称为FILE结构的数据结构。 FILE结构包括缓冲区和文","lvl0":"文件指针和文件描述符的区别","lvl1":["Linux编程"],"lvl2":"摘要","objectID":"e6941b6574a4d75a822c64d6bea3bf3d","tags":null,"url":"/post/%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"content":"iptables简介 netfilter/iptables（简称为iptables）组成Linux平台下的包过滤防火墙，与大多数的Linux软","lvl0":"linux平台下防火墙iptables原理","lvl1":["网络"],"lvl2":"摘要","objectID":"8f9908ea1b15040340b235e555dd4b8e","tags":null,"url":"/post/linux%E5%B9%B3%E5%8F%B0%E4%B8%8B%E9%98%B2%E7%81%AB%E5%A2%99iptables%E5%8E%9F%E7%90%86/"},{"content":"转载: https://github.com/linw7/Skill-Tree/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#mutex 简介 我们这里讨论的是用户态的多线程模型，同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被虽有的","lvl0":"多线程模型详解","lvl1":["Linux编程"],"lvl2":"摘要","objectID":"8a682fc50e06e1a78d3b0e46b4bd411e","tags":null,"url":"/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"},{"content":"下图是基于TCP协议的客户端/服务器程序的一般流程： 服务器调用socket()、bind()、listen()完成初始化后，调用accept","lvl0":"socket通信过程","lvl1":["网络"],"lvl2":"摘要","objectID":"6928312cafe9654c8c623c669c64102c","tags":null,"url":"/post/socket%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B/"},{"content":"一.概述 这里以Linux为例。Linux历史上，最开始使用的线程是LinuxThreads，但LinuxThreads有些方面受限于内核的特","lvl0":"Linux历史上线程的3种实现模型","lvl1":["Linux内核"],"lvl2":"摘要","objectID":"7eeece319575b2dec2927b5c8c9ebbca","tags":null,"url":"/post/linux%E5%8E%86%E5%8F%B2%E4%B8%8A%E7%BA%BF%E7%A8%8B%E7%9A%843%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9E%8B/"},{"content":"最令Linux程序员头疼的莫过于内存泄露了，即使你是在优秀的程序员，你也不能保证所以的malloc操作都有对应的free，那必要的工具就是必","lvl0":"利用linux的mtrace命令定位内存泄露(Memory Leak)","lvl1":["Linux编程"],"lvl2":"摘要","objectID":"448844bc490cc630a791a33989f298e1","tags":null,"url":"/post/%E5%88%A9%E7%94%A8linux%E7%9A%84mtrace%E5%91%BD%E4%BB%A4%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2-memory-leak/"},{"content":"gcc命令 gcc命令使用GNU推出的基于C/C++的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点。现","lvl0":"GCC编译器介绍","lvl1":["Linux编程"],"lvl2":"摘要","objectID":"5867daadf33b379dee40088da7458e6e","tags":null,"url":"/post/gcc%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%8B%E7%BB%8D/"},{"content":"一，什么是coredump 我们经常听到大家说到程序core掉了，需要定位解决，这里说的大部分是指对应程序由于各种异常或者bug导致在运行过程","lvl0":"coredump详解","lvl1":["Linux编程"],"lvl2":"摘要","objectID":"ea8c4d5343059a6ab9eb0ae22090b9f6","tags":null,"url":"/post/coredump%E8%AF%A6%E8%A7%A3/"},{"content":"ping命令 基本原理 Ping命令利用ICMP协议进行工作，ICMP是Internet控制消息协议，用于在主机和路由器之间传递控制消息。Pin","lvl0":"ping命令和traceroute命令详解","lvl1":["Shell"],"lvl2":"摘要","objectID":"3c2c1d9db94bbcf7b73c0b056cd2cf47","tags":null,"url":"/post/ping%E5%91%BD%E4%BB%A4%E5%92%8Ctraceroute%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"content":"运行级别 运行级别就是操作系统当前正在运行的功能级别。级别是从0到6，具有不同的功能。这些级别定义在/ect/inittab文件中。这个文件是","lvl0":"Linux运行级别","lvl1":["Linux内核"],"lvl2":"摘要","objectID":"2949264d8c46519e5ec5b6419fd83fac","tags":null,"url":"/post/linux%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB/"},{"content":"组成 Linux内核主要有 5个子系统组成：进程调度 (SCHED) ,内存管理 (MM) ,虚拟文件系统 (VFS) ,网络接口 (NET)和进程间通信 ( IPC )。 1、进程调度 进程在进程","lvl0":"Linux内核的组成部分","lvl1":["Linux内核 "],"lvl2":"摘要","objectID":"b90db2476ac29a954ed838c01f41c4f2","tags":null,"url":"/post/linux%E5%86%85%E6%A0%B8%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/"},{"content":"一、 Unix/Linux的体系架构 如上图所示，从宏观上来看，Linux操作系统的体系架构分为用户态和内核态。 内核从本质上看是一种软件——控制","lvl0":"Linux用户态与内核态","lvl1":["Linux内核"],"lvl2":"摘要","objectID":"0c45f93a9d4608b48473e3d329ab586d","tags":null,"url":"/post/linux%E7%94%A8%E6%88%B7%E6%80%81%E4%B8%8E%E5%86%85%E6%A0%B8%E6%80%81/"},{"content":"描述一个网络中各个协议层的常用方法是使用国际标准化组织（ISO）的计算机通信开放系统互连（open systems interconnection , OSI）模型。 OSI模型的底下两层是","lvl0":"Socket处在网络层的什么位置？","lvl1":["Linux编程"],"lvl2":"摘要","objectID":"08c8c77a0a6ce2db18a11f8e548eb6e8","tags":null,"url":"/post/socket%E5%A4%84%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E4%BB%80%E4%B9%88%E4%BD%8D%E7%BD%AE/"},{"content":"进程的组成 在Linux系统中进程由以下三部分组成： 进程控制块PCB 有了这个数据结构，进程才能成为内核调度的一个基本单位接受内核的调度。同时，","lvl0":"Linux进程管理","lvl1":["Linux内核"],"lvl2":"摘要","objectID":"7174b133ec413da9442471e1f183476b","tags":null,"url":"/post/linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"content":"组成 Linux系统一般有4个主要部分：内核、shell、文件系统和应用程序。内核、shell和文件系统一起形成了基本的操作系统结构，它们使得","lvl0":"Linux操作系统的组成和基本功能","lvl1":["Linux内核"],"lvl2":"摘要","objectID":"621e82b52ce25d5f07119e544f9ea153","tags":null,"url":"/post/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/"},{"content":"Valgrind是运行在Linux上一套基于仿真技术的程序调试和分析工具，是公认的最接近Purify的产品，它包含一个内核——一个软件合成的","lvl0":"调试工具Valgrind","lvl1":["Linux编程"],"lvl2":"摘要","objectID":"8f9a3098067d7e3ce951534dc9992a6c","tags":null,"url":"/post/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7valgrind/"},{"content":"转载：http://blog.chinaunix.net/uid-26495963-id-3066282.html 启动第一步－－加载BIOS","lvl0":"Linux启动过程详解","lvl1":["Linux内核 "],"lvl2":"摘要","objectID":"8597fb14a539343f29686adc4446921b","tags":null,"url":"/post/linux%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"},{"content":"LeetCode 1. Two Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 解析","lvl0":"数组中和为定值的多元组","lvl1":["解题报告"],"lvl2":"摘要","objectID":"775de94aafe58149a9834c9759c0fe6d","tags":["Array"],"url":"/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BA%E5%AE%9A%E5%80%BC%E7%9A%84%E5%A4%9A%E5%85%83%E7%BB%84/"},{"content":"LeetCode 2. Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt; 6","lvl0":"模拟数组/字符串/链表的相加与相乘","lvl1":["解题报告"],"lvl2":"摘要","objectID":"57a86073a787b75a85d3c18239bb166d","tags":["Array","String","Bit Manipulation","Linked List"],"url":"/post/%E6%A8%A1%E6%8B%9F%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E5%8A%A0%E4%B8%8E%E7%9B%B8%E4%B9%98/"},{"content":"LeetCode 392. Is Subsequence Given a string s and a string t, check if s is subsequence of t. You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (\u0026lt;=100). A subsequence of a string is a new string which is formed from the original string by deleting","lvl0":"最长子串/子序列","lvl1":["解题报告"],"lvl2":"摘要","objectID":"a3f80aa7afcae740a86b45066922ba4d","tags":["Two Pointers"],"url":"/post/%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E5%AD%90%E5%BA%8F%E5%88%97/"},{"content":"LeetCode 409. Longest Palindrome Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example “Aa” is not considered a palindrome here. Note: Assume the length of given string will not exceed 1,010. Example: Input: \u0026ldquo;abccccdd\u0026rdquo; Output: 7 Explanation: One longest palindrome that can be built is “","lvl0":"查找回文子串和回文子序列","lvl1":["解题报告"],"lvl2":"摘要","objectID":"0965a1d0c66c7b0dcacf79131fc8de32","tags":["区间DP","Backtracking"],"url":"/post/%E6%9F%A5%E6%89%BE%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E5%92%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/"},{"content":"LeetCode 6. ZigZag Conversion 字符串“PAYPALISHIRING”以给定数目的行以之字形模式写入，如下所示：（您可能希望以固定字体显示此模式以更好的易读性） P A","lvl0":"“之”字形翻译字符串","lvl1":["解题报告 "],"lvl2":"摘要","objectID":"ab7f34effe8a3fee5df93c2260280a12","tags":["String"],"url":"/post/%E4%B9%8B%E5%AD%97%E5%BD%A2%E7%BF%BB%E8%AF%91%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"content":"LeetCode 7. Reverse Integer Reverse digits of an integer. Example1: x = 123, return 321 Example2: x = -123, return -321 click to show spoilers. Note: The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. 解析：需要注意溢出的问题。一个int可以表示数字","lvl0":"数字字符串转成数字","lvl1":["解题报告"],"lvl2":"摘要","objectID":"ddddd6c59105e77a917571e08ea39ce1","tags":["String"],"url":"/post/%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%88%90%E6%95%B0%E5%AD%97/"},{"content":"LeetCode 9. Palindrome Number Determine whether an integer is a palindrome. Do this without extra space. Some hints: Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Intege","lvl0":"判断回文串","lvl1":["解题报告"],"lvl2":"摘要","objectID":"1dec2171cadabe5f5f319799f8470d2c","tags":["Two Pointers","Linked List"],"url":"/post/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E4%B8%B2/"},{"content":"LeetCode 166. Fraction to Recurring Decimal Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. For example, Given numerator = 1, denominator = 2, return “0.5”. Given numerator = 2, denominator = 1, return “2”. Given numerator = 2, denominator = 3,","lvl0":"模拟除法","lvl1":["解题报告"],"lvl2":"摘要","objectID":"76606c6d8c8d2e0badb3f7c6f4bef2fa","tags":["Math"],"url":"/post/%E6%A8%A1%E6%8B%9F%E9%99%A4%E6%B3%95/"},{"content":"LeetCode 74. Search a 2D Matrix Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. 解析： 因为每行从小到大排序，而且每","lvl0":"在有序矩阵中找数","lvl1":["解题报告"],"lvl2":"摘要","objectID":"d2bccf3740d0355254539a74ce418d75","tags":["Binary Search"],"url":"/post/%E5%9C%A8%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%89%BE%E6%95%B0/"},{"content":"LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal Given preorder and inorder traversal of a tree, construct the binary tree. 解析：可以发现的规律是：中序遍历中根节点是左子树右子树的分割点。前序遍历的第一个节点为根节点。同","lvl0":"先序、中序、后序数组两两组合重构二叉树","lvl1":["解题报告"],"lvl2":"摘要","objectID":"8d4d6224bc05ba307924c8649fa85e7a","tags":["Tree","DFS"],"url":"/post/%E5%85%88%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%A4%E4%B8%A4%E7%BB%84%E5%90%88%E9%87%8D%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91-/"},{"content":"LeetCode 94. Binary Tree Inorder Traversal Given a binary tree, return the inorder traversal of its nodes’ values. 解析：递归太简单，直接上递推，用栈来模拟递归，找左孩子，保存路径，找不到就找右兄弟的左孩子。 1","lvl0":"二叉树的前序/中序/后序遍历","lvl1":["解题报告 "],"lvl2":"摘要","objectID":"9723247f47e596edec51388d5c8a5d99","tags":["Tree"],"url":"/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"content":"LeetCode 230. Kth Smallest Element in a BST Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. 解析：中序遍历BST就可以得到一个有序数组，题目要找Kth，就直接中序遍历，在输出的字符串","lvl0":"Binary Search Tree","lvl1":["解题报告"],"lvl2":"摘要","objectID":"1c00462e34f1cdb7777a3242ea2808c9","tags":["DFS","BST"],"url":"/post/binary-search-tree/"},{"content":"LeetCode 225. Implement Stack using Queues Implement the following operations of a stack using queues. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. empty() – Return whether the stack is empty. Notes: You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty","lvl0":"栈与队列的互相实现","lvl1":["解题报告"],"lvl2":"摘要","objectID":"9838c9dffd8579ed18f3b3c3ba87bad3","tags":["Stack","Queue"],"url":"/post/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%92%E7%9B%B8%E5%AE%9E%E7%8E%B0/"},{"content":"LeetCode 153. Find Minimum in Rotated Sorted Array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. You may assume no duplicate exists in the array. Subscribe to see which companies asked this question. 解析： 二分法，旋","lvl0":"在有序旋转数组中的查找","lvl1":["解题报告 "],"lvl2":"摘要","objectID":"16a9e7ed589cf9b23d365e8e001341f7","tags":["Array","Binary Search"],"url":"/post/%E5%9C%A8%E6%9C%89%E5%BA%8F%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"},{"content":"LeetCode 70. Climbing Stairs You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. 解析：标准Fibonacci，也可看作DP。","lvl0":"斐波那契数列","lvl1":["解题报告"],"lvl2":"摘要","objectID":"be41842d3b3341647eddc2e1d4277b56","tags":null,"url":"/post/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"content":"LeetCode 191. Number of 1 Bits Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight). For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3. 解析：n=n\u0026amp;(n-1)可以取出","lvl0":"常见位运算问题","lvl1":["解题报告 "],"lvl2":"摘要","objectID":"ede22865703e33108b9fed15198615dc","tags":["Bit Manipulation"],"url":"/post/%E5%B8%B8%E8%A7%81%E4%BD%8D%E8%BF%90%E7%AE%97%E9%97%AE%E9%A2%98/"},{"content":"LeetCode 231. Power of Two Given an integer, write a function to determine if it is a power of two. 解析：2的幂表示n的只有一个位是“1”，因此使用n\u0026amp;（n-1）== 0的技巧来判断是否是这种情","lvl0":"求某个数是否为2/3/4的幂","lvl1":[" 解题报告"],"lvl2":"摘要","objectID":"061da95c073da27d6ccab2639725f8a0","tags":["Bit Manipulation"],"url":"/post/%E6%B1%82%E6%9F%90%E4%B8%AA%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA234%E7%9A%84%E5%B9%82/"},{"content":"LeetCode 50. Pow(x, n) Implement pow(x, n). 解析：快速幂，此处需要判断边界值n，如果n为-2^31，那么需要另外设置一个long long变量存储其相反数。0x800000","lvl0":"求幂与开方","lvl1":["解题报告"],"lvl2":"摘要","objectID":"d88e2bd8615de9f2827306838aee3199","tags":["Binary Sort","Math"],"url":"/post/%E6%B1%82%E5%B9%82%E4%B8%8E%E5%BC%80%E6%96%B9/"},{"content":"LeetCode 27. Remove Element Given an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example: Given input array nums = [3,2,2,3],","lvl0":"删除数组/链表的元素","lvl1":["解题报告 "],"lvl2":"摘要","objectID":"9c0a038e58b0b95e2566c741d22ad1f1","tags":["Linked List","Array"],"url":"/post/%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%83%E7%B4%A0/"},{"content":"LeetCode 19. Remove Nth Node From End of List Given a linked list, remove the nth node from the end of list and return its head. For example, Given linked list: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-\u0026gt;2-\u0026gt;3-\u0026gt;5. Note: Given n will always be valid. Try to do this in one pass. 解析： 根据题意","lvl0":"在单链表中删除倒数第N个节点","lvl1":["解题报告"],"lvl2":"摘要","objectID":"fed0d7bfcb52a7ecbc7ce70445d47e4c","tags":["Linked List","Two Pointers"],"url":"/post/%E5%9C%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"content":"LeetCode 141. Linked List Cycle Given a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space? 解析： FLOYD判圈算法(判断是否有环): 如何检测一个链表是否有环，如果有，那么如何确","lvl0":"链表有环和相交问题","lvl1":["解题报告"],"lvl2":"摘要","objectID":"ab7582d44e936d050ffbcf0f6c31d4a7","tags":["Linked List","Two Pointers"],"url":"/post/%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF%E5%92%8C%E7%9B%B8%E4%BA%A4%E9%97%AE%E9%A2%98/"},{"content":"LeetCode 189. Rotate Array Rotate an array of n elements to the right by k steps. For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. 解析： 循环移动数组k位：123","lvl0":"数组、字符串、链表的旋转判定","lvl1":["解题报告"],"lvl2":"摘要","objectID":"6b8fc2f8410374fa24f52efa61d80b5c","tags":["Linked List","Array","String"],"url":"/post/%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE%E8%A1%A8%E7%9A%84%E6%97%8B%E8%BD%AC%E5%88%A4%E5%AE%9A/"},{"content":"LeetCode 24. Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head. For example, Given 1-\u0026gt;2-\u0026gt;3-\u0026gt;4, you should return the list as 2-\u0026gt;1-\u0026gt;4-\u0026gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 解析：直接交换当前结点和其后继节点的","lvl0":"反转链表","lvl1":["解题报告 "],"lvl2":"摘要","objectID":"b5020f132b64b9bfbe439cf9d89ff8c1","tags":["Linked List"],"url":"/post/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"content":"LeetCode 88. Merge Sorted Array Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 解析： 合并两个数组（","lvl0":"合并有序链表/数组","lvl1":["解题报告"],"lvl2":"摘要","objectID":"01df5326083d4cc490d18d8dd1039be0","tags":["Merge","Array","Linked List","STL"],"url":"/post/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E6%95%B0%E7%BB%84/"},{"content":"LeetCode 226. Invert Binary Tree Invert a binary tree. 4 / \\ 2 7 / \\ / \\ 1 3 6 9 to 4 / \\ 7 2 / \\ / \\ 9 6 3 1 解析：二叉树的镜像就是在遍历树的同时交换非叶节点的左右子节点 1 2 3 4","lvl0":"镜像二叉树","lvl1":["解题报告"],"lvl2":"摘要","objectID":"eaf03d7a079554005a951dd7c987db85","tags":["Tree","DFS"],"url":"/post/%E9%95%9C%E5%83%8F%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"content":"LeetCode 100.Same Tree Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. 解析：直接DFS，注意两个节点中任何一个为空要直接返回，算是递归终止","lvl0":"判断t1树是否包含t2树全部的拓扑结构","lvl1":["解题报告"],"lvl2":"摘要","objectID":"a478f92dd1eb5fc2e68d7a93e913716c","tags":["Tree","DFS"],"url":"/post/%E5%88%A4%E6%96%ADt1%E6%A0%91%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%ABt2%E6%A0%91%E5%85%A8%E9%83%A8%E7%9A%84%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/"},{"content":"LeetCode 54. Spiral Matrix Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. For example, Given the following matrix: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] You should return [1,2,3,6,9,8,7,4,5]. 解析： 先找出矩阵的四个边界，然后将整","lvl0":"转圈打印矩阵","lvl1":["解题报告"],"lvl2":"摘要","objectID":"21e7018f67bdf07f7e9acda740029216","tags":["Array"],"url":"/post/%E8%BD%AC%E5%9C%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"},{"content":"LeetCode 399. Evaluate Division Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0. Example: Given a / b = 2.0, b / c = 3.0. queries are: a / c = ?, b / a =","lvl0":"除法的化简","lvl1":["解题报告"],"lvl2":"摘要","objectID":"0e6247b397a60e66101c1b50d4a104db","tags":["DFS","Graph"],"url":"/post/%E9%99%A4%E6%B3%95%E7%9A%84%E5%8C%96%E7%AE%80/"},{"content":"LeetCode 235. Lowest Common Ancestor of a Binary Search Tree Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a","lvl0":"二叉树节点间的公共祖先","lvl1":["解题报告"],"lvl2":"摘要","objectID":"60d0474b2d1a4fa2558bbd51df54539d","tags":["DFS","Tree","LCA"],"url":"/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E9%97%B4%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"},{"content":"LeetCode 155. Min Stack Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --\u0026gt; Returns -3. minStack.pop(); minStack.top(); --\u0026gt; Returns 0.","lvl0":"设计一个有getMin功能的栈","lvl1":["解题报告"],"lvl2":"摘要","objectID":"a7f1edb6a496937a034d1fa62e51ef1d","tags":["Stack","Design"],"url":"/post/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%9C%89getmin%E5%8A%9F%E8%83%BD%E7%9A%84%E6%A0%88/"},{"content":"LeetCode 209. Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. For example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint. 解析：用双指","lvl0":"滑动窗口","lvl1":["解题报告"],"lvl2":"摘要","objectID":"c0007607812e2dd3904a50d394b787ef","tags":["DFS","滑动窗口"],"url":"/post/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"content":"LeetCode102. Binary Tree Level Order Traversal Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 return its level order traversal as: [ [3], [9,20], [15,7] ] 解析：此题要求将二叉树层","lvl0":"二叉树的按层打印与ZigZig打印","lvl1":["解题报告"],"lvl2":"摘要","objectID":"6b196f4e6f4396db2458657071612f1b","tags":["Tree","BFS"],"url":"/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%B8%8Ezigzig%E6%89%93%E5%8D%B0/"},{"content":"LeetCode 104. Maximum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 解析：找二叉树的最大深度，不断dfs，只要能dfs到下一层，就增加","lvl0":"二叉树的深度","lvl1":["解题报告"],"lvl2":"摘要","objectID":"dbb60315e5c688153ed34121cc963367","tags":["Tree","DFS"],"url":"/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"},{"content":"LeetCode 112. Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. For example: Given the below binary tree and sum = 22, 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 return true, as there exist a root-to-leaf path 5-\u0026gt;4-\u0026gt;11-\u0026gt;2","lvl0":"在二叉树中找到累加和为指定值的最长路径长度","lvl1":["解题报告"],"lvl2":"摘要","objectID":"2f0d94a172a6e39893462bf613d9f422","tags":["Tree","DFS"],"url":"/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E6%8C%87%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6/"},{"content":"LeetCode 138. Copy List with Random Pointer A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. 解析： 此题有两种方法，一种是按照原链表next的顺序依次创建节","lvl0":"复制含有随机指针节点的链表","lvl1":["解题报告"],"lvl2":"摘要","objectID":"6bd1edacb7a28628fe2970dc842452ed","tags":["Linked List","Graph"],"url":"/post/%E5%A4%8D%E5%88%B6%E5%90%AB%E6%9C%89%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E8%8A%82%E7%82%B9%E7%9A%84%E9%93%BE%E8%A1%A8/"},{"content":"LeetCode 451. Sort Characters By Frequency Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input: “tree” Output: “eert” Explanation: ‘e’ appears twice while ‘r’ and ‘t’ both appear once. So ‘e’ must appear before both ‘r’ and ‘t’. Therefore","lvl0":"找到无序数组中某一频率的数","lvl1":["解题报告"],"lvl2":"摘要","objectID":"d3693a8a073a9ef45575f4fe29cb1924","tags":["Array","Heap","Bucket Sort","多数投票算法"],"url":"/post/%E6%89%BE%E5%88%B0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%90%E4%B8%80%E9%A2%91%E7%8E%87%E7%9A%84%E6%95%B0/"},{"content":"LeetCode 53. Maximum Subarray Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6. 解析：动态规划 每个元素有2种选择：加入之前的连续子序列；创建一个新","lvl0":"子数组的最大累加和/累乘积","lvl1":["解题报告"],"lvl2":"摘要","objectID":"d86e6b89ee7e2139ac3bf5b67b8f3ca2","tags":["Array","DP","Binary Search","Matrix"],"url":"/post/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E5%8A%A0%E5%92%8C%E7%B4%AF%E4%B9%98%E7%A7%AF/"},{"content":"LeetCode 233. Number of Digit One Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n. For example: Given n = 13, Return 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13. 解析： 每10个数, 有一个个位是1, 每100","lvl0":"与数字的某位相关问题","lvl1":["解题报告"],"lvl2":"摘要","objectID":"a34294aa684588000c33446ab68eeeea","tags":["Math"],"url":"/post/%E4%B8%8E%E6%95%B0%E5%AD%97%E7%9A%84%E6%9F%90%E4%BD%8D%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"},{"content":"LeetCode 263. Ugly Number Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note that 1 is typically treated as an ugly number. 解析： 我们将给定数除以2","lvl0":"丑数","lvl1":["解题报告"],"lvl2":"摘要","objectID":"fa7fbafda4f423d3629b154975bd344c","tags":["Math"],"url":"/post/%E4%B8%91%E6%95%B0/"},{"content":"判断字符数组中是否所有的字符都只出现过一次 题目: 给定一个字符类型数组chas[]，判断chas中是否所有的字符都只出现过一次,在保证额外空间","lvl0":"字符数组中的单独字符","lvl1":["解题报告"],"lvl2":"摘要","objectID":"8fafbed3cb88aa8630fc5d3953f5af8d","tags":["Hash","Heap"],"url":"/post/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E7%8B%AC%E5%AD%97%E7%AC%A6/"},{"content":"LeetCode 402. Remove K Digits Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible. Note: The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero. Example 1: Input: num = \u0026quot;1432219\u0026quot;, k = 3 Output: \u0026quot;1219\u0026quot; Explanation: Remove the three digits 4, 3,","lvl0":"通过增删数位创建新的数字","lvl1":["解题报告"],"lvl2":"摘要","objectID":"e35fe4e4d8518c2206b3fcd30dbe5e8a","tags":["单调栈"],"url":"/post/%E9%80%9A%E8%BF%87%E5%A2%9E%E5%88%A0%E6%95%B0%E4%BD%8D%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E6%95%B0%E5%AD%97/"},{"content":"LeetCode 46. Permutations Given a collection of distinct numbers, return all possible permutations. For example, [1,2,3] have the following permutations: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 解析： 此题可以直接用STL中的next_permutation()实现。利用回溯法暴","lvl0":"排列","lvl1":["解题报告"],"lvl2":"摘要","objectID":"5e13290e3bb5d13b12b13c0adf8bc26b","tags":["STL","Backtracking"],"url":"/post/%E6%8E%92%E5%88%97/"},{"content":"LeetCode 136. Single Number Given an array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 解析：利用异或运算规律，同一个数异或两次相当于没有异或。本题除了所","lvl0":"查找单独/重复/丢失的元素","lvl1":["解题报告"],"lvl2":"摘要","objectID":"a3ecff0b9c3e80b21d2ce73da9cb7d00","tags":["Bit Manipulation"],"url":"/post/%E6%9F%A5%E6%89%BE%E5%8D%95%E7%8B%AC%E9%87%8D%E5%A4%8D%E4%B8%A2%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0/"},{"content":"LeetCode 26. Remove Duplicates from Sorted Array Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example, Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and","lvl0":"删除有序数组/链表的重复值","lvl1":["解题报告 "],"lvl2":"摘要","objectID":"96aa9fb0d924739d306e1e05484bc2e8","tags":["Array","DFS","单调栈","Two Pointers","Linked List"],"url":"/post/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E5%80%BC/"},{"content":"LeetCode 89. Gray Code The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. For example, given n = 2, return [0,1,3,2]. Its gray code sequence is: 00 - 0 01 - 1 11 -","lvl0":"格雷码","lvl1":["解题报告"],"lvl2":"摘要","objectID":"f86cc8b31a94187ccbe50559a5f6cf9d","tags":["Math"],"url":"/post/%E6%A0%BC%E9%9B%B7%E7%A0%81/"},{"content":"LeetCode 44. Wildcard Matching Implement wildcard pattern matching with support for ‘?’ and ‘*’. ‘?’ Matches any single character. ‘*’ Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). The function prototype should be: bool isMatch(const char s, const char p) Some examples: isMatch(\u0026quot;aa\u0026quot;,\u0026quot;a\u0026quot;) → false isMatch(\u0026quot;aa\u0026quot;,\u0026quot;aa\u0026quot;) → true isMatch(\u0026quot;aaa\u0026quot;,\u0026quot;aa\u0026quot;) →","lvl0":"正则表达式匹配","lvl1":["解题报告"],"lvl2":"摘要","objectID":"26b537f2fb24284ec04abb0d6a728721","tags":["Backtracking","DP"],"url":"/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"},{"content":"LeetCode 217. Contains Duplicate Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. 解析：直接构建哈希表 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: bool containsDuplicate(vector\u0026lt;int\u0026gt;\u0026amp;","lvl0":"查找数组中的重复项","lvl1":["解题报告"],"lvl2":"摘要","objectID":"877b73382512b90471f479615244e29a","tags":["Sliding Window","Hash"],"url":"/post/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"},{"content":"LeetCode 11. Container With Most Water Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and","lvl0":"容器的盛水量","lvl1":["解题报告"],"lvl2":"摘要","objectID":"d8b7b8dfd0b6f1b7b1237109e4709eeb","tags":["Two Pointers","BFS"],"url":"/post/%E5%AE%B9%E5%99%A8%E7%9A%84%E7%9B%9B%E6%B0%B4%E9%87%8F/"},{"content":"LeetCode 14. Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings. 解析：求所有字符串的公共前缀，逐个字符比较，时间复杂度为O(N*L),N是字符串个数，L是最长前缀的","lvl0":"最长公共前缀","lvl1":["解题报告"],"lvl2":"摘要","objectID":"aafaf6cc40e53cc0c2c9da27afb70de5","tags":["Array"],"url":"/post/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"},{"content":"LeetCode 12. Integer to Roman Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 解析：先是做了一个表，根据各个位的数字查表，然后组合罗马数字成字符串 1 2 3 4 5 6 7 8 9 10","lvl0":"数字翻译","lvl1":["解题报告"],"lvl2":"摘要","objectID":"d8c3b53978302ac69fa306ec6a4e2f58","tags":["Array","Math","String"],"url":"/post/%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91/"},{"content":"括号字符的有效性 给定一个字符串str,判断是不是整体有效的括号字符串。 解析: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static boolean isValid(String str) { if (str == null || str.equals(\u0026#34;\u0026#34;))","lvl0":"括号匹配","lvl1":["解题报告"],"lvl2":"摘要","objectID":"6461379f912ca827a70035fa14e0ab69","tags":["Stack","DP"],"url":"/post/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/"},{"content":"LeetCode 35. Search Insert Position Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Here are few examples. [1,3,5,6], 5 → 2 [1,3,5,6], 2 → 1 [1,3,5,6], 7 → 4 [1,3,5,6], 0 → 0 解析：在有序","lvl0":"数组中的位置查找","lvl1":["解题报告"],"lvl2":"摘要","objectID":"7c984c477772dad682344fc6fe1e31c2","tags":["STL","Binary Search"],"url":"/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE%E6%9F%A5%E6%89%BE/"},{"content":"LeetCode 374. Guess Number Higher or Lower We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I’ll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0): -1 :","lvl0":"根据大小猜数","lvl1":["解题报告"],"lvl2":"摘要","objectID":"a506d3959e6ff950feca6d48acd384ab","tags":["区间DP","Binary Search"],"url":"/post/%E6%A0%B9%E6%8D%AE%E5%A4%A7%E5%B0%8F%E7%8C%9C%E6%95%B0/"},{"content":"LeetCode 292. Nim Game You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game.","lvl0":"从石堆取石子的博弈问题","lvl1":["解题报告"],"lvl2":"摘要","objectID":"c5df9f41e2192fbaaf51b48c4b14947f","tags":["Math","博弈DP"],"url":"/post/%E4%BB%8E%E7%9F%B3%E5%A0%86%E5%8F%96%E7%9F%B3%E5%AD%90%E7%9A%84%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/"},{"content":"LeetCode 312. Burst Balloons Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] nums[i] nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you","lvl0":"引爆区间气球","lvl1":["解题报告"],"lvl2":"摘要","objectID":"7fa75eea3f772b190842948baac144f3","tags":["区间DP"],"url":"/post/%E5%BC%95%E7%88%86%E5%8C%BA%E9%97%B4%E6%B0%94%E7%90%83/"},{"content":"LeetCode 36. Valid Sudoku The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’. 解析：检查九宫格是否有效，只需要检查每行每列和每个子九宫格是否存在重复数字即可。创建三个map","lvl0":"数独","lvl1":["解题报告"],"lvl2":"摘要","objectID":"44bdca5cde146e22054ead1529afd0e5","tags":["Backtracking"],"url":"/post/%E6%95%B0%E7%8B%AC/"},{"content":"LeetCode 39. Combination Sum Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example, given candidate set [2, 3, 6, 7]","lvl0":"组合","lvl1":["解题报告"],"lvl2":"摘要","objectID":"a0827ddcb70768ce99b1e57cfe617be5","tags":["Greedy","背包DP"],"url":"/post/%E7%BB%84%E5%90%88/"},{"content":"LeetCode 55. Jump Game Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. For example: A = [2,3,1,1,4], return true. A = [3,2,1,0,4], return false. 解析：设最远距离为reach","lvl0":"跳跃游戏","lvl1":["解题报告"],"lvl2":"摘要","objectID":"7ea0d196a719983df9f8f78c4f0cfdd9","tags":["Greedy","DP"],"url":"/post/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"},{"content":"LeetCode 48. Rotate Image You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Follow up: Could you do this in-place? 解析： 二维矩阵顺时针旋转90度，先转置，再把每一行翻转 二维矩阵逆时针旋转90度，","lvl0":"将正方形矩阵转动90度","lvl1":["解题报告"],"lvl2":"摘要","objectID":"e5c6ff4b6a234ba8a3cee7de990f53cb","tags":["Array"],"url":"/post/%E5%B0%86%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9F%A9%E9%98%B5%E8%BD%AC%E5%8A%A890%E5%BA%A6/"},{"content":"LeetCode 383. Ransom Note Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false. Each letter in the magazine string can only be used once in your ransom note. Note: You may assume that both strings contain only lowercase letters. canConstruct(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;)","lvl0":"判断变形字符串","lvl1":["解题报告"],"lvl2":"摘要","objectID":"79c1c7761c52f0e0b2fd4da69775dcae","tags":["Hash","STL","Two Pointers","String"],"url":"/post/%E5%88%A4%E6%96%AD%E5%8F%98%E5%BD%A2%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"content":"LeetCode 51. N-Queens The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen","lvl0":"N皇后问题","lvl1":["解题报告"],"lvl2":"摘要","objectID":"cd408eb98f3566c6da0da404a4ef25c6","tags":["Backtracking"],"url":"/post/n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"},{"content":"LeetCode 58. Length of Last Word Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. For example, Given s = “Hello World”","lvl0":"最后一个单词的长度","lvl1":["解题报告"],"lvl2":"摘要","objectID":"f77fb3140a14fb9fc333b26fccf3795a","tags":["String"],"url":"/post/%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/"},{"content":"LeetCode 68. Text Justification Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ‘ ‘ when necessary so that each line has exactly L characters. Extra spaces between","lvl0":"文本排版","lvl1":["解题报告"],"lvl2":"摘要","objectID":"338d0faece53fd3e264af9c4700e073c","tags":["String"],"url":"/post/%E6%96%87%E6%9C%AC%E6%8E%92%E7%89%88/"},{"content":"LeetCode 62. Unique Paths A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How","lvl0":"路径问题","lvl1":["解题报告"],"lvl2":"摘要","objectID":"aed40204c0119889d4bad334f076f6e9","tags":["Graph","DP"],"url":"/post/%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"},{"content":"LeetCode 228. Summary Ranges Given a sorted integer array without duplicates, return the summary of its ranges. For example, given [0,1,2,4,5,7], return [“0-\u0026gt;2”,”4-\u0026gt;5”,”7”]. 解析： 将一组数划分成若干的区间，用双指针分别","lvl0":"区间问题","lvl1":["解题报告"],"lvl2":"摘要","objectID":"49948ee14da3b0384065241b82bdc70c","tags":["Binary Search","STL","Heap"],"url":"/post/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"},{"content":"LeetCode 71. Simplify Path Given an absolute path for a file (Unix-style), simplify it. For example, path = “/home/“, =\u0026gt; “/home” path = “/a/./b/../../c/“, =\u0026gt; “/c” 解析： 字符串处理，而","lvl0":"文件路径","lvl1":["解题报告"],"lvl2":"摘要","objectID":"ff31746dc0f350ea09247c28e15ca9c5","tags":["String","Stack"],"url":"/post/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/"},{"content":"LeetCode 115. Distinct Subsequences Given a string S and a string T, count the number of distinct subsequences of T in S. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABC","lvl0":"字符串A编辑成字符串B","lvl1":["解题报告"],"lvl2":"摘要","objectID":"96644223096e4da8066e9af9ea7fdffc","tags":["Hash","背包DP","String"],"url":"/post/%E7%AC%A6%E4%B8%B2a%E7%BC%96%E8%BE%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2b/"},{"content":"LeetCode 73. Set Matrix Zeroes Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place. 解析： 题目要求空间复杂度in place，即原地工作O(1),执行算法时所使用的额外空","lvl0":"修改矩阵","lvl1":["解题报告"],"lvl2":"摘要","objectID":"a9899c911f8f43e8fb1b241cc1e1eec1","tags":["Matrix"],"url":"/post/%E4%BF%AE%E6%94%B9%E7%9F%A9%E9%98%B5/"},{"content":"LeetCode 78. Subsets Given a set of distinct integers, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. For example, If nums = [1,2,3], a solution is: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 解析：要求输出所有子集，且输出有序，而每个元素只有出现和","lvl0":"子集","lvl1":["解题报告"],"lvl2":"摘要","objectID":"e2591412291797a93b12802069b98dd7","tags":["背包DP","Bit Manipulation"],"url":"/post/%E5%AD%90%E9%9B%86/"},{"content":"LeetCode 79. Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example, Given board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] word","lvl0":"字典树相关问题","lvl1":["解题报告"],"lvl2":"摘要","objectID":"f0d74dcc1421a04fdac34359f505df39","tags":["字典树","Backtracking"],"url":"/post/%E5%AD%97%E5%85%B8%E6%A0%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"},{"content":"插入排序 LeetCode 147. Insertion Sort List Sort a linked list using insertion sort. 解析： 链表排序最易理解的是插入排序。 插入排序的方法就是枚举数组中的每一个元素i，从头扫描数组，找到第一个比该","lvl0":"单链表排序总结","lvl1":["解题报告"],"lvl2":"摘要","objectID":"38a7e08726b45690526707233ceefa32","tags":["Linked List","Sort"],"url":"/post/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"},{"content":"LeetCode 75. Sort Colors Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library","lvl0":"划分数组/链表","lvl1":["解题报告"],"lvl2":"摘要","objectID":"8c017963ece4d2802880573b2ff3664b","tags":["Linked List","Quick Sort","Array","Two Pointers"],"url":"/post/%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/"},{"content":"LeetCode 87. Scramble String Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Below is one possible representation of s1 = “great”: great / \\ gr eat / \\ / \\ g r e at / \\ a t To scramble the string, we may choose any non-leaf node and swap its","lvl0":"乱序字符串","lvl1":["解题报告"],"lvl2":"摘要","objectID":"a4f02c3de04ef14740cba3228055aaac","tags":["DP","DFS"],"url":"/post/%E4%B9%B1%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"content":"LeetCode 84. Largest Rectangle in Histogram Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area =","lvl0":"最大区域面积","lvl1":["解题报告"],"lvl2":"摘要","objectID":"2438fef8251ccc10b3b3cc003fbd3039","tags":["DP","单调栈"],"url":"/post/%E6%9C%80%E5%A4%A7%E5%8C%BA%E5%9F%9F%E9%9D%A2%E7%A7%AF/"},{"content":"LeetCode 96. Unique Binary Search Trees Given n, how many structurally unique BST’s (binary search trees) that store values 1…n? For example, Given n = 3, there are a total of 5 unique BST’s. 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2","lvl0":"统计和生成所有不同的二叉树","lvl1":["解题报告"],"lvl2":"摘要","objectID":"273970578323525184e1020c4053d953","tags":["Tree","DP"],"url":"/post/%E7%BB%9F%E8%AE%A1%E5%92%8C%E7%94%9F%E6%88%90%E6%89%80%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"content":"LeetCode 108. Convert Sorted Array to Binary Search Tree Given an array where elements are sorted in ascending order, convert it to a height balanced BST. 解析： 每次找到数组的中间位置，这个便是BST的 根节点。左右孩子也很好找，根节点左边区域的","lvl0":"重建搜索二叉树","lvl1":["解题报告"],"lvl2":"摘要","objectID":"2c1530ab602b80bd8efc6f54b6d375b8","tags":["BST","DFS"],"url":"/post/%E9%87%8D%E5%BB%BA%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"content":"LeetCode 93. Restore IP Addresses Given a string containing only digits, restore it by returning all possible valid IP address combinations. For example: Given “25525511135”, return [“255.255.11.135”, “255.255.111.","lvl0":"IP Address","lvl1":["解题报告"],"lvl2":"摘要","objectID":"1859d6c0a17b30b8c6de29e6309ca1ce","tags":["String","Backtracking"],"url":"/post/ip-address/"},{"content":"LeetCode 494. Target Sum You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol. Find out how many ways to assign symbols to make sum of integers equal to target S. Example 1: Input: nums is [1, 1, 1, 1,","lvl0":"添加括号或运算符进行计算","lvl1":["解题报告"],"lvl2":"摘要","objectID":"018abade6ee6499bf598cc433d5b5a16","tags":["DFS","DP"],"url":"/post/%E6%B7%BB%E5%8A%A0%E6%8B%AC%E5%8F%B7%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"content":"LeetCode 114. Flatten Binary Tree to Linked List Given a binary tree, flatten it to a linked list in-place. For example, Given 1 / \\ 2 5 / \\ \\ 3 4 6 The flattened tree should look like: 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 解析： 可以看出变换后的树实际上是按照先序","lvl0":"Flatten Binary Tree to Linked List","lvl1":["解题报告"],"lvl2":"摘要","objectID":"9271941bf3e7014beb1158568457b1f6","tags":["DFS","Tree"],"url":"/post/flatten-binary-tree-to-linked-list/"},{"content":"LeetCode 118. Pascal’s Triangle Given numRows, generate the first numRows of Pascal’s triangle. For example, given numRows = 5, Return [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] 解析： 杨辉三角形的构造方法：左右边界为1，中间num[i]","lvl0":"Pascal's Triangle","lvl1":["解题报告"],"lvl2":"摘要","objectID":"9a6f12342a52e053295dded03e144627","tags":["DFS","Tree"],"url":"/post/pascal-s-triangle/"},{"content":"LeetCode 116. Populating Next Right Pointers in Each Node Given a binary tree struct TreeLinkNode { TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space. You may assume that it","lvl0":"在二叉树节点中添加新指针","lvl1":["解题报告"],"lvl2":"摘要","objectID":"1f221ec4358d7aadfd4019eefaa47335","tags":["DFS","Tree"],"url":"/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%8C%87%E9%92%88/"},{"content":"LeetCode 121. Best Time to Buy and Sell Stock Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1: Input: [7, 1, 5, 3, 6, 4] Output: 5 max.","lvl0":"购买股票问题","lvl1":["解题报告"],"lvl2":"摘要","objectID":"d22311defc97745351cba72879d57d65","tags":["DP"],"url":"/post/%E8%B4%AD%E4%B9%B0%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"},{"content":"LeetCode 127. Word Ladder Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. For example, Given: beginWord =","lvl0":"Word Ladder","lvl1":["解题报告"],"lvl2":"摘要","objectID":"be60a67570fedaf5c3736638d031db0e","tags":["Backtracking","Graph","String","BFS"],"url":"/post/word-ladder/"},{"content":"LeetCode 300. Longest Increasing Subsequence Given an unsorted array of integers, find the length of longest increasing subsequence. For example, Given [10, 9, 2, 5, 3, 7, 101, 18], The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity.","lvl0":"最长上升子序列","lvl1":["解题报告"],"lvl2":"摘要","objectID":"d5e07435cdedbfe8ff086bb90ff1d29e","tags":["Greedy","Hash","DP"],"url":"/post/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"},{"content":"LeetCode 130. Surrounded Regions Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’. A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region. For example, X X X X X O O X X X O X X O X X After running your function,","lvl0":"Surrounded Regions","lvl1":["解题报告"],"lvl2":"摘要","objectID":"0a90317e8d1f0b92fb4a9973f7984314","tags":["DFS","Flood Fill","Graph"],"url":"/post/surrounded-regions/"},{"content":"LeetCode 134. Gas Station There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas stat","lvl0":"134. Gas Station","lvl1":["解题报告"],"lvl2":"摘要","objectID":"1ec014119f8b712d0986074912117ba6","tags":["Greedy"],"url":"/post/gas-station/"},{"content":"LeetCode 135. Candy There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. What is the minimum candies you must give? 解析： 先引入爬坡和下坡的概","lvl0":"分糖果问题","lvl1":["解题报告"],"lvl2":"摘要","objectID":"90f3bb6dfe69d658a8b5b17a34f8b57f","tags":["Greedy"],"url":"/post/%E5%88%86%E7%B3%96%E6%9E%9C%E9%97%AE%E9%A2%98/"},{"content":"LeetCode 164. Maximum Gap Given an unsorted array, find the maximum difference between the successive elements in its sorted form. Try to solve it in linear time/space. Return 0 if the array contains less than 2 elements. You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. 解析： 桶排序要求所有元素在一","lvl0":"数组排序之后相邻数的最大差值","lvl1":["解题报告"],"lvl2":"摘要","objectID":"f744abff8234412870047ca5f75d8d88","tags":["Bucket Sort"],"url":"/post/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%90%8E%E7%9B%B8%E9%82%BB%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/"},{"content":"LeetCode 187. Repeated DNA Sequences All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. For","lvl0":"重复的DNA子序列","lvl1":["解题报告"],"lvl2":"摘要","objectID":"49cd466a8a90da85a376141fa0d65613","tags":["Hash","Bit Manipulation"],"url":"/post/%E9%87%8D%E5%A4%8D%E7%9A%84dna%E5%AD%90%E5%BA%8F%E5%88%97/"},{"content":"LeetCode 204. Count Primes Description: Count the number of prime numbers less than a non-negative number, n. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution {//埃拉托斯特尼尼素数筛法 public: int countPrimes(int n) { if (n\u0026lt;=2) return 0;//2以下没有","lvl0":"筛选素数","lvl1":["解题报告"],"lvl2":"摘要","objectID":"83161fe42e8d9e5ef84768f68486dfe7","tags":["Math","素数筛法"],"url":"/post/%E7%AD%9B%E9%80%89%E7%B4%A0%E6%95%B0/"},{"content":"LeetCode 202. Happy Number Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which","lvl0":"特殊数","lvl1":["解题报告"],"lvl2":"摘要","objectID":"e266a429f4d1a9bd6863451a867d0a2e","tags":["DFS","Math"],"url":"/post/%E7%89%B9%E6%AE%8A%E6%95%B0/"},{"content":"LeetCode 207. Course Schedule There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? For example:","lvl0":"课程安排","lvl1":["解题报告"],"lvl2":"摘要","objectID":"0ba7b7b66fde3c80200251b6e6e366c3","tags":["DFS","BFS","拓扑排序"],"url":"/post/%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92/"},{"content":"LeetCode 223. Rectangle Area Find the total area covered by two rectilinear rectangles in a 2D plane. Each rectangle is defined by its bottom left corner and top right corner as shown in the figure. 解析： 求出两个区域的面积, 然后减去overlapping的区域, 即为所","lvl0":"求重叠矩形的面积","lvl1":["解题报告"],"lvl2":"摘要","objectID":"2c91b3bf0bb8c0ab158a3018231534ae","tags":["Math"],"url":"/post/%E6%B1%82%E9%87%8D%E5%8F%A0%E7%9F%A9%E5%BD%A2%E7%9A%84%E9%9D%A2%E7%A7%AF/"},{"content":"LeetCode 218. The Skyline Problem A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B). The geometric","lvl0":"天际线扫描","lvl1":["解题报告"],"lvl2":"摘要","objectID":"59ff1be56869908aac56ce82091c8d4b","tags":["离散化","扫描线"],"url":"/post/%E5%A4%A9%E9%99%85%E7%BA%BF%E6%89%AB%E6%8F%8F/"},{"content":"LeetCode 274. H-Index Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index. According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have","lvl0":"H-Index","lvl1":["解题报告"],"lvl2":"摘要","objectID":"a79f40164895d2c61bb751bdd686a349","tags":["Array","Binary Search"],"url":"/post/h-index/"},{"content":"LeetCode 205. Isomorphic Strings Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. For example, Given “egg","lvl0":"同构字符串","lvl1":["解题报告"],"lvl2":"摘要","objectID":"36e67cac8fda8edc7ecd0a649da5affb","tags":["String","Hash"],"url":"/post/%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"content":"LeetCode 380. Insert Delete GetRandom O(1) Design a data structure that supports all following operations in average O(1) time. insert(val): Inserts an item val to the set if not already present. remove(val): Removes an item val from the set if present. getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned. Example: 1 2 3 4 5 6 7 8","lvl0":"设计RandomPool结构","lvl1":["解题报告"],"lvl2":"摘要","objectID":"1409a4d504edd33d89f573780a4ef434","tags":["Design","Hash"],"url":"/post/%E8%AE%BE%E8%AE%A1randompool%E7%BB%93%E6%9E%84/"},{"content":"LeetCode 149. Max Points on a Line Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. 解析： 坑点1 如果直线是和y轴平行的，那么不能直接用(y1-y2)/(x1-x2)表示斜","lvl0":"查找一条直线上的最多点个数","lvl1":["解题报告"],"lvl2":"摘要","objectID":"38a8d3057b3cb8a8892c59cfa0f8fe4f","tags":["DP","Backtracking"],"url":"/post/%E6%9F%A5%E6%89%BE%E4%B8%80%E6%9D%A1%E7%9B%B4%E7%BA%BF%E4%B8%8A%E7%9A%84%E6%9C%80%E5%A4%9A%E7%82%B9%E4%B8%AA%E6%95%B0/"},{"content":"LeetCode 146. LRU Cache Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should","lvl0":"设计缓存结构","lvl1":["解题报告"],"lvl2":"摘要","objectID":"f6ef58e6134e6dd0dc345b9333568020","tags":["Design","Linked List"],"url":"/post/%E8%AE%BE%E8%AE%A1%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84/"},{"content":"LeetCode 162. Find Peak Element A peak element is an element that is greater than its neighbors. Given an input array where num[i] ≠ num[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that num[-1] = num[n] = -∞. For example, in array [1, 2,","lvl0":"查找区间最大值","lvl1":["解题报告"],"lvl2":"摘要","objectID":"d927d4ce1974410636ff649e931ddbea","tags":["Array","STL"],"url":"/post/%E6%9F%A5%E6%89%BE%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"content":"LeetCode 297. Serialize and Deserialize Binary Tree Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your","lvl0":"二叉树的序列化与反序列化","lvl1":["解题报告"],"lvl2":"摘要","objectID":"413563964f4ad958057dfec1cad433d5","tags":["BST","Tree"],"url":"/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"content":"LeetCode 299. Bulls and Cows You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”)","lvl0":"Bulls and Cows","lvl1":["解题报告"],"lvl2":"摘要","objectID":"6444d3cbffa03b1a8da154fcf780d13d","tags":["Array","Hash"],"url":"/post/bulls-and-cows/"},{"content":"LeetCode 295. Find Median from Data Stream Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. Examples: [2,3,4] , the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void","lvl0":"随时找到数据流的中位数","lvl1":["解题报告"],"lvl2":"摘要","objectID":"a531c95d2e5d7858c02a4ed538fb3a8d","tags":["eap"],"url":"/post/%E9%9A%8F%E6%97%B6%E6%89%BE%E5%88%B0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"content":"LeetCode 303. Range Sum Query - Immutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -\u0026gt; 1 sumRange(2, 5) -\u0026gt; -1 sumRange(0, 5) -\u0026gt; -3 Note: You may assume that the array does not change. There are many calls to sumRange function. 解析： 数","lvl0":"区间查询问题","lvl1":["解题报告"],"lvl2":"摘要","objectID":"2486c535fed7c64f9676ea0bc5ab295e","tags":["Binary Indexed Tree","DP"],"url":"/post/%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98/"},{"content":"LeetCode 406. Queue Reconstruction by Height Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue. Note: The number of","lvl0":"Queue Reconstruction by Height","lvl1":["解题报告"],"lvl2":"摘要","objectID":"eed51e453ee4cd4f5ea6b42417ee97fd","tags":["Greedy"],"url":"/post/queue-reconstruction-by-height/"},{"content":"LeetCode 319. Bulb Switcher There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it’s off or turning off if it’s on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last","lvl0":"开关灯","lvl1":["解题报告"],"lvl2":"摘要","objectID":"293cf24230c6f094e1ac74ab9f234597","tags":["Math"],"url":"/post/%E5%BC%80%E5%85%B3%E7%81%AF/"},{"content":"LeetCode 322. Coin Change You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: coins = [1, 2, 5], amount = 11 return 3 (11 = 5 + 5","lvl0":"换钱","lvl1":["解题报告"],"lvl2":"摘要","objectID":"33ab4c313d1b93b062065eb26da677fe","tags":["DP","背包DP"],"url":"/post/%E6%8D%A2%E9%92%B1/"},{"content":"LeetCode 330. Patching Array Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required. Example 1: nums = [1, 3], n = 6 Return 1. Combinations of nums are [1], [3], [1,3], which form possible sums","lvl0":"Patching Array","lvl1":["解题报告"],"lvl2":"摘要","objectID":"16aec6b075c9464d0a586dce678b3931","tags":["Array","Greedy"],"url":"/post/patching-array/"},{"content":"LeetCode 332. Reconstruct Itinerary Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example,","lvl0":"Reconstruct Itinerary","lvl1":["解题报告"],"lvl2":"摘要","objectID":"2623428135f753d2bb9249317354ffd4","tags":[" Graph","DFS","欧拉回路"],"url":"/post/reconstruct-itinerary/"},{"content":"LeetCode 335. Self Crossing You are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x[1] metres to the west, x[2] metres to the south, x[3] metres to the east and so on. In other words, after each move your direction changes counter-clockwise. Write a one-pass algorithm with O(1) extra space to determine, if your path crosses itself,","lvl0":"Self Crossing","lvl1":["解题报告"],"lvl2":"摘要","objectID":"69b63008c816c03ad9eb3606e0319209","tags":["Math"],"url":"/post/self-crossing/"},{"content":"LeetCode 341. Flatten Nested List Iterator Given a nested list of integers, implement an iterator to flatten it. Each element is either an integer, or a list – whose elements may also be integers or other lists. Example 1: Given the list [[1,1],2,[1,1]], By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. Example 2: Given the list [1,[4,[6]]], By calling next","lvl0":"Nested List","lvl1":["解题报告"],"lvl2":"摘要","objectID":"51896959617fb48dae2cfea9b8e2d8ee","tags":["Stack"],"url":"/post/nested-list/"},{"content":"LeetCode 344. Reverse String Write a function that takes a string as input and returns the string reversed. Example: Given s = “hello”, return “olleh”. 解析：双指针，从两端向中间移动，并交换元素。 1 2 3 4 5 6 7 8 9","lvl0":"翻转字符串","lvl1":["解题报告"],"lvl2":"摘要","objectID":"bcb8f5da31fe7420519681b13b0c12f6","tags":null,"url":"/post/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"content":"LeetCode 355. Design Twitter Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user’s news feed. Your design should support the following methods: postTweet(userId, tweetId): Compose a new tweet. getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user’s news feed. Each","lvl0":"设计Twitter","lvl1":["解题报告"],"lvl2":"摘要","objectID":"c12d0c915b419f2bbfdea3c4cd020c7b","tags":["Heap","Design"],"url":"/post/%E8%AE%BE%E8%AE%A1twitter/"},{"content":"LeetCode 384. Shuffle an Array Shuffle a set of numbers without duplicates. Example: 1 2 3 4 5 6 7 8 9 10 11 12 // Init an array with set 1, 2, and 3. int[] nums = {1,2,3}; Solution solution = new Solution(nums); // Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned. solution.shuffle(); // Resets the array back to","lvl0":"洗牌问题","lvl1":["解题报告"],"lvl2":"摘要","objectID":"31174b7b73b85187a16542a807717189","tags":null,"url":"/post/%E6%B4%97%E7%89%8C%E9%97%AE%E9%A2%98/"},{"content":"字符串的统计字符串 题目: 给定一个字符串str，返回str的统计字符串。例如，\u0026ldquo;aaabbadddffc\u0026quot;的统计字符串为","lvl0":"字符串的统计形式","lvl1":["解题报告"],"lvl2":"摘要","objectID":"d5697153ed92b95496c1260d0b44555b","tags":["tring"],"url":"/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%BD%A2%E5%BC%8F/"},{"content":"LeetCode 404. Sum of Left Leaves Find the sum of all left leaves in a given binary tree. Example: 3 / 9 20 / 15 7 There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24. 解析： 判断一个节点是否为左叶子节点: 1.是父节点的左孩","lvl0":"树的叶子节点","lvl1":["解题报告"],"lvl2":"摘要","objectID":"0aa316fdaf3faf419f2c0616a98b8459","tags":["Tree","DFS"],"url":"/post/%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9/"},{"content":"412. Fizz Buzz Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”","lvl0":"Fizz Buzz","lvl1":["解题报告"],"lvl2":"摘要","objectID":"c0f5eb59fb51a21dd2ff13b9c8918a0c","tags":["ath"],"url":"/post/fizz-buzz/"},{"content":"LeetCode 413. Arithmetic Slices Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the “Pacific ocean” touches the left and top edges of the matrix and the “Atlantic ocean” touches the right and bottom edges.","lvl0":"Arithmetic Slices","lvl1":["解题报告"],"lvl2":"摘要","objectID":"1e9e953368d2ecb5a06362e17f717361","tags":["FS"],"url":"/post/arithmetic-slices/"},{"content":"LeetCode 417. Pacific Atlantic Water Flow A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequence: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 The following sequence is not arithmetic. 1, 1, 2, 5, 7 A zero-indexed array A consisting of N","lvl0":"Pacific Atlantic Water Flow","lvl1":["解题报告"],"lvl2":"摘要","objectID":"77e1c37f908f65778fa84fa619e7e11b","tags":["Array","DP"],"url":"/post/pacific-atlantic-water-flow/"},{"content":"LeetCode 420. Strong Password Checker A password is considered strong if below conditions are all met: It has at least 6 characters and at most 20 characters. It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit. It must NOT contain three repeating characters in a row (“…aaa…” is weak, but “…aa","lvl0":"密码检查器","lvl1":["解题报告"],"lvl2":"摘要","objectID":"e8dd3445d52461fcf87fde3723bac9f2","tags":["Sliding Window","String","Greedy"],"url":"/post/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"content":"LeetCode 349. Intersection of Two Arrays Given two arrays, write a function to compute their intersection. Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2]. Note: Each element in the result must be unique. The result can be in any order. 解析： 因为要求结果元素不重复，所以采用unord","lvl0":"两个数组的相交数字","lvl1":["解题报告"],"lvl2":"摘要","objectID":"18813ea21b4fdc13cdac63c52df386e7","tags":["Array","Hash"],"url":"/post/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E4%BA%A4%E6%95%B0%E5%AD%97/"},{"content":"数据成员指针、函数成员指针 1. 数据成员指针 对于普通指针变量来说，其值是它所指向的地址，0表示空指针。 而对于数据成员指针变量来说，其值是数据成员","lvl0":"多态实现机制详解","lvl1":["C++"],"lvl2":"摘要","objectID":"27dd963502ddd6fa46b2b021cc151be3","tags":null,"url":"/post/%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"},{"content":"创建三维数组 vector法 vector\u0026lt;vector\u0026lt;vector\u0026gt; \u0026gt; f(N+1,vector\u0026lt;vector\u0026gt;(N,vector(N))); 第一维 第二维 第三维和类型 1维容量 2维数组正常构建方式:vector\u0026lt;vector\u0026gt;(N,vect","lvl0":"日常编程技巧","lvl1":["C++"],"lvl2":"摘要","objectID":"b3ea5654d5d48699bc89ea58fcbf73f4","tags":null,"url":"/post/%E6%97%A5%E5%B8%B8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"},{"content":"转载：http://blog.csdn.net/u013249689/article/details/25297657 vector不是容器，","lvl0":"不使用vector保存bool的理由","lvl1":["C++ "],"lvl2":"摘要","objectID":"ebe53ee7a482d6c9218f2648e137db85","tags":null,"url":"/post/%E4%B8%8D%E4%BD%BF%E7%94%A8vector-bool-%E7%9A%84%E7%90%86%E7%94%B1/"},{"content":"有些C程序用C++编译器会报错，有如下几种情况： 函数声明在使用之后： 1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;stdio.h\u0026gt; int main() { foo(); // foo() is called before its declaration/definition } int foo() { printf(\u0026#34;Hello\u0026#34;); return 0; } 普通指针指","lvl0":"C++编译不了的C程序","lvl1":["C++"],"lvl2":"摘要","objectID":"312cf9c069776387cd17da01be5ae562","tags":null,"url":"/post/c-%E7%BC%96%E8%AF%91%E4%B8%8D%E4%BA%86%E7%9A%84c%E7%A8%8B%E5%BA%8F/"},{"content":"new运算符 开辟单变量地址空间 使用new运算符时必须已知数据类型，new运算符会向系统堆区申请足够的存储空间，如果申请成功，就返回该内存块的","lvl0":"new/delete用法详解","lvl1":["C++ "],"lvl2":"摘要","objectID":"e8c7e940a304a49f703b03ac9605f314","tags":null,"url":"/post/new-delete%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"content":"定义 assert()的用法是一种“契约式编程”，在我的理解中，其表达的意思就是，程序在我的假设条件下，能够正常良好的运作，其实就相当于一个i","lvl0":"assert()用法","lvl1":["C++"],"lvl2":"摘要","objectID":"22a9fd456e59393b4124fa3e0deb49e7","tags":null,"url":"/post/assert-%E7%94%A8%E6%B3%95/"},{"content":"在STL实现中，traits编程技术得到大量的运用，它利用了“内嵌类型”的编程技巧与C++的template参数推导功能，弥补了C++类型识","lvl0":"STL中的Traits编程技法","lvl1":["STL"],"lvl2":"摘要","objectID":"b71ecbe93937c434bebe49f7fb226a98","tags":null,"url":"/post/stl%E4%B8%AD%E7%9A%84traits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95/"},{"content":"前言 本文仅对函数本身进行分析，不考虑编译环境的差异。 例如关于strcpy，memcpy和memmove关于内存重叠的问题，各个编译器和库都对","lvl0":"strcpy、strncpy、memcpy和memmove浅析","lvl1":["STL"],"lvl2":"摘要","objectID":"4d5fc6d2e0999ea8786cccd2bf8bd7a9","tags":null,"url":"/post/strcpystrncpymemcpy%E5%92%8Cmemmove%E6%B5%85%E6%9E%90/"},{"content":"内存溢出和内存泄漏的区别 内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个","lvl0":"内存泄漏和内存溢出","lvl1":["C++"],"lvl2":"摘要","objectID":"7ffd441ff36bc78795d8dcdefd07c07d","tags":null,"url":"/post/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"},{"content":"1. 申请的内存所在位置 new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区","lvl0":"new和malloc的区别","lvl1":["C++"],"lvl2":"摘要","objectID":"864280d81dec9018691b84e088f8b4bc","tags":null,"url":"/post/new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"content":"malloc能够申请的空间大小与物理内存的大小没有直接关系，仅与程序的虚拟地址空间相关。程序运行时，堆空间只是程序向操作系统申请划出来的一大","lvl0":"在1G内存的计算机中能否malloc(1.2G)","lvl1":["C++"],"lvl2":"摘要","objectID":"81ead247d072bf325243781d569bdf75","tags":null,"url":"/post/%E5%9C%A81g%E5%86%85%E5%AD%98%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E8%83%BD%E5%90%A6malloc-1-2g/"},{"content":"转载：http://www.cnblogs.com/jiu0821/p/4127382.html 概念 指针是一块内存的地址值，而引用是一块内存","lvl0":"指针和引用的区别","lvl1":["C++"],"lvl2":"摘要","objectID":"4e654dbd7feec544e0f5b8317baac995","tags":null,"url":"/post/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"content":"1.预处理 读取c源程序，对其中的伪指令（以#开头的指令）和特殊符号进行处理 伪指令主要包括以下四个方面: 宏定义指令，如#define Name Toke","lvl0":"C/C++源代码到可执行程序的过程详解","lvl1":["C++"],"lvl2":"摘要","objectID":"61ec09ecf61cb953b50bdc22591f108f","tags":null,"url":"/post/c-c-%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"},{"content":"堆栈溢出 堆栈溢出通常是所有的缓冲区溢出中最容易进行利用的。了解堆栈溢出之前，先了解以下几个概念： 缓冲区 简单说来是一块连续的计算机内存区域，可","lvl0":"缓冲区溢出(Buffer Overflow)","lvl1":["C++"],"lvl2":"摘要","objectID":"2d49d1e2445d3fcf849c85a6a0807281","tags":null,"url":"/post/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA-buffer-overflow/"},{"content":"迭代器： 迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-\u0026gt;,*,++ –等封装了指针，","lvl0":"迭代器和指针的区别","lvl1":["STL"],"lvl2":"摘要","objectID":"9253bcaa93f27424a1e0ee47ed16b11f","tags":null,"url":"/post/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"content":"vector vector是一个顺序容器，在内存中是一块连续的内存。引起内存重新分配的插入运算使所有迭代器失效，插入也使得插入位置及其后位置的迭代器失效","lvl0":"STL迭代器特性及失效问题","lvl1":["STL"],"lvl2":"摘要","objectID":"599001f0c3d047dd9e06cd7c20d9a868","tags":null,"url":"/post/stl%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%89%B9%E6%80%A7%E5%8F%8A%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"},{"content":"快速排序是一种很快的算法，它平均的时间复杂度WieO(nlgn)， 最坏时间复杂度为O(n^2)。但是快排有很多改良版，其中一种就是内省式的快","lvl0":"STL中的快速排序改进版——内省排序","lvl1":["STL"],"lvl2":"摘要","objectID":"f3b4d43e41943a99e728c0d8a8d31b30","tags":null,"url":"/post/stl%E4%B8%AD%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%94%B9%E8%BF%9B%E7%89%88%E5%86%85%E7%9C%81%E6%8E%92%E5%BA%8F/"},{"content":"什么是拷贝构造函数 首先对于普通类型的对象来说，它们之间的复制是很简单的，例如： int a = 100; int b = a; 而类对象与普通对象不同，类对象内部结构一般较为","lvl0":"拷贝构造函数详解","lvl1":["C++"],"lvl2":"摘要","objectID":"61c7707bbae9a2e3a3c6de46e15f9777","tags":null,"url":"/post/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"},{"content":"空类声明时不会生成任何默认成员函数 对于空类，编译器不会生成任何默认成员函数，只会生成1个字节的占位符。 有时可能会以为编译器会为空类生成默认构","lvl0":"空类产生几个默认成员函数?","lvl1":["C++"],"lvl2":"摘要","objectID":"485ac9613d72b488e3bcffa435f0c606","tags":null,"url":"/post/%E7%A9%BA%E7%B1%BB%E4%BA%A7%E7%94%9F%E5%87%A0%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"},{"content":"inline与宏定义 inline 关键字用来定义一个类的内联函数，引入它的主要原因是用它替代C中表达式形式的宏定义。为什么inline能很好地取代预定义","lvl0":"解析“inline”","lvl1":["C++"],"lvl2":"摘要","objectID":"8b90b7ccfac47a764bd91dd42b07740a","tags":null,"url":"/post/%E8%A7%A3%E6%9E%90inline/"},{"content":"memset性能陷阱 memset是大家常用的函数，而且一般的编程书籍都会谆谆告诫大家：申请内存后要初始化，防止使用未经初始化的内存导致不可预","lvl0":"性能杀手：”潜伏”的memset","lvl1":["C++"],"lvl2":"摘要","objectID":"de7acd3882fbd5bef389a448daa7b4e0","tags":null,"url":"/post/%E6%80%A7%E8%83%BD%E6%9D%80%E6%89%8B%E6%BD%9C%E4%BC%8F%E7%9A%84memset/"},{"content":"概述 char用来定义字符型变量，在内存中占1字节，范围是-128~127. 有以下两种存储方式： 将一个整型常量放到一个字符变量中，实际就是把以","lvl0":"详解char类型","lvl1":["C++"],"lvl2":"摘要","objectID":"4bac3555379690190d6c69aeecdfd3c5","tags":null,"url":"/post/%E8%AF%A6%E8%A7%A3char%E7%B1%BB%E5%9E%8B/"},{"content":"在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中","lvl0":"解析“mutable","lvl1":["C++"],"lvl2":"摘要","objectID":"5c8face7f925f303de52399c301d3bfb","tags":["键字"],"url":"/post/%E8%A7%A3%E6%9E%90mutable/"},{"content":"volatile概述 volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到","lvl0":"解析“volatile”","lvl1":["C++"],"lvl2":"摘要","objectID":"1a314fa49d04f601087592961918bb7b","tags":["键字"],"url":"/post/%E8%A7%A3%E6%9E%90volatile/"},{"content":"C/C++是强类型语言,不同类型之间的相互转换是比较麻烦的.但是在编程实践中,不可避免的要用到类型转换.有2种类型转换:隐式类型转换和强制类","lvl0":"C++中的强制类型转换","lvl1":["C++"],"lvl2":"摘要","objectID":"06a914fa07456c88fefa1512d762ff0e","tags":null,"url":"/post/c-%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"content":"scanf与printf scanf 原型：int scanf(char *format,\u0026hellip;]); 头文件：stdio.h 返回值：返回成功读入的数据项的个数，读到文件末尾或者出错时则返回EOF（0x","lvl0":"字符串的输入输出","lvl1":["C++"],"lvl2":"摘要","objectID":"b9b4ebac71bd3a82570232fc6b63f903","tags":null,"url":"/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"content":"格式化 格式化字符串 格式化整型数值 格式化浮点值（普通计数法） 格式化浮点值（科学计数法） 补充：E是exponent,表示以10为底的指数 prin","lvl0":"printf()输出格式控制","lvl1":["C++"],"lvl2":"摘要","objectID":"4eb1208ff2554c5c833b61e164c2ab9b","tags":null,"url":"/post/printf-%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6/"},{"content":"迭代器类型 辅助函数 本文介绍了STL中的迭代器辅助函数的用法及注意事项，这些迭代器辅助函数包括：begin,end,advance, next (since C++11), prev (since","lvl0":"STL迭代器及辅助函数","lvl1":["STL"],"lvl2":"摘要","objectID":"1e885ca91840ccf0c7a3ccae16c02678","tags":null,"url":"/post/stl%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8F%8A%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/"},{"content":"在C/C++中大括号指明了变量的作用域，在大括号内声明的局部变量其作用域自变量声明始，到大括号之后终结。我们应该善用它，使我们的程序更加清晰","lvl0":"作用域与{}","lvl1":["C++"],"lvl2":"摘要","objectID":"32d583da162d58ffaaf7bdc263ba127b","tags":null,"url":"/post/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E/"},{"content":"数据类型 数据类型特别是int相关的类型在不同位数机器的平台下长度不同。C99标准并不规定具体数据类型的长度大小，只规定级别。作下比较： 16位","lvl0":"int32_t,int64_t","lvl1":["C++"],"lvl2":"摘要","objectID":"3bb36f5a67d489f42ea1ffcfa1acefd1","tags":null,"url":"/post/int32-t-int64-t/"},{"content":"1、字符集与字符编码 字符是各种文字和符号的总称，包括各个国家文字、标点符号、图形符号、数字等。字符集是多个字符的集合，字符集种类较多，每个字","lvl0":"字符集和编码","lvl1":["杂谈"],"lvl2":"摘要","objectID":"fb0ccf358e8d04fca4ce1233063a9b75","tags":null,"url":"/post/%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E7%BC%96%E7%A0%81/"},{"content":"const的用法 修饰变量 修饰常量 与变量不同，有const修饰的量是常量，常量的值不可改变，在定义的时候必须初始化，使用未初始化的常量是错误的","lvl0":"解析“const”","lvl1":["C++"],"lvl2":"摘要","objectID":"b03a87b997d9b7cbe89d89af2d2ae833","tags":["键字"],"url":"/post/%E8%A7%A3%E6%9E%90const/"},{"content":"所谓的C++万能头文件，缺点是编译时间慢，优点无需多说。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026lt;bits/stdc++.h\u0026gt","lvl0":"C++的万能头文件","lvl1":["C++"],"lvl2":"摘要","objectID":"d414c3ec7dd90b7952401c09b2fa15f5","tags":null,"url":"/post/c-%E7%9A%84%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6/"},{"content":"基本解释 extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外e","lvl0":"解析“extern”","lvl1":["C++"],"lvl2":"摘要","objectID":"8af79ecb406d9c70b244ec168697d634","tags":["键字"],"url":"/post/%E8%A7%A3%E6%9E%90extern/"},{"content":"定义 有些时候我们可以声明一些类但是并不去定义它，当然这个类的作用也很有限了。 比如class foo; 声明一个foo类，这个声明，有时候也叫做前向声明","lvl0":"前向声明","lvl1":["C++"],"lvl2":"摘要","objectID":"e51dccf5c0356bc3ffbbc5f70c425bea","tags":null,"url":"/post/%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E/"},{"content":"友元函数的简单介绍 为什么要使用友元函数 在实现类之间数据共享时，减少系统开销，提高效率。如果类A中的函数要访问类B中的成员（例如：智能指针类的","lvl0":"友元浅析","lvl1":["C++"],"lvl2":"摘要","objectID":"0b9ab978d578625ac22191f3072cd68b","tags":null,"url":"/post/%E5%8F%8B%E5%85%83%E6%B5%85%E6%9E%90/"},{"content":"成员的访问权限 public访问权限 一个类的public成员变量、成员函数，可以通过类的成员函数、类的实例变量进行访问 \u0026lt;实际上，类的成员","lvl0":"访问控制与继承","lvl1":["C++"],"lvl2":"摘要","objectID":"5c8a19c9f48b2aa9280148cf18006eb8","tags":null,"url":"/post/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/"},{"content":"（1） 编译错误： 就是编译器无法进行继续编译的错误，最基本的就是语法错误了，比如语句后面少了；或者 } 不匹配之类的，选择题一般是这样。编译错误可","lvl0":"编译错误和运行错误的区别","lvl1":["C++"],"lvl2":"摘要","objectID":"3025e9ffb3a69407072b4274129c61d3","tags":["字节对齐"],"url":"/post/%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E5%92%8C%E8%BF%90%E8%A1%8C%E9%94%99%E8%AF%AF%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"content":"有些成员变量的数据类型比较特别，它们的初始化方式也和普通数据类型的成员变量有所不同。这些特殊的类型的成员变量包括： a.引用 b.常量 c.静态 d","lvl0":"类内特殊成员变量的初始化","lvl1":["C++"],"lvl2":"摘要","objectID":"8aba898d358468793fd37164fe37a9de","tags":null,"url":"/post/%E7%B1%BB%E5%86%85%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"content":"函数指针 函数指针：是指向函数的指针变量，在C编译时，每一个函数都有一个入口地址，那么这个指向这个函数的函数指针便指向这个地址。 函数指针的用途","lvl0":"仿函数和函数指针","lvl1":["STL"],"lvl2":"摘要","objectID":"cdb463bb1bfe6d92d3fb239de9179ea7","tags":["仿函数"],"url":"/post/%E4%BB%BF%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"},{"content":"本质区别 Debug 和 Release 并没有本质的区别，他们只是VC预定义提供的两组编译选项的集合，编译器只是按照预定的选项行动。如果我们愿意，我们完全可以把Deb","lvl0":"Visual Studio中debug和release版本的区别","lvl1":["C++"],"lvl2":"摘要","objectID":"5da51088b51defa9952576ae7d2b64b2","tags":["编译"],"url":"/post/visual-studio%E4%B8%ADdebug%E5%92%8Crelease%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"content":"临时对象 C++中有这样一种对象：它在代码中看不到，但是确实存在。它就是临时对象—由编译器定义的一个没有命名的非堆对象（non-heap obj","lvl0":"C++中临时对象及返回值优化","lvl1":["C++"],"lvl2":"摘要","objectID":"c235693783864137c70048da6b98c847","tags":null,"url":"/post/c-%E4%B8%AD%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/"},{"content":"含义 return 表示从被调函数返回到主调函数继续执行，返回时可附带一个返回值，返回值可以是一个常量，变量，或是表达式。 作用 结束正在运行的函数，并返回函","lvl0":"return语句的用法","lvl1":["C++"],"lvl2":"摘要","objectID":"d8aabb6283c7ee385bee89b088fba48f","tags":null,"url":"/post/return%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%94%A8%E6%B3%95/"},{"content":"调用函数的过程 栈空间是从高地址向低地址增长的。所以压栈即表示栈顶指针变小，而出栈则相反。 函数调用者维护了一个栈空间（stack），拥有栈底指","lvl0":"C++函数返回值问题","lvl1":["C++"],"lvl2":"摘要","objectID":"9df193b9b091640125e95e4e09afb6ab","tags":null,"url":"/post/c-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E9%97%AE%E9%A2%98/"},{"content":"#构造函数 default (1) string(); copy (2) string (const string\u0026amp; str); substring (3) string (const string\u0026amp; str, size_t pos, size_t len = npos); from c-string (4) string (const char* s); from buffer (5) string (const char* s, size_t n); fill (6) string (size_t n, char c); range (7) template \u0026lt;class InputIterator\u0026gt; string (InputIterator first, InputIterator last); initializer list (8) string (initializer_list\u0026lt;char\u0026gt; il); move (9) string (string\u0026amp;\u0026amp; str)","lvl0":"string操作总结","lvl1":["STL"],"lvl2":"摘要","objectID":"0934e29f6ce6f981b548b0d065f360f0","tags":null,"url":"/post/string%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"},{"content":"基本思想是： 在程序中生成字符串self; 加入把self改写成程序自身的算法编码; 输出self字符串。 1 2 3 #include \u0026lt;stdio.h\u0026gt;char* recurse=\u0026#34;#include \u0026lt;stdio.h\u0026gt;%cchar* recurse=%c%s%c;%cint main(){printf(recurse,10,34,recurse,34,10,10);}%c\u0026#34;; int main(){printf(recurse,10,34,recurse,34,10,10);} 解析： 引号里面的内","lvl0":"如何打印自身代码","lvl1":["C++"],"lvl2":"摘要","objectID":"fde11e81a54fb81ca85181cf7e79c11d","tags":null,"url":"/post/%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B0%E8%87%AA%E8%BA%AB%E4%BB%A3%E7%A0%81/"},{"content":"在对一个数进行位运算的时候，是在这个数的补码上进行的，对于补码我们知道，正数的补码是原码，负数的补码为原码除了最高位的符号位，取反，然后加1","lvl0":"位运算求绝对值","lvl1":["解题报告"],"lvl2":"摘要","objectID":"2a602ac5244c30c605c64258ea397539","tags":["it Manipulation"],"url":"/post/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%B1%82%E7%BB%9D%E5%AF%B9%E5%80%BC/"},{"content":"预处理 预处理也称为预编译，它为编译做预备工作，主要进行代码文本的替换工作，用于处理#开头的指令，其中预处理器产生编译器的输出。 经过预处理器处","lvl0":"define详解","lvl1":["C++"],"lvl2":"摘要","objectID":"0d5d150cfe02515c7b75e3826dca4b90","tags":null,"url":"/post/define%E8%AF%A6%E8%A7%A3/"},{"content":"回调函数的定义 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数","lvl0":"回调函数及其实现","lvl1":["C++"],"lvl2":"摘要","objectID":"a5b680f8ecbc101c21b37bca294802ab","tags":["回调函数"],"url":"/post/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"},{"content":"区别 strlen执行的是一个计数器的工作，它从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，直到碰到","lvl0":"区别sizeof()和strlen()","lvl1":["C++"],"lvl2":"摘要","objectID":"e75aaba783961cadcd32fd1934a17094","tags":null,"url":"/post/%E5%8C%BA%E5%88%ABsizeof-%E5%92%8Cstrlen/"},{"content":"参考：http://www.cnblogs.com/longlybits/articles/2385343.html 结构体中的字节对齐 在用s","lvl0":"结构体字节对齐详解","lvl1":["C++"],"lvl2":"摘要","objectID":"6467255f51c7e16dcc7cf6fa549b91ea","tags":null,"url":"/post/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E8%AF%A6%E8%A7%A3/"},{"content":"地址的类型转换 功能 对变量的值进行强制类型转换，是把值按照另外一种类型进行存储后读取，变量在内存中的存储形式发生变化. 对变量的地址进行强制类型","lvl0":"地址的类型转换和数学计算","lvl1":["C++"],"lvl2":"摘要","objectID":"c0bda8f8cfed1accdac1a5c67d185ca8","tags":null,"url":"/post/%E5%9C%B0%E5%9D%80%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97/"},{"content":"程序中内存分配方式 (1) 正文段 (.text) 程序代码就存储在text 段，这是由C P U执行的机器指令部分。通常，正文段是可共享的，所以即使是经常执行的程序(如","lvl0":"C++程序内存分配形式","lvl1":["C++"],"lvl2":"摘要","objectID":"a4adbfa1f894cbc6ec3a8ff9a41c949b","tags":["内存分配"],"url":"/post/c-%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%BD%A2%E5%BC%8F/"}]