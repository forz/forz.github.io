<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>解题报告 on Forz Blog</title>
    <link>/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</link>
    <description>Recent content in 解题报告 on Forz Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 14 Sep 2017 21:04:37 +0000</lastBuildDate><atom:link href="/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>查找二叉树的中心节点</title>
      <link>/post/%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BF%83%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 14 Sep 2017 21:04:37 +0000</pubDate>
      
      <guid>/post/%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BF%83%E8%8A%82%E7%82%B9/</guid>
      <description>LeetCode 310. Minimum Height Trees For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels. Format The graph contains n nodes which</description>
    </item>
    
    <item>
      <title>不用sizeof(),如何判断操作系统是16位还是32位</title>
      <link>/post/%E4%B8%8D%E7%94%A8sizeof-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF16%E4%BD%8D%E8%BF%98%E6%98%AF32%E4%BD%8D/</link>
      <pubDate>Tue, 05 Sep 2017 14:21:05 +0000</pubDate>
      
      <guid>/post/%E4%B8%8D%E7%94%A8sizeof-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF16%E4%BD%8D%E8%BF%98%E6%98%AF32%E4%BD%8D/</guid>
      <description>对0值取反，不同位数下的0值取反，其结果不一样。例如，在32位机器下，按位取反运算，结果为1111111111111111111111111</description>
    </item>
    
    <item>
      <title>利用位运算计算数的绝对值</title>
      <link>/post/%E5%88%A9%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E8%AE%A1%E7%AE%97%E6%95%B0%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%80%BC/</link>
      <pubDate>Tue, 05 Sep 2017 12:53:07 +0000</pubDate>
      
      <guid>/post/%E5%88%A9%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E8%AE%A1%E7%AE%97%E6%95%B0%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%80%BC/</guid>
      <description></description>
    </item>
    
    <item>
      <title>实现位运算求两个数的平均值</title>
      <link>/post/%E5%AE%9E%E7%8E%B0%E4%BD%8D%E8%BF%90%E7%AE%97%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC/</link>
      <pubDate>Tue, 05 Sep 2017 12:46:38 +0000</pubDate>
      
      <guid>/post/%E5%AE%9E%E7%8E%B0%E4%BD%8D%E8%BF%90%E7%AE%97%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC/</guid>
      <description></description>
    </item>
    
    <item>
      <title>如何判断一个变量是有符号数还是无符号数</title>
      <link>/post/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%98%AF%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E8%BF%98%E6%98%AF%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0/</link>
      <pubDate>Tue, 05 Sep 2017 10:57:25 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%98%AF%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E8%BF%98%E6%98%AF%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0/</guid>
      <description>通过改变符号位判断。把A进行一个位运算，将最高位置1,判断是否大于0。 程序示例如下： 1 2 3 4 5 6 7 8 9 10 11 #include &amp;lt;stdio.h&amp;gt;int main() { unsigned A = 10; A = A|(1&amp;lt;&amp;lt;31); if(A &amp;gt; 0) pri</description>
    </item>
    
    <item>
      <title>画匠问题</title>
      <link>/post/%E7%94%BB%E5%8C%A0%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 03 Sep 2017 21:43:56 +0000</pubDate>
      
      <guid>/post/%E7%94%BB%E5%8C%A0%E9%97%AE%E9%A2%98/</guid>
      <description>题目: 给定一个整型数组arr,数组中的每个值都为正数，表示完成一幅画作需要的时间，再给定一个整数num表示画匠的数量，每个画匠只能画连在一起</description>
    </item>
    
    <item>
      <title>丢棋子问题</title>
      <link>/post/%E4%B8%A2%E6%A3%8B%E5%AD%90%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 03 Sep 2017 19:11:19 +0000</pubDate>
      
      <guid>/post/%E4%B8%A2%E6%A3%8B%E5%AD%90%E9%97%AE%E9%A2%98/</guid>
      <description>题目: 举例: 解析: map[i][j]的意义为i个棋子扔j次最多搞定的楼数。 0 1 2 3 4 5 6 7 8 9 10 -&amp;gt;次数 1 0 1 2 3 4 5 6 7 8 9 10 2 0 1</description>
    </item>
    
    <item>
      <title>两个排序数组中的查找问题</title>
      <link>/post/%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 03 Sep 2017 18:26:54 +0000</pubDate>
      
      <guid>/post/%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 4. Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 解</description>
    </item>
    
    <item>
      <title>一种消息接收并打印的结构设计</title>
      <link>/post/%E4%B8%80%E7%A7%8D%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%E5%B9%B6%E6%89%93%E5%8D%B0%E7%9A%84%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Sun, 03 Sep 2017 18:07:34 +0000</pubDate>
      
      <guid>/post/%E4%B8%80%E7%A7%8D%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%E5%B9%B6%E6%89%93%E5%8D%B0%E7%9A%84%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</guid>
      <description>题目: 要求: 消息流最终会吐出全部的1〜N当然最终也会打印完所有的要求接收和打印1~N的整个过程,时间复杂度为O(N)的。 解析: 1 2 3 4 5 6 7</description>
    </item>
    
    <item>
      <title>从N个数中等概率打印M个数</title>
      <link>/post/%E4%BB%8En%E4%B8%AA%E6%95%B0%E4%B8%AD%E7%AD%89%E6%A6%82%E7%8E%87%E6%89%93%E5%8D%B0m%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Sun, 03 Sep 2017 17:02:02 +0000</pubDate>
      
      <guid>/post/%E4%BB%8En%E4%B8%AA%E6%95%B0%E4%B8%AD%E7%AD%89%E6%A6%82%E7%8E%87%E6%89%93%E5%8D%B0m%E4%B8%AA%E6%95%B0/</guid>
      <description>题目: 给定一个长度为N且没有重复元素的数组air和一个整数n,实现函数等概率随机打印arr中的M个数。 要求: 相同的数不要重复打印。 时间复杂度</description>
    </item>
    
    <item>
      <title>正整数数组的最小不可组成和</title>
      <link>/post/%E6%AD%A3%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E4%B8%8D%E5%8F%AF%E7%BB%84%E6%88%90%E5%92%8C/</link>
      <pubDate>Sun, 03 Sep 2017 16:30:08 +0000</pubDate>
      
      <guid>/post/%E6%AD%A3%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E4%B8%8D%E5%8F%AF%E7%BB%84%E6%88%90%E5%92%8C/</guid>
      <description>题目: 给定一个正数数组arr,其中所有的值都为整数，以下是最小不可组成和的概念： 把arr每个子集内的所有元素加起来会出现很多值，其中最小的记</description>
    </item>
    
    <item>
      <title>路径数组变为统计数组</title>
      <link>/post/%E8%B7%AF%E5%BE%84%E6%95%B0%E7%BB%84%E5%8F%98%E4%B8%BA%E7%BB%9F%E8%AE%A1%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sun, 03 Sep 2017 16:08:55 +0000</pubDate>
      
      <guid>/post/%E8%B7%AF%E5%BE%84%E6%95%B0%E7%BB%84%E5%8F%98%E4%B8%BA%E7%BB%9F%E8%AE%A1%E6%95%B0%E7%BB%84/</guid>
      <description>题目: 要求: 如果paths长度为N，请达到时间复杂度为O(N),额外空间复杂度为0(1)。 解析: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22</description>
    </item>
    
    <item>
      <title>调整[0,x)区间上的数出现的频率</title>
      <link>/post/%E8%B0%83%E6%95%B40x%E5%8C%BA%E9%97%B4%E4%B8%8A%E7%9A%84%E6%95%B0%E5%87%BA%E7%8E%B0%E7%9A%84%E9%A2%91%E7%8E%87/</link>
      <pubDate>Sun, 03 Sep 2017 14:47:00 +0000</pubDate>
      
      <guid>/post/%E8%B0%83%E6%95%B40x%E5%8C%BA%E9%97%B4%E4%B8%8A%E7%9A%84%E6%95%B0%E5%87%BA%E7%8E%B0%E7%9A%84%E9%A2%91%E7%8E%87/</guid>
      <description>题目: 解析: 1 2 3 4 5 6 7 8 9 10 public static double randXPowerK(int k) { if (k &amp;lt; 1) { return 0; } double res = -1; for (int i = 0; i != k; i++) { res = Math.max(res, Math.random()); } return res; }</description>
    </item>
    
    <item>
      <title>最大的leftMax与rightMax之差的绝对值</title>
      <link>/post/%E6%9C%80%E5%A4%A7%E7%9A%84leftmax%E4%B8%8Erightmax%E4%B9%8B%E5%B7%AE%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%80%BC/</link>
      <pubDate>Sun, 03 Sep 2017 14:36:45 +0000</pubDate>
      
      <guid>/post/%E6%9C%80%E5%A4%A7%E7%9A%84leftmax%E4%B8%8Erightmax%E4%B9%8B%E5%B7%AE%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%80%BC/</guid>
      <description>题目: 给定一个长度为N的整型数组arr,可以划分成左右两个部分，左部分为arr[O..K],右部分为arr[K+1..N-1], K可以取值的</description>
    </item>
    
    <item>
      <title>设计有setAll功能的哈希表</title>
      <link>/post/%E8%AE%BE%E8%AE%A1%E6%9C%89setall%E5%8A%9F%E8%83%BD%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8/</link>
      <pubDate>Sun, 03 Sep 2017 14:09:29 +0000</pubDate>
      
      <guid>/post/%E8%AE%BE%E8%AE%A1%E6%9C%89setall%E5%8A%9F%E8%83%BD%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8/</guid>
      <description>题目: 哈希表常见的三个操作是put、get和containsKey,而且这三个操作的时间复杂度为O(1)。现在想加一个setAll功能，就是</description>
    </item>
    
    <item>
      <title>蓄水池算法</title>
      <link>/post/%E8%93%84%E6%B0%B4%E6%B1%A0%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 03 Sep 2017 13:18:55 +0000</pubDate>
      
      <guid>/post/%E8%93%84%E6%B0%B4%E6%B1%A0%E7%AE%97%E6%B3%95/</guid>
      <description>算法简介 在不知道文件总行数的情况下，如何从文件中随机的抽取一行？ 首先想到的是我们做过类似的题目吗?当然，在知道文件行数的情况下，我们可以很容</description>
    </item>
    
    <item>
      <title>折纸问题</title>
      <link>/post/%E6%8A%98%E7%BA%B8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 03 Sep 2017 12:59:00 +0000</pubDate>
      
      <guid>/post/%E6%8A%98%E7%BA%B8%E9%97%AE%E9%A2%98/</guid>
      <description>题目: 请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折i次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从</description>
    </item>
    
    <item>
      <title>判断点是否在图形内部</title>
      <link>/post/%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%9B%BE%E5%BD%A2%E5%86%85%E9%83%A8/</link>
      <pubDate>Sat, 02 Sep 2017 16:48:56 +0000</pubDate>
      
      <guid>/post/%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%9B%BE%E5%BD%A2%E5%86%85%E9%83%A8/</guid>
      <description>判断一个点是否在矩形内部 题目: 在二维坐标系中，所有的值都是double类型那么一个矩形可以由4个点来代表:（x1,y1)为最左的点、（x2,</description>
    </item>
    
    <item>
      <title>阶乘相关问题</title>
      <link>/post/%E9%98%B6%E4%B9%98%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 02 Sep 2017 16:20:21 +0000</pubDate>
      
      <guid>/post/%E9%98%B6%E4%B9%98%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 172. Factorial Trailing Zeroes Given an integer n, return the number of trailing zeroes in n!. Note: Your solution should be in logarithmic time complexity. 解析： 这个问题很简单。 因为所有的尾随0来自因子5 2。 计算包含的2和5组成的pair的个数</description>
    </item>
    
    <item>
      <title>从5随机到7随机及其扩展</title>
      <link>/post/%E4%BB%8E5%E9%9A%8F%E6%9C%BA%E5%88%B07%E9%9A%8F%E6%9C%BA%E5%8F%8A%E5%85%B6%E6%89%A9%E5%B1%95/</link>
      <pubDate>Sat, 02 Sep 2017 12:31:15 +0000</pubDate>
      
      <guid>/post/%E4%BB%8E5%E9%9A%8F%E6%9C%BA%E5%88%B07%E9%9A%8F%E6%9C%BA%E5%8F%8A%E5%85%B6%E6%89%A9%E5%B1%95/</guid>
      <description>题目一 给定一个等概率随机产生1〜5的随机函数rand1To5如下： public int randlTo5() { return (int) (Math.random() * 5) + 1; } 除此之外，不能使用任何额外的随机机制，请用rand</description>
    </item>
    
    <item>
      <title>数组中未出现的最小正整数</title>
      <link>/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%AA%E5%87%BA%E7%8E%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0/</link>
      <pubDate>Sat, 02 Sep 2017 11:57:54 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%AA%E5%87%BA%E7%8E%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0/</guid>
      <description>题目: 给定一个无序整型数组arr,找到数组中未出现的最小正整数。 解析: 1 2 3 4 5 6 7 8 9 10 11 12 13 public static int missNum(int[] arr) { int l = 0; int r = arr.length; while (l &amp;lt; r) { if (arr[l] ==</description>
    </item>
    
    <item>
      <title>打印N个数组整体最大的Top K</title>
      <link>/post/%E6%89%93%E5%8D%B0n%E4%B8%AA%E6%95%B0%E7%BB%84%E6%95%B4%E4%BD%93%E6%9C%80%E5%A4%A7%E7%9A%84top-k/</link>
      <pubDate>Fri, 01 Sep 2017 23:54:58 +0000</pubDate>
      
      <guid>/post/%E6%89%93%E5%8D%B0n%E4%B8%AA%E6%95%B0%E7%BB%84%E6%95%B4%E4%BD%93%E6%9C%80%E5%A4%A7%E7%9A%84top-k/</guid>
      <description>题目: 有N个长度不一的数组，所有的数组都是有序的，请从大到小打印这N个数组整体最大的前K个数。 例如，输入含有N行元素的二维数组可以代表N个一</description>
    </item>
    
    <item>
      <title>在数组中找到一个局部最小的位置</title>
      <link>/post/%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E5%B1%80%E9%83%A8%E6%9C%80%E5%B0%8F%E7%9A%84%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Fri, 01 Sep 2017 23:36:04 +0000</pubDate>
      
      <guid>/post/%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E5%B1%80%E9%83%A8%E6%9C%80%E5%B0%8F%E7%9A%84%E4%BD%8D%E7%BD%AE/</guid>
      <description>题目: 解析: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public static int getLessIndex(int[] arr) { if (arr == null || arr.length == 0) { return -1; // no exist } if (arr.length == 1 || arr[0] &amp;lt; arr[1]) { return 0; } if (arr[arr.length - 1] &amp;lt; arr[arr.length</description>
    </item>
    
    <item>
      <title>不包含本位置值的累乘数组</title>
      <link>/post/%E4%B8%8D%E5%8C%85%E5%90%AB%E6%9C%AC%E4%BD%8D%E7%BD%AE%E5%80%BC%E7%9A%84%E7%B4%AF%E4%B9%98%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 01 Sep 2017 23:07:27 +0000</pubDate>
      
      <guid>/post/%E4%B8%8D%E5%8C%85%E5%90%AB%E6%9C%AC%E4%BD%8D%E7%BD%AE%E5%80%BC%E7%9A%84%E7%B4%AF%E4%B9%98%E6%95%B0%E7%BB%84/</guid>
      <description>LeetCode 238. Product of Array Except Self Given an array of n integers where n &amp;gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Solve it without division and in O(n). For example, given [1,2,3,4], return [24,12,8,6]. Follow up: Could you solve it with constant space complexity? (Note: The output array does not count as extra</description>
    </item>
    
    <item>
      <title>下标与数值相关联的排序</title>
      <link>/post/%E4%B8%8B%E6%A0%87%E4%B8%8E%E6%95%B0%E5%80%BC%E7%9B%B8%E5%85%B3%E8%81%94%E7%9A%84%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Fri, 01 Sep 2017 22:37:16 +0000</pubDate>
      
      <guid>/post/%E4%B8%8B%E6%A0%87%E4%B8%8E%E6%95%B0%E5%80%BC%E7%9B%B8%E5%85%B3%E8%81%94%E7%9A%84%E6%8E%92%E5%BA%8F/</guid>
      <description>题目: 给定一个长度为N的整型数组arr,其中有N个互不相等的自然数1〜N,请实现arr的排序，但是不要把下标0〜N-1位置上的数通过直接赋值</description>
    </item>
    
    <item>
      <title>计算数组的小和</title>
      <link>/post/%E8%AE%A1%E7%AE%97%E6%95%B0%E7%BB%84%E7%9A%84%E5%B0%8F%E5%92%8C/</link>
      <pubDate>Fri, 01 Sep 2017 22:07:01 +0000</pubDate>
      
      <guid>/post/%E8%AE%A1%E7%AE%97%E6%95%B0%E7%BB%84%E7%9A%84%E5%B0%8F%E5%92%8C/</guid>
      <description>题目: 解析: 下面介绍一种时间复杂度为O(NlogN)、额外空间复杂度为O(N)的方法，这是一种在归并排序的过程中，利用组间在进行合并时产生小</description>
    </item>
    
    <item>
      <title>未排序数组中累加和为定值的最长子数组</title>
      <link>/post/%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 28 Aug 2017 16:50:52 +0000</pubDate>
      
      <guid>/post/%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>未排序正数数组中累加和为给定值的最长子数组长度 题目: 给定一个数组arr,该数组无序，但每个值均为正数，再给定一个正数k,求arr的所有子数组</description>
    </item>
    
    <item>
      <title>最长的可整合子数组的长度</title>
      <link>/post/%E6%9C%80%E9%95%BF%E7%9A%84%E5%8F%AF%E6%95%B4%E5%90%88%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Mon, 28 Aug 2017 15:16:49 +0000</pubDate>
      
      <guid>/post/%E6%9C%80%E9%95%BF%E7%9A%84%E5%8F%AF%E6%95%B4%E5%90%88%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6/</guid>
      <description>题目: 先给出可整合数组的定义。如果一个数组在排序之后，每相邻两个数差的绝对值都为1，则该数组为可整合数组。例如，[5,3,4,6,2]排序之</description>
    </item>
    
    <item>
      <title>需要排序的最短子数组长度</title>
      <link>/post/%E9%9C%80%E8%A6%81%E6%8E%92%E5%BA%8F%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Mon, 28 Aug 2017 14:16:17 +0000</pubDate>
      
      <guid>/post/%E9%9C%80%E8%A6%81%E6%8E%92%E5%BA%8F%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6/</guid>
      <description>题目: 给定一个无序数组air,求出需要排序的最短子数组长度。 例如：arr = [1，5, 3，4，2, 6，7]返回4，因为只有[5，3, 4，2]需</description>
    </item>
    
    <item>
      <title>找到无序数组中的第k个数</title>
      <link>/post/%E6%89%BE%E5%88%B0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Sun, 27 Aug 2017 20:16:25 +0000</pubDate>
      
      <guid>/post/%E6%89%BE%E5%88%B0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%95%B0/</guid>
      <description>LeetCode 215. Kth Largest Element in an Array Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. For example, Given [3,2,1,5,6,4] and k = 2, return 5. Note: You may assume k is always valid, 1 ≤ k ≤ array’s length. 解析：求第K</description>
    </item>
    
    <item>
      <title>“之”字形打印矩阵</title>
      <link>/post/%E4%B9%8B%E5%AD%97%E5%BD%A2%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Sun, 27 Aug 2017 20:04:40 +0000</pubDate>
      
      <guid>/post/%E4%B9%8B%E5%AD%97%E5%BD%A2%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</guid>
      <description>题目: 解析: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public static void printMatrixZigZag(int[][] matrix) { int tR = 0; int tC = 0; int dR = 0; int dC = 0; int endR = matrix.length - 1; int endC = matrix[0].length</description>
    </item>
    
    <item>
      <title>汉明距离</title>
      <link>/post/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</link>
      <pubDate>Sun, 27 Aug 2017 19:49:03 +0000</pubDate>
      
      <guid>/post/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</guid>
      <description>LeetCode 461. Hamming Distance The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. 解析：利用异或来求出不同的位，然后取出每一个1. 1 2 3 4 5 6 7 8 9 10 11 class Solution {</description>
    </item>
    
    <item>
      <title>只用位运算不用算术运算实现整数的加减乘除运算</title>
      <link>/post/%E5%8F%AA%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B8%8D%E7%94%A8%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E6%95%B4%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97/</link>
      <pubDate>Sun, 27 Aug 2017 19:01:06 +0000</pubDate>
      
      <guid>/post/%E5%8F%AA%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B8%8D%E7%94%A8%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E6%95%B4%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97/</guid>
      <description>题目: 给定两个32位整数a和b,可正、可负、可0。不能使用算术运算符，分别实现a和b的加减乘除运算。如果给定的a和b执行加减乘除的某些结果本</description>
    </item>
    
    <item>
      <title>不用任何比较判断找出两个数中较大的数</title>
      <link>/post/%E4%B8%8D%E7%94%A8%E4%BB%BB%E4%BD%95%E6%AF%94%E8%BE%83%E5%88%A4%E6%96%AD%E6%89%BE%E5%87%BA%E4%B8%A4%E4%B8%AA%E6%95%B0%E4%B8%AD%E8%BE%83%E5%A4%A7%E7%9A%84%E6%95%B0/</link>
      <pubDate>Sun, 27 Aug 2017 18:35:10 +0000</pubDate>
      
      <guid>/post/%E4%B8%8D%E7%94%A8%E4%BB%BB%E4%BD%95%E6%AF%94%E8%BE%83%E5%88%A4%E6%96%AD%E6%89%BE%E5%87%BA%E4%B8%A4%E4%B8%AA%E6%95%B0%E4%B8%AD%E8%BE%83%E5%A4%A7%E7%9A%84%E6%95%B0/</guid>
      <description>题目: 给定两个32位整数a和b，返回a和b中较大的。不用任何比较判断。包括等于号. 解析: 第一种方法。得到a-b的值的符号，就可以知道是返回a</description>
    </item>
    
    <item>
      <title>不用额外变量交换两个整数的值</title>
      <link>/post/%E4%B8%8D%E7%94%A8%E9%A2%9D%E5%A4%96%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E5%80%BC/</link>
      <pubDate>Sun, 27 Aug 2017 18:16:47 +0000</pubDate>
      
      <guid>/post/%E4%B8%8D%E7%94%A8%E9%A2%9D%E5%A4%96%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E5%80%BC/</guid>
      <description>题目: 如何不用任何额外变量交换两个整数的值？ 解析: 如果给定整数a和b,用以下三行代码即可交换a和b的值。 a = a ^ b; b = a ^ b; a = a ^ b; 如何理</description>
    </item>
    
    <item>
      <title>找到被指的新类型字符</title>
      <link>/post/%E6%89%BE%E5%88%B0%E8%A2%AB%E6%8C%87%E7%9A%84%E6%96%B0%E7%B1%BB%E5%9E%8B%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Sun, 27 Aug 2017 00:41:28 +0000</pubDate>
      
      <guid>/post/%E6%89%BE%E5%88%B0%E8%A2%AB%E6%8C%87%E7%9A%84%E6%96%B0%E7%B1%BB%E5%9E%8B%E5%AD%97%E7%AC%A6/</guid>
      <description>题目: 新类型字符的定义如下： 新类型字符是长度为1或者2的字符串。 表现形式可以仅是小写字母,例如”e&amp;quot;;也可以是大写字母+小写字母,</description>
    </item>
    
    <item>
      <title>拼接字符串产生字典顺序最小的字符串</title>
      <link>/post/%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A7%E7%94%9F%E5%AD%97%E5%85%B8%E9%A1%BA%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sat, 26 Aug 2017 23:22:11 +0000</pubDate>
      
      <guid>/post/%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A7%E7%94%9F%E5%AD%97%E5%85%B8%E9%A1%BA%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>LeetCode 179. Largest Number Given a list of non negative integers, arrange them such that they form the largest number. For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330. Note: The result may be very large, so you need to return a string instead of an integer. 解析： 把所有数全部转换成字符串，方便</description>
    </item>
    
    <item>
      <title>字符串匹配</title>
      <link>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Sat, 26 Aug 2017 16:09:41 +0000</pubDate>
      
      <guid>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</guid>
      <description>LeetCode 459. Repeated Substring Pattern 给定一个非空字符串检查，如果它可以通过取其子字符串并将子字符串的多个副本附加在一起构造。 您可以假定给定字符串仅由小写英文字母组成，</description>
    </item>
    
    <item>
      <title>构造回文字符串</title>
      <link>/post/%E6%9E%84%E9%80%A0%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sat, 26 Aug 2017 15:56:04 +0000</pubDate>
      
      <guid>/post/%E6%9E%84%E9%80%A0%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>添加最少字符使字符串整体都是回文字符串 题目: 给定一个字符串str,如果可以在str的任意位置添加字符，请返回在添加字符最少的 情况下，让str</description>
    </item>
    
    <item>
      <title>数组中两个字符串的最小距离</title>
      <link>/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/</link>
      <pubDate>Sat, 26 Aug 2017 14:12:18 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/</guid>
      <description>题目: 给定一个字符串数组strs，再给定两个字符串str1和str2,返回在strs中str1与str2的 最小距离，如果str1或str2为</description>
    </item>
    
    <item>
      <title>字符串的调整与替换</title>
      <link>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%B0%83%E6%95%B4%E4%B8%8E%E6%9B%BF%E6%8D%A2/</link>
      <pubDate>Fri, 25 Aug 2017 14:18:57 +0000</pubDate>
      
      <guid>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%B0%83%E6%95%B4%E4%B8%8E%E6%9B%BF%E6%8D%A2/</guid>
      <description>字符串的替换 题目: 给定一个字符类型的数组chas[], chas右半区全是空字符，左半区不含有空字符。现 在想将左半区中所有的空格字符替换成&amp;q</description>
    </item>
    
    <item>
      <title>在有序但含有空的数组中查找字符串</title>
      <link>/post/%E5%9C%A8%E6%9C%89%E5%BA%8F%E4%BD%86%E5%90%AB%E6%9C%89%E7%A9%BA%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Thu, 24 Aug 2017 23:09:25 +0000</pubDate>
      
      <guid>/post/%E5%9C%A8%E6%9C%89%E5%BA%8F%E4%BD%86%E5%90%AB%E6%9C%89%E7%A9%BA%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目: 给定一个字符串数组strs[],在sirs中有些位置为null,但在不为null的位置上，其字符串是按照字典顺序由小到大依次出现的。再</description>
    </item>
    
    <item>
      <title>替换字符串中连续出现的指定字符串</title>
      <link>/post/%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E8%BF%9E%E7%BB%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Thu, 24 Aug 2017 17:24:37 +0000</pubDate>
      
      <guid>/post/%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E8%BF%9E%E7%BB%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目: 给定三个字符串str、from和to,把str中所有from的子串全部替换成to字符串，对 连续出现from的部分要求只替换成一个to字</description>
    </item>
    
    <item>
      <title>去掉字符串中连续出现k个0的子串</title>
      <link>/post/%E5%8E%BB%E6%8E%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E8%BF%9E%E7%BB%AD%E5%87%BA%E7%8E%B0k%E4%B8%AA0%E7%9A%84%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Thu, 24 Aug 2017 15:36:11 +0000</pubDate>
      
      <guid>/post/%E5%8E%BB%E6%8E%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E8%BF%9E%E7%BB%AD%E5%87%BA%E7%8E%B0k%E4%B8%AA0%E7%9A%84%E5%AD%90%E4%B8%B2/</guid>
      <description>题目: 给定一个字符串str和一个整数如果str中正好有连续的yt个•0&amp;rsquo;字符出现时，把k个 连续的&#39;0’字符去除，返回处理后的字符</description>
    </item>
    
    <item>
      <title>字符串中数字子串的求和</title>
      <link>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%95%B0%E5%AD%97%E5%AD%90%E4%B8%B2%E7%9A%84%E6%B1%82%E5%92%8C/</link>
      <pubDate>Thu, 24 Aug 2017 14:00:27 +0000</pubDate>
      
      <guid>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%95%B0%E5%AD%97%E5%AD%90%E4%B8%B2%E7%9A%84%E6%B1%82%E5%92%8C/</guid>
      <description>题目: 给定一个字符串stn求其中全部数字串所代表的数字之和。 忽略小数点字符，例如&amp;quot;A1.3&amp;quot;,其中包含两个数字1和3。 如</description>
    </item>
    
    <item>
      <title>排成一条线的博弈问题</title>
      <link>/post/%E6%8E%92%E6%88%90%E4%B8%80%E6%9D%A1%E7%BA%BF%E7%9A%84%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 23 Aug 2017 21:07:22 +0000</pubDate>
      
      <guid>/post/%E6%8E%92%E6%88%90%E4%B8%80%E6%9D%A1%E7%BA%BF%E7%9A%84%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/</guid>
      <description>LintCode Coins in a Line II 有 n 个不同价值的硬币排成一条线。两个参赛者轮流从左边依次拿走 1 或 2 个硬币，直到没有硬币为止。计算两个人分别拿到的硬币总价值，价值</description>
    </item>
    
    <item>
      <title>公式字符串求值</title>
      <link>/post/%E5%85%AC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B1%82%E5%80%BC/</link>
      <pubDate>Wed, 23 Aug 2017 17:30:52 +0000</pubDate>
      
      <guid>/post/%E5%85%AC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B1%82%E5%80%BC/</guid>
      <description>LeetCode 150. Evaluate Reverse Polish Notation Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Some examples: [&amp;quot;2&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;+&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;*&amp;quot;] -&amp;gt; ((2 + 1) * 3) -&amp;gt; 9 [&amp;quot;4&amp;quot;, &amp;quot;13&amp;quot;, &amp;quot;5&amp;quot;, &amp;quot;/&amp;quot;, &amp;quot;+&amp;quot;] -&amp;gt; (4 + (13 / 5)) -&amp;gt; 6 解析：用栈来模拟运</description>
    </item>
    
    <item>
      <title>字符串切分</title>
      <link>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E5%88%86/</link>
      <pubDate>Wed, 23 Aug 2017 14:46:27 +0000</pubDate>
      
      <guid>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E5%88%86/</guid>
      <description>数字字符串转换为字母组合的种数 给定一个字符串str, str全部由数字字符组成，如果str中某一个或某相邻两个字符组 成的子串值在1〜26之间，</description>
    </item>
    
    <item>
      <title>字符串交错组成</title>
      <link>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A4%E9%94%99%E7%BB%84%E6%88%90/</link>
      <pubDate>Tue, 22 Aug 2017 22:44:02 +0000</pubDate>
      
      <guid>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A4%E9%94%99%E7%BB%84%E6%88%90/</guid>
      <description>LeetCode 97. Interleaving String Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. For example, Given: s1 = “aabcc”, s2 = “dbbca”, When s3 = “aadbbcbcac”, return true. When s3 = “aadbb</description>
    </item>
    
    <item>
      <title>最长公共子序列/子串</title>
      <link>/post/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Tue, 22 Aug 2017 17:42:36 +0000</pubDate>
      
      <guid>/post/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E5%AD%90%E4%B8%B2/</guid>
      <description>最长公共子序列 题目: 给定两个字符串str1和str2,返回两个字符串的最长公共子序列。 解析: 如果str1的长度为M，str2的长度为N,生成</description>
    </item>
    
    <item>
      <title>在二叉树中找到一个节点的后继节点</title>
      <link>/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sat, 19 Aug 2017 22:51:16 +0000</pubDate>
      
      <guid>/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9/</guid>
      <description>题目: 现在有一种新的二叉树节点类型如下： public class Node { public int value; public Node left; public Node right; public Node parent; public Node(int data) { this.value = data; } 该结构比普通二叉树节点结构多了一个指向父节点的par</description>
    </item>
    
    <item>
      <title>判断二叉树的类型</title>
      <link>/post/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 19 Aug 2017 22:07:36 +0000</pubDate>
      
      <guid>/post/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%B1%BB%E5%9E%8B/</guid>
      <description>LeetCode 110. Balanced Binary Tree Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 解析：dfs求每个节点的高度，在求高度的同时判断当前</description>
    </item>
    
    <item>
      <title>调整搜索二叉树中两个错误的节点</title>
      <link>/post/%E8%B0%83%E6%95%B4%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sat, 19 Aug 2017 20:13:36 +0000</pubDate>
      
      <guid>/post/%E8%B0%83%E6%95%B4%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>LeetCode 99. Recover Binary Search Tree Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Note: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? 解析： 中序遍历二叉树，出现的节点的值会升序排序，如果有两</description>
    </item>
    
    <item>
      <title>查找二叉树中的搜索二叉树</title>
      <link>/post/%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E5%AD%90%E6%A0%91/</link>
      <pubDate>Fri, 18 Aug 2017 22:03:48 +0000</pubDate>
      
      <guid>/post/%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E5%AD%90%E6%A0%91/</guid>
      <description>查找二叉树中的最大搜索二叉子树 给定一棵二叉树的头节点head,己知其中所有节点的值都不一样，找到含有节点最多 的搜索二叉子树，并返回这棵子树的</description>
    </item>
    
    <item>
      <title>如何较为直观地打印二叉树</title>
      <link>/post/%E5%A6%82%E4%BD%95%E8%BE%83%E4%B8%BA%E7%9B%B4%E8%A7%82%E5%9C%B0%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Fri, 18 Aug 2017 14:16:02 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E8%BE%83%E4%B8%BA%E7%9B%B4%E8%A7%82%E5%9C%B0%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目: 二叉树可以用常规的三种遍历结果来描述其结构，但是不够直观，尤其是二叉树中有 重复值的时候，仅通过三种遍历的结果来构造二叉树的真实结构更是</description>
    </item>
    
    <item>
      <title>打印二叉树的边界节点</title>
      <link>/post/%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BE%B9%E7%95%8C%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 17 Aug 2017 17:32:32 +0000</pubDate>
      
      <guid>/post/%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BE%B9%E7%95%8C%E8%8A%82%E7%82%B9/</guid>
      <description>题目 给定一棵二叉树的头节点head,按照如下两种标准分别实现二叉树边界节点的逆时针打印。 标准一： 头节点为边界节点。 叶节点为边界节点。 如果节点</description>
    </item>
    
    <item>
      <title>向有序的环形单链表插入新节点</title>
      <link>/post/%E5%90%91%E6%9C%89%E5%BA%8F%E7%9A%84%E7%8E%AF%E5%BD%A2%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%96%B0%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 17 Aug 2017 16:01:21 +0000</pubDate>
      
      <guid>/post/%E5%90%91%E6%9C%89%E5%BA%8F%E7%9A%84%E7%8E%AF%E5%BD%A2%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%96%B0%E8%8A%82%E7%82%B9/</guid>
      <description>题目: 一个环形单链表从头节点head幵始不降序，同时由最后的节点指回头节点。给定这样一个环形单链表的头节点head和一个整数num，请生成节</description>
    </item>
    
    <item>
      <title>删除无序单链表中值重复出现的点</title>
      <link>/post/%E5%88%A0%E9%99%A4%E6%97%A0%E5%BA%8F%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%BC%E9%87%8D%E5%A4%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E7%82%B9/</link>
      <pubDate>Thu, 17 Aug 2017 14:18:44 +0000</pubDate>
      
      <guid>/post/%E5%88%A0%E9%99%A4%E6%97%A0%E5%BA%8F%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%BC%E9%87%8D%E5%A4%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E7%82%B9/</guid>
      <description>删除无序单链表中值重复出现的点 给定一个无序单链表的头节点head,删除其中值重复出现的节点。 例如：1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;</description>
    </item>
    
    <item>
      <title>构造数组的MaxTree</title>
      <link>/post/%E6%9E%84%E9%80%A0%E6%95%B0%E7%BB%84%E7%9A%84maxtree/</link>
      <pubDate>Wed, 16 Aug 2017 18:26:35 +0000</pubDate>
      
      <guid>/post/%E6%9E%84%E9%80%A0%E6%95%B0%E7%BB%84%E7%9A%84maxtree/</guid>
      <description>题目 对于一个没有重复元素的整数数组，请用其中元素构造一棵MaxTree，MaxTree定义为一棵二叉树，其中的节点与数组元素一一对应，同时对</description>
    </item>
    
    <item>
      <title>用一个栈实现另一个栈的排序</title>
      <link>/post/%E7%94%A8%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%88%E7%9A%84%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Wed, 16 Aug 2017 17:45:36 +0000</pubDate>
      
      <guid>/post/%E7%94%A8%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%88%E7%9A%84%E6%8E%92%E5%BA%8F/</guid>
      <description>一个栈中元素的类型为整型，现在想将该栈从顶到底按从大到小的顺序排序，只许申 请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。如</description>
    </item>
    
    <item>
      <title>猫狗队列</title>
      <link>/post/%E7%8C%AB%E7%8B%97%E9%98%9F%E5%88%97/</link>
      <pubDate>Wed, 16 Aug 2017 17:33:03 +0000</pubDate>
      
      <guid>/post/%E7%8C%AB%E7%8B%97%E9%98%9F%E5%88%97/</guid>
      <description>题目: 宠物、狗和猫的类如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Pet { private String type ; public Pet(String type) { this.type = type ; } public String getPetType() { return this.type ; } } public class Dog extends Pet{ public</description>
    </item>
    
    <item>
      <title>如何仅用递归函数和栈操作逆序一个栈</title>
      <link>/post/%E5%A6%82%E4%BD%95%E4%BB%85%E7%94%A8%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88%E6%93%8D%E4%BD%9C%E9%80%86%E5%BA%8F%E4%B8%80%E4%B8%AA%E6%A0%88/</link>
      <pubDate>Wed, 16 Aug 2017 17:05:28 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E4%BB%85%E7%94%A8%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88%E6%93%8D%E4%BD%9C%E9%80%86%E5%BA%8F%E4%B8%80%E4%B8%AA%E6%A0%88/</guid>
      <description>题目: 一个栈依次压入1、2、3、4、5,那么从栈顶到栈底分别为5、4、3、2、1。将这个栈 转置后，从栈顶到桟底为1、2、3、4、5,也就是实</description>
    </item>
    
    <item>
      <title>汉诺塔问题分析</title>
      <link>/post/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 16 Aug 2017 16:39:46 +0000</pubDate>
      
      <guid>/post/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</guid>
      <description></description>
    </item>
    
    <item>
      <title>为什么把无穷大INF设置成0x3f3f3f3f?</title>
      <link>/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%8A%E6%97%A0%E7%A9%B7%E5%A4%A7inf%E8%AE%BE%E7%BD%AE%E6%88%900x3f3f3f3f/</link>
      <pubDate>Mon, 31 Jul 2017 13:14:13 +0000</pubDate>
      
      <guid>/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%8A%E6%97%A0%E7%A9%B7%E5%A4%A7inf%E8%AE%BE%E7%BD%AE%E6%88%900x3f3f3f3f/</guid>
      <description>如果问题中各数据的范围明确，那么无穷大的设定不是问题，在不明确的情况下，很多程序员都取0x7fffffff作为无穷大，因为这是32-bit i</description>
    </item>
    
    <item>
      <title>约瑟夫环</title>
      <link>/post/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</link>
      <pubDate>Thu, 20 Jul 2017 21:33:51 +0000</pubDate>
      
      <guid>/post/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</guid>
      <description>题目: n 个数字（0,1,…,n-1）形成一个圆圈，从数字 k 开始，每次从这个圆圈中删除第 m 个数字（第一个 为当前数字本身，第二个为当前数字的下一</description>
    </item>
    
    <item>
      <title>求两个数组的交集</title>
      <link>/post/%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</link>
      <pubDate>Sun, 25 Jun 2017 22:45:21 +0000</pubDate>
      
      <guid>/post/%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</guid>
      <description>有序数组 以下两种方法都可以适用于数组中数据重复的情况。 长度相似 采用二路归并法来进行求解交集 对于数组A,B分别以i,j从头遍历数组。如果当前位</description>
    </item>
    
    <item>
      <title>数组中和为定值的多元组</title>
      <link>/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BA%E5%AE%9A%E5%80%BC%E7%9A%84%E5%A4%9A%E5%85%83%E7%BB%84/</link>
      <pubDate>Sun, 25 Jun 2017 02:28:52 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BA%E5%AE%9A%E5%80%BC%E7%9A%84%E5%A4%9A%E5%85%83%E7%BB%84/</guid>
      <description>LeetCode 1. Two Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 解析</description>
    </item>
    
    <item>
      <title>模拟数组/字符串/链表的相加与相乘</title>
      <link>/post/%E6%A8%A1%E6%8B%9F%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E5%8A%A0%E4%B8%8E%E7%9B%B8%E4%B9%98/</link>
      <pubDate>Sun, 25 Jun 2017 02:28:43 +0000</pubDate>
      
      <guid>/post/%E6%A8%A1%E6%8B%9F%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E5%8A%A0%E4%B8%8E%E7%9B%B8%E4%B9%98/</guid>
      <description>LeetCode 2. Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6</description>
    </item>
    
    <item>
      <title>最长子串/子序列</title>
      <link>/post/%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Sun, 25 Jun 2017 02:28:32 +0000</pubDate>
      
      <guid>/post/%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>LeetCode 392. Is Subsequence Given a string s and a string t, check if s is subsequence of t. You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (&amp;lt;=100). A subsequence of a string is a new string which is formed from the original string by deleting</description>
    </item>
    
    <item>
      <title>查找回文子串和回文子序列</title>
      <link>/post/%E6%9F%A5%E6%89%BE%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E5%92%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Sun, 25 Jun 2017 02:28:08 +0000</pubDate>
      
      <guid>/post/%E6%9F%A5%E6%89%BE%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E5%92%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>LeetCode 409. Longest Palindrome Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example “Aa” is not considered a palindrome here. Note: Assume the length of given string will not exceed 1,010. Example: Input: &amp;ldquo;abccccdd&amp;rdquo; Output: 7 Explanation: One longest palindrome that can be built is “</description>
    </item>
    
    <item>
      <title>“之”字形翻译字符串</title>
      <link>/post/%E4%B9%8B%E5%AD%97%E5%BD%A2%E7%BF%BB%E8%AF%91%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sun, 25 Jun 2017 02:27:57 +0000</pubDate>
      
      <guid>/post/%E4%B9%8B%E5%AD%97%E5%BD%A2%E7%BF%BB%E8%AF%91%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>LeetCode 6. ZigZag Conversion 字符串“PAYPALISHIRING”以给定数目的行以之字形模式写入，如下所示：（您可能希望以固定字体显示此模式以更好的易读性） P A</description>
    </item>
    
    <item>
      <title>数字字符串转成数字</title>
      <link>/post/%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%88%90%E6%95%B0%E5%AD%97/</link>
      <pubDate>Sun, 25 Jun 2017 02:27:46 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%88%90%E6%95%B0%E5%AD%97/</guid>
      <description>LeetCode 7. Reverse Integer Reverse digits of an integer. Example1: x = 123, return 321 Example2: x = -123, return -321 click to show spoilers. Note: The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. 解析：需要注意溢出的问题。一个int可以表示数字</description>
    </item>
    
    <item>
      <title>判断回文串</title>
      <link>/post/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E4%B8%B2/</link>
      <pubDate>Sun, 25 Jun 2017 02:27:37 +0000</pubDate>
      
      <guid>/post/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E4%B8%B2/</guid>
      <description>LeetCode 9. Palindrome Number Determine whether an integer is a palindrome. Do this without extra space. Some hints: Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Intege</description>
    </item>
    
    <item>
      <title>模拟除法</title>
      <link>/post/%E6%A8%A1%E6%8B%9F%E9%99%A4%E6%B3%95/</link>
      <pubDate>Sun, 25 Jun 2017 02:27:26 +0000</pubDate>
      
      <guid>/post/%E6%A8%A1%E6%8B%9F%E9%99%A4%E6%B3%95/</guid>
      <description>LeetCode 166. Fraction to Recurring Decimal Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. For example, Given numerator = 1, denominator = 2, return “0.5”. Given numerator = 2, denominator = 1, return “2”. Given numerator = 2, denominator = 3,</description>
    </item>
    
    <item>
      <title>在有序矩阵中找数</title>
      <link>/post/%E5%9C%A8%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%89%BE%E6%95%B0/</link>
      <pubDate>Sun, 25 Jun 2017 02:27:16 +0000</pubDate>
      
      <guid>/post/%E5%9C%A8%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%89%BE%E6%95%B0/</guid>
      <description>LeetCode 74. Search a 2D Matrix Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. 解析： 因为每行从小到大排序，而且每</description>
    </item>
    
    <item>
      <title>先序、中序、后序数组两两组合重构二叉树</title>
      <link>/post/%E5%85%88%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%A4%E4%B8%A4%E7%BB%84%E5%90%88%E9%87%8D%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91-/</link>
      <pubDate>Sun, 25 Jun 2017 02:26:54 +0000</pubDate>
      
      <guid>/post/%E5%85%88%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%A4%E4%B8%A4%E7%BB%84%E5%90%88%E9%87%8D%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91-/</guid>
      <description>LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal Given preorder and inorder traversal of a tree, construct the binary tree. 解析：可以发现的规律是：中序遍历中根节点是左子树右子树的分割点。前序遍历的第一个节点为根节点。同</description>
    </item>
    
    <item>
      <title>二叉树的前序/中序/后序遍历</title>
      <link>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sun, 25 Jun 2017 02:26:40 +0000</pubDate>
      
      <guid>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>LeetCode 94. Binary Tree Inorder Traversal Given a binary tree, return the inorder traversal of its nodes’ values. 解析：递归太简单，直接上递推，用栈来模拟递归，找左孩子，保存路径，找不到就找右兄弟的左孩子。 1</description>
    </item>
    
    <item>
      <title>Binary Search Tree</title>
      <link>/post/binary-search-tree/</link>
      <pubDate>Sun, 25 Jun 2017 02:26:31 +0000</pubDate>
      
      <guid>/post/binary-search-tree/</guid>
      <description>LeetCode 230. Kth Smallest Element in a BST Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. 解析：中序遍历BST就可以得到一个有序数组，题目要找Kth，就直接中序遍历，在输出的字符串</description>
    </item>
    
    <item>
      <title>栈与队列的互相实现</title>
      <link>/post/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%92%E7%9B%B8%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sun, 25 Jun 2017 02:26:20 +0000</pubDate>
      
      <guid>/post/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%92%E7%9B%B8%E5%AE%9E%E7%8E%B0/</guid>
      <description>LeetCode 225. Implement Stack using Queues Implement the following operations of a stack using queues. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. empty() – Return whether the stack is empty. Notes: You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty</description>
    </item>
    
    <item>
      <title>在有序旋转数组中的查找</title>
      <link>/post/%E5%9C%A8%E6%9C%89%E5%BA%8F%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Sun, 25 Jun 2017 02:26:09 +0000</pubDate>
      
      <guid>/post/%E5%9C%A8%E6%9C%89%E5%BA%8F%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</guid>
      <description>LeetCode 153. Find Minimum in Rotated Sorted Array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. You may assume no duplicate exists in the array. Subscribe to see which companies asked this question. 解析： 二分法，旋</description>
    </item>
    
    <item>
      <title>斐波那契数列</title>
      <link>/post/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</link>
      <pubDate>Sun, 25 Jun 2017 02:25:49 +0000</pubDate>
      
      <guid>/post/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</guid>
      <description>LeetCode 70. Climbing Stairs You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. 解析：标准Fibonacci，也可看作DP。</description>
    </item>
    
    <item>
      <title>常见位运算问题</title>
      <link>/post/%E5%B8%B8%E8%A7%81%E4%BD%8D%E8%BF%90%E7%AE%97%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 25 Jun 2017 02:25:37 +0000</pubDate>
      
      <guid>/post/%E5%B8%B8%E8%A7%81%E4%BD%8D%E8%BF%90%E7%AE%97%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 191. Number of 1 Bits Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight). For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3. 解析：n=n&amp;amp;(n-1)可以取出</description>
    </item>
    
    <item>
      <title>求某个数是否为2/3/4的幂</title>
      <link>/post/%E6%B1%82%E6%9F%90%E4%B8%AA%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA234%E7%9A%84%E5%B9%82/</link>
      <pubDate>Sun, 25 Jun 2017 02:25:24 +0000</pubDate>
      
      <guid>/post/%E6%B1%82%E6%9F%90%E4%B8%AA%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA234%E7%9A%84%E5%B9%82/</guid>
      <description>LeetCode 231. Power of Two Given an integer, write a function to determine if it is a power of two. 解析：2的幂表示n的只有一个位是“1”，因此使用n&amp;amp;（n-1）== 0的技巧来判断是否是这种情</description>
    </item>
    
    <item>
      <title>求幂与开方</title>
      <link>/post/%E6%B1%82%E5%B9%82%E4%B8%8E%E5%BC%80%E6%96%B9/</link>
      <pubDate>Sun, 25 Jun 2017 02:25:15 +0000</pubDate>
      
      <guid>/post/%E6%B1%82%E5%B9%82%E4%B8%8E%E5%BC%80%E6%96%B9/</guid>
      <description>LeetCode 50. Pow(x, n) Implement pow(x, n). 解析：快速幂，此处需要判断边界值n，如果n为-2^31，那么需要另外设置一个long long变量存储其相反数。0x800000</description>
    </item>
    
    <item>
      <title>删除数组/链表的元素</title>
      <link>/post/%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%83%E7%B4%A0/</link>
      <pubDate>Sun, 25 Jun 2017 02:24:59 +0000</pubDate>
      
      <guid>/post/%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%83%E7%B4%A0/</guid>
      <description>LeetCode 27. Remove Element Given an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example: Given input array nums = [3,2,2,3],</description>
    </item>
    
    <item>
      <title>在单链表中删除倒数第N个节点</title>
      <link>/post/%E5%9C%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sun, 25 Jun 2017 02:24:48 +0000</pubDate>
      
      <guid>/post/%E5%9C%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</guid>
      <description>LeetCode 19. Remove Nth Node From End of List Given a linked list, remove the nth node from the end of list and return its head. For example, Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5. Note: Given n will always be valid. Try to do this in one pass. 解析： 根据题意</description>
    </item>
    
    <item>
      <title>链表有环和相交问题</title>
      <link>/post/%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF%E5%92%8C%E7%9B%B8%E4%BA%A4%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 25 Jun 2017 02:24:38 +0000</pubDate>
      
      <guid>/post/%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF%E5%92%8C%E7%9B%B8%E4%BA%A4%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 141. Linked List Cycle Given a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space? 解析： FLOYD判圈算法(判断是否有环): 如何检测一个链表是否有环，如果有，那么如何确</description>
    </item>
    
    <item>
      <title>数组、字符串、链表的旋转判定</title>
      <link>/post/%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE%E8%A1%A8%E7%9A%84%E6%97%8B%E8%BD%AC%E5%88%A4%E5%AE%9A/</link>
      <pubDate>Sun, 25 Jun 2017 02:24:25 +0000</pubDate>
      
      <guid>/post/%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE%E8%A1%A8%E7%9A%84%E6%97%8B%E8%BD%AC%E5%88%A4%E5%AE%9A/</guid>
      <description>LeetCode 189. Rotate Array Rotate an array of n elements to the right by k steps. For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. 解析： 循环移动数组k位：123</description>
    </item>
    
    <item>
      <title>反转链表</title>
      <link>/post/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 25 Jun 2017 02:24:14 +0000</pubDate>
      
      <guid>/post/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>LeetCode 24. Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head. For example, Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, you should return the list as 2-&amp;gt;1-&amp;gt;4-&amp;gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 解析：直接交换当前结点和其后继节点的</description>
    </item>
    
    <item>
      <title>合并有序链表/数组</title>
      <link>/post/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sun, 25 Jun 2017 02:23:16 +0000</pubDate>
      
      <guid>/post/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E6%95%B0%E7%BB%84/</guid>
      <description>LeetCode 88. Merge Sorted Array Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 解析： 合并两个数组（</description>
    </item>
    
    <item>
      <title>镜像二叉树</title>
      <link>/post/%E9%95%9C%E5%83%8F%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 25 Jun 2017 02:23:02 +0000</pubDate>
      
      <guid>/post/%E9%95%9C%E5%83%8F%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>LeetCode 226. Invert Binary Tree Invert a binary tree. 4 / \ 2 7 / \ / \ 1 3 6 9 to 4 / \ 7 2 / \ / \ 9 6 3 1 解析：二叉树的镜像就是在遍历树的同时交换非叶节点的左右子节点 1 2 3 4</description>
    </item>
    
    <item>
      <title>判断t1树是否包含t2树全部的拓扑结构</title>
      <link>/post/%E5%88%A4%E6%96%ADt1%E6%A0%91%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%ABt2%E6%A0%91%E5%85%A8%E9%83%A8%E7%9A%84%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 25 Jun 2017 02:22:50 +0000</pubDate>
      
      <guid>/post/%E5%88%A4%E6%96%ADt1%E6%A0%91%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%ABt2%E6%A0%91%E5%85%A8%E9%83%A8%E7%9A%84%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/</guid>
      <description>LeetCode 100.Same Tree Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. 解析：直接DFS，注意两个节点中任何一个为空要直接返回，算是递归终止</description>
    </item>
    
    <item>
      <title>转圈打印矩阵</title>
      <link>/post/%E8%BD%AC%E5%9C%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Sun, 25 Jun 2017 02:22:38 +0000</pubDate>
      
      <guid>/post/%E8%BD%AC%E5%9C%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</guid>
      <description>LeetCode 54. Spiral Matrix Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. For example, Given the following matrix: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] You should return [1,2,3,6,9,8,7,4,5]. 解析： 先找出矩阵的四个边界，然后将整</description>
    </item>
    
    <item>
      <title>除法的化简</title>
      <link>/post/%E9%99%A4%E6%B3%95%E7%9A%84%E5%8C%96%E7%AE%80/</link>
      <pubDate>Sun, 25 Jun 2017 02:22:24 +0000</pubDate>
      
      <guid>/post/%E9%99%A4%E6%B3%95%E7%9A%84%E5%8C%96%E7%AE%80/</guid>
      <description>LeetCode 399. Evaluate Division Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0. Example: Given a / b = 2.0, b / c = 3.0. queries are: a / c = ?, b / a =</description>
    </item>
    
    <item>
      <title>二叉树节点间的公共祖先</title>
      <link>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E9%97%B4%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Sun, 25 Jun 2017 02:22:13 +0000</pubDate>
      
      <guid>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E9%97%B4%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>LeetCode 235. Lowest Common Ancestor of a Binary Search Tree Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a</description>
    </item>
    
    <item>
      <title>设计一个有getMin功能的栈</title>
      <link>/post/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%9C%89getmin%E5%8A%9F%E8%83%BD%E7%9A%84%E6%A0%88/</link>
      <pubDate>Sun, 25 Jun 2017 02:21:54 +0000</pubDate>
      
      <guid>/post/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%9C%89getmin%E5%8A%9F%E8%83%BD%E7%9A%84%E6%A0%88/</guid>
      <description>LeetCode 155. Min Stack Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&amp;gt; Returns -3. minStack.pop(); minStack.top(); --&amp;gt; Returns 0.</description>
    </item>
    
    <item>
      <title>滑动窗口</title>
      <link>/post/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</link>
      <pubDate>Sun, 25 Jun 2017 02:21:40 +0000</pubDate>
      
      <guid>/post/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</guid>
      <description>LeetCode 209. Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. For example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint. 解析：用双指</description>
    </item>
    
    <item>
      <title>二叉树的按层打印与ZigZig打印</title>
      <link>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%B8%8Ezigzig%E6%89%93%E5%8D%B0/</link>
      <pubDate>Sun, 25 Jun 2017 02:21:28 +0000</pubDate>
      
      <guid>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%B8%8Ezigzig%E6%89%93%E5%8D%B0/</guid>
      <description>LeetCode102. Binary Tree Level Order Traversal Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its level order traversal as: [ [3], [9,20], [15,7] ] 解析：此题要求将二叉树层</description>
    </item>
    
    <item>
      <title>二叉树的深度</title>
      <link>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Sun, 25 Jun 2017 00:01:10 +0000</pubDate>
      
      <guid>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</guid>
      <description>LeetCode 104. Maximum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 解析：找二叉树的最大深度，不断dfs，只要能dfs到下一层，就增加</description>
    </item>
    
    <item>
      <title>在二叉树中找到累加和为指定值的最长路径长度</title>
      <link>/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E6%8C%87%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Sun, 25 Jun 2017 00:01:01 +0000</pubDate>
      
      <guid>/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E6%8C%87%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6/</guid>
      <description>LeetCode 112. Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. For example: Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2</description>
    </item>
    
    <item>
      <title>复制含有随机指针节点的链表</title>
      <link>/post/%E5%A4%8D%E5%88%B6%E5%90%AB%E6%9C%89%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E8%8A%82%E7%82%B9%E7%9A%84%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 25 Jun 2017 00:00:49 +0000</pubDate>
      
      <guid>/post/%E5%A4%8D%E5%88%B6%E5%90%AB%E6%9C%89%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E8%8A%82%E7%82%B9%E7%9A%84%E9%93%BE%E8%A1%A8/</guid>
      <description>LeetCode 138. Copy List with Random Pointer A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. 解析： 此题有两种方法，一种是按照原链表next的顺序依次创建节</description>
    </item>
    
    <item>
      <title>找到无序数组中某一频率的数</title>
      <link>/post/%E6%89%BE%E5%88%B0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%90%E4%B8%80%E9%A2%91%E7%8E%87%E7%9A%84%E6%95%B0/</link>
      <pubDate>Sun, 25 Jun 2017 00:00:19 +0000</pubDate>
      
      <guid>/post/%E6%89%BE%E5%88%B0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%90%E4%B8%80%E9%A2%91%E7%8E%87%E7%9A%84%E6%95%B0/</guid>
      <description>LeetCode 451. Sort Characters By Frequency Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input: “tree” Output: “eert” Explanation: ‘e’ appears twice while ‘r’ and ‘t’ both appear once. So ‘e’ must appear before both ‘r’ and ‘t’. Therefore</description>
    </item>
    
    <item>
      <title>子数组的最大累加和/累乘积</title>
      <link>/post/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E5%8A%A0%E5%92%8C%E7%B4%AF%E4%B9%98%E7%A7%AF/</link>
      <pubDate>Sun, 25 Jun 2017 00:00:10 +0000</pubDate>
      
      <guid>/post/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E5%8A%A0%E5%92%8C%E7%B4%AF%E4%B9%98%E7%A7%AF/</guid>
      <description>LeetCode 53. Maximum Subarray Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6. 解析：动态规划 每个元素有2种选择：加入之前的连续子序列；创建一个新</description>
    </item>
    
    <item>
      <title>与数字的某位相关问题</title>
      <link>/post/%E4%B8%8E%E6%95%B0%E5%AD%97%E7%9A%84%E6%9F%90%E4%BD%8D%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Jun 2017 23:59:57 +0000</pubDate>
      
      <guid>/post/%E4%B8%8E%E6%95%B0%E5%AD%97%E7%9A%84%E6%9F%90%E4%BD%8D%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 233. Number of Digit One Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n. For example: Given n = 13, Return 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13. 解析： 每10个数, 有一个个位是1, 每100</description>
    </item>
    
    <item>
      <title>丑数</title>
      <link>/post/%E4%B8%91%E6%95%B0/</link>
      <pubDate>Sat, 24 Jun 2017 23:59:47 +0000</pubDate>
      
      <guid>/post/%E4%B8%91%E6%95%B0/</guid>
      <description>LeetCode 263. Ugly Number Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note that 1 is typically treated as an ugly number. 解析： 我们将给定数除以2</description>
    </item>
    
    <item>
      <title>字符数组中的单独字符</title>
      <link>/post/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E7%8B%AC%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Sat, 24 Jun 2017 23:59:36 +0000</pubDate>
      
      <guid>/post/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E7%8B%AC%E5%AD%97%E7%AC%A6/</guid>
      <description>判断字符数组中是否所有的字符都只出现过一次 题目: 给定一个字符类型数组chas[]，判断chas中是否所有的字符都只出现过一次,在保证额外空间</description>
    </item>
    
    <item>
      <title>通过增删数位创建新的数字</title>
      <link>/post/%E9%80%9A%E8%BF%87%E5%A2%9E%E5%88%A0%E6%95%B0%E4%BD%8D%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Sat, 24 Jun 2017 23:59:18 +0000</pubDate>
      
      <guid>/post/%E9%80%9A%E8%BF%87%E5%A2%9E%E5%88%A0%E6%95%B0%E4%BD%8D%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>LeetCode 402. Remove K Digits Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible. Note: The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero. Example 1: Input: num = &amp;quot;1432219&amp;quot;, k = 3 Output: &amp;quot;1219&amp;quot; Explanation: Remove the three digits 4, 3,</description>
    </item>
    
    <item>
      <title>排列</title>
      <link>/post/%E6%8E%92%E5%88%97/</link>
      <pubDate>Sat, 24 Jun 2017 23:59:06 +0000</pubDate>
      
      <guid>/post/%E6%8E%92%E5%88%97/</guid>
      <description>LeetCode 46. Permutations Given a collection of distinct numbers, return all possible permutations. For example, [1,2,3] have the following permutations: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 解析： 此题可以直接用STL中的next_permutation()实现。利用回溯法暴</description>
    </item>
    
    <item>
      <title>查找单独/重复/丢失的元素</title>
      <link>/post/%E6%9F%A5%E6%89%BE%E5%8D%95%E7%8B%AC%E9%87%8D%E5%A4%8D%E4%B8%A2%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0/</link>
      <pubDate>Sat, 24 Jun 2017 23:58:53 +0000</pubDate>
      
      <guid>/post/%E6%9F%A5%E6%89%BE%E5%8D%95%E7%8B%AC%E9%87%8D%E5%A4%8D%E4%B8%A2%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0/</guid>
      <description>LeetCode 136. Single Number Given an array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 解析：利用异或运算规律，同一个数异或两次相当于没有异或。本题除了所</description>
    </item>
    
    <item>
      <title>删除有序数组/链表的重复值</title>
      <link>/post/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E5%80%BC/</link>
      <pubDate>Sat, 24 Jun 2017 23:58:39 +0000</pubDate>
      
      <guid>/post/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E5%80%BC/</guid>
      <description>LeetCode 26. Remove Duplicates from Sorted Array Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example, Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and</description>
    </item>
    
    <item>
      <title>格雷码</title>
      <link>/post/%E6%A0%BC%E9%9B%B7%E7%A0%81/</link>
      <pubDate>Sat, 24 Jun 2017 23:58:27 +0000</pubDate>
      
      <guid>/post/%E6%A0%BC%E9%9B%B7%E7%A0%81/</guid>
      <description>LeetCode 89. Gray Code The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. For example, given n = 2, return [0,1,3,2]. Its gray code sequence is: 00 - 0 01 - 1 11 -</description>
    </item>
    
    <item>
      <title>正则表达式匹配</title>
      <link>/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Sat, 24 Jun 2017 23:58:16 +0000</pubDate>
      
      <guid>/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description>LeetCode 44. Wildcard Matching Implement wildcard pattern matching with support for ‘?’ and ‘*’. ‘?’ Matches any single character. ‘*’ Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). The function prototype should be: bool isMatch(const char s, const char p) Some examples: isMatch(&amp;quot;aa&amp;quot;,&amp;quot;a&amp;quot;) → false isMatch(&amp;quot;aa&amp;quot;,&amp;quot;aa&amp;quot;) → true isMatch(&amp;quot;aaa&amp;quot;,&amp;quot;aa&amp;quot;) →</description>
    </item>
    
    <item>
      <title>查找数组中的重复项</title>
      <link>/post/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</link>
      <pubDate>Sat, 24 Jun 2017 23:58:05 +0000</pubDate>
      
      <guid>/post/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</guid>
      <description>LeetCode 217. Contains Duplicate Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. 解析：直接构建哈希表 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: bool containsDuplicate(vector&amp;lt;int&amp;gt;&amp;amp;</description>
    </item>
    
    <item>
      <title>容器的盛水量</title>
      <link>/post/%E5%AE%B9%E5%99%A8%E7%9A%84%E7%9B%9B%E6%B0%B4%E9%87%8F/</link>
      <pubDate>Sat, 24 Jun 2017 23:57:56 +0000</pubDate>
      
      <guid>/post/%E5%AE%B9%E5%99%A8%E7%9A%84%E7%9B%9B%E6%B0%B4%E9%87%8F/</guid>
      <description>LeetCode 11. Container With Most Water Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and</description>
    </item>
    
    <item>
      <title>最长公共前缀</title>
      <link>/post/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</link>
      <pubDate>Sat, 24 Jun 2017 22:12:20 +0000</pubDate>
      
      <guid>/post/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</guid>
      <description>LeetCode 14. Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings. 解析：求所有字符串的公共前缀，逐个字符比较，时间复杂度为O(N*L),N是字符串个数，L是最长前缀的</description>
    </item>
    
    <item>
      <title>数字翻译</title>
      <link>/post/%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91/</link>
      <pubDate>Sat, 24 Jun 2017 22:12:10 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91/</guid>
      <description>LeetCode 12. Integer to Roman Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 解析：先是做了一个表，根据各个位的数字查表，然后组合罗马数字成字符串 1 2 3 4 5 6 7 8 9 10</description>
    </item>
    
    <item>
      <title>括号匹配</title>
      <link>/post/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Sat, 24 Jun 2017 22:12:01 +0000</pubDate>
      
      <guid>/post/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/</guid>
      <description>括号字符的有效性 给定一个字符串str,判断是不是整体有效的括号字符串。 解析: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static boolean isValid(String str) { if (str == null || str.equals(&amp;#34;&amp;#34;))</description>
    </item>
    
    <item>
      <title>数组中的位置查找</title>
      <link>/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Sat, 24 Jun 2017 22:11:50 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE%E6%9F%A5%E6%89%BE/</guid>
      <description>LeetCode 35. Search Insert Position Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Here are few examples. [1,3,5,6], 5 → 2 [1,3,5,6], 2 → 1 [1,3,5,6], 7 → 4 [1,3,5,6], 0 → 0 解析：在有序</description>
    </item>
    
    <item>
      <title>根据大小猜数</title>
      <link>/post/%E6%A0%B9%E6%8D%AE%E5%A4%A7%E5%B0%8F%E7%8C%9C%E6%95%B0/</link>
      <pubDate>Sat, 24 Jun 2017 22:11:42 +0000</pubDate>
      
      <guid>/post/%E6%A0%B9%E6%8D%AE%E5%A4%A7%E5%B0%8F%E7%8C%9C%E6%95%B0/</guid>
      <description>LeetCode 374. Guess Number Higher or Lower We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I’ll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0): -1 :</description>
    </item>
    
    <item>
      <title>从石堆取石子的博弈问题</title>
      <link>/post/%E4%BB%8E%E7%9F%B3%E5%A0%86%E5%8F%96%E7%9F%B3%E5%AD%90%E7%9A%84%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Jun 2017 22:11:34 +0000</pubDate>
      
      <guid>/post/%E4%BB%8E%E7%9F%B3%E5%A0%86%E5%8F%96%E7%9F%B3%E5%AD%90%E7%9A%84%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 292. Nim Game You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game.</description>
    </item>
    
    <item>
      <title>引爆区间气球</title>
      <link>/post/%E5%BC%95%E7%88%86%E5%8C%BA%E9%97%B4%E6%B0%94%E7%90%83/</link>
      <pubDate>Sat, 24 Jun 2017 22:11:25 +0000</pubDate>
      
      <guid>/post/%E5%BC%95%E7%88%86%E5%8C%BA%E9%97%B4%E6%B0%94%E7%90%83/</guid>
      <description>LeetCode 312. Burst Balloons Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] nums[i] nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you</description>
    </item>
    
    <item>
      <title>数独</title>
      <link>/post/%E6%95%B0%E7%8B%AC/</link>
      <pubDate>Sat, 24 Jun 2017 22:11:15 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E7%8B%AC/</guid>
      <description>LeetCode 36. Valid Sudoku The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’. 解析：检查九宫格是否有效，只需要检查每行每列和每个子九宫格是否存在重复数字即可。创建三个map</description>
    </item>
    
    <item>
      <title>组合</title>
      <link>/post/%E7%BB%84%E5%90%88/</link>
      <pubDate>Sat, 24 Jun 2017 22:09:05 +0000</pubDate>
      
      <guid>/post/%E7%BB%84%E5%90%88/</guid>
      <description>LeetCode 39. Combination Sum Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example, given candidate set [2, 3, 6, 7]</description>
    </item>
    
    <item>
      <title>跳跃游戏</title>
      <link>/post/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Sat, 24 Jun 2017 22:08:56 +0000</pubDate>
      
      <guid>/post/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</guid>
      <description>LeetCode 55. Jump Game Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. For example: A = [2,3,1,1,4], return true. A = [3,2,1,0,4], return false. 解析：设最远距离为reach</description>
    </item>
    
    <item>
      <title>将正方形矩阵转动90度</title>
      <link>/post/%E5%B0%86%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9F%A9%E9%98%B5%E8%BD%AC%E5%8A%A890%E5%BA%A6/</link>
      <pubDate>Sat, 24 Jun 2017 22:08:46 +0000</pubDate>
      
      <guid>/post/%E5%B0%86%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9F%A9%E9%98%B5%E8%BD%AC%E5%8A%A890%E5%BA%A6/</guid>
      <description>LeetCode 48. Rotate Image You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Follow up: Could you do this in-place? 解析： 二维矩阵顺时针旋转90度，先转置，再把每一行翻转 二维矩阵逆时针旋转90度，</description>
    </item>
    
    <item>
      <title>判断变形字符串</title>
      <link>/post/%E5%88%A4%E6%96%AD%E5%8F%98%E5%BD%A2%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sat, 24 Jun 2017 22:08:38 +0000</pubDate>
      
      <guid>/post/%E5%88%A4%E6%96%AD%E5%8F%98%E5%BD%A2%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>LeetCode 383. Ransom Note Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false. Each letter in the magazine string can only be used once in your ransom note. Note: You may assume that both strings contain only lowercase letters. canConstruct(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;)</description>
    </item>
    
    <item>
      <title>N皇后问题</title>
      <link>/post/n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Jun 2017 22:08:30 +0000</pubDate>
      
      <guid>/post/n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 51. N-Queens The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen</description>
    </item>
    
    <item>
      <title>最后一个单词的长度</title>
      <link>/post/%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Sat, 24 Jun 2017 22:08:22 +0000</pubDate>
      
      <guid>/post/%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</guid>
      <description>LeetCode 58. Length of Last Word Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. For example, Given s = “Hello World”</description>
    </item>
    
    <item>
      <title>文本排版</title>
      <link>/post/%E6%96%87%E6%9C%AC%E6%8E%92%E7%89%88/</link>
      <pubDate>Sat, 24 Jun 2017 22:08:13 +0000</pubDate>
      
      <guid>/post/%E6%96%87%E6%9C%AC%E6%8E%92%E7%89%88/</guid>
      <description>LeetCode 68. Text Justification Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ‘ ‘ when necessary so that each line has exactly L characters. Extra spaces between</description>
    </item>
    
    <item>
      <title>路径问题</title>
      <link>/post/%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Jun 2017 22:08:03 +0000</pubDate>
      
      <guid>/post/%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 62. Unique Paths A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How</description>
    </item>
    
    <item>
      <title>区间问题</title>
      <link>/post/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Jun 2017 22:07:55 +0000</pubDate>
      
      <guid>/post/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 228. Summary Ranges Given a sorted integer array without duplicates, return the summary of its ranges. For example, given [0,1,2,4,5,7], return [“0-&amp;gt;2”,”4-&amp;gt;5”,”7”]. 解析： 将一组数划分成若干的区间，用双指针分别</description>
    </item>
    
    <item>
      <title>文件路径</title>
      <link>/post/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Sat, 24 Jun 2017 22:07:44 +0000</pubDate>
      
      <guid>/post/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/</guid>
      <description>LeetCode 71. Simplify Path Given an absolute path for a file (Unix-style), simplify it. For example, path = “/home/“, =&amp;gt; “/home” path = “/a/./b/../../c/“, =&amp;gt; “/c” 解析： 字符串处理，而</description>
    </item>
    
    <item>
      <title>字符串A编辑成字符串B</title>
      <link>/post/%E7%AC%A6%E4%B8%B2a%E7%BC%96%E8%BE%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2b/</link>
      <pubDate>Sat, 24 Jun 2017 20:32:14 +0000</pubDate>
      
      <guid>/post/%E7%AC%A6%E4%B8%B2a%E7%BC%96%E8%BE%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2b/</guid>
      <description>LeetCode 115. Distinct Subsequences Given a string S and a string T, count the number of distinct subsequences of T in S. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABC</description>
    </item>
    
    <item>
      <title>修改矩阵</title>
      <link>/post/%E4%BF%AE%E6%94%B9%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Sat, 24 Jun 2017 20:32:04 +0000</pubDate>
      
      <guid>/post/%E4%BF%AE%E6%94%B9%E7%9F%A9%E9%98%B5/</guid>
      <description>LeetCode 73. Set Matrix Zeroes Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place. 解析： 题目要求空间复杂度in place，即原地工作O(1),执行算法时所使用的额外空</description>
    </item>
    
    <item>
      <title>子集</title>
      <link>/post/%E5%AD%90%E9%9B%86/</link>
      <pubDate>Sat, 24 Jun 2017 20:31:54 +0000</pubDate>
      
      <guid>/post/%E5%AD%90%E9%9B%86/</guid>
      <description>LeetCode 78. Subsets Given a set of distinct integers, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. For example, If nums = [1,2,3], a solution is: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 解析：要求输出所有子集，且输出有序，而每个元素只有出现和</description>
    </item>
    
    <item>
      <title>字典树相关问题</title>
      <link>/post/%E5%AD%97%E5%85%B8%E6%A0%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Jun 2017 20:31:45 +0000</pubDate>
      
      <guid>/post/%E5%AD%97%E5%85%B8%E6%A0%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 79. Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example, Given board = [ [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;], [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;], [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;] ] word</description>
    </item>
    
    <item>
      <title>单链表排序总结</title>
      <link>/post/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 24 Jun 2017 20:31:28 +0000</pubDate>
      
      <guid>/post/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</guid>
      <description>插入排序 LeetCode 147. Insertion Sort List Sort a linked list using insertion sort. 解析： 链表排序最易理解的是插入排序。 插入排序的方法就是枚举数组中的每一个元素i，从头扫描数组，找到第一个比该</description>
    </item>
    
    <item>
      <title>划分数组/链表</title>
      <link>/post/%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 24 Jun 2017 20:31:14 +0000</pubDate>
      
      <guid>/post/%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/</guid>
      <description>LeetCode 75. Sort Colors Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library</description>
    </item>
    
    <item>
      <title>乱序字符串</title>
      <link>/post/%E4%B9%B1%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sat, 24 Jun 2017 20:29:19 +0000</pubDate>
      
      <guid>/post/%E4%B9%B1%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>LeetCode 87. Scramble String Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Below is one possible representation of s1 = “great”: great / \ gr eat / \ / \ g r e at / \ a t To scramble the string, we may choose any non-leaf node and swap its</description>
    </item>
    
    <item>
      <title>最大区域面积</title>
      <link>/post/%E6%9C%80%E5%A4%A7%E5%8C%BA%E5%9F%9F%E9%9D%A2%E7%A7%AF/</link>
      <pubDate>Sat, 24 Jun 2017 20:29:09 +0000</pubDate>
      
      <guid>/post/%E6%9C%80%E5%A4%A7%E5%8C%BA%E5%9F%9F%E9%9D%A2%E7%A7%AF/</guid>
      <description>LeetCode 84. Largest Rectangle in Histogram Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area =</description>
    </item>
    
    <item>
      <title>统计和生成所有不同的二叉树</title>
      <link>/post/%E7%BB%9F%E8%AE%A1%E5%92%8C%E7%94%9F%E6%88%90%E6%89%80%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sat, 24 Jun 2017 20:29:00 +0000</pubDate>
      
      <guid>/post/%E7%BB%9F%E8%AE%A1%E5%92%8C%E7%94%9F%E6%88%90%E6%89%80%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>LeetCode 96. Unique Binary Search Trees Given n, how many structurally unique BST’s (binary search trees) that store values 1…n? For example, Given n = 3, there are a total of 5 unique BST’s. 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2</description>
    </item>
    
    <item>
      <title>重建搜索二叉树</title>
      <link>/post/%E9%87%8D%E5%BB%BA%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sat, 24 Jun 2017 20:28:50 +0000</pubDate>
      
      <guid>/post/%E9%87%8D%E5%BB%BA%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>LeetCode 108. Convert Sorted Array to Binary Search Tree Given an array where elements are sorted in ascending order, convert it to a height balanced BST. 解析： 每次找到数组的中间位置，这个便是BST的 根节点。左右孩子也很好找，根节点左边区域的</description>
    </item>
    
    <item>
      <title>IP Address</title>
      <link>/post/ip-address/</link>
      <pubDate>Sat, 24 Jun 2017 20:28:40 +0000</pubDate>
      
      <guid>/post/ip-address/</guid>
      <description>LeetCode 93. Restore IP Addresses Given a string containing only digits, restore it by returning all possible valid IP address combinations. For example: Given “25525511135”, return [“255.255.11.135”, “255.255.111.</description>
    </item>
    
    <item>
      <title>添加括号或运算符进行计算</title>
      <link>/post/%E6%B7%BB%E5%8A%A0%E6%8B%AC%E5%8F%B7%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Sat, 24 Jun 2017 20:28:04 +0000</pubDate>
      
      <guid>/post/%E6%B7%BB%E5%8A%A0%E6%8B%AC%E5%8F%B7%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97/</guid>
      <description>LeetCode 494. Target Sum You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol. Find out how many ways to assign symbols to make sum of integers equal to target S. Example 1: Input: nums is [1, 1, 1, 1,</description>
    </item>
    
    <item>
      <title>Flatten Binary Tree to Linked List</title>
      <link>/post/flatten-binary-tree-to-linked-list/</link>
      <pubDate>Sat, 24 Jun 2017 20:27:52 +0000</pubDate>
      
      <guid>/post/flatten-binary-tree-to-linked-list/</guid>
      <description>LeetCode 114. Flatten Binary Tree to Linked List Given a binary tree, flatten it to a linked list in-place. For example, Given 1 / \ 2 5 / \ \ 3 4 6 The flattened tree should look like: 1 \ 2 \ 3 \ 4 \ 5 \ 6 解析： 可以看出变换后的树实际上是按照先序</description>
    </item>
    
    <item>
      <title>Pascal&#39;s Triangle</title>
      <link>/post/pascal-s-triangle/</link>
      <pubDate>Sat, 24 Jun 2017 20:27:41 +0000</pubDate>
      
      <guid>/post/pascal-s-triangle/</guid>
      <description>LeetCode 118. Pascal’s Triangle Given numRows, generate the first numRows of Pascal’s triangle. For example, given numRows = 5, Return [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] 解析： 杨辉三角形的构造方法：左右边界为1，中间num[i]</description>
    </item>
    
    <item>
      <title>在二叉树节点中添加新指针</title>
      <link>/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%8C%87%E9%92%88/</link>
      <pubDate>Sat, 24 Jun 2017 20:26:57 +0000</pubDate>
      
      <guid>/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%8C%87%E9%92%88/</guid>
      <description>LeetCode 116. Populating Next Right Pointers in Each Node Given a binary tree struct TreeLinkNode { TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space. You may assume that it</description>
    </item>
    
    <item>
      <title>购买股票问题</title>
      <link>/post/%E8%B4%AD%E4%B9%B0%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Jun 2017 20:26:45 +0000</pubDate>
      
      <guid>/post/%E8%B4%AD%E4%B9%B0%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 121. Best Time to Buy and Sell Stock Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1: Input: [7, 1, 5, 3, 6, 4] Output: 5 max.</description>
    </item>
    
    <item>
      <title>Word Ladder</title>
      <link>/post/word-ladder/</link>
      <pubDate>Sat, 24 Jun 2017 20:26:35 +0000</pubDate>
      
      <guid>/post/word-ladder/</guid>
      <description>LeetCode 127. Word Ladder Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. For example, Given: beginWord =</description>
    </item>
    
    <item>
      <title>最长上升子序列</title>
      <link>/post/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Sat, 24 Jun 2017 20:26:24 +0000</pubDate>
      
      <guid>/post/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>LeetCode 300. Longest Increasing Subsequence Given an unsorted array of integers, find the length of longest increasing subsequence. For example, Given [10, 9, 2, 5, 3, 7, 101, 18], The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity.</description>
    </item>
    
    <item>
      <title>Surrounded Regions</title>
      <link>/post/surrounded-regions/</link>
      <pubDate>Sat, 24 Jun 2017 20:26:12 +0000</pubDate>
      
      <guid>/post/surrounded-regions/</guid>
      <description>LeetCode 130. Surrounded Regions Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’. A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region. For example, X X X X X O O X X X O X X O X X After running your function,</description>
    </item>
    
    <item>
      <title>134. Gas Station</title>
      <link>/post/gas-station/</link>
      <pubDate>Sat, 24 Jun 2017 20:26:00 +0000</pubDate>
      
      <guid>/post/gas-station/</guid>
      <description>LeetCode 134. Gas Station There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas stat</description>
    </item>
    
    <item>
      <title>分糖果问题</title>
      <link>/post/%E5%88%86%E7%B3%96%E6%9E%9C%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Jun 2017 20:25:50 +0000</pubDate>
      
      <guid>/post/%E5%88%86%E7%B3%96%E6%9E%9C%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 135. Candy There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. What is the minimum candies you must give? 解析： 先引入爬坡和下坡的概</description>
    </item>
    
    <item>
      <title>数组排序之后相邻数的最大差值</title>
      <link>/post/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%90%8E%E7%9B%B8%E9%82%BB%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/</link>
      <pubDate>Sat, 24 Jun 2017 19:52:29 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%90%8E%E7%9B%B8%E9%82%BB%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/</guid>
      <description>LeetCode 164. Maximum Gap Given an unsorted array, find the maximum difference between the successive elements in its sorted form. Try to solve it in linear time/space. Return 0 if the array contains less than 2 elements. You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. 解析： 桶排序要求所有元素在一</description>
    </item>
    
    <item>
      <title>重复的DNA子序列</title>
      <link>/post/%E9%87%8D%E5%A4%8D%E7%9A%84dna%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Sat, 24 Jun 2017 19:52:16 +0000</pubDate>
      
      <guid>/post/%E9%87%8D%E5%A4%8D%E7%9A%84dna%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>LeetCode 187. Repeated DNA Sequences All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. For</description>
    </item>
    
    <item>
      <title>筛选素数</title>
      <link>/post/%E7%AD%9B%E9%80%89%E7%B4%A0%E6%95%B0/</link>
      <pubDate>Sat, 24 Jun 2017 19:52:07 +0000</pubDate>
      
      <guid>/post/%E7%AD%9B%E9%80%89%E7%B4%A0%E6%95%B0/</guid>
      <description>LeetCode 204. Count Primes Description: Count the number of prime numbers less than a non-negative number, n. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution {//埃拉托斯特尼尼素数筛法 public: int countPrimes(int n) { if (n&amp;lt;=2) return 0;//2以下没有</description>
    </item>
    
    <item>
      <title>特殊数</title>
      <link>/post/%E7%89%B9%E6%AE%8A%E6%95%B0/</link>
      <pubDate>Sat, 24 Jun 2017 19:51:48 +0000</pubDate>
      
      <guid>/post/%E7%89%B9%E6%AE%8A%E6%95%B0/</guid>
      <description>LeetCode 202. Happy Number Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which</description>
    </item>
    
    <item>
      <title>课程安排</title>
      <link>/post/%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92/</link>
      <pubDate>Sat, 24 Jun 2017 19:51:39 +0000</pubDate>
      
      <guid>/post/%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92/</guid>
      <description>LeetCode 207. Course Schedule There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? For example:</description>
    </item>
    
    <item>
      <title>求重叠矩形的面积</title>
      <link>/post/%E6%B1%82%E9%87%8D%E5%8F%A0%E7%9F%A9%E5%BD%A2%E7%9A%84%E9%9D%A2%E7%A7%AF/</link>
      <pubDate>Sat, 24 Jun 2017 19:51:32 +0000</pubDate>
      
      <guid>/post/%E6%B1%82%E9%87%8D%E5%8F%A0%E7%9F%A9%E5%BD%A2%E7%9A%84%E9%9D%A2%E7%A7%AF/</guid>
      <description>LeetCode 223. Rectangle Area Find the total area covered by two rectilinear rectangles in a 2D plane. Each rectangle is defined by its bottom left corner and top right corner as shown in the figure. 解析： 求出两个区域的面积, 然后减去overlapping的区域, 即为所</description>
    </item>
    
    <item>
      <title>天际线扫描</title>
      <link>/post/%E5%A4%A9%E9%99%85%E7%BA%BF%E6%89%AB%E6%8F%8F/</link>
      <pubDate>Sat, 24 Jun 2017 19:51:24 +0000</pubDate>
      
      <guid>/post/%E5%A4%A9%E9%99%85%E7%BA%BF%E6%89%AB%E6%8F%8F/</guid>
      <description>LeetCode 218. The Skyline Problem A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B). The geometric</description>
    </item>
    
    <item>
      <title>H-Index</title>
      <link>/post/h-index/</link>
      <pubDate>Sat, 24 Jun 2017 19:51:15 +0000</pubDate>
      
      <guid>/post/h-index/</guid>
      <description>LeetCode 274. H-Index Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index. According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have</description>
    </item>
    
    <item>
      <title>同构字符串</title>
      <link>/post/%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sat, 24 Jun 2017 19:51:07 +0000</pubDate>
      
      <guid>/post/%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>LeetCode 205. Isomorphic Strings Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. For example, Given “egg</description>
    </item>
    
    <item>
      <title>设计RandomPool结构</title>
      <link>/post/%E8%AE%BE%E8%AE%A1randompool%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sat, 24 Jun 2017 19:50:58 +0000</pubDate>
      
      <guid>/post/%E8%AE%BE%E8%AE%A1randompool%E7%BB%93%E6%9E%84/</guid>
      <description>LeetCode 380. Insert Delete GetRandom O(1) Design a data structure that supports all following operations in average O(1) time. insert(val): Inserts an item val to the set if not already present. remove(val): Removes an item val from the set if present. getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned. Example: 1 2 3 4 5 6 7 8</description>
    </item>
    
    <item>
      <title>查找一条直线上的最多点个数</title>
      <link>/post/%E6%9F%A5%E6%89%BE%E4%B8%80%E6%9D%A1%E7%9B%B4%E7%BA%BF%E4%B8%8A%E7%9A%84%E6%9C%80%E5%A4%9A%E7%82%B9%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Sat, 24 Jun 2017 19:50:25 +0000</pubDate>
      
      <guid>/post/%E6%9F%A5%E6%89%BE%E4%B8%80%E6%9D%A1%E7%9B%B4%E7%BA%BF%E4%B8%8A%E7%9A%84%E6%9C%80%E5%A4%9A%E7%82%B9%E4%B8%AA%E6%95%B0/</guid>
      <description>LeetCode 149. Max Points on a Line Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. 解析： 坑点1 如果直线是和y轴平行的，那么不能直接用(y1-y2)/(x1-x2)表示斜</description>
    </item>
    
    <item>
      <title>设计缓存结构</title>
      <link>/post/%E8%AE%BE%E8%AE%A1%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sat, 24 Jun 2017 19:50:14 +0000</pubDate>
      
      <guid>/post/%E8%AE%BE%E8%AE%A1%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84/</guid>
      <description>LeetCode 146. LRU Cache Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should</description>
    </item>
    
    <item>
      <title>查找区间最大值</title>
      <link>/post/%E6%9F%A5%E6%89%BE%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC/</link>
      <pubDate>Sat, 24 Jun 2017 19:49:49 +0000</pubDate>
      
      <guid>/post/%E6%9F%A5%E6%89%BE%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC/</guid>
      <description>LeetCode 162. Find Peak Element A peak element is an element that is greater than its neighbors. Given an input array where num[i] ≠ num[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that num[-1] = num[n] = -∞. For example, in array [1, 2,</description>
    </item>
    
    <item>
      <title>二叉树的序列化与反序列化</title>
      <link>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Sat, 24 Jun 2017 16:12:28 +0000</pubDate>
      
      <guid>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>LeetCode 297. Serialize and Deserialize Binary Tree Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your</description>
    </item>
    
    <item>
      <title>Bulls and Cows</title>
      <link>/post/bulls-and-cows/</link>
      <pubDate>Sat, 24 Jun 2017 16:12:15 +0000</pubDate>
      
      <guid>/post/bulls-and-cows/</guid>
      <description>LeetCode 299. Bulls and Cows You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”)</description>
    </item>
    
    <item>
      <title>随时找到数据流的中位数</title>
      <link>/post/%E9%9A%8F%E6%97%B6%E6%89%BE%E5%88%B0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Sat, 24 Jun 2017 16:12:04 +0000</pubDate>
      
      <guid>/post/%E9%9A%8F%E6%97%B6%E6%89%BE%E5%88%B0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid>
      <description>LeetCode 295. Find Median from Data Stream Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. Examples: [2,3,4] , the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void</description>
    </item>
    
    <item>
      <title>区间查询问题</title>
      <link>/post/%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Jun 2017 16:11:52 +0000</pubDate>
      
      <guid>/post/%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 303. Range Sum Query - Immutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -&amp;gt; 1 sumRange(2, 5) -&amp;gt; -1 sumRange(0, 5) -&amp;gt; -3 Note: You may assume that the array does not change. There are many calls to sumRange function. 解析： 数</description>
    </item>
    
    <item>
      <title>Queue Reconstruction by Height</title>
      <link>/post/queue-reconstruction-by-height/</link>
      <pubDate>Sat, 24 Jun 2017 16:11:38 +0000</pubDate>
      
      <guid>/post/queue-reconstruction-by-height/</guid>
      <description>LeetCode 406. Queue Reconstruction by Height Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue. Note: The number of</description>
    </item>
    
    <item>
      <title>开关灯</title>
      <link>/post/%E5%BC%80%E5%85%B3%E7%81%AF/</link>
      <pubDate>Sat, 24 Jun 2017 16:11:28 +0000</pubDate>
      
      <guid>/post/%E5%BC%80%E5%85%B3%E7%81%AF/</guid>
      <description>LeetCode 319. Bulb Switcher There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it’s off or turning off if it’s on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last</description>
    </item>
    
    <item>
      <title>换钱</title>
      <link>/post/%E6%8D%A2%E9%92%B1/</link>
      <pubDate>Sat, 24 Jun 2017 16:11:15 +0000</pubDate>
      
      <guid>/post/%E6%8D%A2%E9%92%B1/</guid>
      <description>LeetCode 322. Coin Change You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: coins = [1, 2, 5], amount = 11 return 3 (11 = 5 + 5</description>
    </item>
    
    <item>
      <title>Patching Array</title>
      <link>/post/patching-array/</link>
      <pubDate>Sat, 24 Jun 2017 16:11:04 +0000</pubDate>
      
      <guid>/post/patching-array/</guid>
      <description>LeetCode 330. Patching Array Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required. Example 1: nums = [1, 3], n = 6 Return 1. Combinations of nums are [1], [3], [1,3], which form possible sums</description>
    </item>
    
    <item>
      <title>Reconstruct Itinerary</title>
      <link>/post/reconstruct-itinerary/</link>
      <pubDate>Sat, 24 Jun 2017 16:10:53 +0000</pubDate>
      
      <guid>/post/reconstruct-itinerary/</guid>
      <description>LeetCode 332. Reconstruct Itinerary Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example,</description>
    </item>
    
    <item>
      <title>Self Crossing</title>
      <link>/post/self-crossing/</link>
      <pubDate>Sat, 24 Jun 2017 16:10:42 +0000</pubDate>
      
      <guid>/post/self-crossing/</guid>
      <description>LeetCode 335. Self Crossing You are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x[1] metres to the west, x[2] metres to the south, x[3] metres to the east and so on. In other words, after each move your direction changes counter-clockwise. Write a one-pass algorithm with O(1) extra space to determine, if your path crosses itself,</description>
    </item>
    
    <item>
      <title>Nested List</title>
      <link>/post/nested-list/</link>
      <pubDate>Sat, 24 Jun 2017 16:10:30 +0000</pubDate>
      
      <guid>/post/nested-list/</guid>
      <description>LeetCode 341. Flatten Nested List Iterator Given a nested list of integers, implement an iterator to flatten it. Each element is either an integer, or a list – whose elements may also be integers or other lists. Example 1: Given the list [[1,1],2,[1,1]], By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. Example 2: Given the list [1,[4,[6]]], By calling next</description>
    </item>
    
    <item>
      <title>翻转字符串</title>
      <link>/post/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sat, 24 Jun 2017 16:10:18 +0000</pubDate>
      
      <guid>/post/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>LeetCode 344. Reverse String Write a function that takes a string as input and returns the string reversed. Example: Given s = “hello”, return “olleh”. 解析：双指针，从两端向中间移动，并交换元素。 1 2 3 4 5 6 7 8 9</description>
    </item>
    
    <item>
      <title>设计Twitter</title>
      <link>/post/%E8%AE%BE%E8%AE%A1twitter/</link>
      <pubDate>Sat, 24 Jun 2017 16:09:40 +0000</pubDate>
      
      <guid>/post/%E8%AE%BE%E8%AE%A1twitter/</guid>
      <description>LeetCode 355. Design Twitter Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user’s news feed. Your design should support the following methods: postTweet(userId, tweetId): Compose a new tweet. getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user’s news feed. Each</description>
    </item>
    
    <item>
      <title>洗牌问题</title>
      <link>/post/%E6%B4%97%E7%89%8C%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Jun 2017 15:38:28 +0000</pubDate>
      
      <guid>/post/%E6%B4%97%E7%89%8C%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 384. Shuffle an Array Shuffle a set of numbers without duplicates. Example: 1 2 3 4 5 6 7 8 9 10 11 12 // Init an array with set 1, 2, and 3. int[] nums = {1,2,3}; Solution solution = new Solution(nums); // Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned. solution.shuffle(); // Resets the array back to</description>
    </item>
    
    <item>
      <title>字符串的统计形式</title>
      <link>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%BD%A2%E5%BC%8F/</link>
      <pubDate>Sat, 24 Jun 2017 15:38:19 +0000</pubDate>
      
      <guid>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%BD%A2%E5%BC%8F/</guid>
      <description>字符串的统计字符串 题目: 给定一个字符串str，返回str的统计字符串。例如，&amp;ldquo;aaabbadddffc&amp;quot;的统计字符串为</description>
    </item>
    
    <item>
      <title>树的叶子节点</title>
      <link>/post/%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sat, 24 Jun 2017 15:38:08 +0000</pubDate>
      
      <guid>/post/%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9/</guid>
      <description>LeetCode 404. Sum of Left Leaves Find the sum of all left leaves in a given binary tree. Example: 3 / 9 20 / 15 7 There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24. 解析： 判断一个节点是否为左叶子节点: 1.是父节点的左孩</description>
    </item>
    
    <item>
      <title>Fizz Buzz</title>
      <link>/post/fizz-buzz/</link>
      <pubDate>Sat, 24 Jun 2017 15:37:53 +0000</pubDate>
      
      <guid>/post/fizz-buzz/</guid>
      <description>412. Fizz Buzz Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”</description>
    </item>
    
    <item>
      <title>Arithmetic Slices</title>
      <link>/post/arithmetic-slices/</link>
      <pubDate>Sat, 24 Jun 2017 15:34:35 +0000</pubDate>
      
      <guid>/post/arithmetic-slices/</guid>
      <description>LeetCode 413. Arithmetic Slices Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the “Pacific ocean” touches the left and top edges of the matrix and the “Atlantic ocean” touches the right and bottom edges.</description>
    </item>
    
    <item>
      <title>Pacific Atlantic Water Flow</title>
      <link>/post/pacific-atlantic-water-flow/</link>
      <pubDate>Sat, 24 Jun 2017 15:34:21 +0000</pubDate>
      
      <guid>/post/pacific-atlantic-water-flow/</guid>
      <description>LeetCode 417. Pacific Atlantic Water Flow A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequence: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 The following sequence is not arithmetic. 1, 1, 2, 5, 7 A zero-indexed array A consisting of N</description>
    </item>
    
    <item>
      <title>密码检查器</title>
      <link>/post/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</link>
      <pubDate>Sat, 24 Jun 2017 15:32:59 +0000</pubDate>
      
      <guid>/post/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</guid>
      <description>LeetCode 420. Strong Password Checker A password is considered strong if below conditions are all met: It has at least 6 characters and at most 20 characters. It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit. It must NOT contain three repeating characters in a row (“…aaa…” is weak, but “…aa</description>
    </item>
    
    <item>
      <title>两个数组的相交数字</title>
      <link>/post/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E4%BA%A4%E6%95%B0%E5%AD%97/</link>
      <pubDate>Sat, 24 Jun 2017 15:31:24 +0000</pubDate>
      
      <guid>/post/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E4%BA%A4%E6%95%B0%E5%AD%97/</guid>
      <description>LeetCode 349. Intersection of Two Arrays Given two arrays, write a function to compute their intersection. Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2]. Note: Each element in the result must be unique. The result can be in any order. 解析： 因为要求结果元素不重复，所以采用unord</description>
    </item>
    
    <item>
      <title>位运算求绝对值</title>
      <link>/post/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%B1%82%E7%BB%9D%E5%AF%B9%E5%80%BC/</link>
      <pubDate>Fri, 23 Jun 2017 15:52:43 +0000</pubDate>
      
      <guid>/post/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%B1%82%E7%BB%9D%E5%AF%B9%E5%80%BC/</guid>
      <description>在对一个数进行位运算的时候，是在这个数的补码上进行的，对于补码我们知道，正数的补码是原码，负数的补码为原码除了最高位的符号位，取反，然后加1</description>
    </item>
    
  </channel>
</rss>
