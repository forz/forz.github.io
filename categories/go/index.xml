<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on Forz Blog</title>
    <link>http://localhost:1313/categories/go/</link>
    <description>Recent content in Go on Forz Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 11 Oct 2019 16:54:16 +0000</lastBuildDate>
    
	<atom:link href="http://localhost:1313/categories/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go如何嵌入静态资源</title>
      <link>http://localhost:1313/post/go%E5%A6%82%E4%BD%95%E5%B5%8C%E5%85%A5%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/</link>
      <pubDate>Fri, 11 Oct 2019 16:54:16 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E5%A6%82%E4%BD%95%E5%B5%8C%E5%85%A5%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/</guid>
      <description>背景 Go 中一个常被吹捧的特性是 Go 应用容易部署，原因是 Go 写的程序是静态编译的。但在你 运行一个 Web 应用时，如果需要管理一系列文件的路径和权限的话，这</description>
    </item>
    
    <item>
      <title>go generate介绍</title>
      <link>http://localhost:1313/post/go-generate%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Thu, 26 Sep 2019 15:44:33 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go-generate%E4%BB%8B%E7%BB%8D/</guid>
      <description>介绍 go generate命令是go 1.4版本里面新添加的一个命令，当运行go generate时，它将扫描与当前包相关的源代码文件，找出所有包含</description>
    </item>
    
    <item>
      <title>Golang读写Excel</title>
      <link>http://localhost:1313/post/golang%E8%AF%BB%E5%86%99excel/</link>
      <pubDate>Thu, 05 Sep 2019 18:06:03 +0000</pubDate>
      
      <guid>http://localhost:1313/post/golang%E8%AF%BB%E5%86%99excel/</guid>
      <description>简介 Excelize 是 Go 语言编写的用于操作 Office Excel 文档类库，基于 ECMA-376 Office OpenXML 标准。可以使用它来读取、写入由 Microsoft Excel&amp;trade; 2007 及以上版本创建的 XLSX 文档。相比较其他的开源类库，Exc</description>
    </item>
    
    <item>
      <title>如何优雅地比较两个未知结构的JSON</title>
      <link>http://localhost:1313/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E6%9C%AA%E7%9F%A5%E7%BB%93%E6%9E%84%E7%9A%84json/</link>
      <pubDate>Tue, 27 Aug 2019 10:53:46 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E6%9C%AA%E7%9F%A5%E7%BB%93%E6%9E%84%E7%9A%84json/</guid>
      <description>这是之前遇到的一道面试题，后来也确实在工作中实际遇到了。于是记录一下，如何（优雅的）比较两个未知结构的json。 假设，现在有两个简单的jso</description>
    </item>
    
    <item>
      <title>Go中的slice和map的比较方法</title>
      <link>http://localhost:1313/post/go%E4%B8%AD%E7%9A%84slice%E5%92%8Cmap%E7%9A%84%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 26 Aug 2019 13:21:13 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E4%B8%AD%E7%9A%84slice%E5%92%8Cmap%E7%9A%84%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95/</guid>
      <description>思路 开发中经常会遇到需要比较两个slice或map包含的元素是否完全相等的情况，一般来说有两个思路： reflect比较的方法 循环遍历比较的方</description>
    </item>
    
    <item>
      <title>Go中的interface{}比较方法</title>
      <link>http://localhost:1313/post/go%E4%B8%AD%E7%9A%84interface-%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 26 Aug 2019 13:21:07 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E4%B8%AD%E7%9A%84interface-%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95/</guid>
      <description>类型不确定 在不确定类型需要反射的时候，DeepEqual是我们不可不用的强大工具。 比如： 1 2 3 4 5 6 7 func main(){ m1:=map[string]interface{}{&amp;#34;a&amp;#34;:&amp;#34;1&amp;#34;, &amp;#34;b&amp;#34;:2, &amp;#34;c&amp;#34;:3}; m2:=map[string]interface{}{&amp;#34;a&amp;#34;:1, &amp;#34;c&amp;#34;:&amp;#34;3&amp;#34;, &amp;#34;b&amp;#34;:2}; fmt.Println(`reflect.DeepEqual(m1[&amp;#34;a&amp;#34;],m2[&amp;#34;a&amp;#34;]`,reflect.DeepEqual(m1[&amp;#34;a&amp;#34;],m2[&amp;#34;a&amp;#34;])); fmt.Println(`reflect.DeepEqual(m1[&amp;#34;b&amp;#34;],m2[&amp;#34;b&amp;#34;]`,reflect.DeepEqual(m1[&amp;#34;b&amp;#34;],m2[&amp;#34;b&amp;#34;])); } 执行结果： 1 2 3</description>
    </item>
    
    <item>
      <title>DeepEqual浅析</title>
      <link>http://localhost:1313/post/deepequal%E6%B5%85%E6%9E%90/</link>
      <pubDate>Mon, 19 Aug 2019 20:02:22 +0000</pubDate>
      
      <guid>http://localhost:1313/post/deepequal%E6%B5%85%E6%9E%90/</guid>
      <description>规则 不同类型的值不会深度相等 Values of distinct types are never deeply equal. 1 2 3 4 5 6 7 8 9 10 type S1 struct { Field int } type S2 struct { Field int } func main() { fmt.Println(reflect.DeepEqual(S1{1}, S2{1})) } 对应输出false 当两个数组的元素对</description>
    </item>
    
    <item>
      <title>Go和HTTPS</title>
      <link>http://localhost:1313/post/go%E5%92%8Chttps/</link>
      <pubDate>Mon, 19 Aug 2019 13:36:12 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E5%92%8Chttps/</guid>
      <description>HTTPS简介 日常生活中，我们上网用的最多的应用层协议就是HTTP协议了，直至目前全世界的网站中大多数依然只支持HTTP访问。 使用Go创建一</description>
    </item>
    
    <item>
      <title>Go中map的key类型分析</title>
      <link>http://localhost:1313/post/go%E4%B8%ADmap%E7%9A%84key%E7%B1%BB%E5%9E%8B%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 16 Aug 2019 19:29:21 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E4%B8%ADmap%E7%9A%84key%E7%B1%BB%E5%9E%8B%E5%88%86%E6%9E%90/</guid>
      <description>map的key类型 map中的key可以是任何的类型，只要它的值能比较是否相等，Go的语言规范已精确定义，Key的类型可以是： 布尔值 数字 字符串</description>
    </item>
    
    <item>
      <title>Go中的内置类型比较</title>
      <link>http://localhost:1313/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83/</link>
      <pubDate>Fri, 16 Aug 2019 16:25:53 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83/</guid>
      <description>概念 首先区分几个概念：变量可比较，可排序，可赋值 可赋值 规范里面对赋值是这么定义的：https://golang.org/ref/spec#A</description>
    </item>
    
    <item>
      <title>Go语言的浮点数计算</title>
      <link>http://localhost:1313/post/go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Wed, 14 Aug 2019 18:28:02 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97/</guid>
      <description>浮点数计算不精确 浮点数与整数计算 先看两个case 1 2 3 4 5 6 7 // case1: 135.90*100 ==== // float32 var f1 float32 = 135.90 fmt.Println(f1 * 100) // output:13589.999 // float64 var f2 float64 = 135.90 fmt.Println(f2 * 100) // output:13590 浮点数在单精度下, 13</description>
    </item>
    
    <item>
      <title>go语言为什么没有min/max(int, int)函数</title>
      <link>http://localhost:1313/post/go%E8%AF%AD%E8%A8%80%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89min-max-int-int-%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 13 Aug 2019 20:13:15 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E8%AF%AD%E8%A8%80%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89min-max-int-int-%E5%87%BD%E6%95%B0/</guid>
      <description>为什么没有? 我们知道go语言math包里面定义了min/max函数，但是是float64类型的，而并没有整数类型的min/max。 go语言的</description>
    </item>
    
    <item>
      <title>Go Modules 浅析</title>
      <link>http://localhost:1313/post/go-modules-%E6%B5%85%E6%9E%90/</link>
      <pubDate>Thu, 25 Jul 2019 10:49:06 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go-modules-%E6%B5%85%E6%9E%90/</guid>
      <description>go mod 命令 1 2 3 4 5 6 7 8 download download modules to local cache (下载依赖的module到本地cache)) edit edit go.mod from tools or scripts (编辑go.mod文件) graph print module requirement graph (打印模块依</description>
    </item>
    
    <item>
      <title>mongo-go-driver使用总结</title>
      <link>http://localhost:1313/post/mongo-go-driver%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 16 Jul 2019 16:38:41 +0000</pubDate>
      
      <guid>http://localhost:1313/post/mongo-go-driver%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</guid>
      <description>创建main 创建文件main.go并导入bson，mongo和mongo/options包： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main</description>
    </item>
    
    <item>
      <title>types from different packages 问题浅析</title>
      <link>http://localhost:1313/post/types-from-different-packages-%E9%97%AE%E9%A2%98%E6%B5%85%E6%9E%90/</link>
      <pubDate>Tue, 16 Jul 2019 14:44:54 +0000</pubDate>
      
      <guid>http://localhost:1313/post/types-from-different-packages-%E9%97%AE%E9%A2%98%E6%B5%85%E6%9E%90/</guid>
      <description>先看一段代码: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main var X interface{} type T struct{} func F() { type T struct{} X = T{} } func G() { type T struct{} _ = X.(T) } func main() { F() G() } 我们总是可以说“来</description>
    </item>
    
    <item>
      <title>Goroutine的调度机制源码剖析(三)</title>
      <link>http://localhost:1313/post/goroutine%E7%9A%84%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%89/</link>
      <pubDate>Fri, 12 Jul 2019 13:34:23 +0000</pubDate>
      
      <guid>http://localhost:1313/post/goroutine%E7%9A%84%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%89/</guid>
      <description>源码剖析 G的锁定 在执行cgo调用回调时,会用lockOSThread将G锁定在当前线程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27</description>
    </item>
    
    <item>
      <title>Goroutine的调度机制源码剖析(二)</title>
      <link>http://localhost:1313/post/goroutine%E7%9A%84%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%BA%8C/</link>
      <pubDate>Fri, 12 Jul 2019 13:32:56 +0000</pubDate>
      
      <guid>http://localhost:1313/post/goroutine%E7%9A%84%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%BA%8C/</guid>
      <description>源码剖析 M执行G M执行G有两个起点: 1. 线程启动函数mstart. 2. stopm休眠唤醒后再度恢复调度循环. mstart 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17</description>
    </item>
    
    <item>
      <title>Goroutine的调度机制源码剖析(一)</title>
      <link>http://localhost:1313/post/goroutine%E7%9A%84%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%80/</link>
      <pubDate>Fri, 12 Jul 2019 13:29:52 +0000</pubDate>
      
      <guid>http://localhost:1313/post/goroutine%E7%9A%84%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%80/</guid>
      <description>源码分析 根据源码实现,调度器有如下细节优化: G对象和M对象默认会复用.除P本地的复用链表外,还有全局链表在多个P之间共享. P分为本地队列和全</description>
    </item>
    
    <item>
      <title>Goroutine的调度机制基本原理</title>
      <link>http://localhost:1313/post/goroutine%E7%9A%84%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</link>
      <pubDate>Fri, 05 Jul 2019 16:46:28 +0000</pubDate>
      
      <guid>http://localhost:1313/post/goroutine%E7%9A%84%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</guid>
      <description>协程 进程时代 最初的计算机上面没有操作系统，更别提进程、线程和协程了。 后来，现代化的计算机有了操作系统，每个程序都是一个进程，但是操作系统在一</description>
    </item>
    
    <item>
      <title>为什么不要在单个sql.Tx中使用协程</title>
      <link>http://localhost:1313/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E5%9C%A8%E5%8D%95%E4%B8%AAsql.tx%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Thu, 04 Jul 2019 16:03:49 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E5%9C%A8%E5%8D%95%E4%B8%AAsql.tx%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B/</guid>
      <description>问题来源 简单来说就是企图在一个事务中开启多个协程执行并发查询,会出现busy buffer的问题 接下来这篇文章将尝试深入探讨产生 busy buffer 的根本原因</description>
    </item>
    
    <item>
      <title>配置sql.DB获得更好的性能</title>
      <link>http://localhost:1313/post/%E9%85%8D%E7%BD%AEsql-db%E8%8E%B7%E5%BE%97%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%80%A7%E8%83%BD/</link>
      <pubDate>Thu, 04 Jul 2019 14:44:14 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E9%85%8D%E7%BD%AEsql-db%E8%8E%B7%E5%BE%97%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%80%A7%E8%83%BD/</guid>
      <description>事实上你可以使用SetMaxOpenConns（）、SetMaxIdleConns（）和SetConnmaxLifetime（）方法。来配置</description>
    </item>
    
    <item>
      <title>Go中mysql驱动的DSN解析</title>
      <link>http://localhost:1313/post/go%E4%B8%ADmysql%E9%A9%B1%E5%8A%A8%E7%9A%84dsn%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 11 Jun 2019 16:15:20 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E4%B8%ADmysql%E9%A9%B1%E5%8A%A8%E7%9A%84dsn%E8%A7%A3%E6%9E%90/</guid>
      <description>DSN 数据源名称具有通用格式，例如PEAR DB使用它，但没有类型前缀（可选部分用方括号标记）： 1 [username[:password]@][protocol[(address)]]/dbname[?param1=value1&amp;amp;...&amp;amp;paramN=valueN] DSN最完整的形式： 1 username:password@protocol(address)/dbname?param=value 除databasena</description>
    </item>
    
    <item>
      <title>Golang事务使用的正确方法</title>
      <link>http://localhost:1313/post/golang%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 06 Jun 2019 16:35:08 +0000</pubDate>
      
      <guid>http://localhost:1313/post/golang%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%96%B9%E6%B3%95/</guid>
      <description>defer防止panic 利用 Commit() 之后 Rollback() 不会真正执行的特性,可以在创建tx时使用defer防止panic出现没有释放tx 1 2 3 4 5 6 7 8 9 10 11 12</description>
    </item>
    
    <item>
      <title>println与fmt.Println</title>
      <link>http://localhost:1313/post/println%E4%B8%8Efmt-println/</link>
      <pubDate>Tue, 04 Jun 2019 16:42:08 +0000</pubDate>
      
      <guid>http://localhost:1313/post/println%E4%B8%8Efmt-println/</guid>
      <description>简介 println是一种内置于语言中的函数。它位于规范的Bootstrapping部分。 当前实现提供了几个在引导期间有用的内置函数。记录这些</description>
    </item>
    
    <item>
      <title>Go中的nil解析</title>
      <link>http://localhost:1313/post/go%E4%B8%AD%E7%9A%84nil%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 04 Jun 2019 14:31:13 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E4%B8%AD%E7%9A%84nil%E8%A7%A3%E6%9E%90/</guid>
      <description>定义 nil 为预声明的标示符，定义在builtin/builtin.go， 1 2 3 4 5 6 7 8 9 // nil is a predeclared identifier representing the zero value for a // pointer, channel, func, interface, map, or slice type. // Type must be a pointer,</description>
    </item>
    
    <item>
      <title>Go处理数据库的NULL</title>
      <link>http://localhost:1313/post/go%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84null/</link>
      <pubDate>Tue, 04 Jun 2019 11:32:07 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84null/</guid>
      <description>golang是强类型语言，在赋值和解析过程中需要先定义好数据类型，否在会报类型错误，下面总结在处理数据库表时遇到字段为空或零值的情况 场景 假如</description>
    </item>
    
    <item>
      <title>Go语言MySQL中如何为单个事务设置隔离级别</title>
      <link>http://localhost:1313/post/go%E8%AF%AD%E8%A8%80mysql%E4%B8%AD%E5%A6%82%E4%BD%95%E4%B8%BA%E5%8D%95%E4%B8%AA%E4%BA%8B%E5%8A%A1%E8%AE%BE%E7%BD%AE%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</link>
      <pubDate>Thu, 25 Apr 2019 16:16:38 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E8%AF%AD%E8%A8%80mysql%E4%B8%AD%E5%A6%82%E4%BD%95%E4%B8%BA%E5%8D%95%E4%B8%AA%E4%BA%8B%E5%8A%A1%E8%AE%BE%E7%BD%AE%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</guid>
      <description>MySQL 相比起简单的锁表，事务提供了更好的并发性能，但同时也带来更大的复杂性，如隔离级别，mvcc，死锁等。网上关于事务隔离级别的介绍遍地都是，就</description>
    </item>
    
    <item>
      <title>Go中捕获panic信息到日志文件中</title>
      <link>http://localhost:1313/post/go%E4%B8%AD%E6%8D%95%E8%8E%B7panic%E4%BF%A1%E6%81%AF%E5%88%B0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E4%B8%AD/</link>
      <pubDate>Mon, 22 Apr 2019 10:36:47 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E4%B8%AD%E6%8D%95%E8%8E%B7panic%E4%BF%A1%E6%81%AF%E5%88%B0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E4%B8%AD/</guid>
      <description>根据“墨菲定律”，我们编写的后台的服务都有出现crash的可能，一种情况是Go的后台服务我们经常也会遇到panic的情况。出问题不可怕，我们</description>
    </item>
    
    <item>
      <title>Go语言在Linux终端输出彩色字符</title>
      <link>http://localhost:1313/post/go%E8%AF%AD%E8%A8%80%E5%9C%A8linux%E7%BB%88%E7%AB%AF%E8%BE%93%E5%87%BA%E5%BD%A9%E8%89%B2%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Thu, 18 Apr 2019 13:13:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E8%AF%AD%E8%A8%80%E5%9C%A8linux%E7%BB%88%E7%AB%AF%E8%BE%93%E5%87%BA%E5%BD%A9%E8%89%B2%E5%AD%97%E7%AC%A6/</guid>
      <description>Linux终端输出颜色 开发工作中经常见到终端中各种命令输出的彩色文字，例如 ls 命令就以不同颜色表示文件的不同类型。 而在我们自己写的程序输出的信</description>
    </item>
    
    <item>
      <title>Golang的单引号、双引号与反引号</title>
      <link>http://localhost:1313/post/golang%E7%9A%84%E5%8D%95%E5%BC%95%E5%8F%B7%E5%8F%8C%E5%BC%95%E5%8F%B7%E4%B8%8E%E5%8F%8D%E5%BC%95%E5%8F%B7/</link>
      <pubDate>Sun, 14 Apr 2019 16:45:01 +0000</pubDate>
      
      <guid>http://localhost:1313/post/golang%E7%9A%84%E5%8D%95%E5%BC%95%E5%8F%B7%E5%8F%8C%E5%BC%95%E5%8F%B7%E4%B8%8E%E5%8F%8D%E5%BC%95%E5%8F%B7/</guid>
      <description>简介 一个Go语言字符串是一个任意字节的常量序列。Go语言的字符串类型在本质上就与其他语言的字符串类型不同。 Java的String、C++的s</description>
    </item>
    
    <item>
      <title>更优雅的Go错误处理</title>
      <link>http://localhost:1313/post/%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84go%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <pubDate>Fri, 05 Apr 2019 21:50:59 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84go%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <description>错误类型解析 error 接口 Go 继承了 C，以返回值为错误处理的主要方式。但与 C 不同的是，在 Go 的惯用法中，返回值不是整型等常用返回值类型（errno），而</description>
    </item>
    
    <item>
      <title>Go中的内置函数</title>
      <link>http://localhost:1313/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 04 Apr 2019 17:19:42 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</guid>
      <description>func new 1 func new(Type) *Type 内建函数new分配内存。其第一个实参为类型，而非值。其返回值为指向该类型的新分配的零值的指针。 在调用new函数时，将类型名作为参</description>
    </item>
    
    <item>
      <title>sync.Cond解析</title>
      <link>http://localhost:1313/post/sync-cond%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 13 Feb 2019 20:11:24 +0000</pubDate>
      
      <guid>http://localhost:1313/post/sync-cond%E8%A7%A3%E6%9E%90/</guid>
      <description>Cond 实现一个条件变量，即等待或宣布事件发生的 goroutines 的会合点，它会保存一个通知列表。基本思想是当某中状态达成，goroutine 将会等待（Wait）</description>
    </item>
    
    <item>
      <title>神奇的2006-01-02 15:04:05</title>
      <link>http://localhost:1313/post/%E7%A5%9E%E5%A5%87%E7%9A%842006-01-02-15-04-05/</link>
      <pubDate>Wed, 13 Feb 2019 16:58:24 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E7%A5%9E%E5%A5%87%E7%9A%842006-01-02-15-04-05/</guid>
      <description>神奇的日期 刚接触Golang时，阅读代码的时候总会在代码中发现这么一个日期， 1 2006-01-02 15:04:05 刚看到这段代码的时候，我当时想：这个人好随便啊，随便写一个</description>
    </item>
    
    <item>
      <title>Go中接口的类型转换与判断</title>
      <link>http://localhost:1313/post/go%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%88%A4%E6%96%AD/</link>
      <pubDate>Mon, 28 Jan 2019 19:22:50 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%88%A4%E6%96%AD/</guid>
      <description>类型转换和类型断言 Go语言的类型转换和类型断言: 类型转换在编译期完成，包括强制转换和隐式转换 类型断言在运行时确定，包括安全类型断言和非安全类</description>
    </item>
    
    <item>
      <title>Go中的内置类型转换</title>
      <link>http://localhost:1313/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Sat, 26 Jan 2019 21:22:18 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description>隐型转换 转换是T（x）形式的表达式，其中T是类型，x是可以转换为类型T的表达式。 1 Conversion = Type &amp;#34;(&amp;#34; Expression [ &amp;#34;,&amp;#34; ] &amp;#34;)&amp;#34; . 如果类型以operator *或&amp;lt;</description>
    </item>
    
    <item>
      <title>Go中获取程序所在目录</title>
      <link>http://localhost:1313/post/go%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F%E6%89%80%E5%9C%A8%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Fri, 25 Jan 2019 15:47:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F%E6%89%80%E5%9C%A8%E7%9B%AE%E5%BD%95/</guid>
      <description>代码1： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; &amp;#34;path/filepath&amp;#34; ) func main() { dir, err := filepath.Abs(filepath.Dir(os.Args[0])) if err != nil { log.Fatal(err) } fmt.Println(dir) } 代码2： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( &amp;#34;fmt&amp;#34;</description>
    </item>
    
    <item>
      <title>Go中文件及文件夹相关操作</title>
      <link>http://localhost:1313/post/go%E4%B8%AD%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Fri, 25 Jan 2019 14:43:50 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E4%B8%AD%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</guid>
      <description>万物皆文件 UNIX 的一个基础设计就是&amp;rdquo;万物皆文件&amp;rdquo;(everything is a file)。我们不必知道一个文件到底映射成什么</description>
    </item>
    
    <item>
      <title>为什么Go拒绝递归锁</title>
      <link>http://localhost:1313/post/%E9%80%92%E5%BD%92%E9%94%81%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E9%94%81%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Fri, 25 Jan 2019 13:18:41 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E9%80%92%E5%BD%92%E9%94%81%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E9%94%81%E8%A7%A3%E6%9E%90/</guid>
      <description>Mutex可以分为递归锁（recursive mutex）和非递归锁（non-recursive mutex）。 递归锁也叫可重入锁（reentr</description>
    </item>
    
    <item>
      <title>sync.Map解析</title>
      <link>http://localhost:1313/post/sync-map%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sat, 19 Jan 2019 21:11:24 +0000</pubDate>
      
      <guid>http://localhost:1313/post/sync-map%E8%A7%A3%E6%9E%90/</guid>
      <description>在Go 1.6之前， 内置的map类型是部分goroutine安全的，并发的读没有问题，并发的写可能有问题。自go 1.6之后， 并发地读写map会</description>
    </item>
    
    <item>
      <title>Go语言的可变参数详解</title>
      <link>http://localhost:1313/post/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 15 Jan 2019 20:46:21 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/</guid>
      <description>什么是可变参数函数？ 可变参数函数即其参数数量是可变的 —— 0 个或多个。声明可变参数函数的方式是在其参数类型前带上省略符（三个点）前缀。 译者注：</description>
    </item>
    
    <item>
      <title>Go中Map类型Chan类型和Slice类型在函数中的传递</title>
      <link>http://localhost:1313/post/go%E4%B8%ADmap%E7%B1%BB%E5%9E%8Bchan%E7%B1%BB%E5%9E%8B%E5%92%8Cslice%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E4%BC%A0%E9%80%92/</link>
      <pubDate>Thu, 10 Jan 2019 20:17:20 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E4%B8%ADmap%E7%B1%BB%E5%9E%8Bchan%E7%B1%BB%E5%9E%8B%E5%92%8Cslice%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E4%BC%A0%E9%80%92/</guid>
      <description>什么是传值（值传递） 传值的意思是：函数传递的总是原来这个东西的一个副本，一副拷贝。比如我们传递一个int类型的参数，传递的其实是这个参数的一</description>
    </item>
    
    <item>
      <title>GO中使用select实现带优先级的channel队列</title>
      <link>http://localhost:1313/post/go%E4%B8%AD%E4%BD%BF%E7%94%A8select%E5%AE%9E%E7%8E%B0%E5%B8%A6%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84channel%E9%98%9F%E5%88%97/</link>
      <pubDate>Wed, 09 Jan 2019 20:39:44 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E4%B8%AD%E4%BD%BF%E7%94%A8select%E5%AE%9E%E7%8E%B0%E5%B8%A6%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84channel%E9%98%9F%E5%88%97/</guid>
      <description>一般Go语言同时使用多个channel的方法是使用select/case语句配合&amp;lt;-操作符，比如 1 2 3 4 5 6 select { case &amp;lt;- chan1: // do something case &amp;lt;- chan2: // do</description>
    </item>
    
    <item>
      <title>在GO中用名字调用函数</title>
      <link>http://localhost:1313/post/%E5%9C%A8go%E4%B8%AD%E7%94%A8%E5%90%8D%E5%AD%97%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 09 Jan 2019 16:12:05 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E5%9C%A8go%E4%B8%AD%E7%94%A8%E5%90%8D%E5%AD%97%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/</guid>
      <description>Golang 中的函数跟 C 的一样，是个代码块，由于golong中函数也是类型,它可以像其他类型那样赋值给一个变量。 在 Golang 中，你不能这样做： 1 2 3 4 5 func foobar() {</description>
    </item>
    
    <item>
      <title>append的陷阱</title>
      <link>http://localhost:1313/post/append%E7%9A%84%E9%99%B7%E9%98%B1/</link>
      <pubDate>Sat, 05 Jan 2019 11:24:39 +0000</pubDate>
      
      <guid>http://localhost:1313/post/append%E7%9A%84%E9%99%B7%E9%98%B1/</guid>
      <description>背景 问题代码如下： 1 2 3 4 5 6 7 8 9 10 11 package main import &amp;#34;fmt&amp;#34; func main() { s := []byte(&amp;#34;&amp;#34;) s1 := append(s, &amp;#39;a&amp;#39;) s2 := append(s, &amp;#39;b&amp;#39;) //fmt.Println(s1, &amp;#34;==========&amp;#34;, s2) fmt.Println(string(s1), &amp;#34;==========&amp;#34;, string(s2)) } // 出现个让我理解不了的现象, 注释时候输出是 b ========== b //</description>
    </item>
    
    <item>
      <title>Go中的make和new的区别</title>
      <link>http://localhost:1313/post/go%E4%B8%AD%E7%9A%84make%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Wed, 26 Dec 2018 21:26:14 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E4%B8%AD%E7%9A%84make%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>new(T) 返回的是 T 的指针 new(T) 为一个 T 类型新值分配空间并将此空间初始化为 T 的零值，返回的是新值的地址，也就是 T 类型的指针 *T，该指针指向 T 的新分配的零</description>
    </item>
    
    <item>
      <title>Go的逃逸机制分析</title>
      <link>http://localhost:1313/post/go%E7%9A%84%E9%80%83%E9%80%B8%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 21 Dec 2018 14:54:40 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E7%9A%84%E9%80%83%E9%80%B8%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</guid>
      <description>变量的生命周期 生命周期是指程序执行过程中变量存在的时间段。下面我们分别来看看包变量（全局变量）和局部变量两种变量的生命周期。 包变量一直常驻在</description>
    </item>
    
    <item>
      <title>Go中的SQL操作总结</title>
      <link>http://localhost:1313/post/go%E4%B8%AD%E7%9A%84sql%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 20 Dec 2018 15:40:47 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E4%B8%AD%E7%9A%84sql%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>连接与连接池 database/sql database/sql是golang的标准库之一，它提供了一系列接口方法，用于访问关系数据库。它并不会提供数据库特有的方法，</description>
    </item>
    
    <item>
      <title>Go连接MySql数据库too many connections错误解决</title>
      <link>http://localhost:1313/post/go%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93too-many-connections%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</link>
      <pubDate>Thu, 20 Dec 2018 14:07:16 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93too-many-connections%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</guid>
      <description>连接Mysql数据库，在有一定量的查询结果以后，会出先too many connection的错误。 google了一下，很多文章都建议修改MySql的</description>
    </item>
    
    <item>
      <title>如何优雅地控制goroutine</title>
      <link>http://localhost:1313/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E6%8E%A7%E5%88%B6goroutine/</link>
      <pubDate>Fri, 14 Dec 2018 18:17:38 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E6%8E%A7%E5%88%B6goroutine/</guid>
      <description>如何控制goroutine的数量 用什么方法控制goroutine的数量？ 要在每一次执行go之前判断goroutine的数量，如果数量超了，就</description>
    </item>
    
    <item>
      <title>Golang中的闭包</title>
      <link>http://localhost:1313/post/golang%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/</link>
      <pubDate>Thu, 13 Dec 2018 20:24:03 +0000</pubDate>
      
      <guid>http://localhost:1313/post/golang%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/</guid>
      <description>函数式编程概论 在过去近十年时间里，面向对象编程大行其道，以至于在大学的教育里，老师也只会教给我们两种编程模型，面向过程和面向对象。孰不知，在</description>
    </item>
    
    <item>
      <title>Go实现HTTP长连接和短连接</title>
      <link>http://localhost:1313/post/go%E5%AE%9E%E7%8E%B0http%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Thu, 13 Dec 2018 15:33:35 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E5%AE%9E%E7%8E%B0http%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5/</guid>
      <description>TCP的长连接与短连接 Server和Client建立通讯后，确保连接的及时断开就非常重要。否则，多个客户端长时间占用着连接不关闭，是非常可怕</description>
    </item>
    
    <item>
      <title>addressable 详解</title>
      <link>http://localhost:1313/post/addressable-%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 12 Dec 2018 20:02:18 +0000</pubDate>
      
      <guid>http://localhost:1313/post/addressable-%E8%AF%A6%E8%A7%A3/</guid>
      <description>Go语言规范中规定了可寻址(addressable)对象的定义, For an operand x of type T, the address operation &amp;amp;x generates a pointer of type *T to x. The operand must be addressable, that is, either a variable, pointer indirection, or slice indexing operation; or a field</description>
    </item>
    
    <item>
      <title>空结构体struct{}解析</title>
      <link>http://localhost:1313/post/%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93struct-%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 12 Dec 2018 17:41:14 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93struct-%E8%A7%A3%E6%9E%90/</guid>
      <description>空对象 空对象是个神奇的东西。它指的是没有字段的结构类型。 1 type Q struct{} 不占用空间,长度为0 1 2 var s struct{} fmt.Println(unsafe.Sizeof(s)) // prints 0 如果结构体中仅有一个空结构字段,那么结</description>
    </item>
    
    <item>
      <title>如何优雅地关闭Go channel</title>
      <link>http://localhost:1313/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%85%B3%E9%97%ADgo-channel/</link>
      <pubDate>Thu, 29 Nov 2018 15:41:26 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%85%B3%E9%97%ADgo-channel/</guid>
      <description>几天前，我写了一篇文章来说明golang中channel的使用规范。在reddit和HN，那篇文章收到了很多赞同，但是我也收到了下面几个关于</description>
    </item>
    
    <item>
      <title>slice切片的相关操作总结</title>
      <link>http://localhost:1313/post/slice%E5%88%87%E7%89%87%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 28 Nov 2018 14:27:26 +0000</pubDate>
      
      <guid>http://localhost:1313/post/slice%E5%88%87%E7%89%87%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>追加单个元素 1 s3 := append(s2, 7) //append一个元素 追加多个元素(合并切片) 1 s4 := append(s2, s1...) //append 一个切片所有的元素 删除单个元素 1 ss=append(ss</description>
    </item>
    
    <item>
      <title>深入Golang之unsafe</title>
      <link>http://localhost:1313/post/%E6%B7%B1%E5%85%A5golang%E4%B9%8Bunsafe/</link>
      <pubDate>Tue, 27 Nov 2018 19:58:06 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E6%B7%B1%E5%85%A5golang%E4%B9%8Bunsafe/</guid>
      <description>Pointer与uintptr unsafe.Pointer在Golang中是用于各种类型转化的桥梁，Pointer代表了一个指向任意类型的指</description>
    </item>
    
    <item>
      <title>string与byte与rune</title>
      <link>http://localhost:1313/post/string%E4%B8%8Ebyte%E4%B8%8Erune/</link>
      <pubDate>Tue, 27 Nov 2018 15:24:50 +0000</pubDate>
      
      <guid>http://localhost:1313/post/string%E4%B8%8Ebyte%E4%B8%8Erune/</guid>
      <description>string与[]byte 何为string？ 字符串是一系列8位字节的集合，通常但不一定代表UTF-8编码的文本。字符串可以为空，但不能为ni</description>
    </item>
    
    <item>
      <title>Golang 超大文件读取的两个方案</title>
      <link>http://localhost:1313/post/golang-%E8%B6%85%E5%A4%A7%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%A1%88/</link>
      <pubDate>Tue, 27 Nov 2018 10:37:47 +0000</pubDate>
      
      <guid>http://localhost:1313/post/golang-%E8%B6%85%E5%A4%A7%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%A1%88/</guid>
      <description>问题 比如我们有一个log文件，运行了几年，有100G之大。按照我们之前的操作可能代码会这样写： 1 2 3 4 5 6 7 func ReadFile(filePath string) []byte{ content, err := ioutil.ReadFile(filePath) if err != nil { log.Println(&amp;#34;Read error&amp;#34;) }</description>
    </item>
    
    <item>
      <title>Go中写文件的方式比较</title>
      <link>http://localhost:1313/post/go%E4%B8%AD%E5%86%99%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83/</link>
      <pubDate>Mon, 26 Nov 2018 17:33:49 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E4%B8%AD%E5%86%99%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83/</guid>
      <description>ioutil.WriteFile 1 2 // 写入[]byte类型的data到filename文件中，文件权限为perm func WriteFile(filename string, data []byte, perm os.FileMode) error 示例: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import</description>
    </item>
    
    <item>
      <title>Go中读文件的方式比较</title>
      <link>http://localhost:1313/post/go%E4%B8%AD%E8%AF%BB%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83/</link>
      <pubDate>Mon, 26 Nov 2018 14:27:18 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E4%B8%AD%E8%AF%BB%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83/</guid>
      <description>使用golang语言去读取一个文件默认会有多种方式，这里主要介绍以下几种。 ioutil.ReadFile 1 2 //读取文件内容，并返回[]byte数据和错误信息。err ==</description>
    </item>
    
    <item>
      <title>寻找高效的字符串拼接方法</title>
      <link>http://localhost:1313/post/%E5%AF%BB%E6%89%BE%E9%AB%98%E6%95%88%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 23 Nov 2018 17:45:33 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E5%AF%BB%E6%89%BE%E9%AB%98%E6%95%88%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%96%B9%E6%B3%95/</guid>
      <description>实现方法 1. 直接使用运算符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func BenchmarkAddStringWithOperator(b *testing.B) { hello := &amp;#34;hello&amp;#34; world := &amp;#34;world&amp;#34; for i := 0; i &amp;lt; b.N; i++ { _ = hello + &amp;#34;,&amp;#34; + world } } func BenchmarkAddMoreStringWithOperator(b *testing.B) { hello := &amp;#34;hello&amp;#34; world := &amp;#34;world&amp;#34; for i</description>
    </item>
    
    <item>
      <title>开源Json库性能分析</title>
      <link>http://localhost:1313/post/%E5%BC%80%E6%BA%90json%E5%BA%93%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 23 Nov 2018 16:01:54 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E5%BC%80%E6%BA%90json%E5%BA%93%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</guid>
      <description>开源Json库性能分析 Json 作为一种重要的数据格式，具有良好的可读性以及自描述性，广泛地应用在各种数据传输场景中。Go 语言里面原生支持了这种数据</description>
    </item>
    
    <item>
      <title>Go中新建文件的权限与设置不符的原因与解决方案</title>
      <link>http://localhost:1313/post/go%E4%B8%AD%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E7%9A%84%E6%9D%83%E9%99%90%E4%B8%8E%E8%AE%BE%E7%BD%AE%E4%B8%8D%E7%AC%A6%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Fri, 23 Nov 2018 15:43:28 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E4%B8%AD%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E7%9A%84%E6%9D%83%E9%99%90%E4%B8%8E%E8%AE%BE%E7%BD%AE%E4%B8%8D%E7%AC%A6%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <description>问题描述: 今天学习 Golang 文件操作实践时，当我创建一个文件（夹）出现文件权限与我代码设置不一致的问题 以下为我创建文件夹的代码： 1 2 3 4 5 6 func main() { err</description>
    </item>
    
    <item>
      <title>如何运行exec.Command时输出详细错误信息</title>
      <link>http://localhost:1313/post/%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8Cexec-command%E6%97%B6%E8%BE%93%E5%87%BA%E8%AF%A6%E7%BB%86%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Fri, 23 Nov 2018 15:37:53 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8Cexec-command%E6%97%B6%E8%BE%93%E5%87%BA%E8%AF%A6%E7%BB%86%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF/</guid>
      <description>当运行下面的代码时： 1 2 3 4 5 6 7 8 9 cmd := exec.Command(&amp;#34;find&amp;#34;, &amp;#34;/&amp;#34;, &amp;#34;-maxdepth&amp;#34;, &amp;#34;1&amp;#34;, &amp;#34;-exec&amp;#34;, &amp;#34;wc&amp;#34;, &amp;#34;-c&amp;#34;, &amp;#34;{}&amp;#34;, &amp;#34;\\&amp;#34;) var out bytes.Buffer cmd.Stdout = &amp;amp;out err := cmd.Run() if err != nil { fmt.Println(err) return } fmt.Println(&amp;#34;Result: &amp;#34; + out.String()) 我得到这个错误： 1 exit status 1 解决方案是使用</description>
    </item>
    
    <item>
      <title>Golang中使用多维map</title>
      <link>http://localhost:1313/post/golang%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BB%B4map/</link>
      <pubDate>Wed, 21 Nov 2018 12:22:40 +0000</pubDate>
      
      <guid>http://localhost:1313/post/golang%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BB%B4map/</guid>
      <description>map 的底层就是一个 hash，平时咱喜欢利用这一点来给一组数据去除重复. 使用 map 的时候需要注意，你需要显式地初始化才能对 map 进行操作. 1 2 var m map[string]string m[&amp;#34;a&amp;#34;]=&amp;#34;sssss&amp;#34; 上</description>
    </item>
    
    <item>
      <title>Go的静态库和动态库的编译与使用</title>
      <link>http://localhost:1313/post/go%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 15 Nov 2018 18:28:11 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description>go语言静态库的编译和使用 本文主要介绍go语言静态库的编译和使用方法，以windows平台为例，linux平台步骤一样，具体环境如下： 1 2 3</description>
    </item>
    
    <item>
      <title>Go的交叉编译</title>
      <link>http://localhost:1313/post/go%E7%9A%84%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</link>
      <pubDate>Thu, 15 Nov 2018 18:26:56 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E7%9A%84%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</guid>
      <description>交叉编译 通俗地讲就是在一种平台上编译出能运行在体系结构不同的另一种平台上的程序，比如在PC平台（X86 CPU）上编译出能运行在以ARM为内核</description>
    </item>
    
    <item>
      <title>Go中的HTTP通信方式</title>
      <link>http://localhost:1313/post/go%E4%B8%AD%E7%9A%84http%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Thu, 15 Nov 2018 18:26:03 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E4%B8%AD%E7%9A%84http%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</guid>
      <description>客户端:发送请求 http.Get GET请求的数据会附在URL之后(就是把数据放置在HTTP协议头中), ?分割URL和传输数据，参数之间以&amp;amp;相连. G</description>
    </item>
    
    <item>
      <title>Go中的Json编解码总结</title>
      <link>http://localhost:1313/post/go%E4%B8%AD%E7%9A%84json%E7%BC%96%E8%A7%A3%E7%A0%81%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 15 Nov 2018 18:25:06 +0000</pubDate>
      
      <guid>http://localhost:1313/post/go%E4%B8%AD%E7%9A%84json%E7%BC%96%E8%A7%A3%E7%A0%81%E6%80%BB%E7%BB%93/</guid>
      <description>编码 数据结构map json源于javascript的对象结构，golang中直接对应其数据结构，可是golang的map也是key-valu</description>
    </item>
    
  </channel>
</rss>