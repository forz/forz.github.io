<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Libevent on Forz Blog</title>
    <link>/categories/libevent/</link>
    <description>Recent content in Libevent on Forz Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 25 Jun 2017 17:02:30 +0000</lastBuildDate><atom:link href="/categories/libevent/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>libevent源码剖析(十三)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%81%E4%B8%89/</link>
      <pubDate>Sun, 25 Jun 2017 17:02:30 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%81%E4%B8%89/</guid>
      <description>前面讲到了 libevent 实现多线程的方法，然而在多线程的环境中注册信号事件，还是有一些情况需要小心处理，那就是不能在多个 libevent 实例上注册信号事件。依然冠名追</description>
    </item>
    
    <item>
      <title>libevent源码剖析(十二)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%81%E4%BA%8C/</link>
      <pubDate>Sun, 25 Jun 2017 17:02:21 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%81%E4%BA%8C/</guid>
      <description>Libevent本身不是多线程安全的，在多核的时代，如何能充分利用CPU的能力呢，这一节来说说如何在多线程环境中使用libevent，跟源代</description>
    </item>
    
    <item>
      <title>libevent源码剖析(十一)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%81%E4%B8%80/</link>
      <pubDate>Sun, 25 Jun 2017 17:02:12 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%81%E4%B8%80/</guid>
      <description>为了支持定时器，Libevent必须和系统时间打交道，这一部分的内容也比较简单，主要涉及到时间的加减辅助函数、时间缓存、时间校正和定时器堆的</description>
    </item>
    
    <item>
      <title>libevent源码剖析(十)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%81/</link>
      <pubDate>Sun, 25 Jun 2017 17:02:01 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%81/</guid>
      <description>Libevent的核心是事件驱动、同步非阻塞，为了达到这一目标，必须采用系统提供的I/O多路复用技术，而这些在Windows、Linux、U</description>
    </item>
    
    <item>
      <title>libevent源码剖析(九)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B9%9D/</link>
      <pubDate>Sun, 25 Jun 2017 17:01:53 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B9%9D/</guid>
      <description>现在再来详细分析libevent中I/O事件和Timer事件的集成，与Signal相比，Timer事件的集成会直观和简单很多。Libeven</description>
    </item>
    
    <item>
      <title>libevent源码剖析(八)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%85%AB/</link>
      <pubDate>Sun, 25 Jun 2017 17:01:43 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%85%AB/</guid>
      <description>现在我们已经了解了libevent的基本框架：事件管理框架和事件主循环。上节提到了libevent中I/O事件和Signal以及Timer事</description>
    </item>
    
    <item>
      <title>libevent源码剖析(七)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%83/</link>
      <pubDate>Sun, 25 Jun 2017 17:01:35 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%83/</guid>
      <description>现在我们已经初步了解了libevent的Reactor组件——event_base和事件管理框架，接下来就是libevent事件处理的中心部</description>
    </item>
    
    <item>
      <title>libevent源码剖析(六)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%85%AD/</link>
      <pubDate>Sun, 25 Jun 2017 17:01:26 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%85%AD/</guid>
      <description>前面已经对libevent的事件处理框架和event结构体做了描述，现在是时候剖析libevent对事件的详细处理流程了，本节将分析libe</description>
    </item>
    
    <item>
      <title>libevent源码剖析(五</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%BA%94/</link>
      <pubDate>Sun, 25 Jun 2017 17:01:17 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%BA%94/</guid>
      <description>对事件处理流程有了高层的认识后，本节将详细介绍libevent的核心结构event，以及libevent对event的管理。 1 libeven</description>
    </item>
    
    <item>
      <title>libevent源码剖析(四)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%9B%9B/</link>
      <pubDate>Sun, 25 Jun 2017 17:01:08 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%9B%9B/</guid>
      <description>1 前言 详细分析源代码之前，如果能对其代码文件的基本结构有个大概的认识和分类，对于代码的分析将是大有裨益的。本节内容不多，我想并不是说它不重要</description>
    </item>
    
    <item>
      <title>libevent源码剖析(三)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%89/</link>
      <pubDate>Sun, 25 Jun 2017 17:00:59 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%89/</guid>
      <description>1 前言 学习源代码该从哪里入手？我觉得从程序的基本使用场景和代码的整体处理流程入手是个不错的方法，至少从个人的经验上讲，用此方法分析libev</description>
    </item>
    
    <item>
      <title>libevent源码剖析(二)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%BA%8C/</link>
      <pubDate>Sun, 25 Jun 2017 17:00:51 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%BA%8C/</guid>
      <description>前面讲到，整个libevent本身就是一个Reactor，因此本节将专门对Reactor模式进行必要的介绍，并列出libevnet中的几个重</description>
    </item>
    
    <item>
      <title>libevent源码剖析(一)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%80/</link>
      <pubDate>Sun, 25 Jun 2017 17:00:40 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%80/</guid>
      <description>1 前言 Libevent是一个轻量级的开源高性能网络库，使用者众多，研究者更甚，相关文章也不少。写这一系列文章的用意在于，一则分享心得；二则对</description>
    </item>
    
  </channel>
</rss>
