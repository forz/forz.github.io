<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go调优 on Forz Blog</title>
    <link>/categories/go%E8%B0%83%E4%BC%98/</link>
    <description>Recent content in Go调优 on Forz Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 16 Feb 2022 18:24:33 +0000</lastBuildDate><atom:link href="/categories/go%E8%B0%83%E4%BC%98/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go如何优化GC触发频率</title>
      <link>/post/go%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96gc%E8%A7%A6%E5%8F%91%E9%A2%91%E7%8E%87/</link>
      <pubDate>Wed, 16 Feb 2022 18:24:33 +0000</pubDate>
      
      <guid>/post/go%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96gc%E8%A7%A6%E5%8F%91%E9%A2%91%E7%8E%87/</guid>
      <description>观察GC 我们以下面的程序为例，先使用四种不同的方式来介绍如何观察 GC，并在后面的问题中通过几个详细的例子再来讨论如何优化 GC。 1 2 3 4 5 6 7</description>
    </item>
    
    <item>
      <title>Go Perfbook</title>
      <link>/post/go-perfbook/</link>
      <pubDate>Sat, 11 Sep 2021 17:28:41 +0000</pubDate>
      
      <guid>/post/go-perfbook/</guid>
      <description>编写和优化Go代码 本文档概述了编写高性能Go代码的最佳实践。 虽然有些讨论会提高单个服务的速度（通过缓存等），但设计高性能的分布式系统已经超出</description>
    </item>
    
    <item>
      <title>Go语言性能调优指南</title>
      <link>/post/go%E8%AF%AD%E8%A8%80%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%8C%87%E5%8D%97/</link>
      <pubDate>Tue, 07 Sep 2021 13:42:48 +0000</pubDate>
      
      <guid>/post/go%E8%AF%AD%E8%A8%80%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%8C%87%E5%8D%97/</guid>
      <description>为什么要做优化 这是一个速度决定一切的时代，我们的生活在不断地数字化，线下的流程依然在持续向线上转移，转移过程中，作为工程师，我们会碰到各种各</description>
    </item>
    
    <item>
      <title>如何做CodeReview</title>
      <link>/post/%E5%A6%82%E4%BD%95%E5%81%9Acodereview/</link>
      <pubDate>Thu, 17 Jun 2021 14:24:17 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E5%81%9Acodereview/</guid>
      <description>前言 作为公司代码委员会 golang 分会的理事，我 review 了很多代码，看了很多别人的 review 评论。发现不少同学 code review 与写出好代码的水平有待提高。在这里，想分享一下我的</description>
    </item>
    
    <item>
      <title>Go语言面向对象设计</title>
      <link>/post/go%E8%AF%AD%E8%A8%80%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Wed, 16 Jun 2021 21:09:15 +0000</pubDate>
      
      <guid>/post/go%E8%AF%AD%E8%A8%80%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/</guid>
      <description>Code review 在座的各位有谁把 code review 作为日常工作的一部分？【整个房间举起了手，鼓舞人心】。好的，为什么要进行 code review ？【有人高呼“阻止不良代码”】 如果代码审</description>
    </item>
    
    <item>
      <title>Go应用为什么虚拟内存占用过高</title>
      <link>/post/go%E5%BA%94%E7%94%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98/</link>
      <pubDate>Tue, 08 Jun 2021 12:44:27 +0000</pubDate>
      
      <guid>/post/go%E5%BA%94%E7%94%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98/</guid>
      <description>前言 前段时间，某同学说某服务的容器因为超出内存限制，不断地重启，问我们是不是有内存泄露，赶紧排查，然后解决掉，省的出问题。我们大为震惊，赶紧</description>
    </item>
    
    <item>
      <title>如何控制Go服务在容器环境的内存占用</title>
      <link>/post/%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6go%E6%9C%8D%E5%8A%A1%E5%9C%A8%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/</link>
      <pubDate>Mon, 07 Jun 2021 18:49:05 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6go%E6%9C%8D%E5%8A%A1%E5%9C%A8%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/</guid>
      <description>现象 为什么个别 Go 业务服务，Memory 总是提示这么高，经常达到容器限额，以至于被动 OOM Kill，是不是有什么安全隐患？ 发现个别业务服务内存占用</description>
    </item>
    
    <item>
      <title>腾讯Go安全指南</title>
      <link>/post/%E8%85%BE%E8%AE%AFgo%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Wed, 26 May 2021 18:53:08 +0000</pubDate>
      
      <guid>/post/%E8%85%BE%E8%AE%AFgo%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97/</guid>
      <description>1 通用类 I. 代码实现 1.1 内存管理 1.2 文件操作 1.3 系统接口 1.4 通信安全 1.5 敏感数据保护 1.6 加密解密 1.7 正则表达式 2 后台类 I. 代码实现 1.1 输入校验 1.2 SQL操作 1.3 网络</description>
    </item>
    
    <item>
      <title>Go语言实践:编写可维护的程序的建议</title>
      <link>/post/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%B7%B5%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BB%BA%E8%AE%AE/</link>
      <pubDate>Sat, 15 Aug 2020 18:35:56 +0000</pubDate>
      
      <guid>/post/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%B7%B5%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BB%BA%E8%AE%AE/</guid>
      <description>指导原则 我们要谈论在一个编程语言中的最佳实践，那么我们首先应该明确什么是“最佳”。如果您们听了我昨天那场讲演的话，您一定看到了来自 Go 团队的 Russ</description>
    </item>
    
    <item>
      <title>Go代码审查建议</title>
      <link>/post/go%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E5%BB%BA%E8%AE%AE/</link>
      <pubDate>Sat, 15 Aug 2020 16:11:22 +0000</pubDate>
      
      <guid>/post/go%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E5%BB%BA%E8%AE%AE/</guid>
      <description>当前页面收集了在 Go 代码审核期间的常见意见，以便一个详细说明能被快速参考。这是一个常见错误的清单，而非综合性的风格指南。 你也可以将它作为是 Effective Go</description>
    </item>
    
    <item>
      <title>Go编码建议</title>
      <link>/post/go%E7%BC%96%E7%A0%81%E5%BB%BA%E8%AE%AE/</link>
      <pubDate>Fri, 14 Aug 2020 15:13:13 +0000</pubDate>
      
      <guid>/post/go%E7%BC%96%E7%A0%81%E5%BB%BA%E8%AE%AE/</guid>
      <description>注释 可以通过 /……/ 或者 // ……增加注释， //之后应该加一个空格。 如果你想在每个文件中的头部加上注释，需要在版权注释和 Package前面加一个</description>
    </item>
    
    <item>
      <title>Go Advice</title>
      <link>/post/go-advice/</link>
      <pubDate>Tue, 28 Jul 2020 19:17:28 +0000</pubDate>
      
      <guid>/post/go-advice/</guid>
      <description>Go-advice 中文版本 Go 箴言 Go 之禅 代码 并发 性能 模块 构建 测试 工具 Misc Go-advice 中文版本 Go 箴言 不要通过共享内存进行通信，通过通信共享内存 并发不是并行 通道编排；互斥体序</description>
    </item>
    
    <item>
      <title>Uber的Go语言编码规范</title>
      <link>/post/uber%E7%9A%84go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</link>
      <pubDate>Tue, 28 Jul 2020 17:12:51 +0000</pubDate>
      
      <guid>/post/uber%E7%9A%84go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</guid>
      <description>Uber Go 语言编码规范 Uber 是一家美国硅谷的科技公司，也是 Go 语言的早期 adopter。其开源了很多 golang 项目，诸如被 Gopher 圈熟知的 zap、jaeger 等。20</description>
    </item>
    
    <item>
      <title>Go调试器:GODEBUG</title>
      <link>/post/go%E8%B0%83%E8%AF%95%E5%99%A8godebug/</link>
      <pubDate>Tue, 11 Feb 2020 10:22:37 +0000</pubDate>
      
      <guid>/post/go%E8%B0%83%E8%AF%95%E5%99%A8godebug/</guid>
      <description>介绍 让 Go 更强大的原因之一莫过于它的 GODEBUG 工具，GODEBUG 的设置可以让 Go 程序在运行时输出调试信息，可以根据你的要求很直观的看到你想要的调度器或</description>
    </item>
    
    <item>
      <title>堆栈跟踪:Stack-Trace</title>
      <link>/post/%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AAstack-trace/</link>
      <pubDate>Tue, 11 Feb 2020 09:44:31 +0000</pubDate>
      
      <guid>/post/%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AAstack-trace/</guid>
      <description>Stack Trace表示堆栈跟踪，这是一个或多个堆栈帧的有序的集合。在程序出现panic的时候你会看到控制台有Stack Trace信息打印出来。 介绍</description>
    </item>
    
    <item>
      <title>Go性能分析工具trace介绍</title>
      <link>/post/go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7trace%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Mon, 10 Feb 2020 16:53:58 +0000</pubDate>
      
      <guid>/post/go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7trace%E4%BB%8B%E7%BB%8D/</guid>
      <description>trace 你有没有考虑过，你的goroutines是如何被go的runtime系统调度的？是否尝试理解过为什么在程序中增加了并发，但并没有给它带来更</description>
    </item>
    
    <item>
      <title>Pprof实战:解决内存泄露</title>
      <link>/post/pprof%E5%AE%9E%E6%88%98%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/</link>
      <pubDate>Sun, 09 Feb 2020 18:49:21 +0000</pubDate>
      
      <guid>/post/pprof%E5%AE%9E%E6%88%98%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/</guid>
      <description>前言 关于Go的内存泄露有这么一句话不知道你听过没有： 10次内存泄露，有9次是goroutine泄露。 我所解决的问题，也是goroutine泄</description>
    </item>
    
    <item>
      <title>Pprof实战:从零开始排查炸弹程序</title>
      <link>/post/pprof%E5%AE%9E%E6%88%98%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8E%92%E6%9F%A5%E7%82%B8%E5%BC%B9%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sun, 09 Feb 2020 17:45:44 +0000</pubDate>
      
      <guid>/post/pprof%E5%AE%9E%E6%88%98%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8E%92%E6%9F%A5%E7%82%B8%E5%BC%B9%E7%A8%8B%E5%BA%8F/</guid>
      <description>前言 如果要说在 golang 开发过程进行性能调优，pprof 一定是一个大杀器般的工具。但在网上找到的教程都偏向简略，难寻真的能应用于实战的教程。这也无可</description>
    </item>
    
    <item>
      <title>Pprof实战:Profiling Go Programs</title>
      <link>/post/pprof%E5%AE%9E%E6%88%98profiling-go-programs/</link>
      <pubDate>Sun, 02 Feb 2020 21:36:55 +0000</pubDate>
      
      <guid>/post/pprof%E5%AE%9E%E6%88%98profiling-go-programs/</guid>
      <description>背景 在Scala Days 2011，Robert Hundt 发表了一篇名为 Loop Recognition in C++/Java/Go/Scala 的论文。 该论文实现了一种特定的循环查找算法，例如您可以在C++，Go，Jav</description>
    </item>
    
    <item>
      <title>Pprof实战:利用火焰图优化代码</title>
      <link>/post/pprof%E5%AE%9E%E6%88%98%E5%88%A9%E7%94%A8%E7%81%AB%E7%84%B0%E5%9B%BE%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Sun, 02 Feb 2020 11:28:43 +0000</pubDate>
      
      <guid>/post/pprof%E5%AE%9E%E6%88%98%E5%88%A9%E7%94%A8%E7%81%AB%E7%84%B0%E5%9B%BE%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/</guid>
      <description>这里使用火焰图复现 logger 100% CPU 问题。 先看现象， 用 wrk 压测 logger 1 wrk -t1 -c100 -d30 --script=post.lua &amp;#39;http://127.0.0.1:4500/marco/log&amp;#39; 查看 CPU 占用情况 采集 30s 的 CPU profile 火焰图 图中红色标记部分 startSink 函数中 runtime.selectgo 消耗了大量 CPU，</description>
    </item>
    
    <item>
      <title>Pprof替代库:pkg Profile</title>
      <link>/post/pprof%E6%9B%BF%E4%BB%A3%E5%BA%93pkg-profile/</link>
      <pubDate>Sat, 01 Feb 2020 22:32:29 +0000</pubDate>
      
      <guid>/post/pprof%E6%9B%BF%E4%BB%A3%E5%BA%93pkg-profile/</guid>
      <description>简介 Go 运行时的分析接口存在于 runtime/pprof 包中。 runtime/pprof 是一个非常低级的工具，由于历史原因，不同类型 profile 的接口并不统一,而且使用起来还不是太方便，例如：输出数据</description>
    </item>
    
    <item>
      <title>pprof实战:利用runtime-pprof优化代码</title>
      <link>/post/pprof%E5%AE%9E%E6%88%98%E5%88%A9%E7%94%A8runtime-pprof%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Sat, 01 Feb 2020 17:23:12 +0000</pubDate>
      
      <guid>/post/pprof%E5%AE%9E%E6%88%98%E5%88%A9%E7%94%A8runtime-pprof%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/</guid>
      <description>示例代码 我们写一个程序来计算单词数量： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;io&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; &amp;#34;unicode&amp;#34; ) func</description>
    </item>
    
    <item>
      <title>Go代码优化建议</title>
      <link>/post/go%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/</link>
      <pubDate>Sat, 01 Feb 2020 15:48:07 +0000</pubDate>
      
      <guid>/post/go%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/</guid>
      <description>将多个小对象合并成一个大的对象 减少不必要的指针间接引用，多使用copy引用 例如使用bytes.Buffer代替*bytes.Buffer`，</description>
    </item>
    
    <item>
      <title>pprof实战:结合benchmark优化代码</title>
      <link>/post/pprof%E5%AE%9E%E6%88%98%E7%BB%93%E5%90%88benchmark%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Fri, 31 Jan 2020 23:09:56 +0000</pubDate>
      
      <guid>/post/pprof%E5%AE%9E%E6%88%98%E7%BB%93%E5%90%88benchmark%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/</guid>
      <description>示例代码:数独 sodoku.go: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62</description>
    </item>
    
    <item>
      <title>Go性能分析工具pprof介绍</title>
      <link>/post/go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7pprof%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Thu, 30 Jan 2020 21:54:05 +0000</pubDate>
      
      <guid>/post/go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7pprof%E4%BB%8B%E7%BB%8D/</guid>
      <description>简介 什么是pprof 代码上线前，我们通过压测可以获知系统的性能，例如每秒能处理的请求数，平均响应时间，错误率等指标。这样，我们对自己服务的性</description>
    </item>
    
  </channel>
</rss>
