<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go调优 on Forz Blog</title>
    <link>/categories/go%E8%B0%83%E4%BC%98/</link>
    <description>Recent content in Go调优 on Forz Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 11 Feb 2020 23:59:16 +0000</lastBuildDate><atom:link href="/categories/go%E8%B0%83%E4%BC%98/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MemStats与GCStats</title>
      <link>/post/memstats%E4%B8%8Egcstats/</link>
      <pubDate>Tue, 11 Feb 2020 23:59:16 +0000</pubDate>
      
      <guid>/post/memstats%E4%B8%8Egcstats/</guid>
      <description>关于内存分配的情况，最简单的方式是利用 runtime 包的 MemStats。 上面这种是不修改一行代码的情况下，完全使用外部工具/参数，无侵入式的 GC 监控。 另</description>
    </item>
    
    <item>
      <title>Go调试器:GODEBUG</title>
      <link>/post/go%E8%B0%83%E8%AF%95%E5%99%A8godebug/</link>
      <pubDate>Tue, 11 Feb 2020 10:22:37 +0000</pubDate>
      
      <guid>/post/go%E8%B0%83%E8%AF%95%E5%99%A8godebug/</guid>
      <description>介绍 让 Go 更强大的原因之一莫过于它的 GODEBUG 工具，GODEBUG 的设置可以让 Go 程序在运行时输出调试信息，可以根据你的要求很直观的看到你想要的调度器或</description>
    </item>
    
    <item>
      <title>堆栈跟踪:Stack-Trace</title>
      <link>/post/%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AAstack-trace/</link>
      <pubDate>Tue, 11 Feb 2020 09:44:31 +0000</pubDate>
      
      <guid>/post/%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AAstack-trace/</guid>
      <description>Stack Trace表示堆栈跟踪，这是一个或多个堆栈帧的有序的集合。在程序出现panic的时候你会看到控制台有Stack Trace信息打印出来。 介绍</description>
    </item>
    
    <item>
      <title>Go性能分析:trace</title>
      <link>/post/go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90trace/</link>
      <pubDate>Mon, 10 Feb 2020 16:53:58 +0000</pubDate>
      
      <guid>/post/go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90trace/</guid>
      <description>trace 你有没有考虑过，你的goroutines是如何被go的runtime系统调度的？是否尝试理解过为什么在程序中增加了并发，但并没有给它带来更</description>
    </item>
    
    <item>
      <title>Pprof实战:解决内存泄露</title>
      <link>/post/pprof%E5%AE%9E%E6%88%98%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/</link>
      <pubDate>Sun, 09 Feb 2020 18:49:21 +0000</pubDate>
      
      <guid>/post/pprof%E5%AE%9E%E6%88%98%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/</guid>
      <description>前言 关于Go的内存泄露有这么一句话不知道你听过没有： 10次内存泄露，有9次是goroutine泄露。 我所解决的问题，也是goroutine泄</description>
    </item>
    
    <item>
      <title>Pprof实战:从零开始排查炸弹程序</title>
      <link>/post/pprof%E5%AE%9E%E6%88%98%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8E%92%E6%9F%A5%E7%82%B8%E5%BC%B9%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sun, 09 Feb 2020 17:45:44 +0000</pubDate>
      
      <guid>/post/pprof%E5%AE%9E%E6%88%98%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8E%92%E6%9F%A5%E7%82%B8%E5%BC%B9%E7%A8%8B%E5%BA%8F/</guid>
      <description>前言 如果要说在 golang 开发过程进行性能调优，pprof 一定是一个大杀器般的工具。但在网上找到的教程都偏向简略，难寻真的能应用于实战的教程。这也无可</description>
    </item>
    
    <item>
      <title>Pprof实战:Profiling Go Programs</title>
      <link>/post/pprof%E5%AE%9E%E6%88%98profiling-go-programs/</link>
      <pubDate>Sun, 02 Feb 2020 21:36:55 +0000</pubDate>
      
      <guid>/post/pprof%E5%AE%9E%E6%88%98profiling-go-programs/</guid>
      <description>背景 在Scala Days 2011，Robert Hundt 发表了一篇名为 Loop Recognition in C++/Java/Go/Scala 的论文。 该论文实现了一种特定的循环查找算法，例如您可以在C++，Go，Jav</description>
    </item>
    
    <item>
      <title>Pprof实战:利用火焰图优化代码</title>
      <link>/post/pprof%E5%AE%9E%E6%88%98%E5%88%A9%E7%94%A8%E7%81%AB%E7%84%B0%E5%9B%BE%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Sun, 02 Feb 2020 11:28:43 +0000</pubDate>
      
      <guid>/post/pprof%E5%AE%9E%E6%88%98%E5%88%A9%E7%94%A8%E7%81%AB%E7%84%B0%E5%9B%BE%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/</guid>
      <description>这里使用火焰图复现 logger 100% CPU 问题。 先看现象， 用 wrk 压测 logger 1 wrk -t1 -c100 -d30 --script=post.lua &amp;#39;http://127.0.0.1:4500/marco/log&amp;#39; 查看 CPU 占用情况 采集 30s 的 CPU profile 火焰图 图中红色标记部分 startSink 函数中 runtime.selectgo 消耗了大量 CPU，</description>
    </item>
    
    <item>
      <title>Pprof替代库:pkg Profile</title>
      <link>/post/pprof%E6%9B%BF%E4%BB%A3%E5%BA%93pkg-profile/</link>
      <pubDate>Sat, 01 Feb 2020 22:32:29 +0000</pubDate>
      
      <guid>/post/pprof%E6%9B%BF%E4%BB%A3%E5%BA%93pkg-profile/</guid>
      <description>简介 Go 运行时的分析接口存在于 runtime/pprof 包中。 runtime/pprof 是一个非常低级的工具，由于历史原因，不同类型 profile 的接口并不统一,而且使用起来还不是太方便，例如：输出数据</description>
    </item>
    
    <item>
      <title>pprof实战:利用runtime-pprof优化代码</title>
      <link>/post/pprof%E5%AE%9E%E6%88%98%E5%88%A9%E7%94%A8runtime-pprof%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Sat, 01 Feb 2020 17:23:12 +0000</pubDate>
      
      <guid>/post/pprof%E5%AE%9E%E6%88%98%E5%88%A9%E7%94%A8runtime-pprof%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/</guid>
      <description>示例代码 我们写一个程序来计算单词数量： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;io&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; &amp;#34;unicode&amp;#34; ) func</description>
    </item>
    
    <item>
      <title>pprof实战:结合benchmark优化代码</title>
      <link>/post/pprof%E5%AE%9E%E6%88%98%E7%BB%93%E5%90%88benchmark%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Fri, 31 Jan 2020 23:09:56 +0000</pubDate>
      
      <guid>/post/pprof%E5%AE%9E%E6%88%98%E7%BB%93%E5%90%88benchmark%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/</guid>
      <description>示例代码:数独 sodoku.go: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62</description>
    </item>
    
    <item>
      <title>Go性能分析工具pprof介绍</title>
      <link>/post/go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7pprof%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Thu, 30 Jan 2020 21:54:05 +0000</pubDate>
      
      <guid>/post/go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7pprof%E4%BB%8B%E7%BB%8D/</guid>
      <description>简介 什么是pprof 代码上线前，我们通过压测可以获知系统的性能，例如每秒能处理的请求数，平均响应时间，错误率等指标。这样，我们对自己服务的性</description>
    </item>
    
    <item>
      <title>Go的编译优化:内联与死码消除</title>
      <link>/post/go%E7%9A%84%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%86%85%E8%81%94%E4%B8%8E%E6%AD%BB%E7%A0%81%E6%B6%88%E9%99%A4/</link>
      <pubDate>Thu, 30 Jan 2020 16:33:02 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%86%85%E8%81%94%E4%B8%8E%E6%AD%BB%E7%A0%81%E6%B6%88%E9%99%A4/</guid>
      <description>内联 在 Go 中，函数调用有固定的开销；栈和抢占检查。 硬件分支预测器改善了其中的一些功能，但就功能大小和时钟周期而言，这仍然是一个成本。 内联是避免</description>
    </item>
    
    <item>
      <title>Go中的基准测试</title>
      <link>/post/go%E4%B8%AD%E7%9A%84%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Thu, 30 Jan 2020 15:46:41 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E7%9A%84%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</guid>
      <description>基准测试的基本规则 在进行基准测试之前，我们必须要有一个稳定的环境来获得可重现的结果。 机器必须是空闲的——不要运行在共享硬件上，在长时间运行基</description>
    </item>
    
    <item>
      <title>Go的编译优化:逃逸分析</title>
      <link>/post/go%E7%9A%84%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 21 Dec 2018 14:54:40 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</guid>
      <description>变量的生命周期 生命周期是指程序执行过程中变量存在的时间段。下面我们分别来看看包变量（全局变量）和局部变量两种变量的生命周期。 包变量一直常驻在</description>
    </item>
    
  </channel>
</rss>
