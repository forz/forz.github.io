<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux编程 on Forz Blog</title>
    <link>/categories/linux%E7%BC%96%E7%A8%8B/</link>
    <description>Recent content in Linux编程 on Forz Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 19 Nov 2020 11:30:00 +0000</lastBuildDate><atom:link href="/categories/linux%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux的网络IO模型</title>
      <link>/post/linux%E7%9A%84%E7%BD%91%E7%BB%9Cio%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Thu, 19 Nov 2020 11:30:00 +0000</pubDate>
      
      <guid>/post/linux%E7%9A%84%E7%BD%91%E7%BB%9Cio%E6%A8%A1%E5%9E%8B/</guid>
      <description>用户空间与内核空间 现代操作系统都是采用虚拟存储器，那么对 32 位操作系统而言，它的寻址空间（虚拟存储空间）为 4G（2 的 32 次方）。操作系统的核心是</description>
    </item>
    
    <item>
      <title>多进程模型详解</title>
      <link>/post/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 10 Sep 2017 22:25:16 +0000</pubDate>
      
      <guid>/post/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</guid>
      <description>简介 每一个进程是资源分配的基本单位。进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。实际上在</description>
    </item>
    
    <item>
      <title>进程间通信方式(IPC)总结</title>
      <link>/post/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8Fipc%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 09 Sep 2017 21:59:17 +0000</pubDate>
      
      <guid>/post/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8Fipc%E6%80%BB%E7%BB%93/</guid>
      <description>同一主机上的进程通信方式 UNIX进程间通信方式: 包括管道(PIPE), 有名管道(FIFO), 和信号(Signal) System V进程通信方式：包括信号</description>
    </item>
    
    <item>
      <title>使用互斥锁、条件变量实现读写锁 </title>
      <link>/post/%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E9%94%81/</link>
      <pubDate>Thu, 20 Jul 2017 17:16:29 +0000</pubDate>
      
      <guid>/post/%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E9%94%81/</guid>
      <description>要实现读写锁，首先要知道读写锁的特性，除了“读者可并发，写者要排它”之外还要考虑避免写者饥饿的问题。综合考虑后可以讲读写锁的实现总结为一下四</description>
    </item>
    
    <item>
      <title>SQL 和 NoSQL 的区别</title>
      <link>/post/sql-%E5%92%8C-nosql-%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 25 Jun 2017 16:50:09 +0000</pubDate>
      
      <guid>/post/sql-%E5%92%8C-nosql-%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>转载：http://www.cnblogs.com/jeakeven/p/5402095.html 一、概念 SQL (Structured Query Language) 数据库，指关系型数据库。主</description>
    </item>
    
    <item>
      <title>大端模式和小端模式转化及网络字节序</title>
      <link>/post/%E5%A4%A7%E7%AB%AF%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F%E8%BD%AC%E5%8C%96%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F/</link>
      <pubDate>Sun, 25 Jun 2017 16:49:07 +0000</pubDate>
      
      <guid>/post/%E5%A4%A7%E7%AB%AF%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F%E8%BD%AC%E5%8C%96%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F/</guid>
      <description>转载：http://blog.csdn.net/szchtx/article/details/42834391 一、定义 大端模式（Big End</description>
    </item>
    
    <item>
      <title>可重入函数与不可重入函数的区别</title>
      <link>/post/%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0%E4%B8%8E%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 25 Jun 2017 16:48:59 +0000</pubDate>
      
      <guid>/post/%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0%E4%B8%8E%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>基本定义 可重入函数可以做这样的基本定义：重入意味着这个函数可以重复进入，可以被并行调用，可以被中断，它只使用自身栈上的数据变量，它不依赖于任</description>
    </item>
    
    <item>
      <title>多线程之间共享哪些资源？</title>
      <link>/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E5%93%AA%E4%BA%9B%E8%B5%84%E6%BA%90/</link>
      <pubDate>Sun, 25 Jun 2017 14:22:33 +0000</pubDate>
      
      <guid>/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E5%93%AA%E4%BA%9B%E8%B5%84%E6%BA%90/</guid>
      <description>共享资源 正文段. 程序的代码 数据段。程序的全局内存。包括全局变量和静态变量: 全局变量它是与具体某一函数无关的，所以也与特定线程无关；因此也是共</description>
    </item>
    
    <item>
      <title>父子进程的联系</title>
      <link>/post/%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%81%94%E7%B3%BB/</link>
      <pubDate>Sun, 25 Jun 2017 14:22:23 +0000</pubDate>
      
      <guid>/post/%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%81%94%E7%B3%BB/</guid>
      <description>两者联系 子进程得到父进程的数据空间，堆和栈的副本，但是两者是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程</description>
    </item>
    
    <item>
      <title>linux多线程信号处理</title>
      <link>/post/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</link>
      <pubDate>Sun, 25 Jun 2017 14:22:16 +0000</pubDate>
      
      <guid>/post/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</guid>
      <description>在多线程环境下，产生的信号是传递给整个进程的，一般而言，所有线程都有机会收到这个信号，进程在收到信号的的线程上下文执行信号处理函数，具体是哪</description>
    </item>
    
    <item>
      <title>解析shutdown()和close()</title>
      <link>/post/%E8%A7%A3%E6%9E%90shutdown-%E5%92%8Cclose/</link>
      <pubDate>Sun, 25 Jun 2017 14:21:49 +0000</pubDate>
      
      <guid>/post/%E8%A7%A3%E6%9E%90shutdown-%E5%92%8Cclose/</guid>
      <description>TCP连接的关闭有两个方法close和shutdown，这篇文章将尽量精简的说明它们分别做了些什么。 为方便阅读，我们可以带着以下5个问题来阅</description>
    </item>
    
    <item>
      <title>SOCKETOPT-SO_LINGER选项</title>
      <link>/post/socketopt-so-linger%E9%80%89%E9%A1%B9/</link>
      <pubDate>Sun, 25 Jun 2017 14:21:41 +0000</pubDate>
      
      <guid>/post/socketopt-so-linger%E9%80%89%E9%A1%B9/</guid>
      <description>当调用closesocket关闭套接字时，SO_LINGER将决定系统如何处理残存在套接字发送队列中的数据。处理方式无非两种：丢弃或者将数据</description>
    </item>
    
    <item>
      <title>SO_REUESADDR和SO_REUSEPORT</title>
      <link>/post/socketopt-so-reuesaddr%E9%80%89%E9%A1%B9/</link>
      <pubDate>Sun, 25 Jun 2017 14:21:30 +0000</pubDate>
      
      <guid>/post/socketopt-so-reuesaddr%E9%80%89%E9%A1%B9/</guid>
      <description>简介 一般来说，一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。 这个套接字选项通知内核</description>
    </item>
    
    <item>
      <title>open/read/write和fopen/fread/fwrite的区别</title>
      <link>/post/open-read-write%E5%92%8Cfopen-fread-fwrite%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 25 Jun 2017 14:21:12 +0000</pubDate>
      
      <guid>/post/open-read-write%E5%92%8Cfopen-fread-fwrite%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>介绍 open：系统调用，返回的是文件描述符，即文件句柄，是文件在文件描述副表里的索引。 fopen：C语言库函数，返回的是一个指向文件结构的指</description>
    </item>
    
    <item>
      <title>文件指针和文件描述符的区别</title>
      <link>/post/%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 25 Jun 2017 14:21:03 +0000</pubDate>
      
      <guid>/post/%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>FILE文件指针 C语言中使用文件指针做为I/O的句柄。文件指针指向进程用户区中的一个被称为FILE结构的数据结构。 FILE结构包括缓冲区和文</description>
    </item>
    
    <item>
      <title>多线程模型详解</title>
      <link>/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 25 Jun 2017 14:20:42 +0000</pubDate>
      
      <guid>/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</guid>
      <description>转载: https://github.com/linw7/Skill-Tree/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#mutex 简介 我们这里讨论的是用户态的多线程模型，同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被虽有的</description>
    </item>
    
    <item>
      <title>利用linux的mtrace命令定位内存泄露(Memory Leak)</title>
      <link>/post/%E5%88%A9%E7%94%A8linux%E7%9A%84mtrace%E5%91%BD%E4%BB%A4%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2-memory-leak/</link>
      <pubDate>Sun, 25 Jun 2017 14:19:16 +0000</pubDate>
      
      <guid>/post/%E5%88%A9%E7%94%A8linux%E7%9A%84mtrace%E5%91%BD%E4%BB%A4%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2-memory-leak/</guid>
      <description>最令Linux程序员头疼的莫过于内存泄露了，即使你是在优秀的程序员，你也不能保证所以的malloc操作都有对应的free，那必要的工具就是必</description>
    </item>
    
    <item>
      <title>GCC编译器介绍</title>
      <link>/post/gcc%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Sun, 25 Jun 2017 14:19:06 +0000</pubDate>
      
      <guid>/post/gcc%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%8B%E7%BB%8D/</guid>
      <description>gcc命令 gcc命令使用GNU推出的基于C/C++的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点。现</description>
    </item>
    
    <item>
      <title>coredump详解</title>
      <link>/post/coredump%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 25 Jun 2017 05:44:05 +0000</pubDate>
      
      <guid>/post/coredump%E8%AF%A6%E8%A7%A3/</guid>
      <description>一，什么是coredump 我们经常听到大家说到程序core掉了，需要定位解决，这里说的大部分是指对应程序由于各种异常或者bug导致在运行过程</description>
    </item>
    
    <item>
      <title>Socket处在网络层的什么位置？</title>
      <link>/post/socket%E5%A4%84%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E4%BB%80%E4%B9%88%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Sun, 25 Jun 2017 05:43:09 +0000</pubDate>
      
      <guid>/post/socket%E5%A4%84%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E4%BB%80%E4%B9%88%E4%BD%8D%E7%BD%AE/</guid>
      <description>描述一个网络中各个协议层的常用方法是使用国际标准化组织（ISO）的计算机通信开放系统互连（open systems interconnection , OSI）模型。 OSI模型的底下两层是</description>
    </item>
    
    <item>
      <title>调试工具Valgrind</title>
      <link>/post/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7valgrind/</link>
      <pubDate>Sun, 25 Jun 2017 05:10:36 +0000</pubDate>
      
      <guid>/post/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7valgrind/</guid>
      <description>Valgrind是运行在Linux上一套基于仿真技术的程序调试和分析工具，是公认的最接近Purify的产品，它包含一个内核——一个软件合成的</description>
    </item>
    
  </channel>
</rss>
