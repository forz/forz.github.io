<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>STL on Forz Blog</title>
    <link>http://localhost:1313/categories/STL/</link>
    <description>Recent content in STL on Forz Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 07 Sep 2017 17:39:18 +0000</lastBuildDate>
    
	<atom:link href="http://localhost:1313/categories/STL/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>back_inserter()用法</title>
      <link>http://localhost:1313/post/-stdcopy%E5%92%8Cstdback_inserter%E7%94%A8%E6%B3%95/</link>
      <pubDate>Thu, 07 Sep 2017 17:39:18 +0000</pubDate>
      
      <guid>http://localhost:1313/post/-stdcopy%E5%92%8Cstdback_inserter%E7%94%A8%E6%B3%95/</guid>
      <description>头文件: 1 #include &amp;lt;iterator&amp;gt; 函数原型: 1 2 template &amp;lt;class Container&amp;gt; back_insert_iterator&amp;lt;Container&amp;gt; back_inserter (Container&amp;amp; x); 用法: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46</description>
    </item>
    
    <item>
      <title>numeric库操作总结</title>
      <link>http://localhost:1313/post/numeric-%E5%BA%93%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 03 Sep 2017 11:30:37 +0000</pubDate>
      
      <guid>http://localhost:1313/post/numeric-%E5%BA%93%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>accumulate 介绍 1 2 3 4 5 template &amp;lt;class InputIterator, class T&amp;gt; T accumulate (InputIterator first, InputIterator last, T init); template &amp;lt;class InputIterator, class T, class BinaryOperation&amp;gt; T accumulate (InputIterator first, InputIterator last, T init, BinaryOperation binary_op); 1 2 3 4 5 6 7 8 9 template &amp;lt;class InputIterator, class T&amp;gt; T accumulate (InputIterator first, InputIterator last, T init) { while (first!=last) { init = init + *first; //</description>
    </item>
    
    <item>
      <title>数据结构:unordered_map、unordered_set</title>
      <link>http://localhost:1313/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-unordered-mapunordered-set/</link>
      <pubDate>Sun, 03 Sep 2017 05:21:46 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-unordered-mapunordered-set/</guid>
      <description>hashtable的数据结构 bucket所维护的linked list，并不采用STL的list或slist，而是自行维护上述的hashtab</description>
    </item>
    
    <item>
      <title>数据结构:set、multiset、map、multimap</title>
      <link>http://localhost:1313/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-setmultisetmapmultimap/</link>
      <pubDate>Sun, 03 Sep 2017 05:21:28 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-setmultisetmapmultimap/</guid>
      <description>set et的特性是，所有元素都会根据元素的键值自动被排序。set的元素不像map那样可以同时拥有实值（m/m)和键值，set元素的键值就是实值，</description>
    </item>
    
    <item>
      <title>数据结构:list、forward_list</title>
      <link>http://localhost:1313/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-listforward-list/</link>
      <pubDate>Sat, 02 Sep 2017 21:04:17 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-listforward-list/</guid>
      <description>list 概述 相较于vector的连续线性空间，list就显得复杂许多，它的好处是每次插入或删除一个元素，就配置或释放一个元素空间。因此，list对</description>
    </item>
    
    <item>
      <title>数据结构:deque、stack、queue</title>
      <link>http://localhost:1313/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-dequestackqueue/</link>
      <pubDate>Sat, 02 Sep 2017 21:03:59 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-dequestackqueue/</guid>
      <description>deque 概述 vector是单向开口的连续线性空间，deque则是一种双向开口的连续线性空 间。所谓双向开口，意思是可以在头尾两端分别做元素的插人和删</description>
    </item>
    
    <item>
      <title>数据结构:vector、priority_queue</title>
      <link>http://localhost:1313/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-vectorpriority-queue/</link>
      <pubDate>Sat, 02 Sep 2017 21:03:25 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-vectorpriority-queue/</guid>
      <description>vector 概述 vector的数据安排以及操作方式，与array非常相似。两者的唯一差别在于 空间的运用的灵活性。array是静态空间，一旦配置了就不能</description>
    </item>
    
    <item>
      <title>空间配置器Allocator</title>
      <link>http://localhost:1313/post/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8Allocator/</link>
      <pubDate>Sat, 02 Sep 2017 19:55:36 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8Allocator/</guid>
      <description>Allocator 一般而言，我们所习惯的C++内存配置操作和释放操作是这样的: 1 2 3 class Foo {}； Foo* pf = new Foo； // 配置内存，然后构造对象 delete pf； //将对象析构</description>
    </item>
    
    <item>
      <title>multimap中查找方法</title>
      <link>http://localhost:1313/post/multimap%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 01 Aug 2017 00:09:24 +0000</pubDate>
      
      <guid>http://localhost:1313/post/multimap%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95/</guid>
      <description>在multimap中，同一个键关联的元素必然相邻存放。基于这个事实，就可以将某个键对应的值一一输出。 使用find和count函数。count</description>
    </item>
    
    <item>
      <title>algorithm库操作总结</title>
      <link>http://localhost:1313/post/algorithm%E5%BA%93%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 27 Jul 2017 21:50:23 +0000</pubDate>
      
      <guid>http://localhost:1313/post/algorithm%E5%BA%93%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>非修改序列操作 for_each 1 2 template &amp;lt;class InputIterator, class Function&amp;gt; Function for_each (InputIterator first, InputIterator last, Function fn); 1 2 3 4 5 6 7 8 9 template&amp;lt;class InputIterator, class Function&amp;gt; Function for_each(InputIterator first, InputIterator last, Function fn) { while (first!=last) { fn (*first); ++first; } return fn; // or, since C++11: return move(fn); } all_of 1 2 3 4 5 6 7 8 9</description>
    </item>
    
    <item>
      <title>rand()和srand()函数总结</title>
      <link>http://localhost:1313/post/rand-%E5%92%8Csrand-%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 27 Jul 2017 21:18:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/rand-%E5%92%8Csrand-%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</guid>
      <description>转载:http://www.cnblogs.com/guihailiuli/p/4154416.html 要计算机产生一个随机数不像扔色子一样</description>
    </item>
    
    <item>
      <title>cctype库操作总结</title>
      <link>http://localhost:1313/post/cctype%E5%BA%93%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 27 Jul 2017 20:39:29 +0000</pubDate>
      
      <guid>http://localhost:1313/post/cctype%E5%BA%93%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>常用函数:</description>
    </item>
    
    <item>
      <title>math库数值处理函数总结</title>
      <link>http://localhost:1313/post/%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 23 Jul 2017 19:57:02 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</guid>
      <description>向上取整ceil() 1 2 3 4 double ceil (double x); float ceil (float x); long double ceil (long double x); double ceil (T x); // additional overloads for integral types 向上取整,返回大于等于x的值. 示例: 1 2 3 4 5 6 7 8 9 10 11 #include &amp;lt;stdio.h&amp;gt; /*</description>
    </item>
    
    <item>
      <title>map排序相关讨论</title>
      <link>http://localhost:1313/post/map%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E8%AE%A8%E8%AE%BA/</link>
      <pubDate>Fri, 21 Jul 2017 15:22:43 +0000</pubDate>
      
      <guid>http://localhost:1313/post/map%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E8%AE%A8%E8%AE%BA/</guid>
      <description>map是用来存放键值对的数据结构，可以很方便快速的根据key查到相应的value。假如存储学生和其成绩（假定不存在重名，当然可以对重名加以区</description>
    </item>
    
    <item>
      <title>string与其他类型间的转换</title>
      <link>http://localhost:1313/post/string%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Mon, 17 Jul 2017 20:38:39 +0000</pubDate>
      
      <guid>http://localhost:1313/post/string%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</guid>
      <description>string与char数组的转换 string转char数组 使用c_str函数 1 2 string a=&amp;#34;hello world&amp;#34;; const char* ch=a.c_str(); 注意: c_str函数的返回值是const char</description>
    </item>
    
    <item>
      <title>unordered_map操作总结</title>
      <link>http://localhost:1313/post/unordered-map%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 17 Jul 2017 15:07:03 +0000</pubDate>
      
      <guid>http://localhost:1313/post/unordered-map%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>构造函数 empty (1) 1 2 3 4 5 6 explicit unordered_map ( size_type n = /* see below */, const hasher&amp;amp; hf = hasher(), const key_equal&amp;amp; eql = key_equal(), const allocator_type&amp;amp; alloc = allocator_type() ); explicit unordered_map ( const allocator_type&amp;amp; alloc ); range (2) 1 2 3 4 5 6 template &amp;lt;class InputIterator&amp;gt; unordered_map ( InputIterator first, InputIterator last, size_type n = /* see below */, const</description>
    </item>
    
    <item>
      <title>unordered_set操作总结</title>
      <link>http://localhost:1313/post/unordered-set%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 17 Jul 2017 15:06:46 +0000</pubDate>
      
      <guid>http://localhost:1313/post/unordered-set%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>#构造函数 1. empty (1) 1 2 3 4 5 6 explicit unordered_set ( size_type n = /* see below */, const hasher&amp;amp; hf = hasher(), const key_equal&amp;amp; eql = key_equal(), const allocator_type&amp;amp; alloc = allocator_type() ); explicit unordered_set ( const allocator_type&amp;amp; alloc ); range (2) 1 2 3 4 5 6 template &amp;lt;class InputIterator&amp;gt; unordered_set ( InputIterator first, InputIterator last, size_type n = /* see below</description>
    </item>
    
    <item>
      <title>set和multiset操作总结</title>
      <link>http://localhost:1313/post/set%E5%92%8Cmultiset%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 16 Jul 2017 21:22:10 +0000</pubDate>
      
      <guid>http://localhost:1313/post/set%E5%92%8Cmultiset%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>set 构造函数 empty (1) 1 2 3 explicit set (const key_compare&amp;amp; comp = key_compare(), const allocator_type&amp;amp; alloc = allocator_type()); explicit set (const allocator_type&amp;amp; alloc); range (2) 1 2 3 4 template &amp;lt;class InputIterator&amp;gt; set (InputIterator first, InputIterator last, const key_compare&amp;amp; comp = key_compare(), const allocator_type&amp;amp; = allocator_type()); copy (3) 1 2 set (const set&amp;amp; x); set (const set&amp;amp; x, const allocator_type&amp;amp; alloc); move (4) 1 2 set</description>
    </item>
    
    <item>
      <title>map和multimap操作总结</title>
      <link>http://localhost:1313/post/map%E5%92%8Cmultimap%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 16 Jul 2017 21:21:42 +0000</pubDate>
      
      <guid>http://localhost:1313/post/map%E5%92%8Cmultimap%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>map 构造函数 empty (1) 1 2 3 4 explicit map (const key_compare&amp;amp; comp = key_compare(), const allocator_type&amp;amp; alloc = allocator_type()); explicit map (const allocator_type&amp;amp; alloc); range (2) 1 2 3 4 template &amp;lt;class InputIterator&amp;gt; map (InputIterator first, InputIterator last, const key_compare&amp;amp; comp = key_compare(), const allocator_type&amp;amp; = allocator_type()); copy (3) 1 2 map (const map&amp;amp; x); map (const map&amp;amp; x, const allocator_type&amp;amp; alloc); move (4) 1 2</description>
    </item>
    
    <item>
      <title>stack,queue,priority_queue操作总结</title>
      <link>http://localhost:1313/post/stack-queue-priority-queue%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 16 Jul 2017 16:25:55 +0000</pubDate>
      
      <guid>http://localhost:1313/post/stack-queue-priority-queue%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>stack queue priority_queue priority_queue 对于基本类型的使用方法相对简单。他的模板声明带有三个参数: 1 priority_queue&amp;lt;Type, Container, Functional&amp;gt; 其中Type 为数据类型， Container 为保存数据的容器，Functional 为</description>
    </item>
    
    <item>
      <title>forward_list操作总结</title>
      <link>http://localhost:1313/post/forward-list%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 16 Jul 2017 16:25:06 +0000</pubDate>
      
      <guid>http://localhost:1313/post/forward-list%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>构造函数 default (1) 1 explicit forward_list (const allocator_type&amp;amp; alloc = allocator_type()); fill (2) 1 2 3 explicit forward_list (size_type n); explicit forward_list (size_type n, const value_type&amp;amp; val, const allocator_type&amp;amp; alloc = allocator_type()); range (3) 1 2 3 template &amp;lt;class InputIterator&amp;gt; forward_list (InputIterator first, InputIterator last, const allocator_type&amp;amp; alloc = allocator_type()); copy (4) 1 2 forward_list (const forward_list&amp;amp; fwdlst); forward_list (const forward_list&amp;amp; fwdlst, const allocator_type&amp;amp; alloc); move (5)</description>
    </item>
    
    <item>
      <title>deque操作总结</title>
      <link>http://localhost:1313/post/deque%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 15 Jul 2017 17:01:53 +0000</pubDate>
      
      <guid>http://localhost:1313/post/deque%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>deque操作和vector操作基本相同 构造函数 default (1) 1 explicit deque (const allocator_type&amp;amp; alloc = allocator_type()); fill (2) 1 2 3 explicit deque (size_type n); deque (size_type n, const value_type&amp;amp; val, const allocator_type&amp;amp; alloc = allocator_type()); range (3) 1 2 3 template &amp;lt;class InputIterator&amp;gt; deque (InputIterator first, InputIterator last, const allocator_type&amp;amp; alloc</description>
    </item>
    
    <item>
      <title>list操作总结</title>
      <link>http://localhost:1313/post/list%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 15 Jul 2017 11:56:15 +0000</pubDate>
      
      <guid>http://localhost:1313/post/list%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>构造函数 default (1) 1 explicit list (const allocator_type&amp;amp; alloc = allocator_type()); fill (2) 1 2 3 explicit list (size_type n); list (size_type n, const value_type&amp;amp; val, const allocator_type&amp;amp; alloc = allocator_type()); range (3) 1 2 3 template &amp;lt;class InputIterator&amp;gt; list (InputIterator first, InputIterator last, const allocator_type&amp;amp; alloc = allocator_type()); copy (4) 1 2 list (const list&amp;amp; x); list (const list&amp;amp; x, const allocator_type&amp;amp; alloc); move (5) 1</description>
    </item>
    
    <item>
      <title>vector操作总结</title>
      <link>http://localhost:1313/post/vector%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 15 Jul 2017 11:56:07 +0000</pubDate>
      
      <guid>http://localhost:1313/post/vector%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>vector容器的相关操作和string非常相似. 构造函数 default (1) 1 explicit vector (const allocator_type&amp;amp; alloc = allocator_type()); fill (2) 1 2 3 explicit vector (size_type n); vector (size_type n, const value_type&amp;amp; val, const allocator_type&amp;amp; alloc = allocator_type()); range (3) 1 2 3 template &amp;lt;class InputIterator&amp;gt; vector (InputIterator first,</description>
    </item>
    
    <item>
      <title>reverse_iterator的用法</title>
      <link>http://localhost:1313/post/reverse_iterator%E7%9A%84%E7%94%A8%E6%B3%95/</link>
      <pubDate>Fri, 14 Jul 2017 14:50:51 +0000</pubDate>
      
      <guid>http://localhost:1313/post/reverse_iterator%E7%9A%84%E7%94%A8%E6%B3%95/</guid>
      <description>基本区别 调用reverse_iterator的base()成员函数可以得到“与之相对应的”iterator，但是这句话实际上并没有说明真正的</description>
    </item>
    
    <item>
      <title>STL中的Traits编程技法</title>
      <link>http://localhost:1313/post/STL%E4%B8%AD%E7%9A%84Traits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95/</link>
      <pubDate>Sat, 24 Jun 2017 13:42:17 +0000</pubDate>
      
      <guid>http://localhost:1313/post/STL%E4%B8%AD%E7%9A%84Traits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95/</guid>
      <description>在STL实现中，traits编程技术得到大量的运用，它利用了“内嵌类型”的编程技巧与C++的template参数推导功能，弥补了C++类型识</description>
    </item>
    
    <item>
      <title>strcpy、strncpy、memcpy和memmove浅析</title>
      <link>http://localhost:1313/post/strcpystrncpymemcpy%E5%92%8Cmemmove%E6%B5%85%E6%9E%90/</link>
      <pubDate>Sat, 24 Jun 2017 13:23:32 +0000</pubDate>
      
      <guid>http://localhost:1313/post/strcpystrncpymemcpy%E5%92%8Cmemmove%E6%B5%85%E6%9E%90/</guid>
      <description>前言 本文仅对函数本身进行分析，不考虑编译环境的差异。 例如关于strcpy，memcpy和memmove关于内存重叠的问题，各个编译器和库都对</description>
    </item>
    
    <item>
      <title>迭代器和指针的区别</title>
      <link>http://localhost:1313/post/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 24 Jun 2017 11:42:56 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>迭代器： 迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&amp;gt;,*,++ –等封装了指针，</description>
    </item>
    
    <item>
      <title>STL迭代器特性及失效问题</title>
      <link>http://localhost:1313/post/STL%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%89%B9%E6%80%A7%E5%8F%8A%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Jun 2017 11:21:22 +0000</pubDate>
      
      <guid>http://localhost:1313/post/STL%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%89%B9%E6%80%A7%E5%8F%8A%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</guid>
      <description>vector vector是一个顺序容器，在内存中是一块连续的内存。引起内存重新分配的插入运算使所有迭代器失效，插入也使得插入位置及其后位置的迭代器失效</description>
    </item>
    
    <item>
      <title>STL中的快速排序改进版——内省排序</title>
      <link>http://localhost:1313/post/STL%E4%B8%AD%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%94%B9%E8%BF%9B%E7%89%88%E5%86%85%E7%9C%81%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 24 Jun 2017 11:19:44 +0000</pubDate>
      
      <guid>http://localhost:1313/post/STL%E4%B8%AD%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%94%B9%E8%BF%9B%E7%89%88%E5%86%85%E7%9C%81%E6%8E%92%E5%BA%8F/</guid>
      <description>快速排序是一种很快的算法，它平均的时间复杂度WieO(nlgn)， 最坏时间复杂度为O(n^2)。但是快排有很多改良版，其中一种就是内省式的快</description>
    </item>
    
    <item>
      <title>STL迭代器及辅助函数</title>
      <link>http://localhost:1313/post/STL%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8F%8A%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 23 Jun 2017 20:41:10 +0000</pubDate>
      
      <guid>http://localhost:1313/post/STL%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8F%8A%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/</guid>
      <description>迭代器类型 辅助函数 本文介绍了STL中的迭代器辅助函数的用法及注意事项，这些迭代器辅助函数包括：begin,end,advance, next (since C++11), prev (since</description>
    </item>
    
    <item>
      <title>仿函数和函数指针</title>
      <link>http://localhost:1313/post/%E4%BB%BF%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</link>
      <pubDate>Fri, 23 Jun 2017 17:11:28 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E4%BB%BF%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</guid>
      <description>函数指针 函数指针：是指向函数的指针变量，在C编译时，每一个函数都有一个入口地址，那么这个指向这个函数的函数指针便指向这个地址。 函数指针的用途</description>
    </item>
    
    <item>
      <title>string操作总结</title>
      <link>http://localhost:1313/post/string%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 23 Jun 2017 16:11:06 +0000</pubDate>
      
      <guid>http://localhost:1313/post/string%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>#构造函数 default (1) 1 string(); copy (2) 1 string (const string&amp;amp; str); substring (3) 1 string (const string&amp;amp; str, size_t pos, size_t len = npos); from c-string (4) 1 string (const char* s); from buffer (5) 1 string (const char* s, size_t n); fill (6) 1 string (size_t n, char c); range (7) 1 2 template &amp;lt;class InputIterator&amp;gt; string (InputIterator first, InputIterator last); initializer list (8)</description>
    </item>
    
  </channel>
</rss>