<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kubernetes on Forz Blog</title>
    <link>/categories/kubernetes/</link>
    <description>Recent content in Kubernetes on Forz Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 07 Jun 2021 10:41:48 +0000</lastBuildDate><atom:link href="/categories/kubernetes/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>K8s的日志采集实践</title>
      <link>/post/k8s%E7%9A%84%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Mon, 07 Jun 2021 10:41:48 +0000</pubDate>
      
      <guid>/post/k8s%E7%9A%84%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%AE%9E%E8%B7%B5/</guid>
      <description>Kubernetes中日志重要性 通常日志最基础的作用是记录程序的运行轨迹，在此之上会衍生出非常多的功能，例如线上监控、告警、运营分析、安全分</description>
    </item>
    
    <item>
      <title>K8s如何在环境变量中引用其他环境变量</title>
      <link>/post/k8s%E5%A6%82%E4%BD%95%E5%9C%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%AD%E5%BC%95%E7%94%A8%E5%85%B6%E4%BB%96%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</link>
      <pubDate>Sun, 06 Jun 2021 17:16:48 +0000</pubDate>
      
      <guid>/post/k8s%E5%A6%82%E4%BD%95%E5%9C%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%AD%E5%BC%95%E7%94%A8%E5%85%B6%E4%BB%96%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</guid>
      <description>我有一个Deployment使用Downward API公开 POD ID的对象。这很好用。但是，我想设置另一个环境变量，日志路径，参考 POD ID。但是，</description>
    </item>
    
    <item>
      <title>容器环境的GOMAXPROCS</title>
      <link>/post/%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84gomaxprocs/</link>
      <pubDate>Sat, 08 May 2021 18:06:58 +0000</pubDate>
      
      <guid>/post/%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84gomaxprocs/</guid>
      <description>CPU Affinity 熟系 Linux 后台开发的朋友都知道 CPU 亲和性（CPU Affinity）。CPU Affinity 是一种调度属性，它可以将单个进程绑定到一个或一组 CPU 上。 在 SMP（S</description>
    </item>
    
    <item>
      <title>如何编写Docker镜像</title>
      <link>/post/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99docker%E9%95%9C%E5%83%8F/</link>
      <pubDate>Sat, 13 Mar 2021 21:59:49 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99docker%E9%95%9C%E5%83%8F/</guid>
      <description>优化基础镜像 优化基础镜像的方法就是选用合适的更小的基础镜像，常用的 Linux 系统镜像一般有 Ubuntu、CentOs、Alpine，其中Alpine</description>
    </item>
    
    <item>
      <title>如何构建Go的镜像</title>
      <link>/post/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BAgo%E7%9A%84%E9%95%9C%E5%83%8F/</link>
      <pubDate>Fri, 12 Mar 2021 23:33:43 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BAgo%E7%9A%84%E9%95%9C%E5%83%8F/</guid>
      <description>示例应用 首先贴出代码例子，我们假设要构建一个 http 服务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;time&amp;#34; &amp;#34;github.com/gin-gonic/gin&amp;#34; ) func main() { fmt.Println(&amp;#34;Server Ready&amp;#34;) router :=</description>
    </item>
    
    <item>
      <title>Dockerfile参考</title>
      <link>/post/dockerfile%E5%8F%82%E8%80%83/</link>
      <pubDate>Wed, 03 Mar 2021 13:25:03 +0000</pubDate>
      
      <guid>/post/dockerfile%E5%8F%82%E8%80%83/</guid>
      <description>Dockerfile参考（Dockerfile reference） Docker可以通过读取Dockerfile中的指令自动构建镜像。 Dock</description>
    </item>
    
    <item>
      <title>GRPC在k8s集群中的负载均衡</title>
      <link>/post/grpc%E5%9C%A8k8s%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</link>
      <pubDate>Mon, 22 Feb 2021 17:48:28 +0000</pubDate>
      
      <guid>/post/grpc%E5%9C%A8k8s%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</guid>
      <description>背景 很多刚刚接触 gRPC 的用户，通常会惊讶于 Kubernetes 默认提供的负载均衡对于 gRPC 来说无法实现开箱即用的效果。比如，将一个简单的基于 Node.js 实现的 gRPC 微服务部署在 Kubernetes 后</description>
    </item>
    
    <item>
      <title>Nginx Ingress如何负载grpc</title>
      <link>/post/nginx-ingress%E5%A6%82%E4%BD%95%E8%B4%9F%E8%BD%BDgrpc/</link>
      <pubDate>Mon, 22 Feb 2021 17:31:40 +0000</pubDate>
      
      <guid>/post/nginx-ingress%E5%A6%82%E4%BD%95%E8%B4%9F%E8%BD%BDgrpc/</guid>
      <description>概述 一般情况下，我们的系统对外暴露HTTP/HTTPS的接口，内部使用rpc(GRPC)通讯，这时GRPC在服务之间通过service访问，</description>
    </item>
    
  </channel>
</rss>
