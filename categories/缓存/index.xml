<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>缓存 on Forz Blog</title>
    <link>/categories/%E7%BC%93%E5%AD%98/</link>
    <description>Recent content in 缓存 on Forz Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 07 Dec 2021 11:25:23 +0000</lastBuildDate><atom:link href="/categories/%E7%BC%93%E5%AD%98/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>布隆过滤器实现</title>
      <link>/post/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Tue, 07 Dec 2021 11:25:23 +0000</pubDate>
      
      <guid>/post/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%AE%9E%E7%8E%B0/</guid>
      <description>前言 想象一下遇到下面的场景你会如何处理： 手机号是否重复注册 用户是否参与过某秒杀活动 伪造请求大量 id 查询不存在的记录，此时缓存未命中,如何避免缓</description>
    </item>
    
    <item>
      <title>如何保证缓存一致性</title>
      <link>/post/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Sun, 28 Nov 2021 22:31:47 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      <description>旁路缓存 在实际业务中，我们经常采用的一种缓存策略如下： 缓存-数据库读流程 用户发起查询请求 业务服务首先根据关键参数作为key查询缓存 如果数据在</description>
    </item>
    
    <item>
      <title>Memchache和redis的选型对比</title>
      <link>/post/memchache%E5%92%8Credis%E7%9A%84%E9%80%89%E5%9E%8B%E5%AF%B9%E6%AF%94/</link>
      <pubDate>Sun, 28 Nov 2021 22:02:53 +0000</pubDate>
      
      <guid>/post/memchache%E5%92%8Credis%E7%9A%84%E9%80%89%E5%9E%8B%E5%AF%B9%E6%AF%94/</guid>
      <description>memcache memcache 提供简单的 kv cache 存储，value 大小不超过1mb。 我使用 memcache 作为大文本或者简单的 kv结构使用。 memcache 使用了slab 方式做内存管理，存在一定的浪费</description>
    </item>
    
    <item>
      <title>缓存穿透、缓存击穿、缓存雪崩</title>
      <link>/post/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/</link>
      <pubDate>Tue, 09 Jun 2020 18:12:50 +0000</pubDate>
      
      <guid>/post/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/</guid>
      <description>缓存雪崩 缓存雪崩是指大量的应用请求无法在 Redis 缓存中进行处理,紧接着,应用将大量请求发送到数据库层,导致数据库层的压力激增。 缓存雪崩一般是由两个</description>
    </item>
    
  </channel>
</rss>
