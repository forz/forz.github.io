<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>k8s on Forz Blog</title>
    <link>/categories/k8s/</link>
    <description>Recent content in k8s on Forz Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 07 Jun 2021 18:49:05 +0000</lastBuildDate><atom:link href="/categories/k8s/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>为什么容器内存占用居高不下，频频 OOM</title>
      <link>/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%B9%E5%99%A8%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%B1%85%E9%AB%98%E4%B8%8D%E4%B8%8B%E9%A2%91%E9%A2%91-oom/</link>
      <pubDate>Mon, 07 Jun 2021 18:49:05 +0000</pubDate>
      
      <guid>/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%B9%E5%99%A8%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%B1%85%E9%AB%98%E4%B8%8D%E4%B8%8B%E9%A2%91%E9%A2%91-oom/</guid>
      <description>前言 最近我在回顾思考（写 PPT），整理了现状，发现了这个问题存在多时，经过一番波折，最终确定了元凶和相对可行的解决方案，因此也在这里分享一下</description>
    </item>
    
    <item>
      <title>K8s的日志采集实践</title>
      <link>/post/k8s%E7%9A%84%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Mon, 07 Jun 2021 10:41:48 +0000</pubDate>
      
      <guid>/post/k8s%E7%9A%84%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%AE%9E%E8%B7%B5/</guid>
      <description>Kubernetes中日志重要性 通常日志最基础的作用是记录程序的运行轨迹，在此之上会衍生出非常多的功能，例如线上监控、告警、运营分析、安全分</description>
    </item>
    
    <item>
      <title>K8s如何在环境变量中引用其他环境变量</title>
      <link>/post/k8s%E5%A6%82%E4%BD%95%E5%9C%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%AD%E5%BC%95%E7%94%A8%E5%85%B6%E4%BB%96%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</link>
      <pubDate>Sun, 06 Jun 2021 17:16:48 +0000</pubDate>
      
      <guid>/post/k8s%E5%A6%82%E4%BD%95%E5%9C%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%AD%E5%BC%95%E7%94%A8%E5%85%B6%E4%BB%96%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</guid>
      <description>我有一个Deployment使用Downward API公开 POD ID的对象。这很好用。但是，我想设置另一个环境变量，日志路径，参考 POD ID。但是，</description>
    </item>
    
    <item>
      <title>容器环境的GOMAXPROCS</title>
      <link>/post/%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84gomaxprocs/</link>
      <pubDate>Sat, 08 May 2021 18:06:58 +0000</pubDate>
      
      <guid>/post/%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84gomaxprocs/</guid>
      <description>CPU Affinity 熟系 Linux 后台开发的朋友都知道 CPU 亲和性（CPU Affinity）。CPU Affinity 是一种调度属性，它可以将单个进程绑定到一个或一组 CPU 上。 在 SMP（S</description>
    </item>
    
    <item>
      <title>Grpc在k8s集群中的负载均衡</title>
      <link>/post/grpc%E5%9C%A8k8s%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</link>
      <pubDate>Mon, 22 Feb 2021 17:48:28 +0000</pubDate>
      
      <guid>/post/grpc%E5%9C%A8k8s%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</guid>
      <description>背景 很多刚刚接触 gRPC 的用户，通常会惊讶于 Kubernetes 默认提供的负载均衡对于 gRPC 来说无法实现开箱即用的效果。比如，将一个简单的基于 Node.js 实现的 gRPC 微服务部署在 Kubernetes 后</description>
    </item>
    
    <item>
      <title>Nginx Ingress如何负载grpc</title>
      <link>/post/nginx-ingress%E5%A6%82%E4%BD%95%E8%B4%9F%E8%BD%BDgrpc/</link>
      <pubDate>Mon, 22 Feb 2021 17:31:40 +0000</pubDate>
      
      <guid>/post/nginx-ingress%E5%A6%82%E4%BD%95%E8%B4%9F%E8%BD%BDgrpc/</guid>
      <description>概述 一般情况下，我们的系统对外暴露HTTP/HTTPS的接口，内部使用rpc(GRPC)通讯，这时GRPC在服务之间通过service访问，</description>
    </item>
    
  </channel>
</rss>
