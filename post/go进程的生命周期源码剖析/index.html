<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go进程的生命周期源码剖析 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="runtime Go 语言是一⻔有 runtime 的语言，那么 runtime 是什么? 可以认为 runtime 是为了实现额外的功能，而在程序运行时自动 加载/运行的一些模块。 Go 语言的 runtime 包括: 这些模块中，" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.93.3 with theme even" />


<link rel="canonical" href="/post/go%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go进程的生命周期源码剖析" />
<meta property="og:description" content="runtime Go 语言是一⻔有 runtime 的语言，那么 runtime 是什么? 可以认为 runtime 是为了实现额外的功能，而在程序运行时自动 加载/运行的一些模块。 Go 语言的 runtime 包括: 这些模块中，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-11-18T14:34:06+00:00" />
<meta property="article:modified_time" content="2020-11-18T14:34:06+00:00" />

<meta itemprop="name" content="Go进程的生命周期源码剖析">
<meta itemprop="description" content="runtime Go 语言是一⻔有 runtime 的语言，那么 runtime 是什么? 可以认为 runtime 是为了实现额外的功能，而在程序运行时自动 加载/运行的一些模块。 Go 语言的 runtime 包括: 这些模块中，"><meta itemprop="datePublished" content="2020-11-18T14:34:06+00:00" />
<meta itemprop="dateModified" content="2020-11-18T14:34:06+00:00" />
<meta itemprop="wordCount" content="9172">
<meta itemprop="keywords" content="Go源码," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go进程的生命周期源码剖析"/>
<meta name="twitter:description" content="runtime Go 语言是一⻔有 runtime 的语言，那么 runtime 是什么? 可以认为 runtime 是为了实现额外的功能，而在程序运行时自动 加载/运行的一些模块。 Go 语言的 runtime 包括: 这些模块中，"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go进程的生命周期源码剖析</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-11-18 </span>
        <div class="post-category">
            <a href="/categories/go%E6%BA%90%E7%A0%81/"> Go源码 </a>
            </div>
          <span class="more-meta"> 约 9172 字 </span>
          <span class="more-meta"> 预计阅读 19 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#runtime">runtime</a></li>
    <li><a href="#调度器的生命周期">调度器的生命周期</a></li>
    <li><a href="#go进程的执行入口">Go进程的执行入口</a></li>
    <li><a href="#go启动的初始化工作">Go启动的初始化工作</a>
      <ul>
        <li><a href="#argc和argv处理">argc和argv处理</a></li>
        <li><a href="#全局g0和m0初始化">全局g0和m0初始化</a></li>
        <li><a href="#初始化系统核心数与调度器">初始化系统核心数与调度器</a></li>
        <li><a href="#创建runtime-main-goroutine">创建runtime main goroutine</a></li>
        <li><a href="#主线程开始-schedule-循环">主线程开始 schedule 循环</a></li>
      </ul>
    </li>
    <li><a href="#runtime-main-goroutine-执行与退出">runtime main goroutine 执行与退出</a></li>
    <li><a href="#转载">转载</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="runtime">runtime</h2>
<p>Go 语言是一⻔有 runtime 的语言，那么 runtime 是什么?</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210808222206.png" alt=""></p>
<p>可以认为 runtime 是为了实现额外的功能，而在程序运行时自动 加载/运行的一些模块。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210808222246.png" alt=""></p>
<p>Go 语言的 runtime 包括:</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210808222331.png" alt=""></p>
<p>这些模块中，最核心的就是 Scheduler，它负责串联所有的 runtime 流程.</p>
<h2 id="调度器的生命周期">调度器的生命周期</h2>
<p>所有的Go程序运行都会经过一个完整的调度器生命周期：从创建到结束。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20190706204142.png" alt=""></p>
<p>即使下面这段简单的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// main.main
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello scheduler&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>也会经历如上图所示的过程：</p>
<ol>
<li>runtime创建最初的线程m0和goroutine g0，并把2者关联。</li>
<li>调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。</li>
<li>示例代码中的main函数是main.main，runtime中也有1个main函数——runtime.main，代码经过编译后，runtime.main会调用main.main，程序启动时会为runtime.main创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。</li>
<li>启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。</li>
<li>G拥有栈，M根据G中的栈信息和调度信息设置运行环境</li>
<li>M运行G</li>
<li>G退出，再次回到M获取可运行的G，这样重复下去，直到main.main退出，runtime.main执行Defer和Panic处理，或调用runtime.exit退出程序。</li>
</ol>
<p>调度器的生命周期几乎占满了一个Go程序的一生，runtime.main的goroutine执行之前都是为调度器做准备工作，runtime.main的goroutine运行，才是调度器的真正开始，直到runtime.main结束而结束。</p>
<p>M0 是启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了。</p>
<p>G0 是每次启动一个 M 都会第一个创建的 gourtine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0。</p>
<h2 id="go进程的执行入口">Go进程的执行入口</h2>
<p>在 proc.go 和 runtime2.go 文件中，有一些很重要全局的变量，我们先列出来：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 所有 g 的长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">allglen</span>     <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 保存所有的 g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">allgs</span>    <span class="p">[]</span><span class="o">*</span><span class="nx">g</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 保存所有的 m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">allm</span>        <span class="o">*</span><span class="nx">m</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 保存所有的 p，_MaxGomaxprocs = 1024
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">allp</span>        <span class="p">[</span><span class="nx">_MaxGomaxprocs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nx">p</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// p 的最大值，默认等于 ncpu
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">gomaxprocs</span>  <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 程序启动时，会调用 osinit 函数获得此值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">ncpu</span>        <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 调度器结构体对象，记录了调度器的工作状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">sched</span>       <span class="nx">schedt</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 代表进程的主线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">m0</span>           <span class="nx">m</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// m0 的 g0，即 m0.g0 = &amp;g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">g0</span>           <span class="nx">g</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在程序初始化时，这些全局变量都会被初始化为零值：指针被初始化为 nil 指针，切片被初始化为 nil 切片，int 被初始化为 0，结构体的所有成员变量按其类型被初始化为对应的零值。</p>
<p>因此程序刚启动时 allgs，allm 和allp 都不包含任何 g，m 和 p。</p>
<p>不仅是 Go 程序，系统加载可执行文件大概都会经过这几个阶段：</p>
<ol>
<li>从磁盘上读取可执行文件，加载到内存</li>
<li>创建进程和主线程</li>
<li>为主线程分配栈空间</li>
<li>把由用户在命令行输入的参数拷贝到主线程的栈</li>
<li>把主线程放入操作系统的运行队列等待被调度</li>
</ol>
<p>我们从一个 Hello World 的例子来回顾一下 Go 程序初始化的过程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello world&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在项目根目录下执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="line"><span class="cl"><span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">gcflags</span> <span class="s">&#34;-N -l&#34;</span> <span class="o">-</span><span class="n">o</span> <span class="n">hello</span> <span class="n">src</span><span class="o">/</span><span class="n">main.go</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>-gcflags &ldquo;-N -l&rdquo; 是为了关闭编译器优化和函数内联，防止后面在设置断点的时候找不到相对应的代码位置。</p>
<p>得到了可执行文件 hello，执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="line"><span class="cl"><span class="n">gdb</span> <span class="n">hello</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>进入 gdb 调试模式，执行 info files，得到可执行文件的文件头，列出了各种段：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201116150146.png" alt=""></p>
<p>同时，我们也得到了入口地址：0x450e20。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="line"><span class="cl"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">b</span> <span class="o">*</span><span class="mh">0x450e20</span>
</span></span><span class="line"><span class="cl"><span class="n">Breakpoint</span> <span class="m">1</span> <span class="n">at</span> <span class="mh">0x450e20</span><span class="o">:</span> <span class="n">file</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">rt0_linux_amd64.s</span><span class="p">,</span> <span class="n">line</span> <span class="m">8</span><span class="n">.
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这就是 Go 程序的入口地址，我是在 linux 上运行的，所以入口文件为 src/runtime/rt0_linux_amd64.s，runtime 目录下有各种不同名称的程序入口文件，支持各种操作系统和架构，代码为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="line"><span class="cl"><span class="n">TEXT</span> <span class="nf">_rt0_amd64_linux</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span><span class="n">NOSPLIT</span><span class="p">,</span><span class="o">$</span><span class="m">-8</span>
</span></span><span class="line"><span class="cl">    <span class="n">LEAQ</span>    <span class="m">8</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">SI</span> <span class="o">//</span> <span class="n">argv</span>
</span></span><span class="line"><span class="cl">    <span class="n">MOVQ</span>    <span class="m">0</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">DI</span> <span class="o">//</span> <span class="n">argc</span>
</span></span><span class="line"><span class="cl">    <span class="n">MOVQ</span>    <span class="o">$</span><span class="nf">main</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">AX</span>
</span></span><span class="line"><span class="cl">    <span class="n">JMP</span>    <span class="n">AX</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>主要是把 argc，argv 从内存拉到了寄存器。这里 LEAQ 是计算内存地址，然后把内存地址本身放进寄存器里，也就是把 argv 的地址放到了 SI 寄存器中。最后跳转到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="line"><span class="cl"><span class="n">TEXT</span> <span class="nf">main</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span><span class="n">NOSPLIT</span><span class="p">,</span><span class="o">$</span><span class="m">-8</span>
</span></span><span class="line"><span class="cl">    <span class="n">MOVQ</span>    <span class="o">$</span><span class="n">runtime</span>·<span class="nf">rt0_go</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">AX</span>
</span></span><span class="line"><span class="cl">    <span class="n">JMP</span>    <span class="n">AX</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210808222750.png" alt=""></p>
<p>继续跳转到 runtime·rt0_go(SB)，完成 go 启动时所有的初始化工作。位于 /usr/local/go/src/runtime/asm_amd64.s.</p>
<p>或者使用开源反编译工具cutter.</p>
<h2 id="go启动的初始化工作">Go启动的初始化工作</h2>
<p>rt0_go完成 go 启动时所有的初始化工作.请注意这里的用户mian函数是通过执行runtime.main函数来执行的.</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210808222951.png" alt=""></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">rt0_go</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span><span class="nx">NOSPLIT</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// copy arguments forward on an even stack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">DI</span><span class="p">,</span> <span class="nx">AX</span>      <span class="c1">// argc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">SI</span><span class="p">,</span> <span class="nx">BX</span>      <span class="c1">// argv
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">SUBQ</span>    <span class="err">$</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="mi">8</span><span class="o">+</span><span class="mi">7</span><span class="p">),</span> <span class="nx">SP</span>        <span class="c1">// 2args 2auto
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 调整栈顶寄存器使其按 16 字节对齐
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ANDQ</span>    <span class="err">$~</span><span class="mi">15</span><span class="p">,</span> <span class="nx">SP</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// argc 放在 SP+16 字节处
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// argv 放在 SP+24 字节处
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">BX</span><span class="p">,</span> <span class="mi">24</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// create istack out of the given (operating system) stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// _cgo_init may update stackguard.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 给 g0 分配栈空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 把 g0 的地址存入 DI
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">g0</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">DI</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// BX = SP - 64*1024 + 104
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">LEAQ</span>    <span class="p">(</span><span class="o">-</span><span class="mi">64</span><span class="o">*</span><span class="mi">1024</span><span class="o">+</span><span class="mi">104</span><span class="p">)(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BX</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// g0.stackguard0 = SP - 64*1024 + 104
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">BX</span><span class="p">,</span> <span class="nf">g_stackguard0</span><span class="p">(</span><span class="nx">DI</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// g0.stackguard1 = SP - 64*1024 + 104
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">BX</span><span class="p">,</span> <span class="nf">g_stackguard1</span><span class="p">(</span><span class="nx">DI</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// g0.stack.lo = SP - 64*1024 + 104
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">BX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_stack</span><span class="o">+</span><span class="nx">stack_lo</span><span class="p">)(</span><span class="nx">DI</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// g0.stack.hi = SP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">SP</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_stack</span><span class="o">+</span><span class="nx">stack_hi</span><span class="p">)(</span><span class="nx">DI</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ……………………
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 省略了很多检测 CPU 信息的代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ……………………
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化 m 的 tls
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// DI = &amp;m0.tls，取 m0 的 tls 成员的地址到 DI 寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">LEAQ</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nx">m0</span><span class="o">+</span><span class="nf">m_tls</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">DI</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用 settls 设置线程本地存储，settls 函数的参数在 DI 寄存器中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 之后，可通过 fs 段寄存器找到 m.tls
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">settls</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// store through it, to make sure it works
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 获取 fs 段基址并放入 BX 寄存器，其实就是 m0.tls[1] 的地址，get_tls 的代码由编译器生成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">get_tls</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mh">0x123</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">MOVQ</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nx">m0</span><span class="o">+</span><span class="nf">m_tls</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
</span></span><span class="line"><span class="cl">    <span class="nx">CMPQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="err">$</span><span class="mh">0x123</span>
</span></span><span class="line"><span class="cl">    <span class="nx">JEQ</span> <span class="mi">2</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">MOVL</span>    <span class="nx">AX</span><span class="p">,</span> <span class="mi">0</span>   <span class="c1">// abort
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">ok</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// set the per-goroutine and per-mach &#34;registers&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 获取 fs 段基址到 BX 寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">get_tls</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将 g0 的地址存储到 CX，CX = &amp;g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">LEAQ</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">g0</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">CX</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 把 g0 的地址保存在线程本地存储里面，也就是 m0.tls[0]=&amp;g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">CX</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将 m0 的地址存储到 AX，AX = &amp;m0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">LEAQ</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">m0</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// save m-&gt;g0 = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// m0.g0 = &amp;g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">CX</span><span class="p">,</span> <span class="nf">m_g0</span><span class="p">(</span><span class="nx">AX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// save m0 to g0-&gt;m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// g0.m = &amp;m0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="nf">g_m</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">CLD</span>             <span class="c1">// convention is D is always left cleared
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">check</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">MOVL</span>    <span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>      <span class="c1">// copy argc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MOVL</span>    <span class="nx">AX</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">MOVQ</span>    <span class="mi">24</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>      <span class="c1">// copy argv
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">args</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化系统核心数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">osinit</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 调度器初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">schedinit</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// create a new goroutine to start program
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 创建一个新的 goroutine 来启动程序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">mainPC</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>     <span class="c1">// entry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// newproc 的第二个参数入栈，也就是新的 goroutine 需要执行的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// AX = &amp;funcval{runtime·main},
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">PUSHQ</span>   <span class="nx">AX</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// newproc 的第一个参数入栈，该参数表示 runtime.main 函数需要的参数大小，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 因为 runtime.main 没有参数，所以这里是 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">PUSHQ</span>   <span class="err">$</span><span class="mi">0</span>          <span class="c1">// arg size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 创建 main goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">newproc</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">POPQ</span>    <span class="nx">AX</span>
</span></span><span class="line"><span class="cl">    <span class="nx">POPQ</span>    <span class="nx">AX</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// start this M
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 主线程进入调度循环，运行刚刚创建的 goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">mstart</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 永远不会返回，万一返回了，crash 掉
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MOVL</span>    <span class="err">$</span><span class="mh">0xf1</span><span class="p">,</span> <span class="mh">0xf1</span>  <span class="c1">// crash
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">RET</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码完成之后，整个 Go 程序就可以跑起来了。</p>
<p>调度器初始化函数：schedinit 返回后，调度器的相关参数都已经初始化好了.</p>
<h3 id="argc和argv处理">argc和argv处理</h3>
<p>第一段代码，将 SP 调整到了一个地址是 16 的倍数的位置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">SUBQ</span>    <span class="err">$</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="mi">8</span><span class="o">+</span><span class="mi">7</span><span class="p">),</span> <span class="nx">SP</span>        <span class="c1">// 2args 2auto
</span></span></span><span class="line"><span class="cl"><span class="c1">// 调整栈顶寄存器使其按 16 个字节对齐
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">ANDQ</span>    <span class="err">$~</span><span class="mi">15</span><span class="p">,</span> <span class="nx">SP</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>先是将 SP 减掉 39，也就是向下移动了 39 个 Byte，再进行与运算。</p>
<p>15 的二进制低四位是全 1：1111，其他位都是 0；取反后，变成了 0000，高位则是全 1。这样，与 SP 进行了与运算后，低 4 位变成了全 0，高位则不变。因此 SP 继续向下移动，并且这回是在一个地址值为 16 的倍数的地方，16 字节对齐的地方。</p>
<p>为什么要这么做？画一张图就明白了。不过先得说明一点，前面 _rt0_amd64_linux 函数里讲过，DI 里存的是 argc 的值，8 个字节，而 SI 里则存的是 argv 的地址，8 个字节。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201116151357.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201116151417.png" alt=""></p>
<p>上面两张图中，左侧用箭头标注了 16 字节对齐的位置。第一步表示向下移动 39 B，第二步表示与 ~15 相与。
存在两种情况，这也是第一步将 SP 下移的时候，多移了 7 个 Byte 的原因。第一张图里，与 ~15 相与的时候，SP 值减少了 1，第二张图则减少了 9。最后都是移位到了 16 字节对齐的位置。</p>
<p>两张图的共同点是 SP 与 argc 中间多出了 16 个字节的空位。这个后面应该会用到，我们接着探索。</p>
<p>至于为什么进行 16 个字节对齐，就比较好理解了：因为 CPU 有一组 SSE 指令，这些指令中出现的内存地址必须是 16 的倍数。</p>
<h3 id="全局g0和m0初始化">全局g0和m0初始化</h3>
<p>接着往后看，开始初始化 g0 的栈了。g0 栈的作用就是为运行 runtime 代码提供一个“环境”。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 把 g0 的地址存入 DI
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">MOVQ</span>    <span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">g0</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">DI</span>
</span></span><span class="line"><span class="cl"><span class="c1">// BX = SP - 64*1024 + 104
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">LEAQ</span>    <span class="p">(</span><span class="o">-</span><span class="mi">64</span><span class="o">*</span><span class="mi">1024</span><span class="o">+</span><span class="mi">104</span><span class="p">)(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BX</span>
</span></span><span class="line"><span class="cl"><span class="c1">// g0.stackguard0 = SP - 64*1024 + 104
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">MOVQ</span>    <span class="nx">BX</span><span class="p">,</span> <span class="nf">g_stackguard0</span><span class="p">(</span><span class="nx">DI</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// g0.stackguard1 = SP - 64*1024 + 104
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">MOVQ</span>    <span class="nx">BX</span><span class="p">,</span> <span class="nf">g_stackguard1</span><span class="p">(</span><span class="nx">DI</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// g0.stack.lo = SP - 64*1024 + 104
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">MOVQ</span>    <span class="nx">BX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_stack</span><span class="o">+</span><span class="nx">stack_lo</span><span class="p">)(</span><span class="nx">DI</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// g0.stack.hi = SP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">MOVQ</span>    <span class="nx">SP</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_stack</span><span class="o">+</span><span class="nx">stack_hi</span><span class="p">)(</span><span class="nx">DI</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码 L2 把 g0 的地址存入 DI 寄存器；L4 将 SP 下移 (64K-104)B，并将地址存入 BX 寄存器；L6 将 BX 里存储的地址赋给 g0.stackguard0；L8，L10，L12 分别 将 BX 里存储的地址赋给 g0.stackguard1， g0.stack.lo， g0.stack.hi。</p>
<p>这部分完成之后，g0 栈空间如下图：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201116151552.png" alt=""></p>
<p>m0: Go 程序启动后创建的第一个线程</p>
<p>接着往下看，中间我们省略了很多检查 CPU 相关的代码，直接看主线程绑定 m0 的部分：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 初始化 m 的 tls
</span></span></span><span class="line"><span class="cl"><span class="c1">// DI = &amp;m0.tls，取 m0 的 tls 成员的地址到 DI 寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">LEAQ</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nx">m0</span><span class="o">+</span><span class="nf">m_tls</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">DI</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 调用 settls 设置线程本地存储，settls 函数的参数在 DI 寄存器中
</span></span></span><span class="line"><span class="cl"><span class="c1">// 之后，可通过 fs 段寄存器找到 m.tls
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">settls</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// store through it, to make sure it works
</span></span></span><span class="line"><span class="cl"><span class="c1">// 获取 fs 段基地址并放入 BX 寄存器，其实就是 m0.tls[1] 的地址，get_tls 的代码由编译器生成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">get_tls</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">MOVQ</span>    <span class="err">$</span><span class="mh">0x123</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">MOVQ</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nx">m0</span><span class="o">+</span><span class="nf">m_tls</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
</span></span><span class="line"><span class="cl"><span class="nx">CMPQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="err">$</span><span class="mh">0x123</span>
</span></span><span class="line"><span class="cl"><span class="nx">JEQ</span> <span class="mi">2</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">MOVL</span>    <span class="nx">AX</span><span class="p">,</span> <span class="mi">0</span>    <span class="c1">// abort
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因为 m0 是全局变量，而 m0 又要绑定到工作线程才能执行。我们又知道，runtime 会启动多个工作线程，每个线程都会绑定一个 m0。而且，代码里还得保持一致，都是用 m0 来表示。这就要用到线程本地存储的知识了，也就是常说的 TLS（Thread Local Storage）。简单来说，TLS 就是线程本地的私有的全局变量。</p>
<p>一般而言，全局变量对进程中的多个线程同时可见。进程中的全局变量与函数内定义的静态（static）变量，是各个线程都可以访问的共享变量。一个线程修改了，其他线程就会“看见”。要想搞出一个线程私有的变量，就需要用到 TLS 技术。</p>
<p>如果需要在一个线程内部的各个函数调用都能访问、但其它线程不能访问的变量（被称为 static memory local to a thread，线程局部静态变量），就需要新的机制来实现。这就是 TLS。</p>
<p>继续来看源码，L3 将 m0.tls 地址存储到 DI 寄存器，再调用 settls 完成 tls 的设置，tls 是 m 结构体中的一个数组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// thread-local storage (for x86 extern register)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">tls</span> <span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="kt">uintptr</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>设置 tls 的函数 runtime·settls(SB) 位于源码 src/runtime/sys_linux_amd64.s 处，主要内容就是通过一个系统调用将 fs 段基址设置成 m.tls[1] 的地址，而 fs 段基址又可以通过 CPU 里的寄存器 fs 来获取。</p>
<p>而每个线程都有自己的一组 CPU 寄存器值，操作系统在把线程调离 CPU 时会帮我们把所有寄存器中的值保存在内存中，调度线程来运行时又会从内存中把这些寄存器的值恢复到 CPU。</p>
<p>这样，工作线程代码就可以通过 fs 寄存器来找到 m.tls。</p>
<p>设置完 tls 之后，又来了一段验证上面 settls 是否能正常工作。如果不能，会直接 crash。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nf">get_tls</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">MOVQ</span>    <span class="err">$</span><span class="mh">0x123</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">MOVQ</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nx">m0</span><span class="o">+</span><span class="nf">m_tls</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
</span></span><span class="line"><span class="cl"><span class="nx">CMPQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="err">$</span><span class="mh">0x123</span>
</span></span><span class="line"><span class="cl"><span class="nx">JEQ</span> <span class="mi">2</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">MOVL</span>    <span class="nx">AX</span><span class="p">,</span> <span class="mi">0</span>    <span class="c1">// abort
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>第一行代码，获取 tls，get_tls(BX) 的代码由编译器生成，源码中并没有看到，可以理解为将 m.tls 的地址存入 BX 寄存器。</p>
<p>L2 将一个数 0x123 放入 m.tls[0] 处，L3 则将 m.tls[0] 处的数据取出来放到 AX 寄存器，L4 则比较两者是否相等。如果相等，则跳过 L6 行的代码，否则执行 L6，程序 crash。</p>
<p>继续看代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// set the per-goroutine and per-mach &#34;registers&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1">// 获取 fs 段基址到 BX 寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">get_tls</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 将 g0 的地址存储到 CX，CX = &amp;g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">LEAQ</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">g0</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">CX</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把 g0 的地址保存在线程本地存储里面，也就是 m0.tls[0]=&amp;g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">MOVQ</span>    <span class="nx">CX</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 将 m0 的地址存储到 AX，AX = &amp;m0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">LEAQ</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">m0</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// save m-&gt;g0 = g0
</span></span></span><span class="line"><span class="cl"><span class="c1">// m0.g0 = &amp;g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">MOVQ</span>    <span class="nx">CX</span><span class="p">,</span> <span class="nf">m_g0</span><span class="p">(</span><span class="nx">AX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// save m0 to g0-&gt;m
</span></span></span><span class="line"><span class="cl"><span class="c1">// g0.m = &amp;m0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="nf">g_m</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>L3 将 m.tls 地址存入 BX；L5 将 g0 的地址存入 CX；L7 将 CX，也就是 g0 的地址存入 m.tls[0]；L9 将 m0 的地址存入 AX；L13 将 g0 的地址存入 m0.g0；L16 将 m0 存入 g0.m。也就是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">tls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="nx">g0</span>
</span></span><span class="line"><span class="cl"><span class="nx">m0</span><span class="p">.</span><span class="nx">g0</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">g0</span>
</span></span><span class="line"><span class="cl"><span class="nx">g0</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">m0</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码中寄存器前面的符号看着比较奇怪，其实它们最后会被链接器转化为偏移量。</p>
<p>这种写法在标准 plan9 汇编中只是个 symbol，没有任何偏移量的意思，但这里却用名字来代替了其偏移量，这是怎么回事呢？</p>
<p>实际上这是 runtime 的特权，是需要链接器配合完成的，再来看看 gobuf 在 runtime 中的 struct 定义开头部分的注释:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// The offsets of sp, pc, and g are known to (hard-coded in) libmach.
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于我们而言，这种写法读起来比较容易。</p>
<p>这一段执行完之后，就把 m0，g0，m.tls[0] 串联起来了。通过 m.tls[0] 可以找到 g0，通过 g0 可以找到 m0（通过 g 结构体的 m 字段）。并且，通过 m 的字段 g0，m0 也可以找到 g0。于是，主线程和 m0，g0 就关联起来了。</p>
<p>从这里还可以看到，保存在主线程本地存储中的值是 g0 的地址，也就是说工作线程的私有全局变量其实是一个指向 g 的指针而不是指向 m 的指针。</p>
<p>目前这个指针指向g0，表示代码正运行在 g0 栈。</p>
<p>于是，前面的图又增加了新的玩伴 m0：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201116161105.png" alt=""></p>
<h3 id="初始化系统核心数与调度器">初始化系统核心数与调度器</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">MOVL</span>    <span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>        <span class="c1">// copy argc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">MOVL</span>    <span class="nx">AX</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">MOVQ</span>    <span class="mi">24</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>        <span class="c1">// copy argv
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">args</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 初始化系统核心数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">osinit</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 调度器初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">schedinit</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>L1-L2 将 16(SP) 处的内容移动到 0(SP)，也就是栈顶，通过前面的图，16(SP) 处的内容为 argc；L3-L4 将 argv 存入 8(SP)，接下来调用 runtime·args 函数，处理命令行参数。</p>
<p>接着，连续调用了两个 runtime 函数。osinit 函数初始化系统核心数，将全局变量 ncpu 初始化的核心数，schedinit 则是调度器的初始化。</p>
<h3 id="创建runtime-main-goroutine">创建runtime main goroutine</h3>
<p>继续看代码，前面我们完成了 schedinit 函数，这是 runtime·rt0_go 函数里的一步，接着往后看：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 创建一个新的 goroutine 来启动程序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">MOVQ</span>    <span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">mainPC</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>        <span class="c1">// entry
</span></span></span><span class="line"><span class="cl"><span class="c1">// newproc 的第二个参数入栈，也就是新的 goroutine 需要执行的函数
</span></span></span><span class="line"><span class="cl"><span class="c1">// AX = &amp;funcval{runtime·main},
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">PUSHQ</span>    <span class="nx">AX</span>
</span></span><span class="line"><span class="cl"><span class="c1">// newproc 的第一个参数入栈，该参数表示 runtime.main 函数需要的参数大小，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 因为 runtime.main 没有参数，所以这里是 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">PUSHQ</span>    <span class="err">$</span><span class="mi">0</span>            <span class="c1">// arg size
</span></span></span><span class="line"><span class="cl"><span class="c1">// 创建 main goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">newproc</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">POPQ</span>    <span class="nx">AX</span>
</span></span><span class="line"><span class="cl"><span class="nx">POPQ</span>    <span class="nx">AX</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// start this M
</span></span></span><span class="line"><span class="cl"><span class="c1">// 主线程进入调度循环，运行刚刚创建的 goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">mstart</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 永远不会返回，万一返回了，crash 掉
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">MOVL</span>    <span class="err">$</span><span class="mh">0xf1</span><span class="p">,</span> <span class="mh">0xf1</span>  <span class="c1">// crash
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">RET</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码前面几行是在为调用 newproc 函数构“造栈”，执行完 runtime·newproc(SB) 后，就会以一个新的 goroutine 来执行 mainPC 也就是 runtime.main() 函数。runtime.main() 函数最终会执行到我们写的 main 函数。</p>
<p>重点来看 newproc 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// src/runtime/proc.go
</span></span></span><span class="line"><span class="cl"><span class="c1">// 创建一个新的 g，运行 fn 函数，需要 siz byte 的参数
</span></span></span><span class="line"><span class="cl"><span class="c1">// 将其放至 G 队列等待运行
</span></span></span><span class="line"><span class="cl"><span class="c1">// 编译器会将 go 关键字的语句转化成此函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">newproc</span><span class="p">(</span><span class="nx">siz</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>每个 goroutine 都有自己的栈空间，newproc 函数会新创建一个新的 goroutine 来执行 fn 函数.</p>
<p>当前代码在 g0 栈上执行，因此执行完<code>_g_ := getg()</code> 之后，无论是在什么情况下都可以得到 <code>_g_ = g0</code>。之后通过 g0 找到其绑定的 P，也就是 p0。</p>
<p>接着，尝试从 p0 上找一个空闲的 G.</p>
<p>如果拿不到，则会在堆上创建一个新的 G，为其分配 2KB 大小的栈，并设置好新 goroutine 的 stack 成员，设置其状态为 _Gdead，并将其添加到全局变量 allgs 中。创建完成之后，我们就在堆上有了一个 2K 大小的栈。于是，我们的图再次丰富：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201116223753.png" alt=""></p>
<p>g0 栈用于执行调度器的代码，执行完之后，要跳转到执行用户代码的地方，如何跳转？这中间涉及到栈和寄存器的切换。</p>
<p>将 fn 的参数从 g0 栈上拷贝到 newg 的栈上，memmove 函数需要传入源地址、目的地址、参数大小。由于 main 函数在这里没有参数需要拷贝，因此这里相当于没做什么。</p>
<p>接着，初始化 newg 的各种字段，而且涉及到最重要的 pc，sp 等字段：</p>
<p>而 goexit 函数也通过“偷天换日”将自己的地址“强行”放到 newg 的栈顶，达到自己不可告人的目的：每个 goroutine 执行完之后，都要经过我的一些清理工作，才能“放行”。这样一说，goexit 函数还真是无私，默默地做一些“扫尾”的工作。</p>
<p>设置完 newg.sched 这后，我们的图又可以前进一步：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201117103559.png" alt=""></p>
<p>上图中，newg 新增了 sched.pc 指向 runtime.main 函数，当它被调度起来执行时，就从这里开始；新增了 sched.sp 指向了 newg 栈顶位置，同时，newg 栈顶位置的内容是一个跳转地址，指向 runtime.goexit 的第二条指令，当 goroutine 退出时，这条地址会载入 CPU 的 PC 寄存器，跳转到这里执行“扫尾”工作。</p>
<p>newg 的状态变成可执行后（Runnable），就可以将它加入到 P 的本地运行队列里，等待调度。所以，goroutine 何时被执行，用户代码决定不了。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201117103816.png" alt=""></p>
<h3 id="主线程开始-schedule-循环">主线程开始 schedule 循环</h3>
<p>在 runtime·rt0_go 函数里，执行完 runtime·newproc(SB) 后，两条 POP 指令将之前为调用它构建的参数弹出栈。只剩下一个函数了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// start this M
</span></span></span><span class="line"><span class="cl"><span class="c1">// 主线程进入调度循环，运行刚刚创建的 goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">mstart</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>mstart 函数设置了 stackguard0 和 stackguard1 字段后，就直接调用 mstart1() 函数：</p>
<p>调用 gosave 函数来保存调度信息到 g0.sched 结构体.</p>
<p>主要是设置了 g0.sched.sp 和 g0.sched.pc，前者指向 mstart1 函数栈上参数的位置，后者则指向 gosave 函数返回后的下一条指令。如下图：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201117112607.png" alt=""></p>
<p>图中 sched.pc 并不直接指向返回地址，所以图中的虚线并没有箭头。</p>
<p>接下来，进入 schedule 函数，找到了可以运行的 runtime.main goroutine，调用 execute(gp, inheritTime) 将 gp 的状态改为 _Grunning，将 m 和 gp 相互关联起来。最后，调用 gogo 完成从 g0 到 gp 的切换，CPU 的执行权将从 g0 转让到 gp。开始执行 runtime.main 函数。</p>
<p>main goroutine 退出后直接调用 exit(0) 使得整个进程退出，而普通 goroutine 退出后，则进行了一系列的调用，最终又切到 g0 栈，执行 schedule 函数。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201117170452.png" alt=""></p>
<p>如图所示，rt0_go 负责 Go 程序启动的所有初始化，中间进行了很多初始化工作，调用 mstart 之前，已经切换到了 g0 栈，图中不同色块表示使用不同的栈空间。</p>
<p>接着调用 gogo 函数，完成从 g0 栈到用户 goroutine 栈的切换，包括 main goroutine 和普通 goroutine。
之后，执行 main 函数或者用户自定义的 goroutine 任务。</p>
<p>执行完成后，main goroutine 直接调用 eixt(0) 退出，普通 goroutine 则调用 goexit -&gt; goexit1 -&gt; mcall，完成普通 goroutine 退出后的清理工作，然后切换到 g0 栈，调用 goexit0 函数，将普通 goroutine 添加到缓存池中，再调用 schedule 函数进行新一轮的调度。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nf">schedule</span><span class="p">()</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nf">execute</span><span class="p">()</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nf">gogo</span><span class="p">()</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nx">goroutine</span> <span class="nx">任务</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nf">goexit</span><span class="p">()</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nf">goexit1</span><span class="p">()</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nf">mcall</span><span class="p">()</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nf">goexit0</span><span class="p">()</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nf">schedule</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看出，一轮调度从调用 schedule 函数开始，经过一系列过程再次调用 schedule 函数来进行新一轮的调度，从一轮调度到新一轮调度的过程称之为一个调度循环。</p>
<p>这里说的调度循环是指某一个工作线程的调度循环，而同一个Go 程序中存在多个工作线程，每个工作线程都在进行着自己的调度循环。</p>
<p>从前面的代码分析可以得知，上面调度循环中的每一个函数调用都没有返回，虽然 <code>goroutine 任务-&gt; goexit() -&gt; goexit1() -&gt; mcall()</code> 是在 g2 的栈空间执行的，但剩下的函数都是在 g0 的栈空间执行的。</p>
<h2 id="runtime-main-goroutine-执行与退出">runtime main goroutine 执行与退出</h2>
<p>我们探索 main goroutine 以及普通 goroutine 从执行到退出的整个过程。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// The main goroutine.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// g = main goroutine，不再是 g0 了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">g</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Racectx of m0-&gt;g0 is used only as the parent of the main goroutine.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// It must not be used for anything else.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">racectx</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Max stack size is 1 GB on 64-bit, 250 MB on 32-bit.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Using decimal instead of binary GB and MB because
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// they look nicer in the stack overflow failure message.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">==</span> <span class="mi">8</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">maxstacksize</span> <span class="p">=</span> <span class="mi">1000000000</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">maxstacksize</span> <span class="p">=</span> <span class="mi">250000000</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Allow newproc to start new Ms.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mainStarted</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">GOARCH</span> <span class="o">!=</span> <span class="s">&#34;wasm&#34;</span> <span class="p">{</span> <span class="c1">// no threads on wasm yet, so no sysmon
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 创建监控线程，该线程独立于调度器，不需要跟 p 关联即可运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nf">newm</span><span class="p">(</span><span class="nx">sysmon</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Lock the main goroutine onto this, the main OS thread,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// during initialization. Most programs won&#39;t care, but a few
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// do require certain calls to be made by the main thread.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Those can arrange for main.main to run in the main thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// by calling runtime.LockOSThread during initialization
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// to preserve the lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">lockOSThread</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">g</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime.main not on m0&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 调用 runtime 包的初始化函数，由编译器实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">doInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">runtime_inittask</span><span class="p">)</span> <span class="c1">// must be before defer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;nanotime returning zero&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Defer unlock so that runtime.Goexit during init does the unlock too.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">needUnlock</span> <span class="o">:=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">needUnlock</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">unlockOSThread</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Record when the world started.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">runtimeInitTime</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 开启垃圾回收器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">gcenable</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">main_init_done</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">iscgo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">_cgo_thread_start</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;_cgo_thread_start missing&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;windows&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">_cgo_setenv</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;_cgo_setenv missing&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">_cgo_unsetenv</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;_cgo_unsetenv missing&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">_cgo_notify_runtime_init_done</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;_cgo_notify_runtime_init_done missing&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Start the template thread in case we enter Go from
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// a C-created thread and need to create a new thread.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">startTemplateThread</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nf">cgocall</span><span class="p">(</span><span class="nx">_cgo_notify_runtime_init_done</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// main 包的初始化，递归的调用我们 import 进来的包的初始化函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">doInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">main_inittask</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nb">close</span><span class="p">(</span><span class="nx">main_init_done</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">needUnlock</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="nf">unlockOSThread</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">isarchive</span> <span class="o">||</span> <span class="nx">islibrary</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// A program compiled with -buildmode=c-archive or c-shared
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// has a main, but it is not executed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 调用 main.main 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fn</span> <span class="o">:=</span> <span class="nx">main_main</span> <span class="c1">// make an indirect call, as the linker doesn&#39;t know the address of the main package when laying down the runtime
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">fn</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">racefini</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Make racy client program work: if panicking on
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// another goroutine at the same time as main returns,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// let the other goroutine finish printing the panic trace.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Once it does, it will exit. See issues 3934 and 20018.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">runningPanicDefers</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Running deferred functions should not take long.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">c</span> <span class="p">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">c</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">runningPanicDefers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nf">Gosched</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">panicking</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonPanicWait</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 进入系统调用，退出进程，可以看出 main goroutine 并未返回，而是直接进入系统调用退出进程了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 保护性代码，如果 exit 意外返回，下面的代码会让该进程 crash 死掉
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kd">var</span> <span class="nx">x</span> <span class="o">*</span><span class="kt">int32</span>
</span></span><span class="line"><span class="cl">		<span class="o">*</span><span class="nx">x</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>main 函数执行流程如下图：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201117154621.png" alt=""></p>
<p>从流程图可知，main goroutine 执行完之后就直接调用 exit(0) 退出了，这会导致整个进程退出，太粗暴了。</p>
<p>不过，main goroutine 实际上就是代表用户的 main 函数，它都执行完了，肯定是用户的任务都执行完了，直接退出就可以了，就算有其他的 goroutine 没执行完，同样会直接退出。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello qcrao.com&#34;</span><span class="p">)}()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个例子中，main gorutine 退出时，还来不及执行 go 出去 的函数，整个进程就直接退出了，打印语句不会执行。因此，main goroutine 不会等待其他 goroutine 执行完再退出，知道这个有时能解释一些现象，比如上面那个例子。</p>
<p>这时，心中可能会跳出疑问，我们在新创建 goroutine 的时候，不是整出了个“偷天换日”，风风火火地设置了 goroutine 退出时应该跳到 runtime.goexit 函数吗，怎么这会不用了，闲得慌？</p>
<p>回顾一下跳转到 main 函数的两行代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 把 sched.pc 值放入 BX 寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">MOVQ</span>    <span class="nf">gobuf_pc</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BX</span>
</span></span><span class="line"><span class="cl"><span class="c1">// JMP 把 BX 寄存器的包含的地址值放入 CPU 的 IP 寄存器，于是，CPU 跳转到该地址继续执行指令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">JMP</span>    <span class="nx">BX</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>直接使用了一个跳转，并没有使用 CALL 指令，而 runtime.main 函数中确实也没有 RET 返回的指令。所以，main goroutine 执行完后，直接调用 exit(0) 退出整个进程。</p>
<p>那之前整地“偷天换日”还有用吗？有的！这是针对非 main goroutine 起作用。</p>
<p>main goroutine 和普通 goroutine 的退出过程：</p>
<ul>
<li>对于 main goroutine，在执行完用户定义的 main 函数的所有代码后，直接调用 exit(0) 退出整个进程，非常霸道。</li>
<li>对于普通 goroutine 则没这么“舒服”，需要经历一系列的过程。先是跳转到提前设置好的 goexit 函数的第二条指令，然后调用 runtime.goexit1，接着调用 mcall(goexit0)，而 mcall 函数会切换到 g0 栈，运行 goexit0 函数，清理 goroutine 的一些字段，并将其添加到 goroutine 缓存池里，然后进入 schedule 调度循环。到这里，普通 goroutine 才算完成使命。</li>
</ul>
<h2 id="转载">转载</h2>
<p><a href="https://qcrao.com/ishare/go-scheduler/#true%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D">Asciidoc 笔记</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-11-18
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go%E6%BA%90%E7%A0%81/">Go源码</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/linux%E7%9A%84%E7%BD%91%E7%BB%9Cio%E6%A8%A1%E5%9E%8B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Linux的网络IO模型</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/go%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BD%AE%E8%AF%A2%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
            <span class="next-text nav-default">Go的网络轮询器源码剖析</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
