<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go进程的生命周期源码剖析 | Forz Blog</title>
<meta name="keywords" content="Go源码" />
<meta name="description" content="runtime Go 语言是一⻔有 runtime 的语言，那么 runtime 是什么? 可以认为 runtime 是为了实现额外的功能，而在程序运行时自动 加载/运行的一些模块。 Go 语言的 runtime 包括: 这些模块中，">
<meta name="author" content="">
<link rel="canonical" href="/post/go%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Go进程的生命周期源码剖析" />
<meta property="og:description" content="runtime Go 语言是一⻔有 runtime 的语言，那么 runtime 是什么? 可以认为 runtime 是为了实现额外的功能，而在程序运行时自动 加载/运行的一些模块。 Go 语言的 runtime 包括: 这些模块中，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-11-18T14:34:06&#43;00:00" />
<meta property="article:modified_time" content="2020-11-18T14:34:06&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go进程的生命周期源码剖析"/>
<meta name="twitter:description" content="runtime Go 语言是一⻔有 runtime 的语言，那么 runtime 是什么? 可以认为 runtime 是为了实现额外的功能，而在程序运行时自动 加载/运行的一些模块。 Go 语言的 runtime 包括: 这些模块中，"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Go进程的生命周期源码剖析",
      "item": "/post/go%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go进程的生命周期源码剖析",
  "name": "Go进程的生命周期源码剖析",
  "description": "runtime Go 语言是一⻔有 runtime 的语言，那么 runtime 是什么? 可以认为 runtime 是为了实现额外的功能，而在程序运行时自动 加载/运行的一些模块。 Go 语言的 runtime 包括: 这些模块中，",
  "keywords": [
    "Go源码"
  ],
  "articleBody": "runtime Go 语言是一⻔有 runtime 的语言，那么 runtime 是什么?\n可以认为 runtime 是为了实现额外的功能，而在程序运行时自动 加载/运行的一些模块。\nGo 语言的 runtime 包括:\n这些模块中，最核心的就是 Scheduler，它负责串联所有的 runtime 流程.\n调度器的生命周期 所有的Go程序运行都会经过一个完整的调度器生命周期：从创建到结束。\n即使下面这段简单的代码：\n1 2 3 4 5 6 7 8  package main import \"fmt\" // main.main func main() { fmt.Println(\"Hello scheduler\") }   也会经历如上图所示的过程：\n runtime创建最初的线程m0和goroutine g0，并把2者关联。 调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。 示例代码中的main函数是main.main，runtime中也有1个main函数——runtime.main，代码经过编译后，runtime.main会调用main.main，程序启动时会为runtime.main创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。 启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。 G拥有栈，M根据G中的栈信息和调度信息设置运行环境 M运行G G退出，再次回到M获取可运行的G，这样重复下去，直到main.main退出，runtime.main执行Defer和Panic处理，或调用runtime.exit退出程序。  调度器的生命周期几乎占满了一个Go程序的一生，runtime.main的goroutine执行之前都是为调度器做准备工作，runtime.main的goroutine运行，才是调度器的真正开始，直到runtime.main结束而结束。\nM0 是启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了。\nG0 是每次启动一个 M 都会第一个创建的 gourtine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0。\nGo进程的执行入口 在 proc.go 和 runtime2.go 文件中，有一些很重要全局的变量，我们先列出来：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // 所有 g 的长度 allglen uintptr // 保存所有的 g allgs []*g // 保存所有的 m allm *m // 保存所有的 p，_MaxGomaxprocs = 1024 allp [_MaxGomaxprocs + 1]*p // p 的最大值，默认等于 ncpu gomaxprocs int32 // 程序启动时，会调用 osinit 函数获得此值 ncpu int32 // 调度器结构体对象，记录了调度器的工作状态 sched schedt // 代表进程的主线程 m0 m // m0 的 g0，即 m0.g0 = \u0026g0 g0 g   在程序初始化时，这些全局变量都会被初始化为零值：指针被初始化为 nil 指针，切片被初始化为 nil 切片，int 被初始化为 0，结构体的所有成员变量按其类型被初始化为对应的零值。\n因此程序刚启动时 allgs，allm 和allp 都不包含任何 g，m 和 p。\n不仅是 Go 程序，系统加载可执行文件大概都会经过这几个阶段：\n 从磁盘上读取可执行文件，加载到内存 创建进程和主线程 为主线程分配栈空间 把由用户在命令行输入的参数拷贝到主线程的栈 把主线程放入操作系统的运行队列等待被调度  我们从一个 Hello World 的例子来回顾一下 Go 程序初始化的过程：\n1 2 3 4 5 6 7  package main import \"fmt\" func main() { fmt.Println(\"hello world\") }   在项目根目录下执行：\n1  go build -gcflags \"-N -l\" -o hello src/main.go   -gcflags “-N -l” 是为了关闭编译器优化和函数内联，防止后面在设置断点的时候找不到相对应的代码位置。\n得到了可执行文件 hello，执行：\n1  gdb hello   进入 gdb 调试模式，执行 info files，得到可执行文件的文件头，列出了各种段：\n同时，我们也得到了入口地址：0x450e20。\n1 2  (gdb) b *0x450e20 Breakpoint 1 at 0x450e20: file /usr/local/go/src/runtime/rt0_linux_amd64.s, line 8.   这就是 Go 程序的入口地址，我是在 linux 上运行的，所以入口文件为 src/runtime/rt0_linux_amd64.s，runtime 目录下有各种不同名称的程序入口文件，支持各种操作系统和架构，代码为：\n1 2 3 4 5  TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8 LEAQ 8(SP), SI // argv MOVQ 0(SP), DI // argc MOVQ $main(SB), AX JMP AX   主要是把 argc，argv 从内存拉到了寄存器。这里 LEAQ 是计算内存地址，然后把内存地址本身放进寄存器里，也就是把 argv 的地址放到了 SI 寄存器中。最后跳转到：\n1 2 3  TEXT main(SB),NOSPLIT,$-8 MOVQ $runtime·rt0_go(SB), AX JMP AX   继续跳转到 runtime·rt0_go(SB)，完成 go 启动时所有的初始化工作。位于 /usr/local/go/src/runtime/asm_amd64.s.\n或者使用开源反编译工具cutter.\nGo启动的初始化工作 rt0_go完成 go 启动时所有的初始化工作.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102  TEXT runtime·rt0_go(SB),NOSPLIT,$0 // copy arguments forward on an even stack  MOVQ DI, AX // argc  MOVQ SI, BX // argv  SUBQ $(4*8+7), SP // 2args 2auto  // 调整栈顶寄存器使其按 16 字节对齐  ANDQ $~15, SP // argc 放在 SP+16 字节处  MOVQ AX, 16(SP) // argv 放在 SP+24 字节处  MOVQ BX, 24(SP) // create istack out of the given (operating system) stack.  // _cgo_init may update stackguard.  // 给 g0 分配栈空间  // 把 g0 的地址存入 DI  MOVQ $runtime·g0(SB), DI // BX = SP - 64*1024 + 104  LEAQ (-64*1024+104)(SP), BX // g0.stackguard0 = SP - 64*1024 + 104  MOVQ BX, g_stackguard0(DI) // g0.stackguard1 = SP - 64*1024 + 104  MOVQ BX, g_stackguard1(DI) // g0.stack.lo = SP - 64*1024 + 104  MOVQ BX, (g_stack+stack_lo)(DI) // g0.stack.hi = SP  MOVQ SP, (g_stack+stack_hi)(DI) // ……………………  // 省略了很多检测 CPU 信息的代码  // ……………………  // 初始化 m 的 tls  // DI = \u0026m0.tls，取 m0 的 tls 成员的地址到 DI 寄存器  LEAQ runtime·m0+m_tls(SB), DI // 调用 settls 设置线程本地存储，settls 函数的参数在 DI 寄存器中  // 之后，可通过 fs 段寄存器找到 m.tls  CALL runtime·settls(SB) // store through it, to make sure it works  // 获取 fs 段基址并放入 BX 寄存器，其实就是 m0.tls[1] 的地址，get_tls 的代码由编译器生成  get_tls(BX) MOVQ $0x123, g(BX) MOVQ runtime·m0+m_tls(SB), AX CMPQ AX, $0x123 JEQ 2(PC) MOVL AX, 0 // abort ok: // set the per-goroutine and per-mach \"registers\"  // 获取 fs 段基址到 BX 寄存器  get_tls(BX) // 将 g0 的地址存储到 CX，CX = \u0026g0  LEAQ runtime·g0(SB), CX // 把 g0 的地址保存在线程本地存储里面，也就是 m0.tls[0]=\u0026g0  MOVQ CX, g(BX) // 将 m0 的地址存储到 AX，AX = \u0026m0  LEAQ runtime·m0(SB), AX // save m-g0 = g0  // m0.g0 = \u0026g0  MOVQ CX, m_g0(AX) // save m0 to g0-m  // g0.m = \u0026m0  MOVQ AX, g_m(CX) CLD // convention is D is always left cleared  CALL runtime·check(SB) MOVL 16(SP), AX // copy argc  MOVL AX, 0(SP) MOVQ 24(SP), AX // copy argv  MOVQ AX, 8(SP) CALL runtime·args(SB) // 初始化系统核心数  CALL runtime·osinit(SB) // 调度器初始化  CALL runtime·schedinit(SB) // create a new goroutine to start program \t// 创建一个新的 goroutine 来启动程序  MOVQ $runtime·mainPC(SB), AX // entry  // newproc 的第二个参数入栈，也就是新的 goroutine 需要执行的函数  // AX = \u0026funcval{runtime·main},  PUSHQ AX // newproc 的第一个参数入栈，该参数表示 runtime.main 函数需要的参数大小，  // 因为 runtime.main 没有参数，所以这里是 0  PUSHQ $0 // arg size  // 创建 main goroutine  CALL runtime·newproc(SB) POPQ AX POPQ AX // start this M  // 主线程进入调度循环，运行刚刚创建的 goroutine  CALL runtime·mstart(SB) // 永远不会返回，万一返回了，crash 掉  MOVL $0xf1, 0xf1 // crash  RET   这段代码完成之后，整个 Go 程序就可以跑起来了。\n调度器初始化函数：schedinit 返回后，调度器的相关参数都已经初始化好了.\n调整 SP 第一段代码，将 SP 调整到了一个地址是 16 的倍数的位置：\n1 2 3  SUBQ $(4*8+7), SP // 2args 2auto // 调整栈顶寄存器使其按 16 个字节对齐 ANDQ $~15, SP   先是将 SP 减掉 39，也就是向下移动了 39 个 Byte，再进行与运算。\n15 的二进制低四位是全 1：1111，其他位都是 0；取反后，变成了 0000，高位则是全 1。这样，与 SP 进行了与运算后，低 4 位变成了全 0，高位则不变。因此 SP 继续向下移动，并且这回是在一个地址值为 16 的倍数的地方，16 字节对齐的地方。\n为什么要这么做？画一张图就明白了。不过先得说明一点，前面 _rt0_amd64_linux 函数里讲过，DI 里存的是 argc 的值，8 个字节，而 SI 里则存的是 argv 的地址，8 个字节。\n上面两张图中，左侧用箭头标注了 16 字节对齐的位置。第一步表示向下移动 39 B，第二步表示与 ~15 相与。 存在两种情况，这也是第一步将 SP 下移的时候，多移了 7 个 Byte 的原因。第一张图里，与 ~15 相与的时候，SP 值减少了 1，第二张图则减少了 9。最后都是移位到了 16 字节对齐的位置。\n两张图的共同点是 SP 与 argc 中间多出了 16 个字节的空位。这个后面应该会用到，我们接着探索。\n至于为什么进行 16 个字节对齐，就比较好理解了：因为 CPU 有一组 SSE 指令，这些指令中出现的内存地址必须是 16 的倍数。\n初始化 g0 栈 接着往后看，开始初始化 g0 的栈了。g0 栈的作用就是为运行 runtime 代码提供一个“环境”。\n1 2 3 4 5 6 7 8 9 10 11 12  // 把 g0 的地址存入 DI MOVQ $runtime·g0(SB), DI // BX = SP - 64*1024 + 104 LEAQ (-64*1024+104)(SP), BX // g0.stackguard0 = SP - 64*1024 + 104 MOVQ BX, g_stackguard0(DI) // g0.stackguard1 = SP - 64*1024 + 104 MOVQ BX, g_stackguard1(DI) // g0.stack.lo = SP - 64*1024 + 104 MOVQ BX, (g_stack+stack_lo)(DI) // g0.stack.hi = SP MOVQ SP, (g_stack+stack_hi)(DI)   代码 L2 把 g0 的地址存入 DI 寄存器；L4 将 SP 下移 (64K-104)B，并将地址存入 BX 寄存器；L6 将 BX 里存储的地址赋给 g0.stackguard0；L8，L10，L12 分别 将 BX 里存储的地址赋给 g0.stackguard1， g0.stack.lo， g0.stack.hi。\n这部分完成之后，g0 栈空间如下图：\n主线程绑定 m0 m0: Go 程序启动后创建的第一个线程\n接着往下看，中间我们省略了很多检查 CPU 相关的代码，直接看主线程绑定 m0 的部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 初始化 m 的 tls // DI = \u0026m0.tls，取 m0 的 tls 成员的地址到 DI 寄存器 LEAQ runtime·m0+m_tls(SB), DI // 调用 settls 设置线程本地存储，settls 函数的参数在 DI 寄存器中 // 之后，可通过 fs 段寄存器找到 m.tls CALL runtime·settls(SB) // store through it, to make sure it works // 获取 fs 段基地址并放入 BX 寄存器，其实就是 m0.tls[1] 的地址，get_tls 的代码由编译器生成 get_tls(BX) MOVQ $0x123, g(BX) MOVQ runtime·m0+m_tls(SB), AX CMPQ AX, $0x123 JEQ 2(PC) MOVL AX, 0 // abort   因为 m0 是全局变量，而 m0 又要绑定到工作线程才能执行。我们又知道，runtime 会启动多个工作线程，每个线程都会绑定一个 m0。而且，代码里还得保持一致，都是用 m0 来表示。这就要用到线程本地存储的知识了，也就是常说的 TLS（Thread Local Storage）。简单来说，TLS 就是线程本地的私有的全局变量。\n一般而言，全局变量对进程中的多个线程同时可见。进程中的全局变量与函数内定义的静态（static）变量，是各个线程都可以访问的共享变量。一个线程修改了，其他线程就会“看见”。要想搞出一个线程私有的变量，就需要用到 TLS 技术。\n如果需要在一个线程内部的各个函数调用都能访问、但其它线程不能访问的变量（被称为 static memory local to a thread，线程局部静态变量），就需要新的机制来实现。这就是 TLS。\n继续来看源码，L3 将 m0.tls 地址存储到 DI 寄存器，再调用 settls 完成 tls 的设置，tls 是 m 结构体中的一个数组。\n1 2  // thread-local storage (for x86 extern register) tls [6]uintptr   设置 tls 的函数 runtime·settls(SB) 位于源码 src/runtime/sys_linux_amd64.s 处，主要内容就是通过一个系统调用将 fs 段基址设置成 m.tls[1] 的地址，而 fs 段基址又可以通过 CPU 里的寄存器 fs 来获取。\n而每个线程都有自己的一组 CPU 寄存器值，操作系统在把线程调离 CPU 时会帮我们把所有寄存器中的值保存在内存中，调度线程来运行时又会从内存中把这些寄存器的值恢复到 CPU。\n这样，工作线程代码就可以通过 fs 寄存器来找到 m.tls。\n设置完 tls 之后，又来了一段验证上面 settls 是否能正常工作。如果不能，会直接 crash。\n1 2 3 4 5 6  get_tls(BX) MOVQ $0x123, g(BX) MOVQ runtime·m0+m_tls(SB), AX CMPQ AX, $0x123 JEQ 2(PC) MOVL AX, 0 // abort   第一行代码，获取 tls，get_tls(BX) 的代码由编译器生成，源码中并没有看到，可以理解为将 m.tls 的地址存入 BX 寄存器。\nL2 将一个数 0x123 放入 m.tls[0] 处，L3 则将 m.tls[0] 处的数据取出来放到 AX 寄存器，L4 则比较两者是否相等。如果相等，则跳过 L6 行的代码，否则执行 L6，程序 crash。\n继续看代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // set the per-goroutine and per-mach \"registers\" // 获取 fs 段基址到 BX 寄存器 get_tls(BX) // 将 g0 的地址存储到 CX，CX = \u0026g0 LEAQ runtime·g0(SB), CX // 把 g0 的地址保存在线程本地存储里面，也就是 m0.tls[0]=\u0026g0 MOVQ CX, g(BX) // 将 m0 的地址存储到 AX，AX = \u0026m0 LEAQ runtime·m0(SB), AX // save m-g0 = g0 // m0.g0 = \u0026g0 MOVQ CX, m_g0(AX) // save m0 to g0-m // g0.m = \u0026m0 MOVQ AX, g_m(CX)   L3 将 m.tls 地址存入 BX；L5 将 g0 的地址存入 CX；L7 将 CX，也就是 g0 的地址存入 m.tls[0]；L9 将 m0 的地址存入 AX；L13 将 g0 的地址存入 m0.g0；L16 将 m0 存入 g0.m。也就是：\n1 2 3  tls[0] = g0 m0.g0 = \u0026g0 g0.m = \u0026m0   代码中寄存器前面的符号看着比较奇怪，其实它们最后会被链接器转化为偏移量。\n这种写法在标准 plan9 汇编中只是个 symbol，没有任何偏移量的意思，但这里却用名字来代替了其偏移量，这是怎么回事呢？\n实际上这是 runtime 的特权，是需要链接器配合完成的，再来看看 gobuf 在 runtime 中的 struct 定义开头部分的注释:\n1  // The offsets of sp, pc, and g are known to (hard-coded in) libmach.   对于我们而言，这种写法读起来比较容易。\n这一段执行完之后，就把 m0，g0，m.tls[0] 串联起来了。通过 m.tls[0] 可以找到 g0，通过 g0 可以找到 m0（通过 g 结构体的 m 字段）。并且，通过 m 的字段 g0，m0 也可以找到 g0。于是，主线程和 m0，g0 就关联起来了。\n从这里还可以看到，保存在主线程本地存储中的值是 g0 的地址，也就是说工作线程的私有全局变量其实是一个指向 g 的指针而不是指向 m 的指针。\n目前这个指针指向g0，表示代码正运行在 g0 栈。\n于是，前面的图又增加了新的玩伴 m0：\n初始化 m0 1 2 3 4 5 6 7 8 9  MOVL 16(SP), AX // copy argc MOVL AX, 0(SP) MOVQ 24(SP), AX // copy argv MOVQ AX, 8(SP) CALL runtime·args(SB) // 初始化系统核心数 CALL runtime·osinit(SB) // 调度器初始化 CALL runtime·schedinit(SB)   L1-L2 将 16(SP) 处的内容移动到 0(SP)，也就是栈顶，通过前面的图，16(SP) 处的内容为 argc；L3-L4 将 argv 存入 8(SP)，接下来调用 runtime·args 函数，处理命令行参数。\n接着，连续调用了两个 runtime 函数。osinit 函数初始化系统核心数，将全局变量 ncpu 初始化的核心数，schedinit 则是调度器的初始化。\nmain goroutine创建 继续看代码，前面我们完成了 schedinit 函数，这是 runtime·rt0_go 函数里的一步，接着往后看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // 创建一个新的 goroutine 来启动程序 MOVQ $runtime·mainPC(SB), AX // entry // newproc 的第二个参数入栈，也就是新的 goroutine 需要执行的函数 // AX = \u0026funcval{runtime·main}, PUSHQ AX // newproc 的第一个参数入栈，该参数表示 runtime.main 函数需要的参数大小， // 因为 runtime.main 没有参数，所以这里是 0 PUSHQ $0 // arg size // 创建 main goroutine CALL runtime·newproc(SB) POPQ AX POPQ AX // start this M // 主线程进入调度循环，运行刚刚创建的 goroutine CALL runtime·mstart(SB) // 永远不会返回，万一返回了，crash 掉 MOVL $0xf1, 0xf1 // crash RET   代码前面几行是在为调用 newproc 函数构“造栈”，执行完 runtime·newproc(SB) 后，就会以一个新的 goroutine 来执行 mainPC 也就是 runtime.main() 函数。runtime.main() 函数最终会执行到我们写的 main 函数。\n重点来看 newproc 函数：\n1 2 3 4 5 6 7  // src/runtime/proc.go // 创建一个新的 g，运行 fn 函数，需要 siz byte 的参数 // 将其放至 G 队列等待运行 // 编译器会将 go 关键字的语句转化成此函数  //go:nosplit func newproc(siz int32, fn *funcval)   每个 goroutine 都有自己的栈空间，newproc 函数会新创建一个新的 goroutine 来执行 fn 函数.\n当前代码在 g0 栈上执行，因此执行完_g_ := getg() 之后，无论是在什么情况下都可以得到 g = g0。之后通过 g0 找到其绑定的 P，也就是 p0。\n接着，尝试从 p0 上找一个空闲的 G.\n如果拿不到，则会在堆上创建一个新的 G，为其分配 2KB 大小的栈，并设置好新 goroutine 的 stack 成员，设置其状态为 _Gdead，并将其添加到全局变量 allgs 中。创建完成之后，我们就在堆上有了一个 2K 大小的栈。于是，我们的图再次丰富：\n这样，main goroutine 就诞生了。\ng0栈和用户栈的迁移 g0 栈用于执行调度器的代码，执行完之后，要跳转到执行用户代码的地方，如何跳转？这中间涉及到栈和寄存器的切换。\n将 fn 的参数从 g0 栈上拷贝到 newg 的栈上，memmove 函数需要传入源地址、目的地址、参数大小。由于 main 函数在这里没有参数需要拷贝，因此这里相当于没做什么。\n接着，初始化 newg 的各种字段，而且涉及到最重要的 pc，sp 等字段：\n而 goexit 函数也通过“偷天换日”将自己的地址“强行”放到 newg 的栈顶，达到自己不可告人的目的：每个 goroutine 执行完之后，都要经过我的一些清理工作，才能“放行”。这样一说，goexit 函数还真是无私，默默地做一些“扫尾”的工作。\n设置完 newg.sched 这后，我们的图又可以前进一步：\n上图中，newg 新增了 sched.pc 指向 runtime.main 函数，当它被调度起来执行时，就从这里开始；新增了 sched.sp 指向了 newg 栈顶位置，同时，newg 栈顶位置的内容是一个跳转地址，指向 runtime.goexit 的第二条指令，当 goroutine 退出时，这条地址会载入 CPU 的 PC 寄存器，跳转到这里执行“扫尾”工作。\nnewg 的状态变成可执行后（Runnable），就可以将它加入到 P 的本地运行队列里，等待调度。所以，goroutine 何时被执行，用户代码决定不了。\nschedule 循环 在 runtime·rt0_go 函数里，执行完 runtime·newproc(SB) 后，两条 POP 指令将之前为调用它构建的参数弹出栈。只剩下一个函数了：\n1 2 3  // start this M // 主线程进入调度循环，运行刚刚创建的 goroutine CALL runtime·mstart(SB)   mstart 函数设置了 stackguard0 和 stackguard1 字段后，就直接调用 mstart1() 函数：\n调用 gosave 函数来保存调度信息到 g0.sched 结构体.\n主要是设置了 g0.sched.sp 和 g0.sched.pc，前者指向 mstart1 函数栈上参数的位置，后者则指向 gosave 函数返回后的下一条指令。如下图：\n图中 sched.pc 并不直接指向返回地址，所以图中的虚线并没有箭头。\n接下来，进入 schedule 函数，找到了可以运行的 main goroutine，调用 execute(gp, inheritTime) 将 gp 的状态改为 _Grunning，将 m 和 gp 相互关联起来。最后，调用 gogo 完成从 g0 到 gp 的切换，CPU 的执行权将从 g0 转让到 gp。开始执行 runtime.main 函数。\n用一张流程图总结一下从 g0 切换到 main goroutine 的过程.\nmain goroutine 退出后直接调用 exit(0) 使得整个进程退出，而普通 goroutine 退出后，则进行了一系列的调用，最终又切到 g0 栈，执行 schedule 函数。\n如图所示，rt0_go 负责 Go 程序启动的所有初始化，中间进行了很多初始化工作，调用 mstart 之前，已经切换到了 g0 栈，图中不同色块表示使用不同的栈空间。\n接着调用 gogo 函数，完成从 g0 栈到用户 goroutine 栈的切换，包括 main goroutine 和普通 goroutine。 之后，执行 main 函数或者用户自定义的 goroutine 任务。\n执行完成后，main goroutine 直接调用 eixt(0) 退出，普通 goroutine 则调用 goexit - goexit1 - mcall，完成普通 goroutine 退出后的清理工作，然后切换到 g0 栈，调用 goexit0 函数，将普通 goroutine 添加到缓存池中，再调用 schedule 函数进行新一轮的调度。\n1  schedule() - execute() - gogo() - goroutine 任务 - goexit() - goexit1() - mcall() - goexit0() - schedule()   可以看出，一轮调度从调用 schedule 函数开始，经过一系列过程再次调用 schedule 函数来进行新一轮的调度，从一轮调度到新一轮调度的过程称之为一个调度循环。\n这里说的调度循环是指某一个工作线程的调度循环，而同一个Go 程序中存在多个工作线程，每个工作线程都在进行着自己的调度循环。\n从前面的代码分析可以得知，上面调度循环中的每一个函数调用都没有返回，虽然 goroutine 任务- goexit() - goexit1() - mcall() 是在 g2 的栈空间执行的，但剩下的函数都是在 g0 的栈空间执行的。\n那么问题就来了，在一个复杂的程序中，调度可能会进行无数次循环，也就是说会进行无数次没有返回的函数调用，大家都知道，每调用一次函数都会消耗一定的栈空间，而如果一直这样无返回的调用下去无论 g0 有多少栈空间终究是会耗尽的，那么这里是不是有问题？其实没有问题！关键点就在于，每次执行 mcall 切换到 g0 栈时都是切换到 g0.sched.sp 所指的固定位置，这之所以行得通，正是因为从 schedule 函数开始之后的一系列函数永远都不会返回，所以重用这些函数上一轮调度时所使用过的栈内存是没有问题的。\n我再解释一下：栈空间在调用函数时会自动“增大”，而函数返回时，会自动“减小”，这里的增大和减小是指栈顶指针 SP 的变化。上述这些函数都没有返回，说明调用者不需要用到被调用者的返回值，有点像“尾递归”。\n因为 g0 一直没有动过，所有它之前保存的 sp 还能继续使用。每一次调度循环都会覆盖上一次调度循环的栈数据，完美！\ngoroutine 执行与退出 我们探索 main goroutine 以及普通 goroutine 从执行到退出的整个过程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123  // The main goroutine. func main() { // g = main goroutine，不再是 g0 了 \tg := getg() // Racectx of m0-g0 is used only as the parent of the main goroutine. \t// It must not be used for anything else. \tg.m.g0.racectx = 0 // Max stack size is 1 GB on 64-bit, 250 MB on 32-bit. \t// Using decimal instead of binary GB and MB because \t// they look nicer in the stack overflow failure message. \tif sys.PtrSize == 8 { maxstacksize = 1000000000 } else { maxstacksize = 250000000 } // Allow newproc to start new Ms. \tmainStarted = true if GOARCH != \"wasm\" { // no threads on wasm yet, so no sysmon \tsystemstack(func() { // 创建监控线程，该线程独立于调度器，不需要跟 p 关联即可运行 \tnewm(sysmon, nil, -1) }) } // Lock the main goroutine onto this, the main OS thread, \t// during initialization. Most programs won't care, but a few \t// do require certain calls to be made by the main thread. \t// Those can arrange for main.main to run in the main thread \t// by calling runtime.LockOSThread during initialization \t// to preserve the lock. \tlockOSThread() if g.m != \u0026m0 { throw(\"runtime.main not on m0\") } // 调用 runtime 包的初始化函数，由编译器实现 \tdoInit(\u0026runtime_inittask) // must be before defer \tif nanotime() == 0 { throw(\"nanotime returning zero\") } // Defer unlock so that runtime.Goexit during init does the unlock too. \tneedUnlock := true defer func() { if needUnlock { unlockOSThread() } }() // Record when the world started. \truntimeInitTime = nanotime() // 开启垃圾回收器 \tgcenable() main_init_done = make(chan bool) if iscgo { if _cgo_thread_start == nil { throw(\"_cgo_thread_start missing\") } if GOOS != \"windows\" { if _cgo_setenv == nil { throw(\"_cgo_setenv missing\") } if _cgo_unsetenv == nil { throw(\"_cgo_unsetenv missing\") } } if _cgo_notify_runtime_init_done == nil { throw(\"_cgo_notify_runtime_init_done missing\") } // Start the template thread in case we enter Go from \t// a C-created thread and need to create a new thread. \tstartTemplateThread() cgocall(_cgo_notify_runtime_init_done, nil) } // main 包的初始化，递归的调用我们 import 进来的包的初始化函数 \tdoInit(\u0026main_inittask) close(main_init_done) needUnlock = false unlockOSThread() if isarchive || islibrary { // A program compiled with -buildmode=c-archive or c-shared \t// has a main, but it is not executed. \treturn } // 调用 main.main 函数 \tfn := main_main // make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime \tfn() if raceenabled { racefini() } // Make racy client program work: if panicking on \t// another goroutine at the same time as main returns, \t// let the other goroutine finish printing the panic trace. \t// Once it does, it will exit. See issues 3934 and 20018. \tif atomic.Load(\u0026runningPanicDefers) != 0 { // Running deferred functions should not take long. \tfor c := 0; c  1000; c++ { if atomic.Load(\u0026runningPanicDefers) == 0 { break } Gosched() } } if atomic.Load(\u0026panicking) != 0 { gopark(nil, nil, waitReasonPanicWait, traceEvGoStop, 1) } // 进入系统调用，退出进程，可以看出 main goroutine 并未返回，而是直接进入系统调用退出进程了 \texit(0) // 保护性代码，如果 exit 意外返回，下面的代码会让该进程 crash 死掉 \tfor { var x *int32 *x = 0 } }   main 函数执行流程如下图：\n从流程图可知，main goroutine 执行完之后就直接调用 exit(0) 退出了，这会导致整个进程退出，太粗暴了。\n不过，main goroutine 实际上就是代表用户的 main 函数，它都执行完了，肯定是用户的任务都执行完了，直接退出就可以了，就算有其他的 goroutine 没执行完，同样会直接退出。\n1 2 3 4 5 6 7  package main import \"fmt\" func main() { go func() {fmt.Println(\"hello qcrao.com\")}() }   在这个例子中，main gorutine 退出时，还来不及执行 go 出去 的函数，整个进程就直接退出了，打印语句不会执行。因此，main goroutine 不会等待其他 goroutine 执行完再退出，知道这个有时能解释一些现象，比如上面那个例子。\n这时，心中可能会跳出疑问，我们在新创建 goroutine 的时候，不是整出了个“偷天换日”，风风火火地设置了 goroutine 退出时应该跳到 runtime.goexit 函数吗，怎么这会不用了，闲得慌？\n回顾一下跳转到 main 函数的两行代码：\n1 2 3 4  // 把 sched.pc 值放入 BX 寄存器 MOVQ gobuf_pc(BX), BX // JMP 把 BX 寄存器的包含的地址值放入 CPU 的 IP 寄存器，于是，CPU 跳转到该地址继续执行指令 JMP BX   直接使用了一个跳转，并没有使用 CALL 指令，而 runtime.main 函数中确实也没有 RET 返回的指令。所以，main goroutine 执行完后，直接调用 exit(0) 退出整个进程。\n那之前整地“偷天换日”还有用吗？有的！这是针对非 main goroutine 起作用。\nmain goroutine 和普通 goroutine 的退出过程：\n 对于 main goroutine，在执行完用户定义的 main 函数的所有代码后，直接调用 exit(0) 退出整个进程，非常霸道。 对于普通 goroutine 则没这么“舒服”，需要经历一系列的过程。先是跳转到提前设置好的 goexit 函数的第二条指令，然后调用 runtime.goexit1，接着调用 mcall(goexit0)，而 mcall 函数会切换到 g0 栈，运行 goexit0 函数，清理 goroutine 的一些字段，并将其添加到 goroutine 缓存池里，然后进入 schedule 调度循环。到这里，普通 goroutine 才算完成使命。  ",
  "wordCount" : "9522",
  "inLanguage": "zh-cn",
  "datePublished": "2020-11-18T14:34:06Z",
  "dateModified": "2020-11-18T14:34:06Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/go%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Go进程的生命周期源码剖析
    </h1>
    <div class="post-meta">November 18, 2020
</div>
  </header> 
  <div class="post-content"><h2 id="runtime">runtime<a hidden class="anchor" aria-hidden="true" href="#runtime">#</a></h2>
<p>Go 语言是一⻔有 runtime 的语言，那么 runtime 是什么?</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210808222206.png" alt=""  />
</p>
<p>可以认为 runtime 是为了实现额外的功能，而在程序运行时自动 加载/运行的一些模块。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210808222246.png" alt=""  />
</p>
<p>Go 语言的 runtime 包括:</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210808222331.png" alt=""  />
</p>
<p>这些模块中，最核心的就是 Scheduler，它负责串联所有的 runtime 流程.</p>
<h2 id="调度器的生命周期">调度器的生命周期<a hidden class="anchor" aria-hidden="true" href="#调度器的生命周期">#</a></h2>
<p>所有的Go程序运行都会经过一个完整的调度器生命周期：从创建到结束。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20190706204142.png" alt=""  />
</p>
<p>即使下面这段简单的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="c1">// main.main
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello scheduler&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>也会经历如上图所示的过程：</p>
<ol>
<li>runtime创建最初的线程m0和goroutine g0，并把2者关联。</li>
<li>调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。</li>
<li>示例代码中的main函数是main.main，runtime中也有1个main函数——runtime.main，代码经过编译后，runtime.main会调用main.main，程序启动时会为runtime.main创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。</li>
<li>启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。</li>
<li>G拥有栈，M根据G中的栈信息和调度信息设置运行环境</li>
<li>M运行G</li>
<li>G退出，再次回到M获取可运行的G，这样重复下去，直到main.main退出，runtime.main执行Defer和Panic处理，或调用runtime.exit退出程序。</li>
</ol>
<p>调度器的生命周期几乎占满了一个Go程序的一生，runtime.main的goroutine执行之前都是为调度器做准备工作，runtime.main的goroutine运行，才是调度器的真正开始，直到runtime.main结束而结束。</p>
<p>M0 是启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了。</p>
<p>G0 是每次启动一个 M 都会第一个创建的 gourtine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0。</p>
<h2 id="go进程的执行入口">Go进程的执行入口<a hidden class="anchor" aria-hidden="true" href="#go进程的执行入口">#</a></h2>
<p>在 proc.go 和 runtime2.go 文件中，有一些很重要全局的变量，我们先列出来：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 所有 g 的长度
</span><span class="c1"></span><span class="nx">allglen</span>     <span class="kt">uintptr</span>

<span class="c1">// 保存所有的 g
</span><span class="c1"></span><span class="nx">allgs</span>    <span class="p">[]</span><span class="o">*</span><span class="nx">g</span>

<span class="c1">// 保存所有的 m
</span><span class="c1"></span><span class="nx">allm</span>        <span class="o">*</span><span class="nx">m</span>

<span class="c1">// 保存所有的 p，_MaxGomaxprocs = 1024
</span><span class="c1"></span><span class="nx">allp</span>        <span class="p">[</span><span class="nx">_MaxGomaxprocs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nx">p</span>

<span class="c1">// p 的最大值，默认等于 ncpu
</span><span class="c1"></span><span class="nx">gomaxprocs</span>  <span class="kt">int32</span>

<span class="c1">// 程序启动时，会调用 osinit 函数获得此值
</span><span class="c1"></span><span class="nx">ncpu</span>        <span class="kt">int32</span>

<span class="c1">// 调度器结构体对象，记录了调度器的工作状态
</span><span class="c1"></span><span class="nx">sched</span>       <span class="nx">schedt</span>

<span class="c1">// 代表进程的主线程
</span><span class="c1"></span><span class="nx">m0</span>           <span class="nx">m</span>

<span class="c1">// m0 的 g0，即 m0.g0 = &amp;g0
</span><span class="c1"></span><span class="nx">g0</span>           <span class="nx">g</span>
</code></pre></td></tr></table>
</div>
</div><p>在程序初始化时，这些全局变量都会被初始化为零值：指针被初始化为 nil 指针，切片被初始化为 nil 切片，int 被初始化为 0，结构体的所有成员变量按其类型被初始化为对应的零值。</p>
<p>因此程序刚启动时 allgs，allm 和allp 都不包含任何 g，m 和 p。</p>
<p>不仅是 Go 程序，系统加载可执行文件大概都会经过这几个阶段：</p>
<ol>
<li>从磁盘上读取可执行文件，加载到内存</li>
<li>创建进程和主线程</li>
<li>为主线程分配栈空间</li>
<li>把由用户在命令行输入的参数拷贝到主线程的栈</li>
<li>把主线程放入操作系统的运行队列等待被调度</li>
</ol>
<p>我们从一个 Hello World 的例子来回顾一下 Go 程序初始化的过程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello world&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在项目根目录下执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">gcflags</span> <span class="s">&#34;-N -l&#34;</span> <span class="o">-</span><span class="n">o</span> <span class="n">hello</span> <span class="n">src</span><span class="o">/</span><span class="n">main.go</span>
</code></pre></td></tr></table>
</div>
</div><p>-gcflags &ldquo;-N -l&rdquo; 是为了关闭编译器优化和函数内联，防止后面在设置断点的时候找不到相对应的代码位置。</p>
<p>得到了可执行文件 hello，执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">gdb</span> <span class="n">hello</span>
</code></pre></td></tr></table>
</div>
</div><p>进入 gdb 调试模式，执行 info files，得到可执行文件的文件头，列出了各种段：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201116150146.png" alt=""  />
</p>
<p>同时，我们也得到了入口地址：0x450e20。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">b</span> <span class="o">*</span><span class="mh">0x450e20</span>
<span class="n">Breakpoint</span> <span class="m">1</span> <span class="n">at</span> <span class="mh">0x450e20</span><span class="o">:</span> <span class="n">file</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">rt0_linux_amd64.s</span><span class="p">,</span> <span class="n">line</span> <span class="m">8</span><span class="n">.
</span></code></pre></td></tr></table>
</div>
</div><p>这就是 Go 程序的入口地址，我是在 linux 上运行的，所以入口文件为 src/runtime/rt0_linux_amd64.s，runtime 目录下有各种不同名称的程序入口文件，支持各种操作系统和架构，代码为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">TEXT</span> <span class="nf">_rt0_amd64_linux</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span><span class="n">NOSPLIT</span><span class="p">,</span><span class="o">$</span><span class="m">-8</span>
    <span class="n">LEAQ</span>    <span class="m">8</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">SI</span> <span class="o">//</span> <span class="n">argv</span>
    <span class="n">MOVQ</span>    <span class="m">0</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">DI</span> <span class="o">//</span> <span class="n">argc</span>
    <span class="n">MOVQ</span>    <span class="o">$</span><span class="nf">main</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">AX</span>
    <span class="n">JMP</span>    <span class="n">AX</span>
</code></pre></td></tr></table>
</div>
</div><p>主要是把 argc，argv 从内存拉到了寄存器。这里 LEAQ 是计算内存地址，然后把内存地址本身放进寄存器里，也就是把 argv 的地址放到了 SI 寄存器中。最后跳转到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">TEXT</span> <span class="nf">main</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span><span class="n">NOSPLIT</span><span class="p">,</span><span class="o">$</span><span class="m">-8</span>
    <span class="n">MOVQ</span>    <span class="o">$</span><span class="n">runtime</span>·<span class="nf">rt0_go</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">AX</span>
    <span class="n">JMP</span>    <span class="n">AX</span>
</code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210808222750.png" alt=""  />
</p>
<p>继续跳转到 runtime·rt0_go(SB)，完成 go 启动时所有的初始化工作。位于 /usr/local/go/src/runtime/asm_amd64.s.</p>
<p>或者使用开源反编译工具cutter.</p>
<h2 id="go启动的初始化工作">Go启动的初始化工作<a hidden class="anchor" aria-hidden="true" href="#go启动的初始化工作">#</a></h2>
<p>rt0_go完成 go 启动时所有的初始化工作.</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210808222951.png" alt=""  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">rt0_go</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span><span class="nx">NOSPLIT</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span>
    <span class="c1">// copy arguments forward on an even stack
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">DI</span><span class="p">,</span> <span class="nx">AX</span>      <span class="c1">// argc
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">SI</span><span class="p">,</span> <span class="nx">BX</span>      <span class="c1">// argv
</span><span class="c1"></span>    <span class="nx">SUBQ</span>    <span class="err">$</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="mi">8</span><span class="o">+</span><span class="mi">7</span><span class="p">),</span> <span class="nx">SP</span>        <span class="c1">// 2args 2auto
</span><span class="c1"></span>    <span class="c1">// 调整栈顶寄存器使其按 16 字节对齐
</span><span class="c1"></span>    <span class="nx">ANDQ</span>    <span class="err">$~</span><span class="mi">15</span><span class="p">,</span> <span class="nx">SP</span>
    <span class="c1">// argc 放在 SP+16 字节处
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="c1">// argv 放在 SP+24 字节处
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">BX</span><span class="p">,</span> <span class="mi">24</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>

    <span class="c1">// create istack out of the given (operating system) stack.
</span><span class="c1"></span>    <span class="c1">// _cgo_init may update stackguard.
</span><span class="c1"></span>    <span class="c1">// 给 g0 分配栈空间
</span><span class="c1"></span>
    <span class="c1">// 把 g0 的地址存入 DI
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">g0</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">DI</span>
    <span class="c1">// BX = SP - 64*1024 + 104
</span><span class="c1"></span>    <span class="nf">LEAQ</span>    <span class="p">(</span><span class="o">-</span><span class="mi">64</span><span class="o">*</span><span class="mi">1024</span><span class="o">+</span><span class="mi">104</span><span class="p">)(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BX</span>
    <span class="c1">// g0.stackguard0 = SP - 64*1024 + 104
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">BX</span><span class="p">,</span> <span class="nf">g_stackguard0</span><span class="p">(</span><span class="nx">DI</span><span class="p">)</span>
    <span class="c1">// g0.stackguard1 = SP - 64*1024 + 104
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">BX</span><span class="p">,</span> <span class="nf">g_stackguard1</span><span class="p">(</span><span class="nx">DI</span><span class="p">)</span>
    <span class="c1">// g0.stack.lo = SP - 64*1024 + 104
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">BX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_stack</span><span class="o">+</span><span class="nx">stack_lo</span><span class="p">)(</span><span class="nx">DI</span><span class="p">)</span>
    <span class="c1">// g0.stack.hi = SP
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">SP</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_stack</span><span class="o">+</span><span class="nx">stack_hi</span><span class="p">)(</span><span class="nx">DI</span><span class="p">)</span>

    <span class="c1">// ……………………
</span><span class="c1"></span>    <span class="c1">// 省略了很多检测 CPU 信息的代码
</span><span class="c1"></span>    <span class="c1">// ……………………
</span><span class="c1"></span>

    <span class="c1">// 初始化 m 的 tls
</span><span class="c1"></span>    <span class="c1">// DI = &amp;m0.tls，取 m0 的 tls 成员的地址到 DI 寄存器
</span><span class="c1"></span>    <span class="nx">LEAQ</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nx">m0</span><span class="o">+</span><span class="nf">m_tls</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">DI</span>
    <span class="c1">// 调用 settls 设置线程本地存储，settls 函数的参数在 DI 寄存器中
</span><span class="c1"></span>    <span class="c1">// 之后，可通过 fs 段寄存器找到 m.tls
</span><span class="c1"></span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">settls</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

    <span class="c1">// store through it, to make sure it works
</span><span class="c1"></span>    <span class="c1">// 获取 fs 段基址并放入 BX 寄存器，其实就是 m0.tls[1] 的地址，get_tls 的代码由编译器生成
</span><span class="c1"></span>    <span class="nf">get_tls</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mh">0x123</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
    <span class="nx">MOVQ</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nx">m0</span><span class="o">+</span><span class="nf">m_tls</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
    <span class="nx">CMPQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="err">$</span><span class="mh">0x123</span>
    <span class="nx">JEQ</span> <span class="mi">2</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>
    <span class="nx">MOVL</span>    <span class="nx">AX</span><span class="p">,</span> <span class="mi">0</span>   <span class="c1">// abort
</span><span class="c1"></span><span class="nx">ok</span><span class="p">:</span>
    <span class="c1">// set the per-goroutine and per-mach &#34;registers&#34;
</span><span class="c1"></span>    <span class="c1">// 获取 fs 段基址到 BX 寄存器
</span><span class="c1"></span>    <span class="nf">get_tls</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
    <span class="c1">// 将 g0 的地址存储到 CX，CX = &amp;g0
</span><span class="c1"></span>    <span class="nx">LEAQ</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">g0</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">CX</span>
    <span class="c1">// 把 g0 的地址保存在线程本地存储里面，也就是 m0.tls[0]=&amp;g0
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">CX</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
    <span class="c1">// 将 m0 的地址存储到 AX，AX = &amp;m0
</span><span class="c1"></span>    <span class="nx">LEAQ</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">m0</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>

    <span class="c1">// save m-&gt;g0 = g0
</span><span class="c1"></span>    <span class="c1">// m0.g0 = &amp;g0
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">CX</span><span class="p">,</span> <span class="nf">m_g0</span><span class="p">(</span><span class="nx">AX</span><span class="p">)</span>
    <span class="c1">// save m0 to g0-&gt;m
</span><span class="c1"></span>    <span class="c1">// g0.m = &amp;m0
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="nf">g_m</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>

    <span class="nx">CLD</span>             <span class="c1">// convention is D is always left cleared
</span><span class="c1"></span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">check</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

    <span class="nx">MOVL</span>    <span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>      <span class="c1">// copy argc
</span><span class="c1"></span>    <span class="nx">MOVL</span>    <span class="nx">AX</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="nx">MOVQ</span>    <span class="mi">24</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>      <span class="c1">// copy argv
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">args</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

    <span class="c1">// 初始化系统核心数
</span><span class="c1"></span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">osinit</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
    <span class="c1">// 调度器初始化
</span><span class="c1"></span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">schedinit</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

	<span class="c1">// create a new goroutine to start program
</span><span class="c1"></span>	<span class="c1">// 创建一个新的 goroutine 来启动程序
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">mainPC</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>     <span class="c1">// entry
</span><span class="c1"></span>    <span class="c1">// newproc 的第二个参数入栈，也就是新的 goroutine 需要执行的函数
</span><span class="c1"></span>    <span class="c1">// AX = &amp;funcval{runtime·main},
</span><span class="c1"></span>    <span class="nx">PUSHQ</span>   <span class="nx">AX</span>
    <span class="c1">// newproc 的第一个参数入栈，该参数表示 runtime.main 函数需要的参数大小，
</span><span class="c1"></span>    <span class="c1">// 因为 runtime.main 没有参数，所以这里是 0
</span><span class="c1"></span>    <span class="nx">PUSHQ</span>   <span class="err">$</span><span class="mi">0</span>          <span class="c1">// arg size
</span><span class="c1"></span>    <span class="c1">// 创建 main goroutine
</span><span class="c1"></span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">newproc</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
    <span class="nx">POPQ</span>    <span class="nx">AX</span>
    <span class="nx">POPQ</span>    <span class="nx">AX</span>

    <span class="c1">// start this M
</span><span class="c1"></span>    <span class="c1">// 主线程进入调度循环，运行刚刚创建的 goroutine
</span><span class="c1"></span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">mstart</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

    <span class="c1">// 永远不会返回，万一返回了，crash 掉
</span><span class="c1"></span>    <span class="nx">MOVL</span>    <span class="err">$</span><span class="mh">0xf1</span><span class="p">,</span> <span class="mh">0xf1</span>  <span class="c1">// crash
</span><span class="c1"></span>    <span class="nx">RET</span>
</code></pre></td></tr></table>
</div>
</div><p>这段代码完成之后，整个 Go 程序就可以跑起来了。</p>
<p>调度器初始化函数：schedinit 返回后，调度器的相关参数都已经初始化好了.</p>
<h3 id="调整-sp">调整 SP<a hidden class="anchor" aria-hidden="true" href="#调整-sp">#</a></h3>
<p>第一段代码，将 SP 调整到了一个地址是 16 的倍数的位置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">SUBQ</span>    <span class="err">$</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="mi">8</span><span class="o">+</span><span class="mi">7</span><span class="p">),</span> <span class="nx">SP</span>        <span class="c1">// 2args 2auto
</span><span class="c1">// 调整栈顶寄存器使其按 16 个字节对齐
</span><span class="c1"></span><span class="nx">ANDQ</span>    <span class="err">$~</span><span class="mi">15</span><span class="p">,</span> <span class="nx">SP</span>
</code></pre></td></tr></table>
</div>
</div><p>先是将 SP 减掉 39，也就是向下移动了 39 个 Byte，再进行与运算。</p>
<p>15 的二进制低四位是全 1：1111，其他位都是 0；取反后，变成了 0000，高位则是全 1。这样，与 SP 进行了与运算后，低 4 位变成了全 0，高位则不变。因此 SP 继续向下移动，并且这回是在一个地址值为 16 的倍数的地方，16 字节对齐的地方。</p>
<p>为什么要这么做？画一张图就明白了。不过先得说明一点，前面 _rt0_amd64_linux 函数里讲过，DI 里存的是 argc 的值，8 个字节，而 SI 里则存的是 argv 的地址，8 个字节。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201116151357.png" alt=""  />
</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201116151417.png" alt=""  />
</p>
<p>上面两张图中，左侧用箭头标注了 16 字节对齐的位置。第一步表示向下移动 39 B，第二步表示与 ~15 相与。
存在两种情况，这也是第一步将 SP 下移的时候，多移了 7 个 Byte 的原因。第一张图里，与 ~15 相与的时候，SP 值减少了 1，第二张图则减少了 9。最后都是移位到了 16 字节对齐的位置。</p>
<p>两张图的共同点是 SP 与 argc 中间多出了 16 个字节的空位。这个后面应该会用到，我们接着探索。</p>
<p>至于为什么进行 16 个字节对齐，就比较好理解了：因为 CPU 有一组 SSE 指令，这些指令中出现的内存地址必须是 16 的倍数。</p>
<h3 id="初始化-g0-栈">初始化 g0 栈<a hidden class="anchor" aria-hidden="true" href="#初始化-g0-栈">#</a></h3>
<p>接着往后看，开始初始化 g0 的栈了。g0 栈的作用就是为运行 runtime 代码提供一个“环境”。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 把 g0 的地址存入 DI
</span><span class="c1"></span><span class="nx">MOVQ</span>    <span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">g0</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">DI</span>
<span class="c1">// BX = SP - 64*1024 + 104
</span><span class="c1"></span><span class="nf">LEAQ</span>    <span class="p">(</span><span class="o">-</span><span class="mi">64</span><span class="o">*</span><span class="mi">1024</span><span class="o">+</span><span class="mi">104</span><span class="p">)(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BX</span>
<span class="c1">// g0.stackguard0 = SP - 64*1024 + 104
</span><span class="c1"></span><span class="nx">MOVQ</span>    <span class="nx">BX</span><span class="p">,</span> <span class="nf">g_stackguard0</span><span class="p">(</span><span class="nx">DI</span><span class="p">)</span>
<span class="c1">// g0.stackguard1 = SP - 64*1024 + 104
</span><span class="c1"></span><span class="nx">MOVQ</span>    <span class="nx">BX</span><span class="p">,</span> <span class="nf">g_stackguard1</span><span class="p">(</span><span class="nx">DI</span><span class="p">)</span>
<span class="c1">// g0.stack.lo = SP - 64*1024 + 104
</span><span class="c1"></span><span class="nx">MOVQ</span>    <span class="nx">BX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_stack</span><span class="o">+</span><span class="nx">stack_lo</span><span class="p">)(</span><span class="nx">DI</span><span class="p">)</span>
<span class="c1">// g0.stack.hi = SP
</span><span class="c1"></span><span class="nx">MOVQ</span>    <span class="nx">SP</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_stack</span><span class="o">+</span><span class="nx">stack_hi</span><span class="p">)(</span><span class="nx">DI</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>代码 L2 把 g0 的地址存入 DI 寄存器；L4 将 SP 下移 (64K-104)B，并将地址存入 BX 寄存器；L6 将 BX 里存储的地址赋给 g0.stackguard0；L8，L10，L12 分别 将 BX 里存储的地址赋给 g0.stackguard1， g0.stack.lo， g0.stack.hi。</p>
<p>这部分完成之后，g0 栈空间如下图：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201116151552.png" alt=""  />
</p>
<h3 id="主线程绑定-m0">主线程绑定 m0<a hidden class="anchor" aria-hidden="true" href="#主线程绑定-m0">#</a></h3>
<p>m0: Go 程序启动后创建的第一个线程</p>
<p>接着往下看，中间我们省略了很多检查 CPU 相关的代码，直接看主线程绑定 m0 的部分：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 初始化 m 的 tls
</span><span class="c1">// DI = &amp;m0.tls，取 m0 的 tls 成员的地址到 DI 寄存器
</span><span class="c1"></span><span class="nx">LEAQ</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nx">m0</span><span class="o">+</span><span class="nf">m_tls</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">DI</span>
<span class="c1">// 调用 settls 设置线程本地存储，settls 函数的参数在 DI 寄存器中
</span><span class="c1">// 之后，可通过 fs 段寄存器找到 m.tls
</span><span class="c1"></span><span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">settls</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

<span class="c1">// store through it, to make sure it works
</span><span class="c1">// 获取 fs 段基地址并放入 BX 寄存器，其实就是 m0.tls[1] 的地址，get_tls 的代码由编译器生成
</span><span class="c1"></span><span class="nf">get_tls</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
<span class="nx">MOVQ</span>    <span class="err">$</span><span class="mh">0x123</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
<span class="nx">MOVQ</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nx">m0</span><span class="o">+</span><span class="nf">m_tls</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
<span class="nx">CMPQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="err">$</span><span class="mh">0x123</span>
<span class="nx">JEQ</span> <span class="mi">2</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>
<span class="nx">MOVL</span>    <span class="nx">AX</span><span class="p">,</span> <span class="mi">0</span>    <span class="c1">// abort
</span></code></pre></td></tr></table>
</div>
</div><p>因为 m0 是全局变量，而 m0 又要绑定到工作线程才能执行。我们又知道，runtime 会启动多个工作线程，每个线程都会绑定一个 m0。而且，代码里还得保持一致，都是用 m0 来表示。这就要用到线程本地存储的知识了，也就是常说的 TLS（Thread Local Storage）。简单来说，TLS 就是线程本地的私有的全局变量。</p>
<p>一般而言，全局变量对进程中的多个线程同时可见。进程中的全局变量与函数内定义的静态（static）变量，是各个线程都可以访问的共享变量。一个线程修改了，其他线程就会“看见”。要想搞出一个线程私有的变量，就需要用到 TLS 技术。</p>
<p>如果需要在一个线程内部的各个函数调用都能访问、但其它线程不能访问的变量（被称为 static memory local to a thread，线程局部静态变量），就需要新的机制来实现。这就是 TLS。</p>
<p>继续来看源码，L3 将 m0.tls 地址存储到 DI 寄存器，再调用 settls 完成 tls 的设置，tls 是 m 结构体中的一个数组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// thread-local storage (for x86 extern register)
</span><span class="c1"></span><span class="nx">tls</span> <span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="kt">uintptr</span>
</code></pre></td></tr></table>
</div>
</div><p>设置 tls 的函数 runtime·settls(SB) 位于源码 src/runtime/sys_linux_amd64.s 处，主要内容就是通过一个系统调用将 fs 段基址设置成 m.tls[1] 的地址，而 fs 段基址又可以通过 CPU 里的寄存器 fs 来获取。</p>
<p>而每个线程都有自己的一组 CPU 寄存器值，操作系统在把线程调离 CPU 时会帮我们把所有寄存器中的值保存在内存中，调度线程来运行时又会从内存中把这些寄存器的值恢复到 CPU。</p>
<p>这样，工作线程代码就可以通过 fs 寄存器来找到 m.tls。</p>
<p>设置完 tls 之后，又来了一段验证上面 settls 是否能正常工作。如果不能，会直接 crash。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">get_tls</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
<span class="nx">MOVQ</span>    <span class="err">$</span><span class="mh">0x123</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
<span class="nx">MOVQ</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nx">m0</span><span class="o">+</span><span class="nf">m_tls</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
<span class="nx">CMPQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="err">$</span><span class="mh">0x123</span>
<span class="nx">JEQ</span> <span class="mi">2</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>
<span class="nx">MOVL</span>    <span class="nx">AX</span><span class="p">,</span> <span class="mi">0</span>    <span class="c1">// abort
</span></code></pre></td></tr></table>
</div>
</div><p>第一行代码，获取 tls，get_tls(BX) 的代码由编译器生成，源码中并没有看到，可以理解为将 m.tls 的地址存入 BX 寄存器。</p>
<p>L2 将一个数 0x123 放入 m.tls[0] 处，L3 则将 m.tls[0] 处的数据取出来放到 AX 寄存器，L4 则比较两者是否相等。如果相等，则跳过 L6 行的代码，否则执行 L6，程序 crash。</p>
<p>继续看代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// set the per-goroutine and per-mach &#34;registers&#34;
</span><span class="c1">// 获取 fs 段基址到 BX 寄存器
</span><span class="c1"></span><span class="nf">get_tls</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
<span class="c1">// 将 g0 的地址存储到 CX，CX = &amp;g0
</span><span class="c1"></span><span class="nx">LEAQ</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">g0</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">CX</span>
<span class="c1">// 把 g0 的地址保存在线程本地存储里面，也就是 m0.tls[0]=&amp;g0
</span><span class="c1"></span><span class="nx">MOVQ</span>    <span class="nx">CX</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
<span class="c1">// 将 m0 的地址存储到 AX，AX = &amp;m0
</span><span class="c1"></span><span class="nx">LEAQ</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">m0</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>

<span class="c1">// save m-&gt;g0 = g0
</span><span class="c1">// m0.g0 = &amp;g0
</span><span class="c1"></span><span class="nx">MOVQ</span>    <span class="nx">CX</span><span class="p">,</span> <span class="nf">m_g0</span><span class="p">(</span><span class="nx">AX</span><span class="p">)</span>
<span class="c1">// save m0 to g0-&gt;m
</span><span class="c1">// g0.m = &amp;m0
</span><span class="c1"></span><span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="nf">g_m</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>L3 将 m.tls 地址存入 BX；L5 将 g0 的地址存入 CX；L7 将 CX，也就是 g0 的地址存入 m.tls[0]；L9 将 m0 的地址存入 AX；L13 将 g0 的地址存入 m0.g0；L16 将 m0 存入 g0.m。也就是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">tls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="nx">g0</span>
<span class="nx">m0</span><span class="p">.</span><span class="nx">g0</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">g0</span>
<span class="nx">g0</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">m0</span>
</code></pre></td></tr></table>
</div>
</div><p>代码中寄存器前面的符号看着比较奇怪，其实它们最后会被链接器转化为偏移量。</p>
<p>这种写法在标准 plan9 汇编中只是个 symbol，没有任何偏移量的意思，但这里却用名字来代替了其偏移量，这是怎么回事呢？</p>
<p>实际上这是 runtime 的特权，是需要链接器配合完成的，再来看看 gobuf 在 runtime 中的 struct 定义开头部分的注释:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// The offsets of sp, pc, and g are known to (hard-coded in) libmach.
</span></code></pre></td></tr></table>
</div>
</div><p>对于我们而言，这种写法读起来比较容易。</p>
<p>这一段执行完之后，就把 m0，g0，m.tls[0] 串联起来了。通过 m.tls[0] 可以找到 g0，通过 g0 可以找到 m0（通过 g 结构体的 m 字段）。并且，通过 m 的字段 g0，m0 也可以找到 g0。于是，主线程和 m0，g0 就关联起来了。</p>
<p>从这里还可以看到，保存在主线程本地存储中的值是 g0 的地址，也就是说工作线程的私有全局变量其实是一个指向 g 的指针而不是指向 m 的指针。</p>
<p>目前这个指针指向g0，表示代码正运行在 g0 栈。</p>
<p>于是，前面的图又增加了新的玩伴 m0：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201116161105.png" alt=""  />
</p>
<h3 id="初始化-m0">初始化 m0<a hidden class="anchor" aria-hidden="true" href="#初始化-m0">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">MOVL</span>    <span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>        <span class="c1">// copy argc
</span><span class="c1"></span><span class="nx">MOVL</span>    <span class="nx">AX</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
<span class="nx">MOVQ</span>    <span class="mi">24</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>        <span class="c1">// copy argv
</span><span class="c1"></span><span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
<span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">args</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
<span class="c1">// 初始化系统核心数
</span><span class="c1"></span><span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">osinit</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
<span class="c1">// 调度器初始化
</span><span class="c1"></span><span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">schedinit</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>L1-L2 将 16(SP) 处的内容移动到 0(SP)，也就是栈顶，通过前面的图，16(SP) 处的内容为 argc；L3-L4 将 argv 存入 8(SP)，接下来调用 runtime·args 函数，处理命令行参数。</p>
<p>接着，连续调用了两个 runtime 函数。osinit 函数初始化系统核心数，将全局变量 ncpu 初始化的核心数，schedinit 则是调度器的初始化。</p>
<h3 id="main-goroutine创建">main goroutine创建<a hidden class="anchor" aria-hidden="true" href="#main-goroutine创建">#</a></h3>
<p>继续看代码，前面我们完成了 schedinit 函数，这是 runtime·rt0_go 函数里的一步，接着往后看：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 创建一个新的 goroutine 来启动程序
</span><span class="c1"></span><span class="nx">MOVQ</span>    <span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">mainPC</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>        <span class="c1">// entry
</span><span class="c1">// newproc 的第二个参数入栈，也就是新的 goroutine 需要执行的函数
</span><span class="c1">// AX = &amp;funcval{runtime·main},
</span><span class="c1"></span><span class="nx">PUSHQ</span>    <span class="nx">AX</span>
<span class="c1">// newproc 的第一个参数入栈，该参数表示 runtime.main 函数需要的参数大小，
</span><span class="c1">// 因为 runtime.main 没有参数，所以这里是 0
</span><span class="c1"></span><span class="nx">PUSHQ</span>    <span class="err">$</span><span class="mi">0</span>            <span class="c1">// arg size
</span><span class="c1">// 创建 main goroutine
</span><span class="c1"></span><span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">newproc</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
<span class="nx">POPQ</span>    <span class="nx">AX</span>
<span class="nx">POPQ</span>    <span class="nx">AX</span>

<span class="c1">// start this M
</span><span class="c1">// 主线程进入调度循环，运行刚刚创建的 goroutine
</span><span class="c1"></span><span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">mstart</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

<span class="c1">// 永远不会返回，万一返回了，crash 掉
</span><span class="c1"></span><span class="nx">MOVL</span>    <span class="err">$</span><span class="mh">0xf1</span><span class="p">,</span> <span class="mh">0xf1</span>  <span class="c1">// crash
</span><span class="c1"></span><span class="nx">RET</span>
</code></pre></td></tr></table>
</div>
</div><p>代码前面几行是在为调用 newproc 函数构“造栈”，执行完 runtime·newproc(SB) 后，就会以一个新的 goroutine 来执行 mainPC 也就是 runtime.main() 函数。runtime.main() 函数最终会执行到我们写的 main 函数。</p>
<p>重点来看 newproc 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/proc.go
</span><span class="c1">// 创建一个新的 g，运行 fn 函数，需要 siz byte 的参数
</span><span class="c1">// 将其放至 G 队列等待运行
</span><span class="c1">// 编译器会将 go 关键字的语句转化成此函数
</span><span class="c1"></span>
<span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newproc</span><span class="p">(</span><span class="nx">siz</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>每个 goroutine 都有自己的栈空间，newproc 函数会新创建一个新的 goroutine 来执行 fn 函数.</p>
<p>当前代码在 g0 栈上执行，因此执行完<code>_g_ := getg()</code> 之后，无论是在什么情况下都可以得到 <em>g</em> = g0。之后通过 g0 找到其绑定的 P，也就是 p0。</p>
<p>接着，尝试从 p0 上找一个空闲的 G.</p>
<p>如果拿不到，则会在堆上创建一个新的 G，为其分配 2KB 大小的栈，并设置好新 goroutine 的 stack 成员，设置其状态为 _Gdead，并将其添加到全局变量 allgs 中。创建完成之后，我们就在堆上有了一个 2K 大小的栈。于是，我们的图再次丰富：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201116223753.png" alt=""  />
</p>
<p>这样，main goroutine 就诞生了。</p>
<h2 id="g0栈和用户栈的迁移">g0栈和用户栈的迁移<a hidden class="anchor" aria-hidden="true" href="#g0栈和用户栈的迁移">#</a></h2>
<p>g0 栈用于执行调度器的代码，执行完之后，要跳转到执行用户代码的地方，如何跳转？这中间涉及到栈和寄存器的切换。</p>
<p>将 fn 的参数从 g0 栈上拷贝到 newg 的栈上，memmove 函数需要传入源地址、目的地址、参数大小。由于 main 函数在这里没有参数需要拷贝，因此这里相当于没做什么。</p>
<p>接着，初始化 newg 的各种字段，而且涉及到最重要的 pc，sp 等字段：</p>
<p>而 goexit 函数也通过“偷天换日”将自己的地址“强行”放到 newg 的栈顶，达到自己不可告人的目的：每个 goroutine 执行完之后，都要经过我的一些清理工作，才能“放行”。这样一说，goexit 函数还真是无私，默默地做一些“扫尾”的工作。</p>
<p>设置完 newg.sched 这后，我们的图又可以前进一步：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201117103559.png" alt=""  />
</p>
<p>上图中，newg 新增了 sched.pc 指向 runtime.main 函数，当它被调度起来执行时，就从这里开始；新增了 sched.sp 指向了 newg 栈顶位置，同时，newg 栈顶位置的内容是一个跳转地址，指向 runtime.goexit 的第二条指令，当 goroutine 退出时，这条地址会载入 CPU 的 PC 寄存器，跳转到这里执行“扫尾”工作。</p>
<p>newg 的状态变成可执行后（Runnable），就可以将它加入到 P 的本地运行队列里，等待调度。所以，goroutine 何时被执行，用户代码决定不了。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201117103816.png" alt=""  />
</p>
<h2 id="schedule-循环">schedule 循环<a hidden class="anchor" aria-hidden="true" href="#schedule-循环">#</a></h2>
<p>在 runtime·rt0_go 函数里，执行完 runtime·newproc(SB) 后，两条 POP 指令将之前为调用它构建的参数弹出栈。只剩下一个函数了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// start this M
</span><span class="c1">// 主线程进入调度循环，运行刚刚创建的 goroutine
</span><span class="c1"></span><span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">mstart</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>mstart 函数设置了 stackguard0 和 stackguard1 字段后，就直接调用 mstart1() 函数：</p>
<p>调用 gosave 函数来保存调度信息到 g0.sched 结构体.</p>
<p>主要是设置了 g0.sched.sp 和 g0.sched.pc，前者指向 mstart1 函数栈上参数的位置，后者则指向 gosave 函数返回后的下一条指令。如下图：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201117112607.png" alt=""  />
</p>
<p>图中 sched.pc 并不直接指向返回地址，所以图中的虚线并没有箭头。</p>
<p>接下来，进入 schedule 函数，找到了可以运行的 main goroutine，调用 execute(gp, inheritTime) 将 gp 的状态改为 _Grunning，将 m 和 gp 相互关联起来。最后，调用 gogo 完成从 g0 到 gp 的切换，CPU 的执行权将从 g0 转让到 gp。开始执行 runtime.main 函数。</p>
<p>用一张流程图总结一下从 g0 切换到 main goroutine 的过程.</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201117143423.png" alt=""  />
</p>
<p>main goroutine 退出后直接调用 exit(0) 使得整个进程退出，而普通 goroutine 退出后，则进行了一系列的调用，最终又切到 g0 栈，执行 schedule 函数。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201117170452.png" alt=""  />
</p>
<p>如图所示，rt0_go 负责 Go 程序启动的所有初始化，中间进行了很多初始化工作，调用 mstart 之前，已经切换到了 g0 栈，图中不同色块表示使用不同的栈空间。</p>
<p>接着调用 gogo 函数，完成从 g0 栈到用户 goroutine 栈的切换，包括 main goroutine 和普通 goroutine。
之后，执行 main 函数或者用户自定义的 goroutine 任务。</p>
<p>执行完成后，main goroutine 直接调用 eixt(0) 退出，普通 goroutine 则调用 goexit -&gt; goexit1 -&gt; mcall，完成普通 goroutine 退出后的清理工作，然后切换到 g0 栈，调用 goexit0 函数，将普通 goroutine 添加到缓存池中，再调用 schedule 函数进行新一轮的调度。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">schedule</span><span class="p">()</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nf">execute</span><span class="p">()</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nf">gogo</span><span class="p">()</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nx">goroutine</span> <span class="nx">任务</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nf">goexit</span><span class="p">()</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nf">goexit1</span><span class="p">()</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nf">mcall</span><span class="p">()</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nf">goexit0</span><span class="p">()</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nf">schedule</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看出，一轮调度从调用 schedule 函数开始，经过一系列过程再次调用 schedule 函数来进行新一轮的调度，从一轮调度到新一轮调度的过程称之为一个调度循环。</p>
<p>这里说的调度循环是指某一个工作线程的调度循环，而同一个Go 程序中存在多个工作线程，每个工作线程都在进行着自己的调度循环。</p>
<p>从前面的代码分析可以得知，上面调度循环中的每一个函数调用都没有返回，虽然 <code>goroutine 任务-&gt; goexit() -&gt; goexit1() -&gt; mcall()</code> 是在 g2 的栈空间执行的，但剩下的函数都是在 g0 的栈空间执行的。</p>
<p>那么问题就来了，在一个复杂的程序中，调度可能会进行无数次循环，也就是说会进行无数次没有返回的函数调用，大家都知道，每调用一次函数都会消耗一定的栈空间，而如果一直这样无返回的调用下去无论 g0 有多少栈空间终究是会耗尽的，那么这里是不是有问题？其实没有问题！关键点就在于，每次执行 mcall 切换到 g0 栈时都是切换到 g0.sched.sp 所指的固定位置，这之所以行得通，正是因为从 schedule 函数开始之后的一系列函数永远都不会返回，所以重用这些函数上一轮调度时所使用过的栈内存是没有问题的。</p>
<p>我再解释一下：栈空间在调用函数时会自动“增大”，而函数返回时，会自动“减小”，这里的增大和减小是指栈顶指针 SP 的变化。上述这些函数都没有返回，说明调用者不需要用到被调用者的返回值，有点像“尾递归”。</p>
<p>因为 g0 一直没有动过，所有它之前保存的 sp 还能继续使用。每一次调度循环都会覆盖上一次调度循环的栈数据，完美！</p>
<h2 id="goroutine-执行与退出">goroutine 执行与退出<a hidden class="anchor" aria-hidden="true" href="#goroutine-执行与退出">#</a></h2>
<p>我们探索 main goroutine 以及普通 goroutine 从执行到退出的整个过程。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// The main goroutine.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// g = main goroutine，不再是 g0 了
</span><span class="c1"></span>	<span class="nx">g</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="c1">// Racectx of m0-&gt;g0 is used only as the parent of the main goroutine.
</span><span class="c1"></span>	<span class="c1">// It must not be used for anything else.
</span><span class="c1"></span>	<span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">racectx</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="c1">// Max stack size is 1 GB on 64-bit, 250 MB on 32-bit.
</span><span class="c1"></span>	<span class="c1">// Using decimal instead of binary GB and MB because
</span><span class="c1"></span>	<span class="c1">// they look nicer in the stack overflow failure message.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">==</span> <span class="mi">8</span> <span class="p">{</span>
		<span class="nx">maxstacksize</span> <span class="p">=</span> <span class="mi">1000000000</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">maxstacksize</span> <span class="p">=</span> <span class="mi">250000000</span>
	<span class="p">}</span>

	<span class="c1">// Allow newproc to start new Ms.
</span><span class="c1"></span>	<span class="nx">mainStarted</span> <span class="p">=</span> <span class="kc">true</span>

	<span class="k">if</span> <span class="nx">GOARCH</span> <span class="o">!=</span> <span class="s">&#34;wasm&#34;</span> <span class="p">{</span> <span class="c1">// no threads on wasm yet, so no sysmon
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// 创建监控线程，该线程独立于调度器，不需要跟 p 关联即可运行
</span><span class="c1"></span>			<span class="nf">newm</span><span class="p">(</span><span class="nx">sysmon</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">})</span>
	<span class="p">}</span>

	<span class="c1">// Lock the main goroutine onto this, the main OS thread,
</span><span class="c1"></span>	<span class="c1">// during initialization. Most programs won&#39;t care, but a few
</span><span class="c1"></span>	<span class="c1">// do require certain calls to be made by the main thread.
</span><span class="c1"></span>	<span class="c1">// Those can arrange for main.main to run in the main thread
</span><span class="c1"></span>	<span class="c1">// by calling runtime.LockOSThread during initialization
</span><span class="c1"></span>	<span class="c1">// to preserve the lock.
</span><span class="c1"></span>	<span class="nf">lockOSThread</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">g</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime.main not on m0&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 调用 runtime 包的初始化函数，由编译器实现
</span><span class="c1"></span>	<span class="nf">doInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">runtime_inittask</span><span class="p">)</span> <span class="c1">// must be before defer
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;nanotime returning zero&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Defer unlock so that runtime.Goexit during init does the unlock too.
</span><span class="c1"></span>	<span class="nx">needUnlock</span> <span class="o">:=</span> <span class="kc">true</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">needUnlock</span> <span class="p">{</span>
			<span class="nf">unlockOSThread</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="c1">// Record when the world started.
</span><span class="c1"></span>	<span class="nx">runtimeInitTime</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="c1">// 开启垃圾回收器
</span><span class="c1"></span>	<span class="nf">gcenable</span><span class="p">()</span>

	<span class="nx">main_init_done</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">iscgo</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">_cgo_thread_start</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;_cgo_thread_start missing&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;windows&#34;</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">_cgo_setenv</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;_cgo_setenv missing&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">_cgo_unsetenv</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;_cgo_unsetenv missing&#34;</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">_cgo_notify_runtime_init_done</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;_cgo_notify_runtime_init_done missing&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// Start the template thread in case we enter Go from
</span><span class="c1"></span>		<span class="c1">// a C-created thread and need to create a new thread.
</span><span class="c1"></span>		<span class="nf">startTemplateThread</span><span class="p">()</span>
		<span class="nf">cgocall</span><span class="p">(</span><span class="nx">_cgo_notify_runtime_init_done</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// main 包的初始化，递归的调用我们 import 进来的包的初始化函数
</span><span class="c1"></span>	<span class="nf">doInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">main_inittask</span><span class="p">)</span>

	<span class="nb">close</span><span class="p">(</span><span class="nx">main_init_done</span><span class="p">)</span>

	<span class="nx">needUnlock</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nf">unlockOSThread</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">isarchive</span> <span class="o">||</span> <span class="nx">islibrary</span> <span class="p">{</span>
		<span class="c1">// A program compiled with -buildmode=c-archive or c-shared
</span><span class="c1"></span>		<span class="c1">// has a main, but it is not executed.
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 调用 main.main 函数
</span><span class="c1"></span>	<span class="nx">fn</span> <span class="o">:=</span> <span class="nx">main_main</span> <span class="c1">// make an indirect call, as the linker doesn&#39;t know the address of the main package when laying down the runtime
</span><span class="c1"></span>	<span class="nf">fn</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">racefini</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// Make racy client program work: if panicking on
</span><span class="c1"></span>	<span class="c1">// another goroutine at the same time as main returns,
</span><span class="c1"></span>	<span class="c1">// let the other goroutine finish printing the panic trace.
</span><span class="c1"></span>	<span class="c1">// Once it does, it will exit. See issues 3934 and 20018.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">runningPanicDefers</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Running deferred functions should not take long.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">c</span> <span class="p">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">c</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">runningPanicDefers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="nf">Gosched</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">panicking</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonPanicWait</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 进入系统调用，退出进程，可以看出 main goroutine 并未返回，而是直接进入系统调用退出进程了
</span><span class="c1"></span>	<span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="c1">// 保护性代码，如果 exit 意外返回，下面的代码会让该进程 crash 死掉
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">x</span> <span class="o">*</span><span class="kt">int32</span>
		<span class="o">*</span><span class="nx">x</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>main 函数执行流程如下图：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201117154621.png" alt=""  />
</p>
<p>从流程图可知，main goroutine 执行完之后就直接调用 exit(0) 退出了，这会导致整个进程退出，太粗暴了。</p>
<p>不过，main goroutine 实际上就是代表用户的 main 函数，它都执行完了，肯定是用户的任务都执行完了，直接退出就可以了，就算有其他的 goroutine 没执行完，同样会直接退出。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello qcrao.com&#34;</span><span class="p">)}()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这个例子中，main gorutine 退出时，还来不及执行 go 出去 的函数，整个进程就直接退出了，打印语句不会执行。因此，main goroutine 不会等待其他 goroutine 执行完再退出，知道这个有时能解释一些现象，比如上面那个例子。</p>
<p>这时，心中可能会跳出疑问，我们在新创建 goroutine 的时候，不是整出了个“偷天换日”，风风火火地设置了 goroutine 退出时应该跳到 runtime.goexit 函数吗，怎么这会不用了，闲得慌？</p>
<p>回顾一下跳转到 main 函数的两行代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 把 sched.pc 值放入 BX 寄存器
</span><span class="c1"></span><span class="nx">MOVQ</span>    <span class="nf">gobuf_pc</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BX</span>
<span class="c1">// JMP 把 BX 寄存器的包含的地址值放入 CPU 的 IP 寄存器，于是，CPU 跳转到该地址继续执行指令
</span><span class="c1"></span><span class="nx">JMP</span>    <span class="nx">BX</span>
</code></pre></td></tr></table>
</div>
</div><p>直接使用了一个跳转，并没有使用 CALL 指令，而 runtime.main 函数中确实也没有 RET 返回的指令。所以，main goroutine 执行完后，直接调用 exit(0) 退出整个进程。</p>
<p>那之前整地“偷天换日”还有用吗？有的！这是针对非 main goroutine 起作用。</p>
<p>main goroutine 和普通 goroutine 的退出过程：</p>
<ul>
<li>对于 main goroutine，在执行完用户定义的 main 函数的所有代码后，直接调用 exit(0) 退出整个进程，非常霸道。</li>
<li>对于普通 goroutine 则没这么“舒服”，需要经历一系列的过程。先是跳转到提前设置好的 goexit 函数的第二条指令，然后调用 runtime.goexit1，接着调用 mcall(goexit0)，而 mcall 函数会切换到 g0 栈，运行 goexit0 函数，清理 goroutine 的一些字段，并将其添加到 goroutine 缓存池里，然后进入 schedule 调度循环。到这里，普通 goroutine 才算完成使命。</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go%E6%BA%90%E7%A0%81/">Go源码</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
