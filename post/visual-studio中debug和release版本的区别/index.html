<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Visual Studio中debug和release版本的区别 | Forz Blog</title>
<meta name="keywords" content="编译" />
<meta name="description" content="本质区别 Debug 和 Release 并没有本质的区别，他们只是VC预定义提供的两组编译选项的集合，编译器只是按照预定的选项行动。如果我们愿意，我们完全可以把Deb">
<meta name="author" content="">
<link rel="canonical" href="/post/visual-studio%E4%B8%ADdebug%E5%92%8Crelease%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Visual Studio中debug和release版本的区别" />
<meta property="og:description" content="本质区别 Debug 和 Release 并没有本质的区别，他们只是VC预定义提供的两组编译选项的集合，编译器只是按照预定的选项行动。如果我们愿意，我们完全可以把Deb" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/visual-studio%E4%B8%ADdebug%E5%92%8Crelease%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-23T16:57:04&#43;00:00" />
<meta property="article:modified_time" content="2017-06-23T16:57:04&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Visual Studio中debug和release版本的区别"/>
<meta name="twitter:description" content="本质区别 Debug 和 Release 并没有本质的区别，他们只是VC预定义提供的两组编译选项的集合，编译器只是按照预定的选项行动。如果我们愿意，我们完全可以把Deb"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Visual Studio中debug和release版本的区别",
      "item": "/post/visual-studio%E4%B8%ADdebug%E5%92%8Crelease%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Visual Studio中debug和release版本的区别",
  "name": "Visual Studio中debug和release版本的区别",
  "description": "本质区别 Debug 和 Release 并没有本质的区别，他们只是VC预定义提供的两组编译选项的集合，编译器只是按照预定的选项行动。如果我们愿意，我们完全可以把Deb",
  "keywords": [
    "编译"
  ],
  "articleBody": "本质区别 Debug 和 Release 并没有本质的区别，他们只是VC预定义提供的两组编译选项的集合，编译器只是按照预定的选项行动。如果我们愿意，我们完全可以把Debug和Release的行为完全颠倒过来。当然也可以提供其他的模式，例如自己定义一组编译选项，然后命名为MY_ABC等。习惯上，我们仍然更愿意使用VC已经定义好的名称。\nDebug版本包括调试信息，所以要比Release版本大很多（可能大数百K至数M）。至于是否需要DLL支持，主要看你采用的编译选项。如果是基于ATL的，则Debug和Release版本对DLL的要求差不多。如果采用的编译选项为使用MFC动态库，则需要MFC42D.DLL等库支持，而Release版本需要MFC42.DLL支持。Release不对源代码进行调试，不考虑MFC的诊断宏，使用的是MFC Release库，编译时对应用程序的速度进行优化，而Debug则正好相反，它允许对源代码进行调试，可以定义和使用MFC的 诊断宏，采用MFC Debug库，对速度没有优化。\n既然Debug和Release仅仅是编译选项的不同，那么为什么要区分Debug和Release版本呢？\nDebug和Release，在我看来主要是针对其面向的目标不同的而进行区分的。Debug通常称为调试版本，通过一系列编译选项的配合，编译的结果通常包含调试信息，而且不做任何优化，以为开发人员提供强大的应用程序调试能力。而Release通常称为发布版本，是为用户使用的，一般客户不允许在发布版本上进行调试。所以不保存调试信息，同时，它往往进行了各种优化，以期达到代码最小和速度最优。为用户的使用提供便利。\n下面仅就默认的Debug和Release版本的选项进行 比较，详细的编译选项可以看MSDN的说明。\n我们将默认的Debug和Release的选项设置进行比较，过滤掉相同设置，主要的不同如下：\n编译选项：/Od /D “_DEBUG” /Gm /RTC1 /MDd /Fo”Debug““” /ZI\n链接选项：/OUT：”D：“MyProject“logging“Debug“OptionTest.dll” /INCREMENTAL\nRelease设置：\n编译选项：/O2 /GL /D “NDEBUG” /FD /MD /Fo”Release““” /Zi\n链 接选项：/OUT：”D：“MyProject“logging“Release“OptionTest.dll” /INCREMENTAL：NO\nDebug 版本：\n/MDd /MLd 或 /MTd使用 Debug runtime library(调试版本的运行 时刻函数库)\n/Od 关闭优化开关\n/D “_DEBUG” 相当于 #define _DEBUG,打开编译调试代码 开关(主要针对assert函数)\n/ZI 创建 Edit and continue数据库，在调试 过程中如果修改了源代码不需重新编译\n/GZ 可以帮助捕获内存错误\n/Gm 打开最小化重链接开关，减少链接时间\nRelease 版本：\n/MD /ML 或 /MT使用发布版本的运行时刻函数库\n/O1 或 /O2优 化开关，使程序最小或最快\n/D “NDEBUG” 关闭条件编译调试代码开关(即不编译assert函数)\n/GF 合并重 复的字符串，并将字符串常量放到只读内存，防止被修改\n设置详解 MDd与MD 首先，Debug版本使用调试版本的运行时库（/MDd选项），Relase版本则使用的是发布版本的运行时库（vcrt.dll）。其区别主要在于运行时的性能影响。调试版本的运行时库包含了调试信息，并采用了一些保护机制以帮助发现错误，也因此，其性能不如发布版本。编译器提供的Runtime Library很稳定，不会造成Release版本错误，倒是由于Debug版本的Runtime Library加强了对错误的检测，如堆内存分配检查等，反而会报告错误，应当指出，如果Debug有错误，而Release版本正常，程序肯定是有Bug的，只是我们还没有发现。\nZI与Zi 其次，/ZI选项与/Zi选项。通过使用/ZI选项，可以在调试过程修改代码 而不需要重新编译。这是个调试的好帮手，可如果我们使用Release版本，这将变得不可行。\nOd与O2 /O2与/Od选项：Od是关闭编译器优化，普遍用于Debug版本。而O2选项是创建最快速代码，这当然是Release版本的不二选择。\nRTCx选项 /RTCx选项让编译器插入动态检测代码以帮助你检测程序中的错误。比如，它会将局部变量初始化为非零值。包括用0xCC初始化所有自动变量，0xCD初始化堆中分配的内存（即new的内存），使用0xDD填充被释放的内存（即delete的内存），0xFD初始化受保护的内存（debug版在动态分配内存的前后加入保护内存以防止越界访问）。这样做的好处是这些值都很大，一般不可能作为指针，考试，大提示作为数值也很少用到，而且这些值很容易辩认，因此有利于在Debug版本中发现Release版才会遇到的错误。另外，通过函数指针调用函数时，会通过检查栈指针验证函数调用的匹配性（防止原型不匹配）。使用/RTCx选项会造成Debug版本出错，而Release版本正常的现象，因为Release版中未初始化的变量是随机的，很可能使指针指向了有效但是错误的地址，从而掩盖了错误。这个编译选项只能在/Od选项下使用。\nGm，INCREMENTAL or NO 编译选项中的Gm和链接选项中的INCREMENTAL都只为一个目的，加快编译速度。我们经常遇上这样的问题，只修改了一个头文件，结果却造成所有动态库的重新编译。而这两个选项就是为了解决这样的问题。如果启用了/Gm开关，编译器在项目中的.idb文件中存储了源文件和类定义之间的依赖关系。之后的编译过程中使用.idb文件中的信息确定是否需要编译某个源文件，哪怕是此源文件已经包含了已修改的.h文件。\nINCREMENTAL开关默认是开启的。使用增量链接生 成的可执行文件或者动态链接库会大于非增量链接的程序，因为有代码和数据的填充。另外，增量链接的文件还包含跳转trunk以处理函数重定位到新地址。\nMSDN 上明确指出：为确保最终发布版本不包含填充或者trunk，请非增量链接程序。\n/GZ 选项：做以下这些事   初始化内存和变量。包括用 0xCC初始化所有自动变量，0xCD ( Cleared Data )初始化堆中分配的内存（即动态分配 的内存，例如 new），0xDD ( Dead Data )填充已被释放的堆内存（例 如 delete），0xFD( deFencde Data )初始化受保护的内存（debug版在动态分配内存的前后加入保护内存以防止越界访问），其中括号中的词是微软建议的助记词。这样做的好处是这些值都很大，作为指针是不可能的（而且32 位系统中指针很少是奇数值， 在有些系统中奇数的指针会产生运行时错误），作为数值也很少遇到，而且这些值也很容易辨认，因此这很有利于在Debug 版中发 现Release 版才会遇到的错误。要特别注意的是，很多人认为编译器会用0 来初始化变量，这是错误的（而且这样很不利于查找错误）。\n  通过函数指针调用函数时，会通过检查栈指针验证函数调用的匹配性。（防止原形不匹配）\n  函数返回前检查 栈指针，确认未被修改。（防止越界访问和原形不匹配，与第二项合在一起可大致模拟帧指针省略FPO ）\n  通常 /GZ 选 项会造成Debug 版出错而Release 版正常的现象，因为Release 版中未初始化的变量是随机的，这有可能使指针指向一 个有效地址而掩盖了非法访问。\n_DEBUG与NDEBUG 这是最重要的一个选项。这两个是编译器的预处理器定义，默认情况下_DEBUG用于Debug版本，而NDEBUG用于Release版本。 它们可以说是重要的无以复加。因为，assert系列的断言仅仅在_DEBUG下生效！ 下面是assert.h文件中摘出来的：\n1 2 3 4 5 6 7 8 9 10 11 12  #ifdef NDEBUG #define assert(_Expression) ((void)0) #else /* NDEBUG */#ifdef __cplusplus extern \"C\" { #endif /* __cplusplus */_CRTIMP void __cdecl _wassert(__in_z const wchar_t * _Message, __in_z const wchar_t *_File, __in unsigned _Line); #ifdef __cplusplus } #endif /* __cplusplus */ #define assert(_Expression) (void)( (!!(_Expression)) || (_wassert(_CRT_WIDE#_Expression), _CRT_WIDE(__FILE__), __LINE__), 0) ) #endif /* NDEBUG */  可以看出在未定义_DEBUG时，assert变成一条空语句不被执行。\n也就是说，我们现在所有发布的版本无法使 用断言机制进行程序调试。\n区别详解 Debug是调试版本，包括的程序信息更多 只有DEBUG版的程序才能设置断点、单步执行、使用 TRACE/ASSERT等调试输出语句。REALEASE不包含任何调试信息，所以体积小、运行速度快。\n  内存分配问题\n变量未初始化。下面的程序在debug中运行的很好。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  thing*search(thing*something) BOOL found; for(int i=0; i  whatever.GetSize();i++) { if(whatever[i]-field == something-field) { /* found it */ found=TRUE; break; } /* found it */ } if(found) return whatever[i]; else return NULL;   ``\n而在release中却不行，因为debug中会自动给变量初始化found=FALSE,而在release版中则不会。所以尽可能的给变量、类或结构体初始化。\n  数据溢出的问题\n char buffer[10]; int counter; lstrcpy(buffer,\"abcdefghik\");  在debug版中buffer的NULL覆盖了counter的高位，但是除非counter16M,什么问题也 没有。但是在release版 中，counter可能被放在寄存器中，这样NULL就覆盖了buffer下面的空间，可能就是函数的返回地址，这将导致 ACCESS ERROR。\n  内存分配方式\nDEBUG版和RELEASE版的是不同的。如果你在DEBUG版中申请ele为\n6*sizeof(DWORD)=24bytes,实际上分配给你的是32bytes（debug版以32bytes为单位分配），而在release版，分配给你的就是24bytes（release版以8bytes为单位），所以在debug版中如果你写ele[6],可能不会有 什么问题，而在release版中，就有ACCESS VIOLATE。\n  ASSERT和VERIFY ASSERT在Release版本中是不会被编译的。\n1 2 3 4 5 6  #ifdef _DEBUG #define ASSERT(x) if((x) == 0) report_assert_failure() #else #define ASSERT(x) #endif   假如你在这些语句中加了程序中必须要有的代码 c ASSERT(pNewObj = new CMyClass); pNewObj-MyFunction();  这种时候Release版本中的pNewObj不会分配到空间\n所以执行到下一个语句的时候程序会报该程序执行了非法操作的错误。这时可以用VERIFY：\n1 2 3 4 5  #ifdef _DEBUG  #define VERIFY(x) if((x)==0) report_assert_failure()  #else  #define VERIFY(x) (x)  #endif   这样的话，代码在release版中就可以执行了。\n参数问题 自定义消息的处理函数，必须定义如下：\nafx_msg LRESULT OnMyMessage(WPARAM, LPARAM);  返回值必须是HRESULT型，否则Debug会过，而Release出错\n内存分配 保证数据创建和清除的统一性：如果一个DLL提供一个能够创建数据的函数，那么这个DLL同时应该提供一个函数销毁这些数据。数据的创建和清除应该在同一 个层次上。\nDLL的灾难 人们将不同版本DLL混合造成的不一致性形象的称为 “动态连接库的地狱“(DLL Hell) 如果你的程序使用你自己的DLL时请注意：\n  不能将debug和release版的DLL混合在一起使用。debug都是debug版，release版都是release版。\n解决办法是将debug和release的程序分别放在主程序的debug和release目录下\n  千万不要以为静态连接库会解决问题，那只会使情况更糟糕。\n  ##RELEASE版中的调试##\n对RELEASE版本的软件也可以进行调试，请做如下改动：\n  在”Project Settings”中”C++/C”项目下设置”category”为”General”并且将”Debug Info”设置为”Program Database”。\n  在”Link”项目下选中”Generate Debug Info”检查框。\n  将ASSERT() 改为 VERIFY() 。找出定义在”#ifdef _DEBUG”中的代码，如果在RELEASE版本中需要这些代码请将他们移到定义外。查找TRACE(…)中代码，因为这些代码在RELEASE中 也不被编译。 请认真检查那些在RELEASE中需要的代码是否并没有被便宜。\n  变量的初始化所带来的不同，在不同的系统，或是在DEBUG/RELEASE版本间都存在这样的差异，所以请对变量进行初始化。\n  是否在编译时已经有了警告?请将警告级别设置为3或4,然后保证在编译时没有警告出现.\n  “Rebuild All”\n  如此做法会产生的一些限制：\n无法获得在MFC DLL中的变量的值。\n必须对该软件所使用的所有DLL工程都进行改动。\n优化选项改为Disbale（Debug） 将Project Settings”中 “C++/C”项目下优化选项改为Disbale（Debug）。编译器的优化可能导致许多意想不到的错误\n哪些情况下Release版会出错 Runtime Library 链接哪种运行时刻函数库通常只对程序的性能产生影响。调试版本 的 Runtime Library 包含了调试信息，并采用了一些保护机制以帮助发现错误，因此性能不如发布版本。编译器提供 的Runtime Library 通常很稳定，不会造成Release 版错误；倒是由 于Debug 的Runtime Library 加强了对错误的检测，如堆内存分配，有时会出现Debug 有错 但Release 正常的现象。应当指出的是，如果Debug 有错，即使Release 正常，程序肯定是有Bug 的，只不 过可能是Release 版的某次运行没有表现出来而已。\n优化 这是造成错误的主要原因，因为关闭优化时源程序基本上是直接翻译的，而打开优化后编译器会作出一系列假设。这类错误主要有以下几种：\n  帧指针 (Frame Pointer)省略（简称FPO ）：在函数调用过程中，所有调用信息（返回地址、参数）以及自动变量都是放在栈中的。若函数的声明与实现不同（参数、返回值、调用方式），就会产生错误，但Debug 方式下，栈的访问通过EBP 寄存器保存的地址实现，如果没有发生数组越界之类的错误（或是越界“不多”），函数通常能正常执行；Release方式下，优化会省略 EBP栈基址指针，这样通过一个全局 指针访问栈就会造成返回地址错误是程序崩溃。C++的强类型特性能检查出大多数这样的错误，但如果用了强制类型转换，就不行了。你可以 在 Release 版本中强制加入/Oy- 编译选项来关掉帧指针省略，以确定是否此类错误。此类错误通常有：\nMFC消息响应函数书写错误。正确的应为\nafx_msg LRESULT OnMessageOwn(WPARAM wparam, LPARAM lparam);\nON_MESSAGE 宏 包含强制类型转换。防止这种错误的方法之一是重\t定义 ON_MESSAGE宏，把下列代码加到 stdafx.h中 （在#include “afxwin.h”之后）,函数原形错误时编译会报错\n #undef ON_MESSAGE #define ON_MESSAGE(message, memberFxn) \\ { message, 0, 0, 0, AfxSig_lwl, \\ (AFX_PMSG)(AFX_PMSGW)(static_cast(\u0026memberFxn) },    volatile 型变量 ：volatile告诉编译器该变量可能被程序之外的未知方式修改（如系统、其他进程和线程）。优化程序为了使程序性能提高，常把一些变量放在寄存器中（类似于register 关键字），而其他进程只能对该变量所在的内存进行修改，而寄存器中的值没变。如果你的程序是多线程的，或者你发现某个变量的值与预期的不符而你确信已正确的设置了，则很可能遇到这样的问题。这种错误有时会表现为程序在最快优化出错而最小优化正常。把你认为可疑的变量加上volatile 试试。\n  变量优化：优化程序会根据变量的使用情况优化变量。例如，函数中有一个未被使用的变量，在 Debug 版中它有可能掩盖一个数组越界，而在Release 版中，这个变量很可能被优化调，此时数组越界会破坏栈中有用的数据。当然，实际的情况会比这复杂得多。与此有关的错误有： 非法访问，包括数组越界、指针错误 等。例如\n1 2 3 4 5 6 7 8 9 10 11 12  void fn(void) { int i; i = 1; int a[4]; { int j; j = 1; } a[-1] = 1; //当然错误不会这么明显，例如下标是变量  a[4] = 1; }   ``\n虽然在数组越界时已出了作用域，但其空间并未收回，因而i 和j 就会掩盖越界。而Release 版由于i、j并未其很大作用可能会被优化掉，从而使栈被破坏。\n  _DEBUG 与 NDEBUG 当定义了 _DEBUG时，assert()函数会被编译， 而 NDEBUG时不被编译。除此之外，VC++中还有一系列断言宏。这包括：\nANSI C 断 言 void assert(int expression ); C Runtime Lib 断 言 _ASSERT( booleanExpression ); _ASSERTE( booleanExpression ); MFC 断 言 ASSERT( booleanExpression ); VERIFY( booleanExpression ); ASSERT_VALID( pObject ); ASSERT_KINDOF( classname, pobject ); ATL 断 言 ATLASSERT( booleanExpression );  此外，TRACE() 宏的编译也受_DEBUG 控 制。\n所有这些断言都只在 Debug版中才被编译，而在Release 版中被忽略。唯一的例外 是VERIFY() 。\n事实上，这些宏都是调用了assert() 函数，只不过附加了一些与库有关的调试代码。如果你在这些宏中加入了任何程序代码，而不只是布尔表达式（例如赋值、能改变变量值的函数调用 等），那么Release 版都不会执行这些操作，从而造成错误。初学者很容 易犯这类错误，查找的方法也很简单，因为这些宏都已在上面列出，只要利用VC++ 的Find in Files 功能在工程所有文件中 找到用这些宏的地方再一一检查即可。另外，有些高手可能还会加入#ifdef _DEBUG 之类的条件编译，也要注意一下。\n顺便值得一提的是 VERIFY() 宏，这个宏允许你将程序代码放在布尔表达式里。这个宏通常用来检查Windows API 的返回值。有些人 可能为这个原因而滥用VERIFY() ，事实上这是危险的，因为VERIFY() 违反了断言的思想，不能使程序代码和调试代码完全分离， 最终可能会带来很多麻烦。因此，专家们建议尽量少用这个宏。\n",
  "wordCount" : "6700",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-23T16:57:04Z",
  "dateModified": "2017-06-23T16:57:04Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/visual-studio%E4%B8%ADdebug%E5%92%8Crelease%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Visual Studio中debug和release版本的区别
    </h1>
    <div class="post-meta">June 23, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="本质区别">本质区别<a hidden class="anchor" aria-hidden="true" href="#本质区别">#</a></h1>
<p>Debug 和 Release 并没有本质的区别，他们只是VC预定义提供的两组编译选项的集合，编译器只是按照预定的选项行动。如果我们愿意，我们完全可以把Debug和Release的行为完全颠倒过来。当然也可以提供其他的模式，例如自己定义一组编译选项，然后命名为MY_ABC等。习惯上，我们仍然更愿意使用VC已经定义好的名称。</p>
<p>Debug版本包括调试信息，所以要比Release版本大很多（可能大数百K至数M）。至于是否需要DLL支持，主要看你采用的编译选项。如果是基于ATL的，则Debug和Release版本对DLL的要求差不多。如果采用的编译选项为使用MFC动态库，则需要MFC42D.DLL等库支持，而Release版本需要MFC42.DLL支持。Release不对源代码进行调试，不考虑MFC的诊断宏，使用的是MFC Release库，编译时对应用程序的速度进行优化，而Debug则正好相反，它允许对源代码进行调试，可以定义和使用MFC的 诊断宏，采用MFC Debug库，对速度没有优化。</p>
<p>既然Debug和Release仅仅是编译选项的不同，那么为什么要区分Debug和Release版本呢？</p>
<p>Debug和Release，在我看来主要是针对其面向的目标不同的而进行区分的。Debug通常称为调试版本，通过一系列编译选项的配合，编译的结果通常包含调试信息，而且不做任何优化，以为开发人员提供强大的应用程序调试能力。而Release通常称为发布版本，是为用户使用的，一般客户不允许在发布版本上进行调试。所以不保存调试信息，同时，它往往进行了各种优化，以期达到代码最小和速度最优。为用户的使用提供便利。</p>
<p>下面仅就默认的Debug和Release版本的选项进行 比较，详细的编译选项可以看MSDN的说明。</p>
<p>我们将默认的Debug和Release的选项设置进行比较，过滤掉相同设置，主要的不同如下：</p>
<p>编译选项：/Od /D “_DEBUG” /Gm /RTC1 /MDd /Fo”Debug““” /ZI</p>
<p>链接选项：/OUT：”D：“MyProject“logging“Debug“OptionTest.dll” /INCREMENTAL</p>
<p>Release设置：</p>
<p>编译选项：/O2 /GL /D “NDEBUG” /FD /MD /Fo”Release““” /Zi</p>
<p>链 接选项：/OUT：”D：“MyProject“logging“Release“OptionTest.dll” /INCREMENTAL：NO</p>
<p>Debug 版本：</p>
<p>/MDd /MLd 或 /MTd使用 Debug runtime library(调试版本的运行 时刻函数库)</p>
<p>/Od 关闭优化开关</p>
<p>/D “_DEBUG” 相当于 #define _DEBUG,打开编译调试代码 开关(主要针对assert函数)</p>
<p>/ZI 创建 Edit and continue数据库，在调试 过程中如果修改了源代码不需重新编译</p>
<p>/GZ 可以帮助捕获内存错误</p>
<p>/Gm 打开最小化重链接开关，减少链接时间</p>
<p>Release 版本：</p>
<p>/MD /ML 或 /MT使用发布版本的运行时刻函数库</p>
<p>/O1 或 /O2优 化开关，使程序最小或最快</p>
<p>/D “NDEBUG” 关闭条件编译调试代码开关(即不编译assert函数)</p>
<p>/GF 合并重 复的字符串，并将字符串常量放到只读内存，防止被修改</p>
<h1 id="设置详解">设置详解<a hidden class="anchor" aria-hidden="true" href="#设置详解">#</a></h1>
<h2 id="mdd与md">MDd与MD<a hidden class="anchor" aria-hidden="true" href="#mdd与md">#</a></h2>
<p>首先，Debug版本使用调试版本的运行时库（/MDd选项），Relase版本则使用的是发布版本的运行时库（vcrt.dll）。其区别主要在于运行时的性能影响。调试版本的运行时库包含了调试信息，并采用了一些保护机制以帮助发现错误，也因此，其性能不如发布版本。编译器提供的Runtime Library很稳定，不会造成Release版本错误，倒是由于Debug版本的Runtime Library加强了对错误的检测，如堆内存分配检查等，反而会报告错误，应当指出，如果Debug有错误，而Release版本正常，程序肯定是有Bug的，只是我们还没有发现。</p>
<h2 id="zi与zi">ZI与Zi<a hidden class="anchor" aria-hidden="true" href="#zi与zi">#</a></h2>
<p>其次，/ZI选项与/Zi选项。通过使用/ZI选项，可以在调试过程修改代码 而不需要重新编译。这是个调试的好帮手，可如果我们使用Release版本，这将变得不可行。</p>
<h2 id="od与o2">Od与O2<a hidden class="anchor" aria-hidden="true" href="#od与o2">#</a></h2>
<p>/O2与/Od选项：Od是关闭编译器优化，普遍用于Debug版本。而O2选项是创建最快速代码，这当然是Release版本的不二选择。</p>
<h2 id="rtcx选项">RTCx选项<a hidden class="anchor" aria-hidden="true" href="#rtcx选项">#</a></h2>
<p>/RTCx选项让编译器插入动态检测代码以帮助你检测程序中的错误。比如，它会将局部变量初始化为非零值。包括用0xCC初始化所有自动变量，0xCD初始化堆中分配的内存（即new的内存），使用0xDD填充被释放的内存（即delete的内存），0xFD初始化受保护的内存（debug版在动态分配内存的前后加入保护内存以防止越界访问）。这样做的好处是这些值都很大，一般不可能作为指针，考试，大提示作为数值也很少用到，而且这些值很容易辩认，因此有利于在Debug版本中发现Release版才会遇到的错误。另外，通过函数指针调用函数时，会通过检查栈指针验证函数调用的匹配性（防止原型不匹配）。使用/RTCx选项会造成Debug版本出错，而Release版本正常的现象，因为Release版中未初始化的变量是随机的，很可能使指针指向了有效但是错误的地址，从而掩盖了错误。这个编译选项只能在/Od选项下使用。</p>
<h2 id="gmincremental-or-no">Gm，INCREMENTAL or NO<a hidden class="anchor" aria-hidden="true" href="#gmincremental-or-no">#</a></h2>
<p>编译选项中的Gm和链接选项中的INCREMENTAL都只为一个目的，加快编译速度。我们经常遇上这样的问题，只修改了一个头文件，结果却造成所有动态库的重新编译。而这两个选项就是为了解决这样的问题。如果启用了/Gm开关，编译器在项目中的.idb文件中存储了源文件和类定义之间的依赖关系。之后的编译过程中使用.idb文件中的信息确定是否需要编译某个源文件，哪怕是此源文件已经包含了已修改的.h文件。</p>
<p>INCREMENTAL开关默认是开启的。使用增量链接生 成的可执行文件或者动态链接库会大于非增量链接的程序，因为有代码和数据的填充。另外，增量链接的文件还包含跳转trunk以处理函数重定位到新地址。</p>
<p>MSDN 上明确指出：为确保最终发布版本不包含填充或者trunk，请非增量链接程序。</p>
<h2 id="gz-选项做以下这些事">/GZ 选项：做以下这些事<a hidden class="anchor" aria-hidden="true" href="#gz-选项做以下这些事">#</a></h2>
<ol>
<li>
<p>初始化内存和变量。包括用 0xCC初始化所有自动变量，0xCD ( Cleared Data )初始化堆中分配的内存（即动态分配 的内存，例如 new），0xDD ( Dead Data )填充已被释放的堆内存（例 如 delete），0xFD( deFencde Data )初始化受保护的内存（debug版在动态分配内存的前后加入保护内存以防止越界访问），其中括号中的词是微软建议的助记词。这样做的好处是这些值都很大，作为指针是不可能的（而且32 位系统中指针很少是奇数值， 在有些系统中奇数的指针会产生运行时错误），作为数值也很少遇到，而且这些值也很容易辨认，因此这很有利于在Debug 版中发 现Release 版才会遇到的错误。要特别注意的是，很多人认为编译器会用0 来初始化变量，这是错误的（而且这样很不利于查找错误）。</p>
</li>
<li>
<p>通过函数指针调用函数时，会通过检查栈指针验证函数调用的匹配性。（防止原形不匹配）</p>
</li>
<li>
<p>函数返回前检查 栈指针，确认未被修改。（防止越界访问和原形不匹配，与第二项合在一起可大致模拟帧指针省略FPO ）</p>
</li>
</ol>
<p>通常 /GZ 选 项会造成Debug 版出错而Release 版正常的现象，因为Release 版中未初始化的变量是随机的，这有可能使指针指向一 个有效地址而掩盖了非法访问。</p>
<h2 id="_debug与ndebug">_DEBUG与NDEBUG<a hidden class="anchor" aria-hidden="true" href="#_debug与ndebug">#</a></h2>
<p>这是最重要的一个选项。这两个是编译器的预处理器定义，默认情况下_DEBUG用于Debug版本，而NDEBUG用于Release版本。 它们可以说是重要的无以复加。因为，assert系列的断言仅仅在_DEBUG下生效！
下面是assert.h文件中摘出来的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#ifdef NDEBUG   
</span><span class="cp">#define assert(_Expression) ((void)0)   
</span><span class="cp">#else </span><span class="cm">/* NDEBUG */</span><span class="cp">   
</span><span class="cp">#ifdef __cplusplus   
</span><span class="cp"></span><span class="k">extern</span> <span class="s">&#34;C&#34;</span> <span class="p">{</span>   
<span class="cp">#endif </span><span class="cm">/* __cplusplus */</span><span class="cp">   
</span><span class="cp"></span><span class="n">_CRTIMP</span> <span class="kt">void</span> <span class="kr">__cdecl</span> <span class="n">_wassert</span><span class="p">(</span><span class="n">__in_z</span> <span class="k">const</span> <span class="n">wchar_t</span> <span class="o">*</span> <span class="n">_Message</span><span class="p">,</span> <span class="n">__in_z</span> <span class="k">const</span> <span class="n">wchar_t</span> <span class="o">*</span><span class="n">_File</span><span class="p">,</span> <span class="n">__in</span> <span class="kt">unsigned</span> <span class="n">_Line</span><span class="p">);</span>  
<span class="cp">#ifdef __cplusplus   
</span><span class="cp"></span><span class="p">}</span>   
 <span class="err">#</span><span class="n">endif</span> <span class="cm">/* __cplusplus */</span>   
 <span class="err">#</span><span class="n">define</span> <span class="n">assert</span><span class="p">(</span><span class="n">_Expression</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">)(</span> <span class="p">(</span><span class="o">!!</span><span class="p">(</span><span class="n">_Expression</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="n">_wassert</span><span class="p">(</span><span class="n">_CRT_WIDE</span><span class="err">#</span><span class="n">_Expression</span><span class="p">),</span> <span class="n">_CRT_WIDE</span><span class="p">(</span><span class="n">__FILE__</span><span class="p">),</span> <span class="n">__LINE__</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="p">)</span>  
<span class="cp">#endif </span><span class="cm">/* NDEBUG */</span><span class="cp">   
</span></code></pre></td></tr></table>
</div>
</div><p>可以看出在未定义_DEBUG时，assert变成一条空语句不被执行。</p>
<p>也就是说，我们现在所有发布的版本无法使 用断言机制进行程序调试。</p>
<h1 id="区别详解">区别详解<a hidden class="anchor" aria-hidden="true" href="#区别详解">#</a></h1>
<h2 id="debug是调试版本包括的程序信息更多">Debug是调试版本，包括的程序信息更多<a hidden class="anchor" aria-hidden="true" href="#debug是调试版本包括的程序信息更多">#</a></h2>
<p>只有DEBUG版的程序才能设置断点、单步执行、使用 TRACE/ASSERT等调试输出语句。REALEASE不包含任何调试信息，所以体积小、运行速度快。</p>
<ol>
<li>
<p>内存分配问题</p>
<p>变量未初始化。下面的程序在debug中运行的很好。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">thing</span><span class="o">*</span><span class="nf">search</span><span class="p">(</span><span class="n">thing</span><span class="o">*</span><span class="n">something</span><span class="p">)</span>     
<span class="n">BOOL</span> <span class="n">found</span><span class="p">;</span>     
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">whatever</span><span class="p">.</span><span class="n">GetSize</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>     
<span class="p">{</span>     
<span class="k">if</span><span class="p">(</span><span class="n">whatever</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">field</span> <span class="o">==</span> <span class="n">something</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">)</span>     
<span class="p">{</span>    <span class="cm">/*    found    it    */</span>     
<span class="n">found</span><span class="o">=</span><span class="n">TRUE</span><span class="p">;</span>     
<span class="k">break</span><span class="p">;</span>     
<span class="p">}</span>    <span class="cm">/*    found    it    */</span>     
<span class="p">}</span>     
<span class="k">if</span><span class="p">(</span><span class="n">found</span><span class="p">)</span>     
<span class="k">return</span>    <span class="n">whatever</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>     
<span class="k">else</span>     
<span class="k">return</span>    <span class="nb">NULL</span><span class="p">;</span>     
</code></pre></td></tr></table>
</div>
</div><p>``</p>
<p>而在release中却不行，因为debug中会自动给变量初始化found=FALSE,而在release版中则不会。所以尽可能的给变量、类或结构体初始化。</p>
</li>
<li>
<p>数据溢出的问题</p>
<pre><code> char    buffer[10];     
 int    counter;     
 lstrcpy(buffer,&quot;abcdefghik&quot;);
</code></pre>
<p>在debug版中buffer的NULL覆盖了counter的高位，但是除非counter&gt;16M,什么问题也 没有。但是在release版 中，counter可能被放在寄存器中，这样NULL就覆盖了buffer下面的空间，可能就是函数的返回地址，这将导致 ACCESS ERROR。</p>
</li>
<li>
<p>内存分配方式</p>
<p>DEBUG版和RELEASE版的是不同的。如果你在DEBUG版中申请ele为</p>
<p>6*sizeof(DWORD)=24bytes,实际上分配给你的是32bytes（debug版以32bytes为单位分配），而在release版，分配给你的就是24bytes（release版以8bytes为单位），所以在debug版中如果你写ele[6],可能不会有 什么问题，而在release版中，就有ACCESS VIOLATE。</p>
</li>
</ol>
<h2 id="assert和verify">ASSERT和VERIFY<a hidden class="anchor" aria-hidden="true" href="#assert和verify">#</a></h2>
<p>ASSERT在Release版本中是不会被编译的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">
<span class="cp">#ifdef    _DEBUG   
</span><span class="cp">#define    ASSERT(x)    if((x) == 0)    report_assert_failure()   
</span><span class="cp">#else   
</span><span class="cp">#define    ASSERT(x)   
</span><span class="cp">#endif   
</span></code></pre></td></tr></table>
</div>
</div><p>假如你在这些语句中加了程序中必须要有的代码
<code>c ASSERT(pNewObj    =    new    CMyClass);      pNewObj-&gt;MyFunction();     </code>
这种时候Release版本中的pNewObj不会分配到空间</p>
<p>所以执行到下一个语句的时候程序会报该程序执行了非法操作的错误。这时可以用VERIFY：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">     <span class="cp">#ifdef    _DEBUG   
</span><span class="cp"></span>     <span class="cp">#define    VERIFY(x)    if((x)==0)  report_assert_failure()   
</span><span class="cp"></span>     <span class="cp">#else   
</span><span class="cp"></span>     <span class="cp">#define    VERIFY(x)    (x)   
</span><span class="cp"></span>     <span class="cp">#endif 
</span></code></pre></td></tr></table>
</div>
</div><p>这样的话，代码在release版中就可以执行了。</p>
<h2 id="参数问题">参数问题<a hidden class="anchor" aria-hidden="true" href="#参数问题">#</a></h2>
<p>自定义消息的处理函数，必须定义如下：</p>
<pre><code>afx_msg    LRESULT    OnMyMessage(WPARAM,    LPARAM);
</code></pre>
<p>返回值必须是HRESULT型，否则Debug会过，而Release出错</p>
<h2 id="内存分配">内存分配<a hidden class="anchor" aria-hidden="true" href="#内存分配">#</a></h2>
<p>保证数据创建和清除的统一性：如果一个DLL提供一个能够创建数据的函数，那么这个DLL同时应该提供一个函数销毁这些数据。数据的创建和清除应该在同一 个层次上。</p>
<h2 id="dll的灾难">DLL的灾难<a hidden class="anchor" aria-hidden="true" href="#dll的灾难">#</a></h2>
<p>人们将不同版本DLL混合造成的不一致性形象的称为 “动态连接库的地狱“(DLL Hell)
如果你的程序使用你自己的DLL时请注意：</p>
<ol>
<li>
<p>不能将debug和release版的DLL混合在一起使用。debug都是debug版，release版都是release版。</p>
<p>解决办法是将debug和release的程序分别放在主程序的debug和release目录下</p>
</li>
<li>
<p>千万不要以为静态连接库会解决问题，那只会使情况更糟糕。</p>
</li>
</ol>
<p>##RELEASE版中的调试##</p>
<p>对RELEASE版本的软件也可以进行调试，请做如下改动：</p>
<ol>
<li>
<p>在”Project Settings”中”C++/C”项目下设置”category”为”General”并且将”Debug Info”设置为”Program Database”。</p>
</li>
<li>
<p>在”Link”项目下选中”Generate Debug Info”检查框。</p>
</li>
<li>
<p>将ASSERT() 改为 VERIFY() 。找出定义在”#ifdef _DEBUG”中的代码，如果在RELEASE版本中需要这些代码请将他们移到定义外。查找TRACE(…)中代码，因为这些代码在RELEASE中 也不被编译。 请认真检查那些在RELEASE中需要的代码是否并没有被便宜。</p>
</li>
<li>
<p>变量的初始化所带来的不同，在不同的系统，或是在DEBUG/RELEASE版本间都存在这样的差异，所以请对变量进行初始化。</p>
</li>
<li>
<p>是否在编译时已经有了警告?请将警告级别设置为3或4,然后保证在编译时没有警告出现.</p>
</li>
<li>
<p>“Rebuild All”</p>
</li>
</ol>
<p>如此做法会产生的一些限制：</p>
<p>无法获得在MFC DLL中的变量的值。</p>
<p>必须对该软件所使用的所有DLL工程都进行改动。</p>
<h2 id="优化选项改为disbaledebug">优化选项改为Disbale（Debug）<a hidden class="anchor" aria-hidden="true" href="#优化选项改为disbaledebug">#</a></h2>
<p>将Project Settings”中 “C++/C”项目下优化选项改为Disbale（Debug）。编译器的优化可能导致许多意想不到的错误</p>
<h1 id="哪些情况下release版会出错">哪些情况下Release版会出错<a hidden class="anchor" aria-hidden="true" href="#哪些情况下release版会出错">#</a></h1>
<h2 id="runtime-library">Runtime Library<a hidden class="anchor" aria-hidden="true" href="#runtime-library">#</a></h2>
<p>链接哪种运行时刻函数库通常只对程序的性能产生影响。调试版本 的 Runtime Library 包含了调试信息，并采用了一些保护机制以帮助发现错误，因此性能不如发布版本。编译器提供 的Runtime Library 通常很稳定，不会造成Release 版错误；倒是由 于Debug 的Runtime Library 加强了对错误的检测，如堆内存分配，有时会出现Debug 有错 但Release 正常的现象。应当指出的是，如果Debug 有错，即使Release 正常，程序肯定是有Bug 的，只不 过可能是Release 版的某次运行没有表现出来而已。</p>
<h2 id="优化">优化<a hidden class="anchor" aria-hidden="true" href="#优化">#</a></h2>
<p>这是造成错误的主要原因，因为关闭优化时源程序基本上是直接翻译的，而打开优化后编译器会作出一系列假设。这类错误主要有以下几种：</p>
<ol>
<li>
<p>帧指针 (Frame Pointer)省略（简称FPO ）：在函数调用过程中，所有调用信息（返回地址、参数）以及自动变量都是放在栈中的。若函数的声明与实现不同（参数、返回值、调用方式），就会产生错误，但Debug 方式下，栈的访问通过EBP 寄存器保存的地址实现，如果没有发生数组越界之类的错误（或是越界“不多”），函数通常能正常执行；Release方式下，优化会省略 EBP栈基址指针，这样通过一个全局 指针访问栈就会造成返回地址错误是程序崩溃。C++的强类型特性能检查出大多数这样的错误，但如果用了强制类型转换，就不行了。你可以 在 Release 版本中强制加入/Oy- 编译选项来关掉帧指针省略，以确定是否此类错误。此类错误通常有：</p>
<p>MFC消息响应函数书写错误。正确的应为</p>
<p>afx_msg LRESULT OnMessageOwn(WPARAM wparam, LPARAM lparam);</p>
<p>ON_MESSAGE 宏 包含强制类型转换。防止这种错误的方法之一是重	定义 ON_MESSAGE宏，把下列代码加到 stdafx.h中 （在#include “afxwin.h”之后）,函数原形错误时编译会报错</p>
<pre><code> #undef ON_MESSAGE   
 #define ON_MESSAGE(message, memberFxn) \   
 { message, 0, 0, 0, AfxSig_lwl, \   
 (AFX_PMSG)(AFX_PMSGW)(static_cast&lt; LRESULT 	(AFX_MSG_CALL \  
 CWnd::*)(WPARAM, LPARAM) &gt; (&amp;memberFxn) },   
</code></pre>
</li>
<li>
<p>volatile 型变量 ：volatile告诉编译器该变量可能被程序之外的未知方式修改（如系统、其他进程和线程）。优化程序为了使程序性能提高，常把一些变量放在寄存器中（类似于register 关键字），而其他进程只能对该变量所在的内存进行修改，而寄存器中的值没变。如果你的程序是多线程的，或者你发现某个变量的值与预期的不符而你确信已正确的设置了，则很可能遇到这样的问题。这种错误有时会表现为程序在最快优化出错而最小优化正常。把你认为可疑的变量加上volatile 试试。</p>
</li>
<li>
<p>变量优化：优化程序会根据变量的使用情况优化变量。例如，函数中有一个未被使用的变量，在 Debug 版中它有可能掩盖一个数组越界，而在Release 版中，这个变量很可能被优化调，此时数组越界会破坏栈中有用的数据。当然，实际的情况会比这复杂得多。与此有关的错误有：
非法访问，包括数组越界、指针错误 等。例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"> <span class="kt">void</span> <span class="nf">fn</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>   
 <span class="p">{</span>   
 <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>   
 <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   
 <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>   
 <span class="p">{</span>   
 <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>   
 <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   
 <span class="p">}</span>   
 <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//当然错误不会这么明显，例如下标是变量  
</span><span class="c1"></span> <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   
 <span class="p">}</span>   
</code></pre></td></tr></table>
</div>
</div><p>``</p>
<p>虽然在数组越界时已出了作用域，但其空间并未收回，因而i 和j 就会掩盖越界。而Release 版由于i、j并未其很大作用可能会被优化掉，从而使栈被破坏。</p>
</li>
</ol>
<h2 id="_debug-与-ndebug">_DEBUG 与 NDEBUG<a hidden class="anchor" aria-hidden="true" href="#_debug-与-ndebug">#</a></h2>
<p>当定义了 _DEBUG时，assert()函数会被编译， 而 NDEBUG时不被编译。除此之外，VC++中还有一系列断言宏。这包括：</p>
<pre><code>ANSI C 断 言 void assert(int expression );
C Runtime Lib 断 言 _ASSERT( booleanExpression );
_ASSERTE( booleanExpression );
MFC 断 言 ASSERT( booleanExpression );
VERIFY( booleanExpression );
ASSERT_VALID( pObject );
ASSERT_KINDOF( classname, pobject );
ATL 断 言 ATLASSERT( booleanExpression );
</code></pre>
<p>此外，TRACE() 宏的编译也受_DEBUG 控 制。</p>
<p>所有这些断言都只在 Debug版中才被编译，而在Release 版中被忽略。唯一的例外 是VERIFY() 。</p>
<p>事实上，这些宏都是调用了assert() 函数，只不过附加了一些与库有关的调试代码。如果你在这些宏中加入了任何程序代码，而不只是布尔表达式（例如赋值、能改变变量值的函数调用 等），那么Release 版都不会执行这些操作，从而造成错误。初学者很容 易犯这类错误，查找的方法也很简单，因为这些宏都已在上面列出，只要利用VC++ 的Find in Files 功能在工程所有文件中 找到用这些宏的地方再一一检查即可。另外，有些高手可能还会加入#ifdef _DEBUG 之类的条件编译，也要注意一下。</p>
<p>顺便值得一提的是 VERIFY() 宏，这个宏允许你将程序代码放在布尔表达式里。这个宏通常用来检查Windows API 的返回值。有些人 可能为这个原因而滥用VERIFY() ，事实上这是危险的，因为VERIFY() 违反了断言的思想，不能使程序代码和调试代码完全分离， 最终可能会带来很多麻烦。因此，专家们建议尽量少用这个宏。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/%E7%BC%96%E8%AF%91/">编译</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
