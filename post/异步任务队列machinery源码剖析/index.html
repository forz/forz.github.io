<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>异步任务队列:machinery源码剖析 | Forz Blog</title>
<meta name="keywords" content="machinery" />
<meta name="description" content="导语 异步任务，是每一位开发者都遇到过的技术名词，在任何一个稍微复杂的后台系统中，异步任务总是无法避免的，而任务队列由于其松耦合、易扩展的特性">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97machinery%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="异步任务队列:machinery源码剖析" />
<meta property="og:description" content="导语 异步任务，是每一位开发者都遇到过的技术名词，在任何一个稍微复杂的后台系统中，异步任务总是无法避免的，而任务队列由于其松耦合、易扩展的特性" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97machinery%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-10-17T18:22:26&#43;00:00" />
<meta property="article:modified_time" content="2019-10-17T18:22:26&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="异步任务队列:machinery源码剖析"/>
<meta name="twitter:description" content="导语 异步任务，是每一位开发者都遇到过的技术名词，在任何一个稍微复杂的后台系统中，异步任务总是无法避免的，而任务队列由于其松耦合、易扩展的特性"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "异步任务队列:machinery源码剖析",
      "item": "/post/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97machinery%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "异步任务队列:machinery源码剖析",
  "name": "异步任务队列:machinery源码剖析",
  "description": "导语 异步任务，是每一位开发者都遇到过的技术名词，在任何一个稍微复杂的后台系统中，异步任务总是无法避免的，而任务队列由于其松耦合、易扩展的特性",
  "keywords": [
    "machinery"
  ],
  "articleBody": "导语 异步任务，是每一位开发者都遇到过的技术名词，在任何一个稍微复杂的后台系统中，异步任务总是无法避免的，而任务队列由于其松耦合、易扩展的特性，成为了实现异步任务的可靠保证。\n背景 当用户的一次请求事件发生，可能是某种数据的重复数查询，亦或是某批人群的覆盖率统计，展现到用户的是几行数字，但在透视到后端逻辑中，简单的这可能是一次mysql的联表查询或者elasticsearch的聚合，但更多情况下，是附带了一系列复杂的数据交互或者耗时的逻辑计算。当后端这种发生多次数据交互任务的情况一旦存在，为了实现每一次任务的可靠执行以及前端响应速度，任务队列的存在意义就凸显了。\n场景与功能 任务队列有着广泛的适应场景：\n 大批量的计算任务。如大量数据插入，通过拆分并分批插入任务队列，从而实现串行链式任务处理或者实现分组并行任务处理，提高系统鲁棒性，提高系统并发度； 数据预处理。定期的从后端存储将数据同步到到缓存系统，从而在查询请求发生时，直接去缓存系统中查询，提高查询请求的响应速度； 错误重试功能。为了提高系统的可用性，当函数处理出现错误时，我们希望可以给予其重试的机会，增强系统的可用性。  适用于任务队列的场景还有很多，同样，不同语言也有着自己著名的任务队列系统，众所周知的如python下的celery，PHP中laraval框架的Queues，都是使用度十分广泛的任务队列系统。\n我们项目的技术栈为golang，因此，在我们go为基础的微服务框架中，需要存在一个类型于celery或者laraval中的任务队列系统，在经过了一系列筛选后，我们采用了machinery作为我们的任务队列系统。machinery，一个第三方开源的基于分布式消息分发的异步任务队列，有着以下这些特性：\n 任务重试机制 延迟任务支持 任务回调机制 任务结果记录 支持Workflow模式：Chain，Group，Chord 多Brokers支持：Redis, AMQP, AWS SQS 多Backends支持：Redis, Memcache, AMQP, MongoDB  当前machinery在v1 stable版本，可以通过go get github.com/RichardKnop/machinery/v1获取。\n架构设计 任务队列，简而言之就是一个放大的生产者消费者模型，用户请求会生成任务，任务生产者不断的向队列中插入任务，同时，队列的处理器程序充当消费者不断的消费任务。基于这种框架设计思想，我们来看下machinery的简单设计结构图例：\n其中：\n Server：业务模块，生成具体任务，可根据业务逻辑中，按交互进行拆分； Broker：存储具体序列化后的任务，machinery中目前支持到Redis, AMQP,和SQS； Worker：工作进程，负责消费者功能，处理具体的任务； Backend：后端存储，用于存储任务执行状态的数据；  在本篇文章中，我们将对上述几个模块进行详细讲解。\nBroker machinery的broker支持多种存储介质：Redis，AMQP和SQS，本篇文章中，我们将以redis来详细介绍，其他类型的存储介质，在实现细节上由于介质的API支持不一可能略有不同，但machinery具体暴露接口类似，有兴趣的读者可以详细再阅读相关源码。\nmachinery的Broker实现了以下这几种接口，我们将重点介绍起着关键作用的接口：\n1 2 3 4 5 6 7  GetConfig() *config.Config SetRegisteredTaskNames(names []string) IsTaskRegistered(name string) bool StartConsuming(consumerTag string, concurrency int, p TaskProcessor) (bool, error) StopConsuming() Publish(task *tasks.Signature) error GetPendingTasks(queue string) ([]*tasks.Signature, error)   启动和停止 当我们使用machinery时，在启动服务之后，StartConsuming()函数将以阻塞轮询的方式去Broker中获取任务并消费处理。而当服务停止之后，StopConsuming()函数将会等待一系列go程结束，以实现gracefully stop。\n详细来看StartConsumin()函数，具体源码如下（不相关的代码细节已经省略）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  func (b *RedisBroker) StartConsuming(consumerTag string, concurrency int, taskProcessor TaskProcessor) (bool, error) { ... // 获取任务go程 \tgo func() { ... for { select { case b.stopReceivingChan: return case timer.C: if concurrencyAvailable() { task, err := b.nextTask(b.cnf.DefaultQueue) if err != nil { timer.Reset(timerDuration) continue } deliveries  task } //并发控制逻辑 \tif concurrencyAvailable() { timer.Reset(0)//设置timer为0，立即继续消费任务 \t} else { timer.Reset(timerDuration)//重置timer，等待duration后再尝试消费 \t} } } }() // 获取延时任务go程 \tgo func() { ... for { select { case b.stopDelayedChan: return default: task, err := b.nextDelayedTask(redisDelayedTasksKey) if err != nil { continue } signature := new(tasks.Signature) decoder := json.NewDecoder(bytes.NewReader(task)) decoder.UseNumber() if err := decoder.Decode(signature); err != nil { log.ERROR.Print(NewErrCouldNotUnmarshaTaskSignature(task, err)) } if err := b.Publish(signature); err != nil { log.ERROR.Print(err) } } } }() //执行任务消费 \tif err := b.consume(deliveries, pool, concurrency, taskProcessor); err != nil { return b.retry, err } ... }   其中，\n参数consumerTag在AMQP作为Broker时有意义；\n参数concurrency用来实现任务并发调度的控制。\n任务获取 在StartComsuming()中，分别启动了两个go程来并行处理任务，因为针对延时任务和普通任务，machinery将任务存放于两个不同的rediskey中。\n 对于普通任务，使用nextTask()函数用来从broker中获取任务，在redis作为broker时，machinery使用了LIST类型来存储任务，而nextTask()中使用了BLPOP来阻塞式的读取任务. 对于延时任务，使用nextDelayTask()函数从redis中的ZSET中，根据score来优先获取最近的任务（score为ETA的对应的unixnano值）。  具体来看nextTask()函数和nextDelayTask()函数，如下列出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // BLPOP出LIST中的数据 func (b *RedisBroker) nextTask(queue string) (result []byte, err error) { conn := b.open() defer conn.Close() items, err := redis.ByteSlices(conn.Do(\"BLPOP\", queue, 1)) if err != nil { return []byte{}, err } if len(items) != 2 { return []byte{}, redis.ErrNil } result = items[1] return result, nil }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  // 结合WATCH，从ZSET中获取score最小的 func (b *RedisBroker) nextDelayedTask(key string) (result []byte, err error) { ... for { time.Sleep(time.Duration(pollPeriod) * time.Millisecond) if _, err = conn.Do(\"WATCH\", key); err != nil { return } now := time.Now().UTC().UnixNano() items, err = redis.ByteSlices(conn.Do( \"ZRANGEBYSCORE\", key, 0, now, \"LIMIT\", 0, 1, )) if err != nil { return } if len(items) != 1 { err = redis.ErrNil return } conn.Send(\"MULTI\") conn.Send(\"ZREM\", key, items[0]) reply, err = conn.Do(\"EXEC\") if err != nil { return } if reply != nil { result = items[0] break } } return }   特别需要注意的是，由于云服务的盛行，当下的云服务基本上都涵盖了redis服务，且提供了主备方案和集群方案等，但是不论时云服务或者时公司内部的redis服务，对BLPOP的支持可能会受限，这时候我们需要更改nextTask()函数中的BLPOP为LPOP来适应:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /* * modified at 20180717 * use LPOP instead of BLPOP, cause L5 redis does not support BLPOP **/ // nextTask pops next available task from the default queue func (b *Broker) nextTask(queue string) (result []byte, err error) { conn := b.open() defer conn.Close() item, err := redis.Bytes(conn.Do(\"LPOP\", queue)) if err != nil { return []byte{}, err } result = item return result, nil }   任务查看 在redis作为Broker时，machinery还提供了一个额外的接口实现（其他接口Broker存储介质未对该接口进行实现）GetPendingTasks()。顾名思义，GetPendingTasks()可以用来查看当前任务队列中处理pending状态，在等待被处理的任务的详细信息。\nGetPendingTasks()函数，更多的可以理解为，是作者提供的“接口糖”，方便离线的对任务队列中的任务进行查看，当然，machinery中使用的几种第三方队列作为Broker，基本上都是支持这类数据的单独查看的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func (b *RedisBroker) GetPendingTasks(queue string) ([]*tasks.Signature, error) { ... dataBytes, err := conn.Do(\"LRANGE\", queue, 0, 10) if err != nil { return nil, err } results, err := redis.ByteSlices(dataBytes, err) if err != nil { return nil, err } taskSignatures := make([]*tasks.Signature, len(results)) for i, result := range results { signature := new(tasks.Signature) decoder := json.NewDecoder(bytes.NewReader(result)) decoder.UseNumber() if err := decoder.Decode(signature); err != nil { return nil, err } taskSignatures[i] = signature } return taskSignatures, nil }   任务发布 Publish()接口是实现任务发布的函数，将在后续篇幅在对任务做介绍时再单独详细介绍。\nBackend Backend，同样是任务队列不可或缺的一部分，其作用主要是用来存储任务的执行结果的，machinery中支持Redis, Memcache, AMQP, MongoDB四种类型的存储介质来实现Backend。\nmachinery的Backend，根据其自身的功能特性，实现了以下这几种接口，与Broker类似，我们将重点介绍几个关键的接口（同样，以下接口是不同类型的Backend的实现的接口超集，并不是Redis作为介质时都有的）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // Workflow相关接口  InitGroup(groupUUID string, taskUUIDs []string) error GroupCompleted(groupUUID string, groupTaskCount int) (bool, error) GroupTaskStates(groupUUID string, groupTaskCount int) ([]*tasks.TaskState, error) TriggerChord(groupUUID string) (bool, error) // 任务状态设置接口 SetStatePending(signature *tasks.Signature) error SetStateReceived(signature *tasks.Signature) error SetStateStarted(signature *tasks.Signature) error SetStateRetry(signature *tasks.Signature) error SetStateSuccess(signature *tasks.Signature, results []*tasks.TaskResult) error SetStateFailure(signature *tasks.Signature, err string) error GetState(taskUUID string) (*tasks.TaskState, error) // Purging stored stored tasks states and group meta data PurgeState(taskUUID string) error PurgeGroupMeta(groupUUID string) error   Workflow 我们可以看到，第一批接口有Group和Chord相关的字眼，这就是我们在一开始提到的machinery中Workflow机制。Workflow极大的使能了任务队列的功能，使得machinery更加得心应手。关于Workflow的知识，我们将在下面的篇幅中详细介绍，这儿仅仅简单的介绍这几个接口的功能。\n  InitGroup()，顾名思义，在创建一个Group任务；\n  GroupCompleted(),检查一个Group中所有的任务是否都执行完毕；\n  GroupTaskStates()，返回一个Group中，所有任务的状态\n  TriggerChord()，当Group中任务全部执行完毕后，触发Chrod任务\n  State machinery中将任务的状态进行了很详细的划分，通过接口我们就可以看到，machinery支持了以下几种任务中间态：\n Pending，任务到达Broker Received，任务从Broker中读取成功 Started，任务开始执行 Retry，任务需要重试 Success，任务执行成功 Failure，任务执行失败  下面简单列出源码中设置状态接口的使用：\n1 2 3 4 5 6 7 8 9 10 11 12  // SetStatePending updates task state to PENDING func (b *RedisBackend) SetStatePending(signature *tasks.Signature) error { taskState := tasks.NewPendingTaskState(signature) return b.updateState(taskState) } // SetStateReceived updates task state to RECEIVED func (b *RedisBackend) SetStateReceived(signature *tasks.Signature) error { taskState := tasks.NewReceivedTaskState(signature) return b.updateState(taskState) } ...   Worker Worker负责了任务队列的执行单元，是任务队列中处理任务的关键元素，也是因此，Worker的接口很少，很直接：\n1 2 3 4  Launch() LaunchAsync(errorsChan chan error) Quit() Process(signature *tasks.Signature)   启动和停止 Worker启动是通过Launch()启动了一个进程，去订阅默认的任务队列，并且处理收到的任务。LaunchAsync()是Launch()的非阻塞版本，而通过Launch()中的代码，我们发现，其实就是调用了LaunchAsync()。\n在LaunchAsync()中，通过开启一个go程，实现了非阻塞式的调用了Broker的StartConsuming()函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  func (worker *Worker) Launch() error { errorsChan := make(chan error) worker.LaunchAsync(errorsChan) return errorsChan } // Launch()的非阻塞调用 func (worker *Worker) LaunchAsync(errorsChan chan error) { ... // broker消费者go程，同时负责与broker的断开重连等  go func() { for { retry, err := broker.StartConsuming(worker.ConsumerTag, worker.Concurrency, worker) if retry { if worker.errorHandler != nil { worker.errorHandler(err) } else { log.WARNING.Printf(\"Broker failed with error: %s\", err) } } else { errorsChan  err // stop the goroutine  return } } }() ... } }   Worker停止是通过Quit(）函数来实现，其调用了Broker的StopConsuming()函数，以实现gracefully stop。\n1 2 3 4  // Quit tears down the running worker process func (worker *Worker) Quit() { worker.server.GetBroker().StopConsuming() }   处理 Worker中的Process()函数，将会处理在Broker中的待处理任务，并且负责了任务回调的触发功能。Process()函数的任务流程主要是：\n任务检测-任务获取-任务预处理-Tracing处理-任务执行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  func (worker *Worker) Process(signature *tasks.Signature) error { ... //根据任务名，获取注册任务  taskFunc, err := worker.server.GetRegisteredTask(signature.Name) if err != nil { return nil } // 更新任务状态 Received  if err = worker.server.GetBackend().SetStateReceived(signature); err != nil { return fmt.Errorf(\"Set state received error: %s\", err) } // 任务预处理，预防任务出错，导致后面影响worker的运行  task, err := tasks.New(taskFunc, signature.Args) if err != nil { worker.taskFailed(signature, err) return err } // tracing处理  taskSpan := tracing.StartSpanFromHeaders(signature.Headers, signature.Name) tracing.AnnotateSpanWithSignatureInfo(taskSpan, signature) task.Context = opentracing.ContextWithSpan(task.Context, taskSpan) // 更新任务状态 Started  if err = worker.server.GetBackend().SetStateStarted(signature); err != nil { return fmt.Errorf(\"Set state started error: %s\", err) } // 任务执行  results, err := task.Call() if err != nil { // If a tasks.ErrRetryTaskLater was returned from the task,  // retry the task after specified duration  retriableErr, ok := interface{}(err).(tasks.ErrRetryTaskLater) if ok { return worker.retryTaskIn(signature, retriableErr.RetryIn()) } // Otherwise, execute default retry logic based on signature.RetryCount  // and signature.RetryTimeout values  if signature.RetryCount  0 { return worker.taskRetry(signature) } return worker.taskFailed(signature, err) } return worker.taskSucceeded(signature, results) }   machinery中，主要是通过反射实现了任务执行，具体的执行方式，在获取了函数之后与普通的反射无异，详细的介绍在后续篇幅介绍。关于任务执行之后的处理，有可能三种处理：\n任务执行成功:\ntaskSucceeded()，是在一个任务被成功执行后调用，主要负责更新任务状态、触发回调函数或者chord任务中的回调函数（前提是该task是chrod的分组任务中的最后一个任务），关于chord任务，在后面关于Workflow模式中将会详细介绍。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  func (worker *Worker) taskSucceeded(signature *tasks.Signature, taskResults []*tasks.TaskResult) error { // 更新任务状态 \tif err := worker.server.GetBackend().SetStateSuccess(signature, taskResults); err != nil { return fmt.Errorf(\"Set state success error: %s\", err) } ... // 回调任务 \tfor _, successTask := range signature.OnSuccess { // 当immutable为false时，传递参数 \tif signature.Immutable == false { // Pass results of the task to success callbacks \tfor _, taskResult := range taskResults { successTask.Args = append(successTask.Args, tasks.Arg{ Type: taskResult.Type, Value: taskResult.Value, }) } } worker.server.SendTask(successTask) } ... // 触发chord任务的回掉函数 \tshouldTrigger, err := worker.server.GetBackend().TriggerChord(signature.GroupUUID) if err != nil { return fmt.Errorf(\"Trigger chord error: %s\", err) } ... // 针对group任务的返回值做参数传递 \tfor _, taskState := range taskStates { if !taskState.IsSuccess() { return nil } if signature.ChordCallback.Immutable == false { for _, taskResult := range taskState.Results { signature.ChordCallback.Args = append(signature.ChordCallback.Args, tasks.Arg{ Type: taskResult.Type, Value: taskResult.Value, }) } } } // 发送chord任务 \t_, err = worker.server.SendTask(signature.ChordCallback) if err != nil { return err } return nil }   任务执行失败:\ntaskFailed()，是在一个任务执行失败（完全失败，即重试也失败）后调用。需要负责更新任务状态，并触发OnError回调函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  func (worker *Worker) taskFailed(signature *tasks.Signature, taskErr error) error { // 任务状态更新 Failure  if err := worker.server.GetBackend().SetStateFailure(signature, taskErr.Error()); err != nil { return fmt.Errorf(\"Set state failure error: %s\", err) } ... // Trigger error callbacks  for _, errorTask := range signature.OnError { // Pass error as a first argument to error callbacks  args := append([]tasks.Arg{{ Type: \"string\", Value: taskErr.Error(), }}, errorTask.Args...) errorTask.Args = args worker.server.SendTask(errorTask) } return nil }   任务重试:\n关于任务重试，machinery中提供了两种方式来实现。\n  machinery中通过设置任务的RetryCount和RetryTimeout参数来实现。\n  通过返回一个ErrRetryTaskLater类型的值来制定。\n  由于任务重试，需要依赖于对machinery中任务数据结构的了解，我们将在之后详细介绍。\n配置方案 为了掌握如何使用machinery，本文将会同时从调用代码和machinery源码来进行详细介绍，同时将会在每份代码段的初始部分分别标识出。在我们对使用方法进行介绍之前，首先通过machinery的启动配置文件来一探是如何衔接起各个工作模块的。在machinery中，支持两种配置方式，分别是：\n 基于yaml文件的配置 基于环境变量的配置  基于配置文件 对于配置文件，machinery中支持的格式为yaml，下面是一个基本的machinery的配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  # machinery.yamlbroker:'redis://123456@localhost:6379'#broker: 'amqp://guest:guest@localhost:5672/'#broker: 'https://sqs.us-west-2.amazonaws.com/123456789012'default_queue:'machinery_tasks'result_backend:'redis://123456@localhost:6379'#result_backend: 'memcache://localhost:11211'#result_backend: 'mongodb://localhost:27017'results_expire_in:36000amqp:binding_key:machinery_taskexchange:machinery_exchangeexchange_type:directprefetch_count:3  其中，\n broker：broker的地址，可以根据实际使用的存储介质，分别指定Redis、AMQP或AWS SQS； default_queue：broker默认存放任务的队列名称； result_backend：backend配置，用来指定存放结果的介质的配置。可以根据需求，分别制定Redis、memchache或mongodb等； results_expire_in：任务执行结果记录留存于backend保留时间，单位为秒； amqp：为当我们使用AMQP是的详细配置信息；  上面展示的，是一个基本版的配置文件，而machinery中的所有配置，我们可以通过下方的数据结构来了解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 源码 // machinery完整的配置结构 type Config struct { Broker string `yaml:\"broker\" envconfig:\"BROKER\"` DefaultQueue string `yaml:\"default_queue\" envconfig:\"DEFAULT_QUEUE\"` ResultBackend string `yaml:\"result_backend\" envconfig:\"RESULT_BACKEND\"` ResultsExpireIn int `yaml:\"results_expire_in\" envconfig:\"RESULTS_EXPIRE_IN\"` AMQP *AMQPConfig `yaml:\"amqp\"` SQS *SQSConfig `yaml:\"sqs\"` Redis *RedisConfig `yaml:\"redis\"` TLSConfig *tls.Config // NoUnixSignals - when set disables signal handling in machinery \tNoUnixSignals bool `yaml:\"no_unix_signals\" envconfig:\"NO_UNIX_SIGNALS\"` DynamoDB *DynamoDBConfig `yaml:\"dynamodb\"` }   调用yaml文件的配置方式，通过NewFromYaml()接口来完成，NewFromYaml()的基本逻辑中，主要是实现了一个加载配置的函数和reload配置的逻辑，而默认reload间隔reloadDelay为10s：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // 源码 func NewFromYaml(cnfPath string, keepReloading bool) (*Config, error) { cnf, err := fromFile(cnfPath) if err != nil { return nil, err } if keepReloading { // 通过go程，实现定时reload配置  go func() { for { // Delay after each request  time.Sleep(reloadDelay) // Attempt to reload the config  newCnf, newErr := fromFile(cnfPath) if newErr != nil { log.WARNING.Printf(\"Failed to reload config from file %s: %v\", cnfPath, newErr) continue } *cnf = *newCnf } }() } return cnf, nil }   基于环境变量 上面提到，machinery的配置文件方式只支持yaml，然而并不是所有项目都是采用了yaml文件，例如我们目前项目中配置文件普遍使用了toml文件。这样，为了使用machinery就必须在一个项目出现了两个配置文件（项目的toml文件和machinery的yaml文件）。然而，做技术的一般都是有强迫症的，两个配置文件存在于一个项目的确是一个十分ugly的现象，为了解决这一问题，machinery的环境变量配置模式的作用就体现出来了。\n基于环境变量的源码与基于配置的结构类似，不在此列出。由于支持了基于环境变量的配置初始化，那么，我们可以将所有的配置均放在同一个配置文件中（对于我们的项目来说，即为toml文件），并在项目init阶段，将machinery的配置从toml文件中全部加载到临时环境变量并读取，从而曲线救国，解决了多配置文件的问题，简单示例如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 调用代码 //首先将配置文件加载到内存appConfig结构中 // （具体加载到内存中的方法很多，每个项目都有自己的方式，略去）  //然后将相关配置加载到环境变量 os.Setenv(\"BROKER\", brokerValue) os.Setenv(\"REDIS_MAX_IDLE\", strconv.Itoa(appConfig.GetInt(\"redis.maxidle\"))) //从toml中读取参数 os.Setenv(\"REDIS_MAX_ACTIVE\", strconv.Itoa(appConfig.GetInt(\"redis.maxactive\"))) os.Setenv(\"REDIS_IDLE_TIMEOUT\", strconv.Itoa(appConfig.GetInt(\"redis.idletimeout\"))) os.Setenv(\"REDIS_READ_TIMEOUT\", strconv.Itoa(appConfig.GetInt(\"redis.readtimeout\"))) os.Setenv(\"REDIS_WRITE_TIMEOUT\", strconv.Itoa(appConfig.GetInt(\"redis.writetimeout\"))) os.Setenv(\"REDIS_CONNECT_TIMEOUT\", strconv.Itoa(appConfig.GetInt(\"redis.connecttimeout\"))) //通过NewFromEnvironment()函数加载环境变量 config.NewFromEnvironment(false)   任务 从框架设计到逻辑原理，说了这么久的任务队列，任务，才是所有任务队列中的最基础的元素。从代码层面来看，一个任务就是一个执行函数。结合上篇文章中介绍过的machinery架构，我们可以知道在 machinery中，一个典型的处理流程，即为：\n 任务创建 任务注册 任务发布 任务执行 结果获取  在下面的篇幅中，我们分别就上述步骤，从使用方法和原理同时解析，来详细介绍在machinery中如何操作和实现这几个过程。\n结构 在详细介绍machinery如何处理一次任务流程之前，我们需要首先知道，究竟在machinery中一个任务的数据结构是什么样子的。在machinery的源码世界里，我们可以理解将一个任务称作为Signature，其数据结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 源码 type Signature struct { UUID string Name string RoutingKey string ETA *time.Time GroupUUID string GroupTaskCount int Args []Arg Headers Headers Immutable bool RetryCount int RetryTimeout int OnSuccess []*Signature OnError []*Signature ChordCallback *Signature }   我们介绍几个有意义的参数：\n UUID，任务的unique ID，可以主动设定也可以由系统自行设定； Name，任务的名称，用于识别任务； RoutingKey，根据这个key，用于将任务扔到一个正确的队列中； ETA，专用于延时任务，若该参数为nil，说明需要立即将该任务扔给worker，否则，在参数数值到来之前，该任务将一直delay； GroupUUID和GroupTaskCount，用于workflow中的Group分组任务创建 Args，任务传递给worker时的参数列表 Headers，用于tracing RetryCount和RetryTimeout，用于实现任务的重试机制 Immutable，该参数可以控制任务之间是否需要参数传递 OnSuccess和OnError，实现回调，workflow中的链式任务（chain），就是通过OnSuccess来实现链式调度 ChordCallback，workflow中的chord模式，在group内所有任务全部执行完成后，进行callback。  创建任务 任务的创建在machinery中十分简单，其实就是生成一个Signature的实例，我们看下面的示例代码中，我们创建了一个名为 “audience.DownloadFromCos”的任务，指定了该任务的重试次数为2，重试超时时间为3s，同时设定了两个参数到Args中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // 业务代码 const( TASK_RETRY_COUNT = 2 TASK_RETRY_TIMEOUT = 3 ) ... func buildDownloadFromCos(appId, bucketName string) tasks.Signature { return tasks.Signature{ Name: \"audience.DownloadFromCos\", RetryCount: TASK_RETRY_COUNT, RetryTimeout: TASK_RETRY_TIMEOUT, Args: []tasks.Arg{ { Type: \"string\", Value: appId, }, { Type: \"string\", Value: bucketName, }, }, } }   注册任务 当任务创建完毕后，我们需要将任务注册到broker中才可供worker识别以调用。machinery中提供了一个RegisterTasks()函数来接受任务的注册，下面的代码中，我们将上述的DownloadFromCos()和另一个ParseCosFile()任务分别以名称为“audience.DownloadFromCos”和“audience.ParseCosFile”注册到machinery中：\n1 2 3 4 5 6 7  // 调用代码 // 注册任务 tasks := map[string]interface{}{ \"audience.DownloadFromCos\": DownloadFromCos, \"audience.ParseCosFile\": ParseCosFile, } server.RegisterTasks(tasks)   RegisterTasks()会将所有的tasks加载到成员变量registeredTasks(同样为一个map类型)中，同时将通过调用broker接口SetRegisteredTaskNames()，将tasks名称注册到broker中，从而在broker之后接收到待处理任务之后可以判断是否为合法已注册任务：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 源码 func (server *Server) RegisterTasks(namedTaskFuncs map[string]interface{}) error { for _, task := range namedTaskFuncs { if err := tasks.ValidateTask(task); err != nil { return err } } server.registeredTasks = namedTaskFuncs server.broker.SetRegisteredTaskNames(server.GetRegisteredTaskNames()) return nil } ... // SetRegisteredTaskNames函数 func (b *Broker) SetRegisteredTaskNames(names []string) { b.registeredTaskNames = names }   发布任务 通过发布任务，broker中才会收到具体的任务内容。machinery中的任务提供了多种任务类型（主要是与Workflow相关，下文会详述），不同的任务有着类似但不相同的发布方法。在当前章节中，我们将首先介绍最基本的普通任务的发布：\n1 2 3 4 5 6 7  // 业务代码 // 发送一个任务，taskObj由buildDownloadFromCos()返回 asyncResult, err := machinery.SendTask(\u0026taskObj) if err != nil { log.LoggerFromContextWithCaller(ctx).Errorf(err.Error()) return }   SendTask()中会调用Publish()函数去发布任务到broker，我们看到Publish()函数接受一个Signature类型的变量，首先将会根据任务参数ETA去判断任务类型是实时任务还是延时任务，从而扔到不同的任务队列中。一旦任务被扔到Broker中，worker就可以去获取并执行任务了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // 源码 var redisDelayedTasksKey = \"delayed_tasks\" func (b *RedisBroker) Publish(signature *tasks.Signature) error { ... // 根据ETA判断普通任务还是延时任务  // ETA不为nil，延时任务，将ETA作为score到ZSET \tif signature.ETA != nil { now := time.Now().UTC() if signature.ETA.After(now) { score := signature.ETA.UnixNano() _, err = conn.Do(\"ZADD\", redisDelayedTasksKey, score, msg) return err } } // ETA为nil，普通任务，到LIST \t_, err = conn.Do(\"RPUSH\", signature.RoutingKey, msg) return err }   获取结果 1 2 3 4 5 6 7  // 业务代码 // asyncResult由上述发布任务函数machinery.SendTask()所返回 results, err := asyncResult.Get(time.Duration(time.Millisecond * 5)) if err != nil { log.LoggerWrapperWithCaller().Errorf(err.Error()) return }   其中，asyncResult.Get()函数为一个异步阻塞函数，根据设定的参数轮询从backends中获取任务执行结果。以redis作为backends时为例，每一个任务的执行结果会存储于一条redis的key-value中，所以Get()函数最终会调用GET方法，根据任务的UUID，去redis中获取结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // 源码 // 根据uuid，获取该任务最近的状态 func (b *RedisBackend) GetState(taskUUID string) (*tasks.TaskState, error) { conn := b.open() defer conn.Close() item, err := redis.Bytes(conn.Do(\"GET\", taskUUID)) if err != nil { return nil, err } state := new(tasks.TaskState) decoder := json.NewDecoder(bytes.NewReader(item)) decoder.UseNumber() if err := decoder.Decode(state); err != nil { return nil, err } return state, nil }   通过上面的介绍，我们基本知道了在machinery中如何走一个最简单的任务操作及其原理。但是，如同我们在系列一中说到的，任务队列仅有这些功能是远远不够的，接下来我们将继续介绍machinery中的额外的任务队列功能。\n重试机制 任务重试，算是任务队列的一个除了基本功能外的一个重要的基础功能，在上文中也已经顺带提到了。之所以会单独拎出来说，machinery中提供了两种方式来实现任务重试。\n对于第一种，在上文中已经提到过，machinery中通过设置任务的RetryCount和RetryTimeout参数来实现，当任务执行出错后，会通过这两个参数来更新任务的ETA参数。RetryCount提供了重试次数，RetryTimeout提供了一个基于斐波那契数列的回退超时机制。\n关于第二种，通过返回一个ErrRetryTaskLater类型的值来制定。\n1 2 3 4 5 6  // 源码 // ErrRetryTaskLater ... type ErrRetryTaskLater struct { name, msg string retryIn time.Duration }   同时需要注意的是，第二种方式的优先级高于第一种，也就是说，如果在新建任务的时候指定了RetryCount和RetryTimeout参数，但是在执行任务失败后返回了ErrRetryTaskLater类型的数值，依然按照返回值里的参数来制定重试方式。\n在系列之一的最后部分，我们提到了Worker处理中的Process()接口的实现，下面让我们再来看一下Process()实现中的任务重试部分的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // 源码 // worker执行任务的函数 func (worker *Worker) Process(signature *tasks.Signature) error { ... // 任务执行失败后，判定重试的逻辑 \tresults, err := task.Call() if err != nil { // If a tasks.ErrRetryTaskLater was returned from the task, \t// retry the task after specified duration \tretriableErr, ok := interface{}(err).(tasks.ErrRetryTaskLater) if ok { return worker.retryTaskIn(signature, retriableErr.RetryIn()) } // Otherwise, execute default retry logic based on signature.RetryCount \t// and signature.RetryTimeout values \tif signature.RetryCount  0 { return worker.taskRetry(signature) } return worker.taskFailed(signature, err) } ... }   我们看到，当任务执行失败后，将会首先判断tasks.ErrRetryTaskLater是否有被实现，根据是否实现了该接口，分别调用retryTaskIn或者taskRetry函数。其中，\n retryTaskIn()函数将任务参数ETA刷新，并重新发布该任务； retryTask()函数将任务参数RetryCount减1，同时根据RetryTimeout参数更新ETA，并重新发布该任务；  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  // 源码 func (worker *Worker) retryTaskIn(signature *tasks.Signature, retryIn time.Duration) error { // 更新任务状态为Retry  if err := worker.server.GetBackend().SetStateRetry(signature); err != nil { return fmt.Errorf(\"Set state retry error: %s\", err) } // 将参数ETA更新为当前时间+retryIn.Seconds()  eta := time.Now().UTC().Add(retryIn) signature.ETA = \u0026eta log.WARNING.Printf(\"Task %s failed. Going to retry in %.0f seconds.\", signature.UUID, retryIn.Seconds()) // 重新发布任务  _, err := worker.server.SendTask(signature) return err } // 源码 func (worker *Worker) taskRetry(signature *tasks.Signature) error { // Update task state to RETRY  if err := worker.server.GetBackend().SetStateRetry(signature); err != nil { return fmt.Errorf(\"Set state retry error: %s\", err) } // RetryCount - 1  signature.RetryCount-- // 更新Retrytimeout时间  signature.RetryTimeout = retry.FibonacciNext(signature.RetryTimeout) // 更新ETA参数  eta := time.Now().UTC().Add(time.Second * time.Duration(signature.RetryTimeout)) signature.ETA = \u0026eta log.WARNING.Printf(\"Task %s failed. Going to retry in %d seconds.\", signature.UUID, signature.RetryTimeout) // 重新发布任务  _, err := worker.server.SendTask(signature) return err }   WorkFlow 运行一个任务，支持实时执行、或者延时执行，同时在出错后支持重试等功能，这些在部分场合已经十分适用了，但是，在更多场景下，我们需要执行的任务之间有上下依赖需要串行执行、或者任务之间完全并行不相关、又或者根据结果成功失败来执行回调的需求。为了满足这类需求，machinery中Workflow模式的作用体现出来了。\nChain链式任务 所谓任务链式调度，即一系列任务之间采用one by one的串行调度，只有前一个任务执行完毕，才会执行后一个任务。我们依然根据上文介绍普通任务的流程来介绍在machinery中对于链式任务的处理流程：\n任务创建 machinery中提供了NewChain()接口来实现链式任务的创建，如下所示，我们分别创建了两个任务实例task0和task1，然后通过NewChain()生成了链式任务chain实例：\n1 2 3 4 5 6 7 8  // 调用代码 task0 := buildDownloadFromCos(\"audience.DownloadFromCos\",appId, bucketName) task1 := buildDoCompare(\"audience.DoCompare\",appId, upstreamId) chain, err := tasks.NewChain(\u0026task0,\u0026task1) if err != nil { log.LoggerWrapperWithCaller().Errorf(err.Error()) return }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // 源码 func NewChain(signatures ...*Signature) (*Chain, error) { // uuid的生成逻辑  for _, signature := range signatures { if signature.UUID == \"\" { signatureID, err := uuid.NewV4() if err != nil { return nil, fmt.Errorf(\"Error generating signature id: %s\", err.Error()) } signature.UUID = fmt.Sprintf(\"task_%v\", signatureID) } } // 将所有任务拼装，并传递给Chain数据结构中的Tasks变量  for i := len(signatures) - 1; i  0; i-- { if i  0 { signatures[i-1].OnSuccess = []*Signature{signatures[i]} } } chain := \u0026Chain{Tasks: signatures} return chain, nil } ... // 链式任务数据结构 type Chain struct { Tasks []*Signature }   我们重点看一下上述的任务拼装部分，通过链式任务的拼装，最终我们通过chain任务中的第一个任务，就可以看到chain中的所有任务，下方是一个chain任务存储于Broker中的示例，该chain任务中，一共有2个基本任务task，分别通过OnSuccess来实现任务的连接调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99  // Chain任务在Broker中的示例 { \"UUID\": \"task_14a0f22c-b456-493c-9c9c-7cd2216d4339\", \"Name\": \"audience.ExtractEsToFile\", \"RoutingKey\": \"machinery_tasks\", \"ETA\": null, \"GroupUUID\": \"\", \"GroupTaskCount\": 0, \"Args\": [ { \"Name\": \"\", \"Type\": \"string\", \"Value\": \"123456789\" }, { \"Name\": \"\", \"Type\": \"string\", \"Value\": \"audience/2018-06-07/4703668260587260.data\" }, { \"Name\": \"\", \"Type\": \"string\", \"Value\": \"[{\\\"field\\\":\\\"gender.keyword\\\",\\\"value\\\":[\\\"女\\\"],\\\"operation\\\":\\\"and\\\"},{\\\"field\\\":\\\"job_title.keyword\\\",\\\"value\\\":[\\\"快?~R佑~X\\\"],\\\"operation\\\":\\\"and\\\"}} ,{\\\"field\\\":\\\"school_role.keyword\\\",\\\"value\\\":[\\\"维修工\\\"],\\\"operation\\\":\\\"and\\\"}]\" } ], \"Headers\": null, \"Immutable\": false, \"RetryCount\": 3, \"RetryTimmeout\": 5, \"OnSuccess\": [ { \"UUID\": \"task_cab90b2c-2dc5-4035-91f6-4803df67c8c0\", \"Name\": \"audience.EncryptExtractFile\", \"RoutingKey\": \"\", \"ETA\": null, \"GroupUUID\": \"\", \"GroupTaskCount\": 0, \"Args\": [ { \"Name\": \"\", \"Type\": \"string\", \"Value\": \"123456789\" }, { \"Name\": \"\", \"Type\": \"int64\", \"Value\": 29 } ], \"Headers\": null, \"Immutable\": false, \"RetryCount\": 3, \"RetryTimeout\": 5, \"OnSuccess\": [ { \"UUID\": \"task_82f4f831-af24-4f71-950b-5d11abac3dea\", \"Name\": \"audience.UploadExtractFileToCos\", \"RoutingKey\": \"\", \"ETA\": null, \"GroupUUID\": \"\", \"GroupTaskCount\": 0, \"Args\": [ { \"Name\": \"\", \"Type\": \"string\", \"Value\": \"123456789\" }, { \"Name\": \"\", \"Type\": \"string\", \"Value\": \"beta-abc\" }, { \"Name\": \"\", \"Type\": \"string\", \"Value\": \"ap-shanghai\" }, { \"Name\": \"\", \"Type\": \"string\", \"Value\": \"audience/2018-06-07/4703668260587260.data\" } ], \"Headers\": null, \"Immutable\": false, \"RetryCount\": 3, \"RetryTimeout\": 5, \"OnSuccess\": null, \"OnError\": null, \"ChordCallback\": null } ], \"OnError\": null, \"ChordCallback\": null } ], \"OnError\": null, \"ChordCallback\": null }   任务发布 链式任务发布的方法与普通任务接口设计基本一致，直接通过调用SendChain()接口即可：\n1 2 3 4 5 6  // 调用代码 asyncResult, err := mc.SendChain(\u0026chain) if err != nil { log.LoggerFromContextWithCaller(ctx).Errorf(err.Error()) return }   结合上述对chain任务创建的介绍，我们来看下SendChain()代码实现。如上文描述，由于第一个任务中已经包含了所有的后续任务信息，发布一个chain任务，实际上只需要发布第一个任务到Broker中即可：\n1 2 3 4 5 6 7 8 9  // 源码 func (server *Server) SendChain(chain *tasks.Chain) (*backends.ChainAsyncResult, error) { _, err := server.SendTask(chain.Tasks[0]) if err != nil { return nil, err } return backends.NewChainAsyncResult(chain.Tasks, server.backend), nil }   因此，真正实现的chain中后续的任务调用，是由worker对每一个任务的OnSuccess参数检查来实现调度的，当worker中每一个任务调用成功后，都会触发taskSucceeded()执行，taskSucceeded中则会针对OnSuccess进行判断，如果发现存在OnSuccess，则会发布下一个任务，从而实现了任务的链式调度：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // 源码 func (worker *Worker) taskSucceeded(signature *tasks.Signature, taskResults []*tasks.TaskResult) error { ... for _, successTask := range signature.OnSuccess { if signature.Immutable == false { // Pass results of the task to success callbacks  for _, taskResult := range taskResults { successTask.Args = append(successTask.Args, tasks.Arg{ Type: taskResult.Type, Value: taskResult.Value, }) } } worker.server.SendTask(successTask) } ... }   结果获取 链式任务的结果获取，获取的是最后一个任务的执行结果，调用方式与普通任务获取无异，方式如下：\n1 2 3 4 5 6  // 调用代码 results, err := chainAsyncResult.Get(time.Duration(time.Millisecond * 5)) if err != nil { log.LoggerWrapperWithCaller().Errorf(err.Error()) return }   参数传递 这时候，细心的同学可能会问了，如果串行执行的任务之间有参数依赖需要传递的话，如何实现呢？这时候我们回头看一下Signature的参数中有一个Immutable，chain任务会根据每一个任务的Immutable参数的数值来决定是否帮我们将上一个任务的返回值通过参数传递给chain中的下一个任务，如果immutable为true，那么参数将不会被传递下去，实现该部分的代码在任务执行成功的taskSucceeded()函数中。我们会看上一小节的taskSucceeded()代码，就可以看到对每一个任务的Immutable检查。\nGroup分组任务 分组任务，听起来可能不太理解，但如果换成另一个名词：并行任务，就很好理解了。即一个分组group内的所有任务，是相互独立，同时执行的，这在任务队列中也是有着相当大的使用场景的。\n任务创建 machinery中创建分组任务的接口是NewGroup()，可以接受多个普通任务参数，并生成一个group实例：\n1 2 3 4 5  // 调用代码 group, err := tasks.NewGroup(\u0026task0, \u0026task1, \u0026task2) if err != nil { log.LoggerWrapperWithCaller().Errorf(err.Error()) }   在Group中的所有任务，没有执行顺序的要求，所有的任务将会由所有worker去竞争获取并执行。也是因此，创建分组任务的实现也十分简单，只需要进行简单的复制即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  // 源码 func NewGroup(signatures ...*Signature) (*Group, error) { // 创建Group的uuid  groupUUID, err := uuid.NewV4() ... for _, signature := range signatures { if signature.UUID == \"\" { signatureID, err := uuid.NewV4() if err != nil { return nil, fmt.Errorf(\"Error generating signature id: %s\", err.Error()) } signature.UUID = fmt.Sprintf(\"task_%v\", signatureID) } signature.GroupUUID = groupID signature.GroupTaskCount = len(signatures) } return \u0026Group{ GroupUUID: groupID, Tasks: signatures, }, nil } ... // 分组任务数据结构 type Group struct { GroupUUID string Tasks []*Signature }   任务发布 machinery中发布分组任务接口是SendGroup()，支持将任务并行发布到Broker中，同时还支持了一个发送任务的并发控制，以防止同一时刻发布太多任务到任务队列，照顾到Broker的性能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  asyncResults, err := server.SendGroup(group, /*并发任务数量*/5) if err != nil { return fmt.Errorf(\"Could not send group: %s\", err.Error()) } SendGroup()接口的代码如下，不必要的地方已经省略，同时添加了部分注释： // 源码 func (server *Server) SendGroup(group *tasks.Group, sendConcurrency int) ([]*backends.AsyncResult, error) { ... wg.Add(len(group.Tasks)) errorsChan := make(chan error, len(group.Tasks)*2) // 初始化group，主要负责在backend中根据group uuid创建一条记录，以存储该group任务的状态  server.backend.InitGroup(group.GroupUUID, group.GetUUIDs()) // 任务状态设置  for _, signature := range group.Tasks { if err := server.backend.SetStatePending(signature); err != nil { errorsChan  err continue } } // 并发控制  pool := make(chan struct{}, sendConcurrency) go func() { for i := 0; i  sendConcurrency; i++ { pool  struct{}{} } }() for i, signature := range group.Tasks { if sendConcurrency  0 { pool } go func(s *tasks.Signature, index int) { defer wg.Done() // 发布任务  err := server.broker.Publish(s) if sendConcurrency  0 { pool  struct{}{} } if err != nil { errorsChan  fmt.Errorf(\"Publish message error: %s\", err) return } asyncResults[index] = backends.NewAsyncResult(s, server.backend) }(signature, i) } ... }   结果获取 分组任务中每个任务的执行结果，全部存储于asyncResult 中，可通过遍历获取：\n1 2 3 4 5 6 7 8 9 10 11 12 13  // 调用代码 \tfor _, asyncResult := range asyncResults { results, err = asyncResult.Get(time.Duration(time.Millisecond * 5)) if err != nil { return fmt.Errorf(\"Getting task result failed with error: %s\", err.Error()) } log.INFO.Printf( \"%v + %v = %v\\n\", asyncResult.Signature.Args[0].Value, asyncResult.Signature.Args[1].Value, tasks.HumanReadableResults(results), ) }   Chord任务 chord任务，其功能是分组任务+回调任务。即，chord任务允许我们在并行执行完毕所有一组group任务之后，回调一个callback任务，这也是一个有着非常多的应用场景。\n任务创建 machinery通过NewChord()接口实现chord任务创建，接受两个参数，分别是group任务实例和回调函数：\n1 2 3 4 5  // 调用代码 chord, err := tasks.NewChord(group, \u0026cbTask) if err != nil { return fmt.Errorf(\"Error creating chord: %s\", err) }   而NewChord()函数主要负责给group中每个任务的ChordCallback赋值为需要回调的函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 源码 func NewChord(group *Group, callback *Signature) (*Chord, error) { ... for _, signature := range group.Tasks { signature.ChordCallback = callback } return \u0026Chord{Group: group, Callback: callback}, nil } ... // Chord任务数据结构 type Chord struct { Group *Group Callback *Signature }   任务发布 chord任务发布比较也比较简单，接口SendChord()与SendGroup()类似，而SendChord()中的代码逻辑也比较简单，即简单的warp了一下SendGroup任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 调用代码 chordAsyncResult, err := server.SendChord(chord, /*并发任务数量*/5) if err != nil { return fmt.Errorf(\"Could not send chord: %s\", err.Error()) } // 源码 func (server *Server) SendChord(chord *tasks.Chord, sendConcurrency int) (*backends.ChordAsyncResult, error) { _, err := server.SendGroup(chord.Group, sendConcurrency) if err != nil { return nil, err } return backends.NewChordAsyncResult( chord.Group.Tasks, chord.Callback, server.backend, ), nil }   而主要对chord的回调函数的调用，则同样是通过任务执行成功后的执行函数taskSucceeded()来实现，其相关代码如下，具体的逻辑可以从添加的注释中了解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  // 源码 func (worker *Worker) taskSucceeded(signature *tasks.Signature, taskResults []*tasks.TaskResult) error { ... // 若该任务不是groupe任务中的, return \tif signature.GroupUUID == \"\" { return nil } // 检查是否group中的所有任务都执行完毕 \tgroupCompleted, err := worker.server.GetBackend().GroupCompleted( signature.GroupUUID, signature.GroupTaskCount, ) if err != nil { return fmt.Errorf(\"Group completed error: %s\", err) } if !groupCompleted { return nil } ... // 若无chord callback, return  if signature.ChordCallback == nil { return nil } // 触发chord callback, 确保只触发一次  shouldTrigger, err := worker.server.GetBackend().TriggerChord(signature.GroupUUID) if err != nil { return fmt.Errorf(\"Trigger chord error: %s\", err) } if !shouldTrigger { return nil } ... // 发送chord任务  _, err = worker.server.SendTask(signature.ChordCallback) if err != nil { return err } return nil }   结果获取 chord任务的结果获取与其他的操作无异，如下所示：\n1 2 3 4 5  // 调用代码 results, err = chordAsyncResult.Get(time.Duration(time.Millisecond * 5)) if err != nil { return fmt.Errorf(\"Getting chord result failed with error: %s\", err.Error()) }   总结 我们详细的介绍了golang中任务队列machinery的使用和原理，从而为众多golang使用者们推荐了一款好用的任务队列，并从源码层解析了其详细实现。\n同时，本文主要是基于Redis作为存储介质来进行详细介绍，而Redis中缺乏如Ack之类的机制，尽管可以通过LUA脚本简介实现，但是在云时代的Redis集群对EVAL接口支持的能力还有不足，使得使用起来还是略有欠缺。因此，对于任务可靠性要求更高的，可以使用基于AMQP的方案来使用，更多关于AMQP的实现接口，基本与Redis下一致，大家可以进一步阅读源码。\n转载:\nhttps://cloud.tencent.com/developer/article/1169675 https://cloud.tencent.com/developer/article/1177831\n",
  "wordCount" : "14643",
  "inLanguage": "zh-cn",
  "datePublished": "2019-10-17T18:22:26Z",
  "dateModified": "2019-10-17T18:22:26Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97machinery%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      异步任务队列:machinery源码剖析
    </h1>
    <div class="post-meta">October 17, 2019
</div>
  </header> 
  <div class="post-content"><h1 id="导语">导语<a hidden class="anchor" aria-hidden="true" href="#导语">#</a></h1>
<p>异步任务，是每一位开发者都遇到过的技术名词，在任何一个稍微复杂的后台系统中，异步任务总是无法避免的，而任务队列由于其松耦合、易扩展的特性，成为了实现异步任务的可靠保证。</p>
<h1 id="背景">背景<a hidden class="anchor" aria-hidden="true" href="#背景">#</a></h1>
<p>当用户的一次请求事件发生，可能是某种数据的重复数查询，亦或是某批人群的覆盖率统计，展现到用户的是几行数字，但在透视到后端逻辑中，简单的这可能是一次mysql的联表查询或者elasticsearch的聚合，但更多情况下，是附带了一系列复杂的数据交互或者耗时的逻辑计算。当后端这种发生多次数据交互任务的情况一旦存在，为了实现每一次任务的可靠执行以及前端响应速度，任务队列的存在意义就凸显了。</p>
<h1 id="场景与功能">场景与功能<a hidden class="anchor" aria-hidden="true" href="#场景与功能">#</a></h1>
<p>任务队列有着广泛的适应场景：</p>
<ul>
<li>大批量的计算任务。如大量数据插入，通过拆分并分批插入任务队列，从而实现串行链式任务处理或者实现分组并行任务处理，提高系统鲁棒性，提高系统并发度；</li>
<li>数据预处理。定期的从后端存储将数据同步到到缓存系统，从而在查询请求发生时，直接去缓存系统中查询，提高查询请求的响应速度；</li>
<li>错误重试功能。为了提高系统的可用性，当函数处理出现错误时，我们希望可以给予其重试的机会，增强系统的可用性。</li>
</ul>
<p>适用于任务队列的场景还有很多，同样，不同语言也有着自己著名的任务队列系统，众所周知的如python下的celery，PHP中laraval框架的Queues，都是使用度十分广泛的任务队列系统。</p>
<p>我们项目的技术栈为golang，因此，在我们go为基础的微服务框架中，需要存在一个类型于celery或者laraval中的任务队列系统，在经过了一系列筛选后，我们采用了machinery作为我们的任务队列系统。machinery，一个第三方开源的基于分布式消息分发的异步任务队列，有着以下这些特性：</p>
<ul>
<li>任务重试机制</li>
<li>延迟任务支持</li>
<li>任务回调机制</li>
<li>任务结果记录</li>
<li>支持Workflow模式：Chain，Group，Chord</li>
<li>多Brokers支持：Redis, AMQP, AWS SQS</li>
<li>多Backends支持：Redis, Memcache, AMQP, MongoDB</li>
</ul>
<p>当前machinery在v1 stable版本，可以通过<code>go get github.com/RichardKnop/machinery/v1</code>获取。</p>
<h1 id="架构设计">架构设计<a hidden class="anchor" aria-hidden="true" href="#架构设计">#</a></h1>
<p>任务队列，简而言之就是一个放大的生产者消费者模型，用户请求会生成任务，任务生产者不断的向队列中插入任务，同时，队列的处理器程序充当消费者不断的消费任务。基于这种框架设计思想，我们来看下machinery的简单设计结构图例：</p>
<p>其中：</p>
<ul>
<li>Server：业务模块，生成具体任务，可根据业务逻辑中，按交互进行拆分；</li>
<li>Broker：存储具体序列化后的任务，machinery中目前支持到Redis, AMQP,和SQS；</li>
<li>Worker：工作进程，负责消费者功能，处理具体的任务；</li>
<li>Backend：后端存储，用于存储任务执行状态的数据；</li>
</ul>
<p>在本篇文章中，我们将对上述几个模块进行详细讲解。</p>
<h1 id="broker">Broker<a hidden class="anchor" aria-hidden="true" href="#broker">#</a></h1>
<p>machinery的broker支持多种存储介质：Redis，AMQP和SQS，本篇文章中，我们将以redis来详细介绍，其他类型的存储介质，在实现细节上由于介质的API支持不一可能略有不同，但machinery具体暴露接口类似，有兴趣的读者可以详细再阅读相关源码。</p>
<p>machinery的Broker实现了以下这几种接口，我们将重点介绍起着关键作用的接口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">GetConfig</span><span class="p">()</span> <span class="o">*</span><span class="nx">config</span><span class="p">.</span><span class="nx">Config</span>
<span class="nf">SetRegisteredTaskNames</span><span class="p">(</span><span class="nx">names</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span>
<span class="nf">IsTaskRegistered</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span>
<span class="nf">StartConsuming</span><span class="p">(</span><span class="nx">consumerTag</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">concurrency</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">p</span> <span class="nx">TaskProcessor</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="nf">StopConsuming</span><span class="p">()</span>
<span class="nf">Publish</span><span class="p">(</span><span class="nx">task</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span> <span class="kt">error</span>
<span class="nf">GetPendingTasks</span><span class="p">(</span><span class="nx">queue</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="启动和停止">启动和停止<a hidden class="anchor" aria-hidden="true" href="#启动和停止">#</a></h2>
<p>当我们使用machinery时，在启动服务之后，StartConsuming()函数将以阻塞轮询的方式去Broker中获取任务并消费处理。而当服务停止之后，StopConsuming()函数将会等待一系列go程结束，以实现gracefully stop。</p>
<p>详细来看StartConsumin()函数，具体源码如下（不相关的代码细节已经省略）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">RedisBroker</span><span class="p">)</span> <span class="nf">StartConsuming</span><span class="p">(</span><span class="nx">consumerTag</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">concurrency</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">taskProcessor</span> <span class="nx">TaskProcessor</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
  <span class="c1">// 获取任务go程
</span><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
                <span class="o">...</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">b</span><span class="p">.</span><span class="nx">stopReceivingChan</span><span class="p">:</span>
				<span class="k">return</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
				<span class="k">if</span> <span class="nf">concurrencyAvailable</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">task</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">nextTask</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">cnf</span><span class="p">.</span><span class="nx">DefaultQueue</span><span class="p">)</span>
					<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
						<span class="nx">timer</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nx">timerDuration</span><span class="p">)</span>
						<span class="k">continue</span>
					<span class="p">}</span>
					<span class="nx">deliveries</span> <span class="o">&lt;-</span> <span class="nx">task</span>
				<span class="p">}</span>
         <span class="c1">//并发控制逻辑
</span><span class="c1"></span>				<span class="k">if</span> <span class="nf">concurrencyAvailable</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">timer</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="c1">//设置timer为0，立即继续消费任务
</span><span class="c1"></span>				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nx">timer</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nx">timerDuration</span><span class="p">)</span><span class="c1">//重置timer，等待duration后再尝试消费
</span><span class="c1"></span>				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>

  <span class="c1">// 获取延时任务go程
</span><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
                <span class="o">...</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">b</span><span class="p">.</span><span class="nx">stopDelayedChan</span><span class="p">:</span>
				<span class="k">return</span>
			<span class="k">default</span><span class="p">:</span>
				<span class="nx">task</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">nextDelayedTask</span><span class="p">(</span><span class="nx">redisDelayedTasksKey</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="k">continue</span>
				<span class="p">}</span>

				<span class="nx">signature</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span>
				<span class="nx">decoder</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">task</span><span class="p">))</span>
				<span class="nx">decoder</span><span class="p">.</span><span class="nf">UseNumber</span><span class="p">()</span>
				<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">decoder</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">signature</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">log</span><span class="p">.</span><span class="nx">ERROR</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="nf">NewErrCouldNotUnmarshaTaskSignature</span><span class="p">(</span><span class="nx">task</span><span class="p">,</span> <span class="nx">err</span><span class="p">))</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Publish</span><span class="p">(</span><span class="nx">signature</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">log</span><span class="p">.</span><span class="nx">ERROR</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>
  <span class="c1">//执行任务消费
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">consume</span><span class="p">(</span><span class="nx">deliveries</span><span class="p">,</span> <span class="nx">pool</span><span class="p">,</span> <span class="nx">concurrency</span><span class="p">,</span> <span class="nx">taskProcessor</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nx">retry</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
        <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中，</p>
<p>参数consumerTag在AMQP作为Broker时有意义；</p>
<p>参数concurrency用来实现任务并发调度的控制。</p>
<h2 id="任务获取">任务获取<a hidden class="anchor" aria-hidden="true" href="#任务获取">#</a></h2>
<p>在StartComsuming()中，分别启动了两个go程来并行处理任务，因为针对延时任务和普通任务，machinery将任务存放于两个不同的rediskey中。</p>
<ul>
<li>对于普通任务，使用nextTask()函数用来从broker中获取任务，在redis作为broker时，machinery使用了LIST类型来存储任务，而nextTask()中使用了BLPOP来阻塞式的读取任务.</li>
<li>对于延时任务，使用nextDelayTask()函数从redis中的ZSET中，根据score来优先获取最近的任务（score为ETA的对应的unixnano值）。</li>
</ul>
<p>具体来看nextTask()函数和nextDelayTask()函数，如下列出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// BLPOP出LIST中的数据
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">RedisBroker</span><span class="p">)</span> <span class="nf">nextTask</span><span class="p">(</span><span class="nx">queue</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">conn</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">open</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="nx">items</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">redis</span><span class="p">.</span><span class="nf">ByteSlices</span><span class="p">(</span><span class="nx">conn</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="s">&#34;BLPOP&#34;</span><span class="p">,</span> <span class="nx">queue</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{},</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">items</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{},</span> <span class="nx">redis</span><span class="p">.</span><span class="nx">ErrNil</span>
	<span class="p">}</span>

	<span class="nx">result</span> <span class="p">=</span> <span class="nx">items</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

	<span class="k">return</span> <span class="nx">result</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 结合WATCH，从ZSET中获取score最小的
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">RedisBroker</span><span class="p">)</span> <span class="nf">nextDelayedTask</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
   <span class="o">...</span>
   <span class="k">for</span> <span class="p">{</span>
      <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">pollPeriod</span><span class="p">)</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="s">&#34;WATCH&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
         <span class="k">return</span>
      <span class="p">}</span>

      <span class="nx">now</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UTC</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">()</span>

      <span class="nx">items</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">redis</span><span class="p">.</span><span class="nf">ByteSlices</span><span class="p">(</span><span class="nx">conn</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span>
         <span class="s">&#34;ZRANGEBYSCORE&#34;</span><span class="p">,</span>
         <span class="nx">key</span><span class="p">,</span>
         <span class="mi">0</span><span class="p">,</span>
         <span class="nx">now</span><span class="p">,</span>
         <span class="s">&#34;LIMIT&#34;</span><span class="p">,</span>
         <span class="mi">0</span><span class="p">,</span>
         <span class="mi">1</span><span class="p">,</span>
      <span class="p">))</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
         <span class="k">return</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">items</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
         <span class="nx">err</span> <span class="p">=</span> <span class="nx">redis</span><span class="p">.</span><span class="nx">ErrNil</span>
         <span class="k">return</span>
      <span class="p">}</span>

      <span class="nx">conn</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="s">&#34;MULTI&#34;</span><span class="p">)</span>
      <span class="nx">conn</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="s">&#34;ZREM&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="nx">reply</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="s">&#34;EXEC&#34;</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
         <span class="k">return</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="nx">reply</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
         <span class="nx">result</span> <span class="p">=</span> <span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
         <span class="k">break</span>
      <span class="p">}</span>
   <span class="p">}</span>

   <span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>特别需要注意的是，由于云服务的盛行，当下的云服务基本上都涵盖了redis服务，且提供了主备方案和集群方案等，但是不论时云服务或者时公司内部的redis服务，对BLPOP的支持可能会受限，这时候我们需要更改nextTask()函数中的BLPOP为LPOP来适应:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="cm">/*
</span><span class="cm">* modified at 20180717
</span><span class="cm">* use LPOP instead of BLPOP, cause L5 redis does not support BLPOP
</span><span class="cm">**/</span>
<span class="c1">// nextTask pops next available task from the default queue
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Broker</span><span class="p">)</span> <span class="nf">nextTask</span><span class="p">(</span><span class="nx">queue</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">conn</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">open</span><span class="p">()</span>
   <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

   <span class="nx">item</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">redis</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">(</span><span class="nx">conn</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="s">&#34;LPOP&#34;</span><span class="p">,</span> <span class="nx">queue</span><span class="p">))</span>
   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{},</span> <span class="nx">err</span>
   <span class="p">}</span>
   <span class="nx">result</span> <span class="p">=</span> <span class="nx">item</span>

   <span class="k">return</span> <span class="nx">result</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="任务查看">任务查看<a hidden class="anchor" aria-hidden="true" href="#任务查看">#</a></h2>
<p>在redis作为Broker时，machinery还提供了一个额外的接口实现（其他接口Broker存储介质未对该接口进行实现）<code>GetPendingTasks()</code>。顾名思义，GetPendingTasks()可以用来查看当前任务队列中处理pending状态，在等待被处理的任务的详细信息。</p>
<p>GetPendingTasks()函数，更多的可以理解为，是作者提供的“接口糖”，方便离线的对任务队列中的任务进行查看，当然，machinery中使用的几种第三方队列作为Broker，基本上都是支持这类数据的单独查看的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">RedisBroker</span><span class="p">)</span> <span class="nf">GetPendingTasks</span><span class="p">(</span><span class="nx">queue</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nx">dataBytes</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="s">&#34;LRANGE&#34;</span><span class="p">,</span> <span class="nx">queue</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">results</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">redis</span><span class="p">.</span><span class="nf">ByteSlices</span><span class="p">(</span><span class="nx">dataBytes</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">taskSignatures</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">results</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">result</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">results</span> <span class="p">{</span>
		<span class="nx">signature</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span>
		<span class="nx">decoder</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">result</span><span class="p">))</span>
		<span class="nx">decoder</span><span class="p">.</span><span class="nf">UseNumber</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">decoder</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">signature</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="nx">taskSignatures</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">signature</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">taskSignatures</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="任务发布">任务发布<a hidden class="anchor" aria-hidden="true" href="#任务发布">#</a></h2>
<p>Publish()接口是实现任务发布的函数，将在后续篇幅在对任务做介绍时再单独详细介绍。</p>
<h1 id="backend">Backend<a hidden class="anchor" aria-hidden="true" href="#backend">#</a></h1>
<p>Backend，同样是任务队列不可或缺的一部分，其作用主要是用来存储任务的执行结果的，machinery中支持Redis, Memcache, AMQP, MongoDB四种类型的存储介质来实现Backend。</p>
<p>machinery的Backend，根据其自身的功能特性，实现了以下这几种接口，与Broker类似，我们将重点介绍几个关键的接口（同样，以下接口是不同类型的Backend的实现的接口超集，并不是Redis作为介质时都有的）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Workflow相关接口
</span><span class="c1"></span>
<span class="nf">InitGroup</span><span class="p">(</span><span class="nx">groupUUID</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">taskUUIDs</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
<span class="nf">GroupCompleted</span><span class="p">(</span><span class="nx">groupUUID</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">groupTaskCount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="nf">GroupTaskStates</span><span class="p">(</span><span class="nx">groupUUID</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">groupTaskCount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">TaskState</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="nf">TriggerChord</span><span class="p">(</span><span class="nx">groupUUID</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

<span class="c1">// 任务状态设置接口
</span><span class="c1"></span><span class="nf">SetStatePending</span><span class="p">(</span><span class="nx">signature</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span> <span class="kt">error</span>
<span class="nf">SetStateReceived</span><span class="p">(</span><span class="nx">signature</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span> <span class="kt">error</span>
<span class="nf">SetStateStarted</span><span class="p">(</span><span class="nx">signature</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span> <span class="kt">error</span>
<span class="nf">SetStateRetry</span><span class="p">(</span><span class="nx">signature</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span> <span class="kt">error</span>
<span class="nf">SetStateSuccess</span><span class="p">(</span><span class="nx">signature</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">,</span> <span class="nx">results</span> <span class="p">[]</span><span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">TaskResult</span><span class="p">)</span> <span class="kt">error</span>
<span class="nf">SetStateFailure</span><span class="p">(</span><span class="nx">signature</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
<span class="nf">GetState</span><span class="p">(</span><span class="nx">taskUUID</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">TaskState</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

<span class="c1">// Purging stored stored tasks states and group meta data
</span><span class="c1"></span><span class="nf">PurgeState</span><span class="p">(</span><span class="nx">taskUUID</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
<span class="nf">PurgeGroupMeta</span><span class="p">(</span><span class="nx">groupUUID</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="workflow">Workflow<a hidden class="anchor" aria-hidden="true" href="#workflow">#</a></h2>
<p>我们可以看到，第一批接口有Group和Chord相关的字眼，这就是我们在一开始提到的machinery中Workflow机制。Workflow极大的使能了任务队列的功能，使得machinery更加得心应手。关于Workflow的知识，我们将在下面的篇幅中详细介绍，这儿仅仅简单的介绍这几个接口的功能。</p>
<ul>
<li>
<p>InitGroup()，顾名思义，在创建一个Group任务；</p>
</li>
<li>
<p>GroupCompleted(),检查一个Group中所有的任务是否都执行完毕；</p>
</li>
<li>
<p>GroupTaskStates()，返回一个Group中，所有任务的状态</p>
</li>
<li>
<p>TriggerChord()，当Group中任务全部执行完毕后，触发Chrod任务</p>
</li>
</ul>
<h2 id="state">State<a hidden class="anchor" aria-hidden="true" href="#state">#</a></h2>
<p>machinery中将任务的状态进行了很详细的划分，通过接口我们就可以看到，machinery支持了以下几种任务中间态：</p>
<ul>
<li>Pending，任务到达Broker</li>
<li>Received，任务从Broker中读取成功</li>
<li>Started，任务开始执行</li>
<li>Retry，任务需要重试</li>
<li>Success，任务执行成功</li>
<li>Failure，任务执行失败</li>
</ul>
<p>下面简单列出源码中设置状态接口的使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// SetStatePending updates task state to PENDING
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">RedisBackend</span><span class="p">)</span> <span class="nf">SetStatePending</span><span class="p">(</span><span class="nx">signature</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
   <span class="nx">taskState</span> <span class="o">:=</span> <span class="nx">tasks</span><span class="p">.</span><span class="nf">NewPendingTaskState</span><span class="p">(</span><span class="nx">signature</span><span class="p">)</span>
   <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nf">updateState</span><span class="p">(</span><span class="nx">taskState</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// SetStateReceived updates task state to RECEIVED
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">RedisBackend</span><span class="p">)</span> <span class="nf">SetStateReceived</span><span class="p">(</span><span class="nx">signature</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
   <span class="nx">taskState</span> <span class="o">:=</span> <span class="nx">tasks</span><span class="p">.</span><span class="nf">NewReceivedTaskState</span><span class="p">(</span><span class="nx">signature</span><span class="p">)</span>
   <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nf">updateState</span><span class="p">(</span><span class="nx">taskState</span><span class="p">)</span>
<span class="p">}</span>
<span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="worker">Worker<a hidden class="anchor" aria-hidden="true" href="#worker">#</a></h1>
<p>Worker负责了任务队列的执行单元，是任务队列中处理任务的关键元素，也是因此，Worker的接口很少，很直接：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">Launch</span><span class="p">()</span> 
<span class="nf">LaunchAsync</span><span class="p">(</span><span class="nx">errorsChan</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">error</span><span class="p">)</span>
<span class="nf">Quit</span><span class="p">()</span>
<span class="nf">Process</span><span class="p">(</span><span class="nx">signature</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="启动和停止-1">启动和停止<a hidden class="anchor" aria-hidden="true" href="#启动和停止-1">#</a></h2>
<p>Worker启动是通过Launch()启动了一个进程，去订阅默认的任务队列，并且处理收到的任务。LaunchAsync()是Launch()的非阻塞版本，而通过Launch()中的代码，我们发现，其实就是调用了LaunchAsync()。</p>
<p>在LaunchAsync()中，通过开启一个go程，实现了非阻塞式的调用了Broker的StartConsuming()函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">worker</span> <span class="o">*</span><span class="nx">Worker</span><span class="p">)</span> <span class="nf">Launch</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
   <span class="nx">errorsChan</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">)</span>
   <span class="nx">worker</span><span class="p">.</span><span class="nf">LaunchAsync</span><span class="p">(</span><span class="nx">errorsChan</span><span class="p">)</span>
   <span class="k">return</span> <span class="o">&lt;-</span><span class="nx">errorsChan</span>
<span class="p">}</span>

<span class="c1">// Launch()的非阻塞调用
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">worker</span> <span class="o">*</span><span class="nx">Worker</span><span class="p">)</span> <span class="nf">LaunchAsync</span><span class="p">(</span><span class="nx">errorsChan</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
   <span class="o">...</span>
   <span class="c1">// broker消费者go程，同时负责与broker的断开重连等
</span><span class="c1"></span>   <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">{</span>
         <span class="nx">retry</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">broker</span><span class="p">.</span><span class="nf">StartConsuming</span><span class="p">(</span><span class="nx">worker</span><span class="p">.</span><span class="nx">ConsumerTag</span><span class="p">,</span> <span class="nx">worker</span><span class="p">.</span><span class="nx">Concurrency</span><span class="p">,</span> <span class="nx">worker</span><span class="p">)</span>

         <span class="k">if</span> <span class="nx">retry</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">worker</span><span class="p">.</span><span class="nx">errorHandler</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
               <span class="nx">worker</span><span class="p">.</span><span class="nf">errorHandler</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
               <span class="nx">log</span><span class="p">.</span><span class="nx">WARNING</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Broker failed with error: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="p">}</span>
         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">errorsChan</span> <span class="o">&lt;-</span> <span class="nx">err</span> <span class="c1">// stop the goroutine
</span><span class="c1"></span>            <span class="k">return</span>
         <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">}()</span>
   <span class="o">...</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Worker停止是通过Quit(）函数来实现，其调用了Broker的StopConsuming()函数，以实现gracefully stop。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Quit tears down the running worker process
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">worker</span> <span class="o">*</span><span class="nx">Worker</span><span class="p">)</span> <span class="nf">Quit</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">worker</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">GetBroker</span><span class="p">().</span><span class="nf">StopConsuming</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="处理">处理<a hidden class="anchor" aria-hidden="true" href="#处理">#</a></h2>
<p>Worker中的Process()函数，将会处理在Broker中的待处理任务，并且负责了任务回调的触发功能。Process()函数的任务流程主要是：</p>
<p>任务检测-&gt;任务获取-&gt;任务预处理-&gt;Tracing处理-&gt;任务执行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">worker</span> <span class="o">*</span><span class="nx">Worker</span><span class="p">)</span> <span class="nf">Process</span><span class="p">(</span><span class="nx">signature</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
   <span class="o">...</span>
   <span class="c1">//根据任务名，获取注册任务
</span><span class="c1"></span>   <span class="nx">taskFunc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">worker</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">GetRegisteredTask</span><span class="p">(</span><span class="nx">signature</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">nil</span>
   <span class="p">}</span>

   <span class="c1">// 更新任务状态 Received
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">worker</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">GetBackend</span><span class="p">().</span><span class="nf">SetStateReceived</span><span class="p">(</span><span class="nx">signature</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Set state received error: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
   <span class="p">}</span>

   <span class="c1">// 任务预处理，预防任务出错，导致后面影响worker的运行
</span><span class="c1"></span>   <span class="nx">task</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tasks</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">taskFunc</span><span class="p">,</span> <span class="nx">signature</span><span class="p">.</span><span class="nx">Args</span><span class="p">)</span>
   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">worker</span><span class="p">.</span><span class="nf">taskFailed</span><span class="p">(</span><span class="nx">signature</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
      <span class="k">return</span> <span class="nx">err</span>
   <span class="p">}</span>

   <span class="c1">// tracing处理   
</span><span class="c1"></span>   <span class="nx">taskSpan</span> <span class="o">:=</span> <span class="nx">tracing</span><span class="p">.</span><span class="nf">StartSpanFromHeaders</span><span class="p">(</span><span class="nx">signature</span><span class="p">.</span><span class="nx">Headers</span><span class="p">,</span> <span class="nx">signature</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
   <span class="nx">tracing</span><span class="p">.</span><span class="nf">AnnotateSpanWithSignatureInfo</span><span class="p">(</span><span class="nx">taskSpan</span><span class="p">,</span> <span class="nx">signature</span><span class="p">)</span>
   <span class="nx">task</span><span class="p">.</span><span class="nx">Context</span> <span class="p">=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">ContextWithSpan</span><span class="p">(</span><span class="nx">task</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">taskSpan</span><span class="p">)</span>

   <span class="c1">// 更新任务状态 Started
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">worker</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">GetBackend</span><span class="p">().</span><span class="nf">SetStateStarted</span><span class="p">(</span><span class="nx">signature</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Set state started error: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
   <span class="p">}</span>

   <span class="c1">// 任务执行
</span><span class="c1"></span>   <span class="nx">results</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">task</span><span class="p">.</span><span class="nf">Call</span><span class="p">()</span>
   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="c1">// If a tasks.ErrRetryTaskLater was returned from the task,
</span><span class="c1"></span>      <span class="c1">// retry the task after specified duration
</span><span class="c1"></span>      <span class="nx">retriableErr</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="kd">interface</span><span class="p">{}(</span><span class="nx">err</span><span class="p">).(</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">ErrRetryTaskLater</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
         <span class="k">return</span> <span class="nx">worker</span><span class="p">.</span><span class="nf">retryTaskIn</span><span class="p">(</span><span class="nx">signature</span><span class="p">,</span> <span class="nx">retriableErr</span><span class="p">.</span><span class="nf">RetryIn</span><span class="p">())</span>
      <span class="p">}</span>

      <span class="c1">// Otherwise, execute default retry logic based on signature.RetryCount
</span><span class="c1"></span>      <span class="c1">// and signature.RetryTimeout values
</span><span class="c1"></span>      <span class="k">if</span> <span class="nx">signature</span><span class="p">.</span><span class="nx">RetryCount</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
         <span class="k">return</span> <span class="nx">worker</span><span class="p">.</span><span class="nf">taskRetry</span><span class="p">(</span><span class="nx">signature</span><span class="p">)</span>
      <span class="p">}</span>

      <span class="k">return</span> <span class="nx">worker</span><span class="p">.</span><span class="nf">taskFailed</span><span class="p">(</span><span class="nx">signature</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
   <span class="p">}</span>

   <span class="k">return</span> <span class="nx">worker</span><span class="p">.</span><span class="nf">taskSucceeded</span><span class="p">(</span><span class="nx">signature</span><span class="p">,</span> <span class="nx">results</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>machinery中，主要是通过反射实现了任务执行，具体的执行方式，在获取了函数之后与普通的反射无异，详细的介绍在后续篇幅介绍。关于任务执行之后的处理，有可能三种处理：</p>
<p>任务执行成功:</p>
<p>taskSucceeded()，是在一个任务被成功执行后调用，主要负责更新任务状态、触发回调函数或者chord任务中的回调函数（前提是该task是chrod的分组任务中的最后一个任务），关于chord任务，在后面关于Workflow模式中将会详细介绍。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">worker</span> <span class="o">*</span><span class="nx">Worker</span><span class="p">)</span> <span class="nf">taskSucceeded</span><span class="p">(</span><span class="nx">signature</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">,</span> <span class="nx">taskResults</span> <span class="p">[]</span><span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">TaskResult</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">// 更新任务状态
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">worker</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">GetBackend</span><span class="p">().</span><span class="nf">SetStateSuccess</span><span class="p">(</span><span class="nx">signature</span><span class="p">,</span> <span class="nx">taskResults</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Set state success error: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="o">...</span>
	<span class="c1">// 回调任务
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">successTask</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">signature</span><span class="p">.</span><span class="nx">OnSuccess</span> <span class="p">{</span>
        <span class="c1">// 当immutable为false时，传递参数
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">signature</span><span class="p">.</span><span class="nx">Immutable</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
			<span class="c1">// Pass results of the task to success callbacks
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">taskResult</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">taskResults</span> <span class="p">{</span>
				<span class="nx">successTask</span><span class="p">.</span><span class="nx">Args</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">successTask</span><span class="p">.</span><span class="nx">Args</span><span class="p">,</span> <span class="nx">tasks</span><span class="p">.</span><span class="nx">Arg</span><span class="p">{</span>
					<span class="nx">Type</span><span class="p">:</span>  <span class="nx">taskResult</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span>
					<span class="nx">Value</span><span class="p">:</span> <span class="nx">taskResult</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span>
				<span class="p">})</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">worker</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">SendTask</span><span class="p">(</span><span class="nx">successTask</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="o">...</span>
	<span class="c1">// 触发chord任务的回掉函数
</span><span class="c1"></span>	<span class="nx">shouldTrigger</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">worker</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">GetBackend</span><span class="p">().</span><span class="nf">TriggerChord</span><span class="p">(</span><span class="nx">signature</span><span class="p">.</span><span class="nx">GroupUUID</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Trigger chord error: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
        <span class="o">...</span>
	<span class="c1">// 针对group任务的返回值做参数传递
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">taskState</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">taskStates</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">taskState</span><span class="p">.</span><span class="nf">IsSuccess</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">signature</span><span class="p">.</span><span class="nx">ChordCallback</span><span class="p">.</span><span class="nx">Immutable</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">taskResult</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">taskState</span><span class="p">.</span><span class="nx">Results</span> <span class="p">{</span>
				<span class="nx">signature</span><span class="p">.</span><span class="nx">ChordCallback</span><span class="p">.</span><span class="nx">Args</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">signature</span><span class="p">.</span><span class="nx">ChordCallback</span><span class="p">.</span><span class="nx">Args</span><span class="p">,</span> <span class="nx">tasks</span><span class="p">.</span><span class="nx">Arg</span><span class="p">{</span>
					<span class="nx">Type</span><span class="p">:</span>  <span class="nx">taskResult</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span>
					<span class="nx">Value</span><span class="p">:</span> <span class="nx">taskResult</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span>
				<span class="p">})</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 发送chord任务
</span><span class="c1"></span>	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">worker</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">SendTask</span><span class="p">(</span><span class="nx">signature</span><span class="p">.</span><span class="nx">ChordCallback</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>任务执行失败:</p>
<p>taskFailed()，是在一个任务执行失败（完全失败，即重试也失败）后调用。需要负责更新任务状态，并触发OnError回调函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">worker</span> <span class="o">*</span><span class="nx">Worker</span><span class="p">)</span> <span class="nf">taskFailed</span><span class="p">(</span><span class="nx">signature</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">,</span> <span class="nx">taskErr</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
   <span class="c1">// 任务状态更新 Failure
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">worker</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">GetBackend</span><span class="p">().</span><span class="nf">SetStateFailure</span><span class="p">(</span><span class="nx">signature</span><span class="p">,</span> <span class="nx">taskErr</span><span class="p">.</span><span class="nf">Error</span><span class="p">());</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Set state failure error: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
   <span class="p">}</span>

   <span class="o">...</span>
   <span class="c1">// Trigger error callbacks
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">errorTask</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">signature</span><span class="p">.</span><span class="nx">OnError</span> <span class="p">{</span>
      <span class="c1">// Pass error as a first argument to error callbacks
</span><span class="c1"></span>      <span class="nx">args</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">([]</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Arg</span><span class="p">{{</span>
         <span class="nx">Type</span><span class="p">:</span>  <span class="s">&#34;string&#34;</span><span class="p">,</span>
         <span class="nx">Value</span><span class="p">:</span> <span class="nx">taskErr</span><span class="p">.</span><span class="nf">Error</span><span class="p">(),</span>
      <span class="p">}},</span> <span class="nx">errorTask</span><span class="p">.</span><span class="nx">Args</span><span class="o">...</span><span class="p">)</span>
      <span class="nx">errorTask</span><span class="p">.</span><span class="nx">Args</span> <span class="p">=</span> <span class="nx">args</span>
      <span class="nx">worker</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">SendTask</span><span class="p">(</span><span class="nx">errorTask</span><span class="p">)</span>
   <span class="p">}</span>

   <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>任务重试:</p>
<p>关于任务重试，machinery中提供了两种方式来实现。</p>
<ol>
<li>
<p>machinery中通过设置任务的RetryCount和RetryTimeout参数来实现。</p>
</li>
<li>
<p>通过返回一个ErrRetryTaskLater类型的值来制定。</p>
</li>
</ol>
<p>由于任务重试，需要依赖于对machinery中任务数据结构的了解，我们将在之后详细介绍。</p>
<h1 id="配置方案">配置方案<a hidden class="anchor" aria-hidden="true" href="#配置方案">#</a></h1>
<p>为了掌握如何使用machinery，本文将会同时从调用代码和machinery源码来进行详细介绍，同时将会在每份代码段的初始部分分别标识出。在我们对使用方法进行介绍之前，首先通过machinery的启动配置文件来一探是如何衔接起各个工作模块的。在machinery中，支持两种配置方式，分别是：</p>
<ul>
<li>基于yaml文件的配置</li>
<li>基于环境变量的配置</li>
</ul>
<h2 id="基于配置文件">基于配置文件<a hidden class="anchor" aria-hidden="true" href="#基于配置文件">#</a></h2>
<p>对于配置文件，machinery中支持的格式为yaml，下面是一个基本的machinery的配置文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="c"># machinery.yaml</span><span class="w">
</span><span class="w"></span><span class="nt">broker</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;redis://123456@localhost:6379&#39;</span><span class="w">
</span><span class="w"></span><span class="c">#broker: &#39;amqp://guest:guest@localhost:5672/&#39;</span><span class="w">
</span><span class="w"></span><span class="c">#broker: &#39;https://sqs.us-west-2.amazonaws.com/123456789012&#39;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">default_queue</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;machinery_tasks&#39;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">result_backend</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;redis://123456@localhost:6379&#39;</span><span class="w">
</span><span class="w"></span><span class="c">#result_backend: &#39;memcache://localhost:11211&#39;</span><span class="w">
</span><span class="w"></span><span class="c">#result_backend: &#39;mongodb://localhost:27017&#39;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">results_expire_in</span><span class="p">:</span><span class="w"> </span><span class="m">36000</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">amqp</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">binding_key</span><span class="p">:</span><span class="w"> </span><span class="l">machinery_task</span><span class="w">
</span><span class="w">  </span><span class="nt">exchange</span><span class="p">:</span><span class="w"> </span><span class="l">machinery_exchange</span><span class="w">
</span><span class="w">  </span><span class="nt">exchange_type</span><span class="p">:</span><span class="w"> </span><span class="l">direct</span><span class="w">
</span><span class="w">  </span><span class="nt">prefetch_count</span><span class="p">:</span><span class="w"> </span><span class="m">3</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>其中，</p>
<ul>
<li>broker：broker的地址，可以根据实际使用的存储介质，分别指定Redis、AMQP或AWS SQS；</li>
<li>default_queue：broker默认存放任务的队列名称；</li>
<li>result_backend：backend配置，用来指定存放结果的介质的配置。可以根据需求，分别制定Redis、memchache或mongodb等；</li>
<li>results_expire_in：任务执行结果记录留存于backend保留时间，单位为秒；</li>
<li>amqp：为当我们使用AMQP是的详细配置信息；</li>
</ul>
<p>上面展示的，是一个基本版的配置文件，而machinery中的所有配置，我们可以通过下方的数据结构来了解：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 源码
</span><span class="c1">// machinery完整的配置结构
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Config</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Broker</span>          <span class="kt">string</span>       <span class="s">`yaml:&#34;broker&#34; envconfig:&#34;BROKER&#34;`</span>
	<span class="nx">DefaultQueue</span>    <span class="kt">string</span>       <span class="s">`yaml:&#34;default_queue&#34; envconfig:&#34;DEFAULT_QUEUE&#34;`</span>
	<span class="nx">ResultBackend</span>   <span class="kt">string</span>       <span class="s">`yaml:&#34;result_backend&#34; envconfig:&#34;RESULT_BACKEND&#34;`</span>
	<span class="nx">ResultsExpireIn</span> <span class="kt">int</span>          <span class="s">`yaml:&#34;results_expire_in&#34; envconfig:&#34;RESULTS_EXPIRE_IN&#34;`</span>
	<span class="nx">AMQP</span>            <span class="o">*</span><span class="nx">AMQPConfig</span>  <span class="s">`yaml:&#34;amqp&#34;`</span>
	<span class="nx">SQS</span>             <span class="o">*</span><span class="nx">SQSConfig</span>   <span class="s">`yaml:&#34;sqs&#34;`</span>
	<span class="nx">Redis</span>           <span class="o">*</span><span class="nx">RedisConfig</span> <span class="s">`yaml:&#34;redis&#34;`</span>
	<span class="nx">TLSConfig</span>       <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span>
	<span class="c1">// NoUnixSignals - when set disables signal handling in machinery
</span><span class="c1"></span>	<span class="nx">NoUnixSignals</span> <span class="kt">bool</span>            <span class="s">`yaml:&#34;no_unix_signals&#34; envconfig:&#34;NO_UNIX_SIGNALS&#34;`</span>
	<span class="nx">DynamoDB</span>      <span class="o">*</span><span class="nx">DynamoDBConfig</span> <span class="s">`yaml:&#34;dynamodb&#34;`</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>调用yaml文件的配置方式，通过NewFromYaml()接口来完成，NewFromYaml()的基本逻辑中，主要是实现了一个加载配置的函数和reload配置的逻辑，而默认reload间隔reloadDelay为10s：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 源码
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewFromYaml</span><span class="p">(</span><span class="nx">cnfPath</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">keepReloading</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Config</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">cnf</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">fromFile</span><span class="p">(</span><span class="nx">cnfPath</span><span class="p">)</span>
   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
   <span class="p">}</span>
   <span class="k">if</span> <span class="nx">keepReloading</span> <span class="p">{</span>
      <span class="c1">// 通过go程，实现定时reload配置
</span><span class="c1"></span>      <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
         <span class="k">for</span> <span class="p">{</span>
            <span class="c1">// Delay after each request
</span><span class="c1"></span>            <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">reloadDelay</span><span class="p">)</span>
            <span class="c1">// Attempt to reload the config
</span><span class="c1"></span>            <span class="nx">newCnf</span><span class="p">,</span> <span class="nx">newErr</span> <span class="o">:=</span> <span class="nf">fromFile</span><span class="p">(</span><span class="nx">cnfPath</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">newErr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
               <span class="nx">log</span><span class="p">.</span><span class="nx">WARNING</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to reload config from file %s: %v&#34;</span><span class="p">,</span> <span class="nx">cnfPath</span><span class="p">,</span> <span class="nx">newErr</span><span class="p">)</span>
               <span class="k">continue</span>
            <span class="p">}</span>
            <span class="o">*</span><span class="nx">cnf</span> <span class="p">=</span> <span class="o">*</span><span class="nx">newCnf</span>
         <span class="p">}</span>
      <span class="p">}()</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">cnf</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="基于环境变量">基于环境变量<a hidden class="anchor" aria-hidden="true" href="#基于环境变量">#</a></h2>
<p>上面提到，machinery的配置文件方式只支持yaml，然而并不是所有项目都是采用了yaml文件，例如我们目前项目中配置文件普遍使用了toml文件。这样，为了使用machinery就必须在一个项目出现了两个配置文件（项目的toml文件和machinery的yaml文件）。然而，做技术的一般都是有强迫症的，两个配置文件存在于一个项目的确是一个十分ugly的现象，为了解决这一问题，machinery的环境变量配置模式的作用就体现出来了。</p>
<p>基于环境变量的源码与基于配置的结构类似，不在此列出。由于支持了基于环境变量的配置初始化，那么，我们可以将所有的配置均放在同一个配置文件中（对于我们的项目来说，即为toml文件），并在项目init阶段，将machinery的配置从toml文件中全部加载到临时环境变量并读取，从而曲线救国，解决了多配置文件的问题，简单示例如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 调用代码
</span><span class="c1">//首先将配置文件加载到内存appConfig结构中
</span><span class="c1">// （具体加载到内存中的方法很多，每个项目都有自己的方式，略去）
</span><span class="c1"></span>
<span class="c1">//然后将相关配置加载到环境变量
</span><span class="c1"></span><span class="nx">os</span><span class="p">.</span><span class="nf">Setenv</span><span class="p">(</span><span class="s">&#34;BROKER&#34;</span><span class="p">,</span> <span class="nx">brokerValue</span><span class="p">)</span>
<span class="nx">os</span><span class="p">.</span><span class="nf">Setenv</span><span class="p">(</span><span class="s">&#34;REDIS_MAX_IDLE&#34;</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">appConfig</span><span class="p">.</span><span class="nf">GetInt</span><span class="p">(</span><span class="s">&#34;redis.maxidle&#34;</span><span class="p">)))</span> <span class="c1">//从toml中读取参数
</span><span class="c1"></span><span class="nx">os</span><span class="p">.</span><span class="nf">Setenv</span><span class="p">(</span><span class="s">&#34;REDIS_MAX_ACTIVE&#34;</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">appConfig</span><span class="p">.</span><span class="nf">GetInt</span><span class="p">(</span><span class="s">&#34;redis.maxactive&#34;</span><span class="p">)))</span>
<span class="nx">os</span><span class="p">.</span><span class="nf">Setenv</span><span class="p">(</span><span class="s">&#34;REDIS_IDLE_TIMEOUT&#34;</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">appConfig</span><span class="p">.</span><span class="nf">GetInt</span><span class="p">(</span><span class="s">&#34;redis.idletimeout&#34;</span><span class="p">)))</span>
<span class="nx">os</span><span class="p">.</span><span class="nf">Setenv</span><span class="p">(</span><span class="s">&#34;REDIS_READ_TIMEOUT&#34;</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">appConfig</span><span class="p">.</span><span class="nf">GetInt</span><span class="p">(</span><span class="s">&#34;redis.readtimeout&#34;</span><span class="p">)))</span>
<span class="nx">os</span><span class="p">.</span><span class="nf">Setenv</span><span class="p">(</span><span class="s">&#34;REDIS_WRITE_TIMEOUT&#34;</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">appConfig</span><span class="p">.</span><span class="nf">GetInt</span><span class="p">(</span><span class="s">&#34;redis.writetimeout&#34;</span><span class="p">)))</span>
<span class="nx">os</span><span class="p">.</span><span class="nf">Setenv</span><span class="p">(</span><span class="s">&#34;REDIS_CONNECT_TIMEOUT&#34;</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">appConfig</span><span class="p">.</span><span class="nf">GetInt</span><span class="p">(</span><span class="s">&#34;redis.connecttimeout&#34;</span><span class="p">)))</span>

<span class="c1">//通过NewFromEnvironment()函数加载环境变量
</span><span class="c1"></span><span class="nx">config</span><span class="p">.</span><span class="nf">NewFromEnvironment</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="任务">任务<a hidden class="anchor" aria-hidden="true" href="#任务">#</a></h1>
<p>从框架设计到逻辑原理，说了这么久的任务队列，任务，才是所有任务队列中的最基础的元素。从代码层面来看，一个任务就是一个执行函数。结合上篇文章中介绍过的machinery架构，我们可以知道在 machinery中，一个典型的处理流程，即为：</p>
<ul>
<li>任务创建</li>
<li>任务注册</li>
<li>任务发布</li>
<li>任务执行</li>
<li>结果获取</li>
</ul>
<p>在下面的篇幅中，我们分别就上述步骤，从使用方法和原理同时解析，来详细介绍在machinery中如何操作和实现这几个过程。</p>
<h2 id="结构">结构<a hidden class="anchor" aria-hidden="true" href="#结构">#</a></h2>
<p>在详细介绍machinery如何处理一次任务流程之前，我们需要首先知道，究竟在machinery中一个任务的数据结构是什么样子的。在machinery的源码世界里，我们可以理解将一个任务称作为Signature，其数据结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 源码
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Signature</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">UUID</span>           <span class="kt">string</span>
        <span class="nx">Name</span>           <span class="kt">string</span>
        <span class="nx">RoutingKey</span>     <span class="kt">string</span>
        <span class="nx">ETA</span>            <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
        <span class="nx">GroupUUID</span>      <span class="kt">string</span>
        <span class="nx">GroupTaskCount</span> <span class="kt">int</span>
        <span class="nx">Args</span>           <span class="p">[]</span><span class="nx">Arg</span>
        <span class="nx">Headers</span>        <span class="nx">Headers</span>
        <span class="nx">Immutable</span>      <span class="kt">bool</span>
        <span class="nx">RetryCount</span>     <span class="kt">int</span>
        <span class="nx">RetryTimeout</span>   <span class="kt">int</span>
        <span class="nx">OnSuccess</span>      <span class="p">[]</span><span class="o">*</span><span class="nx">Signature</span>
        <span class="nx">OnError</span>        <span class="p">[]</span><span class="o">*</span><span class="nx">Signature</span>
        <span class="nx">ChordCallback</span>  <span class="o">*</span><span class="nx">Signature</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们介绍几个有意义的参数：</p>
<ul>
<li>UUID，任务的unique ID，可以主动设定也可以由系统自行设定；</li>
<li>Name，任务的名称，用于识别任务；</li>
<li>RoutingKey，根据这个key，用于将任务扔到一个正确的队列中；</li>
<li>ETA，专用于延时任务，若该参数为nil，说明需要立即将该任务扔给worker，否则，在参数数值到来之前，该任务将一直delay；</li>
<li>GroupUUID和GroupTaskCount，用于workflow中的Group分组任务创建</li>
<li>Args，任务传递给worker时的参数列表</li>
<li>Headers，用于tracing</li>
<li>RetryCount和RetryTimeout，用于实现任务的重试机制</li>
<li>Immutable，该参数可以控制任务之间是否需要参数传递</li>
<li>OnSuccess和OnError，实现回调，workflow中的链式任务（chain），就是通过OnSuccess来实现链式调度</li>
<li>ChordCallback，workflow中的chord模式，在group内所有任务全部执行完成后，进行callback。</li>
</ul>
<h2 id="创建任务">创建任务<a hidden class="anchor" aria-hidden="true" href="#创建任务">#</a></h2>
<p>任务的创建在machinery中十分简单，其实就是生成一个Signature的实例，我们看下面的示例代码中，我们创建了一个名为 “audience.DownloadFromCos”的任务，指定了该任务的重试次数为2，重试超时时间为3s，同时设定了两个参数到Args中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 业务代码
</span><span class="c1"></span><span class="kd">const</span><span class="p">(</span>
    <span class="nx">TASK_RETRY_COUNT</span> <span class="p">=</span> <span class="mi">2</span>
    <span class="nx">TASK_RETRY_TIMEOUT</span> <span class="p">=</span> <span class="mi">3</span>
<span class="p">)</span>

<span class="o">...</span>

<span class="kd">func</span> <span class="nf">buildDownloadFromCos</span><span class="p">(</span><span class="nx">appId</span><span class="p">,</span> <span class="nx">bucketName</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;audience.DownloadFromCos&#34;</span><span class="p">,</span>
		<span class="nx">RetryCount</span><span class="p">:</span> <span class="nx">TASK_RETRY_COUNT</span><span class="p">,</span>
		<span class="nx">RetryTimeout</span><span class="p">:</span> <span class="nx">TASK_RETRY_TIMEOUT</span><span class="p">,</span>
		<span class="nx">Args</span><span class="p">:</span> <span class="p">[]</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Arg</span><span class="p">{</span>
			<span class="p">{</span>
				<span class="nx">Type</span><span class="p">:</span> <span class="s">&#34;string&#34;</span><span class="p">,</span>
				<span class="nx">Value</span><span class="p">:</span> <span class="nx">appId</span><span class="p">,</span>
			<span class="p">},</span>
			<span class="p">{</span>
				<span class="nx">Type</span><span class="p">:</span> <span class="s">&#34;string&#34;</span><span class="p">,</span>
				<span class="nx">Value</span><span class="p">:</span> <span class="nx">bucketName</span><span class="p">,</span>
			<span class="p">},</span>
		<span class="p">},</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="注册任务">注册任务<a hidden class="anchor" aria-hidden="true" href="#注册任务">#</a></h2>
<p>当任务创建完毕后，我们需要将任务注册到broker中才可供worker识别以调用。machinery中提供了一个RegisterTasks()函数来接受任务的注册，下面的代码中，我们将上述的DownloadFromCos()和另一个ParseCosFile()任务分别以名称为“audience.DownloadFromCos”和“audience.ParseCosFile”注册到machinery中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 调用代码
</span><span class="c1">// 注册任务
</span><span class="c1"></span><span class="nx">tasks</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
   <span class="s">&#34;audience.DownloadFromCos&#34;</span><span class="p">:</span> <span class="nx">DownloadFromCos</span><span class="p">,</span>
   <span class="s">&#34;audience.ParseCosFile&#34;</span><span class="p">:</span> <span class="nx">ParseCosFile</span><span class="p">,</span>
 <span class="p">}</span>
<span class="nx">server</span><span class="p">.</span><span class="nf">RegisterTasks</span><span class="p">(</span><span class="nx">tasks</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>RegisterTasks()会将所有的tasks加载到成员变量registeredTasks(同样为一个map类型)中，同时将通过调用broker接口SetRegisteredTaskNames()，将tasks名称注册到broker中，从而在broker之后接收到待处理任务之后可以判断是否为合法已注册任务：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 源码
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">server</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">RegisterTasks</span><span class="p">(</span><span class="nx">namedTaskFuncs</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">task</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">namedTaskFuncs</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tasks</span><span class="p">.</span><span class="nf">ValidateTask</span><span class="p">(</span><span class="nx">task</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">server</span><span class="p">.</span><span class="nx">registeredTasks</span> <span class="p">=</span> <span class="nx">namedTaskFuncs</span>
	
	<span class="nx">server</span><span class="p">.</span><span class="nx">broker</span><span class="p">.</span><span class="nf">SetRegisteredTaskNames</span><span class="p">(</span><span class="nx">server</span><span class="p">.</span><span class="nf">GetRegisteredTaskNames</span><span class="p">())</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="o">...</span>

<span class="c1">// SetRegisteredTaskNames函数
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Broker</span><span class="p">)</span> <span class="nf">SetRegisteredTaskNames</span><span class="p">(</span><span class="nx">names</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">registeredTaskNames</span> <span class="p">=</span> <span class="nx">names</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="发布任务">发布任务<a hidden class="anchor" aria-hidden="true" href="#发布任务">#</a></h2>
<p>通过发布任务，broker中才会收到具体的任务内容。machinery中的任务提供了多种任务类型（主要是与Workflow相关，下文会详述），不同的任务有着类似但不相同的发布方法。在当前章节中，我们将首先介绍最基本的普通任务的发布：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 业务代码
</span><span class="c1">// 发送一个任务，taskObj由buildDownloadFromCos()返回
</span><span class="c1"></span><span class="nx">asyncResult</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">machinery</span><span class="p">.</span><span class="nf">SendTask</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">taskObj</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="nx">log</span><span class="p">.</span><span class="nf">LoggerFromContextWithCaller</span><span class="p">(</span><span class="nx">ctx</span><span class="p">).</span><span class="nf">Errorf</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
   <span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>SendTask()中会调用Publish()函数去发布任务到broker，我们看到Publish()函数接受一个Signature类型的变量，首先将会根据任务参数ETA去判断任务类型是实时任务还是延时任务，从而扔到不同的任务队列中。一旦任务被扔到Broker中，worker就可以去获取并执行任务了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 源码
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">redisDelayedTasksKey</span> <span class="p">=</span> <span class="s">&#34;delayed_tasks&#34;</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">RedisBroker</span><span class="p">)</span> <span class="nf">Publish</span><span class="p">(</span><span class="nx">signature</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
        <span class="o">...</span>
	<span class="c1">// 根据ETA判断普通任务还是延时任务
</span><span class="c1"></span>  <span class="c1">// ETA不为nil，延时任务，将ETA作为score到ZSET
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">signature</span><span class="p">.</span><span class="nx">ETA</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">now</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UTC</span><span class="p">()</span>

		<span class="k">if</span> <span class="nx">signature</span><span class="p">.</span><span class="nx">ETA</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">score</span> <span class="o">:=</span> <span class="nx">signature</span><span class="p">.</span><span class="nx">ETA</span><span class="p">.</span><span class="nf">UnixNano</span><span class="p">()</span>
                        
			<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="s">&#34;ZADD&#34;</span><span class="p">,</span> <span class="nx">redisDelayedTasksKey</span><span class="p">,</span> <span class="nx">score</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>

  <span class="c1">// ETA为nil，普通任务，到LIST
</span><span class="c1"></span>	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="s">&#34;RPUSH&#34;</span><span class="p">,</span> <span class="nx">signature</span><span class="p">.</span><span class="nx">RoutingKey</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="获取结果">获取结果<a hidden class="anchor" aria-hidden="true" href="#获取结果">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 业务代码
</span><span class="c1">// asyncResult由上述发布任务函数machinery.SendTask()所返回
</span><span class="c1"></span><span class="nx">results</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">asyncResult</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">5</span><span class="p">))</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">LoggerWrapperWithCaller</span><span class="p">().</span><span class="nf">Errorf</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
        <span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中，asyncResult.Get()函数为一个异步阻塞函数，根据设定的参数轮询从backends中获取任务执行结果。以redis作为backends时为例，每一个任务的执行结果会存储于一条redis的key-value中，所以Get()函数最终会调用GET方法，根据任务的UUID，去redis中获取结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 源码
</span><span class="c1">// 根据uuid，获取该任务最近的状态 
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">RedisBackend</span><span class="p">)</span> <span class="nf">GetState</span><span class="p">(</span><span class="nx">taskUUID</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">TaskState</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">conn</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">open</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="nx">item</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">redis</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">(</span><span class="nx">conn</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="nx">taskUUID</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">state</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">TaskState</span><span class="p">)</span>
	<span class="nx">decoder</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">item</span><span class="p">))</span>
	<span class="nx">decoder</span><span class="p">.</span><span class="nf">UseNumber</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">decoder</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">state</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">state</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>通过上面的介绍，我们基本知道了在machinery中如何走一个最简单的任务操作及其原理。但是，如同我们在系列一中说到的，任务队列仅有这些功能是远远不够的，接下来我们将继续介绍machinery中的额外的任务队列功能。</p>
<h2 id="重试机制">重试机制<a hidden class="anchor" aria-hidden="true" href="#重试机制">#</a></h2>
<p>任务重试，算是任务队列的一个除了基本功能外的一个重要的基础功能，在上文中也已经顺带提到了。之所以会单独拎出来说，machinery中提供了两种方式来实现任务重试。</p>
<p>对于第一种，在上文中已经提到过，machinery中通过设置任务的RetryCount和RetryTimeout参数来实现，当任务执行出错后，会通过这两个参数来更新任务的ETA参数。RetryCount提供了重试次数，RetryTimeout提供了一个基于斐波那契数列的回退超时机制。</p>
<p>关于第二种，通过返回一个ErrRetryTaskLater类型的值来制定。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 源码
</span><span class="c1">// ErrRetryTaskLater ...
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ErrRetryTaskLater</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span><span class="p">,</span> <span class="nx">msg</span> <span class="kt">string</span>
	<span class="nx">retryIn</span>   <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>同时需要注意的是，第二种方式的优先级高于第一种，也就是说，如果在新建任务的时候指定了RetryCount和RetryTimeout参数，但是在执行任务失败后返回了ErrRetryTaskLater类型的数值，依然按照返回值里的参数来制定重试方式。</p>
<p>在系列之一的最后部分，我们提到了Worker处理中的Process()接口的实现，下面让我们再来看一下Process()实现中的任务重试部分的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 源码
</span><span class="c1">// worker执行任务的函数
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">worker</span> <span class="o">*</span><span class="nx">Worker</span><span class="p">)</span> <span class="nf">Process</span><span class="p">(</span><span class="nx">signature</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	
	<span class="o">...</span>
	
	<span class="c1">// 任务执行失败后，判定重试的逻辑
</span><span class="c1"></span>	<span class="nx">results</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">task</span><span class="p">.</span><span class="nf">Call</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// If a tasks.ErrRetryTaskLater was returned from the task,
</span><span class="c1"></span>		<span class="c1">// retry the task after specified duration
</span><span class="c1"></span>		<span class="nx">retriableErr</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="kd">interface</span><span class="p">{}(</span><span class="nx">err</span><span class="p">).(</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">ErrRetryTaskLater</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">worker</span><span class="p">.</span><span class="nf">retryTaskIn</span><span class="p">(</span><span class="nx">signature</span><span class="p">,</span> <span class="nx">retriableErr</span><span class="p">.</span><span class="nf">RetryIn</span><span class="p">())</span>
		<span class="p">}</span>
		<span class="c1">// Otherwise, execute default retry logic based on signature.RetryCount
</span><span class="c1"></span>		<span class="c1">// and signature.RetryTimeout values
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">signature</span><span class="p">.</span><span class="nx">RetryCount</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">worker</span><span class="p">.</span><span class="nf">taskRetry</span><span class="p">(</span><span class="nx">signature</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">worker</span><span class="p">.</span><span class="nf">taskFailed</span><span class="p">(</span><span class="nx">signature</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	 
	<span class="o">...</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们看到，当任务执行失败后，将会首先判断tasks.ErrRetryTaskLater是否有被实现，根据是否实现了该接口，分别调用retryTaskIn或者taskRetry函数。其中，</p>
<ul>
<li>retryTaskIn()函数将任务参数ETA刷新，并重新发布该任务；</li>
<li>retryTask()函数将任务参数RetryCount减1，同时根据RetryTimeout参数更新ETA，并重新发布该任务；</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 源码
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">worker</span> <span class="o">*</span><span class="nx">Worker</span><span class="p">)</span> <span class="nf">retryTaskIn</span><span class="p">(</span><span class="nx">signature</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">,</span> <span class="nx">retryIn</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
   <span class="c1">// 更新任务状态为Retry
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">worker</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">GetBackend</span><span class="p">().</span><span class="nf">SetStateRetry</span><span class="p">(</span><span class="nx">signature</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Set state retry error: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
   <span class="p">}</span>

   <span class="c1">// 将参数ETA更新为当前时间+retryIn.Seconds()
</span><span class="c1"></span>   <span class="nx">eta</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UTC</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">retryIn</span><span class="p">)</span>
   <span class="nx">signature</span><span class="p">.</span><span class="nx">ETA</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">eta</span>

   <span class="nx">log</span><span class="p">.</span><span class="nx">WARNING</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Task %s failed. Going to retry in %.0f seconds.&#34;</span><span class="p">,</span> <span class="nx">signature</span><span class="p">.</span><span class="nx">UUID</span><span class="p">,</span> <span class="nx">retryIn</span><span class="p">.</span><span class="nf">Seconds</span><span class="p">())</span>

   <span class="c1">// 重新发布任务
</span><span class="c1"></span>   <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">worker</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">SendTask</span><span class="p">(</span><span class="nx">signature</span><span class="p">)</span>
   <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="c1">// 源码
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">worker</span> <span class="o">*</span><span class="nx">Worker</span><span class="p">)</span> <span class="nf">taskRetry</span><span class="p">(</span><span class="nx">signature</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
   <span class="c1">// Update task state to RETRY
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">worker</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">GetBackend</span><span class="p">().</span><span class="nf">SetStateRetry</span><span class="p">(</span><span class="nx">signature</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Set state retry error: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
   <span class="p">}</span>

   <span class="c1">// RetryCount - 1
</span><span class="c1"></span>   <span class="nx">signature</span><span class="p">.</span><span class="nx">RetryCount</span><span class="o">--</span>

   <span class="c1">// 更新Retrytimeout时间
</span><span class="c1"></span>   <span class="nx">signature</span><span class="p">.</span><span class="nx">RetryTimeout</span> <span class="p">=</span> <span class="nx">retry</span><span class="p">.</span><span class="nf">FibonacciNext</span><span class="p">(</span><span class="nx">signature</span><span class="p">.</span><span class="nx">RetryTimeout</span><span class="p">)</span>

   <span class="c1">// 更新ETA参数
</span><span class="c1"></span>   <span class="nx">eta</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UTC</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">signature</span><span class="p">.</span><span class="nx">RetryTimeout</span><span class="p">))</span>
   <span class="nx">signature</span><span class="p">.</span><span class="nx">ETA</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">eta</span>

   <span class="nx">log</span><span class="p">.</span><span class="nx">WARNING</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Task %s failed. Going to retry in %d seconds.&#34;</span><span class="p">,</span> <span class="nx">signature</span><span class="p">.</span><span class="nx">UUID</span><span class="p">,</span> <span class="nx">signature</span><span class="p">.</span><span class="nx">RetryTimeout</span><span class="p">)</span>

   <span class="c1">// 重新发布任务
</span><span class="c1"></span>   <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">worker</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">SendTask</span><span class="p">(</span><span class="nx">signature</span><span class="p">)</span>
   <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="workflow-1">WorkFlow<a hidden class="anchor" aria-hidden="true" href="#workflow-1">#</a></h1>
<p>运行一个任务，支持实时执行、或者延时执行，同时在出错后支持重试等功能，这些在部分场合已经十分适用了，但是，在更多场景下，我们需要执行的任务之间有上下依赖需要串行执行、或者任务之间完全并行不相关、又或者根据结果成功失败来执行回调的需求。为了满足这类需求，machinery中Workflow模式的作用体现出来了。</p>
<h2 id="chain链式任务">Chain链式任务<a hidden class="anchor" aria-hidden="true" href="#chain链式任务">#</a></h2>
<p>所谓任务链式调度，即一系列任务之间采用one by one的串行调度，只有前一个任务执行完毕，才会执行后一个任务。我们依然根据上文介绍普通任务的流程来介绍在machinery中对于链式任务的处理流程：</p>
<h3 id="任务创建">任务创建<a hidden class="anchor" aria-hidden="true" href="#任务创建">#</a></h3>
<p>machinery中提供了NewChain()接口来实现链式任务的创建，如下所示，我们分别创建了两个任务实例task0和task1，然后通过NewChain()生成了链式任务chain实例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 调用代码
</span><span class="c1"></span><span class="nx">task0</span> <span class="o">:=</span> <span class="nf">buildDownloadFromCos</span><span class="p">(</span><span class="s">&#34;audience.DownloadFromCos&#34;</span><span class="p">,</span><span class="nx">appId</span><span class="p">,</span> <span class="nx">bucketName</span><span class="p">)</span>
<span class="nx">task1</span> <span class="o">:=</span> <span class="nf">buildDoCompare</span><span class="p">(</span><span class="s">&#34;audience.DoCompare&#34;</span><span class="p">,</span><span class="nx">appId</span><span class="p">,</span> <span class="nx">upstreamId</span><span class="p">)</span>
<span class="nx">chain</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tasks</span><span class="p">.</span><span class="nf">NewChain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">task0</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">task1</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">LoggerWrapperWithCaller</span><span class="p">().</span><span class="nf">Errorf</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
    <span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 源码
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewChain</span><span class="p">(</span><span class="nx">signatures</span> <span class="o">...*</span><span class="nx">Signature</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Chain</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// uuid的生成逻辑
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">signature</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">signatures</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">signature</span><span class="p">.</span><span class="nx">UUID</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>

         <span class="nx">signatureID</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">uuid</span><span class="p">.</span><span class="nf">NewV4</span><span class="p">()</span>

         <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Error generating signature id: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
         <span class="p">}</span>

         <span class="nx">signature</span><span class="p">.</span><span class="nx">UUID</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;task_%v&#34;</span><span class="p">,</span> <span class="nx">signatureID</span><span class="p">)</span>
      <span class="p">}</span>
   <span class="p">}</span>

   <span class="c1">// 将所有任务拼装，并传递给Chain数据结构中的Tasks变量
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">signatures</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
         <span class="nx">signatures</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nx">OnSuccess</span> <span class="p">=</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Signature</span><span class="p">{</span><span class="nx">signatures</span><span class="p">[</span><span class="nx">i</span><span class="p">]}</span>
      <span class="p">}</span>
   <span class="p">}</span>

   <span class="nx">chain</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Chain</span><span class="p">{</span><span class="nx">Tasks</span><span class="p">:</span> <span class="nx">signatures</span><span class="p">}</span>

   <span class="k">return</span> <span class="nx">chain</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="o">...</span>

<span class="c1">// 链式任务数据结构
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Chain</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Tasks</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Signature</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们重点看一下上述的任务拼装部分，通过链式任务的拼装，最终我们通过chain任务中的第一个任务，就可以看到chain中的所有任务，下方是一个chain任务存储于Broker中的示例，该chain任务中，一共有2个基本任务task，分别通过OnSuccess来实现任务的连接调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span><span class="lnt">98
</span><span class="lnt">99
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="err">//</span> <span class="err">Chain任务在Broker中的示例</span>
<span class="p">{</span>
    <span class="nt">&#34;UUID&#34;</span><span class="p">:</span> <span class="s2">&#34;task_14a0f22c-b456-493c-9c9c-7cd2216d4339&#34;</span><span class="p">,</span> 
    <span class="nt">&#34;Name&#34;</span><span class="p">:</span> <span class="s2">&#34;audience.ExtractEsToFile&#34;</span><span class="p">,</span> 
    <span class="nt">&#34;RoutingKey&#34;</span><span class="p">:</span> <span class="s2">&#34;machinery_tasks&#34;</span><span class="p">,</span> 
    <span class="nt">&#34;ETA&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span> 
    <span class="nt">&#34;GroupUUID&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span> 
    <span class="nt">&#34;GroupTaskCount&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> 
    <span class="nt">&#34;Args&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="nt">&#34;Name&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span> 
            <span class="nt">&#34;Type&#34;</span><span class="p">:</span> <span class="s2">&#34;string&#34;</span><span class="p">,</span> 
            <span class="nt">&#34;Value&#34;</span><span class="p">:</span> <span class="s2">&#34;123456789&#34;</span>
        <span class="p">},</span> 
        <span class="p">{</span>
            <span class="nt">&#34;Name&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span> 
            <span class="nt">&#34;Type&#34;</span><span class="p">:</span> <span class="s2">&#34;string&#34;</span><span class="p">,</span> 
            <span class="nt">&#34;Value&#34;</span><span class="p">:</span> <span class="s2">&#34;audience/2018-06-07/4703668260587260.data&#34;</span>
        <span class="p">},</span> 
        <span class="p">{</span>
            <span class="nt">&#34;Name&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span> 
            <span class="nt">&#34;Type&#34;</span><span class="p">:</span> <span class="s2">&#34;string&#34;</span><span class="p">,</span> 
            <span class="nt">&#34;Value&#34;</span><span class="p">:</span> <span class="s2">&#34;[{\&#34;field\&#34;:\&#34;gender.keyword\&#34;,\&#34;value\&#34;:[\&#34;女\&#34;],\&#34;operation\&#34;:\&#34;and\&#34;},{\&#34;field\&#34;:\&#34;job_title.keyword\&#34;,\&#34;value\&#34;:[\&#34;快?~R佑~X\&#34;],\&#34;operation\&#34;:\&#34;and\&#34;}} ,{\&#34;field\&#34;:\&#34;school_role.keyword\&#34;,\&#34;value\&#34;:[\&#34;维修工\&#34;],\&#34;operation\&#34;:\&#34;and\&#34;}]&#34;</span>
        <span class="p">}</span>
    <span class="p">],</span> 
    <span class="nt">&#34;Headers&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span> 
    <span class="nt">&#34;Immutable&#34;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> 
    <span class="nt">&#34;RetryCount&#34;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> 
    <span class="nt">&#34;RetryTimmeout&#34;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> 
    <span class="nt">&#34;OnSuccess&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="nt">&#34;UUID&#34;</span><span class="p">:</span> <span class="s2">&#34;task_cab90b2c-2dc5-4035-91f6-4803df67c8c0&#34;</span><span class="p">,</span> 
            <span class="nt">&#34;Name&#34;</span><span class="p">:</span> <span class="s2">&#34;audience.EncryptExtractFile&#34;</span><span class="p">,</span> 
            <span class="nt">&#34;RoutingKey&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span> 
            <span class="nt">&#34;ETA&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span> 
            <span class="nt">&#34;GroupUUID&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span> 
            <span class="nt">&#34;GroupTaskCount&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> 
            <span class="nt">&#34;Args&#34;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="nt">&#34;Name&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span> 
                    <span class="nt">&#34;Type&#34;</span><span class="p">:</span> <span class="s2">&#34;string&#34;</span><span class="p">,</span> 
                    <span class="nt">&#34;Value&#34;</span><span class="p">:</span> <span class="s2">&#34;123456789&#34;</span>
                <span class="p">},</span> 
                <span class="p">{</span>
                    <span class="nt">&#34;Name&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span> 
                    <span class="nt">&#34;Type&#34;</span><span class="p">:</span> <span class="s2">&#34;int64&#34;</span><span class="p">,</span> 
                    <span class="nt">&#34;Value&#34;</span><span class="p">:</span> <span class="mi">29</span>
                <span class="p">}</span>
            <span class="p">],</span> 
            <span class="nt">&#34;Headers&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span> 
            <span class="nt">&#34;Immutable&#34;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> 
            <span class="nt">&#34;RetryCount&#34;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> 
            <span class="nt">&#34;RetryTimeout&#34;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> 
            <span class="nt">&#34;OnSuccess&#34;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="nt">&#34;UUID&#34;</span><span class="p">:</span> <span class="s2">&#34;task_82f4f831-af24-4f71-950b-5d11abac3dea&#34;</span><span class="p">,</span> 
                    <span class="nt">&#34;Name&#34;</span><span class="p">:</span> <span class="s2">&#34;audience.UploadExtractFileToCos&#34;</span><span class="p">,</span> 
                    <span class="nt">&#34;RoutingKey&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span> 
                    <span class="nt">&#34;ETA&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span> 
                    <span class="nt">&#34;GroupUUID&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span> 
                    <span class="nt">&#34;GroupTaskCount&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> 
                    <span class="nt">&#34;Args&#34;</span><span class="p">:</span> <span class="p">[</span>
                        <span class="p">{</span>
                            <span class="nt">&#34;Name&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span> 
                            <span class="nt">&#34;Type&#34;</span><span class="p">:</span> <span class="s2">&#34;string&#34;</span><span class="p">,</span> 
                            <span class="nt">&#34;Value&#34;</span><span class="p">:</span> <span class="s2">&#34;123456789&#34;</span>
                        <span class="p">},</span> 
                        <span class="p">{</span>
                            <span class="nt">&#34;Name&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span> 
                            <span class="nt">&#34;Type&#34;</span><span class="p">:</span> <span class="s2">&#34;string&#34;</span><span class="p">,</span> 
                            <span class="nt">&#34;Value&#34;</span><span class="p">:</span> <span class="s2">&#34;beta-abc&#34;</span>
                        <span class="p">},</span> 
                        <span class="p">{</span>
                            <span class="nt">&#34;Name&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span> 
                            <span class="nt">&#34;Type&#34;</span><span class="p">:</span> <span class="s2">&#34;string&#34;</span><span class="p">,</span> 
                            <span class="nt">&#34;Value&#34;</span><span class="p">:</span> <span class="s2">&#34;ap-shanghai&#34;</span>
                        <span class="p">},</span> 
                        <span class="p">{</span>
                            <span class="nt">&#34;Name&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span> 
                            <span class="nt">&#34;Type&#34;</span><span class="p">:</span> <span class="s2">&#34;string&#34;</span><span class="p">,</span> 
                            <span class="nt">&#34;Value&#34;</span><span class="p">:</span> <span class="s2">&#34;audience/2018-06-07/4703668260587260.data&#34;</span>
                        <span class="p">}</span>
                    <span class="p">],</span> 
                    <span class="nt">&#34;Headers&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span> 
                    <span class="nt">&#34;Immutable&#34;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> 
                    <span class="nt">&#34;RetryCount&#34;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> 
                    <span class="nt">&#34;RetryTimeout&#34;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> 
                    <span class="nt">&#34;OnSuccess&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span> 
                    <span class="nt">&#34;OnError&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span> 
                    <span class="nt">&#34;ChordCallback&#34;</span><span class="p">:</span> <span class="kc">null</span>
                <span class="p">}</span>
            <span class="p">],</span> 
            <span class="nt">&#34;OnError&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span> 
            <span class="nt">&#34;ChordCallback&#34;</span><span class="p">:</span> <span class="kc">null</span>
        <span class="p">}</span>
    <span class="p">],</span> 
    <span class="nt">&#34;OnError&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span> 
    <span class="nt">&#34;ChordCallback&#34;</span><span class="p">:</span> <span class="kc">null</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="任务发布-1">任务发布<a hidden class="anchor" aria-hidden="true" href="#任务发布-1">#</a></h3>
<p>链式任务发布的方法与普通任务接口设计基本一致，直接通过调用SendChain()接口即可：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 调用代码
</span><span class="c1"></span><span class="nx">asyncResult</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">mc</span><span class="p">.</span><span class="nf">SendChain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">chain</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
 <span class="nx">log</span><span class="p">.</span><span class="nf">LoggerFromContextWithCaller</span><span class="p">(</span><span class="nx">ctx</span><span class="p">).</span><span class="nf">Errorf</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
 <span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>结合上述对chain任务创建的介绍，我们来看下SendChain()代码实现。如上文描述，由于第一个任务中已经包含了所有的后续任务信息，发布一个chain任务，实际上只需要发布第一个任务到Broker中即可：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 源码
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">server</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">SendChain</span><span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Chain</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">backends</span><span class="p">.</span><span class="nx">ChainAsyncResult</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">server</span><span class="p">.</span><span class="nf">SendTask</span><span class="p">(</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Tasks</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
   <span class="p">}</span>

   <span class="k">return</span> <span class="nx">backends</span><span class="p">.</span><span class="nf">NewChainAsyncResult</span><span class="p">(</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Tasks</span><span class="p">,</span> <span class="nx">server</span><span class="p">.</span><span class="nx">backend</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>因此，真正实现的chain中后续的任务调用，是由worker对每一个任务的OnSuccess参数检查来实现调度的，当worker中每一个任务调用成功后，都会触发taskSucceeded()执行，taskSucceeded中则会针对OnSuccess进行判断，如果发现存在OnSuccess，则会发布下一个任务，从而实现了任务的链式调度：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 源码
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">worker</span> <span class="o">*</span><span class="nx">Worker</span><span class="p">)</span> <span class="nf">taskSucceeded</span><span class="p">(</span><span class="nx">signature</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">,</span> <span class="nx">taskResults</span> <span class="p">[]</span><span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">TaskResult</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  
   <span class="o">...</span> 

   <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">successTask</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">signature</span><span class="p">.</span><span class="nx">OnSuccess</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">signature</span><span class="p">.</span><span class="nx">Immutable</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
         <span class="c1">// Pass results of the task to success callbacks
</span><span class="c1"></span>         <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">taskResult</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">taskResults</span> <span class="p">{</span>
            <span class="nx">successTask</span><span class="p">.</span><span class="nx">Args</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">successTask</span><span class="p">.</span><span class="nx">Args</span><span class="p">,</span> <span class="nx">tasks</span><span class="p">.</span><span class="nx">Arg</span><span class="p">{</span>
               <span class="nx">Type</span><span class="p">:</span>  <span class="nx">taskResult</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span>
               <span class="nx">Value</span><span class="p">:</span> <span class="nx">taskResult</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span>
            <span class="p">})</span>
         <span class="p">}</span>
      <span class="p">}</span>

      <span class="nx">worker</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">SendTask</span><span class="p">(</span><span class="nx">successTask</span><span class="p">)</span>
   <span class="p">}</span>
   
   <span class="o">...</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="结果获取">结果获取<a hidden class="anchor" aria-hidden="true" href="#结果获取">#</a></h3>
<p>链式任务的结果获取，获取的是最后一个任务的执行结果，调用方式与普通任务获取无异，方式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 调用代码
</span><span class="c1"></span><span class="nx">results</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">chainAsyncResult</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">5</span><span class="p">))</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
<span class="nx">log</span><span class="p">.</span><span class="nf">LoggerWrapperWithCaller</span><span class="p">().</span><span class="nf">Errorf</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
<span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="参数传递">参数传递<a hidden class="anchor" aria-hidden="true" href="#参数传递">#</a></h3>
<p>这时候，细心的同学可能会问了，如果串行执行的任务之间有参数依赖需要传递的话，如何实现呢？这时候我们回头看一下Signature的参数中有一个Immutable，chain任务会根据每一个任务的Immutable参数的数值来决定是否帮我们将上一个任务的返回值通过参数传递给chain中的下一个任务，如果immutable为true，那么参数将不会被传递下去，实现该部分的代码在任务执行成功的taskSucceeded()函数中。我们会看上一小节的taskSucceeded()代码，就可以看到对每一个任务的Immutable检查。</p>
<h2 id="group分组任务">Group分组任务<a hidden class="anchor" aria-hidden="true" href="#group分组任务">#</a></h2>
<p>分组任务，听起来可能不太理解，但如果换成另一个名词：并行任务，就很好理解了。即一个分组group内的所有任务，是相互独立，同时执行的，这在任务队列中也是有着相当大的使用场景的。</p>
<h3 id="任务创建-1">任务创建<a hidden class="anchor" aria-hidden="true" href="#任务创建-1">#</a></h3>
<p>machinery中创建分组任务的接口是NewGroup()，可以接受多个普通任务参数，并生成一个group实例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 调用代码
</span><span class="c1"></span><span class="nx">group</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tasks</span><span class="p">.</span><span class="nf">NewGroup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">task0</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">task1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">task2</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">LoggerWrapperWithCaller</span><span class="p">().</span><span class="nf">Errorf</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在Group中的所有任务，没有执行顺序的要求，所有的任务将会由所有worker去竞争获取并执行。也是因此，创建分组任务的实现也十分简单，只需要进行简单的复制即可：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 源码
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewGroup</span><span class="p">(</span><span class="nx">signatures</span> <span class="o">...*</span><span class="nx">Signature</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Group</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// 创建Group的uuid
</span><span class="c1"></span>   <span class="nx">groupUUID</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">uuid</span><span class="p">.</span><span class="nf">NewV4</span><span class="p">()</span>
   
   <span class="o">...</span>

   <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">signature</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">signatures</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">signature</span><span class="p">.</span><span class="nx">UUID</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>

         <span class="nx">signatureID</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">uuid</span><span class="p">.</span><span class="nf">NewV4</span><span class="p">()</span>

         <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Error generating signature id: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
         <span class="p">}</span>

         <span class="nx">signature</span><span class="p">.</span><span class="nx">UUID</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;task_%v&#34;</span><span class="p">,</span> <span class="nx">signatureID</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="nx">signature</span><span class="p">.</span><span class="nx">GroupUUID</span> <span class="p">=</span> <span class="nx">groupID</span>
      <span class="nx">signature</span><span class="p">.</span><span class="nx">GroupTaskCount</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">signatures</span><span class="p">)</span>
   <span class="p">}</span>

   <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Group</span><span class="p">{</span>
      <span class="nx">GroupUUID</span><span class="p">:</span> <span class="nx">groupID</span><span class="p">,</span>
      <span class="nx">Tasks</span><span class="p">:</span>     <span class="nx">signatures</span><span class="p">,</span>
   <span class="p">},</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="o">...</span>

<span class="c1">// 分组任务数据结构
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Group</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">GroupUUID</span> <span class="kt">string</span>
	<span class="nx">Tasks</span>     <span class="p">[]</span><span class="o">*</span><span class="nx">Signature</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="任务发布-2">任务发布<a hidden class="anchor" aria-hidden="true" href="#任务发布-2">#</a></h3>
<p>machinery中发布分组任务接口是SendGroup()，支持将任务并行发布到Broker中，同时还支持了一个发送任务的并发控制，以防止同一时刻发布太多任务到任务队列，照顾到Broker的性能。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">asyncResults</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">server</span><span class="p">.</span><span class="nf">SendGroup</span><span class="p">(</span><span class="nx">group</span><span class="p">,</span> <span class="cm">/*并发任务数量*/</span><span class="mi">5</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Could not send group: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
<span class="p">}</span>
<span class="nf">SendGroup</span><span class="p">()</span><span class="nx">接口的代码如下</span><span class="err">，</span><span class="nx">不必要的地方已经省略</span><span class="err">，</span><span class="nx">同时添加了部分注释</span><span class="err">：</span>

<span class="c1">// 源码
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">server</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">SendGroup</span><span class="p">(</span><span class="nx">group</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Group</span><span class="p">,</span> <span class="nx">sendConcurrency</span> <span class="kt">int</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">backends</span><span class="p">.</span><span class="nx">AsyncResult</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
   
   <span class="o">...</span>
   
   <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">group</span><span class="p">.</span><span class="nx">Tasks</span><span class="p">))</span>
   <span class="nx">errorsChan</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">group</span><span class="p">.</span><span class="nx">Tasks</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>

   <span class="c1">// 初始化group，主要负责在backend中根据group uuid创建一条记录，以存储该group任务的状态
</span><span class="c1"></span>   <span class="nx">server</span><span class="p">.</span><span class="nx">backend</span><span class="p">.</span><span class="nf">InitGroup</span><span class="p">(</span><span class="nx">group</span><span class="p">.</span><span class="nx">GroupUUID</span><span class="p">,</span> <span class="nx">group</span><span class="p">.</span><span class="nf">GetUUIDs</span><span class="p">())</span>

   <span class="c1">// 任务状态设置
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">signature</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">group</span><span class="p">.</span><span class="nx">Tasks</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">server</span><span class="p">.</span><span class="nx">backend</span><span class="p">.</span><span class="nf">SetStatePending</span><span class="p">(</span><span class="nx">signature</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
         <span class="nx">errorsChan</span> <span class="o">&lt;-</span> <span class="nx">err</span>
         <span class="k">continue</span>
      <span class="p">}</span>
   <span class="p">}</span>

   <span class="c1">// 并发控制
</span><span class="c1"></span>   <span class="nx">pool</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="nx">sendConcurrency</span><span class="p">)</span>
   <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">sendConcurrency</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
         <span class="nx">pool</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
      <span class="p">}</span>
   <span class="p">}()</span>

   <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">signature</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">group</span><span class="p">.</span><span class="nx">Tasks</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">sendConcurrency</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
         <span class="o">&lt;-</span><span class="nx">pool</span>
      <span class="p">}</span>

      <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">,</span> <span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
         <span class="c1">// 发布任务
</span><span class="c1"></span>         <span class="nx">err</span> <span class="o">:=</span> <span class="nx">server</span><span class="p">.</span><span class="nx">broker</span><span class="p">.</span><span class="nf">Publish</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>

         <span class="k">if</span> <span class="nx">sendConcurrency</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">pool</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
         <span class="p">}</span>

         <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">errorsChan</span> <span class="o">&lt;-</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Publish message error: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="k">return</span>
         <span class="p">}</span>

         <span class="nx">asyncResults</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="p">=</span> <span class="nx">backends</span><span class="p">.</span><span class="nf">NewAsyncResult</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">server</span><span class="p">.</span><span class="nx">backend</span><span class="p">)</span>
      <span class="p">}(</span><span class="nx">signature</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
   <span class="p">}</span>

   <span class="o">...</span>
 
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="结果获取-1">结果获取<a hidden class="anchor" aria-hidden="true" href="#结果获取-1">#</a></h3>
<p>分组任务中每个任务的执行结果，全部存储于asyncResult 中，可通过遍历获取：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">	<span class="c1">// 调用代码
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">asyncResult</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">asyncResults</span> <span class="p">{</span>
		<span class="nx">results</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">asyncResult</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">5</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Getting task result failed with error: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
		<span class="p">}</span>
		<span class="nx">log</span><span class="p">.</span><span class="nx">INFO</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span>
			<span class="s">&#34;%v + %v = %v\n&#34;</span><span class="p">,</span>
			<span class="nx">asyncResult</span><span class="p">.</span><span class="nx">Signature</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Value</span><span class="p">,</span>
			<span class="nx">asyncResult</span><span class="p">.</span><span class="nx">Signature</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">Value</span><span class="p">,</span>
			<span class="nx">tasks</span><span class="p">.</span><span class="nf">HumanReadableResults</span><span class="p">(</span><span class="nx">results</span><span class="p">),</span>
		<span class="p">)</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="chord任务">Chord任务<a hidden class="anchor" aria-hidden="true" href="#chord任务">#</a></h2>
<p>chord任务，其功能是分组任务+回调任务。即，chord任务允许我们在并行执行完毕所有一组group任务之后，回调一个callback任务，这也是一个有着非常多的应用场景。</p>
<h3 id="任务创建-2">任务创建<a hidden class="anchor" aria-hidden="true" href="#任务创建-2">#</a></h3>
<p>machinery通过NewChord()接口实现chord任务创建，接受两个参数，分别是group任务实例和回调函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 调用代码
</span><span class="c1"></span><span class="nx">chord</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tasks</span><span class="p">.</span><span class="nf">NewChord</span><span class="p">(</span><span class="nx">group</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">cbTask</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Error creating chord: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>而NewChord()函数主要负责给group中每个任务的ChordCallback赋值为需要回调的函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 源码
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewChord</span><span class="p">(</span><span class="nx">group</span> <span class="o">*</span><span class="nx">Group</span><span class="p">,</span> <span class="nx">callback</span> <span class="o">*</span><span class="nx">Signature</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Chord</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
   
   <span class="o">...</span>

   <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">signature</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">group</span><span class="p">.</span><span class="nx">Tasks</span> <span class="p">{</span>
      <span class="nx">signature</span><span class="p">.</span><span class="nx">ChordCallback</span> <span class="p">=</span> <span class="nx">callback</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Chord</span><span class="p">{</span><span class="nx">Group</span><span class="p">:</span> <span class="nx">group</span><span class="p">,</span> <span class="nx">Callback</span><span class="p">:</span> <span class="nx">callback</span><span class="p">},</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="o">...</span>

<span class="c1">// Chord任务数据结构
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Chord</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Group</span>    <span class="o">*</span><span class="nx">Group</span>
	<span class="nx">Callback</span> <span class="o">*</span><span class="nx">Signature</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="任务发布-3">任务发布<a hidden class="anchor" aria-hidden="true" href="#任务发布-3">#</a></h3>
<p>chord任务发布比较也比较简单，接口SendChord()与SendGroup()类似，而SendChord()中的代码逻辑也比较简单，即简单的warp了一下SendGroup任务。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 调用代码
</span><span class="c1"></span><span class="nx">chordAsyncResult</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">server</span><span class="p">.</span><span class="nf">SendChord</span><span class="p">(</span><span class="nx">chord</span><span class="p">,</span> <span class="cm">/*并发任务数量*/</span><span class="mi">5</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Could not send chord: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
<span class="p">}</span>
<span class="c1">// 源码
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">server</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">SendChord</span><span class="p">(</span><span class="nx">chord</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Chord</span><span class="p">,</span> <span class="nx">sendConcurrency</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">backends</span><span class="p">.</span><span class="nx">ChordAsyncResult</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">server</span><span class="p">.</span><span class="nf">SendGroup</span><span class="p">(</span><span class="nx">chord</span><span class="p">.</span><span class="nx">Group</span><span class="p">,</span> <span class="nx">sendConcurrency</span><span class="p">)</span>
   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
   <span class="p">}</span>

   <span class="k">return</span> <span class="nx">backends</span><span class="p">.</span><span class="nf">NewChordAsyncResult</span><span class="p">(</span>
      <span class="nx">chord</span><span class="p">.</span><span class="nx">Group</span><span class="p">.</span><span class="nx">Tasks</span><span class="p">,</span>
      <span class="nx">chord</span><span class="p">.</span><span class="nx">Callback</span><span class="p">,</span>
      <span class="nx">server</span><span class="p">.</span><span class="nx">backend</span><span class="p">,</span>
   <span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>而主要对chord的回调函数的调用，则同样是通过任务执行成功后的执行函数taskSucceeded()来实现，其相关代码如下，具体的逻辑可以从添加的注释中了解：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 源码
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">worker</span> <span class="o">*</span><span class="nx">Worker</span><span class="p">)</span> <span class="nf">taskSucceeded</span><span class="p">(</span><span class="nx">signature</span> <span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">Signature</span><span class="p">,</span> <span class="nx">taskResults</span> <span class="p">[]</span><span class="o">*</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">TaskResult</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
   
   <span class="o">...</span> 
   
   <span class="c1">// 若该任务不是groupe任务中的, return
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">signature</span><span class="p">.</span><span class="nx">GroupUUID</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="c1">// 检查是否group中的所有任务都执行完毕
</span><span class="c1"></span>	<span class="nx">groupCompleted</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">worker</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">GetBackend</span><span class="p">().</span><span class="nf">GroupCompleted</span><span class="p">(</span>
		<span class="nx">signature</span><span class="p">.</span><span class="nx">GroupUUID</span><span class="p">,</span>
		<span class="nx">signature</span><span class="p">.</span><span class="nx">GroupTaskCount</span><span class="p">,</span>
	<span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Group completed error: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">groupCompleted</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

   <span class="o">...</span>

   <span class="c1">// 若无chord callback, return
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">signature</span><span class="p">.</span><span class="nx">ChordCallback</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">nil</span>
   <span class="p">}</span>

   <span class="c1">// 触发chord callback, 确保只触发一次
</span><span class="c1"></span>   <span class="nx">shouldTrigger</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">worker</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">GetBackend</span><span class="p">().</span><span class="nf">TriggerChord</span><span class="p">(</span><span class="nx">signature</span><span class="p">.</span><span class="nx">GroupUUID</span><span class="p">)</span>
   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Trigger chord error: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
   <span class="p">}</span>
   <span class="k">if</span> <span class="p">!</span><span class="nx">shouldTrigger</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">nil</span>
   <span class="p">}</span>

   <span class="o">...</span>

   <span class="c1">// 发送chord任务
</span><span class="c1"></span>   <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">worker</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">SendTask</span><span class="p">(</span><span class="nx">signature</span><span class="p">.</span><span class="nx">ChordCallback</span><span class="p">)</span>
   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">err</span>
   <span class="p">}</span>

   <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="结果获取-2">结果获取<a hidden class="anchor" aria-hidden="true" href="#结果获取-2">#</a></h3>
<p>chord任务的结果获取与其他的操作无异，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 调用代码
</span><span class="c1"></span><span class="nx">results</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">chordAsyncResult</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">5</span><span class="p">))</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Getting chord result failed with error: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h1>
<p>我们详细的介绍了golang中任务队列machinery的使用和原理，从而为众多golang使用者们推荐了一款好用的任务队列，并从源码层解析了其详细实现。</p>
<p>同时，本文主要是基于Redis作为存储介质来进行详细介绍，而Redis中缺乏如Ack之类的机制，尽管可以通过LUA脚本简介实现，但是在云时代的Redis集群对EVAL接口支持的能力还有不足，使得使用起来还是略有欠缺。因此，对于任务可靠性要求更高的，可以使用基于AMQP的方案来使用，更多关于AMQP的实现接口，基本与Redis下一致，大家可以进一步阅读源码。</p>
<p>转载:<br>
<a href="https://cloud.tencent.com/developer/article/1169675">https://cloud.tencent.com/developer/article/1169675</a>
<a href="https://cloud.tencent.com/developer/article/1177831">https://cloud.tencent.com/developer/article/1177831</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/machinery/">machinery</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
