<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Git撤销操作总结 | Forz Blog</title>
<meta name="keywords" content="Git" />
<meta name="description" content="分支提交错误 有时我们会遇到这种情况：我们从develop 分支新建一个名为feat/home 分支去做A功能，然后由于一些其他原因A 功能需要延后">
<meta name="author" content="">
<link rel="canonical" href="/post/git%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Git撤销操作总结" />
<meta property="og:description" content="分支提交错误 有时我们会遇到这种情况：我们从develop 分支新建一个名为feat/home 分支去做A功能，然后由于一些其他原因A 功能需要延后" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/git%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-03-13T15:55:46&#43;00:00" />
<meta property="article:modified_time" content="2020-03-13T15:55:46&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Git撤销操作总结"/>
<meta name="twitter:description" content="分支提交错误 有时我们会遇到这种情况：我们从develop 分支新建一个名为feat/home 分支去做A功能，然后由于一些其他原因A 功能需要延后"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Git撤销操作总结",
      "item": "/post/git%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Git撤销操作总结",
  "name": "Git撤销操作总结",
  "description": "分支提交错误 有时我们会遇到这种情况：我们从develop 分支新建一个名为feat/home 分支去做A功能，然后由于一些其他原因A 功能需要延后",
  "keywords": [
    "Git"
  ],
  "articleBody": "分支提交错误 有时我们会遇到这种情况：我们从develop 分支新建一个名为feat/home 分支去做A功能，然后由于一些其他原因A 功能需要延后，然后我们再从develop分支新建一个分支去做B功能或者C功能，在多分支多功能开发时，就容易出现做B功能时，忘记切换分支，一直等做完了提交了push之后才发现 push 错了远端的分支，并且 push 的改动与该分支需要开发的功能并没有交集，因此我们需要将已经提交错的分支内容回滚并提交push 到正确的远端分支。\n已经提交到本地 使用 git reset 命令，可以在提交层面在私有分支舍弃一些没有提交的更改：\n1 2  # 回退到上一个版本  git reset --hard HEAD^   git reset 命令主要有三个选项： –soft、–mixed 、–hard，默认参数为 –mixed。\ngit reset –soft –soft 这个版本的命令有“最小”影响，只改变一个符号引用的状态使其指向一个新提交，不会改变其索引和工作目录， 具体体现如下：\n1 2 3 4 5 6  # 模拟一份提交历史 git add 1.js \u0026\u0026 git commit -m \"update part 1\" git add 2.js \u0026\u0026 git commit -m \"update part 2\" git add 3.js \u0026\u0026 git commit -m \"update part 3\" git add 4.js \u0026\u0026 git commit -m \"update part 4\" git log --oneline --graph -4 --decorate   1 2  # 用 --soft 参数尝试回退一个版本 git reset --soft HEAD~1   当我们执行 –soft 命令后，可以看到控制台无任何输出，此时再次查看当前提交历史：\n1  git log --oneline --graph -4 --decorate   如下图，可以看到版本库已经回退了一个版本：\n执行 git status，可以看到SHA1为54b1941 的commit 上的更改回到了缓存区：\n因此我们可以认为 –soft 操作是软重置，只撤销了git commit操作，保留了 git add 操作。\ngit reset –hard 此时接上面的流程，我们这次执行 –hard 操作，尝试回退两个版本：\n1  git reset --hard HEAD~2   如下图，可以看到版本库回退了两个版本，并且将本地版本库的头指针全部重置到了指定版本，暂存区也会被重置，工作区的代码也回退到了这一版本：\n执行git status 可以看到 我们的 SHA1 为 54b1941的 commit 上做的修改都“丢失”了，新的文件也被删除了。\n因此可以知道，git commit –hard 是具有破坏性，是很危险的操作，它很容易导致数据丢失，如果我们真的进行了该操作想要找回丢失的数据，那么此时可以使用git reflog 回到未来，找到丢失的commit。这个命令的具体使用会在文章后面介绍。\ngit reset –mixed 我们重新造一系列 commit 历史：\n1 2 3 4 5 6  git add 1.js \u0026\u0026 git commit -m \"update 1.js\" git add 2.js \u0026\u0026 git commit -m \"update 2.js\" git add 3.js \u0026\u0026 git commit -m \"update 3.js\" git add 4.js \u0026\u0026 git commit -m \"update 4.js\" git add 5.js \u0026\u0026 git commit -m \"update 5.js\" git log --oneline --graph -4 --decorate   可以看到当前的 commit 历史如下：\n此时执行–mixed 操作，尝试回退两个版本：\n1 2  # 等价于 git reset HEAD~2 git reset --mixed HEAD~2   提交历史此时改变为下图所示：\n此时执行 git status ，命令行输出如下：\nHEAD、索引被更改，工作目录未被更改\n可以看出，该命令加上 –mixed 参数会保留提交的源码改动，只是将索引信息回退到了某一个版本，如果还需要继续提交，再次执行 git add 和 git commit\n解决问题 介绍完git reset，那么我们来说一下如何用该命令解决提交分支错误的问题：\n第一种方法：\n适用于多个分支一起开发的时候将A分支的改动错误的提交到B的场景：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  # 将该分支的本不应该提交的commit撤销 git reset HEAD^ # 按需选择想要回到哪个版本 # 回到HEAD git reset --soft HEAD # 回到HEAD的前一个版本 git reset --soft HEAD^ # 回到HEAD的前5个版本 git reset --soft HEAD~5 # 利用id回到指定版本 git reset --soft a06ef2f # 将撤销的代码暂存起来 git stash # 切换到正确的分支 git checkout feat/xxx # 重新应用缓存 git stash pop # 在正确的分支进行提交操作 git add . \u0026\u0026 git commit -m \"update xxxx\"   第二种方法：\n适用于在不小心在 master 分支上提交了代码，而实际想要在 feature 分支上提交代码的场景：\n1 2 3 4 5 6 7 8  # 新检出一个新分支，但是仍在master 分支上，并不会切换到新分支 git branch feat/update # 恢复master本身提交的状态 git reset --hard origin/master # 提交错的代码已经在新检出的分支上面了，可以继续进行开发或者push git checkout feat/update   第三种方法：\n适用于想要对特定的某一个或几个commit 进行“嫁接”，使其复制一份到正确的 feature 分支的场景； 在功能性迭代开发中发现一个bug，并提交了一个commit 进行修复，但是发现该bug也存在线上的发布版本上，必须要尽快对线上进行修复，此时可以使用git cherry-pick 将bug 修复的commit 嫁接到 fix 分支上进行代码修复，并及时发布，解决线上bug。\n1 2 3 4 5 6 7 8 9 10 11  # 先切换到正确的分支 git checkout feat/update # 取出提交错误的或bug fix的 commit 引入到feat/update 分支中 git cherry-pick a06ef2f # 回到错误的分支 git checkout feat/feedback # 将 a06ef2f 的改动从当前分支销毁 git reset --head a06ef2f   上面演示的是“嫁接” 一个commit，如果想要嫁接多个 commit 可以这样做：\n1 2  # 将三个commit 合并过来 git cherry-pick b9dabf9 e2c739d dad9e51   如果想加个一个应用范围内的 commit，可以这样做：\n1  git cherry-pick 422db47..e2c739d   需要注意的是无论是对单个 commit 进行 git cherry-pick ，还是批量处理，注意一定要根据时间线，依照 commit 的先后顺序来处理。\n如果你只想把改动转移到目标分支，但是并不想提交，可以这样做：\n1 2  # --no-commit 参数会使嫁接过来的改动不会提交，只会放在暂存区 git cherry-pick b9dabf9 --no-commit   第四种方法：\n适用于当多个文件被缓存时，发现其中一个文件是其他分支的功能性改动，想直接取消该文件的缓存：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  # 编辑了 1.js 2.js 3.js # 缓存所有改动的文件 git add . # 发现 3.js 不应该出现在此时提交的功能上，要取消它的缓存 git reset 3.js # 此时3.js 被取消了缓存，我们继续提交1.js 2.js git commit -m \"Update 1.js 2.js\" # 将3.js 暂存起来 git stash # 切换到提交 3.js 改动的分支 git checkout feat/update # 重新应用缓存起来的 stash（3.js） # pop 参数会将缓存栈的第一个stash删除，并将对应修改应用到当前分支目录下 git stash pop # 继续提交 git add \u0026\u0026 git commit -m \"update 3.js\"   已经推送到远端 场景：假设我们在 feat/feedback 分支上发现最后一次 commit 的功能是feat/update 分支的改动，此时想要取消这次commit（update 2.js）\n下图是feat/feedback 的提交历史：\n此时我们需要借助 git revert 命令来撤销我们的操作。\n解决方式：\n1 2  # 撤销最近的一次提交 git revert HEAD --no-edit   接着我们使用 sourceTree 查看撤销之后的提交历史：\n我们看到想要撤销的 SHA1 为 db6bb3 的 commit（Update 2.js）记录还在，并且多了一个SHA1 为 6e1d7ee 新的 commit（Revert “Update 2.js”）。因此可以看出，git revert 是对给定的 commit 提交进行逆过程，该命令会引入一个新的提交来抵消给定提交的影响。 和 git cherry-pick 一样，revert命令不修改版本库的现存历史记录，相反它只会在记录添加新的提交。\n接下来我们已经解决了错误分支的提交，但是还要把这次提交放到正确的分支上，依然可以使用 git cherry pick 去操作：\n1 2 3 4 5  # 将revert commit push到远端 git push origin feat/feedback # 切换到正确的分支 git checkout feat/update   将目标commit 嫁接到当前分支\n1  git cherry pick db6bb3f   git revert 后面可以加不同的参数达到不同的撤销效果，常用的如下：\n–edit ：该参数为git revert 的默认参数，它会自动创建提交日志提醒，此时会弹出编辑器会话，可以在里面修改提交消息，然后再提交。\n1  git revert 6ac5152 --edit   –no-edit ：表示不编辑 commit 信息，revert 的 commit 会直接自动变回 ‘Revert + 想要撤销的commit 的message’ 的格式。上面例子中使用的就是这种方式。\n–no-commit：该命令会使撤销的 commit 里面的改动放到暂存区，不进行提交，用户可以自行再次提交。这种参数并且适用于将多个 commit 结果还原到索引中，集体放置在缓冲区，进行用户自定义的操作。\n1  git revert 13b7faf --no-commit   已经合到主仓库 当我们把本不属于该分支的代码或者不需要提交的改动提交到主仓库，并合并到了develop 仓库之后，这时想要撤销合到主仓库的改动，解决方式如下：\n推荐的工作流程是如在一个新分支中恢复错误的提交。在这里有人会问，为什么不直接在 develop 分支进行 git revert 操作，岂不是更方便，何必麻麻烦烦的去多建一个分支出来？\n这么做的原因是：在拥有大量开发人员的团队中， develop、master 分支为保护分支，为了安全不允许或不建议去直接修改。\n通过这次操作我们可以了解到：revert 分支的操作实际上是合并进develop 分支的逆操作，它会新产生一个新的分支，将 feat/feedback 的改动还原。\n当你使用 git revert 撤销一个 merge commit 时，如果除了 commit 号而不加任何其他参数，git 将会提示错误：\n1 2 3  $ git revert g error: Commit g is a merge but no -m option was given. fatal: revert failed   在你合并两个分支并试图撤销时，Git 并不知道你到底需要保留哪一个分支上所做的修改。从 Git 的角度来看，master 分支和 dev 在地位上是完全平等的，只是在 workflow 中，master 被人为约定成了「主分支」。\n于是 Git 需要你通过 m 或 mainline 参数来指定「主线」。merge commit 的 parents 一定是在两个不同的线索上，因此可以通过 parent 来表示「主线」。m 参数的值可以是 1 或者 2，对应着 parent 在 merge commit 信息中的顺序。\n举个例子，通常，我们的稳定代码都在 master 分支，而开发过程使用 dev 分支，当开发完成后，再把 dev 分支 merge 进 master 分支：\n1 2 3  a - b - c - f -- g - h (master) \\ / d - e (dev)   以上面那张图为例，我们查看 commit g 的内容：\n1 2 3  $ git show g commit g Merge: f e   那么，$ git revert -m 1 g 将会保留 master 分支上的修改，撤销 dev 分支上的修改。\n撤销成功之后，Git 将会生成一个新的 Commit，提交历史就成了这样：\n1 2 3  a - b - c - f -- g - h - G (master) \\ / d - e (dev)   其中 G 是撤销 g 生成的 commit。通过 $ git show G 之后，我们会发现 G 是一个常规提交，内容就是撤销 merge 时被丢弃的那条线索的所有 commit 的「反操作」的合集。\n下面我们看一下具体操作:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  # 添加三个文件 echo 1  1.html echo 2  2.html echo 3  3.html # 以为提交的是1.html 2.html，将改动推到了远端分支 git add . \u0026\u0026 git commit -m \"Add 1.html 2.html\" git push origin feat/update # 将feat/update的改动创建一个“合并提交”合入develop 分支，生成的 Merge commit 的SHA1 为 f439c6f git checkout develop git merge feat/update --no-ff # 如果存在冲突，先解决冲突，然后继续请求合并 git add . \u0026\u0026 git merge --continue # 将develop 合并的最后结果提交到远端 git push origin develop # 合并之后发现不应该将3.html 不应该放入功能迭代中。需要撤销本次合并 # 做任何操作前，先保证本地的develop 代码是最新状态 git pull --rebase origin develop # 从develop分支新建一个 revert 分支 git checkout -b revert-feat/update # 用 -m 参数指定父编号（从1开始），因为它是“合并提交” git revert -m 1 f439c6f # push revert 的改动 git push origin revert-feat/update # 切换回 develop 分支，将 revert-feat/update 分支进行合并 git checkout develop git merge revert-feat/update --no-ff git push origin develop   图为新建revert 分支：\n图为git revert 弹出编辑器编辑 revert commit message 过程：\n图为执行完git revert 之后的 commit 历史记录：\n接下来我们想将 3.html 的改动撤销的操作就变成了上面场景 2 的操作流程了。\n主仓库回退错误 当我们的代码合到主仓库，并且成功发布到生产环境，此时发现线上有集中报错，必须马上将线上代码回滚到最新版本。这是我们需要进行revert 操作。revert 的代码发布到生产之后，发现错误仍旧存在，最后排查到是某个外部服务依赖出现问题，本次revert 的改动无关，并且外部服务已经恢复。此时需要将 revert 的改动再次发布上生产环境。\n我们可以再用一次git revert，revert 掉我们之前的 revert commit：\n1  git revert HEAD --no-edit   这样 revert 撤销的改动又回来了，此时会发现提交历史上又会出现一个新的revert commit。\n暂存区回退错误 如果我们真的使用了git reset –hard 之后，发现某些修改还有必要的，这时候就需要借助时光机 git reflog “回来未来”了。\ngit reflog 是非常好用的“后悔药”，它几乎可以恢复我们 commit 过的改动，即使这条 commit 记录已经被我们 reset 掉了。\n具体演示如下：\n如上图，在当前提交历史中，我们认为最新的两个commit 已经没有用了，想直接reset 到 SHA1 为 c48a245 这个 commit：\n1 2  # 回到 c48a245 commit git reset --hard c48a245   此时提交历史变为现在这样：\n此时可以看到SHA1 为c48a245 的 commit 时间线之后的改动都已经被撤销了。 这时候我们突然想到：commit 信息为 “Add 1.html 2.html” 的提交里面的改动很重要，需要被找回，但是我们使用 git log 查看过去提交历史，已经找不到这条被我们 reset 掉的历史记录了。这时候进行如下操作：\n1  git reflog   我们如愿以偿的看到了曾经提交过的这个想要找回的commit（commit: Add 1.html 2.html），它的 SHA1 为 cf2e245。\n接下来怎么做取决于你具体想要达到什么目的：\n想要回到cf2e245 这个特定的commit：\n1  git reset --hard cf2e245   想要暂存 cf2e245 中的改动，并且不想马上提交：\n1  git reset --soft cf2e245   想要把cf2e245 嫁接到某个分支目录下：\n1 2  git checkout feat/xxx git cherry-pick cf2e245   想要找回 cf2e245 某个文件的改动，暂存起来：\n1  git checkout cf2e245 1.html   对于 git reflog 需要注意的是： 它不是万能的。Git 会定期清理那些你已经不再用到的“对象”，如果你想找到几个月以前的提交，可能会指望不上它。\n文件修改错误 git reset 和 git checkout 命令接受文件路径作为参数。这时它的行为就大为不同了。它不会作用于整份提交，参数将它限制于特定文件。\nReset 当检测到文件路径时，git reset 将缓存区同步到你指定的那个提交。比如，下面这个命令会将倒数第二个提交中的 foo.py 加入到缓存区中，供下一个提交使用。\n1  git reset HEAD~2 foo.py   和提交层面的 git reset 一样，通常我们使用HEAD而不是某个特定的提交。运行 git reset HEAD foo.py 会将当前的 foo.py 从缓存区中移除出去，而不会影响工作目录中对 foo.py 的更改。\n将一个文件从 commit 历史中移动到 stage 缓存中\n–soft、–mixed 和 –hard 对文件层面的 git reset 毫无作用，因为缓存区中的文件一定会变化，而工作目录中的文件一定不变。\nCheckout Checkout 一个文件和带文件路径 git reset 非常像，除了它更改的是工作目录而不是缓存区。不像提交层面的 checkout 命令，它不会移动 HEAD引用，也就是你不会切换到别的分支上去。\n将文件从提交历史移动到工作目录中\n比如，下面这个命令将工作目录中的 foo.py 同步到了倒数第二个提交中的 foo.py。\n1  git checkout HEAD~2 foo.py   和提交层面相同的是，它可以用来检查项目的旧版本，但作用域被限制到了特定文件。\n如果你缓存并且提交了 checkout 的文件，它具备将某个文件回撤到之前版本的效果。注意它撤销了这个文件后面所有的更改，而 git revert 命令只撤销某个特定提交的更改。\n和 git reset 一样，这个命令通常和 HEAD 一起使用。比如 git checkout HEAD foo.py 等同于舍弃 foo.py 没有缓存的更改。这个行为和 git reset HEAD –hard 很像，但只影响特定文件。\n参考:\nhttps://zhuanlan.zhihu.com/p/42929114\nhttp://blog.psjay.com/posts/git-revert-merge-commit/\nhttps://github.com/geeeeeeeeek/git-recipes\n",
  "wordCount" : "5586",
  "inLanguage": "zh-cn",
  "datePublished": "2020-03-13T15:55:46Z",
  "dateModified": "2020-03-13T15:55:46Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/git%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Git撤销操作总结
    </h1>
    <div class="post-meta">March 13, 2020
</div>
  </header> 
  <div class="post-content"><h1 id="分支提交错误">分支提交错误<a hidden class="anchor" aria-hidden="true" href="#分支提交错误">#</a></h1>
<p>有时我们会遇到这种情况：我们从develop 分支新建一个名为feat/home 分支去做A功能，然后由于一些其他原因A 功能需要延后，然后我们再从develop分支新建一个分支去做B功能或者C功能，在多分支多功能开发时，就容易出现做B功能时，忘记切换分支，一直等做完了提交了push之后才发现 push 错了远端的分支，并且 push 的改动与该分支需要开发的功能并没有交集，因此我们需要将已经提交错的分支内容回滚并提交push 到正确的远端分支。</p>
<h2 id="已经提交到本地">已经提交到本地<a hidden class="anchor" aria-hidden="true" href="#已经提交到本地">#</a></h2>
<p>使用 git reset 命令，可以在提交层面在私有分支舍弃一些没有提交的更改：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 回退到上一个版本 </span>
git reset --hard HEAD^  
</code></pre></td></tr></table>
</div>
</div><p>git reset 命令主要有三个选项： &ndash;soft、&ndash;mixed 、&ndash;hard，默认参数为 &ndash;mixed。</p>
<h3 id="git-reset---soft">git reset &ndash;soft<a hidden class="anchor" aria-hidden="true" href="#git-reset---soft">#</a></h3>
<p>&ndash;soft 这个版本的命令有“最小”影响，只改变一个符号引用的状态使其指向一个新提交，不会改变其索引和工作目录， 具体体现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 模拟一份提交历史</span>
git add 1.js <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&#34;update part 1&#34;</span>
git add 2.js <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&#34;update part 2&#34;</span>
git add 3.js <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&#34;update part 3&#34;</span>
git add 4.js <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&#34;update part 4&#34;</span>
git log --oneline --graph -4 --decorate
</code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200313160116.png" alt=""  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 用 --soft 参数尝试回退一个版本</span>
git reset --soft HEAD~1
</code></pre></td></tr></table>
</div>
</div><p>当我们执行 &ndash;soft 命令后，可以看到控制台无任何输出，此时再次查看当前提交历史：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">git log --oneline --graph -4 --decorate
</code></pre></td></tr></table>
</div>
</div><p>如下图，可以看到版本库已经回退了一个版本：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200313160204.png" alt=""  />
</p>
<p>执行 git status，可以看到SHA1为54b1941 的commit 上的更改回到了缓存区：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200313160215.png" alt=""  />
</p>
<p>因此我们可以认为 &ndash;soft 操作是软重置，只撤销了git commit操作，保留了 git add 操作。</p>
<h3 id="git-reset---hard">git reset &ndash;hard<a hidden class="anchor" aria-hidden="true" href="#git-reset---hard">#</a></h3>
<p>此时接上面的流程，我们这次执行 &ndash;hard 操作，尝试回退两个版本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">git reset --hard HEAD~2
</code></pre></td></tr></table>
</div>
</div><p>如下图，可以看到版本库回退了两个版本，并且将本地版本库的头指针全部重置到了指定版本，暂存区也会被重置，工作区的代码也回退到了这一版本：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200313160505.png" alt=""  />
</p>
<p>执行git status 可以看到 我们的 SHA1 为 54b1941的 commit 上做的修改都“丢失”了，新的文件也被删除了。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200313161645.png" alt=""  />
</p>
<p>因此可以知道，git commit &ndash;hard 是具有破坏性，是很危险的操作，它很容易导致数据丢失，如果我们真的进行了该操作想要找回丢失的数据，那么此时可以使用git reflog 回到未来，找到丢失的commit。这个命令的具体使用会在文章后面介绍。</p>
<h3 id="git-reset---mixed">git reset &ndash;mixed<a hidden class="anchor" aria-hidden="true" href="#git-reset---mixed">#</a></h3>
<p>我们重新造一系列 commit 历史：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">git add 1.js <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&#34;update 1.js&#34;</span>
git add 2.js <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&#34;update 2.js&#34;</span>
git add 3.js <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&#34;update 3.js&#34;</span>
git add 4.js <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&#34;update 4.js&#34;</span>
git add 5.js <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&#34;update 5.js&#34;</span>
git log --oneline --graph -4 --decorate
</code></pre></td></tr></table>
</div>
</div><p>可以看到当前的 commit 历史如下：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200313162121.png" alt=""  />
</p>
<p>此时执行&ndash;mixed 操作，尝试回退两个版本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 等价于 git reset HEAD~2</span>
git reset --mixed HEAD~2
</code></pre></td></tr></table>
</div>
</div><p>提交历史此时改变为下图所示：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200313162155.png" alt=""  />
</p>
<p>此时执行 git status ，命令行输出如下：</p>
<p>HEAD、索引被更改，工作目录未被更改</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200313162204.png" alt=""  />
</p>
<p>可以看出，该命令加上 &ndash;mixed 参数会保留提交的源码改动，只是将索引信息回退到了某一个版本，如果还需要继续提交，再次执行 git add 和 git commit</p>
<h3 id="解决问题">解决问题<a hidden class="anchor" aria-hidden="true" href="#解决问题">#</a></h3>
<p>介绍完git reset，那么我们来说一下如何用该命令解决提交分支错误的问题：</p>
<p>第一种方法：</p>
<p>适用于多个分支一起开发的时候将A分支的改动错误的提交到B的场景：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 将该分支的本不应该提交的commit撤销</span>
git reset HEAD^

<span class="c1"># 按需选择想要回到哪个版本</span>
<span class="c1"># 回到HEAD</span>
git reset --soft HEAD

<span class="c1"># 回到HEAD的前一个版本</span>
git reset --soft HEAD^

<span class="c1"># 回到HEAD的前5个版本</span>
git reset --soft HEAD~5 

<span class="c1"># 利用id回到指定版本</span>
git reset --soft a06ef2f

<span class="c1"># 将撤销的代码暂存起来</span>
git stash

<span class="c1"># 切换到正确的分支</span>
git checkout feat/xxx

<span class="c1"># 重新应用缓存</span>
git stash pop

<span class="c1"># 在正确的分支进行提交操作</span>
git add . <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&#34;update xxxx&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>第二种方法：</p>
<p>适用于在不小心在 master 分支上提交了代码，而实际想要在 feature 分支上提交代码的场景：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 新检出一个新分支，但是仍在master 分支上，并不会切换到新分支</span>
git branch feat/update

<span class="c1"># 恢复master本身提交的状态</span>
git reset --hard origin/master

<span class="c1"># 提交错的代码已经在新检出的分支上面了，可以继续进行开发或者push</span>
git checkout feat/update
</code></pre></td></tr></table>
</div>
</div><p>第三种方法：</p>
<p>适用于想要对特定的某一个或几个commit 进行“嫁接”，使其复制一份到正确的 feature 分支的场景；
在功能性迭代开发中发现一个bug，并提交了一个commit 进行修复，但是发现该bug也存在线上的发布版本上，必须要尽快对线上进行修复，此时可以使用git cherry-pick 将bug 修复的commit 嫁接到 fix 分支上进行代码修复，并及时发布，解决线上bug。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 先切换到正确的分支</span>
git checkout feat/update

<span class="c1"># 取出提交错误的或bug fix的 commit 引入到feat/update 分支中</span>
git cherry-pick a06ef2f

<span class="c1"># 回到错误的分支</span>
git checkout feat/feedback

<span class="c1"># 将 a06ef2f 的改动从当前分支销毁</span>
git reset --head a06ef2f
</code></pre></td></tr></table>
</div>
</div><p>上面演示的是“嫁接” 一个commit，如果想要嫁接多个 commit 可以这样做：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 将三个commit 合并过来</span>
git cherry-pick b9dabf9 e2c739d dad9e51
</code></pre></td></tr></table>
</div>
</div><p>如果想加个一个应用范围内的 commit，可以这样做：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">git cherry-pick 422db47..e2c739d
</code></pre></td></tr></table>
</div>
</div><p>需要注意的是无论是对单个 commit 进行 git cherry-pick ，还是批量处理，注意一定要根据时间线，依照 commit 的先后顺序来处理。</p>
<p>如果你只想把改动转移到目标分支，但是并不想提交，可以这样做：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># --no-commit 参数会使嫁接过来的改动不会提交，只会放在暂存区</span>
git cherry-pick b9dabf9 --no-commit
</code></pre></td></tr></table>
</div>
</div><p>第四种方法：</p>
<p>适用于当多个文件被缓存时，发现其中一个文件是其他分支的功能性改动，想直接取消该文件的缓存：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 编辑了 1.js 2.js 3.js</span>
<span class="c1"># 缓存所有改动的文件</span>
git add .

<span class="c1"># 发现 3.js 不应该出现在此时提交的功能上，要取消它的缓存</span>
git reset 3.js

<span class="c1"># 此时3.js 被取消了缓存，我们继续提交1.js 2.js</span>
git commit -m <span class="s2">&#34;Update 1.js 2.js&#34;</span>

<span class="c1"># 将3.js 暂存起来</span>
git stash

<span class="c1"># 切换到提交 3.js 改动的分支</span>
git checkout feat/update

<span class="c1"># 重新应用缓存起来的 stash（3.js）</span>
<span class="c1"># pop 参数会将缓存栈的第一个stash删除，并将对应修改应用到当前分支目录下</span>
git stash pop

<span class="c1"># 继续提交</span>
git add <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&#34;update 3.js&#34;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="已经推送到远端">已经推送到远端<a hidden class="anchor" aria-hidden="true" href="#已经推送到远端">#</a></h2>
<p>场景：假设我们在 feat/feedback 分支上发现最后一次 commit 的功能是feat/update 分支的改动，此时想要取消这次commit（update 2.js）</p>
<p>下图是feat/feedback 的提交历史：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200313163512.png" alt=""  />
</p>
<p>此时我们需要借助 git revert 命令来撤销我们的操作。</p>
<p>解决方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 撤销最近的一次提交</span>
git revert HEAD --no-edit
</code></pre></td></tr></table>
</div>
</div><p>接着我们使用 sourceTree 查看撤销之后的提交历史：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200313163545.png" alt=""  />
</p>
<p>我们看到想要撤销的 SHA1 为 db6bb3 的 commit（Update 2.js）记录还在，并且多了一个SHA1 为 6e1d7ee 新的 commit（Revert &ldquo;Update 2.js&rdquo;）。因此可以看出，git revert 是对给定的 commit 提交进行逆过程，该命令会引入一个新的提交来抵消给定提交的影响。 和 git cherry-pick 一样，revert命令不修改版本库的现存历史记录，相反它只会在记录添加新的提交。</p>
<p>接下来我们已经解决了错误分支的提交，但是还要把这次提交放到正确的分支上，依然可以使用 git cherry pick 去操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 将revert commit push到远端</span>
git push origin feat/feedback

<span class="c1"># 切换到正确的分支</span>
git checkout feat/update
</code></pre></td></tr></table>
</div>
</div><p>将目标commit 嫁接到当前分支</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">git cherry pick db6bb3f
</code></pre></td></tr></table>
</div>
</div><p>git revert 后面可以加不同的参数达到不同的撤销效果，常用的如下：</p>
<p>&ndash;edit ：该参数为git revert 的默认参数，它会自动创建提交日志提醒，此时会弹出编辑器会话，可以在里面修改提交消息，然后再提交。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">git revert 6ac5152 --edit 
</code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200313163639.png" alt=""  />
</p>
<p>&ndash;no-edit ：表示不编辑 commit 信息，revert 的 commit 会直接自动变回 &lsquo;Revert + 想要撤销的commit 的message&rsquo; 的格式。上面例子中使用的就是这种方式。</p>
<p>&ndash;no-commit：该命令会使撤销的 commit 里面的改动放到暂存区，不进行提交，用户可以自行再次提交。这种参数并且适用于将多个 commit 结果还原到索引中，集体放置在缓冲区，进行用户自定义的操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">git revert 13b7faf --no-commit
</code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200313163711.png" alt=""  />
</p>
<h2 id="已经合到主仓库">已经合到主仓库<a hidden class="anchor" aria-hidden="true" href="#已经合到主仓库">#</a></h2>
<p>当我们把本不属于该分支的代码或者不需要提交的改动提交到主仓库，并合并到了develop 仓库之后，这时想要撤销合到主仓库的改动，解决方式如下：</p>
<p>推荐的工作流程是如在一个新分支中恢复错误的提交。在这里有人会问，为什么不直接在 develop 分支进行 git revert 操作，岂不是更方便，何必麻麻烦烦的去多建一个分支出来？</p>
<p>这么做的原因是：在拥有大量开发人员的团队中， develop、master 分支为保护分支，为了安全不允许或不建议去直接修改。</p>
<p>通过这次操作我们可以了解到：revert 分支的操作实际上是合并进develop 分支的逆操作，它会新产生一个新的分支，将 feat/feedback 的改动还原。</p>
<p>当你使用 git revert 撤销一个 merge commit 时，如果除了 commit 号而不加任何其他参数，git 将会提示错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ git revert g
error: Commit g is a merge but no -m option was given.
fatal: revert failed
</code></pre></td></tr></table>
</div>
</div><p>在你合并两个分支并试图撤销时，Git 并不知道你到底需要保留哪一个分支上所做的修改。从 Git 的角度来看，master 分支和 dev 在地位上是完全平等的，只是在 workflow 中，master 被人为约定成了「主分支」。</p>
<p>于是 Git 需要你通过 m 或 mainline 参数来指定「主线」。merge commit 的 parents 一定是在两个不同的线索上，因此可以通过 parent 来表示「主线」。m 参数的值可以是 1 或者 2，对应着 parent 在 merge commit 信息中的顺序。</p>
<p>举个例子，通常，我们的稳定代码都在 master 分支，而开发过程使用 dev 分支，当开发完成后，再把 dev 分支 merge 进 master 分支：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">a -&gt; b -&gt; c -&gt; f -- g -&gt; h (master)
           \      /
            d -&gt; e  (dev)
</code></pre></td></tr></table>
</div>
</div><p>以上面那张图为例，我们查看 commit g 的内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ git show g
commit g
Merge: f e
</code></pre></td></tr></table>
</div>
</div><p>那么，$ git revert -m 1 g 将会保留 master 分支上的修改，撤销 dev 分支上的修改。</p>
<p>撤销成功之后，Git 将会生成一个新的 Commit，提交历史就成了这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">a -&gt; b -&gt; c -&gt; f -- g -&gt; h -&gt; G (master)
           \      /
            d -&gt; e  (dev)
</code></pre></td></tr></table>
</div>
</div><p>其中 G 是撤销 g 生成的 commit。通过 $ git show G 之后，我们会发现 G 是一个常规提交，内容就是撤销 merge 时被丢弃的那条线索的所有 commit 的「反操作」的合集。</p>
<p>下面我们看一下具体操作:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 添加三个文件</span>
<span class="nb">echo</span> <span class="m">1</span> &gt; 1.html
<span class="nb">echo</span> <span class="m">2</span> &gt; 2.html
<span class="nb">echo</span> <span class="m">3</span> &gt; 3.html

<span class="c1"># 以为提交的是1.html 2.html，将改动推到了远端分支</span>
git add . <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&#34;Add 1.html 2.html&#34;</span>
git push origin feat/update

<span class="c1"># 将feat/update的改动创建一个“合并提交”合入develop 分支，生成的 Merge commit 的SHA1 为 f439c6f</span>
git checkout develop
git merge feat/update --no-ff

<span class="c1"># 如果存在冲突，先解决冲突，然后继续请求合并</span>
git add . <span class="o">&amp;&amp;</span> git merge --continue

<span class="c1"># 将develop 合并的最后结果提交到远端</span>
git push origin develop

<span class="c1"># 合并之后发现不应该将3.html 不应该放入功能迭代中。需要撤销本次合并</span>
<span class="c1"># 做任何操作前，先保证本地的develop 代码是最新状态</span>
git pull --rebase origin develop

<span class="c1"># 从develop分支新建一个 revert 分支</span>
git checkout -b revert-feat/update

<span class="c1"># 用 -m 参数指定父编号（从1开始），因为它是“合并提交”</span>
git revert -m <span class="m">1</span> f439c6f

<span class="c1"># push revert 的改动</span>
git push origin revert-feat/update

<span class="c1"># 切换回 develop 分支，将 revert-feat/update 分支进行合并</span>
git checkout develop
git merge revert-feat/update --no-ff
git push origin develop
</code></pre></td></tr></table>
</div>
</div><p>图为新建revert 分支：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200313170743.png" alt=""  />
</p>
<p>图为git revert 弹出编辑器编辑 revert commit message 过程：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200313170807.png" alt=""  />
</p>
<p>图为执行完git revert 之后的 commit 历史记录：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200313170749.png" alt=""  />
</p>
<p>接下来我们想将 3.html 的改动撤销的操作就变成了上面场景 2 的操作流程了。</p>
<h2 id="主仓库回退错误">主仓库回退错误<a hidden class="anchor" aria-hidden="true" href="#主仓库回退错误">#</a></h2>
<p>当我们的代码合到主仓库，并且成功发布到生产环境，此时发现线上有集中报错，必须马上将线上代码回滚到最新版本。这是我们需要进行revert 操作。revert 的代码发布到生产之后，发现错误仍旧存在，最后排查到是某个外部服务依赖出现问题，本次revert 的改动无关，并且外部服务已经恢复。此时需要将 revert 的改动再次发布上生产环境。</p>
<p>我们可以再用一次git revert，revert 掉我们之前的 revert commit：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">git revert HEAD --no-edit
</code></pre></td></tr></table>
</div>
</div><p>这样 revert 撤销的改动又回来了，此时会发现提交历史上又会出现一个新的revert commit。</p>
<h1 id="暂存区回退错误">暂存区回退错误<a hidden class="anchor" aria-hidden="true" href="#暂存区回退错误">#</a></h1>
<p>如果我们真的使用了git reset &ndash;hard 之后，发现某些修改还有必要的，这时候就需要借助时光机 git reflog “回来未来”了。</p>
<p>git reflog 是非常好用的“后悔药”，它几乎可以恢复我们 commit 过的改动，即使这条 commit 记录已经被我们 reset 掉了。</p>
<p>具体演示如下：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200313171015.png" alt=""  />
</p>
<p>如上图，在当前提交历史中，我们认为最新的两个commit 已经没有用了，想直接reset 到 SHA1 为 c48a245 这个 commit：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 回到 c48a245 commit</span>
git reset --hard c48a245
</code></pre></td></tr></table>
</div>
</div><p>此时提交历史变为现在这样：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200313171059.png" alt=""  />
</p>
<p>此时可以看到SHA1 为c48a245 的 commit 时间线之后的改动都已经被撤销了。 这时候我们突然想到：commit 信息为 “Add 1.html 2.html” 的提交里面的改动很重要，需要被找回，但是我们使用 git log 查看过去提交历史，已经找不到这条被我们 reset 掉的历史记录了。这时候进行如下操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">git reflog
</code></pre></td></tr></table>
</div>
</div><p>我们如愿以偿的看到了曾经提交过的这个想要找回的commit（commit: Add 1.html 2.html），它的 SHA1 为 cf2e245。</p>
<p>接下来怎么做取决于你具体想要达到什么目的：</p>
<p>想要回到cf2e245 这个特定的commit：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">git reset --hard cf2e245
</code></pre></td></tr></table>
</div>
</div><p>想要暂存 cf2e245 中的改动，并且不想马上提交：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">git reset --soft cf2e245
</code></pre></td></tr></table>
</div>
</div><p>想要把cf2e245 嫁接到某个分支目录下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">git checkout feat/xxx
git cherry-pick cf2e245
</code></pre></td></tr></table>
</div>
</div><p>想要找回 cf2e245 某个文件的改动，暂存起来：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">git checkout cf2e245 1.html
</code></pre></td></tr></table>
</div>
</div><p>对于 git reflog 需要注意的是： 它不是万能的。Git 会定期清理那些你已经不再用到的“对象”，如果你想找到几个月以前的提交，可能会指望不上它。</p>
<h1 id="文件修改错误">文件修改错误<a hidden class="anchor" aria-hidden="true" href="#文件修改错误">#</a></h1>
<p>git reset 和 git checkout 命令接受文件路径作为参数。这时它的行为就大为不同了。它不会作用于整份提交，参数将它限制于特定文件。</p>
<h2 id="reset">Reset<a hidden class="anchor" aria-hidden="true" href="#reset">#</a></h2>
<p>当检测到文件路径时，git reset 将缓存区同步到你指定的那个提交。比如，下面这个命令会将倒数第二个提交中的 foo.py 加入到缓存区中，供下一个提交使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">git reset HEAD~2 foo.py
</code></pre></td></tr></table>
</div>
</div><p>和提交层面的 git reset 一样，通常我们使用HEAD而不是某个特定的提交。运行 git reset HEAD foo.py 会将当前的 foo.py 从缓存区中移除出去，而不会影响工作目录中对 foo.py 的更改。</p>
<p>将一个文件从 commit 历史中移动到 stage 缓存中</p>
<p>&ndash;soft、&ndash;mixed 和 &ndash;hard 对文件层面的 git reset 毫无作用，因为缓存区中的文件一定会变化，而工作目录中的文件一定不变。</p>
<h2 id="checkout">Checkout<a hidden class="anchor" aria-hidden="true" href="#checkout">#</a></h2>
<p>Checkout 一个文件和带文件路径 git reset 非常像，除了它更改的是工作目录而不是缓存区。不像提交层面的 checkout 命令，它不会移动 HEAD引用，也就是你不会切换到别的分支上去。</p>
<p>将文件从提交历史移动到工作目录中</p>
<p>比如，下面这个命令将工作目录中的 foo.py 同步到了倒数第二个提交中的 foo.py。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">git checkout HEAD~2 foo.py
</code></pre></td></tr></table>
</div>
</div><p>和提交层面相同的是，它可以用来检查项目的旧版本，但作用域被限制到了特定文件。</p>
<p>如果你缓存并且提交了 checkout 的文件，它具备将某个文件回撤到之前版本的效果。注意它撤销了这个文件后面所有的更改，而 git revert 命令只撤销某个特定提交的更改。</p>
<p>和 git reset 一样，这个命令通常和 HEAD 一起使用。比如 git checkout HEAD foo.py 等同于舍弃 foo.py 没有缓存的更改。这个行为和 git reset HEAD &ndash;hard 很像，但只影响特定文件。</p>
<p>参考:<br>
<a href="https://zhuanlan.zhihu.com/p/42929114">https://zhuanlan.zhihu.com/p/42929114</a><br>
<a href="http://blog.psjay.com/posts/git-revert-merge-commit/">http://blog.psjay.com/posts/git-revert-merge-commit/</a><br>
<a href="https://github.com/geeeeeeeeek/git-recipes">https://github.com/geeeeeeeeek/git-recipes</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/git/">Git</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
