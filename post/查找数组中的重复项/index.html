<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>查找数组中的重复项 | Forz Blog</title>
<meta name="keywords" content="Sliding Window, Hash" />
<meta name="description" content="LeetCode 217. Contains Duplicate Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. 解析：直接构建哈希表 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: bool containsDuplicate(vector&lt;int&gt;&amp;">
<meta name="author" content="">
<link rel="canonical" href="/post/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="查找数组中的重复项" />
<meta property="og:description" content="LeetCode 217. Contains Duplicate Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. 解析：直接构建哈希表 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: bool containsDuplicate(vector&lt;int&gt;&amp;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-24T23:58:05&#43;00:00" />
<meta property="article:modified_time" content="2017-06-24T23:58:05&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="查找数组中的重复项"/>
<meta name="twitter:description" content="LeetCode 217. Contains Duplicate Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. 解析：直接构建哈希表 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: bool containsDuplicate(vector&lt;int&gt;&amp;"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "查找数组中的重复项",
      "item": "/post/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "查找数组中的重复项",
  "name": "查找数组中的重复项",
  "description": "LeetCode 217. Contains Duplicate Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. 解析：直接构建哈希表 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: bool containsDuplicate(vector\u0026lt;int\u0026gt;\u0026amp;",
  "keywords": [
    "Sliding Window", "Hash"
  ],
  "articleBody": "LeetCode 217. Contains Duplicate Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\n解析：直接构建哈希表\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution { public: bool containsDuplicate(vectorint\u0026 nums) { mapint,int hmap; for(int i=0;inums.size();i++){ if(!hmap.count(nums[i])) hmap.insert(make_pair(nums[i],i)); //make_pair()是一个创建二元组的便利函数模板，参数类型可省略  else return true; } return false; } };   LeetCode 219. Contains Duplicate II Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.\n解析：在哈希表中不光要记录某个元素是否出现，还要记录某个元素上一次出现的位置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution { public: bool containsNearbyDuplicate(vectorint\u0026 nums, int k) { mapint,int hmap; for(int i=0;inums.size();i++){ if(!hmap.count(nums[i])) hmap.insert(pairint,int(nums[i],i)); else { if(i-hmap[nums[i]]k) return true; hmap[nums[i]]=i; } } return false; } };   LeetCode 220. Contains Duplicate III Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.\n解析：\n此题既要保证i和j之间的间隔小于等于k，又要保证nums[i]和nums[j]的差值小于t。返回是否存在即可。\n先要保证i和j之间的间隔小于等于k，扫描每一个元素的过程中，建立一个滑动窗口，窗口大小为k。此时以窗口首元素为中心，该窗口就是它的符合要求的最大查找范围。然后在窗口中查找符合条件的i和j。\n由于在窗口内的i和j全都满足间隔小于等于k。只需要判断nums[i]和nums[j]的差值小于t，可以将窗口内部所有元素排序，找到窗口首元素的lower_bound()和upper_bound()-1;进行比较即可。\n因为是在一个容器中进行排序，直接选用set关联容器，自带排序。\n因为ＯＪ上有这条数据：\n[-1,2147483647] 1 2147483647  可以看出，做减法后取绝对值，整型数会溢出，所以容器要用长整型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution { public: bool containsNearbyAlmostDuplicate(vectorint\u0026 nums, int k, int t) { multisetlong long bst;//利用set使用二叉树 //OJ上有这条数据[-1,2147483647]  for (int i = 0; i  nums.size(); ++i) {//扫描数组  if (bst.size() == k + 1) bst.erase(bst.find(nums[i - k - 1])); //维护窗口大小，使BSTBST的大小为 k 或不超过 k，所以这里面的数下标的差值一定是符合条件的  auto lb = bst.lower_bound(nums[i]); //lower_bound()返回一个 iterator 它指向在[first,last)标记的有序序列中第一个大于等于该元素的位置  if (lb != bst.end() \u0026\u0026 abs(*lb - nums[i])  t) return true; auto ub = bst.upper_bound(nums[i]); //lower_bound()返回一个 iterator 它指向在[first,last)标记的有序序列中最后一个小于等于该元素的下一个位置  if (ub != bst.begin() \u0026\u0026 abs(*(--ub) - nums[i])  t) return true; //ub--求得最后一个小于等于该元素的位置  bst.insert(nums[i]); } return false; } };   LeetCode 287. Find the Duplicate Number Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.\nNote:\nYou must not modify the array (assume the array is read only).\nYou must use only constant, O(1) extra space.\nYour runtime complexity should be less than O(n^2).\nThere is only one duplicate number in the array, but it could be repeated more than once.\n解析：\n本题要求不能修改数组而且空间复杂度为O(1)，也就是不能利用排序。而且因为时间复杂度小于O(n^2)不能利用二重循环。所以要先将数组中元素的位置和数值转化为链表关系，然后采用快慢指针的做法。\n假设数组中没有重复，那我们可以做到这么一点，就是将数组的下标和1到n每一个数一对一的映射起来。\n比如数组是213,则映射关系为0-2, 1-1, 2-3。假设这个一对一映射关系是一个函数f(n)，其中n是下标，f(n)是映射到的数。\n如果我们从下标为0出发，根据这个函数计算出一个值，以这个值为新的下标，再用这个函数计算，以此类推，直到下标超界。实际上可以产生一个类似链表一样的序列。\n比如在这个例子中有两个下标的序列，0-2-3。但如果有重复的话，这中间就会产生多对一的映射，比如数组2131,则映射关系为0-2, {1，3}-1, 2-3。\n这样，我们推演的序列就一定会有环路了，这里下标的序列是0-2-3-1-1-1-1-…，而环的起点就是重复的数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution { public: int findDuplicate(vectorint\u0026 nums) { int fast = nums[nums[0]]; int slow = nums[0]; //我们先用快慢两个下标都从0开始，快下标每轮映射两次，慢下标每轮映射一次，直到两个下标再次相同。证明有环。  while(slow != fast) { slow=nums[slow]; fast=nums[nums[fast]]; } //保持慢下标位置不变，再用一个新的下标从0开始，这两个下标都继续每轮映射一次，当这两个下标相遇时，就是环的起点，也就是重复的数。  fast = 0; while(slow!=fast) { slow=nums[slow]; fast=nums[fast]; } return slow; } };   ",
  "wordCount" : "1700",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-24T23:58:05Z",
  "dateModified": "2017-06-24T23:58:05Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      查找数组中的重复项
    </h1>
    <div class="post-meta">June 24, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="leetcode--217-contains-duplicate">LeetCode  217. Contains Duplicate<a hidden class="anchor" aria-hidden="true" href="#leetcode--217-contains-duplicate">#</a></h1>
<p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<p>解析：直接构建哈希表</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">bool</span> <span class="n">containsDuplicate</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">hmap</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">hmap</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">hmap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">i</span><span class="p">));</span>
<span class="c1">//make_pair()是一个创建二元组的便利函数模板，参数类型可省略
</span><span class="c1"></span>            <span class="k">else</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="leetcode-219-contains-duplicate-ii">LeetCode 219. Contains Duplicate II<a hidden class="anchor" aria-hidden="true" href="#leetcode-219-contains-duplicate-ii">#</a></h2>
<p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.</p>
<p>解析：在哈希表中不光要记录某个元素是否出现，还要记录某个元素上一次出现的位置</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
    <span class="nl">public</span><span class="p">:</span>
        <span class="kt">bool</span> <span class="n">containsNearbyDuplicate</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">hmap</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">hmap</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="n">hmap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">i</span><span class="p">));</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="n">hmap</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">&lt;=</span><span class="n">k</span><span class="p">)</span>
                        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
                    <span class="n">hmap</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>  
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-220-contains-duplicate-iii">LeetCode 220. Contains Duplicate III<a hidden class="anchor" aria-hidden="true" href="#leetcode-220-contains-duplicate-iii">#</a></h1>
<p>Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.</p>
<p>解析：</p>
<p>此题既要保证i和j之间的间隔小于等于k，又要保证nums[i]和nums[j]的差值小于t。返回是否存在即可。</p>
<p>先要保证i和j之间的间隔小于等于k，扫描每一个元素的过程中，建立一个滑动窗口，窗口大小为k。此时以窗口首元素为中心，该窗口就是它的符合要求的最大查找范围。然后在窗口中查找符合条件的i和j。</p>
<p>由于在窗口内的i和j全都满足间隔小于等于k。只需要判断nums[i]和nums[j]的差值小于t，可以将窗口内部所有元素排序，找到窗口首元素的lower_bound()和upper_bound()-1;进行比较即可。</p>
<p>因为是在一个容器中进行排序，直接选用set关联容器，自带排序。</p>
<p>因为ＯＪ上有这条数据：</p>
<pre><code>[-1,2147483647]
1
2147483647
</code></pre>
<p>可以看出，做减法后取绝对值，整型数会溢出，所以容器要用长整型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>    
    <span class="kt">bool</span> <span class="n">containsNearbyAlmostDuplicate</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">multiset</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span> <span class="n">bst</span><span class="p">;</span><span class="c1">//利用set使用二叉树
</span><span class="c1">//OJ上有这条数据[-1,2147483647]
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="c1">//扫描数组
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">bst</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">bst</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">bst</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>
            <span class="c1">//维护窗口大小，使BSTBST的大小为 k 或不超过 k，所以这里面的数下标的差值一定是符合条件的
</span><span class="c1"></span>            <span class="k">auto</span> <span class="n">lb</span> <span class="o">=</span> <span class="n">bst</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="c1">//lower_bound()返回一个 iterator 它指向在[first,last)标记的有序序列中第一个大于等于该元素的位置
</span><span class="c1"></span>       <span class="k">if</span> <span class="p">(</span><span class="n">lb</span> <span class="o">!=</span> <span class="n">bst</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">abs</span><span class="p">(</span><span class="o">*</span><span class="n">lb</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">t</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">ub</span> <span class="o">=</span> <span class="n">bst</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="c1">//lower_bound()返回一个 iterator 它指向在[first,last)标记的有序序列中最后一个小于等于该元素的下一个位置
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">ub</span> <span class="o">!=</span> <span class="n">bst</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">abs</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">ub</span><span class="p">)</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">t</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="c1">//ub--求得最后一个小于等于该元素的位置
</span><span class="c1"></span>        <span class="n">bst</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-287-find-the-duplicate-number">LeetCode 287. Find the Duplicate Number<a hidden class="anchor" aria-hidden="true" href="#leetcode-287-find-the-duplicate-number">#</a></h1>
<p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<p>Note:</p>
<p>You must not modify the array (assume the array is read only).</p>
<p>You must use only constant, O(1) extra space.</p>
<p>Your runtime complexity should be less than O(n^2).</p>
<p>There is only one duplicate number in the array, but it could be repeated more than once.</p>
<p>解析：</p>
<p>本题要求不能修改数组而且空间复杂度为O(1)，也就是不能利用排序。而且因为时间复杂度小于O(n^2)不能利用二重循环。所以要先将数组中元素的位置和数值转化为链表关系，然后采用快慢指针的做法。</p>
<p>假设数组中没有重复，那我们可以做到这么一点，就是将数组的下标和1到n每一个数一对一的映射起来。</p>
<p>比如数组是213,则映射关系为0-&gt;2, 1-&gt;1, 2-&gt;3。假设这个一对一映射关系是一个函数f(n)，其中n是下标，f(n)是映射到的数。</p>
<p>如果我们从下标为0出发，根据这个函数计算出一个值，以这个值为新的下标，再用这个函数计算，以此类推，直到下标超界。实际上可以产生一个类似链表一样的序列。</p>
<p>比如在这个例子中有两个下标的序列，0-&gt;2-&gt;3。但如果有重复的话，这中间就会产生多对一的映射，比如数组2131,则映射关系为0-&gt;2, {1，3}-&gt;1, 2-&gt;3。</p>
<p>这样，我们推演的序列就一定会有环路了，这里下标的序列是0-&gt;2-&gt;3-&gt;1-&gt;1-&gt;1-&gt;1-&gt;…，而环的起点就是重复的数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span>
<span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">findDuplicate</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>
    <span class="kt">int</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="c1">//我们先用快慢两个下标都从0开始，快下标每轮映射两次，慢下标每轮映射一次，直到两个下标再次相同。证明有环。
</span><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">slow</span><span class="o">=</span><span class="n">nums</span><span class="p">[</span><span class="n">slow</span><span class="p">];</span>
        <span class="n">fast</span><span class="o">=</span><span class="n">nums</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">fast</span><span class="p">]];</span>
    <span class="p">}</span>
<span class="c1">//保持慢下标位置不变，再用一个新的下标从0开始，这两个下标都继续每轮映射一次，当这两个下标相遇时，就是环的起点，也就是重复的数。
</span><span class="c1"></span>    <span class="n">fast</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">slow</span><span class="o">!=</span><span class="n">fast</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">slow</span><span class="o">=</span><span class="n">nums</span><span class="p">[</span><span class="n">slow</span><span class="p">];</span>
        <span class="n">fast</span><span class="o">=</span><span class="n">nums</span><span class="p">[</span><span class="n">fast</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">slow</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/sliding-window/">Sliding Window</a></li>
      <li><a href="/tags/hash/">Hash</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
