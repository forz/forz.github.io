<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>MongoDB的批量写操作 | Forz Blog</title>
<meta name="keywords" content="MongoDB" />
<meta name="description" content="概述 MongoDB使客户端能够批量执行写操作。批量写入操作会影响单个集合。MongoDB允许应用程序确定批量写入操作所需的可接受的确认级别。">
<meta name="author" content="">
<link rel="canonical" href="/post/mongodb%E7%9A%84%E6%89%B9%E9%87%8F%E5%86%99%E6%93%8D%E4%BD%9C/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="MongoDB的批量写操作" />
<meta property="og:description" content="概述 MongoDB使客户端能够批量执行写操作。批量写入操作会影响单个集合。MongoDB允许应用程序确定批量写入操作所需的可接受的确认级别。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/mongodb%E7%9A%84%E6%89%B9%E9%87%8F%E5%86%99%E6%93%8D%E4%BD%9C/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-06-23T11:41:54&#43;00:00" />
<meta property="article:modified_time" content="2020-06-23T11:41:54&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="MongoDB的批量写操作"/>
<meta name="twitter:description" content="概述 MongoDB使客户端能够批量执行写操作。批量写入操作会影响单个集合。MongoDB允许应用程序确定批量写入操作所需的可接受的确认级别。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "MongoDB的批量写操作",
      "item": "/post/mongodb%E7%9A%84%E6%89%B9%E9%87%8F%E5%86%99%E6%93%8D%E4%BD%9C/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MongoDB的批量写操作",
  "name": "MongoDB的批量写操作",
  "description": "概述 MongoDB使客户端能够批量执行写操作。批量写入操作会影响单个集合。MongoDB允许应用程序确定批量写入操作所需的可接受的确认级别。",
  "keywords": [
    "MongoDB"
  ],
  "articleBody": "概述 MongoDB使客户端能够批量执行写操作。批量写入操作会影响单个集合。MongoDB允许应用程序确定批量写入操作所需的可接受的确认级别。\n3.2版中的新功能。\ndb.collection.bulkWrite()方法提供了执行批量插入，更新和删除操作的能力。MongoDB还支持通过db.collection.insertMany()批量插入。\n有序与无序操作 批量写操作可以有序或无序。\n通过操作的有序列表，MongoDB串行执行操作。如果在写操作之一的处理过程中发生错误，MongoDB将返回而不处理列表中任何剩余的写操作。请参阅有序的批量写入\n使用无序的操作列表，MongoDB可以并行执行操作，但是不能保证此行为。如果在写操作之一的处理过程中发生错误，MongoDB将继续处理列表中剩余的写操作。请参阅无序批量写入。\n在分片集合上执行操作的有序列表通常比执行无序列表要慢，因为对于有序列表，每个操作必须等待上一个操作完成。\n默认情况下，bulkWrite()执行ordered 操作。要指定unordered写操作，请在选项文档中进行设置 。ordered : false\n请参阅执行操作\nbulkWrite（）方法 bulkWrite() 支持以下写操作：\ninsertOne updateOne updateMany replaceOne deleteOne deleteMany 每个写操作都bulkWrite()作为文档传递到数组中。\n例如，以下执行多个写操作：\n该characters集合包含以下文档：\n{ “ _id” ： 1 ， “ char” ： “布里斯班” ， “ class” ： “和尚” ， “ lvl” ： 4 }， { “ _id” ： 2 ， “ char” ： “ Eldon” ， “ class” ： “ alchemist” ， “ lvl” ： 3 }， { “ _id” ： 3 ， “ char” ： “ Meldane” ， “ class” ： “ ranger”， “ lvl” ： 3 } 以下bulkWrite()对集合执行多项操作：\n尝试 { db 。字符。bulkWrite （ [ { insertOne ： { “ document” ： { “ _id” ： 4 ， “ char” ： “ Dithras” ， “ class” ： “ barbarian” ， “ lvl” ： 4 } } } } } {{ insertOne ： { “ document” ： { “ _id” ： 5 ， “ char” ： “ Taeln” ， “ ， “ lvl” ： 3 } } }， { updateOne ： { “ filter” ： { “ char” ： “ Eldon” }， “ update” ： { $ set ： { “ status” ： “严重伤害” } } } }， { deleteOne ： { “ filter” ： { “ char” ： “ Brisbane” } } }}， { replaceOne ： { “ filter” ： { “ char” ： “ Meldane” }， “ replacement” ： { “ char” ： “ Tanys” ， “ class” ： “ oracle” ， “ lvl” ： 4 } } } ] ））； } catch （e ） { print （e ）; } 该操作返回以下内容：\n{ “ acknowledged” ： true ， “ deletedCount” ： 1 ， “ insertedCount” ： 2 ， “ matchedCount” ： 2 ， “ upsertedCount” ： 0 ， “ insertedIds” ： { “ 0” ： 4 ， “ 1” ： 5 }， “ upsertedIds“ ： {\n} } 有关更多示例，请参见 bulkWrite（）示例\n批量插入分片集合的策略 大量的大容量插入操作（包括初始数据插入或常规数据导入）可能会影响分片群集的性能。对于批量插入，请考虑以下策略：\n预分割集合 如果分片集合为空，则该集合只有一个初始块，该块位于单个分片上。然后，MongoDB必须花一些时间来接收数据，创建拆分并将拆分的块分发到可用的分片。为了避免这种性能损失，您可以按照拆分碎片中的拆分块中的说明预先拆分集合 。\n无序写入mongos 要提高对分片群集的写入性能，请使用 bulkWrite()可选参数ordered 设置为false。mongos可以尝试同时将写入发送到多个分片。对于空集合，首先按照分片群集中的分割块中的说明预先分割集合 。\n避免单调节流 如果您的分片键在插入过程中单调增加，则所有插入的数据将到达集合中的最后一块，该块将始终以单个分片结尾。因此，群集的插入容量将永远不会超过该单个分片的插入容量。\n如果插入量大于单个分片可以处理的插入量，并且如果无法避免单调增加的分片键，请考虑对应用程序进行以下修改：\n反转分片密钥的二进制位。这样可以保留信息，并避免将插入顺序与值序列的增加关联起来。 交换第一个和最后一个16位字以“随机”插入。 例\n在C ++中，以下示例交换 生成的BSON ObjectId的前导和尾随16位字，因此它们不再单调递增。\n使用 名称空间 mongo ; OID make_an_id （） { OID x = OID :: gen （）; const unsigned char * p = x 。getData （）; 交换（ （unsigned short ＆） p [ 0 ]， （unsigned short ＆） p [ 10 ] ）; 返回 x ; }\nvoid foo （） { //创建一个对象 BSONObj o = BSON （ “ _id” « make_an_id （） « “ x” « 3 « “ name” « “ jane” ）; //现在我们可以将o插入分片集合 }\n",
  "wordCount" : "1948",
  "inLanguage": "zh-cn",
  "datePublished": "2020-06-23T11:41:54Z",
  "dateModified": "2020-06-23T11:41:54Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/mongodb%E7%9A%84%E6%89%B9%E9%87%8F%E5%86%99%E6%93%8D%E4%BD%9C/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      MongoDB的批量写操作
    </h1>
    <div class="post-meta">June 23, 2020
</div>
  </header> 
  <div class="post-content"><h1 id="概述">概述<a hidden class="anchor" aria-hidden="true" href="#概述">#</a></h1>
<p>MongoDB使客户端能够批量执行写操作。批量写入操作会影响单个集合。MongoDB允许应用程序确定批量写入操作所需的可接受的确认级别。</p>
<p>3.2版中的新功能。</p>
<p>db.collection.bulkWrite()方法提供了执行批量插入，更新和删除操作的能力。MongoDB还支持通过db.collection.insertMany()批量插入。</p>
<p>有序与无序操作
批量写操作可以有序或无序。</p>
<p>通过操作的有序列表，MongoDB串行执行操作。如果在写操作之一的处理过程中发生错误，MongoDB将返回而不处理列表中任何剩余的写操作。请参阅有序的批量写入</p>
<p>使用无序的操作列表，MongoDB可以并行执行操作，但是不能保证此行为。如果在写操作之一的处理过程中发生错误，MongoDB将继续处理列表中剩余的写操作。请参阅无序批量写入。</p>
<p>在分片集合上执行操作的有序列表通常比执行无序列表要慢，因为对于有序列表，每个操作必须等待上一个操作完成。</p>
<p>默认情况下，bulkWrite()执行ordered 操作。要指定unordered写操作，请在选项文档中进行设置 。ordered : false</p>
<p>请参阅执行操作</p>
<p>bulkWrite（）方法
bulkWrite() 支持以下写操作：</p>
<p>insertOne
updateOne
updateMany
replaceOne
deleteOne
deleteMany
每个写操作都bulkWrite()作为文档传递到数组中。</p>
<p>例如，以下执行多个写操作：</p>
<p>该characters集合包含以下文档：</p>
<p>{  “ _id”  ： 1 ， “ char”  ： “布里斯班” ， “ class”  ： “和尚” ， “ lvl”  ： 4  }，
{  “ _id”  ： 2 ， “ char”  ： “ Eldon” ， “ class”  ： “ alchemist” ， “ lvl”  ： 3  }，
{  “ _id”  ： 3 ， “ char”  ： “ Meldane” ， “ class”  ： “ ranger”， “ lvl”  ： 3  }
以下bulkWrite()对集合执行多项操作：</p>
<p>尝试 {
db 。字符。bulkWrite （
[
{  insertOne  ：
{
“ document”  ：
{
“ _id”  ： 4 ， “ char”  ： “ Dithras” ， “ class”  ： “ barbarian” ， “ lvl”  ： 4
}
}
}
} } {{  insertOne  ：
{
“ document”  ：
{
“ _id”  ： 5 ， “ char”  ： “ Taeln” ， “  ， “ lvl”  ： 3
}
}
}，
{  updateOne  ：
{
“ filter”  ： {  “ char”  ： “ Eldon”  }，
“ update”  ： {  $ set  ： {  “ status”  ： “严重伤害”  }  }
}
}，
{  deleteOne  ：
{  “ filter”  ： {  “ char”  ： “ Brisbane” }  }
}}，
{  replaceOne  ：
{
“ filter”  ： {  “ char”  ： “ Meldane”  }，
“ replacement”  ： {  “ char”  ： “ Tanys” ， “ class”  ： “ oracle” ， “ lvl”  ： 4  }
}
}
]
））；
}
catch  （e ） {
print （e ）;
}
该操作返回以下内容：</p>
<p>{
“ acknowledged”  ： true ，
“ deletedCount”  ： 1 ，
“ insertedCount”  ： 2 ，
“ matchedCount”  ： 2 ，
“ upsertedCount”  ： 0 ，
“ insertedIds”  ： {
“ 0”  ： 4 ，
“ 1”  ： 5
}，
“ upsertedIds“  ： {</p>
<p>}
}
有关更多示例，请参见 bulkWrite（）示例</p>
<p>批量插入分片集合的策略
大量的大容量插入操作（包括初始数据插入或常规数据导入）可能会影响分片群集的性能。对于批量插入，请考虑以下策略：</p>
<p>预分割集合
如果分片集合为空，则该集合只有一个初始块，该块位于单个分片上。然后，MongoDB必须花一些时间来接收数据，创建拆分并将拆分的块分发到可用的分片。为了避免这种性能损失，您可以按照拆分碎片中的拆分块中的说明预先拆分集合 。</p>
<p>无序写入mongos
要提高对分片群集的写入性能，请使用 bulkWrite()可选参数ordered 设置为false。mongos可以尝试同时将写入发送到多个分片。对于空集合，首先按照分片群集中的分割块中的说明预先分割集合 。</p>
<p>避免单调节流
如果您的分片键在插入过程中单调增加，则所有插入的数据将到达集合中的最后一块，该块将始终以单个分片结尾。因此，群集的插入容量将永远不会超过该单个分片的插入容量。</p>
<p>如果插入量大于单个分片可以处理的插入量，并且如果无法避免单调增加的分片键，请考虑对应用程序进行以下修改：</p>
<p>反转分片密钥的二进制位。这样可以保留信息，并避免将插入顺序与值序列的增加关联起来。
交换第一个和最后一个16位字以“随机”插入。
例</p>
<p>在C ++中，以下示例交换 生成的BSON ObjectId的前导和尾随16位字，因此它们不再单调递增。</p>
<p>使用 名称空间 mongo ;
OID  make_an_id （） {
OID  x  =  OID :: gen （）;
const  unsigned  char  * p  =  x 。getData （）;
交换（ （unsigned  short ＆） p [ 0 ]， （unsigned  short ＆） p [ 10 ]  ）;
返回 x ;
}</p>
<p>void  foo （） {
//创建一个对象
BSONObj  o  =  BSON （ “ _id”  &laquo;  make_an_id （） &laquo;  “ x”  &laquo;  3  &laquo;  “ name”  &laquo;  “ jane”  ）;
//现在我们可以将o插入分片集合
}</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/mongodb/">MongoDB</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
