<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Linux的网络IO模型 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author"
  content="Forz" /><meta name="description" content="用户空间与内核空间 现代操作系统都是采用虚拟存储器，那么对 32 位操作系统而言，它的寻址空间（虚拟存储空间）为 4G（2 的 32 次方）。操作系统的核心是" /><meta name="keywords"
  content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.84.1 with theme even" />


<link rel="canonical" href="/post/linux%E7%9A%84%E7%BD%91%E7%BB%9Cio%E6%A8%A1%E5%9E%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link rel="stylesheet" href="/css/search.css" />


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Linux的网络IO模型" />
<meta property="og:description" content="用户空间与内核空间 现代操作系统都是采用虚拟存储器，那么对 32 位操作系统而言，它的寻址空间（虚拟存储空间）为 4G（2 的 32 次方）。操作系统的核心是" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/linux%E7%9A%84%E7%BD%91%E7%BB%9Cio%E6%A8%A1%E5%9E%8B/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-11-19T11:30:00&#43;00:00" />
<meta property="article:modified_time" content="2020-11-19T11:30:00&#43;00:00" />

<meta itemprop="name" content="Linux的网络IO模型">
<meta itemprop="description" content="用户空间与内核空间 现代操作系统都是采用虚拟存储器，那么对 32 位操作系统而言，它的寻址空间（虚拟存储空间）为 4G（2 的 32 次方）。操作系统的核心是"><meta itemprop="datePublished" content="2020-11-19T11:30:00&#43;00:00" />
<meta itemprop="dateModified" content="2020-11-19T11:30:00&#43;00:00" />
<meta itemprop="wordCount" content="24567">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Linux的网络IO模型"/>
<meta name="twitter:description" content="用户空间与内核空间 现代操作系统都是采用虚拟存储器，那么对 32 位操作系统而言，它的寻址空间（虚拟存储空间）为 4G（2 的 32 次方）。操作系统的核心是"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="clearfix">
  <div class="logo-wrapper">
    <a href="/" class="logo">Forz Blog</a>
  </div>

  <nav class="site-navbar">
    <ul id="menu" class="menu">
      <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
    </ul>
  </nav>
</div>


<div class="search-container">
  <div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="Search for titles or URIs..."
        name="search" autocomplete="off" />
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path
            d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js"></script>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js"></script>
<script>
    var client = algoliasearch("IAR2EF5L65", "b4b9da2eba53aa6dabe4b8ac9e8676e1");
    var index = client.initIndex('forz.forzvina.com');
    autocomplete('#aa-search-input',
        { hint: false }, {
        source: autocomplete.sources.hits(index, { hitsPerPage: 8 }),
        displayKey: 'name',
        templates: {
            suggestion: function (suggestion) {
                var reg = /([A-Z]+)/ig
                var title = suggestion.uri.replace(reg, function (m) {
                    return m.toLowerCase()
                })
                return '<span class="search-item">' + '<a href="\/' + title + '">' +
                    suggestion._highlightResult.title.value + '</a></span>';
            }
        }
    });
</script>
</div>


    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Linux的网络IO模型</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-11-19 </span>
        <div class="post-category">
            <a href="/categories/linux%E7%BC%96%E7%A8%8B/"> Linux编程 </a>
            </div>
          <span class="more-meta"> 约 24567 字 </span>
          <span class="more-meta"> 预计阅读 50 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#用户空间与内核空间">用户空间与内核空间</a></li>
    <li><a href="#io-模型">I/O 模型</a></li>
    <li><a href="#阻塞-io">阻塞 I/O</a></li>
    <li><a href="#非阻塞-io">非阻塞 I/O</a></li>
    <li><a href="#io-多路复用">I/O 多路复用</a>
      <ul>
        <li><a href="#select--poll">select &amp; poll</a></li>
        <li><a href="#epoll">epoll</a></li>
        <li><a href="#区别-1">区别</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="用户空间与内核空间">用户空间与内核空间</h2>
<p>现代操作系统都是采用虚拟存储器，那么对 32 位操作系统而言，它的寻址空间（虚拟存储空间）为 4G（2 的 32 次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对 Linux 操作系统而言，将最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，称为内核空间，而将较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201119103431.png" alt=""></p>
<p>现代的网络服务的主流已经完成从 CPU 密集型到 IO 密集型的转变，所以服务端程序对 I/O 的处理必不可少，而一旦操作 I/O 则必定要在用户态和内核态之间来回切换。</p>
<h2 id="io-模型">I/O 模型</h2>
<p>在神作《UNIX 网络编程》里，总结归纳了 5 种 I/O 模型，包括同步和异步 I/O：</p>
<ul>
<li>阻塞 I/O (Blocking I/O)</li>
<li>非阻塞 I/O (Nonblocking I/O)</li>
<li>I/O 多路复用 (I/O multiplexing)</li>
<li>信号驱动 I/O (Signal driven I/O)</li>
<li>异步 I/O (Asynchronous I/O)</li>
</ul>
<p>操作系统上的 I/O 是用户空间和内核空间的数据交互，因此 I/O 操作通常包含以下两个步骤：</p>
<ol>
<li>等待网络数据到达网卡(读就绪)/等待网卡可写(写就绪) –&gt; 读取/写入到内核缓冲区</li>
<li>从内核缓冲区复制数据 –&gt; 用户空间(读)/从用户空间复制数据 -&gt; 内核缓冲区(写)</li>
</ol>
<p>而判定一个 I/O 模型是同步还是异步，主要看第二步：数据在用户和内核空间之间复制的时候是不是会阻塞当前进程，如果会，则是同步 I/O，否则，就是异步 I/O。基于这个原则，这 5 种 I/O 模型中只有一种异步 I/O 模型：Asynchronous I/O，其余都是同步 I/O 模型。</p>
<p>这 5 种 I/O 模型的对比如下：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/5-io-model.jpg" alt=""></p>
<p>在描述这块内容的诸多书籍中，很多都只说笼统的概念，我们将问题具体化，暂时只考虑服务器端的网络I/O情形。我们假定目前的情形是服务器已经在监听用户请求，建立连接后服务器调用read()函数等待读取用户发送过来的数据流，之后将接收到的数据打印出来。</p>
<p>所以服务器端简单是这样的流程：建立连接 -&gt; 监听请求 -&gt; 等待用户数据 -&gt; 打印数据。我们总结网络通信中的等待：</p>
<ol>
<li>
<p>建立连接时等待对方的ACK包（TCP）。</p>
</li>
<li>
<p>等待客户端请求（HTTP）。</p>
</li>
<li>
<p>输入等待：服务器用户数据到达内核缓冲区（read函数等待）。</p>
</li>
<li>
<p>输出等待：用户端等待缓冲区有足够空间可以输入（write函数等待）。</p>
</li>
</ol>
<p>另外为了能够解释清楚网络I/O模型，还需要了解一些基础。对服务器而言，打印出用户输入的字符串（printf函数）和从网络中获取数据（read函数）需要单独来看。服务器首先accept用户连接请求后首先调用read函数等待数据，这里的read函数是系统调用，运行于内核态，使用的也是内核地址空间，并且从网络中取得的数据需要先写入到内核缓冲区。当read系统调用获取到数据后将这些数据再复制到用户地址空间的用户缓冲区中，之后返回到用户态执行printf函数打印字符串。我们需要明确两点：</p>
<p>read执行在内核态且数据流先读入内核缓冲区；printf运行于用户态，打印的数据会先从内核缓冲区复制到进程的用户缓冲区，之后打印出来。</p>
<p>printf函数一定是在read函数已经准备好数据之后才能执行，但read函数作为I/O操作通常需要等待而触发阻塞。调用read函数的是服务器进程，一旦被read调用阻塞，整个服务器在获取到用户数据前都不能接受任何其他用户的请求（单进程/线程）。</p>
<p>有了上面的基础，我们就可以介绍下面五种网络I/O模型。</p>
<h2 id="阻塞-io">阻塞 I/O</h2>
<p>阻塞表示一旦调用I/O函数必须等整个I/O完成才返回。正如上面提到的那种情形，当服务器调用了read函数之后，如果不是立即接收到数据，服务器进程会被阻塞，之后一直在等待用户数据到达，用户数据到达后首先会写进内核缓冲区，之后内核缓冲区数据复制到用户进程（服务器进程）缓冲区。完成了上述所有的工作后，才会把执行权限返回给用户（从内核态 -&gt; 用户态）。</p>
<p>很显然，阻塞式I/O的效率实在太低，如果用户输入数据迟迟不到的话，整个服务器就会一直被阻塞（单进程/线程）。为了不影响服务器接收其他进程的连接，我们可以考虑多进程模型，这样当服务器建立连接后为连接的用户创建新线程，新线程即使是使用阻塞式I/O也仅仅是这一个线程被阻塞，不会影响服务器等待接收新的连接。</p>
<p>多线程模型下，主线程等待用户请求，用户有请求到达时创建新线程。新线程负责具体的工作，即使是因为调用了read函数被阻塞也不会影响服务器。我们还可以进一步优化创建连接池和线程池以减小频繁调用I/O接口的开销。但新问题随之产生，每个新线程或者进程（加入使用对进程模型）都会占用大量系统资源，除此之外过多的线程和进程在调度方面开销也会大很对，所以这种模型并不适合大并发量。</p>
<h2 id="非阻塞-io">非阻塞 I/O</h2>
<p>什么叫非阻塞 I/O，顾名思义就是：所有 I/O 操作都是立刻返回而不会阻塞当前用户进程。I/O 多路复用通常情况下需要和非阻塞 I/O 搭配使用，否则可能会产生意想不到的问题。比如，epoll 的 ET(边缘触发) 模式下，如果不使用非阻塞 I/O，有极大的概率会导致阻塞 event-loop 线程，从而降低吞吐量，甚至导致 bug。</p>
<p>Linux 下，我们可以通过 fcntl 系统调用来设置 O_NONBLOCK 标志位，从而把 socket 设置成 Non-blocking。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_SETFL</span><span class="p">,</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>当对一个 Non-blocking socket 执行读操作时，流程是这个样子：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201119105159.png" alt=""></p>
<p>当用户进程发出 read 操作时，如果 kernel 中的数据还没有准备好，那么它并不会 block 用户进程，而是立刻返回一个 EAGAIN error。从用户进程角度讲 ，它发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦 kernel 中的数据准备好了，并且又再次收到了用户进程的 system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<p>所以，Non-blocking I/O 的特点是用户进程需要不断的主动询问 kernel 数据好了没有。</p>
<p>阻塞和非阻塞最大的区别在于调用I/O系统调用后，是等整个I/O过程完成再把操作权限返回给用户还是会立即返回。</p>
<p>非阻塞I/O在调用后会立即返回，用户进程对返回的返回值判断以区分是否完成了I/O。如果返回大于0表示完成了数据读取，返回值即读取的字节数；返回0表示连接已经正常断开；返回-1表示错误，接下来用户进程会不停地询问kernel是否准备完毕。</p>
<p>非阻塞I/O虽然不再会完全阻塞用户进程，但实际上由于用户进程需要不停地询问kernel是否准备完数据，所以整体效率依旧非常低，不适合做并发。</p>
<p>下一节我们要讲的 I/O 多路复用需要和 Non-blocking I/O 配合才能发挥出最大的威力！</p>
<h2 id="io-多路复用">I/O 多路复用</h2>
<p>前面已经论述了多进程、多进程模型会因为开销巨大和调度困难而导致并不能承受高并发量。但不适用这种模型的话，无论是阻塞还是非阻塞方式都会导致整个服务器停滞。</p>
<p>所以对于大并发量，我们需要一种代理模型可以帮助我们集中去管理所有的socket连接，一旦某个socket数据到达了就执行其对应的用户进程，I/O多路复用就是这么一种模型。Linux下I/O多路复用的系统调用有select，poll和epoll，但从本质上来讲他们都是同步I/O范畴。</p>
<p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>
<p>所谓 I/O 多路复用指的就是 select/poll/epoll 这一系列的多路选择器：支持单一线程同时监听多个文件描述符（I/O 事件），阻塞等待，并在其中某个文件描述符可读写时收到通知。 I/O 复用其实复用的不是 I/O 连接，而是复用线程，让一个 thread of control 能够处理多个连接（I/O 事件）。</p>
<p>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：</p>
<p>（1）当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用。</p>
<p>（2）当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</p>
<p>（3）如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</p>
<p>（4）如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</p>
<p>（5）如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</p>
<p>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</p>
<h3 id="select--poll">select &amp; poll</h3>
<p>相关接口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">select</span> <span class="p">(</span><span class="kt">int</span> <span class="n">maxfd</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">readfds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">writefds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">errorfds</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">timeout</span><span class="p">);</span>
<span class="n">FD_ZERO</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">fd_set</span><span class="o">*</span> <span class="n">fds</span><span class="p">)</span> <span class="c1">//清空集合
</span><span class="c1"></span><span class="n">FD_SET</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">fd_set</span><span class="o">*</span> <span class="n">fds</span><span class="p">)</span> <span class="c1">//将给定的描述符加入集合
</span><span class="c1"></span><span class="n">FD_ISSET</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">fd_set</span><span class="o">*</span> <span class="n">fds</span><span class="p">)</span> <span class="c1">//将给定的描述符从文件中删除
</span><span class="c1"></span><span class="n">FD_CLR</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">fd_set</span><span class="o">*</span> <span class="n">fds</span><span class="p">)</span> <span class="c1">//判断指定描述符是否在集合中
</span></code></pre></td></tr></table>
</div>
</div><p>参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-s" data-lang="s"><span class="n">maxfd</span>：当前最大文件描述符的值<span class="m">+1</span>（≠ <span class="n">MAX_CONN</span>）。
<span class="n">readfds</span>：指向读文件队列集合（<span class="n">fd_set</span>）的指针。
<span class="n">writefds</span>：同上，指向读集合的指针。
<span class="n">writefds</span>：同上，指向错误集合的指针。
<span class="n">timeout</span>：指向<span class="n">timeval结构指针</span>，用于设置超时。
</code></pre></td></tr></table>
</div>
</div><p>其他：</p>
<p>判断和操作对象为set_fd集合，集合大小为单个进程可打开的最大文件数1024或2048（可重新编译内核修改但不建议）。</p>
<p>select 是 epoll 之前 Linux 使用的 I/O 事件驱动技术。</p>
<p>select整体流程如下:</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/17201205-8ac47f1f1fcd4773bd4edd947c0bb1f4.png" alt=""></p>
<ol>
<li>
<p>使用copy_from_user从用户空间拷贝fd_set到内核空间</p>
</li>
<li>
<p>注册回调函数__pollwait</p>
<p>__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。</p>
</li>
<li>
<p>遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）.poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。</p>
</li>
<li>
<p>如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout使调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。</p>
</li>
<li>
<p>把fd_set从内核空间拷贝到用户空间。</p>
</li>
</ol>
<p>理解 select 的关键在于理解 fd_set，为说明方便，取 fd_set 长度为 1 字节，fd_set 中的每一 bit 可以对应一个文件描述符 fd，则 1 字节长的 fd_set 最大可以对应 8 个 fd。select 的调用过程如下：</p>
<ol>
<li>执行 FD_ZERO(&amp;set), 则 set 用位表示是 0000,0000</li>
<li>若 fd＝5, 执行 FD_SET(fd, &amp;set); 后 set 变为 0001,0000(第 5 位置为 1)</li>
<li>再加入 fd＝2, fd=1，则 set 变为 0001,0011</li>
<li>执行 select(6, &amp;set, 0, 0, 0) 阻塞等待</li>
<li>若 fd=1, fd=2 上都发生可读事件，则 select 返回，此时 set 变为 0000,0011 (注意：没有事件发生的 fd=5 被清空)</li>
</ol>
<p>基于上面的调用过程，可以得出 select 的特点：</p>
<ul>
<li>可监控的文件描述符个数取决于 sizeof(fd_set) 的值。假设服务器上 sizeof(fd_set)＝512，每 bit 表示一个文件描述符，则服务器上支持的最大文件描述符是 512*8=4096。fd_set 的大小调整可突破 select 可监控的文件描述符上限</li>
<li>将 fd 加入 select 监控集的同时，还要再使用一个数据结构 array 保存放到 select 监控集中的 fd，一是用于在 select 返回后，array 作为源数据和 fd_set 进行 FD_ISSET 判断。二是 select 返回后会把以前加入的但并无事件发生的 fd 清空，则每次开始 select 前都要重新从 array 取得 fd 逐一加入（FD_ZERO 最先），扫描 array 的同时取得 fd 最大值 maxfd，用于 select 的第一个参数</li>
<li>可见 select 模型必须在 select 前循环 array（加 fd，取 maxfd），select 返回后循环 array（FD_ISSET 判断是否有事件发生）</li>
</ul>
<p>所以，select 有如下的缺点：</p>
<ol>
<li>最大并发数限制：使用 32 个整数的 32 位，即 32*32=1024 来标识 fd，虽然可修改，但是有以下第 2, 3 点的瓶颈</li>
<li>每次调用 select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大</li>
<li>性能衰减严重：每次 kernel 都需要线性扫描整个 fd_set，所以随着监控的描述符 fd 数量增长，其 I/O 性能会线性下降</li>
</ol>
<p>poll 的实现和 select 非常相似，只是描述 fd 集合的方式不同，poll 使用 pollfd 结构而不是 select 的 fd_set 结构，poll 解决了最大文件描述符数量限制的问题，但是同样需要从用户态拷贝所有的 fd 到内核态，也需要线性遍历所有的 fd 集合，所以它和 select 只是实现细节上的区分，并没有本质上的区别。</p>
<p>相关接口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">pollfd</span> <span class="o">*</span><span class="n">fds</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nfds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>结构体定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">pollfd</span><span class="p">{</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span> <span class="c1">// 文件描述符
</span><span class="c1"></span>	<span class="kt">short</span> <span class="n">events</span><span class="p">;</span> <span class="c1">// 等到的事件
</span><span class="c1"></span>	<span class="kt">short</span> <span class="n">revents</span><span class="p">;</span> <span class="c1">// 实际发生的事件
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-s" data-lang="s"><span class="n">fds</span>：指向<span class="n">pollfd结构体数组的指针</span>。
<span class="n">nfds</span>：<span class="n">pollfd数组当前已被使用的最大下标</span>。
<span class="n">timeout</span>：等待毫秒数。
</code></pre></td></tr></table>
</div>
</div><p>其他：</p>
<p>判断和操作对象是元素为pollfd类型的数组，数组大小自己设定，即为最大连接数。</p>
<h3 id="epoll">epoll</h3>
<h4 id="原理">原理</h4>
<p>epoll 是 Linux kernel 2.6 之后引入的新 I/O 事件驱动技术，I/O 多路复用的核心设计是 1 个线程处理所有连接的 等待消息准备好 I/O 事件，这一点上 epoll 和 select&amp;poll 是大同小异的。但 select&amp;poll 错误预估了一件事，当数十万并发连接存在时，可能每一毫秒只有数百个活跃的连接，同时其余数十万连接在这一毫秒是非活跃的。select&amp;poll 的使用方法是这样的： 返回的活跃连接 == select(全部待监控的连接) 。</p>
<p>什么时候会调用 select&amp;poll 呢？在你认为需要找出有报文到达的活跃连接时，就应该调用。所以，select&amp;poll 在高并发时是会被频繁调用的。这样，这个频繁调用的方法就很有必要看看它是否有效率，因为，它的轻微效率损失都会被 高频 二字所放大。它有效率损失吗？显而易见，全部待监控连接是数以十万计的，返回的只是数百个活跃连接，这本身就是无效率的表现。被放大后就会发现，处理并发上万个连接时，select&amp;poll 就完全力不从心了。这个时候就该 epoll 上场了，epoll 通过一些新的设计和优化，基本上解决了 select&amp;poll 的问题。</p>
<p>epoll 的 API 非常简洁，涉及到的只有 3 个系统调用：</p>
<p>相关接口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">epoll_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">);</span> <span class="c1">// 创建epoll句柄
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">epoll_ctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">structepoll_event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span> <span class="c1">// 事件注册函数
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">epoll_wait</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span> <span class="n">events</span><span class="p">,</span><span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>结构体定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">epoll_event</span><span class="p">{</span>
    <span class="n">__uint32_t</span> <span class="n">events</span><span class="p">;</span>
    <span class="n">epoll_data_t</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="n">epoll_data</span><span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="n">__uint32_t</span> <span class="n">u32</span><span class="p">;</span>
    <span class="n">__uint64_t</span> <span class="n">u64</span><span class="p">;</span>
<span class="p">}</span><span class="n">epoll_data_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>参数：</p>
<ul>
<li>size：用来告诉内核要监听的数目。</li>
<li>epfd：epoll函数的返回值。</li>
<li>op：表示动作（EPOLL_CTL_ADD/EPOLL_CTL_FD/EPOLL_CTL_DEL）。</li>
<li>fd：需要监听的fd。</li>
<li>events：指向epoll_event的指针，该结构记录监听的事件。</li>
<li>maxevents：告诉内核events的大小。</li>
</ul>
<p>其中，epoll_create 创建一个 epoll 实例并返回 epollfd；epoll_ctl 注册 file descriptor 等待的 I/O 事件(比如 EPOLLIN、EPOLLOUT 等) 到 epoll 实例上；epoll_wait 则是阻塞监听 epoll 实例上所有的 file descriptor 的 I/O 事件，它接收一个用户空间上的一块内存地址 (events 数组)，kernel 会在有 I/O 事件发生的时候把文件描述符列表复制到这块内存地址上，然后 epoll_wait 解除阻塞并返回，最后用户空间上的程序就可以对相应的 fd 进行读写了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">ssize_t</span> <span class="nf">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">);</span>
<span class="n">ssize_t</span> <span class="nf">write</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>epoll 的工作原理如下：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201119111512.png" alt=""></p>
<p>与 select&amp;poll 相比，epoll 分清了高频调用和低频调用。例如，epoll_ctl 相对来说就是非频繁调用的，而 epoll_wait 则是会被高频调用的。所以 epoll 利用 epoll_ctl 来插入或者删除一个 fd，实现用户态到内核态的数据拷贝，这确保了每一个 fd 在其生命周期只需要被拷贝一次，而不是每次调用 epoll_wait 的时候都拷贝一次。 epoll_wait 则被设计成几乎没有入参的调用，相比 select&amp;poll 需要把全部监听的 fd 集合从用户态拷贝至内核态的做法，epoll 的效率就高出了一大截。</p>
<p>在实现上 epoll 采用红黑树来存储所有监听的 fd，而红黑树本身插入和删除性能比较稳定，时间复杂度 O(logN)。通过 epoll_ctl 函数添加进来的 fd 都会被放在红黑树的某个节点内，所以，重复添加是没有用的。当把 fd 添加进来的时候会完成关键的一步：该 fd 会与相应的设备（网卡）驱动程序建立回调关系，也就是在内核中断处理程序为它注册一个回调函数，在 fd 相应的事件触发（中断）之后（设备就绪了），内核就会调用这个回调函数，该回调函数在内核中被称为： ep_poll_callback ，这个回调函数其实就是把这个 fd 添加到 rdllist 这个双向链表（就绪链表）中。epoll_wait 实际上就是去检查 rdllist 双向链表中是否有就绪的 fd，当 rdllist 为空（无就绪 fd）时挂起当前进程，直到 rdllist 非空时进程才被唤醒并返回。</p>
<p>相比于 select&amp;poll 调用时会将全部监听的 fd 从用户态空间拷贝至内核态空间并线性扫描一遍找出就绪的 fd 再返回到用户态，epoll_wait 则是直接返回已就绪 fd，因此 epoll 的 I/O 性能不会像 select&amp;poll 那样随着监听的 fd 数量增加而出现线性衰减，是一个非常高效的 I/O 事件驱动技术。</p>
<p>由于使用 epoll 的 I/O 多路复用需要用户进程自己负责 I/O 读写，从用户进程的角度看，读写过程是阻塞的，所以 select&amp;poll&amp;epoll 本质上都是同步 I/O 模型，而像 Windows 的 IOCP 这一类的异步 I/O，只需要在调用 WSARecv 或 WSASend 方法读写数据的时候把用户空间的内存 buffer 提交给 kernel，kernel 负责数据在用户空间和内核空间拷贝，完成之后就会通知用户进程，整个过程不需要用户进程参与，所以是真正的异步 I/O。</p>
<h4 id="api">API</h4>
<p><code>int epoll_create(int size)</code>:</p>
<p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
<p>从slab缓存中创建一个eventpoll对象,并且创建一个匿名的fd跟fd对应的file对象, 而eventpoll对象保存在struct file结构的private指针中,并且返回,该fd对应的file operations只是实现了poll跟release操作</p>
<p>创建eventpoll对象的初始化操作</p>
<p>获取当前用户信息,是不是root,最大监听fd数目等并且保存到eventpoll对象中初始化等待队列,初始化就绪链表,初始化红黑树的头结点</p>
<p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code>:</p>
<p>epoll的事件注册函数，它不同于select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。第一个参数是epoll_create()的返回值.</p>
<p>第二个参数表示动作，用三个宏来表示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">EPOLL_CTL_ADD</span><span class="err">：注册新的</span><span class="n">fd到epfd中</span><span class="err">；</span>
<span class="n">EPOLL_CTL_MOD</span><span class="err">：修改已经注册的</span><span class="n">fd的监听事件</span><span class="err">；</span>
<span class="n">EPOLL_CTL_DEL</span><span class="err">：从</span><span class="n">epfd中删除一个fd</span><span class="err">；</span>
</code></pre></td></tr></table>
</div>
</div><p>第三个参数是需要监听的fd，第四个参数是告诉内核需要监听什么事，struct epoll_event结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">epoll_event</span> <span class="p">{</span>
  <span class="n">__uint32_t</span> <span class="n">events</span><span class="p">;</span>  <span class="cm">/* Epoll events */</span>
  <span class="n">epoll_data_t</span> <span class="n">data</span><span class="p">;</span>  <span class="cm">/* User data variable */</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>events可以是以下几个宏的集合：</p>
<ul>
<li>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</li>
<li>EPOLLOUT：表示对应的文件描述符可以写；</li>
<li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</li>
<li>EPOLLERR：表示对应的文件描述符发生错误；</li>
<li>EPOLLHUP：表示对应的文件描述符被挂断；</li>
<li>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</li>
<li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</li>
<li>EPOLLRDHUP: 表示对端调用close()关闭socket连接或调用shutdown(SHUT_WR)关闭对端的写。</li>
</ul>
<p>有几点需要注意:</p>
<ul>
<li>对于EPOLLERR和EPOLLHUP，不需要在epoll_event时针对fd作设置，一样也会触发；</li>
<li>EPOLLRDHUP实测在对端关闭时会触发，需要注意的是：
<ul>
<li>对EPOLLRDHUP的处理应该放在EPOLLIN和EPOLLOUT前面，处理方式应该 是close掉相应的fd后，作其他应用层的清理动作；</li>
<li>如果采用的是LT触发模式，且没有close相应的fd, EPOLLRDHUP会持续被触发；</li>
<li>EPOLLRDHUP想要被触发，需要显式地在epoll_ctl调用时设置在events中；</li>
</ul>
</li>
<li>对于EPOLLOUT：有写需要时才通过epoll_ctl添加相应fd，不然在LT模式下会频繁触发;</li>
<li>对于写操作，大部分情况下都处于可写状态，可先直接调用write来发送数据，直到返回 EAGAIN后再使能EPOLLOUT，待触发后再继续write。</li>
</ul>
<p>如何判断对端关闭:</p>
<ul>
<li>优先使用上面介绍的EPOLLRDHUP;</li>
<li>使用EPOLLIN， 然后调用read, 此时返回的ssize_t类型结果为0；</li>
<li>对端关闭包括：ctrl + c, kill, kill -9。</li>
</ul>
<p>将epoll_event结构拷贝到内核空间中，并且判断加入的fd是否支持poll结构(epoll,poll,selectI/O多路复用必须支持poll操作). 并且从epfd-&gt;file-&gt;privatedata获取event_poll对象,根据op区分是添加删除还是修改, 首先在eventpoll结构中的红黑树查找是否已经存在了相对应的fd,没找到* 就支持插入操作,否则报重复的错误.</p>
<p>相对应的修改,删除比较简单就不啰嗦了</p>
<p>插入操作时,会创建一个与fd对应的epitem结构,并且初始化相关成员,比如保存监听的fd跟file结构之类的.</p>
<p>重要的是指定了调用poll_wait时的回调函数用于数据就绪时唤醒进程,(其内部,初始化设备的等待队列,将该进程注册到等待队列)完成这一步,我们的epitem就跟这个socket关联起来了, 当它有状态变化时, 会通过ep_poll_callback()来通知. 最后调用加入的fd的file operation-&gt;poll函数(最后会调用poll_wait操作)用于完成注册操作.最后将epitem结构添加到红黑树中</p>
<p><code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)</code></p>
<p>等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>
<p>计算睡眠时间(如果有),判断eventpoll对象的链表是否为空,不为空那就干活不睡眠.并且初始化一个等待队列,把自己挂上去,设置自己的进程状态 为可睡眠状态.判断是否有信号到来(有的话直接被中断醒来,),如果啥事都没有那就调用schedule_timeout进行睡眠,如果超时或者被唤醒,首先从自己初始化的等待队列删除,然后开始拷贝资源给用户空间了.拷贝资源则是先把就绪事件链表转移到中间链表,然后挨个遍历拷贝到用户空间,并且挨个判断其是否为水平触发,是的话再次插入到就绪链表</p>
<h4 id="工作模式">工作模式</h4>
<p>LT模式状态时，主线程正在epoll_wait等待事件时，请求到了，epoll_wait返回后没有去处理请求(recv)，那么下次epoll_wait时此请求还是会返回（立刻返回了）；而ET模式状态下，这次没处理，下次epoll_wait时将不返回（所以我们应该每次一定要处理）.</p>
<h5 id="level-triggered-lt-水平触发">Level Triggered (LT) 水平触发</h5>
<ol>
<li>
<p>socket接收缓冲区不为空 有数据可读 读事件一直触发</p>
</li>
<li>
<p>socket发送缓冲区不满 可以继续写入数据 写事件一直触发</p>
</li>
</ol>
<p>符合思维习惯，epoll_wait返回的事件就是socket的状态</p>
<p>LT的处理过程：</p>
<ol>
<li>accept一个连接，添加到epoll中监听EPOLLIN|EPOLLOUT事件</li>
<li>当EPOLLIN事件到达时，read fd中的数据并处理</li>
<li>当需要写出数据时，把数据write到fd中；</li>
<li>当EPOLLOUT事件到达时，继续把数据write到fd中；如果数据写出完毕，那么在epoll中关闭EPOLLOUT事件.如果数据较大，无法一次性写出，那么在epoll中监听EPOLLOUT事件.</li>
</ol>
<p>水平触发的问题：不必要的唤醒</p>
<ol>
<li>内核：收到一个新建连接的请求</li>
<li>内核：由于 “惊群效应” ，唤醒两个正在 epoll_wait() 的线程 A 和线程 B</li>
<li>线程A：epoll_wait() 返回</li>
<li>线程B：epoll_wait() 返回</li>
<li>线程A：执行 accept() 并且成功</li>
<li>线程B：执行 accept() 失败，accept() 返回 EAGAIN</li>
</ol>
<p>epoll LT惊群的发生:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 否则会阻塞在IO系统调用，导致没有机会再epoll
</span><span class="c1"></span><span class="n">set_socket_nonblocking</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
<span class="n">epfd</span> <span class="o">=</span> <span class="n">epoll_create</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
<span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">sd</span><span class="p">;</span>
<span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">xx</span><span class="p">);</span>
    <span class="p">...</span> <span class="c1">// 危险区域！如果有共享同一个epfd的进程/线程调用epoll_wait，它们也将会被唤醒！
</span><span class="c1"></span>    <span class="c1">// 这个accept将会有多个进程/线程调用，如果并发请求数很少，那么将仅有几个进程会成功：
</span><span class="c1"></span>    <span class="c1">// 1. 假设accept队列中有n个请求，则仅有n个进程能成功，其它将全部返回EAGAIN (Resource temporarily unavailable)
</span><span class="c1"></span>    <span class="c1">// 2. 如果n很大(即增加请求负载)，虽然返回EAGAIN的比率会降低，但这些进程也并不一定取到了epoll_wait返回当下的那个预期的请求。
</span><span class="c1"></span>    <span class="n">csd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">in_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">in_len</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>再看一遍LT的描述“如果事件来了，不管来了几个，只要仍然有未处理的事件，epoll都会通知你。”，显然，epoll_wait刚刚取到事件的时候的时候，不可能马上就调用accept去处理，事实上，逻辑在epoll_wait函数调用的ep_poll中还没返回的，这个时候，显然符合“仍然有未处理的事件”这个条件，显然这个时候为了实现这个语义，需要做的就是通知别的同样阻塞在同一个epoll句柄睡眠队列上的进程！在实现上，这个语义由两点来保证：</p>
<p>保证1：在LT模式下，“就绪链表”上取出的epi上报完事件后会重新加回“就绪链表”；
保证2：如果“就绪链表”不为空，且此时有进程阻塞在同一个epoll句柄的睡眠队列上，则唤醒它。</p>
<p>epoll LT模式下有进程被不必要唤醒，这一点并不是内核无意而为之的，内核肯定是知道这件事的，这个并不像之前accept惊群那样算是内核的一个缺陷。epoll LT模式只是提供了一种模式，误用这种模式将会造成类似惊群那样的效应。但是不管怎么说，为了讨论上的方便，后面我们姑且将这种效应称作epoll LT惊群吧。</p>
<h5 id="edge-triggered-et-边沿触发">Edge Triggered (ET) 边沿触发</h5>
<ol>
<li>
<p>socket的接收缓冲区状态变化时触发读事件，即空的接收缓冲区刚接收到数据时触发读事件</p>
</li>
<li>
<p>socket的发送缓冲区状态变化时触发写事件，即满的缓冲区刚空出空间时触发读事件</p>
</li>
</ol>
<p>仅在状态变化时触发事件</p>
<p>ET的处理过程：</p>
<ol>
<li>accept一个一个连接，添加到epoll中监听EPOLLIN|EPOLLOUT事件</li>
<li>当EPOLLIN事件到达时，read fd中的数据并处理，read需要一直读，直到返回EAGAIN为止</li>
<li>当需要写出数据时，把数据write到fd中，直到数据全部写完，或者write返回EAGAIN</li>
<li>当EPOLLOUT事件到达时，继续把数据write到fd中，直到数据全部写完，或者write返回EAGAIN</li>
</ol>
<p>边缘触发的问题：不必要的唤醒以及饥饿</p>
<p>不必要的唤醒：</p>
<ol>
<li>内核：收到第一个连接请求。线程 A 和 线程 B 两个线程都在 epoll_wait() 上等待。由于采用边缘触发模式，所以只有一个线程会收到通知。这里假定线程 A 收到通知</li>
<li>线程A：epoll_wait() 返回</li>
<li>线程A：调用 accpet() 并且成功</li>
<li>内核：此时 accept queue 为空，所以将边缘触发的 socket 的状态从可读置成不可读</li>
<li>内核：收到第二个建连请求</li>
<li>内核：此时，由于线程 A 还在执行 accept() 处理，只剩下线程 B 在等待 epoll_wait()，于是唤醒线程 B</li>
<li>线程A：继续执行 accept() 直到返回 EAGAIN</li>
<li>线程B：执行 accept()，并返回 EAGAIN，此时线程 B 可能有点困惑(“明明通知我有事件，结果却返回 EAGAIN”)</li>
<li>线程A：再次执行 accept()，这次终于返回 EAGAIN</li>
</ol>
<p>饥饿：</p>
<ol>
<li>内核：接收到两个建连请求。线程 A 和 线程 B 两个线程都在等在 epoll_wait()。由于采用边缘触发模式，只有一个线程会被唤醒，我们这里假定线程 A 先被唤醒</li>
<li>线程A：epoll_wait() 返回</li>
<li>线程A：调用 accpet() 并且成功</li>
<li>内核：收到第三个建连请求。由于线程 A 还没有处理完(没有返回 EAGAIN)，当前 socket 还处于可读的状态，由于是边缘触发模式，所有不会产生新的事件</li>
<li>线程A：继续执行 accept() 希望返回 EAGAIN 再进入 epoll_wait() 等待，然而它又 accept() 成功并处理了一个新连接</li>
<li>内核：又收到了第四个建连请求</li>
<li>线程A：又继续执行 accept()，结果又返回成功</li>
</ol>
<p>由于epi entry的callback即ep_poll_callback所做的事情仅仅是将该epi自身加入到epoll句柄的“就绪链表”，同时唤醒在epoll句柄睡眠队列上的task，所以这里并不对事件的细节进行计数，比如说，如果ep_poll_callback在将一个epi加入“就绪链表”之前发现它已经在“就绪链表”了，那么就不会再次添加，因此可以说，一个epi可能pending了多个事件，注意到这点非常重要！</p>
<p>一个epi上pending多个事件，这个在LT模式下没有任何问题，因为获取事件的epi总是会被重新添加回“就绪链表”，那么如果还有事件，在下次check的时候总会取到。然而对于ET模式，仅仅将epi从“就绪链表”删除并将事件本身上报后就返回了，因此如果该epi里还有事件，则只能等待再次发生事件，进而调用ep_poll_callback时将该epi加入“就绪队列”。这意味着什么？</p>
<p>这意味着，应用程序，即epoll_wait的调用进程必须自己在获取事件后将其处理干净后方可再次调用epoll_wait，否则epoll_wait不会返回，而是必须等到下次产生事件的时候方可返回。这会导致事件堆积，所以一般会死循环一直拉取事件，直到拉取不到了再返回。</p>
<ol>
<li>
<p>对于读操作，如果read没有一次读完buff数据，下一次将得不到就绪通知（ET特性），造成buff中数据无法读出，除非有新数据到达。
解决方法：将套接字设置为非阻塞，用while循环包住read，只要buff中有数据，就一直读。一直读到产生EAGIN错误。</p>
</li>
<li>
<p>对于写操作主要因为ET模式下非阻塞需要我们考虑如何将用户要求写的数据写完。
解决方法：只要buff还有空间且用户请求写的数据还未写完，就一直写。</p>
</li>
</ol>
<h5 id="区别">区别</h5>
<p>边缘触发会比条件触发更高效一些，因为边缘触发不会让同一个文件描述符多次被处理,比如有些文件描述符已经不需要再读写了,但是在条件触发下每次都会返回,而边缘触发只会返回一次。</p>
<p>ET模式下每次write或read需要循环write或read直到返回EAGAIN错误。以读操作为例，这是因为ET模式只在socket描述符状态发生变化时才触发事件，如果不一次把socket内核缓冲区的数据读完，会导致socket内核缓冲区中即使还有一部分数据，该socket的可读事件也不会被触发.</p>
<p>根据上面的讨论，若ET模式下使用阻塞IO，则程序一定会阻塞在最后一次write或read操作，因此说ET模式下一定要使用非阻塞IO</p>
<h4 id="对端close">对端close</h4>
<p>对端close时，如果接收缓冲区内已无数据，则走tcp四次挥手流程，发送FIN 包，此时本端会触发事件如下：
EPOLLRDHUP （需要主动在epoll_ctal时加入events） EPOLLIN EPOLLOUT</p>
<p>此时应优先处理EPOLLRDHUP,它明确表明对端已经关闭，处理时close相应fd后，无需再继续处理其他事件；</p>
<p>如果不处理EPOLLRDHUP的话，也可以处理EPOLLIN事件，此时read返回0, 同样表明对端已经关闭；</p>
<p>如果以上两个事件都没有处理，而是在EPOLLOUT事件里又向fd写了数据，数据只是写入到本地tcp发送缓冲区，此时write调用会返回成功，但是紧接着epoll_wait又会返回如下事件组合：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-s" data-lang="s"><span class="n">EPOLLERR</span> <span class="n">EPOLLHUP</span> <span class="n">EPOLLIN</span> <span class="n">EPOLLOUT</span> <span class="n">POLLRDHUP</span> （需要主动在<span class="n">epoll_ctal时加入events</span>）
</code></pre></td></tr></table>
</div>
</div><p>可以看到相比之前多了EPOLLERR和EPOLLHUP，是因为之前收到了对端close时发送的FIN 包，此时再给对端发送数据，对端会返回RST包。</p>
<p>如果在收到RST包后，又向对端发送数据，会收到sigpipe异常，其默认处理是终止当前进程，此时可通过忽略此异常解决，忽略后write会返回</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-s" data-lang="s"><span class="m">-1</span><span class="p">,</span> <span class="n">erron</span> <span class="o">=</span><span class="m">32</span><span class="p">,</span> <span class="n">Broken</span> <span class="n">pipe</span><span class="o">:</span><span class="n">c</span> <span class="nf">signal</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="n">SIG_IGN</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>Broker pipie这个异常，说到底是应用层没有对相应的fd在收到对端关闭通知时，作正确的处理所致，它并不是tcp/ip通讯层面的问题。</p>
<p>下图可以看到发送了FIN包</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201121163438.png" alt=""></p>
<p>对端close（kill, kill -9）时，如果接收缓冲区内还有数据，不会发送FIN包，而是发送RST,此时本端：</p>
<p>收到RST后的第一次写操作，写失败，errno = 104, Connection reset by peer; 之后将触发下列事件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-s" data-lang="s"><span class="n">EPOLLIN</span> <span class="n">EPOLLOUT</span> <span class="n">EPOLLHUP</span> <span class="n">EPOLLRDHUP</span>（需要主动在<span class="n">epoll_ctal时加入events</span>）
</code></pre></td></tr></table>
</div>
</div><p>收到RST后的第二次及后序的写操作，写失败，在忽略了SIGPIPE后，erron =32, Broken pipe；</p>
<p>收到RST后的读操作：errno = 104, Connection reset by peer</p>
<p>下面可以看到发送了RST包：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201121163632.png" alt=""></p>
<h4 id="epoll源码">epoll源码</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span><span class="lnt">319
</span><span class="lnt">320
</span><span class="lnt">321
</span><span class="lnt">322
</span><span class="lnt">323
</span><span class="lnt">324
</span><span class="lnt">325
</span><span class="lnt">326
</span><span class="lnt">327
</span><span class="lnt">328
</span><span class="lnt">329
</span><span class="lnt">330
</span><span class="lnt">331
</span><span class="lnt">332
</span><span class="lnt">333
</span><span class="lnt">334
</span><span class="lnt">335
</span><span class="lnt">336
</span><span class="lnt">337
</span><span class="lnt">338
</span><span class="lnt">339
</span><span class="lnt">340
</span><span class="lnt">341
</span><span class="lnt">342
</span><span class="lnt">343
</span><span class="lnt">344
</span><span class="lnt">345
</span><span class="lnt">346
</span><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span><span class="lnt">351
</span><span class="lnt">352
</span><span class="lnt">353
</span><span class="lnt">354
</span><span class="lnt">355
</span><span class="lnt">356
</span><span class="lnt">357
</span><span class="lnt">358
</span><span class="lnt">359
</span><span class="lnt">360
</span><span class="lnt">361
</span><span class="lnt">362
</span><span class="lnt">363
</span><span class="lnt">364
</span><span class="lnt">365
</span><span class="lnt">366
</span><span class="lnt">367
</span><span class="lnt">368
</span><span class="lnt">369
</span><span class="lnt">370
</span><span class="lnt">371
</span><span class="lnt">372
</span><span class="lnt">373
</span><span class="lnt">374
</span><span class="lnt">375
</span><span class="lnt">376
</span><span class="lnt">377
</span><span class="lnt">378
</span><span class="lnt">379
</span><span class="lnt">380
</span><span class="lnt">381
</span><span class="lnt">382
</span><span class="lnt">383
</span><span class="lnt">384
</span><span class="lnt">385
</span><span class="lnt">386
</span><span class="lnt">387
</span><span class="lnt">388
</span><span class="lnt">389
</span><span class="lnt">390
</span><span class="lnt">391
</span><span class="lnt">392
</span><span class="lnt">393
</span><span class="lnt">394
</span><span class="lnt">395
</span><span class="lnt">396
</span><span class="lnt">397
</span><span class="lnt">398
</span><span class="lnt">399
</span><span class="lnt">400
</span><span class="lnt">401
</span><span class="lnt">402
</span><span class="lnt">403
</span><span class="lnt">404
</span><span class="lnt">405
</span><span class="lnt">406
</span><span class="lnt">407
</span><span class="lnt">408
</span><span class="lnt">409
</span><span class="lnt">410
</span><span class="lnt">411
</span><span class="lnt">412
</span><span class="lnt">413
</span><span class="lnt">414
</span><span class="lnt">415
</span><span class="lnt">416
</span><span class="lnt">417
</span><span class="lnt">418
</span><span class="lnt">419
</span><span class="lnt">420
</span><span class="lnt">421
</span><span class="lnt">422
</span><span class="lnt">423
</span><span class="lnt">424
</span><span class="lnt">425
</span><span class="lnt">426
</span><span class="lnt">427
</span><span class="lnt">428
</span><span class="lnt">429
</span><span class="lnt">430
</span><span class="lnt">431
</span><span class="lnt">432
</span><span class="lnt">433
</span><span class="lnt">434
</span><span class="lnt">435
</span><span class="lnt">436
</span><span class="lnt">437
</span><span class="lnt">438
</span><span class="lnt">439
</span><span class="lnt">440
</span><span class="lnt">441
</span><span class="lnt">442
</span><span class="lnt">443
</span><span class="lnt">444
</span><span class="lnt">445
</span><span class="lnt">446
</span><span class="lnt">447
</span><span class="lnt">448
</span><span class="lnt">449
</span><span class="lnt">450
</span><span class="lnt">451
</span><span class="lnt">452
</span><span class="lnt">453
</span><span class="lnt">454
</span><span class="lnt">455
</span><span class="lnt">456
</span><span class="lnt">457
</span><span class="lnt">458
</span><span class="lnt">459
</span><span class="lnt">460
</span><span class="lnt">461
</span><span class="lnt">462
</span><span class="lnt">463
</span><span class="lnt">464
</span><span class="lnt">465
</span><span class="lnt">466
</span><span class="lnt">467
</span><span class="lnt">468
</span><span class="lnt">469
</span><span class="lnt">470
</span><span class="lnt">471
</span><span class="lnt">472
</span><span class="lnt">473
</span><span class="lnt">474
</span><span class="lnt">475
</span><span class="lnt">476
</span><span class="lnt">477
</span><span class="lnt">478
</span><span class="lnt">479
</span><span class="lnt">480
</span><span class="lnt">481
</span><span class="lnt">482
</span><span class="lnt">483
</span><span class="lnt">484
</span><span class="lnt">485
</span><span class="lnt">486
</span><span class="lnt">487
</span><span class="lnt">488
</span><span class="lnt">489
</span><span class="lnt">490
</span><span class="lnt">491
</span><span class="lnt">492
</span><span class="lnt">493
</span><span class="lnt">494
</span><span class="lnt">495
</span><span class="lnt">496
</span><span class="lnt">497
</span><span class="lnt">498
</span><span class="lnt">499
</span><span class="lnt">500
</span><span class="lnt">501
</span><span class="lnt">502
</span><span class="lnt">503
</span><span class="lnt">504
</span><span class="lnt">505
</span><span class="lnt">506
</span><span class="lnt">507
</span><span class="lnt">508
</span><span class="lnt">509
</span><span class="lnt">510
</span><span class="lnt">511
</span><span class="lnt">512
</span><span class="lnt">513
</span><span class="lnt">514
</span><span class="lnt">515
</span><span class="lnt">516
</span><span class="lnt">517
</span><span class="lnt">518
</span><span class="lnt">519
</span><span class="lnt">520
</span><span class="lnt">521
</span><span class="lnt">522
</span><span class="lnt">523
</span><span class="lnt">524
</span><span class="lnt">525
</span><span class="lnt">526
</span><span class="lnt">527
</span><span class="lnt">528
</span><span class="lnt">529
</span><span class="lnt">530
</span><span class="lnt">531
</span><span class="lnt">532
</span><span class="lnt">533
</span><span class="lnt">534
</span><span class="lnt">535
</span><span class="lnt">536
</span><span class="lnt">537
</span><span class="lnt">538
</span><span class="lnt">539
</span><span class="lnt">540
</span><span class="lnt">541
</span><span class="lnt">542
</span><span class="lnt">543
</span><span class="lnt">544
</span><span class="lnt">545
</span><span class="lnt">546
</span><span class="lnt">547
</span><span class="lnt">548
</span><span class="lnt">549
</span><span class="lnt">550
</span><span class="lnt">551
</span><span class="lnt">552
</span><span class="lnt">553
</span><span class="lnt">554
</span><span class="lnt">555
</span><span class="lnt">556
</span><span class="lnt">557
</span><span class="lnt">558
</span><span class="lnt">559
</span><span class="lnt">560
</span><span class="lnt">561
</span><span class="lnt">562
</span><span class="lnt">563
</span><span class="lnt">564
</span><span class="lnt">565
</span><span class="lnt">566
</span><span class="lnt">567
</span><span class="lnt">568
</span><span class="lnt">569
</span><span class="lnt">570
</span><span class="lnt">571
</span><span class="lnt">572
</span><span class="lnt">573
</span><span class="lnt">574
</span><span class="lnt">575
</span><span class="lnt">576
</span><span class="lnt">577
</span><span class="lnt">578
</span><span class="lnt">579
</span><span class="lnt">580
</span><span class="lnt">581
</span><span class="lnt">582
</span><span class="lnt">583
</span><span class="lnt">584
</span><span class="lnt">585
</span><span class="lnt">586
</span><span class="lnt">587
</span><span class="lnt">588
</span><span class="lnt">589
</span><span class="lnt">590
</span><span class="lnt">591
</span><span class="lnt">592
</span><span class="lnt">593
</span><span class="lnt">594
</span><span class="lnt">595
</span><span class="lnt">596
</span><span class="lnt">597
</span><span class="lnt">598
</span><span class="lnt">599
</span><span class="lnt">600
</span><span class="lnt">601
</span><span class="lnt">602
</span><span class="lnt">603
</span><span class="lnt">604
</span><span class="lnt">605
</span><span class="lnt">606
</span><span class="lnt">607
</span><span class="lnt">608
</span><span class="lnt">609
</span><span class="lnt">610
</span><span class="lnt">611
</span><span class="lnt">612
</span><span class="lnt">613
</span><span class="lnt">614
</span><span class="lnt">615
</span><span class="lnt">616
</span><span class="lnt">617
</span><span class="lnt">618
</span><span class="lnt">619
</span><span class="lnt">620
</span><span class="lnt">621
</span><span class="lnt">622
</span><span class="lnt">623
</span><span class="lnt">624
</span><span class="lnt">625
</span><span class="lnt">626
</span><span class="lnt">627
</span><span class="lnt">628
</span><span class="lnt">629
</span><span class="lnt">630
</span><span class="lnt">631
</span><span class="lnt">632
</span><span class="lnt">633
</span><span class="lnt">634
</span><span class="lnt">635
</span><span class="lnt">636
</span><span class="lnt">637
</span><span class="lnt">638
</span><span class="lnt">639
</span><span class="lnt">640
</span><span class="lnt">641
</span><span class="lnt">642
</span><span class="lnt">643
</span><span class="lnt">644
</span><span class="lnt">645
</span><span class="lnt">646
</span><span class="lnt">647
</span><span class="lnt">648
</span><span class="lnt">649
</span><span class="lnt">650
</span><span class="lnt">651
</span><span class="lnt">652
</span><span class="lnt">653
</span><span class="lnt">654
</span><span class="lnt">655
</span><span class="lnt">656
</span><span class="lnt">657
</span><span class="lnt">658
</span><span class="lnt">659
</span><span class="lnt">660
</span><span class="lnt">661
</span><span class="lnt">662
</span><span class="lnt">663
</span><span class="lnt">664
</span><span class="lnt">665
</span><span class="lnt">666
</span><span class="lnt">667
</span><span class="lnt">668
</span><span class="lnt">669
</span><span class="lnt">670
</span><span class="lnt">671
</span><span class="lnt">672
</span><span class="lnt">673
</span><span class="lnt">674
</span><span class="lnt">675
</span><span class="lnt">676
</span><span class="lnt">677
</span><span class="lnt">678
</span><span class="lnt">679
</span><span class="lnt">680
</span><span class="lnt">681
</span><span class="lnt">682
</span><span class="lnt">683
</span><span class="lnt">684
</span><span class="lnt">685
</span><span class="lnt">686
</span><span class="lnt">687
</span><span class="lnt">688
</span><span class="lnt">689
</span><span class="lnt">690
</span><span class="lnt">691
</span><span class="lnt">692
</span><span class="lnt">693
</span><span class="lnt">694
</span><span class="lnt">695
</span><span class="lnt">696
</span><span class="lnt">697
</span><span class="lnt">698
</span><span class="lnt">699
</span><span class="lnt">700
</span><span class="lnt">701
</span><span class="lnt">702
</span><span class="lnt">703
</span><span class="lnt">704
</span><span class="lnt">705
</span><span class="lnt">706
</span><span class="lnt">707
</span><span class="lnt">708
</span><span class="lnt">709
</span><span class="lnt">710
</span><span class="lnt">711
</span><span class="lnt">712
</span><span class="lnt">713
</span><span class="lnt">714
</span><span class="lnt">715
</span><span class="lnt">716
</span><span class="lnt">717
</span><span class="lnt">718
</span><span class="lnt">719
</span><span class="lnt">720
</span><span class="lnt">721
</span><span class="lnt">722
</span><span class="lnt">723
</span><span class="lnt">724
</span><span class="lnt">725
</span><span class="lnt">726
</span><span class="lnt">727
</span><span class="lnt">728
</span><span class="lnt">729
</span><span class="lnt">730
</span><span class="lnt">731
</span><span class="lnt">732
</span><span class="lnt">733
</span><span class="lnt">734
</span><span class="lnt">735
</span><span class="lnt">736
</span><span class="lnt">737
</span><span class="lnt">738
</span><span class="lnt">739
</span><span class="lnt">740
</span><span class="lnt">741
</span><span class="lnt">742
</span><span class="lnt">743
</span><span class="lnt">744
</span><span class="lnt">745
</span><span class="lnt">746
</span><span class="lnt">747
</span><span class="lnt">748
</span><span class="lnt">749
</span><span class="lnt">750
</span><span class="lnt">751
</span><span class="lnt">752
</span><span class="lnt">753
</span><span class="lnt">754
</span><span class="lnt">755
</span><span class="lnt">756
</span><span class="lnt">757
</span><span class="lnt">758
</span><span class="lnt">759
</span><span class="lnt">760
</span><span class="lnt">761
</span><span class="lnt">762
</span><span class="lnt">763
</span><span class="lnt">764
</span><span class="lnt">765
</span><span class="lnt">766
</span><span class="lnt">767
</span><span class="lnt">768
</span><span class="lnt">769
</span><span class="lnt">770
</span><span class="lnt">771
</span><span class="lnt">772
</span><span class="lnt">773
</span><span class="lnt">774
</span><span class="lnt">775
</span><span class="lnt">776
</span><span class="lnt">777
</span><span class="lnt">778
</span><span class="lnt">779
</span><span class="lnt">780
</span><span class="lnt">781
</span><span class="lnt">782
</span><span class="lnt">783
</span><span class="lnt">784
</span><span class="lnt">785
</span><span class="lnt">786
</span><span class="lnt">787
</span><span class="lnt">788
</span><span class="lnt">789
</span><span class="lnt">790
</span><span class="lnt">791
</span><span class="lnt">792
</span><span class="lnt">793
</span><span class="lnt">794
</span><span class="lnt">795
</span><span class="lnt">796
</span><span class="lnt">797
</span><span class="lnt">798
</span><span class="lnt">799
</span><span class="lnt">800
</span><span class="lnt">801
</span><span class="lnt">802
</span><span class="lnt">803
</span><span class="lnt">804
</span><span class="lnt">805
</span><span class="lnt">806
</span><span class="lnt">807
</span><span class="lnt">808
</span><span class="lnt">809
</span><span class="lnt">810
</span><span class="lnt">811
</span><span class="lnt">812
</span><span class="lnt">813
</span><span class="lnt">814
</span><span class="lnt">815
</span><span class="lnt">816
</span><span class="lnt">817
</span><span class="lnt">818
</span><span class="lnt">819
</span><span class="lnt">820
</span><span class="lnt">821
</span><span class="lnt">822
</span><span class="lnt">823
</span><span class="lnt">824
</span><span class="lnt">825
</span><span class="lnt">826
</span><span class="lnt">827
</span><span class="lnt">828
</span><span class="lnt">829
</span><span class="lnt">830
</span><span class="lnt">831
</span><span class="lnt">832
</span><span class="lnt">833
</span><span class="lnt">834
</span><span class="lnt">835
</span><span class="lnt">836
</span><span class="lnt">837
</span><span class="lnt">838
</span><span class="lnt">839
</span><span class="lnt">840
</span><span class="lnt">841
</span><span class="lnt">842
</span><span class="lnt">843
</span><span class="lnt">844
</span><span class="lnt">845
</span><span class="lnt">846
</span><span class="lnt">847
</span><span class="lnt">848
</span><span class="lnt">849
</span><span class="lnt">850
</span><span class="lnt">851
</span><span class="lnt">852
</span><span class="lnt">853
</span><span class="lnt">854
</span><span class="lnt">855
</span><span class="lnt">856
</span><span class="lnt">857
</span><span class="lnt">858
</span><span class="lnt">859
</span><span class="lnt">860
</span><span class="lnt">861
</span><span class="lnt">862
</span><span class="lnt">863
</span><span class="lnt">864
</span><span class="lnt">865
</span><span class="lnt">866
</span><span class="lnt">867
</span><span class="lnt">868
</span><span class="lnt">869
</span><span class="lnt">870
</span><span class="lnt">871
</span><span class="lnt">872
</span><span class="lnt">873
</span><span class="lnt">874
</span><span class="lnt">875
</span><span class="lnt">876
</span><span class="lnt">877
</span><span class="lnt">878
</span><span class="lnt">879
</span><span class="lnt">880
</span><span class="lnt">881
</span><span class="lnt">882
</span><span class="lnt">883
</span><span class="lnt">884
</span><span class="lnt">885
</span><span class="lnt">886
</span><span class="lnt">887
</span><span class="lnt">888
</span><span class="lnt">889
</span><span class="lnt">890
</span><span class="lnt">891
</span><span class="lnt">892
</span><span class="lnt">893
</span><span class="lnt">894
</span><span class="lnt">895
</span><span class="lnt">896
</span><span class="lnt">897
</span><span class="lnt">898
</span><span class="lnt">899
</span><span class="lnt">900
</span><span class="lnt">901
</span><span class="lnt">902
</span><span class="lnt">903
</span><span class="lnt">904
</span><span class="lnt">905
</span><span class="lnt">906
</span><span class="lnt">907
</span><span class="lnt">908
</span><span class="lnt">909
</span><span class="lnt">910
</span><span class="lnt">911
</span><span class="lnt">912
</span><span class="lnt">913
</span><span class="lnt">914
</span><span class="lnt">915
</span><span class="lnt">916
</span><span class="lnt">917
</span><span class="lnt">918
</span><span class="lnt">919
</span><span class="lnt">920
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm"> *  fs/eventpoll.c (Efficient event retrieval implementation)
</span><span class="cm"> *  Copyright (C) 2001,...,2009     Davide Libenzi
</span><span class="cm"> *
</span><span class="cm"> *  This program is free software; you can redistribute it and/or modify
</span><span class="cm"> *  it under the terms of the GNU General Public License as published by
</span><span class="cm"> *  the Free Software Foundation; either version 2 of the License, or
</span><span class="cm"> *  (at your option) any later version.
</span><span class="cm"> *
</span><span class="cm"> *  Davide Libenzi &lt;davidel@xmailserver.org&gt;
</span><span class="cm"> *
</span><span class="cm"> */</span>
<span class="cm">/*
</span><span class="cm"> * 在深入了解epoll的实现之前, 先来了解内核的3个方面.
</span><span class="cm"> * 1. 等待队列 waitqueue
</span><span class="cm"> * 我们简单解释一下等待队列:
</span><span class="cm"> * 队列头(wait_queue_head_t)往往是资源生产者,
</span><span class="cm"> * 队列成员(wait_queue_t)往往是资源消费者,
</span><span class="cm"> * 当头的资源ready后, 会逐个执行每个成员指定的回调函数,
</span><span class="cm"> * 来通知它们资源已经ready了, 等待队列大致就这个意思.
</span><span class="cm"> * 2. 内核的poll机制
</span><span class="cm"> * 被Poll的fd, 必须在实现上支持内核的Poll技术,
</span><span class="cm"> * 比如fd是某个字符设备,或者是个socket, 它必须实现
</span><span class="cm"> * file_operations中的poll操作, 给自己分配有一个等待队列头.
</span><span class="cm"> * 主动poll fd的某个进程必须分配一个等待队列成员, 添加到
</span><span class="cm"> * fd的对待队列里面去, 并指定资源ready时的回调函数.
</span><span class="cm"> * 用socket做例子, 它必须有实现一个poll操作, 这个Poll是
</span><span class="cm"> * 发起轮询的代码必须主动调用的, 该函数中必须调用poll_wait(),
</span><span class="cm"> * poll_wait会将发起者作为等待队列成员加入到socket的等待队列中去.
</span><span class="cm"> * 这样socket发生状态变化时可以通过队列头逐个通知所有关心它的进程.
</span><span class="cm"> * 这一点必须很清楚的理解, 否则会想不明白epoll是如何
</span><span class="cm"> * 得知fd的状态发生变化的.
</span><span class="cm"> * 3. epollfd本身也是个fd, 所以它本身也可以被epoll,
</span><span class="cm"> * 可以猜测一下它是不是可以无限嵌套epoll下去...
</span><span class="cm"> *
</span><span class="cm"> * epoll基本上就是使用了上面的1,2点来完成.
</span><span class="cm"> * 可见epoll本身并没有给内核引入什么特别复杂或者高深的技术,
</span><span class="cm"> * 只不过是已有功能的重新组合, 达到了超过select的效果.
</span><span class="cm"> */</span>
<span class="cm">/*
</span><span class="cm"> * 相关的其它内核知识:
</span><span class="cm"> * 1. fd我们知道是文件描述符, 在内核态, 与之对应的是struct file结构,
</span><span class="cm"> * 可以看作是内核态的文件描述符.
</span><span class="cm"> * 2. spinlock, 自旋锁, 必须要非常小心使用的锁,
</span><span class="cm"> * 尤其是调用spin_lock_irqsave()的时候, 中断关闭, 不会发生进程调度,
</span><span class="cm"> * 被保护的资源其它CPU也无法访问. 这个锁是很强力的, 所以只能锁一些
</span><span class="cm"> * 非常轻量级的操作.
</span><span class="cm"> * 3. 引用计数在内核中是非常重要的概念,
</span><span class="cm"> * 内核代码里面经常有些release, free释放资源的函数几乎不加任何锁,
</span><span class="cm"> * 这是因为这些函数往往是在对象的引用计数变成0时被调用,
</span><span class="cm"> * 既然没有进程在使用在这些对象, 自然也不需要加锁.
</span><span class="cm"> * struct file 是持有引用计数的.
</span><span class="cm"> */</span>
<span class="cm">/* --- epoll相关的数据结构 --- */</span>
<span class="cm">/*
</span><span class="cm"> * This structure is stored inside the &#34;private_data&#34; member of the file
</span><span class="cm"> * structure and rapresent the main data sructure for the eventpoll
</span><span class="cm"> * interface.
</span><span class="cm"> */</span>
<span class="cm">/* 每创建一个epollfd, 内核就会分配一个eventpoll与之对应, 可以说是
</span><span class="cm"> * 内核态的epollfd. */</span>
<span class="k">struct</span> <span class="n">eventpoll</span> <span class="p">{</span>
    <span class="cm">/* Protect the this structure access */</span>
    <span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
    <span class="cm">/*
</span><span class="cm">     * This mutex is used to ensure that files are not removed
</span><span class="cm">     * while epoll is using them. This is held during the event
</span><span class="cm">     * collection loop, the file cleanup path, the epoll file exit
</span><span class="cm">     * code and the ctl operations.
</span><span class="cm">     */</span>
    <span class="cm">/* 添加, 修改或者删除监听fd的时候, 以及epoll_wait返回, 向用户空间
</span><span class="cm">     * 传递数据时都会持有这个互斥锁, 所以在用户空间可以放心的在多个线程
</span><span class="cm">     * 中同时执行epoll相关的操作, 内核级已经做了保护. */</span>
    <span class="k">struct</span> <span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
    <span class="cm">/* Wait queue used by sys_epoll_wait() */</span>
    <span class="cm">/* 调用epoll_wait()时, 我们就是&#34;睡&#34;在了这个等待队列上... */</span>
    <span class="n">wait_queue_head_t</span> <span class="n">wq</span><span class="p">;</span>
    <span class="cm">/* Wait queue used by file-&gt;poll() */</span>
    <span class="cm">/* 这个用于epollfd本事被poll的时候... */</span>
    <span class="n">wait_queue_head_t</span> <span class="n">poll_wait</span><span class="p">;</span>
    <span class="cm">/* List of ready file descriptors */</span>
    <span class="cm">/* 所有已经ready的epitem都在这个链表里面 */</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">rdllist</span><span class="p">;</span>
    <span class="cm">/* RB tree root used to store monitored fd structs */</span>
    <span class="cm">/* 所有要监听的epitem都在这里 */</span>
    <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">rbr</span><span class="p">;</span>
    <span class="cm">/*
</span><span class="cm">        这是一个单链表链接着所有的struct epitem当event转移到用户空间时
</span><span class="cm">     */</span>
     <span class="o">*</span> <span class="n">This</span> <span class="n">is</span> <span class="n">a</span> <span class="n">single</span> <span class="n">linked</span> <span class="n">list</span> <span class="n">that</span> <span class="n">chains</span> <span class="n">all</span> <span class="n">the</span> <span class="s">&#34;struct epitem&#34;</span> <span class="n">that</span>
     <span class="o">*</span> <span class="n">happened</span> <span class="k">while</span> <span class="n">transfering</span> <span class="n">ready</span> <span class="n">events</span> <span class="n">to</span> <span class="n">userspace</span> <span class="n">w</span><span class="o">/</span><span class="n">out</span>
     <span class="o">*</span> <span class="n">holding</span> <span class="o">-&gt;</span><span class="n">lock</span><span class="p">.</span>
     <span class="err">*/</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">ovflist</span><span class="p">;</span>
    <span class="cm">/* The user that created the eventpoll descriptor */</span>
    <span class="cm">/* 这里保存了一些用户变量, 比如fd监听数量的最大值等等 */</span>
    <span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="n">user</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/*
</span><span class="cm"> * Each file descriptor added to the eventpoll interface will
</span><span class="cm"> * have an entry of this type linked to the &#34;rbr&#34; RB tree.
</span><span class="cm"> */</span>
<span class="cm">/* epitem 表示一个被监听的fd */</span>
<span class="k">struct</span> <span class="n">epitem</span> <span class="p">{</span>
    <span class="cm">/* RB tree node used to link this structure to the eventpoll RB tree */</span>
    <span class="cm">/* rb_node, 当使用epoll_ctl()将一批fds加入到某个epollfd时, 内核会分配
</span><span class="cm">     * 一批的epitem与fds们对应, 而且它们以rb_tree的形式组织起来, tree的root
</span><span class="cm">     * 保存在epollfd, 也就是struct eventpoll中.
</span><span class="cm">     * 在这里使用rb_tree的原因我认为是提高查找,插入以及删除的速度.
</span><span class="cm">     * rb_tree对以上3个操作都具有O(lgN)的时间复杂度 */</span>
    <span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rbn</span><span class="p">;</span>
    <span class="cm">/* List header used to link this structure to the eventpoll ready list */</span>
    <span class="cm">/* 链表节点, 所有已经ready的epitem都会被链到eventpoll的rdllist中 */</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">rdllink</span><span class="p">;</span>
    <span class="cm">/*
</span><span class="cm">     * Works together &#34;struct eventpoll&#34;-&gt;ovflist in keeping the
</span><span class="cm">     * single linked chain of items.
</span><span class="cm">     */</span>
    <span class="cm">/* 这个在代码中再解释... */</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="cm">/* The file descriptor information this item refers to */</span>
    <span class="cm">/* epitem对应的fd和struct file */</span>
    <span class="k">struct</span> <span class="n">epoll_filefd</span> <span class="n">ffd</span><span class="p">;</span>
    <span class="cm">/* Number of active wait queue attached to poll operations */</span>
    <span class="kt">int</span> <span class="n">nwait</span><span class="p">;</span>
    <span class="cm">/* List containing poll wait queues */</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">pwqlist</span><span class="p">;</span>
    <span class="cm">/* The &#34;container&#34; of this item */</span>
    <span class="cm">/* 当前epitem属于哪个eventpoll */</span>
    <span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
    <span class="cm">/* List header used to link this item to the &#34;struct file&#34; items list */</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">fllink</span><span class="p">;</span>
    <span class="cm">/* The structure that describe the interested events and the source fd */</span>
    <span class="cm">/* 当前的epitem关系哪些events, 这个数据是调用epoll_ctl时从用户态传递过来 */</span>
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">event</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">epoll_filefd</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/* poll所用到的钩子Wait structure used by the poll hooks */</span>
<span class="k">struct</span> <span class="n">eppoll_entry</span> <span class="p">{</span>
    <span class="cm">/* List header used to link this structure to the &#34;struct epitem&#34; */</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">llink</span><span class="p">;</span>
    <span class="cm">/* The &#34;base&#34; pointer is set to the container &#34;struct epitem&#34; */</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
    <span class="cm">/*
</span><span class="cm">     * Wait queue item that will be linked to the target file wait
</span><span class="cm">     * queue head.
</span><span class="cm">     */</span>
    <span class="n">wait_queue_t</span> <span class="n">wait</span><span class="p">;</span>
    <span class="cm">/* The wait queue head that linked the &#34;wait&#34; wait queue item */</span>
    <span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">whead</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/* Wrapper struct used by poll queueing */</span>
<span class="k">struct</span> <span class="n">ep_pqueue</span> <span class="p">{</span>
    <span class="n">poll_table</span> <span class="n">pt</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/* Used by the ep_send_events() function as callback private data */</span>
<span class="k">struct</span> <span class="n">ep_send_events_data</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">maxevents</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="n">events</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* --- 代码注释 --- */</span>
<span class="cm">/* 你没看错, 这就是epoll_create()的真身, 基本啥也不干直接调用epoll_create1了,
</span><span class="cm"> * 另外你也可以发现, size这个参数其实是没有任何用处的... */</span>
<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">epoll_create</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="k">return</span> <span class="nf">sys_epoll_create1</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/* 这才是真正的epoll_create啊~~ */</span>
<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">epoll_create1</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><span class="c1">//主描述符
</span><span class="c1"></span>    <span class="cm">/* Check the EPOLL_* constant for consistency.  */</span>
    <span class="cm">/* 这句没啥用处... */</span>
    <span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">EPOLL_CLOEXEC</span> <span class="o">!=</span> <span class="n">O_CLOEXEC</span><span class="p">);</span>
    <span class="cm">/* 对于epoll来讲, 目前唯一有效的FLAG就是CLOEXEC */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">EPOLL_CLOEXEC</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="cm">/*
</span><span class="cm">     * Create the internal data structure (&#34;struct eventpoll&#34;).
</span><span class="cm">     */</span>
    <span class="cm">/* 分配一个struct eventpoll, 分配和初始化细节我们随后深聊~ */</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">ep_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
    <span class="cm">/*
</span><span class="cm">     * Creates all the items needed to setup an eventpoll file. That is,
</span><span class="cm">     * a file structure and a free file descriptor.
</span><span class="cm">     */</span>
    <span class="cm">/* 这里是创建一个匿名fd, 说起来就话长了...长话短说:
</span><span class="cm">     * epollfd本身并不存在一个真正的文件与之对应, 所以内核需要创建一个
</span><span class="cm">     * &#34;虚拟&#34;的文件, 并为之分配真正的struct file结构, 而且有真正的fd.
</span><span class="cm">     * 这里2个参数比较关键:
</span><span class="cm">     * eventpoll_fops, fops就是file operations, 就是当你对这个文件(这里是虚拟的)进行操作(比如读)时,
</span><span class="cm">     * fops里面的函数指针指向真正的操作实现, 类似C++里面虚函数和子类的概念.
</span><span class="cm">     * epoll只实现了poll和release(就是close)操作, 其它文件系统操作都有VFS全权处理了.
</span><span class="cm">     * ep, ep就是struct epollevent, 它会作为一个私有数据保存在struct file的private指针里面.
</span><span class="cm">     * 其实说白了, 就是为了能通过fd找到struct file, 通过struct file能找到eventpoll结构.
</span><span class="cm">     * 如果懂一点Linux下字符设备驱动开发, 这里应该是很好理解的,
</span><span class="cm">     * 推荐阅读 &lt;Linux device driver 3rd&gt;
</span><span class="cm">     */</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">anon_inode_getfd</span><span class="p">(</span><span class="s">&#34;[eventpoll]&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eventpoll_fops</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span>
                 <span class="n">O_RDWR</span> <span class="o">|</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_CLOEXEC</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">ep_free</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
</span><span class="cm">* 创建好epollfd后, 接下来我们要往里面添加fd咯
</span><span class="cm">* 来看epoll_ctl
</span><span class="cm">* epfd 就是epollfd
</span><span class="cm">* op ADD,MOD,DEL
</span><span class="cm">* fd 需要监听的描述符
</span><span class="cm">* event 我们关心的events
</span><span class="cm">*/</span>
<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">epoll_ctl</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">epfd</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="o">*</span><span class="n">tfile</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">epds</span><span class="p">;</span>
    <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
    <span class="cm">/*
</span><span class="cm">     * 错误处理以及从用户空间将epoll_event结构copy到内核空间.
</span><span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ep_op_has_event</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epds</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">epoll_event</span><span class="p">)))</span>
        <span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>
    <span class="cm">/* Get the &#34;struct file *&#34; for the eventpoll file */</span>
    <span class="cm">/* 取得struct file结构, epfd既然是真正的fd, 那么内核空间
</span><span class="cm">     * 就会有与之对于的一个struct file结构
</span><span class="cm">     * 这个结构在epoll_create1()中, 由函数anon_inode_getfd()分配 */</span>
    <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
    <span class="n">file</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">epfd</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>
    <span class="cm">/* Get the &#34;struct file *&#34; for the target file */</span>
    <span class="cm">/* 我们需要监听的fd, 它当然也有个struct file结构, 上下2个不要搞混了哦 */</span>
    <span class="n">tfile</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tfile</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">error_fput</span><span class="p">;</span>
    <span class="cm">/* The target file descriptor must support poll */</span>
    <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
    <span class="cm">/* 如果监听的文件不支持poll, 那就没辙了.
</span><span class="cm">     * 你知道什么情况下, 文件会不支持poll吗?
</span><span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">||</span> <span class="o">!</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">error_tgt_fput</span><span class="p">;</span>
    <span class="cm">/*
</span><span class="cm">     * We have to check that the file structure underneath the file descriptor
</span><span class="cm">     * the user passed to us _is_ an eventpoll file. And also we do not permit
</span><span class="cm">     * adding an epoll file descriptor inside itself.
</span><span class="cm">     */</span>
    <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="cm">/* epoll不能自己监听自己... */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">==</span> <span class="n">tfile</span> <span class="o">||</span> <span class="o">!</span><span class="n">is_file_epoll</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">error_tgt_fput</span><span class="p">;</span>
    <span class="cm">/*
</span><span class="cm">     * At this point it is safe to assume that the &#34;private_data&#34; contains
</span><span class="cm">     * our own data structure.
</span><span class="cm">     */</span>
    <span class="cm">/* 取到我们的eventpoll结构, 来自与epoll_create1()中的分配 */</span>
    <span class="n">ep</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
    <span class="cm">/* 接下来的操作有可能修改数据结构内容, 锁之~ */</span>
    <span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
    <span class="cm">/*
</span><span class="cm">     * Try to lookup the file inside our RB tree, Since we grabbed &#34;mtx&#34;
</span><span class="cm">     * above, we can be sure to be able to use the item looked up by
</span><span class="cm">     * ep_find() till we release the mutex.
</span><span class="cm">     */</span>
    <span class="cm">/* 对于每一个监听的fd, 内核都有分配一个epitem结构,
</span><span class="cm">     * 而且我们也知道, epoll是不允许重复添加fd的,
</span><span class="cm">     * 所以我们首先查找该fd是不是已经存在了.
</span><span class="cm">     * ep_find()其实就是RBTREE查找, 跟C++STL的map差不多一回事, O(lgn)的时间复杂度.
</span><span class="cm">     */</span>
    <span class="n">epi</span> <span class="o">=</span> <span class="n">ep_find</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">tfile</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
    <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 首先我们关心添加 */</span>
    <span class="k">case</span> <span class="nl">EPOLL_CTL_ADD</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">epi</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* 之前的find没有找到有效的epitem, 证明是第一次插入, 接受!
</span><span class="cm">             * 这里我们可以知道, POLLERR和POLLHUP事件内核总是会关心的
</span><span class="cm">             * */</span>
            <span class="n">epds</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">POLLERR</span> <span class="o">|</span> <span class="n">POLLHUP</span><span class="p">;</span>
            <span class="cm">/* rbtree插入, 详情见ep_insert()的分析
</span><span class="cm">             * 其实我觉得这里有insert的话, 之前的find应该
</span><span class="cm">             * 是可以省掉的... */</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">ep_insert</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epds</span><span class="p">,</span> <span class="n">tfile</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span>
            <span class="cm">/* 找到了!? 重复添加! */</span>
            <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
        <span class="cm">/* 删除和修改操作都比较简单 */</span>
    <span class="k">case</span> <span class="nl">EPOLL_CTL_DEL</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="p">)</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">ep_remove</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">EPOLL_CTL_MOD</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">epds</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">POLLERR</span> <span class="o">|</span> <span class="n">POLLHUP</span><span class="p">;</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">ep_modify</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epds</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span>
            <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
<span class="nl">error_tgt_fput</span><span class="p">:</span>
    <span class="n">fput</span><span class="p">(</span><span class="n">tfile</span><span class="p">);</span>
<span class="nl">error_fput</span><span class="p">:</span>
    <span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="nl">error_return</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* 分配一个eventpoll结构 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ep_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">**</span><span class="n">pep</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="n">user</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
    <span class="cm">/* 获取当前用户的一些信息, 比如是不是root啦, 最大监听fd数目啦 */</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">get_current_user</span><span class="p">();</span>
    <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
    <span class="n">ep</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ep</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">free_uid</span><span class="p">;</span>
    <span class="cm">/* 这些都是初始化啦 */</span>
    <span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
    <span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
    <span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span><span class="c1">//初始化自己睡在的等待队列
</span><span class="c1"></span>    <span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">);</span><span class="c1">//初始化
</span><span class="c1"></span>    <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">);</span><span class="c1">//初始化就绪链表
</span><span class="c1"></span>    <span class="n">ep</span><span class="o">-&gt;</span><span class="n">rbr</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
    <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span> <span class="o">=</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">;</span>
    <span class="n">ep</span><span class="o">-&gt;</span><span class="n">user</span> <span class="o">=</span> <span class="n">user</span><span class="p">;</span>
    <span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">free_uid</span><span class="p">:</span>
    <span class="n">free_uid</span><span class="p">(</span><span class="n">user</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
</span><span class="cm"> * Must be called with &#34;mtx&#34; held.
</span><span class="cm"> */</span>
<span class="cm">/*
</span><span class="cm"> * ep_insert()在epoll_ctl()中被调用, 完成往epollfd里面添加一个监听fd的工作
</span><span class="cm"> * tfile是fd在内核态的struct file结构
</span><span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ep_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
         <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">tfile</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">revents</span><span class="p">,</span> <span class="n">pwake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">ep_pqueue</span> <span class="n">epq</span><span class="p">;</span>
    <span class="cm">/* 查看是否达到当前用户的最大监听数 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">epoll_watches</span><span class="p">)</span> <span class="o">&gt;=</span>
         <span class="n">max_user_watches</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
    <span class="cm">/* 从著名的slab中分配一个epitem */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">epi</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">epi_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
    <span class="cm">/* Item initialization follow here ... */</span>
    <span class="cm">/* 这些都是相关成员的初始化... */</span>
    <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">);</span>
    <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">fllink</span><span class="p">);</span>
    <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">pwqlist</span><span class="p">);</span>
    <span class="n">epi</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
    <span class="cm">/* 这里保存了我们需要监听的文件fd和它的file结构 */</span>
    <span class="n">ep_set_ffd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">,</span> <span class="n">tfile</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
    <span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span> <span class="o">=</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
    <span class="n">epi</span><span class="o">-&gt;</span><span class="n">nwait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="cm">/* 这个指针的初值不是NULL哦... */</span>
    <span class="n">epi</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">;</span>
    <span class="cm">/* Initialize the poll table using the queue callback */</span>
    <span class="cm">/* 好, 我们终于要进入到poll的正题了 */</span>
    <span class="n">epq</span><span class="p">.</span><span class="n">epi</span> <span class="o">=</span> <span class="n">epi</span><span class="p">;</span>
    <span class="cm">/* 初始化一个poll_table
</span><span class="cm">     * 其实就是指定调用poll_wait(注意不是epoll_wait!!!)时的回调函数,和我们关心哪些events,
</span><span class="cm">     * ep_ptable_queue_proc()就是我们的回调啦, 初值是所有event都关心 */</span>
    <span class="n">init_poll_funcptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epq</span><span class="p">.</span><span class="n">pt</span><span class="p">,</span> <span class="n">ep_ptable_queue_proc</span><span class="p">);</span>
    <span class="cm">/*
</span><span class="cm">     * Attach the item to the poll hooks and get current event bits.
</span><span class="cm">     * We can safely use the file* here because its usage count has
</span><span class="cm">     * been increased by the caller of this function. Note that after
</span><span class="cm">     * this operation completes, the poll callback can start hitting
</span><span class="cm">     * the new item.
</span><span class="cm">     */</span>
    <span class="cm">/* 这一部很关键, 也比较难懂, 完全是内核的poll机制导致的...
</span><span class="cm">     * 首先, f_op-&gt;poll()一般来说只是个wrapper, 它会调用真正的poll实现,
</span><span class="cm">     * 拿UDP的socket来举例, 这里就是这样的调用流程: f_op-&gt;poll(), sock_poll(),
</span><span class="cm">     * udp_poll(), datagram_poll(), sock_poll_wait(), 最后调用到我们上面指定的
</span><span class="cm">     * ep_ptable_queue_proc()这个回调函数...(好深的调用路径...).
</span><span class="cm">     * 完成这一步, 我们的epitem就跟这个socket关联起来了, 当它有状态变化时,
</span><span class="cm">     * 会通过ep_poll_callback()来通知.
</span><span class="cm">     * 最后, 这个函数还会查询当前的fd是不是已经有啥event已经ready了, 有的话
</span><span class="cm">     * 会将event返回. */</span>
    <span class="n">revents</span> <span class="o">=</span> <span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">(</span><span class="n">tfile</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epq</span><span class="p">.</span><span class="n">pt</span><span class="p">);</span>
    <span class="cm">/*
</span><span class="cm">     * We have to check if something went wrong during the poll wait queue
</span><span class="cm">     * install process. Namely an allocation for a wait queue failed due
</span><span class="cm">     * high memory pressure.
</span><span class="cm">     */</span>
    <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">nwait</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">error_unregister</span><span class="p">;</span>
    <span class="cm">/* Add the current item to the list of active epoll hook for this file */</span>
    <span class="cm">/* 这个就是每个文件会将所有监听自己的epitem链起来 */</span>
    <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
    <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">fllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_ep_links</span><span class="p">);</span>
    <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
    <span class="cm">/*
</span><span class="cm">     * Add the current item to the RB tree. All RB tree operations are
</span><span class="cm">     * protected by &#34;mtx&#34;, and ep_insert() is called with &#34;mtx&#34; held.
</span><span class="cm">     */</span>
    <span class="cm">/* 都搞定后, 将epitem插入到对应的eventpoll中去 */</span>
    <span class="n">ep_rbtree_insert</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">);</span>
    <span class="cm">/* We have to drop the new item inside our item list to keep track of it */</span>
    <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="cm">/* If the file is already &#34;ready&#34; we drop it inside the ready list */</span>
    <span class="cm">/* 到达这里后, 如果我们监听的fd已经有事件发生, 那就要处理一下 */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ep_is_linked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* 将当前的epitem加入到ready list中去 */</span>
        <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">);</span>
        <span class="cm">/* Notify waiting tasks that events are available */</span>
        <span class="cm">/* 谁在epoll_wait, 就唤醒它... */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">))</span>
            <span class="n">wake_up_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
        <span class="cm">/* 谁在epoll当前的epollfd, 也唤醒它... */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">))</span>
            <span class="n">pwake</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">epoll_watches</span><span class="p">);</span>
    <span class="cm">/* We have to call this outside the lock */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pwake</span><span class="p">)</span>
        <span class="n">ep_poll_safewake</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error_unregister</span><span class="p">:</span>
    <span class="n">ep_unregister_pollwait</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">);</span>
    <span class="cm">/*
</span><span class="cm">     * We need to do this because an event could have been arrived on some
</span><span class="cm">     * allocated wait queue. Note that we don&#39;t care about the ep-&gt;ovflist
</span><span class="cm">     * list, since that is used/cleaned only inside a section bound by &#34;mtx&#34;.
</span><span class="cm">     * And ep_insert() is called with &#34;mtx&#34; held.
</span><span class="cm">     */</span>
    <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ep_is_linked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">))</span>
        <span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">);</span>
    <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">epi_cache</span><span class="p">,</span> <span class="n">epi</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
</span><span class="cm"> * This is the callback that is used to add our wait queue to the
</span><span class="cm"> * target file wakeup lists.
</span><span class="cm"> */</span>
<span class="cm">/*
</span><span class="cm"> * 该函数在调用f_op-&gt;poll()时会被调用.
</span><span class="cm"> * 也就是epoll主动poll某个fd时, 用来将epitem与指定的fd关联起来的.
</span><span class="cm"> * 关联的办法就是使用等待队列(waitqueue)
</span><span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ep_ptable_queue_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">whead</span><span class="p">,</span>
                 <span class="n">poll_table</span> <span class="o">*</span><span class="n">pt</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span> <span class="o">=</span> <span class="n">ep_item_from_epqueue</span><span class="p">(</span><span class="n">pt</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">eppoll_entry</span> <span class="o">*</span><span class="n">pwq</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">nwait</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pwq</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">pwq_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)))</span> <span class="p">{</span>
        <span class="cm">/* 初始化等待队列, 指定ep_poll_callback为唤醒时的回调函数,
</span><span class="cm">         * 当我们监听的fd发生状态改变时, 也就是队列头被唤醒时,
</span><span class="cm">         * 指定的回调函数将会被调用. */</span>
        <span class="n">init_waitqueue_func_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="n">ep_poll_callback</span><span class="p">);</span>
        <span class="n">pwq</span><span class="o">-&gt;</span><span class="n">whead</span> <span class="o">=</span> <span class="n">whead</span><span class="p">;</span>
        <span class="n">pwq</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">epi</span><span class="p">;</span>
        <span class="cm">/* 将刚分配的等待队列成员加入到头中, 头是由fd持有的 */</span>
        <span class="n">add_wait_queue</span><span class="p">(</span><span class="n">whead</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
        <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">llink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">pwqlist</span><span class="p">);</span>
        <span class="cm">/* nwait记录了当前epitem加入到了多少个等待队列中,
</span><span class="cm">         * 我认为这个值最大也只会是1... */</span>
        <span class="n">epi</span><span class="o">-&gt;</span><span class="n">nwait</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* We have to signal that an error occurred */</span>
        <span class="n">epi</span><span class="o">-&gt;</span><span class="n">nwait</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*
</span><span class="cm"> * This is the callback that is passed to the wait queue wakeup
</span><span class="cm"> * machanism. It is called by the stored file descriptors when they
</span><span class="cm"> * have events to report.
</span><span class="cm"> */</span>
<span class="cm">/*
</span><span class="cm"> * 这个是关键性的回调函数, 当我们监听的fd发生状态改变时, 它会被调用.
</span><span class="cm"> * 参数key被当作一个unsigned long整数使用, 携带的是events.
</span><span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ep_poll_callback</span><span class="p">(</span><span class="n">wait_queue_t</span> <span class="o">*</span><span class="n">wait</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">pwake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span> <span class="o">=</span> <span class="n">ep_item_from_wait</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span><span class="c1">//从等待队列获取epitem.需要知道哪个进程挂载到这个设备
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span><span class="c1">//获取
</span><span class="c1"></span>    <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="cm">/*
</span><span class="cm">     * If the event mask does not contain any poll(2) event, we consider the
</span><span class="cm">     * descriptor to be disabled. This condition is likely the effect of the
</span><span class="cm">     * EPOLLONESHOT bit that disables the descriptor when an event is received,
</span><span class="cm">     * until the next EPOLL_CTL_MOD will be issued.
</span><span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">EP_PRIVATE_BITS</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
    <span class="cm">/*
</span><span class="cm">     * Check the events coming with the callback. At this stage, not
</span><span class="cm">     * every device reports the events in the &#34;key&#34; parameter of the
</span><span class="cm">     * callback. We need to be able to handle both cases here, hence the
</span><span class="cm">     * test for &#34;key&#34; != NULL before the event match test.
</span><span class="cm">     */</span>
    <span class="cm">/* 没有我们关心的event... */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">key</span> <span class="o">&amp;</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
    <span class="cm">/*
</span><span class="cm">     * If we are trasfering events to userspace, we can hold no locks
</span><span class="cm">     * (because we&#39;re accessing user memory, and because of linux f_op-&gt;poll()
</span><span class="cm">     * semantics). All the events that happens during that period of time are
</span><span class="cm">     * chained in ep-&gt;ovflist and requeued later on.
</span><span class="cm">     */</span>
    <span class="cm">/*
</span><span class="cm">     * 这里看起来可能有点费解, 其实干的事情比较简单:
</span><span class="cm">     * 如果该callback被调用的同时, epoll_wait()已经返回了,
</span><span class="cm">     * 也就是说, 此刻应用程序有可能已经在循环获取events,
</span><span class="cm">     * 这种情况下, 内核将此刻发生event的epitem用一个单独的链表
</span><span class="cm">     * 链起来, 不发给应用程序, 也不丢弃, 而是在下一次epoll_wait
</span><span class="cm">     * 时返回给用户.
</span><span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span> <span class="o">!=</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">epi</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span><span class="p">;</span>
            <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span> <span class="o">=</span> <span class="n">epi</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* If this file is already in the ready list we exit soon */</span>
    <span class="cm">/* 将当前的epitem放入ready list */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_is_linked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">))</span>
        <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">);</span>
    <span class="cm">/*
</span><span class="cm">     * Wake up ( if active ) both the eventpoll wait list and the -&gt;poll()
</span><span class="cm">     * wait list.
</span><span class="cm">     */</span>
    <span class="cm">/* 唤醒epoll_wait... */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">))</span>
        <span class="n">wake_up_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
    <span class="cm">/* 如果epollfd也在被poll, 那就唤醒队列里面的所有成员. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">))</span>
        <span class="n">pwake</span><span class="o">++</span><span class="p">;</span>
<span class="nl">out_unlock</span><span class="p">:</span>
    <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="cm">/* We have to call this outside the lock */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pwake</span><span class="p">)</span>
        <span class="n">ep_poll_safewake</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
</span><span class="cm"> * Implement the event wait interface for the eventpoll file. It is the kernel
</span><span class="cm"> * part of the user space epoll_wait(2).
</span><span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">epoll_wait</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span>
        <span class="kt">int</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
    <span class="cm">/* The maximum number of event must be greater than zero */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">maxevents</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">maxevents</span> <span class="o">&gt;</span> <span class="n">EP_MAX_EVENTS</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="cm">/* Verify that the area passed by the user is writeable */</span>
    <span class="cm">/* 这个地方有必要说明一下:
</span><span class="cm">     * 内核对应用程序采取的策略是&#34;绝对不信任&#34;,
</span><span class="cm">     * 所以内核跟应用程序之间的数据交互大都是copy, 不允许(也时候也是不能...)指针引用.
</span><span class="cm">     * epoll_wait()需要内核返回数据给用户空间, 内存由用户程序提供,
</span><span class="cm">     * 所以内核会用一些手段来验证这一段内存空间是不是有效的.
</span><span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">maxevents</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">epoll_event</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* Get the &#34;struct file *&#34; for the eventpoll file */</span>
    <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
    <span class="cm">/* 获取epollfd的struct file, epollfd也是文件嘛 */</span>
    <span class="n">file</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">epfd</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>
    <span class="cm">/*
</span><span class="cm">     * We have to check that the file structure underneath the fd
</span><span class="cm">     * the user passed to us _is_ an eventpoll file.
</span><span class="cm">     */</span>
    <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="cm">/* 检查一下它是不是一个真正的epollfd... */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_file_epoll</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">error_fput</span><span class="p">;</span>
    <span class="cm">/*
</span><span class="cm">     * At this point it is safe to assume that the &#34;private_data&#34; contains
</span><span class="cm">     * our own data structure.
</span><span class="cm">     */</span>
    <span class="cm">/* 获取eventpoll结构 */</span>
    <span class="n">ep</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
    <span class="cm">/* Time to fish for events ... */</span>
    <span class="cm">/* OK, 睡觉, 等待事件到来~~ */</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">ep_poll</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
<span class="nl">error_fput</span><span class="p">:</span>
    <span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="nl">error_return</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* 这个函数真正将执行epoll_wait的进程带入睡眠状态... */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ep_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span>
           <span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">res</span><span class="p">,</span> <span class="n">eavail</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">jtimeout</span><span class="p">;</span>
    <span class="n">wait_queue_t</span> <span class="n">wait</span><span class="p">;</span><span class="c1">//等待队列
</span><span class="c1"></span>    <span class="cm">/*
</span><span class="cm">     * Calculate the timeout by checking for the &#34;infinite&#34; value (-1)
</span><span class="cm">     * and the overflow condition. The passed timeout is in milliseconds,
</span><span class="cm">     * that why (t * HZ) / 1000.
</span><span class="cm">     */</span>
    <span class="cm">/* 计算睡觉时间, 毫秒要转换为HZ */</span>
    <span class="n">jtimeout</span> <span class="o">=</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">timeout</span> <span class="o">&gt;=</span> <span class="n">EP_MAX_MSTIMEO</span><span class="p">)</span> <span class="o">?</span>
        <span class="nl">MAX_SCHEDULE_TIMEOUT</span> <span class="p">:</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">+</span> <span class="mi">999</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
<span class="nl">retry</span><span class="p">:</span>
    <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="cm">/* 如果ready list不为空, 就不睡了, 直接干活... */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/*
</span><span class="cm">         * We don&#39;t have any available event to return to the caller.
</span><span class="cm">         * We need to sleep here, and we will be wake up by
</span><span class="cm">         * ep_poll_callback() when events will become available.
</span><span class="cm">         */</span>
        <span class="cm">/* OK, 初始化一个等待队列, 准备直接把自己挂起,
</span><span class="cm">         * 注意current是一个宏, 代表当前进程 */</span>
        <span class="n">init_waitqueue_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span><span class="c1">//初始化等待队列,wait表示当前进程
</span><span class="c1"></span>        <span class="n">__add_wait_queue_exclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span><span class="c1">//挂载到ep结构的等待队列
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
            <span class="cm">/*
</span><span class="cm">             * We don&#39;t want to sleep if the ep_poll_callback() sends us
</span><span class="cm">             * a wakeup in between. That&#39;s why we set the task state
</span><span class="cm">             * to TASK_INTERRUPTIBLE before doing the checks.
</span><span class="cm">             */</span>
            <span class="cm">/* 将当前进程设置位睡眠, 但是可以被信号唤醒的状态,
</span><span class="cm">             * 注意这个设置是&#34;将来时&#34;, 我们此刻还没睡! */</span>
            <span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
            <span class="cm">/* 如果这个时候, ready list里面有成员了,
</span><span class="cm">             * 或者睡眠时间已经过了, 就直接不睡了... */</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">jtimeout</span><span class="p">)</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="cm">/* 如果有信号产生, 也起床... */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="cm">/* 啥事都没有,解锁, 睡觉... */</span>
            <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
            <span class="cm">/* jtimeout这个时间后, 会被唤醒,
</span><span class="cm">             * ep_poll_callback()如果此时被调用,
</span><span class="cm">             * 那么我们就会直接被唤醒, 不用等时间了...
</span><span class="cm">             * 再次强调一下ep_poll_callback()的调用时机是由被监听的fd
</span><span class="cm">             * 的具体实现, 比如socket或者某个设备驱动来决定的,
</span><span class="cm">             * 因为等待队列头是他们持有的, epoll和当前进程
</span><span class="cm">             * 只是单纯的等待...
</span><span class="cm">             **/</span>
            <span class="n">jtimeout</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">jtimeout</span><span class="p">);</span><span class="c1">//睡觉
</span><span class="c1"></span>            <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">__remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
        <span class="cm">/* OK 我们醒来了... */</span>
        <span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/* Is it worth to try to dig for events ? */</span>
    <span class="n">eavail</span> <span class="o">=</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">)</span> <span class="o">||</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span> <span class="o">!=</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">;</span>
    <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="cm">/*
</span><span class="cm">     * Try to transfer events to user space. In case we get 0 events and
</span><span class="cm">     * there&#39;s still timeout left over, we go trying again in search of
</span><span class="cm">     * more luck.
</span><span class="cm">     */</span>
    <span class="cm">/* 如果一切正常, 有event发生, 就开始准备数据copy给用户空间了... */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span> <span class="o">&amp;&amp;</span> <span class="n">eavail</span> <span class="o">&amp;&amp;</span>
    <span class="o">!</span><span class="p">(</span><span class="n">res</span> <span class="o">=</span> <span class="n">ep_send_events</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">jtimeout</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* 这个简单, 我们直奔下一个... */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ep_send_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
              <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxevents</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">ep_send_events_data</span> <span class="n">esed</span><span class="p">;</span>
    <span class="n">esed</span><span class="p">.</span><span class="n">maxevents</span> <span class="o">=</span> <span class="n">maxevents</span><span class="p">;</span>
    <span class="n">esed</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">events</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">ep_scan_ready_list</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep_send_events_proc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">esed</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/**
</span><span class="cm"> * ep_scan_ready_list - Scans the ready list in a way that makes possible for
</span><span class="cm"> *  the scan code, to call f_op-&gt;poll(). Also allows for
</span><span class="cm"> *  O(NumReady) performance.
</span><span class="cm"> *
</span><span class="cm"> * @ep: Pointer to the epoll private data structure.
</span><span class="cm"> * @sproc: Pointer to the scan callback.
</span><span class="cm"> * @priv: Private opaque data passed to the @sproc callback.
</span><span class="cm"> *
</span><span class="cm"> * Returns: The same integer error code returned by the @sproc callback.
</span><span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ep_scan_ready_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
              <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sproc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="p">,</span>
                       <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
              <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">pwake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">,</span> <span class="o">*</span><span class="n">nepi</span><span class="p">;</span>
    <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">txlist</span><span class="p">);</span>
    <span class="cm">/*
</span><span class="cm">     * We need to lock this because we could be hit by
</span><span class="cm">     * eventpoll_release_file() and epoll_ctl().
</span><span class="cm">     */</span>
    <span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
    <span class="cm">/*
</span><span class="cm">     * Steal the ready list, and re-init the original one to the
</span><span class="cm">     * empty list. Also, set ep-&gt;ovflist to NULL so that events
</span><span class="cm">     * happening while looping w/out locks, are not lost. We cannot
</span><span class="cm">     * have the poll callback to queue directly on ep-&gt;rdllist,
</span><span class="cm">     * because we want the &#34;sproc&#34; callback to be able to do it
</span><span class="cm">     * in a lockless way.
</span><span class="cm">     */</span>
    <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="cm">/* 这一步要注意, 首先, 所有监听到events的epitem都链到rdllist上了,
</span><span class="cm">     * 但是这一步之后, 所有的epitem都转移到了txlist上, 而rdllist被清空了,
</span><span class="cm">     * 要注意哦, rdllist已经被清空了! */</span>
    <span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txlist</span><span class="p">);</span>
    <span class="cm">/* ovflist, 在ep_poll_callback()里面我解释过, 此时此刻我们不希望
</span><span class="cm">     * 有新的event加入到ready list中了, 保存后下次再处理... */</span>
    <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="cm">/*
</span><span class="cm">     * Now call the callback function.
</span><span class="cm">     */</span>
    <span class="cm">/* 在这个回调函数里面处理每个epitem
</span><span class="cm">     * sproc 就是 ep_send_events_proc, 下面会注释到. */</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">sproc</span><span class="p">)(</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txlist</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>
    <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="cm">/*
</span><span class="cm">     * During the time we spent inside the &#34;sproc&#34; callback, some
</span><span class="cm">     * other events might have been queued by the poll callback.
</span><span class="cm">     * We re-insert them inside the main ready-list here.
</span><span class="cm">     */</span>
    <span class="cm">/* 现在我们来处理ovflist, 这些epitem都是我们在传递数据给用户空间时
</span><span class="cm">     * 监听到了事件. */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">nepi</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span><span class="p">;</span> <span class="p">(</span><span class="n">epi</span> <span class="o">=</span> <span class="n">nepi</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
     <span class="n">nepi</span> <span class="o">=</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/*
</span><span class="cm">         * We need to check if the item is already in the list.
</span><span class="cm">         * During the &#34;sproc&#34; callback execution time, items are
</span><span class="cm">         * queued into -&gt;ovflist but the &#34;txlist&#34; might already
</span><span class="cm">         * contain them, and the list_splice() below takes care of them.
</span><span class="cm">         */</span>
        <span class="cm">/* 将这些直接放入readylist */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_is_linked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">))</span>
            <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/*
</span><span class="cm">     * We need to set back ep-&gt;ovflist to EP_UNACTIVE_PTR, so that after
</span><span class="cm">     * releasing the lock, events will be queued in the normal way inside
</span><span class="cm">     * ep-&gt;rdllist.
</span><span class="cm">     */</span>
    <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span> <span class="o">=</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">;</span>
    <span class="cm">/*
</span><span class="cm">     * Quickly re-inject items left on &#34;txlist&#34;.
</span><span class="cm">     */</span>
    <span class="cm">/* 上一次没有处理完的epitem, 重新插入到ready list */</span>
    <span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">);</span>
    <span class="cm">/* ready list不为空, 直接唤醒... */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/*
</span><span class="cm">         * Wake up (if active) both the eventpoll wait list and
</span><span class="cm">         * the -&gt;poll() wait list (delayed after we release the lock).
</span><span class="cm">         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">))</span>
            <span class="n">wake_up_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">))</span>
            <span class="n">pwake</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
    <span class="cm">/* We have to call this outside the lock */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pwake</span><span class="p">)</span>
        <span class="n">ep_poll_safewake</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* 该函数作为callbakc在ep_scan_ready_list()中被调用
</span><span class="cm"> * head是一个链表, 包含了已经ready的epitem,
</span><span class="cm"> * 这个不是eventpoll里面的ready list, 而是上面函数中的txlist.
</span><span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ep_send_events_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
               <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">ep_send_events_data</span> <span class="o">*</span><span class="n">esed</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">eventcnt</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">revents</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uevent</span><span class="p">;</span>
    <span class="cm">/*
</span><span class="cm">     * We can loop without lock because we are passed a task private list.
</span><span class="cm">     * Items cannot vanish during the loop because ep_scan_ready_list() is
</span><span class="cm">     * holding &#34;mtx&#34; during this call.
</span><span class="cm">     */</span>
    <span class="cm">/* 扫描整个链表... */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">eventcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">uevent</span> <span class="o">=</span> <span class="n">esed</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">;</span>
     <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">eventcnt</span> <span class="o">&lt;</span> <span class="n">esed</span><span class="o">-&gt;</span><span class="n">maxevents</span><span class="p">;)</span> <span class="p">{</span>
        <span class="cm">/* 取出第一个成员 */</span>
        <span class="n">epi</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epitem</span><span class="p">,</span> <span class="n">rdllink</span><span class="p">);</span>
        <span class="cm">/* 然后从链表里面移除 */</span>
        <span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">);</span>
        <span class="cm">/* 读取events,
</span><span class="cm">         * 注意events我们ep_poll_callback()里面已经取过一次了, 为啥还要再取?
</span><span class="cm">         * 1. 我们当然希望能拿到此刻的最新数据, events是会变的~
</span><span class="cm">         * 2. 不是所有的poll实现, 都通过等待队列传递了events, 有可能某些驱动压根没传
</span><span class="cm">         * 必须主动去读取. */</span>
        <span class="n">revents</span> <span class="o">=</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">.</span><span class="n">file</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;</span>
            <span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">revents</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* 将当前的事件和用户传入的数据都copy给用户空间,
</span><span class="cm">             * 就是epoll_wait()后应用程序能读到的那一堆数据. */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">(</span><span class="n">revents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uevent</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">)</span> <span class="o">||</span>
            <span class="n">__put_user</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uevent</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">eventcnt</span> <span class="o">?</span> <span class="nl">eventcnt</span> <span class="p">:</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">eventcnt</span><span class="o">++</span><span class="p">;</span>
            <span class="n">uevent</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLONESHOT</span><span class="p">)</span>
                <span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">&amp;=</span> <span class="n">EP_PRIVATE_BITS</span><span class="p">;</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLET</span><span class="p">))</span> <span class="p">{</span>
                <span class="cm">/* 嘿嘿, EPOLLET和非ET的区别就在这一步之差呀~
</span><span class="cm">                 * 如果是ET, epitem是不会再进入到readly list,
</span><span class="cm">                 * 除非fd再次发生了状态改变, ep_poll_callback被调用.
</span><span class="cm">                 * 如果是非ET, 不管你还有没有有效的事件或者数据,
</span><span class="cm">                 * 都会被重新插入到ready list, 再下一次epoll_wait
</span><span class="cm">                 * 时, 会立即返回, 并通知给用户空间. 当然如果这个
</span><span class="cm">                 * 被监听的fds确实没事件也没数据了, epoll_wait会返回一个0,
</span><span class="cm">                 * 空转一次.
</span><span class="cm">                 */</span>
                <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">eventcnt</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* ep_free在epollfd被close时调用,
</span><span class="cm"> * 释放一些资源而已, 比较简单 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ep_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rbp</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>
    <span class="cm">/* We need to release all tasks waiting for these file */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">))</span>
        <span class="n">ep_poll_safewake</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">);</span>
    <span class="cm">/*
</span><span class="cm">     * We need to lock this because we could be hit by
</span><span class="cm">     * eventpoll_release_file() while we&#39;re freeing the &#34;struct eventpoll&#34;.
</span><span class="cm">     * We do not need to hold &#34;ep-&gt;mtx&#34; here because the epoll file
</span><span class="cm">     * is on the way to be removed and no one has references to it
</span><span class="cm">     * anymore. The only hit might come from eventpoll_release_file() but
</span><span class="cm">     * holding &#34;epmutex&#34; is sufficent here.
</span><span class="cm">     */</span>
    <span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epmutex</span><span class="p">);</span>
    <span class="cm">/*
</span><span class="cm">     * Walks through the whole tree by unregistering poll callbacks.
</span><span class="cm">     */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">rbp</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rbr</span><span class="p">);</span> <span class="n">rbp</span><span class="p">;</span> <span class="n">rbp</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">rbp</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">epi</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rbp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epitem</span><span class="p">,</span> <span class="n">rbn</span><span class="p">);</span>
        <span class="n">ep_unregister_pollwait</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/*
</span><span class="cm">     * Walks through the whole tree by freeing each &#34;struct epitem&#34;. At this
</span><span class="cm">     * point we are sure no poll callbacks will be lingering around, and also by
</span><span class="cm">     * holding &#34;epmutex&#34; we can be sure that no file cleanup code will hit
</span><span class="cm">     * us during this operation. So we can avoid the lock on &#34;ep-&gt;lock&#34;.
</span><span class="cm">     */</span>
    <span class="cm">/* 之所以在关闭epollfd之前不需要调用epoll_ctl移除已经添加的fd,
</span><span class="cm">     * 是因为这里已经做了... */</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">rbp</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rbr</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">epi</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rbp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epitem</span><span class="p">,</span> <span class="n">rbn</span><span class="p">);</span>
        <span class="n">ep_remove</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epmutex</span><span class="p">);</span>
    <span class="n">mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
    <span class="n">free_uid</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">);</span>
    <span class="n">kfree</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/* File callbacks that implement the eventpoll file behaviour */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">eventpoll_fops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">release</span>    <span class="o">=</span> <span class="n">ep_eventpoll_release</span><span class="p">,</span>
    <span class="p">.</span><span class="n">poll</span>        <span class="o">=</span> <span class="n">ep_eventpoll_poll</span>
<span class="p">};</span>
<span class="cm">/* Fast test to see if the file is an evenpoll file */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_file_epoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">eventpoll_fops</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* OK, eventpoll我认为比较重要的函数都注释完了... */</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="区别-1">区别</h3>
<p>epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。</p>
<p>对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</p>
<p>对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果)</p>
<p>对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。</p>
<p>参考:</p>
<p><a href="https://www.zhihu.com/question/30772664">https://www.zhihu.com/question/30772664</a><br>
<a href="https://strikefreedom.top/go-netpoll-io-multiplexing-reactor">Go netpoller 原生网络模型之源码全面解析</a><br>
<a href="https://www.cnblogs.com/developing/p/10888544.html">为何 epoll 的 ET 模式一定要设置为非阻塞IO</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-11-19
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/go%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go的内存分配器源码剖析</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/go%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
            <span class="next-text nav-default">Go的程序生命周期源码剖析</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Forz</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
