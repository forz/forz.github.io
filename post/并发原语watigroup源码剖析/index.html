<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>并发原语WatiGroup源码剖析 | Forz Blog</title>
<meta name="keywords" content="Go源码" />
<meta name="description" content="WaitGroup sync.WaitGroup 可以达到并发 Goroutine 的执行屏障的效果，等待多个 Goroutine 执行完毕。 sync.WaitGroup 结构体中只包含两个成员变量： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwatigroup%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="并发原语WatiGroup源码剖析" />
<meta property="og:description" content="WaitGroup sync.WaitGroup 可以达到并发 Goroutine 的执行屏障的效果，等待多个 Goroutine 执行完毕。 sync.WaitGroup 结构体中只包含两个成员变量： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwatigroup%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-05-21T14:32:20&#43;00:00" />
<meta property="article:modified_time" content="2021-05-21T14:32:20&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="并发原语WatiGroup源码剖析"/>
<meta name="twitter:description" content="WaitGroup sync.WaitGroup 可以达到并发 Goroutine 的执行屏障的效果，等待多个 Goroutine 执行完毕。 sync.WaitGroup 结构体中只包含两个成员变量： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "并发原语WatiGroup源码剖析",
      "item": "/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwatigroup%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "并发原语WatiGroup源码剖析",
  "name": "并发原语WatiGroup源码剖析",
  "description": "WaitGroup sync.WaitGroup 可以达到并发 Goroutine 的执行屏障的效果，等待多个 Goroutine 执行完毕。 sync.WaitGroup 结构体中只包含两个成员变量： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27",
  "keywords": [
    "Go源码"
  ],
  "articleBody": "WaitGroup sync.WaitGroup 可以达到并发 Goroutine 的执行屏障的效果，等待多个 Goroutine 执行完毕。\nsync.WaitGroup 结构体中只包含两个成员变量：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // A WaitGroup waits for a collection of goroutines to finish. // The main goroutine calls Add to set the number of // goroutines to wait for. Then each of the goroutines // runs and calls Done when finished. At the same time, // Wait can be used to block until all goroutines have finished. // // A WaitGroup must not be copied after first use. // WaitGroup 用于等待一组 Goroutine 执行完毕。 // 主 Goroutine 调用 Add 来设置需要等待的 Goroutine 的数量 // 然后每个 Goroutine 运行并调用 Done 来确认已经执行网完毕 // 同时，Wait 可以用于阻塞并等待所有 Goroutine 完成。 // // WaitGroup 在第一次使用后不能被复制 type WaitGroup struct { // 避免复制使用的一个技巧,可以告诉vet工具违反了复制使用的规则 \tnoCopy noCopy // 64-bit value: high 32 bits are counter, low 32 bits are waiter count. \t// 64-bit atomic operations require 64-bit alignment, but 32-bit \t// compilers do not ensure it. So we allocate 12 bytes and then use \t// the aligned 8 bytes in them as state, and the other 4 as storage \t// for the sema. \t// 64 位值: 高 32 位用于计数，低 32 位用于等待计数 \t// 64 位的原子操作要求 64 位对齐，但 32 位编译器无法保证这个要求 \t// 因此分配 12 字节然后将他们对齐，其中 8 字节作为状态，其他 4 字节用于存储原语 \t// 64bit(8bytes)的值分成两段,高32bit是计数值,低32bit是waiter的计数 \t// 另外32bit是用作信号量的 \t// 因为64bit值的原子操作需要64bit对齐，但是32bit编译器不支持，所以数组中的元素在不同的架构中不一样，具体处理看下面的方法 \t// 总之,会找到对齐的那64bit作为state,其余的32bit做信号量  state1 [3]uint32 }   可以看到，WaitGroup 内部仅仅只是一个 uint32 类型的数组。由于需要考虑 32 位机器的兼容性， 这里采用了 uint32 结构的数组，保证在不同类型的机器上都是 12 个字节。\n noCopy 的辅助字段,主要就是辅助 vet 工具检查是否通过 copy 赋值这个 WaitGroup 实例 state1,一个具有复合意义的字段,包含 WaitGroup 的计数、阻塞在检查点的 waiter 数和信号量。  通过 state() 函数来确定实际的存储情况：\n1 2 3 4 5 6 7 8 9 10 11 12  // 得到state的地址和信号量的地址 // state returns pointers to the state and sema fields stored within wg.state1. // state 返回 wg.state1 中存储的状态和原语字段 func (wg *WaitGroup) state() (statep *uint64, semap *uint32) { if uintptr(unsafe.Pointer(\u0026wg.state1))%8 == 0 { // 如果地址是64bit对齐的,数组前两个元素做state,后一个元素做信号量 \treturn (*uint64)(unsafe.Pointer(\u0026wg.state1)), \u0026wg.state1[2] } else { // 如果地址是32bit对齐的,数组后两个元素用来做state,它可以用来做64bit的原子操作 \treturn (*uint64)(unsafe.Pointer(\u0026wg.state1[1])), \u0026wg.state1[0] } }    在 64 位机器上 state1[0] 和 state1[1] 分别用于等待计数和计数，而最后一个 state1[2] 用于存储原语。 在 32 位机器上 state1[0] 作为存储原语，而 state[1] 和 state[2] 用于等待计数和计数  因为对 64 位整数的原子操作要求整数的地址是 64 位对齐的,所以针对 64 位和 32 位环境的 state 字段的组成是不一样的。\n在 64 位环境下,state1 的第一个元素是 waiter 数,第二个元素是 WaitGroup 的计数值,第三个元素是信号量。\n在 32 位环境下,如果 state1 不是 64 位对齐的地址,那么 state1 的第一个元素是信号量,后两个元素分别是 waiter 数和计数值。\nAdd\u0026Done Add 方法主要操作的是 state 的计数部分。你可以为计数值增加一个 delta 值,内部通过原子操作把这个值加到计数值上。需要注意的是,这个 delta 也可以是个负数,相当于为计数值减去一个值,Done 方法内部其实就是通过 Add(-1) 实现的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88  // Add adds delta, which may be negative, to the WaitGroup counter. // If the counter becomes zero, all goroutines blocked on Wait are released. // If the counter goes negative, Add panics. // // Note that calls with a positive delta that occur when the counter is zero // must happen before a Wait. Calls with a negative delta, or calls with a // positive delta that start when the counter is greater than zero, may happen // at any time. // Typically this means the calls to Add should execute before the statement // creating the goroutine or other event to be waited for. // If a WaitGroup is reused to wait for several independent sets of events, // new Add calls must happen after all previous Wait calls have returned. // See the WaitGroup example. // Add 将 delta（可能为负）加到 WaitGroup 的计数器上 // 如果计数器归零，则所有阻塞在 Wait 的 Goroutine 被释放 // 如果计数器为负，则 panic // // 请注意，当计数器为 0 时发生的带有正的 delta 的调用必须在 Wait 之前。 // 当计数器大于 0 时，带有负 delta 的调用或带有正 delta 调用可能在任何时候发生。 // 通常，这意味着 Add 调用必须发生在 Goroutine 创建之前或其他被等待事件之前。 // 如果一个 WaitGroup 被复用于等待几个不同的独立事件集合，必须在前一个 Wait 调用返回后才能调用 Add。 func (wg *WaitGroup) Add(delta int) { // 首先获取状态指针和存储指针 \tstatep, semap := wg.state() if race.Enabled { _ = *statep // trigger nil deref early \tif delta  0 { // Synchronize decrements with Wait. \trace.ReleaseMerge(unsafe.Pointer(wg)) } race.Disable() defer race.Enable() } // 高32bit是计数值v,所以把delta左移32,增加到计数上 \t// 将 delta 加到 statep 的前 32 位上，即加到计数器上 \tstate := atomic.AddUint64(statep, uint64(delta)32) // 计数器的值 \tv := int32(state  32)// 当前计数值 \t// 等待器的值 \tw := uint32(state) if race.Enabled \u0026\u0026 delta  0 \u0026\u0026 v == int32(delta) { // The first increment must be synchronized with Wait. \t// Need to model this as a read, because there can be \t// several concurrent wg.counter transitions from 0. \trace.Read(unsafe.Pointer(semap)) } // 如果实际计数为负则直接 panic，因此是不允许计数为负值的 \tif v  0 { //WaitGroup 的计数器的值必须大于等于 0。我们在更改这个计数值的时候,WaitGroup 会先做检查,如果计数值被设置为负数,就会导致 panic。 \tpanic(\"sync: negative WaitGroup counter\") } // 如果等待器不为零，但 delta 是处于增加的状态，而且存储计数与 delta 的值相同，则立即 panic \tif w != 0 \u0026\u0026 delta  0 \u0026\u0026 v == int32(delta) { panic(\"sync: WaitGroup misuse: Add called concurrently with Wait\") } // 如果计数器  0 或者等待器为 0 则一切都很好，直接返回 \tif v  0 || w == 0 { return } // This goroutine has set counter to 0 when waiters  0. \t// Now there can't be concurrent mutations of state: \t// - Adds must not happen concurrently with Wait, \t// - Wait does not increment waiters if it sees counter == 0. \t// Still do a cheap sanity check to detect WaitGroup misuse. \t// 这时 Goroutine 已经将计数器清零，且等待器大于零（并发调用导致） \t// 这时不允许出现并发使用导致的状态突变，否则就应该 panic \t// - Add 不能与 Wait 并发调用 \t// - Wait 在计数器已经归零的情况下，不能再继续增加等待器了 \t// 仍然检查来保证 WaitGroup 不会被滥用 \tif *statep != state { panic(\"sync: WaitGroup misuse: Add called concurrently with Wait\") } // Reset waiters count to 0. \t// 如果计数值v为0并且waiter的数量w不为0，那么state的值就是waiter的数量  // 将waiter的数量设置为0，因为计数值v也是0,所以它们俩的组合*statep直接设置为0即可。此时需要并唤醒所有的waiter \t// 结束后将等待器清零 \t*statep = 0 // 等待器大于零，减少 runtime_Semrelease 产生的阻塞 \tfor ; w != 0; w-- { runtime_Semrelease(semap, false, 0) } } // Done decrements the WaitGroup counter by one. func (wg *WaitGroup) Done() { // Done方法实际就是计数器减1 \twg.Add(-1) }   Add 将 statep 的值作为两段来处理，前 32 位处理为计数器，后 32 位处理为等待器。\n 在初始阶段，等待器为 0 ，计数器随着 Add 正数的调用而增加。 如果 Add 使用错误导致计数器为负，则会立即 panic 由于并发的效果，计数器和等待器的值是分开操作的，因此可能出现计数器已经为零（说明当前 Add 的操作为负，即 Done），但等待器为正的情况，依次调用存储原语释放产生的阻塞（本质上为加 1 操作）  我们来考虑一个使用场景，首先刚创建的 WaitGroup 所有值为零：\n1  statep 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000   这时候调用 Add(1)：\n注意，有符号数为补码表示，最高位为符号位\n1 2 3 4  int64(delta) 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001 int64(delta)32 0000 0000 0000 0000 0000 0000 0000 0001 0000 0000 0000 0000 0000 0000 0000 0000 statep 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 state 0000 0000 0000 0000 0000 0000 0000 0001 0000 0000 0000 0000 0000 0000 0000 0000   那么这时候的 v （计数器）为 1，而 w 等待器为 0。\n再来执行一遍减一的操作。再减一之前：\n1  statep 0000 0000 0000 0000 0000 0000 0000 0001 0000 0000 0000 0000 0000 0000 0000 0000   减一：\n注意，有符号数为补码表示，最高位为符号位\n1 2 3 4  int64(delta) 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 int64(delta)32 1111 1111 1111 1111 1111 1111 1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 statep 0000 0000 0000 0000 0000 0000 0000 0001 0000 0000 0000 0000 0000 0000 0000 0000 state 10000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000   即计数器归零。\nWait Wait 方法的实现逻辑是:不断检查 state 的值。如果其中的计数值变为了 0,那么说明所有的任务已完成,调用者不必再等待,直接返回。如果计数值大于 0,说明此时还有任务没完成,那么调用者就变成了等待者,需要加入 waiter 队列,并且阻塞住自己。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  // Wait blocks until the WaitGroup counter is zero. // Wait 会保持阻塞直到 WaitGroup 计数器归零 func (wg *WaitGroup) Wait() { // 先获得计数器和存储原语 \tstatep, semap := wg.state() if race.Enabled { _ = *statep // trigger nil deref early \trace.Disable() } // 一个简单的死循环，只有当计数器归零才会结束 \tfor { // 原子读 \tstate := atomic.LoadUint64(statep) // 计数 \tv := int32(state  32)// 当前计数值 \tw := uint32(state)\t// waiter的数量 \t// 如果计数器已经归零，则直接退出循环 \tif v == 0 { // Counter is 0, no need to wait. \t// 如果计数值为0, 调用这个方法的goroutine不必再等待,继续执行它后面的逻辑即可 \tif race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(wg)) } return } // Increment waiters count. \t// 否则把waiter数量加1。期间可能有并发调用Wait的情况，所以最外层使用了一个for循环 \t// 增加等待计数，此处的原语会比较 statep 和 state 的值，如果相同则等待计数加 1 \tif atomic.CompareAndSwapUint64(statep, state, state+1) { if race.Enabled \u0026\u0026 w == 0 { // Wait must be synchronized with the first Add. \t// Need to model this is as a write to race with the read in Add. \t// As a consequence, can do the write only for the first waiter, \t// otherwise concurrent Waits will race with each other. \trace.Write(unsafe.Pointer(semap)) } // 阻塞休眠等待 \t// 会阻塞到存储原语是否  0（即睡眠），如果 *semap  0 则会减 1，因此最终的 semap 理论为 0 \truntime_Semacquire(semap) // 在这种情况下，如果 *semap 不等于 0 ，则说明使用失误，直接 panic \tif *statep != 0 { //WaitGroup 虽然可以重用,但是是有一个前提的,那就是必须等到上一轮的 Wait 完成之后,才能重用 WaitGroup 执行下一轮的 Add/Wait,如果你在 Wait 还没执行完的时候就调用下一轮 Add 方法,就有可能出现 panic \tpanic(\"sync: WaitGroup is reused before previous Wait has returned\") } // 被唤醒,不再阻塞,返回 \tif race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(wg)) } return } } }   可以看到 Wait 使用的是一个简单的死循环来进行操作。在循环体中，每次先读取计数器和等待器的值。 然后增加等待计数，如果增加成功，会调用 runtime_Semacquire 来阻塞当前的死循环， 直到存储原语的值被 runtime_Semrelease 减少后才会解除阻塞状态进入下一个循环。\n整体流程 我们来完成考虑一下整个流程：\n1 2 3 4  wg := sync.WaitGroup{} wg.Add(1) go func() { wg.Done() }() wg.Wait()   在 wg 创建之初，计数器、等待器、存储原语的值均初始化为零值。不妨假设调用 wg.Add(1)，则计数器加 1 等待器、存储原语保持不变，均为 0。\nwg.Done() 和 wg.Wait() 的调用顺序可能成两种情况：\n情况 1：先调用 wg.Done() 再调用 wg.Wait()。\n这时候 wg.Done() 使计数器减 1 ，这时计数器、等待器、存储原语均为 0，由于等待器为 0 则 runtime_Semrelease 不会被调用。 于是当 wg.Wait() 开始调用时，读取到计数器已经为 0，循环退出，wg.Wait() 调用完毕。\n情况 2：先调用 wg.Wait() 再调用 wg.Done()。\n这时候 wg.Wait() 开始调用时，读取到计数器为 1，则为等待器加 1，并调用 runtime_Semacquire 开始阻塞在存储原语为 0 的状态。\n在阻塞的过程中，Goroutine 被调度器调度，开始执行 wg.Done()，于是计数器清零，但由于等待器为 1 大于零。 这时将等待器也清零，并调用与等待器技术相同次数（此处为 1 次）的 runtime_Semrelease，这导致存储原语的值变为 1，计数器和等待器均为零。 这时，runtime_Semacquire 在存储原语大于零后被唤醒，这时检查计数器和等待器是否为零（如果不为零则说明 Add 与 Wait 产生并发调用，直接 panic），这时他们为 0，因此进入下一个循环，当再次读取计数器时，发现计数器已经清理，于是退出 wg.Wait() 调用，结束阻塞。\nnoCopy vet 会对实现 Locker 接口的数据类型做静态检查,一旦代码中有复制使用这种数据类型的情况,就会发出警告。\n通过给 WaitGroup 添加一个 noCopy 字段,我们就可以为 WaitGroup 实现 Locker 接口,这样 vet 工具就可以做复制检查了。而且因为 noCopy 字段是未输出类型,所以 WaitGroup 不会暴露 Lock/Unlock 方法。\nnoCopy 字段的类型是 noCopy,它只是一个辅助的、用来帮助 vet 检查用的类型:\n1 2 3 4 5 6 7 8 9 10 11 12  // noCopy may be embedded into structs which must not be copied // after the first use. // // See https://golang.org/issues/8005#issuecomment-190753527 // for details. type noCopy struct{} // Lock is a no-op used by -copylocks checker from `go vet`. func (*noCopy) Lock() {} func (*noCopy) Unlock() {}   如果你想要自己定义的数据结构不被复制使用,或者说,不能通过 vet 工具检查出复制使用的报警,就可以通过嵌入 noCopy 这个数据类型来实现。\n参考 https://colobu.com/2017/07/11/dive-into-sync-Map\nhttps://segmentfault.com/a/1190000015242373\nhttps://pathbox.github.io/2018/04/05/understand-sync.Map-in-Goalng/\nhttp://www.qiuxiaobing.cn/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2018/03/09/go-sync-map.html\nhttp://www.gogodjzhu.com/index.php/code/basic/397/\nhttp://russellluo.com/2017/06/go-sync-map-diagram.html\n5.4 条件变量\n5.5 同步组\nGo 标准库源码分析 - sync 包的Pool\n5.7 并发安全散列表\n6.1 上下文 Context\ngo context剖析之源码分析\n5.3 原子操作\n",
  "wordCount" : "4541",
  "inLanguage": "zh-cn",
  "datePublished": "2021-05-21T14:32:20Z",
  "dateModified": "2021-05-21T14:32:20Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwatigroup%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      并发原语WatiGroup源码剖析
    </h1>
    <div class="post-meta">May 21, 2021
</div>
  </header> 
  <div class="post-content"><h2 id="waitgroup">WaitGroup<a hidden class="anchor" aria-hidden="true" href="#waitgroup">#</a></h2>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210819162825.png" alt=""  />
</p>
<p>sync.WaitGroup 可以达到并发 Goroutine 的执行屏障的效果，等待多个 Goroutine 执行完毕。</p>
<p>sync.WaitGroup 结构体中只包含两个成员变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A WaitGroup waits for a collection of goroutines to finish.
</span><span class="c1">// The main goroutine calls Add to set the number of
</span><span class="c1">// goroutines to wait for. Then each of the goroutines
</span><span class="c1">// runs and calls Done when finished. At the same time,
</span><span class="c1">// Wait can be used to block until all goroutines have finished.
</span><span class="c1">//
</span><span class="c1">// A WaitGroup must not be copied after first use.
</span><span class="c1">// WaitGroup 用于等待一组 Goroutine 执行完毕。
</span><span class="c1">// 主 Goroutine 调用 Add 来设置需要等待的 Goroutine 的数量
</span><span class="c1">// 然后每个 Goroutine 运行并调用 Done 来确认已经执行网完毕
</span><span class="c1">// 同时，Wait 可以用于阻塞并等待所有 Goroutine 完成。
</span><span class="c1">//
</span><span class="c1">// WaitGroup 在第一次使用后不能被复制
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">WaitGroup</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// 避免复制使用的一个技巧,可以告诉vet工具违反了复制使用的规则
</span><span class="c1"></span>	<span class="nx">noCopy</span> <span class="nx">noCopy</span>

	<span class="c1">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.
</span><span class="c1"></span>	<span class="c1">// 64-bit atomic operations require 64-bit alignment, but 32-bit
</span><span class="c1"></span>	<span class="c1">// compilers do not ensure it. So we allocate 12 bytes and then use
</span><span class="c1"></span>	<span class="c1">// the aligned 8 bytes in them as state, and the other 4 as storage
</span><span class="c1"></span>	<span class="c1">// for the sema.
</span><span class="c1"></span>	<span class="c1">// 64 位值: 高 32 位用于计数，低 32 位用于等待计数
</span><span class="c1"></span>	<span class="c1">// 64 位的原子操作要求 64 位对齐，但 32 位编译器无法保证这个要求
</span><span class="c1"></span>	<span class="c1">// 因此分配 12 字节然后将他们对齐，其中 8 字节作为状态，其他 4 字节用于存储原语
</span><span class="c1"></span>	<span class="c1">// 64bit(8bytes)的值分成两段,高32bit是计数值,低32bit是waiter的计数
</span><span class="c1"></span>	<span class="c1">// 另外32bit是用作信号量的
</span><span class="c1"></span>	<span class="c1">// 因为64bit值的原子操作需要64bit对齐，但是32bit编译器不支持，所以数组中的元素在不同的架构中不一样，具体处理看下面的方法
</span><span class="c1"></span>	<span class="c1">// 总之,会找到对齐的那64bit作为state,其余的32bit做信号量
</span><span class="c1"></span>
	<span class="nx">state1</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">uint32</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，WaitGroup 内部仅仅只是一个 uint32 类型的数组。由于需要考虑 32 位机器的兼容性， 这里采用了 uint32 结构的数组，保证在不同类型的机器上都是 12 个字节。</p>
<ul>
<li>noCopy 的辅助字段,主要就是辅助 vet 工具检查是否通过 copy 赋值这个 WaitGroup 实例</li>
<li>state1,一个具有复合意义的字段,包含 WaitGroup 的计数、阻塞在检查点的 waiter 数和信号量。</li>
</ul>
<p>通过 state() 函数来确定实际的存储情况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 得到state的地址和信号量的地址
</span><span class="c1">// state returns pointers to the state and sema fields stored within wg.state1.
</span><span class="c1">// state 返回 wg.state1 中存储的状态和原语字段
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">state</span><span class="p">()</span> <span class="p">(</span><span class="nx">statep</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">,</span> <span class="nx">semap</span> <span class="o">*</span><span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">wg</span><span class="p">.</span><span class="nx">state1</span><span class="p">))</span><span class="o">%</span><span class="mi">8</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 如果地址是64bit对齐的,数组前两个元素做state,后一个元素做信号量
</span><span class="c1"></span>		<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">wg</span><span class="p">.</span><span class="nx">state1</span><span class="p">)),</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">.</span><span class="nx">state1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 如果地址是32bit对齐的,数组后两个元素用来做state,它可以用来做64bit的原子操作
</span><span class="c1"></span>		<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">wg</span><span class="p">.</span><span class="nx">state1</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">.</span><span class="nx">state1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>在 64 位机器上 state1[0] 和 state1[1] 分别用于等待计数和计数，而最后一个 state1[2] 用于存储原语。</li>
<li>在 32 位机器上 state1[0] 作为存储原语，而 state[1] 和 state[2] 用于等待计数和计数</li>
</ul>
<p>因为对 64 位整数的原子操作要求整数的地址是 64 位对齐的,所以针对 64 位和 32 位环境的 state 字段的组成是不一样的。</p>
<p>在 64 位环境下,state1 的第一个元素是 waiter 数,第二个元素是 WaitGroup 的计数值,第三个元素是信号量。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210118113645.png" alt=""  />
</p>
<p>在 32 位环境下,如果 state1 不是 64 位对齐的地址,那么 state1 的第一个元素是信号量,后两个元素分别是 waiter 数和计数值。</p>
<h3 id="adddone">Add&amp;Done<a hidden class="anchor" aria-hidden="true" href="#adddone">#</a></h3>
<p>Add 方法主要操作的是 state 的计数部分。你可以为计数值增加一个 delta 值,内部通过原子操作把这个值加到计数值上。需要注意的是,这个 delta 也可以是个负数,相当于为计数值减去一个值,Done 方法内部其实就是通过 Add(-1) 实现的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// Add adds delta, which may be negative, to the WaitGroup counter.
</span><span class="c1">// If the counter becomes zero, all goroutines blocked on Wait are released.
</span><span class="c1">// If the counter goes negative, Add panics.
</span><span class="c1">//
</span><span class="c1">// Note that calls with a positive delta that occur when the counter is zero
</span><span class="c1">// must happen before a Wait. Calls with a negative delta, or calls with a
</span><span class="c1">// positive delta that start when the counter is greater than zero, may happen
</span><span class="c1">// at any time.
</span><span class="c1">// Typically this means the calls to Add should execute before the statement
</span><span class="c1">// creating the goroutine or other event to be waited for.
</span><span class="c1">// If a WaitGroup is reused to wait for several independent sets of events,
</span><span class="c1">// new Add calls must happen after all previous Wait calls have returned.
</span><span class="c1">// See the WaitGroup example.
</span><span class="c1">// Add 将 delta（可能为负）加到 WaitGroup 的计数器上
</span><span class="c1">// 如果计数器归零，则所有阻塞在 Wait 的 Goroutine 被释放
</span><span class="c1">// 如果计数器为负，则 panic
</span><span class="c1">//
</span><span class="c1">// 请注意，当计数器为 0 时发生的带有正的 delta 的调用必须在 Wait 之前。
</span><span class="c1">// 当计数器大于 0 时，带有负 delta 的调用或带有正 delta 调用可能在任何时候发生。
</span><span class="c1">// 通常，这意味着 Add 调用必须发生在 Goroutine 创建之前或其他被等待事件之前。
</span><span class="c1">// 如果一个 WaitGroup 被复用于等待几个不同的独立事件集合，必须在前一个 Wait 调用返回后才能调用 Add。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">delta</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 首先获取状态指针和存储指针
</span><span class="c1"></span>	<span class="nx">statep</span><span class="p">,</span> <span class="nx">semap</span> <span class="o">:=</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">state</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">_</span> <span class="p">=</span> <span class="o">*</span><span class="nx">statep</span> <span class="c1">// trigger nil deref early
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">delta</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Synchronize decrements with Wait.
</span><span class="c1"></span>			<span class="nx">race</span><span class="p">.</span><span class="nf">ReleaseMerge</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">wg</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Disable</span><span class="p">()</span>
		<span class="k">defer</span> <span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 高32bit是计数值v,所以把delta左移32,增加到计数上
</span><span class="c1"></span>	<span class="c1">// 将 delta 加到 statep 的前 32 位上，即加到计数器上
</span><span class="c1"></span>	<span class="nx">state</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddUint64</span><span class="p">(</span><span class="nx">statep</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">)</span>
	<span class="c1">// 计数器的值
</span><span class="c1"></span>	<span class="nx">v</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">state</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span><span class="c1">// 当前计数值
</span><span class="c1"></span>	<span class="c1">// 等待器的值
</span><span class="c1"></span>	<span class="nx">w</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">state</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="o">&amp;&amp;</span> <span class="nx">delta</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">v</span> <span class="o">==</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// The first increment must be synchronized with Wait.
</span><span class="c1"></span>		<span class="c1">// Need to model this as a read, because there can be
</span><span class="c1"></span>		<span class="c1">// several concurrent wg.counter transitions from 0.
</span><span class="c1"></span>		<span class="nx">race</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">semap</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="c1">// 如果实际计数为负则直接 panic，因此是不允许计数为负值的
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">v</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">//WaitGroup 的计数器的值必须大于等于 0。我们在更改这个计数值的时候,WaitGroup 会先做检查,如果计数值被设置为负数,就会导致 panic。
</span><span class="c1"></span>		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync: negative WaitGroup counter&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果等待器不为零，但 delta 是处于增加的状态，而且存储计数与 delta 的值相同，则立即 panic
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">w</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">delta</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">v</span> <span class="o">==</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync: WaitGroup misuse: Add called concurrently with Wait&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果计数器 &gt; 0 或者等待器为 0 则一切都很好，直接返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">v</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">w</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// This goroutine has set counter to 0 when waiters &gt; 0.
</span><span class="c1"></span>	<span class="c1">// Now there can&#39;t be concurrent mutations of state:
</span><span class="c1"></span>	<span class="c1">// - Adds must not happen concurrently with Wait,
</span><span class="c1"></span>	<span class="c1">// - Wait does not increment waiters if it sees counter == 0.
</span><span class="c1"></span>	<span class="c1">// Still do a cheap sanity check to detect WaitGroup misuse.
</span><span class="c1"></span>	<span class="c1">// 这时 Goroutine 已经将计数器清零，且等待器大于零（并发调用导致）
</span><span class="c1"></span>	<span class="c1">// 这时不允许出现并发使用导致的状态突变，否则就应该 panic
</span><span class="c1"></span>	<span class="c1">// - Add 不能与 Wait 并发调用
</span><span class="c1"></span>	<span class="c1">// - Wait 在计数器已经归零的情况下，不能再继续增加等待器了
</span><span class="c1"></span>	<span class="c1">// 仍然检查来保证 WaitGroup 不会被滥用
</span><span class="c1"></span>	<span class="k">if</span> <span class="o">*</span><span class="nx">statep</span> <span class="o">!=</span> <span class="nx">state</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync: WaitGroup misuse: Add called concurrently with Wait&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// Reset waiters count to 0.
</span><span class="c1"></span>	<span class="c1">// 如果计数值v为0并且waiter的数量w不为0，那么state的值就是waiter的数量
</span><span class="c1"></span>    <span class="c1">// 将waiter的数量设置为0，因为计数值v也是0,所以它们俩的组合*statep直接设置为0即可。此时需要并唤醒所有的waiter
</span><span class="c1"></span>	<span class="c1">// 结束后将等待器清零
</span><span class="c1"></span>	<span class="o">*</span><span class="nx">statep</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 等待器大于零，减少 runtime_Semrelease 产生的阻塞
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">;</span> <span class="nx">w</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">w</span><span class="o">--</span> <span class="p">{</span>
		<span class="nf">runtime_Semrelease</span><span class="p">(</span><span class="nx">semap</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="c1">// Done decrements the WaitGroup counter by one.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Done</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Done方法实际就是计数器减1
</span><span class="c1"></span>	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Add 将 statep 的值作为两段来处理，前 32 位处理为计数器，后 32 位处理为等待器。</p>
<ul>
<li>在初始阶段，等待器为 0 ，计数器随着 Add 正数的调用而增加。</li>
<li>如果 Add 使用错误导致计数器为负，则会立即 panic</li>
<li>由于并发的效果，计数器和等待器的值是分开操作的，因此可能出现计数器已经为零（说明当前 Add 的操作为负，即 Done），但等待器为正的情况，依次调用存储原语释放产生的阻塞（本质上为加 1 操作）</li>
</ul>
<p>我们来考虑一个使用场景，首先刚创建的 WaitGroup 所有值为零：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">statep</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span>
</code></pre></td></tr></table>
</div>
</div><p>这时候调用 Add(1)：</p>
<p>注意，有符号数为补码表示，最高位为符号位</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="nf">int64</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>      <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0001</span>
<span class="nf">int64</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="m">32</span>  <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0001</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span>
<span class="n">statep</span>            <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span>
<span class="n">state</span>             <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0001</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span>
</code></pre></td></tr></table>
</div>
</div><p>那么这时候的 v （计数器）为 1，而 w 等待器为 0。</p>
<p>再来执行一遍减一的操作。再减一之前：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">statep</span>            <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0001</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span>
</code></pre></td></tr></table>
</div>
</div><p>减一：</p>
<p>注意，有符号数为补码表示，最高位为符号位</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="nf">int64</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>      <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span>
<span class="nf">int64</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="m">32</span>  <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span>
<span class="n">statep</span>            <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0001</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span>
<span class="n">state</span>            <span class="m">10000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span>
</code></pre></td></tr></table>
</div>
</div><p>即计数器归零。</p>
<h3 id="wait">Wait<a hidden class="anchor" aria-hidden="true" href="#wait">#</a></h3>
<p>Wait 方法的实现逻辑是:不断检查 state 的值。如果其中的计数值变为了 0,那么说明所有的任务已完成,调用者不必再等待,直接返回。如果计数值大于 0,说明此时还有任务没完成,那么调用者就变成了等待者,需要加入 waiter 队列,并且阻塞住自己。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Wait blocks until the WaitGroup counter is zero.
</span><span class="c1">// Wait 会保持阻塞直到 WaitGroup 计数器归零
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Wait</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 先获得计数器和存储原语
</span><span class="c1"></span>	<span class="nx">statep</span><span class="p">,</span> <span class="nx">semap</span> <span class="o">:=</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">state</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">_</span> <span class="p">=</span> <span class="o">*</span><span class="nx">statep</span> <span class="c1">// trigger nil deref early
</span><span class="c1"></span>		<span class="nx">race</span><span class="p">.</span><span class="nf">Disable</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 一个简单的死循环，只有当计数器归零才会结束
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// 原子读
</span><span class="c1"></span>		<span class="nx">state</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="nx">statep</span><span class="p">)</span>
		<span class="c1">// 计数
</span><span class="c1"></span>		<span class="nx">v</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">state</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span><span class="c1">// 当前计数值
</span><span class="c1"></span>		<span class="nx">w</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">state</span><span class="p">)</span>	<span class="c1">// waiter的数量
</span><span class="c1"></span>		<span class="c1">// 如果计数器已经归零，则直接退出循环
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Counter is 0, no need to wait.
</span><span class="c1"></span>			<span class="c1">// 如果计数值为0, 调用这个方法的goroutine不必再等待,继续执行它后面的逻辑即可
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
				<span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
				<span class="nx">race</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">wg</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">// Increment waiters count.
</span><span class="c1"></span>		<span class="c1">// 否则把waiter数量加1。期间可能有并发调用Wait的情况，所以最外层使用了一个for循环
</span><span class="c1"></span>		<span class="c1">// 增加等待计数，此处的原语会比较 statep 和 state 的值，如果相同则等待计数加 1
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapUint64</span><span class="p">(</span><span class="nx">statep</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">state</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="o">&amp;&amp;</span> <span class="nx">w</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// Wait must be synchronized with the first Add.
</span><span class="c1"></span>				<span class="c1">// Need to model this is as a write to race with the read in Add.
</span><span class="c1"></span>				<span class="c1">// As a consequence, can do the write only for the first waiter,
</span><span class="c1"></span>				<span class="c1">// otherwise concurrent Waits will race with each other.
</span><span class="c1"></span>				<span class="nx">race</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">semap</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="c1">// 阻塞休眠等待
</span><span class="c1"></span>			<span class="c1">// 会阻塞到存储原语是否 &gt; 0（即睡眠），如果 *semap &gt; 0 则会减 1，因此最终的 semap 理论为 0
</span><span class="c1"></span>			<span class="nf">runtime_Semacquire</span><span class="p">(</span><span class="nx">semap</span><span class="p">)</span>
			<span class="c1">// 在这种情况下，如果 *semap 不等于 0 ，则说明使用失误，直接 panic
</span><span class="c1"></span>			<span class="k">if</span> <span class="o">*</span><span class="nx">statep</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">//WaitGroup 虽然可以重用,但是是有一个前提的,那就是必须等到上一轮的 Wait 完成之后,才能重用 WaitGroup 执行下一轮的 Add/Wait,如果你在 Wait 还没执行完的时候就调用下一轮 Add 方法,就有可能出现 panic
</span><span class="c1"></span>				<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync: WaitGroup is reused before previous Wait has returned&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 被唤醒,不再阻塞,返回
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
				<span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
				<span class="nx">race</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">wg</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>可以看到 Wait 使用的是一个简单的死循环来进行操作。在循环体中，每次先读取计数器和等待器的值。 然后增加等待计数，如果增加成功，会调用 runtime_Semacquire 来阻塞当前的死循环， 直到存储原语的值被 runtime_Semrelease 减少后才会解除阻塞状态进入下一个循环。</p>
<h3 id="整体流程">整体流程<a hidden class="anchor" aria-hidden="true" href="#整体流程">#</a></h3>
<p>我们来完成考虑一下整个流程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">wg</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span> <span class="p">}()</span>
<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>在 wg 创建之初，计数器、等待器、存储原语的值均初始化为零值。不妨假设调用 wg.Add(1)，则计数器加 1 等待器、存储原语保持不变，均为 0。</p>
<p>wg.Done() 和 wg.Wait() 的调用顺序可能成两种情况：</p>
<p>情况 1：先调用 wg.Done() 再调用 wg.Wait()。</p>
<p>这时候 wg.Done() 使计数器减 1 ，这时计数器、等待器、存储原语均为 0，由于等待器为 0 则 runtime_Semrelease 不会被调用。 于是当 wg.Wait() 开始调用时，读取到计数器已经为 0，循环退出，wg.Wait() 调用完毕。</p>
<p>情况 2：先调用 wg.Wait() 再调用 wg.Done()。</p>
<p>这时候 wg.Wait() 开始调用时，读取到计数器为 1，则为等待器加 1，并调用 runtime_Semacquire 开始阻塞在存储原语为 0 的状态。</p>
<p>在阻塞的过程中，Goroutine 被调度器调度，开始执行 wg.Done()，于是计数器清零，但由于等待器为 1 大于零。 这时将等待器也清零，并调用与等待器技术相同次数（此处为 1 次）的 runtime_Semrelease，这导致存储原语的值变为 1，计数器和等待器均为零。 这时，runtime_Semacquire 在存储原语大于零后被唤醒，这时检查计数器和等待器是否为零（如果不为零则说明 Add 与 Wait 产生并发调用，直接 panic），这时他们为 0，因此进入下一个循环，当再次读取计数器时，发现计数器已经清理，于是退出 wg.Wait() 调用，结束阻塞。</p>
<h3 id="nocopy">noCopy<a hidden class="anchor" aria-hidden="true" href="#nocopy">#</a></h3>
<p>vet 会对实现 Locker 接口的数据类型做静态检查,一旦代码中有复制使用这种数据类型的情况,就会发出警告。</p>
<p>通过给 WaitGroup 添加一个 noCopy 字段,我们就可以为 WaitGroup 实现 Locker 接口,这样 vet 工具就可以做复制检查了。而且因为 noCopy 字段是未输出类型,所以 WaitGroup 不会暴露 Lock/Unlock 方法。</p>
<p>noCopy 字段的类型是 noCopy,它只是一个辅助的、用来帮助 vet 检查用的类型:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// noCopy may be embedded into structs which must not be copied
</span><span class="c1">// after the first use.
</span><span class="c1">//
</span><span class="c1">// See https://golang.org/issues/8005#issuecomment-190753527
</span><span class="c1">// for details.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">noCopy</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">// Lock is a no-op used by -copylocks checker from `go vet`.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">noCopy</span><span class="p">)</span> <span class="nf">Lock</span><span class="p">()</span>   <span class="p">{}</span>
<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">noCopy</span><span class="p">)</span> <span class="nf">Unlock</span><span class="p">()</span> <span class="p">{}</span>

</code></pre></td></tr></table>
</div>
</div><p>如果你想要自己定义的数据结构不被复制使用,或者说,不能通过 vet 工具检查出复制使用的报警,就可以通过嵌入 noCopy 这个数据类型来实现。</p>
<h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<p><a href="https://colobu.com/2017/07/11/dive-into-sync-Map">https://colobu.com/2017/07/11/dive-into-sync-Map</a></p>
<p><a href="https://segmentfault.com/a/1190000015242373">https://segmentfault.com/a/1190000015242373</a></p>
<p><a href="https://pathbox.github.io/2018/04/05/understand-sync.Map-in-Goalng/">https://pathbox.github.io/2018/04/05/understand-sync.Map-in-Goalng/</a></p>
<p><a href="http://www.qiuxiaobing.cn/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2018/03/09/go-sync-map.html">http://www.qiuxiaobing.cn/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2018/03/09/go-sync-map.html</a></p>
<p><a href="http://www.gogodjzhu.com/index.php/code/basic/397/">http://www.gogodjzhu.com/index.php/code/basic/397/</a></p>
<p><a href="http://russellluo.com/2017/06/go-sync-map-diagram.html">http://russellluo.com/2017/06/go-sync-map-diagram.html</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/cond/">5.4 条件变量</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/waitgroup/">5.5 同步组</a></p>
<p><a href="https://blog.csdn.net/sinat_41790904/article/details/115416237">Go 标准库源码分析 - sync 包的Pool</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/map/">5.7 并发安全散列表</a></p>
<p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/">6.1 上下文 Context</a></p>
<p><a href="https://juejin.cn/post/6844903741842259975">go context剖析之源码分析</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/atomic/">5.3 原子操作</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go%E6%BA%90%E7%A0%81/">Go源码</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
