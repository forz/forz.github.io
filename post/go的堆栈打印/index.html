<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go的堆栈打印 | Forz Blog</title>
<meta name="keywords" content="Go" />
<meta name="description" content="打印全部堆栈 Stack trace是指堆栈回溯信息，在当前时间，以当前方法的执行点开始，回溯调用它的方法的方法的执行点，然后继续回溯，这样就可以跟踪整">
<meta name="author" content="">
<link rel="canonical" href="/post/go%E7%9A%84%E5%A0%86%E6%A0%88%E6%89%93%E5%8D%B0/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Go的堆栈打印" />
<meta property="og:description" content="打印全部堆栈 Stack trace是指堆栈回溯信息，在当前时间，以当前方法的执行点开始，回溯调用它的方法的方法的执行点，然后继续回溯，这样就可以跟踪整" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E7%9A%84%E5%A0%86%E6%A0%88%E6%89%93%E5%8D%B0/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-08-10T14:08:15&#43;00:00" />
<meta property="article:modified_time" content="2017-08-10T14:08:15&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go的堆栈打印"/>
<meta name="twitter:description" content="打印全部堆栈 Stack trace是指堆栈回溯信息，在当前时间，以当前方法的执行点开始，回溯调用它的方法的方法的执行点，然后继续回溯，这样就可以跟踪整"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Go的堆栈打印",
      "item": "/post/go%E7%9A%84%E5%A0%86%E6%A0%88%E6%89%93%E5%8D%B0/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go的堆栈打印",
  "name": "Go的堆栈打印",
  "description": "打印全部堆栈 Stack trace是指堆栈回溯信息，在当前时间，以当前方法的执行点开始，回溯调用它的方法的方法的执行点，然后继续回溯，这样就可以跟踪整",
  "keywords": [
    "Go"
  ],
  "articleBody": "打印全部堆栈 Stack trace是指堆栈回溯信息，在当前时间，以当前方法的执行点开始，回溯调用它的方法的方法的执行点，然后继续回溯，这样就可以跟踪整个方法的调用\npanic 如果应用中有没recover的panic,或者应用在运行的时候出现运行时的异常，那么程序自动会将当前的goroutine的stack trace打印出来。\n比如下面的程序，如果你运行会抛出一个panic。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  package main import ( \"time\" ) func main() { go a() m1() } func m1() { m2() } func m2() { m3() } func m3() { panic(\"panic from m3\") } func a() { time.Sleep(time.Hour) }   输出下面的stack trace:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  dump go run p.go panic: panic from m3 goroutine 1 [running]: panic(0x596a0, 0xc42000a1a0) /usr/local/Cellar/go/1.7.4/libexec/src/runtime/panic.go:500 +0x1a1 main.m3() /Users/yuepan/go/src/github.com/smallnest/dump/p.go:21 +0x6d main.m2() /Users/yuepan/go/src/github.com/smallnest/dump/p.go:17 +0x14 main.m1() /Users/yuepan/go/src/github.com/smallnest/dump/p.go:13 +0x14 main.main() /Users/yuepan/go/src/github.com/smallnest/dump/p.go:9 +0x3a exit status 2   从这个信息中我们可以看到p.go的第9行是main方法，它在这一行调用m1方法，m1方法在第13行调用m2方法，m2方法在第17行调用m3方法，m3方法在第21出现panic， 它们运行在goroutine 1中，当前goroutine 1的状态是running状态。\n如果想让它把所有的goroutine信息都输出出来，可以设置 GOTRACEBACK=1:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  GOTRACEBACK=1 go run p.go panic: panic from m3 goroutine 1 [running]: panic(0x596a0, 0xc42000a1b0) /usr/local/Cellar/go/1.7.4/libexec/src/runtime/panic.go:500 +0x1a1 main.m3() /Users/yuepan/go/src/github.com/smallnest/dump/p.go:21 +0x6d main.m2() /Users/yuepan/go/src/github.com/smallnest/dump/p.go:17 +0x14 main.m1() /Users/yuepan/go/src/github.com/smallnest/dump/p.go:13 +0x14 main.main() /Users/yuepan/go/src/github.com/smallnest/dump/p.go:9 +0x3a goroutine 4 [sleep]: time.Sleep(0x34630b8a000) /usr/local/Cellar/go/1.7.4/libexec/src/runtime/time.go:59 +0xe1 main.a() /Users/yuepan/go/src/github.com/smallnest/dump/p.go:25 +0x30 created by main.main /Users/yuepan/go/src/github.com/smallnest/dump/p.go:8 +0x35 exit status 2   同样你也可以分析这个stack trace的信息，得到方法调用点的情况，同时这个信息将两个goroutine的stack trace都打印出来了，而且goroutine 4的状态是sleep状态。\nGo官方文档对这个环境变量有介绍：\n1  The GOTRACEBACK variable controls the amount of output generated when a Go program fails due to an unrecovered panic or an unexpected runtime condition. By default, a failure prints a stack trace for the current goroutine, eliding functions internal to the run-time system, and then exits with exit code 2. The failure prints stack traces for all goroutines if there is no current goroutine or the failure is internal to the run-time. GOTRACEBACK=none omits the goroutine stack traces entirely. GOTRACEBACK=single (the default) behaves as described above. GOTRACEBACK=all adds stack traces for all user-created goroutines. GOTRACEBACK=system is like “all” but adds stack frames for run-time functions and shows goroutines created internally by the run-time. GOTRACEBACK=crash is like “system” but crashes in an operating system-specific manner instead of exiting. For example, on Unix systems, the crash raises SIGABRT to trigger a core dump. For historical reasons, the GOTRACEBACK settings 0, 1, and 2 are synonyms for none, all, and system, respectively. The runtime/debug package's SetTraceback function allows increasing the amount of output at run time, but it cannot reduce the amount below that specified by the environment variable. See .   你可以设置 none、all、system、single、crash，历史原因， 你可以可是设置数字0、1、2，分别代表none、all、system。\nSIGQUIT 如果程序没有发生panic,但是程序有问题，“假死“不工作，我们想看看哪儿出现了问题，可以给程序发送SIGQUIT信号，也可以输出stack trace信息。\n比如下面的程序:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  package main import ( \"time\" ) func main() { go a() m1() } func m1() { m2() } func m2() { m3() } func m3() { time.Sleep(time.Hour) } func a() { time.Sleep(time.Hour) }   你可以运行 kill -SIGQUIT  杀死这个程序，程序在退出的时候输出strack trace。\npprof.Lookup(“goroutine”).WriteTo 可以通过pprof.Lookup(“goroutine”).WriteTo将所有的goroutine的stack trace都打印出来，如下面的程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  package main import ( \"os\" \"runtime/pprof\" \"time\" ) func main() { go a() m1() } func m1() { m2() } func m2() { m3() } func m3() { pprof.Lookup(\"goroutine\").WriteTo(os.Stdout, 1) time.Sleep(time.Hour) } func a() { time.Sleep(time.Hour) }   debug.PrintStack() 在程序panic的时候，一般会自动把堆栈打出来，如果你想在程序中获取堆栈信息，可以通过debug.PrintStack()打印出来。比如你在程序中遇到一个Error,但是不期望程序panic,只是想把堆栈信息打印出来以便跟踪调试，你可以使用debug.PrintStack()。\n该方法只能输出到标准错误输出的fd上。为了能完整输出栈信息，还精细的做了buf的扩充重试。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package main import ( \"runtime/debug\" \"time\" ) func main() { go a() m1() } func m1() { m2() } func m2() { m3() } func m3() { debug.PrintStack() time.Sleep(time.Hour) } func a() { time.Sleep(time.Hour) }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // PrintStack prints to standard error the stack trace returned by runtime.Stack. func PrintStack() { os.Stderr.Write(Stack()) } // Stack returns a formatted stack trace of the goroutine that calls it. // It calls runtime.Stack with a large enough buffer to capture the entire trace. func Stack() []byte { buf := make([]byte, 1024) for { n := runtime.Stack(buf, false) if n  len(buf) { return buf[:n] } buf = make([]byte, 2*len(buf)) } }   runtime.Stack 你可以使用runtime.Stack得到所有的goroutine的stack trace信息，事实上前面debug.PrintStack()也是通过这个方法获得的。\n为了更方便的随时的得到应用所有的goroutine的stack trace信息，我们可以监听SIGUSR1信号，当收到这个信号的时候就将stack trace打印出来。发送信号也很简单，通过kill -SIGUSR1 就可以，不必担心kill会将程序杀死，它只是发了一个信号而已。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  package main import ( \"fmt\" \"os\" \"os/signal\" \"runtime\" \"syscall\" \"time\" ) func main() { setupSigusr1Trap() go a() m1() } func m1() { m2() } func m2() { m3() } func m3() { time.Sleep(time.Hour) } func a() { time.Sleep(time.Hour) } func setupSigusr1Trap() { c := make(chan os.Signal, 1) signal.Notify(c, syscall.SIGUSR1) go func() { for range c { DumpStacks() } }() } func DumpStacks() { buf := make([]byte, 16384) // 获取 所有goroutine 的 stacktrace \tbuf = buf[:runtime.Stack(buf, true)] // 如果需要获取当前goroutine 的 stacktrace, 第二个参数需要为 `false` \tfmt.Printf(\"=== BEGIN goroutine stack dump ===\\n%s\\n=== END goroutine stack dump ===\", buf) }   输出结果很直观，方便检查。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  === BEGIN goroutine stack dump === goroutine 36 [running]: main.DumpStacks() /Users/yuepan/go/src/github.com/smallnest/dump/d3.go:47 +0x77 main.setupSigusr1Trap.func1(0xc420070060) /Users/yuepan/go/src/github.com/smallnest/dump/d3.go:40 +0x73 created by main.setupSigusr1Trap /Users/yuepan/go/src/github.com/smallnest/dump/d3.go:42 +0xec goroutine 1 [sleep]: time.Sleep(0x34630b8a000) /usr/local/Cellar/go/1.7.4/libexec/src/runtime/time.go:59 +0xe1 main.m3() /Users/yuepan/go/src/github.com/smallnest/dump/d3.go:28 +0x30 main.m2() /Users/yuepan/go/src/github.com/smallnest/dump/d3.go:24 +0x14 main.m1() /Users/yuepan/go/src/github.com/smallnest/dump/d3.go:20 +0x14 main.main() /Users/yuepan/go/src/github.com/smallnest/dump/d3.go:16 +0x3f goroutine 34 [syscall]: os/signal.signal_recv(0xff280) /usr/local/Cellar/go/1.7.4/libexec/src/runtime/sigqueue.go:116 +0x157 os/signal.loop() /usr/local/Cellar/go/1.7.4/libexec/src/os/signal/signal_unix.go:22 +0x22 created by os/signal.init.1 /usr/local/Cellar/go/1.7.4/libexec/src/os/signal/signal_unix.go:28 +0x41 goroutine 35 [select, locked to thread]: runtime.gopark(0xb5cc8, 0x0, 0xab3ef, 0x6, 0x18, 0x2) /usr/local/Cellar/go/1.7.4/libexec/src/runtime/proc.go:259 +0x13a runtime.selectgoImpl(0xc42008d730, 0x0, 0x18) /usr/local/Cellar/go/1.7.4/libexec/src/runtime/select.go:423 +0x11d9 runtime.selectgo(0xc42008d730) /usr/local/Cellar/go/1.7.4/libexec/src/runtime/select.go:238 +0x1c runtime.ensureSigM.func1() /usr/local/Cellar/go/1.7.4/libexec/src/runtime/signal1_unix.go:304 +0x2d1 runtime.goexit() /usr/local/Cellar/go/1.7.4/libexec/src/runtime/asm_amd64.s:2086 +0x1 goroutine 37 [sleep]: time.Sleep(0x34630b8a000) /usr/local/Cellar/go/1.7.4/libexec/src/runtime/time.go:59 +0xe1 main.a() /Users/yuepan/go/src/github.com/smallnest/dump/d3.go:32 +0x30 created by main.main /Users/yuepan/go/src/github.com/smallnest/dump/d3.go:15 +0x3a === END goroutine stack dump ===   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // Stack formats a stack trace of the calling goroutine into buf // and returns the number of bytes written to buf. // If all is true, Stack formats stack traces of all other goroutines // into buf after the trace for the current goroutine. func Stack(buf []byte, all bool) int { if all { stopTheWorld(\"stack trace\") } n := 0 if len(buf)  0 { gp := getg() sp := getcallersp() pc := getcallerpc() systemstack(func() { g0 := getg() // Force traceback=1 to override GOTRACEBACK setting, \t// so that Stack's results are consistent. \t// GOTRACEBACK is only about crash dumps. \tg0.m.traceback = 1 g0.writebuf = buf[0:0:len(buf)] goroutineheader(gp) traceback(pc, sp, 0, gp) if all { tracebackothers(gp) } g0.m.traceback = 0 n = len(g0.writebuf) g0.writebuf = nil }) } if all { startTheWorld() } return n }   当all=false时，只会获取当前协程的函数调用栈信息，无需加锁。但all=true时，意味着要获取所有协程的栈信息，在go runtime的pmg调度模型下，为了保证并发操作安全，自然就需要在stack方法里加了锁，且锁的粒度还不小，直接调用stopTheWorld用来阻塞GC的操作。\ngoroutineheader方法用来获取协程的状态信息，比如等待锁，scan，已等待时间等。allgs是runtime保存的所有已创建协程的容器，当然不会去追踪已经消亡的协程。另外，为了保护allgs切片的安全，还会对allglock加锁，在allgadd()创建goroutine和checkdead()检测死锁里会产生锁竞争。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  func goroutineheader(gp *g) { gpstatus := readgstatus(gp) isScan := gpstatus\u0026_Gscan != 0 gpstatus \u0026^= _Gscan // drop the scan bit  // Basic string status \tvar status string if 0  gpstatus \u0026\u0026 gpstatus  uint32(len(gStatusStrings)) { status = gStatusStrings[gpstatus] } else { status = \"???\" } // Override. \tif gpstatus == _Gwaiting \u0026\u0026 gp.waitreason != waitReasonZero { status = gp.waitreason.String() } // approx time the G is blocked, in minutes \tvar waitfor int64 if (gpstatus == _Gwaiting || gpstatus == _Gsyscall) \u0026\u0026 gp.waitsince != 0 { waitfor = (nanotime() - gp.waitsince) / 60e9 } print(\"goroutine \", gp.goid, \" [\", status) if isScan { print(\" (scan)\") } if waitfor = 1 { print(\", \", waitfor, \" minutes\") } if gp.lockedm != 0 { print(\", locked to thread\") } print(\"]:\\n\") }   http/pprof 如果你的代码中配置了 http/pprof,你可以通过下面的地址访问所有的groutine的堆栈：\n1  http://localhost:8888/debug/pprof/goroutine?debug=2.   更可控的调用信息 上面的函数虽然可以获取调用栈，但是直接将所有调用信息返回，控制参数较少。\n下面几个函数可以实现获取单层的调用信息。\nruntime.Caller 1  runtime.Caller(skip int) (pc uintptr, file string, line int, ok bool)   runtime.Caller 返回当前 goroutine 的栈上的函数调用信息. 主要有当前的pc 值和调用的文件和行号等信息.\n 参数skip：表示跳过的层级，相当于往上获取第几层的调用者。若为 0 则表示 runtime.Caller 的调用者。1 代表上一层调用者，以此类推。 返回值  pc：program counter，可以大概理解为函数编号，可以通过runtime.FuncForPC解析. file：文件名 line：行号 ok:若无法获得信息, 返回的 ok 值为 false.    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func main() { Foo() } func Foo() { fmt.Printf(\"我是 %s, %s 在调用我!\\n\", printMyName(), printCallerName()) Bar() } func Bar() { fmt.Printf(\"我是 %s, %s 又在调用我!\\n\", printMyName(), printCallerName()) } func printMyName() string { pc, _, _, _ := runtime.Caller(1) return runtime.FuncForPC(pc).Name() } func printCallerName() string { pc, _, _, _ := runtime.Caller(2) return runtime.FuncForPC(pc).Name() }   可以得到这样一条输出：\n1 2  我是 main.Foo, 谁在调用我? 我是 main.Bar, 谁又在调用我?   runtime.Callers 1  runtime.Callers(skip int, pc []uintptr) int   runtime.Callers 把调用它的函数Go程栈上的程序计数器填入切片 pc 中. 参数 skip 为开始在 pc 中记录之前所要跳过的栈帧数, 若为 0 则表示 runtime.Callers 自身的栈帧, 若为 1 则表示调用者的栈帧. 该函数返回写入到 pc 切片中的项数(受切片的容量限制).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  …… func Bar() { fmt.Printf(\"我是 %s, %s 又在调用我!\\n\", printMyName(), printCallerName()) trace() } func trace() { pc := make([]uintptr, 10) // at least 1 entry needed \tn := runtime.Callers(0, pc) for i := 0; i  n; i++ { f := runtime.FuncForPC(pc[i]) file, line := f.FileLine(pc[i]) fmt.Printf(\"%s:%d %s\\n\", file, line, f.Name()) } }   输出结果可以看到这个goroutine的整个栈都打印出来了：\n1 2 3 4 5 6 7  /usr/local/go/src/runtime/extern.go:218 runtime.Callers /Users/yuepan/go/src/git.intra.weibo.com/platform/tool/g/main.go:34 main.trace /Users/yuepan/go/src/git.intra.weibo.com/platform/tool/g/main.go:20 main.Bar /Users/yuepan/go/src/git.intra.weibo.com/platform/tool/g/main.go:15 main.Foo /Users/yuepan/go/src/git.intra.weibo.com/platform/tool/g/main.go:10 main.main /usr/local/go/src/runtime/proc.go:210 runtime.main /usr/local/go/src/runtime/asm_amd64.s:1334 runtime.goexit   runtime.FuncForPC FuncForPC 是一个有趣的函数， 它可以把程序计数器地址对应的函数的信息获取出来。如果因为内联程序计数器对应多个函数，它返回最外面的函数。\n它的返回值是一个Func类型的值，通过Func可以获得函数地址、文件行、函数名等信息。\n1 2 3 4  func runtime.FuncForPC(pc uintptr) *runtime.Func func (f *runtime.Func) FileLine(pc uintptr) (file string, line int) func (f *runtime.Func) Entry() uintptr func (f *runtime.Func) Name() string   其中 runtime.FuncForPC 返回包含给定 pc 地址的函数, 如果是无效 pc 则返回 nil .\nruntime.Func.FileLine 返回与 pc 对应的源码文件名和行号. 如果pc不在函数帧范围内, 则结果是不确定的.\nruntime.Func.Entry 对应函数的地址. runtime.Func.Name 返回该函数的名称.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  func main() { for skip := 0; ; skip++ { pc, _, _, ok := runtime.Caller(skip) if !ok { break } p := runtime.FuncForPC(pc) file, line := p.FileLine(0) fmt.Printf(\"skip = %v, pc = %v\\n\", skip, pc) fmt.Printf(\" file = %v, line = %d\\n\", file, line) fmt.Printf(\" entry = %v\\n\", p.Entry()) fmt.Printf(\" name = %v\\n\", p.Name()) } // Output: \t// skip = 0, pc = 4198456 \t// file = caller.go, line = 8 \t// entry = 4198400 \t// name = main.main \t// skip = 1, pc = 4282882 \t// file = $(GOROOT)/src/pkg/runtime/proc.c, line = 179 \t// entry = 4282576 \t// name = runtime.main \t// skip = 2, pc = 4292528 \t// file = $(GOROOT)/src/pkg/runtime/proc.c, line = 1394 \t// entry = 4292528 \t// name = runtime.goexit \tpc := make([]uintptr, 1024) for skip := 0; ; skip++ { n := runtime.Callers(skip, pc) if n  0 { break } fmt.Printf(\"skip = %v, pc = %v\\n\", skip, pc[:n]) for j := 0; j  n; j++ { p := runtime.FuncForPC(pc[j]) file, line := p.FileLine(0) fmt.Printf(\" skip = %v, pc = %v\\n\", skip, pc[j]) fmt.Printf(\" file = %v, line = %d\\n\", file, line) fmt.Printf(\" entry = %v\\n\", p.Entry()) fmt.Printf(\" name = %v\\n\", p.Name()) } break } // Output: \t// skip = 0, pc = [4307254 4198586 4282882 4292528] \t// skip = 0, pc = 4307254 \t// file = $(GOROOT)/src/pkg/runtime/runtime.c, line = 315 \t// entry = 4307168 \t// name = runtime.Callers \t// skip = 0, pc = 4198586 \t// file = caller.go, line = 8 \t// entry = 4198400 \t// name = main.main \t// skip = 0, pc = 4282882 \t// file = $(GOROOT)/src/pkg/runtime/proc.c, line = 179 \t// entry = 4282576 \t// name = runtime.main \t// skip = 0, pc = 4292528 \t// file = $(GOROOT)/src/pkg/runtime/proc.c, line = 1394 \t// entry = 4292528 \t// name = runtime.goexit }   除了上面获取程序计数器的方式，也可以通过反射的方式获取函数的地址：\n1  runtime.FuncForPC(reflect.ValueOf(foo).Pointer()).Name()   runtime.CallersFrames 上面的Callers只是或者栈的程序计数器，如果想获得整个栈的信息，可以使用CallersFrames函数，省去遍历调用FuncForPC。\n1  runtime.CallersFrames(callers []uintptr) *runtime.Frames   runtime.CallersFrames可以一次解析多个pc\n上面的trace函数可以更改为下面的方式：\n1 2 3 4 5 6 7 8 9 10 11 12  func trace2() { pc := make([]uintptr, 10) // at least 1 entry needed \tn := runtime.Callers(0, pc) frames := runtime.CallersFrames(pc[:n]) for { frame, more := frames.Next() fmt.Printf(\"%s:%d %s\\n\", frame.File, frame.Line, frame.Function) if !more { break } } }   获取goroutine的id 1 2 3 4 5 6 7 8 9 10  func GoID() int { var buf [64]byte n := runtime.Stack(buf[:], false) idField := strings.Fields(strings.TrimPrefix(string(buf[:n]), \"goroutine \"))[0] id, err := strconv.Atoi(idField) if err != nil { panic(fmt.Sprintf(\"cannot get goroutine id: %v\", err)) } return id }   打印堆栈的性能问题 背景 runtime.Caller能够拿到当前执行的文件名和行号，这个方法几乎所有的日志组件里都有使用。\n1  func Caller(skip int) (pc uintptr, file string, line int, ok bool) {}   但是问题也很明显，这个函数开销太大。跟了一下代码实现，发现主要就是不停地迭代，而这个迭代过程虽然单次消耗的时间可以忽略不计，但是对于日志量巨大的服务而言影响还是很大的。详情参见下面的代码\n解决方案 网上了解了一下，目前没有找到不使用runtime包获取执行文件和行号的解决方案。既然官方的包很难有优化空间，那可以考虑一下业务侧有什么解决方案。于是查了一些github上比较知名的项目，学习了一下。\n标准库log 官方写的日志组件，在log包里的，值得参考一下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // Output writes the output for a logging event. The string s contains // the text to print after the prefix specified by the flags of the // Logger. A newline is appended if the last character of s is not // already a newline. Calldepth is used to recover the PC and is // provided for generality, although at the moment on all pre-defined // paths it will be 2. func (l *Logger) Output(calldepth int, s string) error { now := time.Now() // get this early. \tvar file string var line int l.mu.Lock() defer l.mu.Unlock() if l.flag\u0026(Lshortfile|Llongfile) != 0 { // Release lock while getting caller info - it's expensive. \tl.mu.Unlock() var ok bool _, file, line, ok = runtime.Caller(calldepth) if !ok { file = \"???\" line = 0 } l.mu.Lock() } l.buf = l.buf[:0] l.formatHeader(\u0026l.buf, now, file, line) l.buf = append(l.buf, s...) if len(s) == 0 || s[len(s)-1] != '\\n' { l.buf = append(l.buf, '\\n') } _, err := l.out.Write(l.buf) return err }   注释里说明官方也是知道runtime.Caller性能有问题。这里的Logger里带有一个Mutex锁，方便在高并发或者多协程的时候保护上下文数据一致。\n这里值得借鉴的是并没有所有的日志都记录文件名和行号，而是添加了标记位flag，只有在需要的业务场景下(Lshortfile或者Llongfile )，才调用runtime.Caller，避免不必要的开支。\n另外一方面，在调用性能比较差的runtime.Caller之前，把锁释放，执行完毕后再把锁加上，继续处理自己后续的业务。这个可以避免锁的时间过长，影响其他业务。\nzap 看一下实现行号和文件名的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  func (log *Logger) check(lvl zapcore.Level, msg string) *zapcore.CheckedEntry { // check must always be called directly by a method in the Logger interface \t// (e.g., Check, Info, Fatal). \tconst callerSkipOffset = 2 // Check the level first to reduce the cost of disabled log calls. \t// Since Panic and higher may exit, we skip the optimization for those levels. \tif lvl  zapcore.DPanicLevel \u0026\u0026 !log.core.Enabled(lvl) { return nil } // Create basic checked entry thru the core; this will be non-nil if the \t// log message will actually be written somewhere. \tent := zapcore.Entry{ LoggerName: log.name, Time: time.Now(), Level: lvl, Message: msg, } ce := log.core.Check(ent, nil) willWrite := ce != nil // Set up any required terminal behavior. \tswitch ent.Level { case zapcore.PanicLevel: ce = ce.Should(ent, zapcore.WriteThenPanic) case zapcore.FatalLevel: onFatal := log.onFatal // Noop is the default value for CheckWriteAction, and it leads to \t// continued execution after a Fatal which is unexpected. \tif onFatal == zapcore.WriteThenNoop { onFatal = zapcore.WriteThenFatal } ce = ce.Should(ent, onFatal) case zapcore.DPanicLevel: if log.development { ce = ce.Should(ent, zapcore.WriteThenPanic) } } // Only do further annotation if we're going to write this message; checked \t// entries that exist only for terminal behavior don't benefit from \t// annotation. \tif !willWrite { return ce } // Thread the error output through to the CheckedEntry. \tce.ErrorOutput = log.errorOutput if log.addCaller { frame, defined := getCallerFrame(log.callerSkip + callerSkipOffset) if !defined { fmt.Fprintf(log.errorOutput, \"%v Logger.check error: failed to get caller\\n\", time.Now().UTC()) log.errorOutput.Sync() } ce.Entry.Caller = zapcore.EntryCaller{ Defined: defined, PC: frame.PC, File: frame.File, Line: frame.Line, Function: frame.Function, } } if log.addStack.Enabled(ce.Entry.Level) { ce.Entry.Stack = StackSkip(\"\", log.callerSkip+callerSkipOffset).String } return ce }   它们将Caller信息放在CallerEntry.Entry.Caller结构里，并且和google类似，提供了标记位(addCaller)，只有在需要的场景下才会调用runtime.Caller.\n值得一提的是，zap提供了Sugar和Desugar的模式，所谓Sugar就是提供程序员更友好方便的日志记录方式，但是牺牲了部分性能，核心就是Caller的skipCaller+2。Desugar就是个逆向的过程，可以将Sugared的结构再次回退到性能较高的原始模式，核心是Caller的callerSkip-2。两者可以在代码里面共同存在使用。\nSugar和Desuagr的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  //go.uber.org/zap/logger.go#L126  // Sugar wraps the Logger to provide a more ergonomic, but slightly slower, // API. Sugaring a Logger is quite inexpensive, so it's reasonable for a // single application to use both Loggers and SugaredLoggers, converting // between them on the boundaries of performance-sensitive code. func (log *Logger) Sugar() *SugaredLogger { core := log.clone() core.callerSkip += 2 return \u0026SugaredLogger{core} } // Desugar unwraps a SugaredLogger, exposing the original Logger. Desugaring // is quite inexpensive, so it's reasonable for a single application to use // both Loggers and SugaredLoggers, converting between them on the boundaries // of performance-sensitive code. func (s *SugaredLogger) Desugar() *Logger { base := s.base.clone() base.callerSkip -= 2 return base }   顺便在这里提一下受zap启发的zerolog项目( https://github.com/rs/zerolog )，zerolog更是将行号和文件名的开关提到了顶层位置，使用时需要手动触发(log.With().Caller())才会去调用Caller: github.com/rs/zerolog/event.go#L635\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  //add file name and file line number to log  log.Logger = log.With().Caller().Logger() log.Info().Msg(\"hello world\") // Caller adds the file:line of the caller with the zerolog.CallerFieldName key.  func (e *Event) Caller()*Event { return e.caller(CallerSkipFrameCount) } func (e *Event) caller(skip int)*Event { if e == nil { return e } _, file, line, ok := runtime.Caller(skip) if !ok { return e } e.buf = enc.AppendString(enc.AppendKey(e.buf, CallerFieldName), file+\":\"+strconv.Itoa(line)) return e }   参考 调试利器：dump goroutine 的 stacktrace\ngo runtime.stack加锁引起高时延及阻塞 在 Golang 中打印调用栈信息 如何在Go的函数中得到调用者函数名? 深入学习 Go 语言函数调用信息 golang日志组件使用runtime.Caller性能问题分析\n",
  "wordCount" : "6181",
  "inLanguage": "zh-cn",
  "datePublished": "2017-08-10T14:08:15Z",
  "dateModified": "2017-08-10T14:08:15Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/go%E7%9A%84%E5%A0%86%E6%A0%88%E6%89%93%E5%8D%B0/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Go的堆栈打印
    </h1>
    <div class="post-meta">August 10, 2017
</div>
  </header> 
  <div class="post-content"><h2 id="打印全部堆栈">打印全部堆栈<a hidden class="anchor" aria-hidden="true" href="#打印全部堆栈">#</a></h2>
<p>Stack trace是指堆栈回溯信息，在当前时间，以当前方法的执行点开始，回溯调用它的方法的方法的执行点，然后继续回溯，这样就可以跟踪整个方法的调用</p>
<h3 id="panic">panic<a hidden class="anchor" aria-hidden="true" href="#panic">#</a></h3>
<p>如果应用中有没recover的panic,或者应用在运行的时候出现运行时的异常，那么程序自动会将当前的goroutine的stack trace打印出来。</p>
<p>比如下面的程序，如果你运行会抛出一个panic。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="nf">a</span><span class="p">()</span>
	<span class="nf">m1</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">m1</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">m2</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">m2</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">m3</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">m3</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;panic from m3&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">a</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>输出下面的stack trace:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">dump</span> <span class="n">go</span> <span class="n">run</span> <span class="n">p.go</span>
<span class="n">panic</span><span class="o">:</span> <span class="n">panic</span> <span class="n">from</span> <span class="n">m3</span>
<span class="n">goroutine</span> <span class="m">1</span> <span class="n">[running]</span><span class="o">:</span>
<span class="nf">panic</span><span class="p">(</span><span class="mh">0x596a0</span><span class="p">,</span> <span class="mh">0xc42000a1a0</span><span class="p">)</span>
	<span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">Cellar</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="m">1.7.4</span><span class="o">/</span><span class="n">libexec</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">panic.go</span><span class="o">:</span><span class="m">500</span> <span class="m">+0</span><span class="n">x1a1</span>
<span class="nf">main.m3</span><span class="p">()</span>
	<span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">yuepan</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">github.com</span><span class="o">/</span><span class="n">smallnest</span><span class="o">/</span><span class="n">dump</span><span class="o">/</span><span class="n">p.go</span><span class="o">:</span><span class="m">21</span> <span class="m">+0</span><span class="n">x6d</span>
<span class="nf">main.m2</span><span class="p">()</span>
	<span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">yuepan</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">github.com</span><span class="o">/</span><span class="n">smallnest</span><span class="o">/</span><span class="n">dump</span><span class="o">/</span><span class="n">p.go</span><span class="o">:</span><span class="m">17</span> <span class="m">+0</span><span class="n">x14</span>
<span class="nf">main.m1</span><span class="p">()</span>
	<span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">yuepan</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">github.com</span><span class="o">/</span><span class="n">smallnest</span><span class="o">/</span><span class="n">dump</span><span class="o">/</span><span class="n">p.go</span><span class="o">:</span><span class="m">13</span> <span class="m">+0</span><span class="n">x14</span>
<span class="nf">main.main</span><span class="p">()</span>
	<span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">yuepan</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">github.com</span><span class="o">/</span><span class="n">smallnest</span><span class="o">/</span><span class="n">dump</span><span class="o">/</span><span class="n">p.go</span><span class="o">:</span><span class="m">9</span> <span class="m">+0</span><span class="n">x3a</span>
<span class="n">exit</span> <span class="n">status</span> <span class="m">2</span>
</code></pre></td></tr></table>
</div>
</div><p>从这个信息中我们可以看到p.go的第9行是main方法，它在这一行调用m1方法，m1方法在第13行调用m2方法，m2方法在第17行调用m3方法，m3方法在第21出现panic， 它们运行在goroutine 1中，当前goroutine 1的状态是running状态。</p>
<p>如果想让它把所有的goroutine信息都输出出来，可以设置 GOTRACEBACK=1:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">GOTRACEBACK</span><span class="p">=</span><span class="mi">1</span> <span class="k">go</span> <span class="nx">run</span> <span class="nx">p</span><span class="p">.</span><span class="k">go</span>
<span class="nx">panic</span><span class="p">:</span> <span class="nx">panic</span> <span class="nx">from</span> <span class="nx">m3</span>
<span class="nx">goroutine</span> <span class="mi">1</span> <span class="p">[</span><span class="nx">running</span><span class="p">]:</span>
<span class="nb">panic</span><span class="p">(</span><span class="mh">0x596a0</span><span class="p">,</span> <span class="mh">0xc42000a1b0</span><span class="p">)</span>
	<span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">Cellar</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="mf">1.7.4</span><span class="o">/</span><span class="nx">libexec</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="nx">panic</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">500</span> <span class="o">+</span><span class="mh">0x1a1</span>
<span class="nx">main</span><span class="p">.</span><span class="nf">m3</span><span class="p">()</span>
	<span class="o">/</span><span class="nx">Users</span><span class="o">/</span><span class="nx">yuepan</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">smallnest</span><span class="o">/</span><span class="nx">dump</span><span class="o">/</span><span class="nx">p</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">21</span> <span class="o">+</span><span class="mh">0x6d</span>
<span class="nx">main</span><span class="p">.</span><span class="nf">m2</span><span class="p">()</span>
	<span class="o">/</span><span class="nx">Users</span><span class="o">/</span><span class="nx">yuepan</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">smallnest</span><span class="o">/</span><span class="nx">dump</span><span class="o">/</span><span class="nx">p</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">17</span> <span class="o">+</span><span class="mh">0x14</span>
<span class="nx">main</span><span class="p">.</span><span class="nf">m1</span><span class="p">()</span>
	<span class="o">/</span><span class="nx">Users</span><span class="o">/</span><span class="nx">yuepan</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">smallnest</span><span class="o">/</span><span class="nx">dump</span><span class="o">/</span><span class="nx">p</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">13</span> <span class="o">+</span><span class="mh">0x14</span>
<span class="nx">main</span><span class="p">.</span><span class="nf">main</span><span class="p">()</span>
	<span class="o">/</span><span class="nx">Users</span><span class="o">/</span><span class="nx">yuepan</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">smallnest</span><span class="o">/</span><span class="nx">dump</span><span class="o">/</span><span class="nx">p</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">9</span> <span class="o">+</span><span class="mh">0x3a</span>
<span class="nx">goroutine</span> <span class="mi">4</span> <span class="p">[</span><span class="nx">sleep</span><span class="p">]:</span>
<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mh">0x34630b8a000</span><span class="p">)</span>
	<span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">Cellar</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="mf">1.7.4</span><span class="o">/</span><span class="nx">libexec</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="nx">time</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">59</span> <span class="o">+</span><span class="mh">0xe1</span>
<span class="nx">main</span><span class="p">.</span><span class="nf">a</span><span class="p">()</span>
	<span class="o">/</span><span class="nx">Users</span><span class="o">/</span><span class="nx">yuepan</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">smallnest</span><span class="o">/</span><span class="nx">dump</span><span class="o">/</span><span class="nx">p</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">25</span> <span class="o">+</span><span class="mh">0x30</span>
<span class="nx">created</span> <span class="nx">by</span> <span class="nx">main</span><span class="p">.</span><span class="nx">main</span>
	<span class="o">/</span><span class="nx">Users</span><span class="o">/</span><span class="nx">yuepan</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">smallnest</span><span class="o">/</span><span class="nx">dump</span><span class="o">/</span><span class="nx">p</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">8</span> <span class="o">+</span><span class="mh">0x35</span>
<span class="nx">exit</span> <span class="nx">status</span> <span class="mi">2</span>
</code></pre></td></tr></table>
</div>
</div><p>同样你也可以分析这个stack trace的信息，得到方法调用点的情况，同时这个信息将两个goroutine的stack trace都打印出来了，而且goroutine 4的状态是sleep状态。</p>
<p>Go官方文档对这个环境变量有介绍：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">The</span> <span class="n">GOTRACEBACK</span> <span class="n">variable</span> <span class="n">controls</span> <span class="n">the</span> <span class="n">amount</span> <span class="n">of</span> <span class="n">output</span> <span class="n">generated</span> <span class="n">when</span> <span class="n">a</span> <span class="n">Go</span> <span class="n">program</span> <span class="n">fails</span> <span class="n">due</span> <span class="n">to</span> <span class="n">an</span> <span class="n">unrecovered</span> <span class="n">panic</span> <span class="n">or</span> <span class="n">an</span> <span class="n">unexpected</span> <span class="n">runtime</span> <span class="n">condition.</span> <span class="n">By</span> <span class="n">default</span><span class="p">,</span> <span class="n">a</span> <span class="n">failure</span> <span class="n">prints</span> <span class="n">a</span> <span class="n">stack</span> <span class="n">trace</span> <span class="n">for</span> <span class="n">the</span> <span class="n">current</span> <span class="n">goroutine</span><span class="p">,</span> <span class="n">eliding</span> <span class="n">functions</span> <span class="n">internal</span> <span class="n">to</span> <span class="n">the</span> <span class="n">run</span><span class="o">-</span><span class="n">time</span> <span class="n">system</span><span class="p">,</span> <span class="n">and</span> <span class="n">then</span> <span class="n">exits</span> <span class="n">with</span> <span class="n">exit</span> <span class="n">code</span> <span class="m">2</span><span class="n">. The</span> <span class="n">failure</span> <span class="n">prints</span> <span class="n">stack</span> <span class="n">traces</span> <span class="n">for</span> <span class="n">all</span> <span class="n">goroutines</span> <span class="n">if</span> <span class="n">there</span> <span class="n">is</span> <span class="n">no</span> <span class="n">current</span> <span class="n">goroutine</span> <span class="n">or</span> <span class="n">the</span> <span class="n">failure</span> <span class="n">is</span> <span class="n">internal</span> <span class="n">to</span> <span class="n">the</span> <span class="n">run</span><span class="o">-</span><span class="n">time.</span> <span class="n">GOTRACEBACK</span><span class="o">=</span><span class="n">none</span> <span class="n">omits</span> <span class="n">the</span> <span class="n">goroutine</span> <span class="n">stack</span> <span class="n">traces</span> <span class="n">entirely.</span> <span class="n">GOTRACEBACK</span><span class="o">=</span><span class="nf">single </span><span class="p">(</span><span class="n">the</span> <span class="n">default</span><span class="p">)</span> <span class="n">behaves</span> <span class="n">as</span> <span class="n">described</span> <span class="n">above.</span> <span class="n">GOTRACEBACK</span><span class="o">=</span><span class="n">all</span> <span class="n">adds</span> <span class="n">stack</span> <span class="n">traces</span> <span class="n">for</span> <span class="n">all</span> <span class="n">user</span><span class="o">-</span><span class="n">created</span> <span class="n">goroutines.</span> <span class="n">GOTRACEBACK</span><span class="o">=</span><span class="n">system</span> <span class="n">is</span> <span class="n">like</span> “<span class="n">all</span>” <span class="n">but</span> <span class="n">adds</span> <span class="n">stack</span> <span class="n">frames</span> <span class="n">for</span> <span class="n">run</span><span class="o">-</span><span class="n">time</span> <span class="n">functions</span> <span class="n">and</span> <span class="n">shows</span> <span class="n">goroutines</span> <span class="n">created</span> <span class="n">internally</span> <span class="n">by</span> <span class="n">the</span> <span class="n">run</span><span class="o">-</span><span class="n">time.</span> <span class="n">GOTRACEBACK</span><span class="o">=</span><span class="n">crash</span> <span class="n">is</span> <span class="n">like</span> “<span class="n">system</span>” <span class="n">but</span> <span class="n">crashes</span> <span class="n">in</span> <span class="n">an</span> <span class="n">operating</span> <span class="n">system</span><span class="o">-</span><span class="n">specific</span> <span class="n">manner</span> <span class="n">instead</span> <span class="n">of</span> <span class="n">exiting.</span> <span class="n">For</span> <span class="n">example</span><span class="p">,</span> <span class="n">on</span> <span class="n">Unix</span> <span class="n">systems</span><span class="p">,</span> <span class="n">the</span> <span class="n">crash</span> <span class="n">raises</span> <span class="n">SIGABRT</span> <span class="n">to</span> <span class="n">trigger</span> <span class="n">a</span> <span class="n">core</span> <span class="n">dump.</span> <span class="n">For</span> <span class="n">historical</span> <span class="n">reasons</span><span class="p">,</span> <span class="n">the</span> <span class="n">GOTRACEBACK</span> <span class="n">settings</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="n">and</span> <span class="m">2</span> <span class="n">are</span> <span class="n">synonyms</span> <span class="n">for</span> <span class="n">none</span><span class="p">,</span> <span class="n">all</span><span class="p">,</span> <span class="n">and</span> <span class="n">system</span><span class="p">,</span> <span class="n">respectively.</span> <span class="n">The</span> <span class="n">runtime</span><span class="o">/</span><span class="n">debug</span> <span class="n">package</span><span class="s">&#39;</span><span class="err">s SetTraceback function allows increasing the amount of output at run time, but it cannot reduce the amount below that specified by the environment variable. See &lt;https://golang.org/pkg/runtime/debug/#SetTraceback&gt;.</span>
</code></pre></td></tr></table>
</div>
</div><p>你可以设置 none、all、system、single、crash，历史原因， 你可以可是设置数字0、1、2，分别代表none、all、system。</p>
<h3 id="sigquit">SIGQUIT<a hidden class="anchor" aria-hidden="true" href="#sigquit">#</a></h3>
<p>如果程序没有发生panic,但是程序有问题，&ldquo;假死“不工作，我们想看看哪儿出现了问题，可以给程序发送SIGQUIT信号，也可以输出stack trace信息。</p>
<p>比如下面的程序:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="nf">a</span><span class="p">()</span>
	<span class="nf">m1</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">m1</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">m2</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">m2</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">m3</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">m3</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">a</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>你可以运行 <code>kill -SIGQUIT &lt;pid&gt;</code> 杀死这个程序，程序在退出的时候输出strack trace。</p>
<h3 id="pproflookupgoroutinewriteto">pprof.Lookup(&ldquo;goroutine&rdquo;).WriteTo<a hidden class="anchor" aria-hidden="true" href="#pproflookupgoroutinewriteto">#</a></h3>
<p>可以通过pprof.Lookup(&ldquo;goroutine&rdquo;).WriteTo将所有的goroutine的stack trace都打印出来，如下面的程序：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;runtime/pprof&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="nf">a</span><span class="p">()</span>
	<span class="nf">m1</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">m1</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">m2</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">m2</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">m3</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">m3</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">pprof</span><span class="p">.</span><span class="nf">Lookup</span><span class="p">(</span><span class="s">&#34;goroutine&#34;</span><span class="p">).</span><span class="nf">WriteTo</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">a</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="debugprintstack">debug.PrintStack()<a hidden class="anchor" aria-hidden="true" href="#debugprintstack">#</a></h3>
<p>在程序panic的时候，一般会自动把堆栈打出来，如果你想在程序中获取堆栈信息，可以通过debug.PrintStack()打印出来。比如你在程序中遇到一个Error,但是不期望程序panic,只是想把堆栈信息打印出来以便跟踪调试，你可以使用debug.PrintStack()。</p>
<p>该方法只能输出到标准错误输出的fd上。为了能完整输出栈信息，还精细的做了buf的扩充重试。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;runtime/debug&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="nf">a</span><span class="p">()</span>
	<span class="nf">m1</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">m1</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">m2</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">m2</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">m3</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">m3</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">debug</span><span class="p">.</span><span class="nf">PrintStack</span><span class="p">()</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">a</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// PrintStack prints to standard error the stack trace returned by runtime.Stack.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">PrintStack</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nf">Stack</span><span class="p">())</span>
<span class="p">}</span>

<span class="c1">// Stack returns a formatted stack trace of the goroutine that calls it.
</span><span class="c1">// It calls runtime.Stack with a large enough buffer to capture the entire trace.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Stack</span><span class="p">()</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">Stack</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="nx">buf</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h3 id="runtimestack">runtime.Stack<a hidden class="anchor" aria-hidden="true" href="#runtimestack">#</a></h3>
<p>你可以使用runtime.Stack得到所有的goroutine的stack trace信息，事实上前面debug.PrintStack()也是通过这个方法获得的。</p>
<p>为了更方便的随时的得到应用所有的goroutine的stack trace信息，我们可以监听SIGUSR1信号，当收到这个信号的时候就将stack trace打印出来。发送信号也很简单，通过kill -SIGUSR1 <!-- raw HTML omitted -->就可以，不必担心kill会将程序杀死，它只是发了一个信号而已。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;os/signal&#34;</span>
	<span class="s">&#34;runtime&#34;</span>
	<span class="s">&#34;syscall&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">setupSigusr1Trap</span><span class="p">()</span>
	<span class="k">go</span> <span class="nf">a</span><span class="p">()</span>
	<span class="nf">m1</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">m1</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">m2</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">m2</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">m3</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">m3</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">a</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">setupSigusr1Trap</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Signal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">signal</span><span class="p">.</span><span class="nf">Notify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SIGUSR1</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="k">range</span> <span class="nx">c</span> <span class="p">{</span>
			<span class="nf">DumpStacks</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">DumpStacks</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">16384</span><span class="p">)</span>
	<span class="c1">// 获取 所有goroutine 的 stacktrace
</span><span class="c1"></span>	<span class="nx">buf</span> <span class="p">=</span> <span class="nx">buf</span><span class="p">[:</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">Stack</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="kc">true</span><span class="p">)]</span>
	<span class="c1">// 如果需要获取当前goroutine 的 stacktrace, 第二个参数需要为 `false`
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;=== BEGIN goroutine stack dump ===\n%s\n=== END goroutine stack dump ===&#34;</span><span class="p">,</span> <span class="nx">buf</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>输出结果很直观，方便检查。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="o">==</span><span class="p">=</span> <span class="nx">BEGIN</span> <span class="nx">goroutine</span> <span class="nx">stack</span> <span class="nx">dump</span> <span class="o">==</span><span class="p">=</span>
<span class="nx">goroutine</span> <span class="mi">36</span> <span class="p">[</span><span class="nx">running</span><span class="p">]:</span>
<span class="nx">main</span><span class="p">.</span><span class="nf">DumpStacks</span><span class="p">()</span>
	<span class="o">/</span><span class="nx">Users</span><span class="o">/</span><span class="nx">yuepan</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">smallnest</span><span class="o">/</span><span class="nx">dump</span><span class="o">/</span><span class="nx">d3</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">47</span> <span class="o">+</span><span class="mh">0x77</span>
<span class="nx">main</span><span class="p">.</span><span class="nx">setupSigusr1Trap</span><span class="p">.</span><span class="nf">func1</span><span class="p">(</span><span class="mh">0xc420070060</span><span class="p">)</span>
	<span class="o">/</span><span class="nx">Users</span><span class="o">/</span><span class="nx">yuepan</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">smallnest</span><span class="o">/</span><span class="nx">dump</span><span class="o">/</span><span class="nx">d3</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">40</span> <span class="o">+</span><span class="mh">0x73</span>
<span class="nx">created</span> <span class="nx">by</span> <span class="nx">main</span><span class="p">.</span><span class="nx">setupSigusr1Trap</span>
	<span class="o">/</span><span class="nx">Users</span><span class="o">/</span><span class="nx">yuepan</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">smallnest</span><span class="o">/</span><span class="nx">dump</span><span class="o">/</span><span class="nx">d3</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">42</span> <span class="o">+</span><span class="mh">0xec</span>
<span class="nx">goroutine</span> <span class="mi">1</span> <span class="p">[</span><span class="nx">sleep</span><span class="p">]:</span>
<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mh">0x34630b8a000</span><span class="p">)</span>
	<span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">Cellar</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="mf">1.7.4</span><span class="o">/</span><span class="nx">libexec</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="nx">time</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">59</span> <span class="o">+</span><span class="mh">0xe1</span>
<span class="nx">main</span><span class="p">.</span><span class="nf">m3</span><span class="p">()</span>
	<span class="o">/</span><span class="nx">Users</span><span class="o">/</span><span class="nx">yuepan</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">smallnest</span><span class="o">/</span><span class="nx">dump</span><span class="o">/</span><span class="nx">d3</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">28</span> <span class="o">+</span><span class="mh">0x30</span>
<span class="nx">main</span><span class="p">.</span><span class="nf">m2</span><span class="p">()</span>
	<span class="o">/</span><span class="nx">Users</span><span class="o">/</span><span class="nx">yuepan</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">smallnest</span><span class="o">/</span><span class="nx">dump</span><span class="o">/</span><span class="nx">d3</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">24</span> <span class="o">+</span><span class="mh">0x14</span>
<span class="nx">main</span><span class="p">.</span><span class="nf">m1</span><span class="p">()</span>
	<span class="o">/</span><span class="nx">Users</span><span class="o">/</span><span class="nx">yuepan</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">smallnest</span><span class="o">/</span><span class="nx">dump</span><span class="o">/</span><span class="nx">d3</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">20</span> <span class="o">+</span><span class="mh">0x14</span>
<span class="nx">main</span><span class="p">.</span><span class="nf">main</span><span class="p">()</span>
	<span class="o">/</span><span class="nx">Users</span><span class="o">/</span><span class="nx">yuepan</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">smallnest</span><span class="o">/</span><span class="nx">dump</span><span class="o">/</span><span class="nx">d3</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">16</span> <span class="o">+</span><span class="mh">0x3f</span>
<span class="nx">goroutine</span> <span class="mi">34</span> <span class="p">[</span><span class="nx">syscall</span><span class="p">]:</span>
<span class="nx">os</span><span class="o">/</span><span class="nx">signal</span><span class="p">.</span><span class="nf">signal_recv</span><span class="p">(</span><span class="mh">0xff280</span><span class="p">)</span>
	<span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">Cellar</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="mf">1.7.4</span><span class="o">/</span><span class="nx">libexec</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="nx">sigqueue</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">116</span> <span class="o">+</span><span class="mh">0x157</span>
<span class="nx">os</span><span class="o">/</span><span class="nx">signal</span><span class="p">.</span><span class="nf">loop</span><span class="p">()</span>
	<span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">Cellar</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="mf">1.7.4</span><span class="o">/</span><span class="nx">libexec</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">os</span><span class="o">/</span><span class="nx">signal</span><span class="o">/</span><span class="nx">signal_unix</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">22</span> <span class="o">+</span><span class="mh">0x22</span>
<span class="nx">created</span> <span class="nx">by</span> <span class="nx">os</span><span class="o">/</span><span class="nx">signal</span><span class="p">.</span><span class="nx">init</span><span class="mf">.1</span>
	<span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">Cellar</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="mf">1.7.4</span><span class="o">/</span><span class="nx">libexec</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">os</span><span class="o">/</span><span class="nx">signal</span><span class="o">/</span><span class="nx">signal_unix</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">28</span> <span class="o">+</span><span class="mh">0x41</span>
<span class="nx">goroutine</span> <span class="mi">35</span> <span class="p">[</span><span class="k">select</span><span class="p">,</span> <span class="nx">locked</span> <span class="nx">to</span> <span class="nx">thread</span><span class="p">]:</span>
<span class="nx">runtime</span><span class="p">.</span><span class="nf">gopark</span><span class="p">(</span><span class="mh">0xb5cc8</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0xab3ef</span><span class="p">,</span> <span class="mh">0x6</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">,</span> <span class="mh">0x2</span><span class="p">)</span>
	<span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">Cellar</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="mf">1.7.4</span><span class="o">/</span><span class="nx">libexec</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="nx">proc</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">259</span> <span class="o">+</span><span class="mh">0x13a</span>
<span class="nx">runtime</span><span class="p">.</span><span class="nf">selectgoImpl</span><span class="p">(</span><span class="mh">0xc42008d730</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">)</span>
	<span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">Cellar</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="mf">1.7.4</span><span class="o">/</span><span class="nx">libexec</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="k">select</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">423</span> <span class="o">+</span><span class="mh">0x11d9</span>
<span class="nx">runtime</span><span class="p">.</span><span class="nf">selectgo</span><span class="p">(</span><span class="mh">0xc42008d730</span><span class="p">)</span>
	<span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">Cellar</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="mf">1.7.4</span><span class="o">/</span><span class="nx">libexec</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="k">select</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">238</span> <span class="o">+</span><span class="mh">0x1c</span>
<span class="nx">runtime</span><span class="p">.</span><span class="nx">ensureSigM</span><span class="p">.</span><span class="nf">func1</span><span class="p">()</span>
	<span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">Cellar</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="mf">1.7.4</span><span class="o">/</span><span class="nx">libexec</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="nx">signal1_unix</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">304</span> <span class="o">+</span><span class="mh">0x2d1</span>
<span class="nx">runtime</span><span class="p">.</span><span class="nf">goexit</span><span class="p">()</span>
	<span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">Cellar</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="mf">1.7.4</span><span class="o">/</span><span class="nx">libexec</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="nx">asm_amd64</span><span class="p">.</span><span class="nx">s</span><span class="p">:</span><span class="mi">2086</span> <span class="o">+</span><span class="mh">0x1</span>
<span class="nx">goroutine</span> <span class="mi">37</span> <span class="p">[</span><span class="nx">sleep</span><span class="p">]:</span>
<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mh">0x34630b8a000</span><span class="p">)</span>
	<span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">Cellar</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="mf">1.7.4</span><span class="o">/</span><span class="nx">libexec</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="nx">time</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">59</span> <span class="o">+</span><span class="mh">0xe1</span>
<span class="nx">main</span><span class="p">.</span><span class="nf">a</span><span class="p">()</span>
	<span class="o">/</span><span class="nx">Users</span><span class="o">/</span><span class="nx">yuepan</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">smallnest</span><span class="o">/</span><span class="nx">dump</span><span class="o">/</span><span class="nx">d3</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">32</span> <span class="o">+</span><span class="mh">0x30</span>
<span class="nx">created</span> <span class="nx">by</span> <span class="nx">main</span><span class="p">.</span><span class="nx">main</span>
	<span class="o">/</span><span class="nx">Users</span><span class="o">/</span><span class="nx">yuepan</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">smallnest</span><span class="o">/</span><span class="nx">dump</span><span class="o">/</span><span class="nx">d3</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">15</span> <span class="o">+</span><span class="mh">0x3a</span>
<span class="o">==</span><span class="p">=</span> <span class="nx">END</span> <span class="nx">goroutine</span> <span class="nx">stack</span> <span class="nx">dump</span> <span class="o">==</span><span class="p">=</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Stack formats a stack trace of the calling goroutine into buf
</span><span class="c1">// and returns the number of bytes written to buf.
</span><span class="c1">// If all is true, Stack formats stack traces of all other goroutines
</span><span class="c1">// into buf after the trace for the current goroutine.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Stack</span><span class="p">(</span><span class="nx">buf</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">all</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">all</span> <span class="p">{</span>
		<span class="nf">stopTheWorld</span><span class="p">(</span><span class="s">&#34;stack trace&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
		<span class="nx">sp</span> <span class="o">:=</span> <span class="nf">getcallersp</span><span class="p">()</span>
		<span class="nx">pc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">g0</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
			<span class="c1">// Force traceback=1 to override GOTRACEBACK setting,
</span><span class="c1"></span>			<span class="c1">// so that Stack&#39;s results are consistent.
</span><span class="c1"></span>			<span class="c1">// GOTRACEBACK is only about crash dumps.
</span><span class="c1"></span>			<span class="nx">g0</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">traceback</span> <span class="p">=</span> <span class="mi">1</span>
			<span class="nx">g0</span><span class="p">.</span><span class="nx">writebuf</span> <span class="p">=</span> <span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)]</span>
			<span class="nf">goroutineheader</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
			<span class="nf">traceback</span><span class="p">(</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">gp</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">all</span> <span class="p">{</span>
				<span class="nf">tracebackothers</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">g0</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">traceback</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">n</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">g0</span><span class="p">.</span><span class="nx">writebuf</span><span class="p">)</span>
			<span class="nx">g0</span><span class="p">.</span><span class="nx">writebuf</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">})</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">all</span> <span class="p">{</span>
		<span class="nf">startTheWorld</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当all=false时，只会获取当前协程的函数调用栈信息，无需加锁。但all=true时，意味着要获取所有协程的栈信息，在go runtime的pmg调度模型下，为了保证并发操作安全，自然就需要在stack方法里加了锁，且锁的粒度还不小，直接调用stopTheWorld用来阻塞GC的操作。</p>
<p>goroutineheader方法用来获取协程的状态信息，比如等待锁，scan，已等待时间等。allgs是runtime保存的所有已创建协程的容器，当然不会去追踪已经消亡的协程。另外，为了保护allgs切片的安全，还会对allglock加锁，在allgadd()创建goroutine和checkdead()检测死锁里会产生锁竞争。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">goroutineheader</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">gpstatus</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>

	<span class="nx">isScan</span> <span class="o">:=</span> <span class="nx">gpstatus</span><span class="o">&amp;</span><span class="nx">_Gscan</span> <span class="o">!=</span> <span class="mi">0</span>
	<span class="nx">gpstatus</span> <span class="o">&amp;^=</span> <span class="nx">_Gscan</span> <span class="c1">// drop the scan bit
</span><span class="c1"></span>
	<span class="c1">// Basic string status
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">status</span> <span class="kt">string</span>
	<span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="nx">gpstatus</span> <span class="o">&amp;&amp;</span> <span class="nx">gpstatus</span> <span class="p">&lt;</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">gStatusStrings</span><span class="p">))</span> <span class="p">{</span>
		<span class="nx">status</span> <span class="p">=</span> <span class="nx">gStatusStrings</span><span class="p">[</span><span class="nx">gpstatus</span><span class="p">]</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">status</span> <span class="p">=</span> <span class="s">&#34;???&#34;</span>
	<span class="p">}</span>

	<span class="c1">// Override.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gpstatus</span> <span class="o">==</span> <span class="nx">_Gwaiting</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waitreason</span> <span class="o">!=</span> <span class="nx">waitReasonZero</span> <span class="p">{</span>
		<span class="nx">status</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waitreason</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// approx time the G is blocked, in minutes
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">waitfor</span> <span class="kt">int64</span>
	<span class="k">if</span> <span class="p">(</span><span class="nx">gpstatus</span> <span class="o">==</span> <span class="nx">_Gwaiting</span> <span class="o">||</span> <span class="nx">gpstatus</span> <span class="o">==</span> <span class="nx">_Gsyscall</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waitsince</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">waitfor</span> <span class="p">=</span> <span class="p">(</span><span class="nf">nanotime</span><span class="p">()</span> <span class="o">-</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waitsince</span><span class="p">)</span> <span class="o">/</span> <span class="mf">60e9</span>
	<span class="p">}</span>
	<span class="nb">print</span><span class="p">(</span><span class="s">&#34;goroutine &#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">goid</span><span class="p">,</span> <span class="s">&#34; [&#34;</span><span class="p">,</span> <span class="nx">status</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">isScan</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34; (scan)&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">waitfor</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;, &#34;</span><span class="p">,</span> <span class="nx">waitfor</span><span class="p">,</span> <span class="s">&#34; minutes&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">lockedm</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;, locked to thread&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nb">print</span><span class="p">(</span><span class="s">&#34;]:\n&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="httppprof">http/pprof<a hidden class="anchor" aria-hidden="true" href="#httppprof">#</a></h3>
<p>如果你的代码中配置了 http/pprof,你可以通过下面的地址访问所有的groutine的堆栈：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">&lt;</span><span class="n">http</span><span class="o">://</span><span class="n">localhost</span><span class="o">:</span><span class="m">8888</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">pprof</span><span class="o">/</span><span class="n">goroutine</span><span class="o">?</span><span class="n">debug</span><span class="o">=</span><span class="m">2</span><span class="o">&gt;</span><span class="n">.
</span></code></pre></td></tr></table>
</div>
</div><h2 id="更可控的调用信息">更可控的调用信息<a hidden class="anchor" aria-hidden="true" href="#更可控的调用信息">#</a></h2>
<p>上面的函数虽然可以获取调用栈，但是直接将所有调用信息返回，控制参数较少。</p>
<p>下面几个函数可以实现获取单层的调用信息。</p>
<h3 id="runtimecaller">runtime.Caller<a hidden class="anchor" aria-hidden="true" href="#runtimecaller">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">runtime</span><span class="p">.</span><span class="nf">Caller</span><span class="p">(</span><span class="nx">skip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">pc</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">file</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">line</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime.Caller 返回当前 goroutine 的栈上的函数调用信息. 主要有当前的pc 值和调用的文件和行号等信息.</p>
<ul>
<li>参数skip：表示跳过的层级，相当于往上获取第几层的调用者。若为 0 则表示 runtime.Caller 的调用者。1 代表上一层调用者，以此类推。</li>
<li>返回值
<ul>
<li>pc：program counter，可以大概理解为函数编号，可以通过runtime.FuncForPC解析.</li>
<li>file：文件名</li>
<li>line：行号</li>
<li>ok:若无法获得信息, 返回的 ok 值为 false.</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">Foo</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">Foo</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;我是 %s, %s 在调用我!\n&#34;</span><span class="p">,</span> <span class="nf">printMyName</span><span class="p">(),</span> <span class="nf">printCallerName</span><span class="p">())</span>
	<span class="nf">Bar</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">Bar</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;我是 %s, %s 又在调用我!\n&#34;</span><span class="p">,</span> <span class="nf">printMyName</span><span class="p">(),</span> <span class="nf">printCallerName</span><span class="p">())</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">printMyName</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">pc</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">Caller</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">FuncForPC</span><span class="p">(</span><span class="nx">pc</span><span class="p">).</span><span class="nf">Name</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">printCallerName</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">pc</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">Caller</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">FuncForPC</span><span class="p">(</span><span class="nx">pc</span><span class="p">).</span><span class="nf">Name</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以得到这样一条输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s">我是 <span class="n">main.Foo</span><span class="p">,</span> 谁在调用我<span class="o">?</span>
我是 <span class="n">main.Bar</span><span class="p">,</span> 谁又在调用我<span class="o">?</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="runtimecallers">runtime.Callers<a hidden class="anchor" aria-hidden="true" href="#runtimecallers">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">runtime</span><span class="p">.</span><span class="nf">Callers</span><span class="p">(</span><span class="nx">skip</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">pc</span> <span class="p">[]</span><span class="kt">uintptr</span><span class="p">)</span> <span class="kt">int</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime.Callers 把调用它的函数Go程栈上的程序计数器填入切片 pc 中. 参数 skip 为开始在 pc 中记录之前所要跳过的栈帧数, 若为 0 则表示 runtime.Callers 自身的栈帧, 若为 1 则表示调用者的栈帧. 该函数返回写入到 pc 切片中的项数(受切片的容量限制).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="err">……</span>
<span class="kd">func</span> <span class="nf">Bar</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;我是 %s, %s 又在调用我!\n&#34;</span><span class="p">,</span> <span class="nf">printMyName</span><span class="p">(),</span> <span class="nf">printCallerName</span><span class="p">())</span>
	<span class="nf">trace</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">trace</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">pc</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">uintptr</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">// at least 1 entry needed
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">Callers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">f</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">FuncForPC</span><span class="p">(</span><span class="nx">pc</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="nx">file</span><span class="p">,</span> <span class="nx">line</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nf">FileLine</span><span class="p">(</span><span class="nx">pc</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s:%d %s\n&#34;</span><span class="p">,</span> <span class="nx">file</span><span class="p">,</span> <span class="nx">line</span><span class="p">,</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Name</span><span class="p">())</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>输出结果可以看到这个goroutine的整个栈都打印出来了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">extern.go</span><span class="o">:</span><span class="m">218</span> <span class="n">runtime.Callers</span>
<span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">yuepan</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">git.intra.weibo.com</span><span class="o">/</span><span class="n">platform</span><span class="o">/</span><span class="n">tool</span><span class="o">/</span><span class="n">g</span><span class="o">/</span><span class="n">main.go</span><span class="o">:</span><span class="m">34</span> <span class="n">main.trace</span>
<span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">yuepan</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">git.intra.weibo.com</span><span class="o">/</span><span class="n">platform</span><span class="o">/</span><span class="n">tool</span><span class="o">/</span><span class="n">g</span><span class="o">/</span><span class="n">main.go</span><span class="o">:</span><span class="m">20</span> <span class="n">main.Bar</span>
<span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">yuepan</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">git.intra.weibo.com</span><span class="o">/</span><span class="n">platform</span><span class="o">/</span><span class="n">tool</span><span class="o">/</span><span class="n">g</span><span class="o">/</span><span class="n">main.go</span><span class="o">:</span><span class="m">15</span> <span class="n">main.Foo</span>
<span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">yuepan</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">git.intra.weibo.com</span><span class="o">/</span><span class="n">platform</span><span class="o">/</span><span class="n">tool</span><span class="o">/</span><span class="n">g</span><span class="o">/</span><span class="n">main.go</span><span class="o">:</span><span class="m">10</span> <span class="n">main.main</span>
<span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">proc.go</span><span class="o">:</span><span class="m">210</span> <span class="n">runtime.main</span>
<span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">asm_amd64.s</span><span class="o">:</span><span class="m">1334</span> <span class="n">runtime.goexit</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="runtimefuncforpc">runtime.FuncForPC<a hidden class="anchor" aria-hidden="true" href="#runtimefuncforpc">#</a></h3>
<p>FuncForPC 是一个有趣的函数， 它可以把程序计数器地址对应的函数的信息获取出来。如果因为内联程序计数器对应多个函数，它返回最外面的函数。</p>
<p>它的返回值是一个<em>Func类型的值，通过</em>Func可以获得函数地址、文件行、函数名等信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">FuncForPC</span><span class="p">(</span><span class="nx">pc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="o">*</span><span class="nx">runtime</span><span class="p">.</span><span class="nx">Func</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">runtime</span><span class="p">.</span><span class="nx">Func</span><span class="p">)</span> <span class="nf">FileLine</span><span class="p">(</span><span class="nx">pc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">(</span><span class="nx">file</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">line</span> <span class="kt">int</span><span class="p">)</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">runtime</span><span class="p">.</span><span class="nx">Func</span><span class="p">)</span> <span class="nf">Entry</span><span class="p">()</span> <span class="kt">uintptr</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">runtime</span><span class="p">.</span><span class="nx">Func</span><span class="p">)</span> <span class="nf">Name</span><span class="p">()</span> <span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><p>其中 runtime.FuncForPC 返回包含给定 pc 地址的函数, 如果是无效 pc 则返回 nil .</p>
<p>runtime.Func.FileLine 返回与 pc 对应的源码文件名和行号. 如果pc不在函数帧范围内, 则结果是不确定的.</p>
<p>runtime.Func.Entry 对应函数的地址. runtime.Func.Name 返回该函数的名称.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">skip</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="nx">skip</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">pc</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">Caller</span><span class="p">(</span><span class="nx">skip</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">FuncForPC</span><span class="p">(</span><span class="nx">pc</span><span class="p">)</span>
		<span class="nx">file</span><span class="p">,</span> <span class="nx">line</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">FileLine</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;skip = %v, pc = %v\n&#34;</span><span class="p">,</span> <span class="nx">skip</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;  file = %v, line = %d\n&#34;</span><span class="p">,</span> <span class="nx">file</span><span class="p">,</span> <span class="nx">line</span><span class="p">)</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;  entry = %v\n&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Entry</span><span class="p">())</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;  name = %v\n&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Name</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="c1">// Output:
</span><span class="c1"></span>	<span class="c1">// skip = 0, pc = 4198456
</span><span class="c1"></span>	<span class="c1">//   file = caller.go, line = 8
</span><span class="c1"></span>	<span class="c1">//   entry = 4198400
</span><span class="c1"></span>	<span class="c1">//   name = main.main
</span><span class="c1"></span>	<span class="c1">// skip = 1, pc = 4282882
</span><span class="c1"></span>	<span class="c1">//   file = $(GOROOT)/src/pkg/runtime/proc.c, line = 179
</span><span class="c1"></span>	<span class="c1">//   entry = 4282576
</span><span class="c1"></span>	<span class="c1">//   name = runtime.main
</span><span class="c1"></span>	<span class="c1">// skip = 2, pc = 4292528
</span><span class="c1"></span>	<span class="c1">//   file = $(GOROOT)/src/pkg/runtime/proc.c, line = 1394
</span><span class="c1"></span>	<span class="c1">//   entry = 4292528
</span><span class="c1"></span>	<span class="c1">//   name = runtime.goexit
</span><span class="c1"></span>	<span class="nx">pc</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">uintptr</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">skip</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="nx">skip</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">Callers</span><span class="p">(</span><span class="nx">skip</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;skip = %v, pc = %v\n&#34;</span><span class="p">,</span> <span class="nx">skip</span><span class="p">,</span> <span class="nx">pc</span><span class="p">[:</span><span class="nx">n</span><span class="p">])</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">p</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">FuncForPC</span><span class="p">(</span><span class="nx">pc</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span>
			<span class="nx">file</span><span class="p">,</span> <span class="nx">line</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">FileLine</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;  skip = %v, pc = %v\n&#34;</span><span class="p">,</span> <span class="nx">skip</span><span class="p">,</span> <span class="nx">pc</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;    file = %v, line = %d\n&#34;</span><span class="p">,</span> <span class="nx">file</span><span class="p">,</span> <span class="nx">line</span><span class="p">)</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;    entry = %v\n&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Entry</span><span class="p">())</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;    name = %v\n&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Name</span><span class="p">())</span>
		<span class="p">}</span>
		<span class="k">break</span>
	<span class="p">}</span>
	<span class="c1">// Output:
</span><span class="c1"></span>	<span class="c1">// skip = 0, pc = [4307254 4198586 4282882 4292528]
</span><span class="c1"></span>	<span class="c1">//   skip = 0, pc = 4307254
</span><span class="c1"></span>	<span class="c1">//     file = $(GOROOT)/src/pkg/runtime/runtime.c, line = 315
</span><span class="c1"></span>	<span class="c1">//     entry = 4307168
</span><span class="c1"></span>	<span class="c1">//     name = runtime.Callers
</span><span class="c1"></span>	<span class="c1">//   skip = 0, pc = 4198586
</span><span class="c1"></span>	<span class="c1">//     file = caller.go, line = 8
</span><span class="c1"></span>	<span class="c1">//     entry = 4198400
</span><span class="c1"></span>	<span class="c1">//     name = main.main
</span><span class="c1"></span>	<span class="c1">//   skip = 0, pc = 4282882
</span><span class="c1"></span>	<span class="c1">//     file = $(GOROOT)/src/pkg/runtime/proc.c, line = 179
</span><span class="c1"></span>	<span class="c1">//     entry = 4282576
</span><span class="c1"></span>	<span class="c1">//     name = runtime.main
</span><span class="c1"></span>	<span class="c1">//   skip = 0, pc = 4292528
</span><span class="c1"></span>	<span class="c1">//     file = $(GOROOT)/src/pkg/runtime/proc.c, line = 1394
</span><span class="c1"></span>	<span class="c1">//     entry = 4292528
</span><span class="c1"></span>	<span class="c1">//     name = runtime.goexit
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>除了上面获取程序计数器的方式，也可以通过反射的方式获取函数的地址：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">runtime</span><span class="p">.</span><span class="nf">FuncForPC</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">foo</span><span class="p">).</span><span class="nf">Pointer</span><span class="p">()).</span><span class="nf">Name</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="runtimecallersframes">runtime.CallersFrames<a hidden class="anchor" aria-hidden="true" href="#runtimecallersframes">#</a></h3>
<p>上面的Callers只是或者栈的程序计数器，如果想获得整个栈的信息，可以使用CallersFrames函数，省去遍历调用FuncForPC。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">runtime</span><span class="p">.</span><span class="nf">CallersFrames</span><span class="p">(</span><span class="nx">callers</span> <span class="p">[]</span><span class="kt">uintptr</span><span class="p">)</span> <span class="o">*</span><span class="nx">runtime</span><span class="p">.</span><span class="nx">Frames</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime.CallersFrames可以一次解析多个pc</p>
<p>上面的trace函数可以更改为下面的方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">trace2</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">pc</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">uintptr</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">// at least 1 entry needed
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">Callers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
	<span class="nx">frames</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">CallersFrames</span><span class="p">(</span><span class="nx">pc</span><span class="p">[:</span><span class="nx">n</span><span class="p">])</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">frame</span><span class="p">,</span> <span class="nx">more</span> <span class="o">:=</span> <span class="nx">frames</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s:%d %s\n&#34;</span><span class="p">,</span> <span class="nx">frame</span><span class="p">.</span><span class="nx">File</span><span class="p">,</span> <span class="nx">frame</span><span class="p">.</span><span class="nx">Line</span><span class="p">,</span> <span class="nx">frame</span><span class="p">.</span><span class="nx">Function</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">more</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="获取goroutine的id">获取goroutine的id<a hidden class="anchor" aria-hidden="true" href="#获取goroutine的id">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GoID</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">buf</span> <span class="p">[</span><span class="mi">64</span><span class="p">]</span><span class="kt">byte</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">Stack</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:],</span> <span class="kc">false</span><span class="p">)</span>
	<span class="nx">idField</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Fields</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">TrimPrefix</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">]),</span> <span class="s">&#34;goroutine &#34;</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">id</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">idField</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;cannot get goroutine id: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">id</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="打印堆栈的性能问题">打印堆栈的性能问题<a hidden class="anchor" aria-hidden="true" href="#打印堆栈的性能问题">#</a></h2>
<h3 id="背景">背景<a hidden class="anchor" aria-hidden="true" href="#背景">#</a></h3>
<p>runtime.Caller能够拿到当前执行的文件名和行号，这个方法几乎所有的日志组件里都有使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Caller</span><span class="p">(</span><span class="nx">skip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">pc</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">file</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">line</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><p>但是问题也很明显，这个函数开销太大。跟了一下代码实现，发现主要就是不停地迭代，而这个迭代过程虽然单次消耗的时间可以忽略不计，但是对于日志量巨大的服务而言影响还是很大的。详情参见下面的代码</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201214142832.png" alt=""  />
</p>
<h3 id="解决方案">解决方案<a hidden class="anchor" aria-hidden="true" href="#解决方案">#</a></h3>
<p>网上了解了一下，目前没有找到不使用runtime包获取执行文件和行号的解决方案。既然官方的包很难有优化空间，那可以考虑一下业务侧有什么解决方案。于是查了一些github上比较知名的项目，学习了一下。</p>
<h4 id="标准库log">标准库log<a hidden class="anchor" aria-hidden="true" href="#标准库log">#</a></h4>
<p>官方写的日志组件，在log包里的，值得参考一下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Output writes the output for a logging event. The string s contains
</span><span class="c1">// the text to print after the prefix specified by the flags of the
</span><span class="c1">// Logger. A newline is appended if the last character of s is not
</span><span class="c1">// already a newline. Calldepth is used to recover the PC and is
</span><span class="c1">// provided for generality, although at the moment on all pre-defined
</span><span class="c1">// paths it will be 2.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">Output</span><span class="p">(</span><span class="nx">calldepth</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">now</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span> <span class="c1">// get this early.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">file</span> <span class="kt">string</span>
	<span class="kd">var</span> <span class="nx">line</span> <span class="kt">int</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">l</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">flag</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">Lshortfile</span><span class="p">|</span><span class="nx">Llongfile</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Release lock while getting caller info - it&#39;s expensive.
</span><span class="c1"></span>		<span class="nx">l</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="kd">var</span> <span class="nx">ok</span> <span class="kt">bool</span>
		<span class="nx">_</span><span class="p">,</span> <span class="nx">file</span><span class="p">,</span> <span class="nx">line</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">Caller</span><span class="p">(</span><span class="nx">calldepth</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">file</span> <span class="p">=</span> <span class="s">&#34;???&#34;</span>
			<span class="nx">line</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">buf</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">l</span><span class="p">.</span><span class="nf">formatHeader</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">now</span><span class="p">,</span> <span class="nx">file</span><span class="p">,</span> <span class="nx">line</span><span class="p">)</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">s</span><span class="o">...</span><span class="p">)</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">s</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">buf</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">out</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注释里说明官方也是知道runtime.Caller性能有问题。这里的Logger里带有一个Mutex锁，方便在高并发或者多协程的时候保护上下文数据一致。</p>
<p>这里值得借鉴的是并没有所有的日志都记录文件名和行号，而是添加了标记位flag，只有在需要的业务场景下(Lshortfile或者Llongfile )，才调用runtime.Caller，避免不必要的开支。</p>
<p>另外一方面，在调用性能比较差的runtime.Caller之前，把锁释放，执行完毕后再把锁加上，继续处理自己后续的业务。这个可以避免锁的时间过长，影响其他业务。</p>
<h4 id="zap">zap<a hidden class="anchor" aria-hidden="true" href="#zap">#</a></h4>
<p>看一下实现行号和文件名的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">log</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">check</span><span class="p">(</span><span class="nx">lvl</span> <span class="nx">zapcore</span><span class="p">.</span><span class="nx">Level</span><span class="p">,</span> <span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">zapcore</span><span class="p">.</span><span class="nx">CheckedEntry</span> <span class="p">{</span>
	<span class="c1">// check must always be called directly by a method in the Logger interface
</span><span class="c1"></span>	<span class="c1">// (e.g., Check, Info, Fatal).
</span><span class="c1"></span>	<span class="kd">const</span> <span class="nx">callerSkipOffset</span> <span class="p">=</span> <span class="mi">2</span>

	<span class="c1">// Check the level first to reduce the cost of disabled log calls.
</span><span class="c1"></span>	<span class="c1">// Since Panic and higher may exit, we skip the optimization for those levels.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">lvl</span> <span class="p">&lt;</span> <span class="nx">zapcore</span><span class="p">.</span><span class="nx">DPanicLevel</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">log</span><span class="p">.</span><span class="nx">core</span><span class="p">.</span><span class="nf">Enabled</span><span class="p">(</span><span class="nx">lvl</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="c1">// Create basic checked entry thru the core; this will be non-nil if the
</span><span class="c1"></span>	<span class="c1">// log message will actually be written somewhere.
</span><span class="c1"></span>	<span class="nx">ent</span> <span class="o">:=</span> <span class="nx">zapcore</span><span class="p">.</span><span class="nx">Entry</span><span class="p">{</span>
		<span class="nx">LoggerName</span><span class="p">:</span> <span class="nx">log</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span>
		<span class="nx">Time</span><span class="p">:</span>       <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">(),</span>
		<span class="nx">Level</span><span class="p">:</span>      <span class="nx">lvl</span><span class="p">,</span>
		<span class="nx">Message</span><span class="p">:</span>    <span class="nx">msg</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">ce</span> <span class="o">:=</span> <span class="nx">log</span><span class="p">.</span><span class="nx">core</span><span class="p">.</span><span class="nf">Check</span><span class="p">(</span><span class="nx">ent</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="nx">willWrite</span> <span class="o">:=</span> <span class="nx">ce</span> <span class="o">!=</span> <span class="kc">nil</span>

	<span class="c1">// Set up any required terminal behavior.
</span><span class="c1"></span>	<span class="k">switch</span> <span class="nx">ent</span><span class="p">.</span><span class="nx">Level</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">zapcore</span><span class="p">.</span><span class="nx">PanicLevel</span><span class="p">:</span>
		<span class="nx">ce</span> <span class="p">=</span> <span class="nx">ce</span><span class="p">.</span><span class="nf">Should</span><span class="p">(</span><span class="nx">ent</span><span class="p">,</span> <span class="nx">zapcore</span><span class="p">.</span><span class="nx">WriteThenPanic</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">zapcore</span><span class="p">.</span><span class="nx">FatalLevel</span><span class="p">:</span>
		<span class="nx">onFatal</span> <span class="o">:=</span> <span class="nx">log</span><span class="p">.</span><span class="nx">onFatal</span>
		<span class="c1">// Noop is the default value for CheckWriteAction, and it leads to
</span><span class="c1"></span>		<span class="c1">// continued execution after a Fatal which is unexpected.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">onFatal</span> <span class="o">==</span> <span class="nx">zapcore</span><span class="p">.</span><span class="nx">WriteThenNoop</span> <span class="p">{</span>
			<span class="nx">onFatal</span> <span class="p">=</span> <span class="nx">zapcore</span><span class="p">.</span><span class="nx">WriteThenFatal</span>
		<span class="p">}</span>
		<span class="nx">ce</span> <span class="p">=</span> <span class="nx">ce</span><span class="p">.</span><span class="nf">Should</span><span class="p">(</span><span class="nx">ent</span><span class="p">,</span> <span class="nx">onFatal</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">zapcore</span><span class="p">.</span><span class="nx">DPanicLevel</span><span class="p">:</span>
		<span class="k">if</span> <span class="nx">log</span><span class="p">.</span><span class="nx">development</span> <span class="p">{</span>
			<span class="nx">ce</span> <span class="p">=</span> <span class="nx">ce</span><span class="p">.</span><span class="nf">Should</span><span class="p">(</span><span class="nx">ent</span><span class="p">,</span> <span class="nx">zapcore</span><span class="p">.</span><span class="nx">WriteThenPanic</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Only do further annotation if we&#39;re going to write this message; checked
</span><span class="c1"></span>	<span class="c1">// entries that exist only for terminal behavior don&#39;t benefit from
</span><span class="c1"></span>	<span class="c1">// annotation.
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">willWrite</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ce</span>
	<span class="p">}</span>

	<span class="c1">// Thread the error output through to the CheckedEntry.
</span><span class="c1"></span>	<span class="nx">ce</span><span class="p">.</span><span class="nx">ErrorOutput</span> <span class="p">=</span> <span class="nx">log</span><span class="p">.</span><span class="nx">errorOutput</span>
	<span class="k">if</span> <span class="nx">log</span><span class="p">.</span><span class="nx">addCaller</span> <span class="p">{</span>
		<span class="nx">frame</span><span class="p">,</span> <span class="nx">defined</span> <span class="o">:=</span> <span class="nf">getCallerFrame</span><span class="p">(</span><span class="nx">log</span><span class="p">.</span><span class="nx">callerSkip</span> <span class="o">+</span> <span class="nx">callerSkipOffset</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">defined</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">log</span><span class="p">.</span><span class="nx">errorOutput</span><span class="p">,</span> <span class="s">&#34;%v Logger.check error: failed to get caller\n&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UTC</span><span class="p">())</span>
			<span class="nx">log</span><span class="p">.</span><span class="nx">errorOutput</span><span class="p">.</span><span class="nf">Sync</span><span class="p">()</span>
		<span class="p">}</span>

		<span class="nx">ce</span><span class="p">.</span><span class="nx">Entry</span><span class="p">.</span><span class="nx">Caller</span> <span class="p">=</span> <span class="nx">zapcore</span><span class="p">.</span><span class="nx">EntryCaller</span><span class="p">{</span>
			<span class="nx">Defined</span><span class="p">:</span>  <span class="nx">defined</span><span class="p">,</span>
			<span class="nx">PC</span><span class="p">:</span>       <span class="nx">frame</span><span class="p">.</span><span class="nx">PC</span><span class="p">,</span>
			<span class="nx">File</span><span class="p">:</span>     <span class="nx">frame</span><span class="p">.</span><span class="nx">File</span><span class="p">,</span>
			<span class="nx">Line</span><span class="p">:</span>     <span class="nx">frame</span><span class="p">.</span><span class="nx">Line</span><span class="p">,</span>
			<span class="nx">Function</span><span class="p">:</span> <span class="nx">frame</span><span class="p">.</span><span class="nx">Function</span><span class="p">,</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">log</span><span class="p">.</span><span class="nx">addStack</span><span class="p">.</span><span class="nf">Enabled</span><span class="p">(</span><span class="nx">ce</span><span class="p">.</span><span class="nx">Entry</span><span class="p">.</span><span class="nx">Level</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">ce</span><span class="p">.</span><span class="nx">Entry</span><span class="p">.</span><span class="nx">Stack</span> <span class="p">=</span> <span class="nf">StackSkip</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">log</span><span class="p">.</span><span class="nx">callerSkip</span><span class="o">+</span><span class="nx">callerSkipOffset</span><span class="p">).</span><span class="nx">String</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">ce</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>它们将Caller信息放在CallerEntry.Entry.Caller结构里，并且和google类似，提供了标记位(addCaller)，只有在需要的场景下才会调用runtime.Caller.</p>
<p>值得一提的是，zap提供了Sugar和Desugar的模式，所谓Sugar就是提供程序员更友好方便的日志记录方式，但是牺牲了部分性能，核心就是Caller的skipCaller+2。Desugar就是个逆向的过程，可以将Sugared的结构再次回退到性能较高的原始模式，核心是Caller的callerSkip-2。两者可以在代码里面共同存在使用。</p>
<p>Sugar和Desuagr的实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go.uber.org/zap/logger.go#L126
</span><span class="c1"></span>
<span class="c1">// Sugar wraps the Logger to provide a more ergonomic, but slightly slower,
</span><span class="c1">// API. Sugaring a Logger is quite inexpensive, so it&#39;s reasonable for a
</span><span class="c1">// single application to use both Loggers and SugaredLoggers, converting
</span><span class="c1">// between them on the boundaries of performance-sensitive code.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">log</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">Sugar</span><span class="p">()</span> <span class="o">*</span><span class="nx">SugaredLogger</span> <span class="p">{</span>
	<span class="nx">core</span> <span class="o">:=</span> <span class="nx">log</span><span class="p">.</span><span class="nf">clone</span><span class="p">()</span>
	<span class="nx">core</span><span class="p">.</span><span class="nx">callerSkip</span> <span class="o">+=</span> <span class="mi">2</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">SugaredLogger</span><span class="p">{</span><span class="nx">core</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Desugar unwraps a SugaredLogger, exposing the original Logger. Desugaring
</span><span class="c1">// is quite inexpensive, so it&#39;s reasonable for a single application to use
</span><span class="c1">// both Loggers and SugaredLoggers, converting between them on the boundaries
</span><span class="c1">// of performance-sensitive code.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">SugaredLogger</span><span class="p">)</span> <span class="nf">Desugar</span><span class="p">()</span> <span class="o">*</span><span class="nx">Logger</span> <span class="p">{</span>
	<span class="nx">base</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">base</span><span class="p">.</span><span class="nf">clone</span><span class="p">()</span>
	<span class="nx">base</span><span class="p">.</span><span class="nx">callerSkip</span> <span class="o">-=</span> <span class="mi">2</span>
	<span class="k">return</span> <span class="nx">base</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>顺便在这里提一下受zap启发的zerolog项目( <a href="https://github.com/rs/zerolog">https://github.com/rs/zerolog</a> )，zerolog更是将行号和文件名的开关提到了顶层位置，使用时需要手动触发(log.With().Caller())才会去调用Caller: github.com/rs/zerolog/event.go#L635</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//add file name and file line number to log
</span><span class="c1"></span>
<span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span> <span class="p">=</span> <span class="nx">log</span><span class="p">.</span><span class="nf">With</span><span class="p">().</span><span class="nf">Caller</span><span class="p">().</span><span class="nf">Logger</span><span class="p">()</span>

<span class="nx">log</span><span class="p">.</span><span class="nf">Info</span><span class="p">().</span><span class="nf">Msg</span><span class="p">(</span><span class="s">&#34;hello world&#34;</span><span class="p">)</span>

<span class="c1">// Caller adds the file:line of the caller with the zerolog.CallerFieldName key.
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Event</span><span class="p">)</span> <span class="nf">Caller</span><span class="p">()</span><span class="o">*</span><span class="nx">Event</span> <span class="p">{</span>

    <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nf">caller</span><span class="p">(</span><span class="nx">CallerSkipFrameCount</span><span class="p">)</span>

<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Event</span><span class="p">)</span> <span class="nf">caller</span><span class="p">(</span><span class="nx">skip</span> <span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="nx">Event</span> <span class="p">{</span>

    <span class="k">if</span> <span class="nx">e</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>

        <span class="k">return</span> <span class="nx">e</span>

    <span class="p">}</span>

    <span class="nx">_</span><span class="p">,</span> <span class="nx">file</span><span class="p">,</span> <span class="nx">line</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">Caller</span><span class="p">(</span><span class="nx">skip</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>

        <span class="k">return</span> <span class="nx">e</span>

    <span class="p">}</span>

    <span class="nx">e</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">enc</span><span class="p">.</span><span class="nf">AppendString</span><span class="p">(</span><span class="nx">enc</span><span class="p">.</span><span class="nf">AppendKey</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">CallerFieldName</span><span class="p">),</span> <span class="nx">file</span><span class="o">+</span><span class="s">&#34;:&#34;</span><span class="o">+</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">line</span><span class="p">))</span>

    <span class="k">return</span> <span class="nx">e</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<p><a href="https://colobu.com/2016/12/21/how-to-dump-goroutine-stack-traces/">调试利器：dump goroutine 的 stacktrace</a><br>
<a href="http://xiaorui.cc/archives/6294">go runtime.stack加锁引起高时延及阻塞</a>
<a href="https://www.orztu.com/post/golang-trace/">在 Golang 中打印调用栈信息</a>
<a href="https://colobu.com/2018/11/03/get-function-name-in-go/">如何在Go的函数中得到调用者函数名?</a>
<a href="https://github.com/unknwon/gcblog/blob/master/content/04-go-caller.md">深入学习 Go 语言函数调用信息</a>
<a href="https://cloud.tencent.com/developer/article/1385947">golang日志组件使用runtime.Caller性能问题分析</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go/">Go</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
