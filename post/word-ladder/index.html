<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Word Ladder | Forz Blog</title>
<meta name="keywords" content="Backtracking, Graph, String, BFS" />
<meta name="description" content="LeetCode 127. Word Ladder Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. For example, Given: beginWord =">
<meta name="author" content="">
<link rel="canonical" href="/post/word-ladder/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Word Ladder" />
<meta property="og:description" content="LeetCode 127. Word Ladder Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. For example, Given: beginWord =" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/word-ladder/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-24T20:26:35&#43;00:00" />
<meta property="article:modified_time" content="2019-09-29T20:52:47&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Word Ladder"/>
<meta name="twitter:description" content="LeetCode 127. Word Ladder Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. For example, Given: beginWord ="/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Word Ladder",
      "item": "/post/word-ladder/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Word Ladder",
  "name": "Word Ladder",
  "description": "LeetCode 127. Word Ladder Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. For example, Given: beginWord =",
  "keywords": [
    "Backtracking", "Graph", "String", "BFS"
  ],
  "articleBody": "LeetCode 127. Word Ladder Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:\nOnly one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. For example,\nGiven: beginWord = “hit”.\nendWord = “cog”.\nwordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]. As one shortest transformation is “hit” - “hot” - “dot” - “dog” - “cog”, return its length 5.\nNote:\nReturn 0 if there is no such transformation sequence.\nAll words have the same length.\nAll words contain only lowercase alphabetic characters. You may assume no duplicates in the word list.\nYou may assume beginWord and endWord are non-empty and are not the same.\nUPDATE (2017/1/20): The wordList parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.\n解析：\n这个就是图论算法中的单源最短路, 求单源最短路比较通用的算法是BFS和Dijkstra, 其区别是BFS不能用于带权重的图中, 而后者可以, 可以看出在本题中两个字符串之间是无权重的, 也就是如果连通就是1, 不联通就是无穷.\n其思路就是先把起点加到队列中, 然后每次将字典中与队首距离为1的字符串加进队列, 直到最后出队列的是终点字符串,为确保终点字符串存在, 我们可以先在字典中加进去终点字符串.\n如果对beginWord、endWord以及wordList中的所有单词建立一个图的话，当数据量上去的时候，这个图将非常之大（主要体现在边的规模有可能非常大）.所以不能先整体建一个完全的图，再进行BFS。可以在BFS过程中直接找邻接点，可以去掉很多没有价值的边和点。\n而在本题中在寻找与一个字符串相距为1的的字典中另一个字符串时如果一个个遍历字典消耗时间比较多, 每次时间复杂度是O(n). 在单个字符串不是很长的情况下, 一个个查看改变一个字符然后在字典中查看是否存在效率要更高些, 其时间复杂度是O(k log n), 其中k为单个字符串长度, n为字典长度.\nBFS过程中保存当前的单词和已走的步数。为了防止走回头路，每次将单词放入队列后都将其从字典中删除。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution { public: int ladderLength(string beginWord, string endWord, vectorstring\u0026 wordList) { unordered_setstring List(wordList.begin(),wordList.end());//vector转化为set  queuepairstring, int que; que.push(make_pair(beginWord, 1)); while(!que.empty()) { auto val = que.front(); que.pop(); if(val.first == endWord) return val.second; for(int i =0; i val.first.size(); i++) { string str = val.first; for(int j = 0; j  26; j++) { str[i] = 'a'+j; if(List.count(str) == 1) { que.push(make_pair(str, val.second+1)); List.erase(str); } } } } return 0;//如果没有路径，返回0 } };   LeetCode 126. Word Ladder II Given two words (beginWord and endWord), and a dictionary’s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:\nOnly one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word. For example,\nGiven:\nbeginWord = \"hit\" endWord = \"cog\" wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]  Return\n [ [\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"], [\"hit\",\"hot\",\"lot\",\"log\",\"cog\"] ]  Note:\nReturn an empty list if there is no such transformation sequence.\nAll words have the same length.\nAll words contain only lowercase alphabetic characters.\nYou may assume no duplicates in the word list.\nYou may assume beginWord and endWord are non-empty and are not the same.\nUPDATE (2017/1/20):\nThe wordList parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.\n解析：\n和Word Ladder相比多了要记录路径，也就是利用bfs求出最短路径后要进行dfs回溯求具体路径。\n因为BFS和DFS都需要使用邻接表，所以在BFS过程中要将邻接表保存。\ndfs回溯法需要前驱节点，但是此题即使求最短路径，也有可能某节点的前驱节点不止一个，当我们将字典中的一个字符串删除的时候在另一条路径上可能还会用到这个字符. 也就是像这样:\nA - C - D, B-C-D\n他们都会经过C, 并且两个都是最短的路径。在BFS中，在A的时候搜索到C, 并且将C从字典中删除, 当B在搜索与其距离为1的字符串时, C已经不在字典中了，无法继续更新到前驱节点。\n所以索性不用前驱节点来进行回溯，按照最短路径长度来进行dfs，一个字符串的父结点集合的距离起点的距离必然是相等的, 也就是说他们都是最短距离.这样就不需要考虑重复使用某点的问题，dfs自然会将其放入结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  class Solution { public: vectorvectorstring  ans;//记录结果 vectorstring path;//记录当前路径 vectorvectorstring findLadders(string start, string end, vectorstring \u0026wordList) { ans.clear(); unordered_setstring dict(wordList.begin(),wordList.end()); if(dict.count(end) == 0) return ans; int len = start.size(); // 起点字符串的长度  unordered_mapstring, vectorstring next; // 某个字符，经过一步变换，可以得到的所有字符串（邻接表）  unordered_mapstring, int step; // start到该单词的最短路径长度，可以当作visit数组来标记已走过的点  queuestring que; // 遍历所有字符使用的队列  que.push(start); step[start] = 0; while (!que.empty()) { string curstr = que.front(); que.pop(); if (curstr == end) break; int curstep = step[curstr];//当前已走步数  vectorstring snext;//当前字符串的临时邻接表  for (int i = 0; i  len; i++) {//枚举当前元素的每一位  string newstr = curstr; for (char c = 'a'; c  'z'; c++) //枚举当前位的所有可能字母  { newstr[i] = c; if (c == curstr[i] || dict.count(newstr) ==0)//无符合  continue; if (step.count(newstr) == 0) { que.push(newstr); step[newstr] = curstep + 1;//加一步  } snext.push_back(newstr);//记录当前字符串的邻接表  } } next[curstr] = snext;//邻接表更新  } path.push_back(start); dfspath(next, step, start, end); return ans; } void dfspath(unordered_mapstring, vectorstring  \u0026next, unordered_mapstring, int \u0026step, string now, string end){ if (now == end) ans.push_back(path); //寻到了一条路径，把路径加入结果  else { vectorstring nextStrs = next[now]; int stepNow = step[now]; for (int i = 0; i  nextStrs.size(); i++) { //对于每一个可能的next step进行遍历  if (step[nextStrs[i]] != stepNow + 1) //不符合BFS得到的结果  continue; path.push_back(nextStrs[i]); dfspath(next, step, nextStrs[i], end); path.pop_back();//回溯  } } } };   ",
  "wordCount" : "1972",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-24T20:26:35Z",
  "dateModified": "2019-09-29T20:52:47+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/word-ladder/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Word Ladder
    </h1>
    <div class="post-meta">June 24, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="leetcode-127-word-ladder">LeetCode 127. Word Ladder<a hidden class="anchor" aria-hidden="true" href="#leetcode-127-word-ladder">#</a></h1>
<p>Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:</p>
<p>Only one letter can be changed at a time.
Each transformed word must exist in the word list. Note that beginWord is not a transformed word.
For example,</p>
<p>Given:
beginWord = “hit”.<br>
endWord = “cog”.<br>
wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”].     <br>
As one shortest transformation is “hit” -&gt; “hot” -&gt;     “dot” -&gt; “dog” -&gt; “cog”,  <br>
return its length 5.</p>
<p>Note:<br>
Return 0 if there is no such transformation sequence.<br>
All words have the same length.<br>
All words contain only lowercase alphabetic characters.
You may assume no duplicates in the word list.<br>
You may assume beginWord and endWord are non-empty and are not the same.</p>
<p>UPDATE (2017/1/20):
The wordList parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.</p>
<p>解析：</p>
<p>这个就是图论算法中的单源最短路, 求单源最短路比较通用的算法是BFS和Dijkstra, 其区别是BFS不能用于带权重的图中, 而后者可以, 可以看出在本题中两个字符串之间是无权重的, 也就是如果连通就是1, 不联通就是无穷.</p>
<p>其思路就是先把起点加到队列中, 然后每次将字典中与队首距离为1的字符串加进队列, 直到最后出队列的是终点字符串,为确保终点字符串存在, 我们可以先在字典中加进去终点字符串.</p>
<p>如果对beginWord、endWord以及wordList中的所有单词建立一个图的话，当数据量上去的时候，这个图将非常之大（主要体现在边的规模有可能非常大）.所以不能先整体建一个完全的图，再进行BFS。可以在BFS过程中直接找邻接点，可以去掉很多没有价值的边和点。</p>
<p>而在本题中在寻找与一个字符串相距为1的的字典中另一个字符串时如果一个个遍历字典消耗时间比较多,
每次时间复杂度是O(n). 在单个字符串不是很长的情况下, 一个个查看改变一个字符然后在字典中查看是否存在效率要更高些, 其时间复杂度是O(k log n), 其中k为单个字符串长度, n为字典长度.</p>
<p>BFS过程中保存当前的单词和已走的步数。为了防止走回头路，每次将单词放入队列后都将其从字典中删除。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">ladderLength</span><span class="p">(</span><span class="n">string</span> <span class="n">beginWord</span><span class="p">,</span> <span class="n">string</span> <span class="n">endWord</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">wordList</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">List</span><span class="p">(</span><span class="n">wordList</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">wordList</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="c1">//vector转化为set
</span><span class="c1"></span>    <span class="n">queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">que</span><span class="p">;</span>
    <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">beginWord</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">val</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">val</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">endWord</span><span class="p">)</span> <span class="k">return</span> <span class="n">val</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">val</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="n">val</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="o">+</span><span class="n">j</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="n">List</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">val</span><span class="p">.</span><span class="n">second</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
                    <span class="n">List</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//如果没有路径，返回0
</span><span class="c1"></span><span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-126-word-ladder-ii">LeetCode 126. Word Ladder II<a hidden class="anchor" aria-hidden="true" href="#leetcode-126-word-ladder-ii">#</a></h1>
<p>Given two words (beginWord and endWord), and a dictionary’s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:</p>
<p>Only one letter can be changed at a time
Each transformed word must exist in the word list. Note that beginWord is not a transformed word.
For example,</p>
<p>Given:</p>
<pre><code>beginWord = &quot;hit&quot;  
endWord = &quot;cog&quot;  
wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]  
</code></pre>
<p>Return</p>
<pre><code>  [
    [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],
    [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]
  ]
</code></pre>
<p>Note:</p>
<p>Return an empty list if there is no such
transformation sequence.</p>
<p>All words have the same length.</p>
<p>All words contain only lowercase alphabetic characters.</p>
<p>You may assume no duplicates in the word list.</p>
<p>You may assume beginWord and endWord are non-empty and are not the same.</p>
<p>UPDATE (2017/1/20):<br>
The wordList parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.</p>
<p>解析：</p>
<p>和Word Ladder相比多了要记录路径，也就是利用bfs求出最短路径后要进行dfs回溯求具体路径。</p>
<p>因为BFS和DFS都需要使用邻接表，所以在BFS过程中要将邻接表保存。</p>
<p>dfs回溯法需要前驱节点，但是此题即使求最短路径，也有可能某节点的前驱节点不止一个，当我们将字典中的一个字符串删除的时候在另一条路径上可能还会用到这个字符. 也就是像这样:</p>
<p>A -&gt; C -&gt; D, B-&gt;C-&gt;D</p>
<p>他们都会经过C, 并且两个都是最短的路径。在BFS中，在A的时候搜索到C, 并且将C从字典中删除, 当B在搜索与其距离为1的字符串时, C已经不在字典中了，无法继续更新到前驱节点。</p>
<p>所以索性不用前驱节点来进行回溯，按照最短路径长度来进行dfs，一个字符串的父结点集合的距离起点的距离必然是相等的, 也就是说他们都是最短距离.这样就不需要考虑重复使用某点的问题，dfs自然会将其放入结果。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span><span class="c1">//记录结果
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span><span class="c1">//记录当前路径
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">findLadders</span><span class="p">(</span><span class="n">string</span> <span class="n">start</span><span class="p">,</span> <span class="n">string</span> <span class="n">end</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">wordList</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ans</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">dict</span><span class="p">(</span><span class="n">wordList</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">wordList</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="k">if</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">end</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">start</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="c1">// 起点字符串的长度
</span><span class="c1"></span>    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">next</span><span class="p">;</span> <span class="c1">// 某个字符，经过一步变换，可以得到的所有字符串（邻接表）
</span><span class="c1"></span>    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">step</span><span class="p">;</span> <span class="c1">// start到该单词的最短路径长度，可以当作visit数组来标记已走过的点
</span><span class="c1"></span>    <span class="n">queue</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">que</span><span class="p">;</span> <span class="c1">// 遍历所有字符使用的队列
</span><span class="c1"></span>    <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
    <span class="n">step</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> 
    <span class="p">{</span>
        <span class="n">string</span> <span class="n">curstr</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> 
        <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">curstr</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span> 
            <span class="k">break</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">curstep</span> <span class="o">=</span> <span class="n">step</span><span class="p">[</span><span class="n">curstr</span><span class="p">];</span><span class="c1">//当前已走步数
</span><span class="c1"></span>        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">snext</span><span class="p">;</span><span class="c1">//当前字符串的临时邻接表
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="c1">//枚举当前元素的每一位
</span><span class="c1"></span>            <span class="n">string</span> <span class="n">newstr</span> <span class="o">=</span> <span class="n">curstr</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;z&#39;</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span> <span class="c1">//枚举当前位的所有可能字母
</span><span class="c1"></span>            <span class="p">{</span>
                <span class="n">newstr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">curstr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">||</span> <span class="n">dict</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">newstr</span><span class="p">)</span> <span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="c1">//无符合
</span><span class="c1"></span>                    <span class="k">continue</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">step</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">newstr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">newstr</span><span class="p">);</span>
                    <span class="n">step</span><span class="p">[</span><span class="n">newstr</span><span class="p">]</span> <span class="o">=</span> <span class="n">curstep</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//加一步
</span><span class="c1"></span>                <span class="p">}</span>
                <span class="n">snext</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">newstr</span><span class="p">);</span><span class="c1">//记录当前字符串的邻接表
</span><span class="c1"></span>            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">next</span><span class="p">[</span><span class="n">curstr</span><span class="p">]</span> <span class="o">=</span> <span class="n">snext</span><span class="p">;</span><span class="c1">//邻接表更新
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
    <span class="n">dfspath</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">dfspath</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">next</span><span class="p">,</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">step</span><span class="p">,</span> <span class="n">string</span> <span class="n">now</span><span class="p">,</span> <span class="n">string</span> <span class="n">end</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
        <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span> <span class="c1">//寻到了一条路径，把路径加入结果
</span><span class="c1"></span>    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">nextStrs</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">now</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">stepNow</span> <span class="o">=</span> <span class="n">step</span><span class="p">[</span><span class="n">now</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nextStrs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//对于每一个可能的next step进行遍历
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">step</span><span class="p">[</span><span class="n">nextStrs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">!=</span> <span class="n">stepNow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">//不符合BFS得到的结果
</span><span class="c1"></span>                <span class="k">continue</span><span class="p">;</span>
            <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nextStrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">dfspath</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">nextStrs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">end</span><span class="p">);</span>
            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span><span class="c1">//回溯
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/backtracking/">Backtracking</a></li>
      <li><a href="/tags/graph/"> Graph</a></li>
      <li><a href="/tags/string/">String</a></li>
      <li><a href="/tags/bfs/">BFS</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
