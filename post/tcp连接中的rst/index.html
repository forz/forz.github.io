<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>TCP连接中的RST | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="RST简介 RST标示复位、用来异常的关闭连接。 发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓冲区中的包，发送RST。 而接收端">
<meta name="author" content="">
<link rel="canonical" href="/post/tcp%E8%BF%9E%E6%8E%A5%E4%B8%AD%E7%9A%84rst/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="TCP连接中的RST" />
<meta property="og:description" content="RST简介 RST标示复位、用来异常的关闭连接。 发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓冲区中的包，发送RST。 而接收端" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/tcp%E8%BF%9E%E6%8E%A5%E4%B8%AD%E7%9A%84rst/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-25T20:08:15&#43;00:00" />
<meta property="article:modified_time" content="2017-06-25T20:08:15&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="TCP连接中的RST"/>
<meta name="twitter:description" content="RST简介 RST标示复位、用来异常的关闭连接。 发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓冲区中的包，发送RST。 而接收端"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "TCP连接中的RST",
      "item": "/post/tcp%E8%BF%9E%E6%8E%A5%E4%B8%AD%E7%9A%84rst/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TCP连接中的RST",
  "name": "TCP连接中的RST",
  "description": "RST简介 RST标示复位、用来异常的关闭连接。 发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓冲区中的包，发送RST。 而接收端",
  "keywords": [
    
  ],
  "articleBody": "RST简介 RST标示复位、用来异常的关闭连接。\n  发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓冲区中的包，发送RST。\n  而接收端收到RST包后，也不必发送ACK包来确认。\n  TCP中出现RST的几种场景   在连接建立时\n  端口未打开\n向一个不存在的端口发送数据，目的端口没有被进程正在监听，而客户端来connect。对于UDP，当一个数据报到达目的端口时，该端口没在使用，它将产生一个ICMP端口不可达的信息\n  请求超时\n有89、27两台主机。主机89向主机27发送了一个SYN，表示希望连接8888端口，主机27回应了主机89一个SYN表示可以连接。但是主机89却发送了一个RST表示拒绝连接。后来经过排查发现，在主机89上的程序在建立了socket之后，用setsockopt的SO_RCVTIMEO选项设置了recv的超时时间为100ms。而从主机89发出SYN到接收SYN的时间多达110ms。因此主机89上的程序认为接收超时，所以发送了RST拒绝进一步发送数据。\n  向处于listen的端口发送数据，发送端会收到对端发送的rst复位报文段\n    发送数据时\n数据出现错误，不是按照既定序列号发送数据时\n  连接关闭时\n  在一个已关闭的socket上收到数据\n四次挥手如果没有TIME_WAIT状态下，就会产生RST。连接关闭后，网络中游离的数据到达目的端，目的端发现连接已经关闭，就会回应一个RST\n  提前关闭连接\n服务器关闭或异常终止了连接，由于网络问题，客户端没有收到服务器的关闭请求，这称为TCP半打开连接。就算重启服务器，也没有连接信息。如果客户端向提其写入数据，对方就会回应一个RST报文段。\n  异常终止一个连接\n    在数据交换完成之后，一方给另一方发送结束报文，同时TCP提供了异常终止一个连接的方法，就是给对方发送一个rst复位报文段，一旦发送复位报文段，发送端所有排队等待发送的数据都被丢弃，应用程序可使用套接字选项来发送复位报文段\n尝试手动发送RST包   三次握手成功后，使用shutdown、close关闭套接字，发送的是FIN，不是RST。\n  套接字关闭前，使用sleep。对运行的程序Ctrl+C，会发送FIN，不是RST。\n  套接字关闭前，执行return、exit(0)、exit(1)，会发送FIN、不是RST。\n  以上几种方法，都不能发送RST包。 发送RST包，需要自己伪造数据包进行发送。\nRST攻击 A和服务器B之间建立了TCP连接，此时C伪造了一个TCP包发给B，使B异常的断开了与A之间的TCP连接，就是RST攻击了。实际上从上面RST标志位的功能已经可以看出这种攻击如何达到效果了。\n那么伪造什么样的TCP包可以达成目的呢？我们至顶向下的看。\n  假定C伪装成A发过去的包，这个包如果是RST包的话，毫无疑问，B将会丢弃与A的缓冲区上所有数据，强制关掉连接。\n  如果发过去的包是SYN包，那么，B会表示A已经发疯了（与OS的实现有关），正常连接时又来建新连接，B主动向A发个RST包，并在自己这端强制关掉连接。\n  这两种方式都能够达到复位攻击的效果。似乎挺恐怖，然而关键是，如何能伪造成A发给B的包呢？这里有两个关键因素，源端口和序列号。\n一个TCP连接都是四元组，由源IP、源端口、目标IP、目标端口唯一确定一个连接。所以，如果C要伪造A发给B的包，要在上面提到的IP头和TCP头，把源IP、源端口、目标IP、目标端口都填对。这里B作为服务器，IP和端口是公开的，A是我们要下手的目标，IP当然知道，但A的源端口就不清楚了，因为这可能是A随机生成的。当然，如果能够对常见的OS如windows和linux找出生成source port规律的话，还是可以搞定的。\n序列号问题是与滑动窗口对应的，伪造的TCP包里需要填序列号，如果序列号的值不在A之前向B发送时B的滑动窗口内，B是会主动丢弃的。所以我们要找到能落到当时的AB间滑动窗口的序列号。这个可以暴力解决，因为一个sequence长度是32位，取值范围0-4294967296，如果窗口大小像windows下的65535的话，只需要相除，就知道最多只需要发65537（4294967296/65535=65537）个包就能有一个序列号落到滑动窗口内。RST包是很小的，IP头＋TCP头也才40字节，算算我们的带宽就知道这实在只需要几秒钟就能搞定。\n那么，序列号不是问题，源端口会麻烦点，如果各个操作系统不能完全随机的生成源端口，或者黑客们能通过其他方式获取到source port，RST攻击易如反掌，后果很严重。\n",
  "wordCount" : "1861",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-25T20:08:15Z",
  "dateModified": "2017-06-25T20:08:15Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/tcp%E8%BF%9E%E6%8E%A5%E4%B8%AD%E7%9A%84rst/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      TCP连接中的RST
    </h1>
    <div class="post-meta">June 25, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="rst简介">RST简介<a hidden class="anchor" aria-hidden="true" href="#rst简介">#</a></h1>
<p>RST标示复位、用来异常的关闭连接。</p>
<ol>
<li>
<p>发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓冲区中的包，发送RST。</p>
</li>
<li>
<p>而接收端收到RST包后，也不必发送ACK包来确认。</p>
</li>
</ol>
<h1 id="tcp中出现rst的几种场景">TCP中出现RST的几种场景<a hidden class="anchor" aria-hidden="true" href="#tcp中出现rst的几种场景">#</a></h1>
<ol>
<li>
<p>在连接建立时</p>
<ol>
<li>
<p>端口未打开</p>
<p>向一个不存在的端口发送数据，目的端口没有被进程正在监听，而客户端来connect。对于UDP，当一个数据报到达目的端口时，该端口没在使用，它将产生一个ICMP端口不可达的信息</p>
</li>
<li>
<p>请求超时</p>
<p>有89、27两台主机。主机89向主机27发送了一个SYN，表示希望连接8888端口，主机27回应了主机89一个SYN表示可以连接。但是主机89却发送了一个RST表示拒绝连接。后来经过排查发现，在主机89上的程序在建立了socket之后，用setsockopt的SO_RCVTIMEO选项设置了recv的超时时间为100ms。而从主机89发出SYN到接收SYN的时间多达110ms。因此主机89上的程序认为接收超时，所以发送了RST拒绝进一步发送数据。</p>
</li>
<li>
<p>向处于listen的端口发送数据，发送端会收到对端发送的rst复位报文段</p>
</li>
</ol>
</li>
<li>
<p>发送数据时</p>
<p>数据出现错误，不是按照既定序列号发送数据时</p>
</li>
<li>
<p>连接关闭时</p>
<ol>
<li>
<p>在一个已关闭的socket上收到数据</p>
<p>四次挥手如果没有TIME_WAIT状态下，就会产生RST。连接关闭后，网络中游离的数据到达目的端，目的端发现连接已经关闭，就会回应一个RST</p>
</li>
<li>
<p>提前关闭连接</p>
<p>服务器关闭或异常终止了连接，由于网络问题，客户端没有收到服务器的关闭请求，这称为TCP半打开连接。就算重启服务器，也没有连接信息。如果客户端向提其写入数据，对方就会回应一个RST报文段。</p>
</li>
<li>
<p>异常终止一个连接</p>
</li>
</ol>
</li>
</ol>
<p>在数据交换完成之后，一方给另一方发送结束报文，同时TCP提供了异常终止一个连接的方法，就是给对方发送一个rst复位报文段，一旦发送复位报文段，发送端所有排队等待发送的数据都被丢弃，应用程序可使用套接字选项来发送复位报文段</p>
<h1 id="尝试手动发送rst包">尝试手动发送RST包<a hidden class="anchor" aria-hidden="true" href="#尝试手动发送rst包">#</a></h1>
<ol>
<li>
<p>三次握手成功后，使用shutdown、close关闭套接字，发送的是FIN，不是RST。</p>
</li>
<li>
<p>套接字关闭前，使用sleep。对运行的程序Ctrl+C，会发送FIN，不是RST。</p>
</li>
<li>
<p>套接字关闭前，执行return、exit(0)、exit(1)，会发送FIN、不是RST。</p>
</li>
</ol>
<p>以上几种方法，都不能发送RST包。 发送RST包，需要自己伪造数据包进行发送。</p>
<h1 id="rst攻击">RST攻击<a hidden class="anchor" aria-hidden="true" href="#rst攻击">#</a></h1>
<p>A和服务器B之间建立了TCP连接，此时C伪造了一个TCP包发给B，使B异常的断开了与A之间的TCP连接，就是RST攻击了。实际上从上面RST标志位的功能已经可以看出这种攻击如何达到效果了。</p>
<p>那么伪造什么样的TCP包可以达成目的呢？我们至顶向下的看。</p>
<ol>
<li>
<p>假定C伪装成A发过去的包，这个包如果是RST包的话，毫无疑问，B将会丢弃与A的缓冲区上所有数据，强制关掉连接。</p>
</li>
<li>
<p>如果发过去的包是SYN包，那么，B会表示A已经发疯了（与OS的实现有关），正常连接时又来建新连接，B主动向A发个RST包，并在自己这端强制关掉连接。</p>
</li>
</ol>
<p>这两种方式都能够达到复位攻击的效果。似乎挺恐怖，然而关键是，如何能伪造成A发给B的包呢？这里有两个关键因素，源端口和序列号。</p>
<p>一个TCP连接都是四元组，由源IP、源端口、目标IP、目标端口唯一确定一个连接。所以，如果C要伪造A发给B的包，要在上面提到的IP头和TCP头，把源IP、源端口、目标IP、目标端口都填对。这里B作为服务器，IP和端口是公开的，A是我们要下手的目标，IP当然知道，但A的源端口就不清楚了，因为这可能是A随机生成的。当然，如果能够对常见的OS如windows和linux找出生成source port规律的话，还是可以搞定的。</p>
<p>序列号问题是与滑动窗口对应的，伪造的TCP包里需要填序列号，如果序列号的值不在A之前向B发送时B的滑动窗口内，B是会主动丢弃的。所以我们要找到能落到当时的AB间滑动窗口的序列号。这个可以暴力解决，因为一个sequence长度是32位，取值范围0-4294967296，如果窗口大小像windows下的65535的话，只需要相除，就知道最多只需要发65537（4294967296/65535=65537）个包就能有一个序列号落到滑动窗口内。RST包是很小的，IP头＋TCP头也才40字节，算算我们的带宽就知道这实在只需要几秒钟就能搞定。</p>
<p>那么，序列号不是问题，源端口会麻烦点，如果各个操作系统不能完全随机的生成源端口，或者黑客们能通过其他方式获取到source port，RST攻击易如反掌，后果很严重。</p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
