<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go的定时器源码剖析 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author"
  content="Forz" /><meta name="description" content="数据结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 ┌──" /><meta name="keywords"
  content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.84.4 with theme even" />


<link rel="canonical" href="/post/go%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link rel="stylesheet" href="/css/search.css" />


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go的定时器源码剖析" />
<meta property="og:description" content="数据结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 ┌──" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-10-21T15:23:59+00:00" />
<meta property="article:modified_time" content="2019-10-21T15:23:59+00:00" />

<meta itemprop="name" content="Go的定时器源码剖析">
<meta itemprop="description" content="数据结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 ┌──"><meta itemprop="datePublished" content="2019-10-21T15:23:59+00:00" />
<meta itemprop="dateModified" content="2019-10-21T15:23:59+00:00" />
<meta itemprop="wordCount" content="9132">
<meta itemprop="keywords" content="Go,定时器," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go的定时器源码剖析"/>
<meta name="twitter:description" content="数据结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 ┌──"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="clearfix">
  <div class="logo-wrapper">
    <a href="/" class="logo">Forz Blog</a>
  </div>

  <nav class="site-navbar">
    <ul id="menu" class="menu">
      <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
    </ul>
  </nav>
</div>


<div class="search-container">
  <div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="Search for titles or URIs..."
        name="search" autocomplete="off" />
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path
            d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js"></script>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js"></script>
<script>
    var client = algoliasearch("IAR2EF5L65", "b4b9da2eba53aa6dabe4b8ac9e8676e1");
    var index = client.initIndex('forz.forzvina.com');
    autocomplete('#aa-search-input',
        { hint: false }, {
        source: autocomplete.sources.hits(index, { hitsPerPage: 8 }),
        displayKey: 'name',
        templates: {
            suggestion: function (suggestion) {
                var reg = /([A-Z]+)/ig
                var title = suggestion.uri.replace(reg, function (m) {
                    return m.toLowerCase()
                })
                return '<span class="search-item">' + '<a href="\/' + title + '">' +
                    suggestion._highlightResult.title.value + '</a></span>';
            }
        }
    });
</script>
</div>


    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go的定时器源码剖析</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-10-21 </span>
        <div class="post-category">
            <a href="/categories/go%E6%BA%90%E7%A0%81/"> Go源码 </a>
            </div>
          <span class="more-meta"> 约 9132 字 </span>
          <span class="more-meta"> 预计阅读 19 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#timers">timers</a></li>
    <li><a href="#timer">Timer</a></li>
  </ul>

  <ul>
    <li><a href="#四叉小顶堆">四叉小顶堆</a></li>
    <li><a href="#时间堆插入">时间堆插入</a></li>
    <li><a href="#时间堆删除">时间堆删除</a></li>
    <li><a href="#时间堆触发">时间堆触发</a></li>
    <li><a href="#时间堆调整">时间堆调整</a>
      <ul>
        <li><a href="#向上调整">向上调整</a></li>
        <li><a href="#向下调整">向下调整</a></li>
      </ul>
    </li>
    <li><a href="#sleeping">sleeping</a></li>
    <li><a href="#rescheduling">rescheduling</a></li>
  </ul>

  <ul>
    <li><a href="#timerafter">timer.After</a></li>
    <li><a href="#timerafterfunc">Timer.AfterFunc</a></li>
    <li><a href="#timertick">timer.Tick</a></li>
    <li><a href="#timerreset">Timer.Reset</a></li>
    <li><a href="#timerstop--tickerstop">Timer.Stop &amp; Ticker.Stop</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="数据结构">数据结构</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">                                          ┌────────┐                                                                                                     
                                          │ timers │                                                                                                     
                                          ├────┬───┴┬────┬────┬────┬────┬────┬───────────────────────┬────┐                                              
                                          │    │    │    │    │    │    │    │                       │    │                                              
                                          │  0 │  1 │  2 │  3 │  4 │  5 │  6 │            ...        │ 63 │                                              
                                          └────┴────┴────┴────┴────┴────┴────┴───────────────────────┴────┘                                              
                                              │                                                         │                                                
                                              │                                                         │                                                
                                              │                                                         │                                                
                                              │                                                         │                                                
                                              │                                                         │                                                
                                              │ │                                          │            │    │                                          │
                                              │ │          ┌────────────────────┐          │            │    │          ┌────────────────────┐          │
                                              │ │────────▶ │   cacheline size   │ ◀────────┤            │    │────────▶ │   cacheline size   │ ◀────────┤
                                              │ │          └────────────────────┘          │            │    │          └────────────────────┘          │
                                              │ ├─────────────┬─────────────────┬──────────┤            │    ├─────────────┬─────────────────┬──────────┤
                                              └▶│timersBucket │                 │          │            └───▶│timersBucket │                 │          │
                                                ├─────────────┴─────────────────┤   pad    │                 ├─────────────┴─────────────────┤   pad    │
                                                │          lock mutex           │          │                 │          lock mutex           │          │
                                                ├───────────────────────────────┤          │                 ├───────────────────────────────┤          │
                                                │             gp *g             │          │                 │             gp *g             │          │
                                                ├───────────────────────────────┤          │                 ├───────────────────────────────┤          │
                                                │         created bool          │          │                 │         created bool          │          │
                                                ├───────────────────────────────┤          │    ........     ├───────────────────────────────┤          │
                                                │         sleeping bool         │          │                 │         sleeping bool         │          │
                                                ├───────────────────────────────┤          │                 ├───────────────────────────────┤          │
                                                │       rescheduling bool       │          │                 │       rescheduling bool       │          │
                                                ├───────────────────────────────┤          │                 ├───────────────────────────────┤          │
                                                │       sleepUntil int64        │          │                 │       sleepUntil int64        │          │
                                                ├───────────────────────────────┤          │                 ├───────────────────────────────┤          │
                                                │         waitnote note         │          │                 │         waitnote note         │          │
                                                ├───────────────────────────────┤          │                 ├───────────────────────────────┤          │
                                                │          t []*timer           │          │                 │          t []*timer           │          │
                                                └───────────────────────────────┴──────────┘                 └───────────────────────────────┴──────────┘
                                                                │                                                                                        
                                                                │                                                                                        
                                                                │                                                                                        
                                                                ▼                                                                                        
                                                              ┌───┐                                                                                      
                                                              │ 0 │                                                                                      
                                                              └───┘                                                                                      
                                                                │                                                                                        
                                                                │                                                                                        
                                                                │                                                                                        
                                                                │                                                                                        
                                                                ▼                                                                                        
                                                        ┌───┬───┬───┬───┐                                                                                
                                                        │ 1 │ 2 │ 3 │ 4 │                                                                                
                                                        └─┬─┴─┬─┴─┬─┴─┬─┘                                                                                
                        ┌─────────────────────────────────┘   │   │   └──────────────────────────────────────────┐                                       
                        │                              ┌──────┘   └────────┐                                     │                                       
                        ▼                              │                   │                                     ▼                                       
                ┌───┬───┬───┬───┐                      ▼                   ▼                             ┌───┬───┬───┬───┐                               
                │   │   │   │   │              ┌───┬───┬───┬───┐   ┌───┬───┬───┬───┐                     │   │   │   │   │                               
                └─┬─┴─┬─┴───┴───┘              │   │   │   │   │   │   │   │   │   │                     └───┴───┴─┬─┴─┬─┘                               
                  │   │                        └───┴───┴───┴───┘   └───┴───┴───┴───┘                               │   │                                 
        ┌─────────┘   └─────────┐                                                                        ┌─────────┘   └─────┐                           
        │                       │                                                                        │                   │                           
        │                       │                                                                        │                   │                           
        ▼                       ▼                                                                        ▼                   ▼                           
┌───┬───┬───┬───┐       ┌───┬───┬───┬───┐                                                        ┌───┬───┬───┬───┐   ┌───┬───┬───┬───┐                   
│   │   │   │   │       │   │   │   │   │                  .................                     │   │   │   │   │   │   │   │   │   │                   
└───┴───┴───┴───┘       └───┴───┴───┴───┘                                                        └───┴───┴───┴───┘   └───┴───┴───┴───┘                   
</code></pre></td></tr></table>
</div>
</div><p>下面的结论都可以结合上面的图来看。</p>
<h2 id="timers">timers</h2>
<p>在 <code>runtime/time.go</code> 中定义了 timers 数组:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">timers</span> <span class="p">[</span><span class="nx">timersLen</span><span class="p">]</span><span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">timersBucket</span>
    <span class="nx">pad</span> <span class="p">[</span><span class="nx">sys</span><span class="p">.</span><span class="nx">CacheLineSize</span> <span class="o">-</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">timersBucket</span><span class="p">{})</span><span class="o">%</span><span class="nx">sys</span><span class="p">.</span><span class="nx">CacheLineSize</span><span class="p">]</span><span class="kt">byte</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在 Go 的早期实现中是全局一个 timer 的，但操作全局的 timer 堆要加锁，所以多核心会暴露出因为争锁而性能低下的问题。从某个版本起，Go 的 timers 修改成了这种多个时间堆的实现方式，目前在 runtime 里写死为 64:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">timersLen</span> <span class="p">=</span> <span class="mi">64</span>
</code></pre></td></tr></table>
</div>
</div><p>嗯，官方表示如果和 GOMAXPROCS 相等的话，那么会在 procresize 的时候重新分配和修改这些时间堆。写死成 64 是内存使用和性能上的一个折衷。如果 GOMAXPROCS 比 64 大的话，那么可能多个 P 会公用同一个时间堆。当然，实际场景中我还没有见过 64 核以上的 CPU。</p>
<p>timers 数组的元素是一个匿名 struct，包含 timersBucket 和 pad 两个成员，这个 pad 是为了填充 struct 到 cacheline 的整数倍，以避免在不同的 P 之间发生 false sharing。在多核心的编程场景中较为常见。timerBucket 的结构:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">timersBucket</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">lock</span>         <span class="nx">mutex</span>
    <span class="nx">gp</span>           <span class="o">*</span><span class="nx">g</span>
    <span class="nx">created</span>      <span class="kt">bool</span>
    <span class="nx">sleeping</span>     <span class="kt">bool</span>
    <span class="nx">rescheduling</span> <span class="kt">bool</span>
    <span class="nx">sleepUntil</span>   <span class="kt">int64</span>
    <span class="nx">waitnote</span>     <span class="nx">note</span>
    <span class="nx">t</span>            <span class="p">[]</span><span class="o">*</span><span class="nx">timer</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中的 t 就是我们的时间堆了，不过这个和我们传统的 heap 结构稍微有所不同，是分四个叉的，这种设计第一次见。这里的 timersBucket 还有个特殊的注释 <code>go:notinheap</code>，官方的说明:</p>
<blockquote>
<p>go:notinheap applies to type declarations. It indicates that a type must never be allocated from the GC&rsquo;d heap. Specifically, pointers to this type must always fail the runtime.inheap check. The type may be used for global variables, for stack variables, or for objects in unmanaged memory (e.g., allocated with sysAlloc, persistentalloc, fixalloc, or from a manually-managed span). Specifically:</p>
<ol>
<li>new(T), make([]T), append([]T, &hellip;) and implicit heap allocation of T are disallowed. (Though implicit allocations are disallowed in the runtime anyway.)</li>
<li>A pointer to a regular type (other than unsafe.Pointer) cannot be converted to a pointer to a go:notinheap type, even if they have the same underlying type.</li>
<li>Any type that contains a go:notinheap type is itself go:notinheap. Structs and arrays are go:notinheap if their elements are. Maps and channels of go:notinheap types are disallowed. To keep things explicit, any type declaration where the type is implicitly go:notinheap must be explicitly marked go:notinheap as well.</li>
<li>Write barriers on pointers to go:notinheap types can be omitted.
The last point is the real benefit of go:notinheap. The runtime uses it for low-level internal structures to avoid memory barriers in the scheduler and the memory allocator where they are illegal or simply inefficient. This mechanism is reasonably safe and does not compromise the readability of the runtime.</li>
</ol>
</blockquote>
<p>嗯，了解一下就行了，在用户代码中基本不会用得到。</p>
<h2 id="timer">Timer</h2>
<p>Timer 类型代表单次时间事件。当 Timer 到期时，当时的时间会被发送给 C (channel)，除非 Timer 是被 AfterFunc 函数创建的。</p>
<p>注意：Timer 的实例必须通过 NewTimer 或 AfterFunc 获得。</p>
<p>类型定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Timer</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">C</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">Time</span>     <span class="c1">// The channel on which the time is delivered.
</span><span class="c1"></span>    <span class="nx">r</span> <span class="nx">runtimeTimer</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>C 已经解释了，我们看看 runtimeTimer。它定义在 sleep.go 文件中，必须和 runtime 包中 time.go 文件中的 timer 必须保持一致：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Interface to timers implemented in package runtime.
</span><span class="c1">// Must be in sync with ../runtime/time.go:/^type timer
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">runtimeTimer</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">tb</span> <span class="kt">uintptr</span>
	<span class="nx">i</span>  <span class="kt">int</span>

	<span class="nx">when</span>   <span class="kt">int64</span>
	<span class="nx">period</span> <span class="kt">int64</span>
	<span class="nx">f</span>      <span class="kd">func</span><span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="c1">// NOTE: must not be closure
</span><span class="c1"></span>	<span class="nx">arg</span>    <span class="kd">interface</span><span class="p">{}</span>
	<span class="nx">seq</span>    <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们通过 NewTimer() 来看这些字段都怎么赋值，是什么用途。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NewTimer creates a new Timer that will send
</span><span class="c1">// the current time on its channel after at least duration d.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewTimer</span><span class="p">(</span><span class="nx">d</span> <span class="nx">Duration</span><span class="p">)</span> <span class="o">*</span><span class="nx">Timer</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Time</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 创建一个带有一个Time结构缓冲的通道
</span><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Timer</span><span class="p">{</span>
		<span class="nx">C</span><span class="p">:</span> <span class="nx">c</span><span class="p">,</span>
		<span class="nx">r</span><span class="p">:</span> <span class="nx">runtimeTimer</span><span class="p">{</span><span class="c1">// 运行时定时器
</span><span class="c1"></span>			<span class="nx">when</span><span class="p">:</span> <span class="nf">when</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span><span class="c1">// 定时多久
</span><span class="c1"></span>			<span class="nx">f</span><span class="p">:</span>    <span class="nx">sendTime</span><span class="p">,</span><span class="c1">// Golang写入时间的回调接口
</span><span class="c1"></span>			<span class="nx">arg</span><span class="p">:</span>  <span class="nx">c</span><span class="p">,</span><span class="c1">// 往哪个通道写入时间
</span><span class="c1"></span>		<span class="p">},</span>
	<span class="p">}</span>
	<span class="nf">startTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span><span class="c1">// 启动提交定时器
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">t</span>
<span class="p">}</span>

<span class="c1">// when is a helper function for setting the &#39;when&#39; field of a runtimeTimer.
</span><span class="c1">// It returns what the time will be, in nanoseconds, Duration d in the future.
</span><span class="c1">// If d is negative, it is ignored. If the returned value would be less than
</span><span class="c1">// zero because of an overflow, MaxInt64 is returned.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">when</span><span class="p">(</span><span class="nx">d</span> <span class="nx">Duration</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">d</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">runtimeNano</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nf">runtimeNano</span><span class="p">()</span> <span class="o">+</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">t</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">t</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">63</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// math.MaxInt64
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">t</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>when 表示时间到时，会往 Timer.C 中发送当前时间。when 表示的时间是纳秒时间，正常通过 runtimeNano() + int64(d) 赋值。</li>
<li>f 参数的值是 sendTime，定时器时间到时，会调用 f，并将 arg 和 seq 传给 f。</li>
<li>因为 Timer 是一次性的，所以 period 保留默认值 0。</li>
<li>runtimeTimer 结构中的 i 字段，表示在堆中的索引.</li>
</ul>
<p>在time包中，函数f有三种类型：</p>
<ul>
<li>sendTime：发送当前时间到channel或者在发送被阻塞的情况下丢弃。被time.Timer和time.Ticker使用。</li>
<li>goFunc：在goroutine中执行一些函数。被time.AfterFunc使用。</li>
<li>goroutineReady：唤醒特定的goroutine。被runtime.timeSleep使用。</li>
</ul>
<h1 id="定时器实现">定时器实现</h1>
<h2 id="四叉小顶堆">四叉小顶堆</h2>
<p>四叉堆高度上比二叉堆要矮一些。一个节点的所有(最多有4个)孩子节点都比这个节点要大。一个节点的(只有一个)父节点一定比当前节点小。下面是填好值之后的一个典型的四叉堆:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">                                                             ┌─────┐                                                         
                                                             │     │                                                         
                                                             │  0  │                                                         
                                                             └─────┘                                                         
                                                                │                                                            
                                                                │                                                            
                                                                │                                                            
                                                                ▼                                                            
                                                    ┌─────┬─────┬─────┬─────┐                                                
                                                    │     │     │     │     │                                                
                                                    │  3  │  2  │  2  │  10 │                                                
                                                    └─────┴─────┴─────┴─────┘                                                
                                                       │     │     │     │                                                   
                                                       │     │     │     │                                                   
                    ┌──────────┐                       │     │     │     │                                                   
   ┌────────────────┤  4*i+1   ├───────────────────────┘     │     │     └─────────────────────────────┐                     
   │                └──────────┘         ┌───────────────────┘     └───┐                               │                     
   │                                     │                             │                               │                     
   │                                     │                             │                               │                     
   ▼                                     │                             │                               ▼                     
┌─────┬─────┬─────┬─────┐                │                             │                            ┌─────┬─────┬─────┬─────┐
│     │     │     │     │                ▼                             ▼                            │     │     │     │     │
│  20 │  4  │  5  │  13 │             ┌─────┬─────┬─────┬─────┐     ┌─────┬─────┬─────┬─────┐       │ 99  │ 13  │ 11  │  12 │
└─────┴─────┴─────┴─────┘             │     │     │     │     │     │     │     │     │     │       └─────┴─────┴─────┴─────┘
                                      │ 12  │ 14  │ 15  │  16 │     │ 3   │ 10  │ 3   │  3  │                                
                                      └─────┴─────┴─────┴─────┘     └─────┴─────┴─────┴─────┘                                
</code></pre></td></tr></table>
</div>
</div><p>和二叉堆一样，对于一个节点的要求只有和其父节点以及子节点之间的大小关系。相邻节点之间没有任何关系。</p>
<h2 id="时间堆插入">时间堆插入</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 分配 timerBucket
</span><span class="c1">// 加锁，添加 timer 进时间堆
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">addtimer</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">timer</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">tb</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">assignBucket</span><span class="p">()</span>
    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tb</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="nx">tb</span><span class="p">.</span><span class="nf">addtimerLocked</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tb</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 太简单了，就是用 g.m.p 的 id 模 64
</span><span class="c1">// 然后分配对应的 timerBucket
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">timer</span><span class="p">)</span> <span class="nf">assignBucket</span><span class="p">()</span> <span class="o">*</span><span class="nx">timersBucket</span> <span class="p">{</span>
    <span class="nx">id</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">id</span><span class="p">)</span> <span class="o">%</span> <span class="nx">timersLen</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">tb</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">timers</span><span class="p">[</span><span class="nx">id</span><span class="p">].</span><span class="nx">timersBucket</span>
    <span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nx">tb</span>
<span class="p">}</span>

<span class="c1">// 向时间堆中添加一个 timer，如果时间堆第一次被初始化或者当前的 timer 比之前所有的 timers 都要早，那么就启动(首次初始化)或唤醒(最早的 timer) timerproc
</span><span class="c1">// 函数内假设外部已经对 timers 数组加锁了
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">tb</span> <span class="o">*</span><span class="nx">timersBucket</span><span class="p">)</span> <span class="nf">addtimerLocked</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">timer</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// when 必须大于 0，否则会在计算 delta 的时候溢出并导致其它的 runtime timer 永远没法过期
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">when</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">when</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">63</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">i</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">tb</span><span class="p">.</span><span class="nx">t</span><span class="p">)</span>
    <span class="nx">tb</span><span class="p">.</span><span class="nx">t</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">tb</span><span class="p">.</span><span class="nx">t</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
    <span class="c1">// 维持堆的性质不变
</span><span class="c1"></span>    <span class="nf">siftupTimer</span><span class="p">(</span><span class="nx">tb</span><span class="p">.</span><span class="nx">t</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// 新插入的 timer 比之前所有的都要早
</span><span class="c1"></span>        <span class="c1">// 向上调整堆
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">tb</span><span class="p">.</span><span class="nx">sleeping</span> <span class="p">{</span>
            <span class="c1">// 修改 timerBucket 的 sleep 状态
</span><span class="c1"></span>            <span class="nx">tb</span><span class="p">.</span><span class="nx">sleeping</span> <span class="p">=</span> <span class="kc">false</span>
            <span class="c1">// 唤醒 timerproc
</span><span class="c1"></span>            <span class="c1">// 使 timerproc 中的 for 循环不再阻塞在 notesleepg 上
</span><span class="c1"></span>            <span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tb</span><span class="p">.</span><span class="nx">waitnote</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">// 同一个 P 上的所有 timers 如果
</span><span class="c1"></span>        <span class="c1">// 都在 timerproc 中被弹出了
</span><span class="c1"></span>        <span class="c1">// 该 rescheduling 会被标记为 true
</span><span class="c1"></span>        <span class="c1">// 并且启动 timerproc 的 goroutine 会被 goparkunlock
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">tb</span><span class="p">.</span><span class="nx">rescheduling</span> <span class="p">{</span>
            <span class="c1">// 该标记会在这里和 timejumpLocked 中被设置为 false
</span><span class="c1"></span>            <span class="nx">tb</span><span class="p">.</span><span class="nx">rescheduling</span> <span class="p">=</span> <span class="kc">false</span>
            <span class="nf">goready</span><span class="p">(</span><span class="nx">tb</span><span class="p">.</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 如果 timerBucket 是第一次创建，需要启动一个 goroutine
</span><span class="c1"></span>    <span class="c1">// 来循环弹出时间堆，内部会根据需要最早触发的 timer
</span><span class="c1"></span>    <span class="c1">// 进行相应时间的 sleep
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nx">tb</span><span class="p">.</span><span class="nx">created</span> <span class="p">{</span>
        <span class="nx">tb</span><span class="p">.</span><span class="nx">created</span> <span class="p">=</span> <span class="kc">true</span>
        <span class="k">go</span> <span class="nf">timerproc</span><span class="p">(</span><span class="nx">tb</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>插入 timer 到堆中的时候的逻辑是先追加到数组末尾(append)，然后向上 adjust(siftup) heap 以重新恢复四叉小顶堆性质。</p>
<h2 id="时间堆删除">时间堆删除</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 从堆中删除 timer t
</span><span class="c1">// 如果 timerproc 提前被唤醒也没所谓
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">deltimer</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">timer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">tb</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// t.tb can be nil if the user created a timer
</span><span class="c1"></span>        <span class="c1">// directly, without invoking startTimer e.g
</span><span class="c1"></span>        <span class="c1">//    time.Ticker{C: c}
</span><span class="c1"></span>        <span class="c1">// In this case, return early without any deletion.
</span><span class="c1"></span>        <span class="c1">// See Issue 21874.
</span><span class="c1"></span>        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>

    <span class="nx">tb</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">tb</span>

    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tb</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="c1">// t may not be registered anymore and may have
</span><span class="c1"></span>    <span class="c1">// a bogus i (typically 0, if generated by Go).
</span><span class="c1"></span>    <span class="c1">// Verify it before proceeding.
</span><span class="c1"></span>    <span class="nx">i</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">i</span>
    <span class="nx">last</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">tb</span><span class="p">.</span><span class="nx">t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="nx">last</span> <span class="o">||</span> <span class="nx">tb</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">t</span> <span class="p">{</span>
        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tb</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="c1">// 把 timer[i] 替换为 timer[last]
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">i</span> <span class="o">!=</span> <span class="nx">last</span> <span class="p">{</span>
        <span class="nx">tb</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">tb</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">last</span><span class="p">]</span>
        <span class="nx">tb</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">i</span> <span class="p">=</span> <span class="nx">i</span>
    <span class="p">}</span>
    <span class="c1">// 删除 timer[last]，并缩小 slice
</span><span class="c1"></span>    <span class="nx">tb</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">last</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="nx">tb</span><span class="p">.</span><span class="nx">t</span> <span class="p">=</span> <span class="nx">tb</span><span class="p">.</span><span class="nx">t</span><span class="p">[:</span><span class="nx">last</span><span class="p">]</span>

    <span class="c1">// 判断是不是删的最后一个
</span><span class="c1"></span>    <span class="c1">// 如果不是的话，需要重新调整堆
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">i</span> <span class="o">!=</span> <span class="nx">last</span> <span class="p">{</span>
        <span class="c1">// 最后一个节点当前来的分叉可能并不是它那个分叉
</span><span class="c1"></span>        <span class="c1">// 所以向上走或者向下走都是有可能的
</span><span class="c1"></span>        <span class="c1">// 即使是二叉堆，也是有这种可能的
</span><span class="c1"></span>        <span class="nf">siftupTimer</span><span class="p">(</span><span class="nx">tb</span><span class="p">.</span><span class="nx">t</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
        <span class="nf">siftdownTimer</span><span class="p">(</span><span class="nx">tb</span><span class="p">.</span><span class="nx">t</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tb</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="时间堆触发">时间堆触发</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// timerproc 负责处理时间驱动的事件
</span><span class="c1">// 在堆中的下一个事件需要触发之前，会一直保持 sleep 状态
</span><span class="c1">// 如果 addtimer 插入了一个更早的事件，会提前唤醒 timerproc
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">timerproc</span><span class="p">(</span><span class="nx">tb</span> <span class="o">*</span><span class="nx">timersBucket</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">tb</span><span class="p">.</span><span class="nx">gp</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">()</span>
    <span class="c1">// 死循环
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">{</span>
        <span class="c1">// timerBucket 的局部大锁
</span><span class="c1"></span>        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tb</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">// 被唤醒，所以修改 sleeping 状态为 false
</span><span class="c1"></span>        <span class="nx">tb</span><span class="p">.</span><span class="nx">sleeping</span> <span class="p">=</span> <span class="kc">false</span>
        <span class="c1">// 计时
</span><span class="c1"></span>        <span class="nx">now</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
        <span class="nx">delta</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">// 在处理完到期的 timer 之前，一直循环
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">{</span>
            <span class="c1">// 如果 timer 已经都弹出了
</span><span class="c1"></span>            <span class="c1">// 那么不用循环了，跳出后接着睡觉
</span><span class="c1"></span>            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">tb</span><span class="p">.</span><span class="nx">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nx">delta</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="c1">// 取小顶堆顶部元素
</span><span class="c1"></span>            <span class="c1">// 即最近会被触发的 timer
</span><span class="c1"></span>            <span class="nx">t</span> <span class="o">:=</span> <span class="nx">tb</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="nx">delta</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">when</span> <span class="o">-</span> <span class="nx">now</span> <span class="c1">// 还差多长时间才需要触发最近的 timer
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">delta</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="c1">// 大于 0 说明这个 timer 还没到需要触发的时间
</span><span class="c1"></span>                <span class="c1">// 跳出循环去睡觉
</span><span class="c1"></span>                <span class="k">break</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">period</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="c1">// 这个 timer 还会留在堆里
</span><span class="c1"></span>                <span class="c1">// 不过要调整它的下次触发时间
</span><span class="c1"></span>                <span class="nx">t</span><span class="p">.</span><span class="nx">when</span> <span class="o">+=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">period</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="o">-</span><span class="nx">delta</span><span class="o">/</span><span class="nx">t</span><span class="p">.</span><span class="nx">period</span><span class="p">)</span>
                <span class="nf">siftdownTimer</span><span class="p">(</span><span class="nx">tb</span><span class="p">.</span><span class="nx">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 从堆中移除这个 timer
</span><span class="c1"></span>                <span class="c1">// 用最后一个 timer 覆盖第 0 个 timer
</span><span class="c1"></span>                <span class="c1">// 然后向下调整堆
</span><span class="c1"></span>                <span class="nx">last</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">tb</span><span class="p">.</span><span class="nx">t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="nx">last</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="nx">tb</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="nx">tb</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">last</span><span class="p">]</span>
                    <span class="nx">tb</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span>
                <span class="p">}</span>
                <span class="nx">tb</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">last</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
                <span class="nx">tb</span><span class="p">.</span><span class="nx">t</span> <span class="p">=</span> <span class="nx">tb</span><span class="p">.</span><span class="nx">t</span><span class="p">[:</span><span class="nx">last</span><span class="p">]</span>
                <span class="k">if</span> <span class="nx">last</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="nf">siftdownTimer</span><span class="p">(</span><span class="nx">tb</span><span class="p">.</span><span class="nx">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="nx">t</span><span class="p">.</span><span class="nx">i</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">// 标记 timer 在堆中的位置已经没有了
</span><span class="c1"></span>            <span class="p">}</span>
            <span class="c1">// timer 触发时需要调用的函数
</span><span class="c1"></span>            <span class="nx">f</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">f</span>
            <span class="nx">arg</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">arg</span>
            <span class="nx">seq</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">seq</span>
            <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tb</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
            <span class="c1">// 调用需触发的函数
</span><span class="c1"></span>            <span class="nf">f</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span> <span class="nx">seq</span><span class="p">)</span>
            <span class="c1">// 把锁加回来，如果下次 break 了内层的 for 循环
</span><span class="c1"></span>            <span class="c1">// 能保证 timeBucket 是被锁住的
</span><span class="c1"></span>            <span class="c1">// 然后在下面的 goparkunlock 中被解锁
</span><span class="c1"></span>            <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tb</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">delta</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">faketime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="c1">// 说明时间堆里已经没有 timer 了
</span><span class="c1"></span>            <span class="c1">// 让 goroutine 挂起，去睡觉
</span><span class="c1"></span>            <span class="nx">tb</span><span class="p">.</span><span class="nx">rescheduling</span> <span class="p">=</span> <span class="kc">true</span>
            <span class="nf">goparkunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tb</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="s">&#34;timer goroutine (idle)&#34;</span><span class="p">,</span> <span class="nx">traceEvGoBlock</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="c1">// 说明堆里至少还有一个以上的 timer
</span><span class="c1"></span>        <span class="c1">// 睡到最近的 timer 时间
</span><span class="c1"></span>        <span class="nx">tb</span><span class="p">.</span><span class="nx">sleeping</span> <span class="p">=</span> <span class="kc">true</span>
        <span class="nx">tb</span><span class="p">.</span><span class="nx">sleepUntil</span> <span class="p">=</span> <span class="nx">now</span> <span class="o">+</span> <span class="nx">delta</span>
        <span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tb</span><span class="p">.</span><span class="nx">waitnote</span><span class="p">)</span>
        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tb</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">// 内部是 futex sleep
</span><span class="c1"></span>        <span class="c1">// 时间睡到了会自动醒
</span><span class="c1"></span>        <span class="c1">// 或者 addtimer 的时候，发现新的 timer 更早，会提前唤醒
</span><span class="c1"></span>        <span class="nf">notetsleepg</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tb</span><span class="p">.</span><span class="nx">waitnote</span><span class="p">,</span> <span class="nx">delta</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以留意一下这里的 period，有 period 的 timer 会从 when 开始，每隔 period 段时间，就再次触发。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">                                                                                
                                          when+period                           
                                                          when+period*3         
                                             │                                  
                                             │               │                  
                                             │               │                  
                                             │  when+period*2│                  
                                  when       │               │                  
                                             │       │       │                  
                                     │       │       │       │        .....     
                                     │       │       │       │                  
┌───────────┐                        │       │       │       │                  
│ timeline  ├────────────────────────┼───────┼───────┼───────┼─────────────────▷
└───────────┘                        │       │       │       │                  
                                     ▼       ▼       ▼       ▼                  
                                                                                
                                  trigger          trigger                      
                                          trigger          trigger              

</code></pre></td></tr></table>
</div>
</div><h2 id="时间堆调整">时间堆调整</h2>
<p>之前的代码也看到了，时间堆调整有向上调整和向下调整两种调整方式。</p>
<h3 id="向上调整">向上调整</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">siftupTimer</span><span class="p">(</span><span class="nx">t</span> <span class="p">[]</span><span class="o">*</span><span class="nx">timer</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 先暂存当前刚插入到数组尾部的节点
</span><span class="c1"></span>    <span class="nx">when</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">when</span>
    <span class="nx">tmp</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>

    <span class="c1">// 从当前插入节点的父节点开始
</span><span class="c1"></span>    <span class="c1">// 如果最新插入的那个节点的触发时间要比父节点的触发时间更早
</span><span class="c1"></span>    <span class="c1">// 那么就把这个父节点下移
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">p</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span> <span class="c1">// parent
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">when</span> <span class="o">&gt;=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">p</span><span class="p">].</span><span class="nx">when</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span>
        <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">i</span> <span class="p">=</span> <span class="nx">i</span>
        <span class="nx">i</span> <span class="p">=</span> <span class="nx">p</span>
    <span class="p">}</span>

    <span class="c1">// 如果发生过移动，用最新插入的节点
</span><span class="c1"></span>    <span class="c1">// 覆盖掉最后一个下移的父节点
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">tmp</span> <span class="o">!=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">tmp</span>
        <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">i</span> <span class="p">=</span> <span class="nx">i</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="向下调整">向下调整</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">siftdownTimer</span><span class="p">(</span><span class="nx">t</span> <span class="p">[]</span><span class="o">*</span><span class="nx">timer</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
    <span class="nx">when</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">when</span>
    <span class="nx">tmp</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">c</span> <span class="o">:=</span> <span class="nx">i</span><span class="o">*</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// 最左孩子节点
</span><span class="c1"></span>        <span class="nx">c3</span> <span class="o">:=</span> <span class="nx">c</span> <span class="o">+</span> <span class="mi">2</span>  <span class="c1">// 第三个孩子节点
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">c</span> <span class="o">&gt;=</span> <span class="nx">n</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="nx">w</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">c</span><span class="p">].</span><span class="nx">when</span>
        <span class="k">if</span> <span class="nx">c</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">[</span><span class="nx">c</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="nx">when</span> <span class="p">&lt;</span> <span class="nx">w</span> <span class="p">{</span>
            <span class="nx">w</span> <span class="p">=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">c</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="nx">when</span>
            <span class="nx">c</span><span class="o">++</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">c3</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="p">{</span>
            <span class="nx">w3</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">c3</span><span class="p">].</span><span class="nx">when</span>
            <span class="k">if</span> <span class="nx">c3</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">[</span><span class="nx">c3</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="nx">when</span> <span class="p">&lt;</span> <span class="nx">w3</span> <span class="p">{</span>
                <span class="nx">w3</span> <span class="p">=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">c3</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="nx">when</span>
                <span class="nx">c3</span><span class="o">++</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">w3</span> <span class="p">&lt;</span> <span class="nx">w</span> <span class="p">{</span>
                <span class="nx">w</span> <span class="p">=</span> <span class="nx">w3</span>
                <span class="nx">c</span> <span class="p">=</span> <span class="nx">c3</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">w</span> <span class="o">&gt;=</span> <span class="nx">when</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">c</span><span class="p">]</span>
        <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">i</span> <span class="p">=</span> <span class="nx">i</span>
        <span class="nx">i</span> <span class="p">=</span> <span class="nx">c</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">tmp</span> <span class="o">!=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">tmp</span>
        <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">i</span> <span class="p">=</span> <span class="nx">i</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这段代码实在是称不上优雅，其实就是在所有孩子节点中先找出最小的那一个，如果最小的比当前要下移的节点还要大，那么就 break。反之，则将最小的节点上移，然后再判断这个最小节点的 4 个子节点是否都比要下移的节点大。以此类推。用图来模拟一下这个过程:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">                         │            ┌───┐                                       
                         │            │ 5 │                                       
                         │            └───┘                                       
                         │              │                                         
                         │        ┌─────┘                                         
                         │        ▼                                               
                         │      ┌───┬───┳━━━┳───┐                                 
                         │      │ 7 │ 3 │ 2 ┃ 6 │                                 
                         │      └───┴───┻━━━┻───┘                                 
┌───────────────────┐    │                │                                       
│   siftdownTimer   │    │                └──────────┐                            
└───────────────────┘    │                           ▼                            
     .─────────.         │                         ┌───┬───┬───┳━━━┓              
    (  before   )        │                         │ 4 │ 5 │ 9 │ 3 ┃              
     `─────────&#39;         │                         └───┴───┴───┻━━━┛              
                         │                                       │                
                         │                                       └─────────────┐  
                         │                                                     ▼  
                         │                                       ┌───┬───┬───┳━━━┓
                         │                                       │ 6 │ 6 │ 6 │ 4 ┃
                         │                                       └───┴───┴───┻━━━┛
                         │                                                        
                         ▼                                                        
                                                                                  
                                                                                  
                                                                                  
                         │            ┌───┐                                       
                         │            │ 2 │                                       
                         │            └───┘                                       
                         │              │                                         
                         │        ┌─────┘                                         
                         │        ▼                                               
                         │      ┌───┬───┳━━━┳───┐                                 
                         │      │ 7 │ 3 │ 3 ┃ 6 │                                 
                         │      └───┴───┻━━━┻───┘                                 
┌───────────────────┐    │                │                                       
│   siftdownTimer   │    │                └──────────┐                            
└───────────────────┘    │                           ▼                            
    .─────────.          │                         ┌───┬───┬───┳━━━┓              
   (   after   )         │                         │ 4 │ 5 │ 9 │ 4 ┃              
    `─────────&#39;          │                         └───┴───┴───┻━━━┛              
                         │                                       │                
                         │                                       └─────────────┐  
                         │                                                     ▼  
                         │                                       ┌───┬───┬───┳━━━┓
                         │                                       │ 6 │ 6 │ 6 │ 5 ┃
                         │                                       └───┴───┴───┻━━━┛
                         │                                                        
                         ▼                                                        
</code></pre></td></tr></table>
</div>
</div><h2 id="sleeping">sleeping</h2>
<p>当所有当前的定时器已经被处理，但是在未来一段时间还有需要处理的时候，将会设置成sleeping。它使用了基于OS的同步，所以它会调用一些OS的系统调用来进入睡眠并唤醒goroutine，并且系统调用也意味着它是用OS线程来做这件事的。它使用了 note 结构和下面的函数来达到同步：</p>
<ul>
<li>noteclear -重置 note 状态</li>
<li>notetsleepg -使goroutine进入睡眠直到 notewakeup 被调用或者经过一段时间之后（假设是定时器到下一个定时器之间的时间）。这个函数将 timers.waitnote 赋值给“指向定时器goroutine的指针”</li>
<li>notewakeup -唤醒调用notetsleepg的goroutine</li>
</ul>
<p>如果新的定时器比之前最早的定时器还要早的话，notewakeup 可能会在 addtimerLocked 中被调用。</p>
<h2 id="rescheduling">rescheduling</h2>
<p>当堆中已经没有任何定时器，也就是没有事情干的时候，将会设置成rescheduling。它会利用go 调度器使用goparkunlock函数来使goroutine进入睡眠。不像 notetsleepg，这样不会消耗任何的操作系统资源，但同样的也就不支持“唤醒超时”，因此它不能在 sleeping分支的时候代替 notetsleepg。 而当一个新的定时器通过 addTimerLocked被加进来的时候，就会调用 goready函数来唤醒goroutine。</p>
<h1 id="流程逻辑">流程逻辑</h1>
<h2 id="timerafter">timer.After</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">After</span><span class="p">(</span><span class="nx">d</span> <span class="nx">Duration</span><span class="p">)</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">Time</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">NewTimer</span><span class="p">(</span><span class="nx">d</span><span class="p">).</span><span class="nx">C</span>
<span class="p">}</span>

<span class="c1">// NewTimer creates a new Timer that will send
</span><span class="c1">// the current time on its channel after at least duration d.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewTimer</span><span class="p">(</span><span class="nx">d</span> <span class="nx">Duration</span><span class="p">)</span> <span class="o">*</span><span class="nx">Timer</span> <span class="p">{</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Time</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Timer</span><span class="p">{</span>
        <span class="nx">C</span><span class="p">:</span> <span class="nx">c</span><span class="p">,</span>
        <span class="nx">r</span><span class="p">:</span> <span class="nx">runtimeTimer</span><span class="p">{</span>
            <span class="nx">when</span><span class="p">:</span> <span class="nf">when</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span>
            <span class="nx">f</span><span class="p">:</span>    <span class="nx">sendTime</span><span class="p">,</span>
            <span class="nx">arg</span><span class="p">:</span>  <span class="nx">c</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">}</span>
    <span class="nf">startTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">t</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">startTimer</span><span class="p">(</span><span class="o">*</span><span class="nx">runtimeTimer</span><span class="p">)</span>

<span class="c1">// 时间到后，Golang自动调用sendTime接口，尝试往c通道写入时间
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sendTime</span><span class="p">(</span><span class="nx">c</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">seq</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Non-blocking send of time on c.
</span><span class="c1"></span>	<span class="c1">// Used in NewTimer, it cannot block anyway (buffer).
</span><span class="c1"></span>	<span class="c1">// Used in NewTicker, dropping sends on the floor is
</span><span class="c1"></span>	<span class="c1">// the desired behavior when the reader gets behind,
</span><span class="c1"></span>    <span class="c1">// because the sends are periodic.
</span><span class="c1"></span>    <span class="c1">// 给c通道以非阻塞方式发送时间
</span><span class="c1"></span>    <span class="c1">// 如果被用于NewTimer, 无论如何不能阻塞.
</span><span class="c1"></span>    <span class="c1">// 如果被用于NewTicker，接收方未及时接受时间，则会丢弃掉，因为发送时间是周期性的。
</span><span class="c1"></span>	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">c</span><span class="p">.(</span><span class="kd">chan</span> <span class="nx">Time</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="nf">Now</span><span class="p">():</span>
	<span class="k">default</span><span class="p">:</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>因为 Timer 是一次性的，所以 period 保留默认值 0</p>
<p>这个 startTimer 的实现是在 <code>runtime/time.go</code> 里:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// startTimer adds t to the timer heap.
</span><span class="c1">// 把 t 添加到 timer 堆
</span><span class="c1">//go:linkname startTimer time.startTimer
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">startTimer</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">timer</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">addtimer</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>addtimer 后面的流程之前已经看过了。</p>
<p>而对于NewTimer和After这两种创建方法，则是Timer在超时(timer expire)后，执行一个标准库中内置的函数：sendTime。sendTime将当前当前事件send到timer的时间Channel中，那么说这个动作不会阻塞到timerproc的执行么？答案肯定是不会的.</p>
<p>我们看到NewTimer中创建了一个buffered channel，size = 1。正常情况下，当timer expire，t.C无论是否有goroutine在read，sendTime都可以non-block的将当前时间发送到C中；同时，我们看到sendTime还加了双保险：通过一个select判断c buffer是否已满，一旦满了，直接退出，依然不会block，这种情况在reuse active timer时可能会遇到。</p>
<h2 id="timerafterfunc">Timer.AfterFunc</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// AfterFunc waits for the duration to elapse and then calls f
</span><span class="c1">// in its own goroutine. It returns a Timer that can
</span><span class="c1">// be used to cancel the call using its Stop method.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AfterFunc</span><span class="p">(</span><span class="nx">d</span> <span class="nx">Duration</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="o">*</span><span class="nx">Timer</span> <span class="p">{</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Timer</span><span class="p">{</span>
		<span class="nx">r</span><span class="p">:</span> <span class="nx">runtimeTimer</span><span class="p">{</span>
			<span class="nx">when</span><span class="p">:</span> <span class="nf">when</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span>
			<span class="nx">f</span><span class="p">:</span>    <span class="nx">goFunc</span><span class="p">,</span>
			<span class="nx">arg</span><span class="p">:</span>  <span class="nx">f</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">}</span>
	<span class="nf">startTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">t</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">goFunc</span><span class="p">(</span><span class="nx">arg</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">seq</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">go</span> <span class="nx">arg</span><span class="p">.(</span><span class="kd">func</span><span class="p">())()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意：从AfterFunc源码可以看到，外面传入的f参数并非直接赋值给了内部的f，而是作为wrapper function：goFunc的arg传入的。而goFunc则是启动了一个新的goroutine来执行那个外部传入的f。这是因为timer expire对应的事件处理函数的执行是在go runtime内唯一的timer events maintenance goroutine: timerproc中。为了不block timerproc的执行，必须启动一个新的goroutine。</p>
<h2 id="timertick">timer.Tick</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Tick</span><span class="p">(</span><span class="nx">d</span> <span class="nx">Duration</span><span class="p">)</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">Time</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">d</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">NewTicker</span><span class="p">(</span><span class="nx">d</span><span class="p">).</span><span class="nx">C</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NewTicker 会返回一个 Ticker 对象，其 channel 每隔 period 时间
</span><span class="c1">// 会收到一个时间值
</span><span class="c1">// 如果 receiver 接收慢了，Ticker 会把不需要的 tick drop 掉
</span><span class="c1">// d 必须比 0 大，否则 panic
</span><span class="c1">// Stop ticker 才能释放相关的资源
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewTicker</span><span class="p">(</span><span class="nx">d</span> <span class="nx">Duration</span><span class="p">)</span> <span class="o">*</span><span class="nx">Ticker</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">d</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;non-positive interval for NewTicker&#34;</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Time</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Ticker</span><span class="p">{</span>
        <span class="nx">C</span><span class="p">:</span> <span class="nx">c</span><span class="p">,</span>
        <span class="nx">r</span><span class="p">:</span> <span class="nx">runtimeTimer</span><span class="p">{</span>
            <span class="nx">when</span><span class="p">:</span>   <span class="nf">when</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span>
            <span class="nx">period</span><span class="p">:</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span>
            <span class="nx">f</span><span class="p">:</span>      <span class="nx">sendTime</span><span class="p">,</span>
            <span class="nx">arg</span><span class="p">:</span>    <span class="nx">c</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">}</span>
    <span class="nf">startTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">t</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到， Ticker 和 Timer 的 r 成员就只差在 period 这一个字段上，每隔一个 period 就往 channel 里发数据的就是 Ticker，而 fire and disappear 的就是 Timer。</p>
<h2 id="timerreset">Timer.Reset</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Timer</span><span class="p">)</span> <span class="nf">Reset</span><span class="p">(</span><span class="nx">d</span> <span class="nx">Duration</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nx">f</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;time: Reset called on uninitialized Timer&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">w</span> <span class="o">:=</span> <span class="nf">when</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
    <span class="nx">active</span> <span class="o">:=</span> <span class="nf">stopTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nx">when</span> <span class="p">=</span> <span class="nx">w</span>
    <span class="nf">startTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">active</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>都是见过的函数，没啥特别的。</p>
<h2 id="timerstop--tickerstop">Timer.Stop &amp; Ticker.Stop</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Ticker</span><span class="p">)</span> <span class="nf">Stop</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">stopTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Timer</span><span class="p">)</span> <span class="nf">Stop</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nx">f</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;time: Stop called on uninitialized Timer&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">stopTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Timer 和 Ticker 都是调用的 stopTimer。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">stopTimer</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">timer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">deltimer</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>deltimer 在上面也看到过了。</p>
<h1 id="timer的资源释放">Timer的资源释放</h1>
<p>很多Go初学者在使用Timer时都会担忧Timer的创建会占用系统资源，比如：</p>
<ul>
<li>创建一个Timer后，runtime会创建一个单独的Goroutine去计时并在expire后发送当前时间到channel里。</li>
<li>创建一个timer后，runtime会申请一个os级别的定时器资源去完成计时工作。</li>
</ul>
<p>go runtime实际上仅仅是启动了一个单独的goroutine，运行timerproc函数，维护了一个”最小堆”，定期wake up后，读取堆顶的timer，执行timer对应的f函数，并移除该timer element。创建一个Timer实则就是在这个最小堆中添加一个element，Stop一个timer，则是从堆中删除对应的element。</p>
<p>同时，从上面的两个Timer常见的使用场景中代码来看，我们并没有显式的去释放什么。Timer在创建后可能占用的资源还包括：</p>
<ul>
<li>0或一个Channel</li>
<li>0或一个Goroutine</li>
</ul>
<p>这些资源都会在timer使用后被GC回收。</p>
<p>综上，作为Timer的使用者，我们要做的就是尽量减少在使用Timer时对最小堆管理goroutine和GC的压力即可，即：及时调用timer的Stop方法从最小堆删除timer element(如果timer 没有expire)以及reuse active timer。</p>
<p>参考:<br>
<a href="https://www.jianshu.com/p/ac94989215d6">https://www.jianshu.com/p/ac94989215d6</a><br>
<a href="https://tonybai.com/2016/12/21/how-to-use-timer-reset-in-golang-correctly/">https://tonybai.com/2016/12/21/how-to-use-timer-reset-in-golang-correctly/</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2019-10-21
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go/">Go</a>
          <a href="/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/">定时器</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go%E7%9A%84timer%E5%92%8Cticker%E7%94%A8%E6%B3%95/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go的timer和ticker用法</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/linux%E5%86%85%E6%A0%B8%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0/">
            <span class="next-text nav-default">Linux内核时钟系统和定时器实现</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Forz</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
