<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Binary Search Tree | Forz Blog</title>
<meta name="keywords" content="DFS, BST" />
<meta name="description" content="LeetCode 230. Kth Smallest Element in a BST Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. 解析：中序遍历BST就可以得到一个有序数组，题目要找Kth，就直接中序遍历，在输出的字符串">
<meta name="author" content="">
<link rel="canonical" href="/post/binary-search-tree/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Binary Search Tree" />
<meta property="og:description" content="LeetCode 230. Kth Smallest Element in a BST Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. 解析：中序遍历BST就可以得到一个有序数组，题目要找Kth，就直接中序遍历，在输出的字符串" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/binary-search-tree/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-25T02:26:31&#43;00:00" />
<meta property="article:modified_time" content="2019-09-29T20:52:47&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Binary Search Tree"/>
<meta name="twitter:description" content="LeetCode 230. Kth Smallest Element in a BST Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. 解析：中序遍历BST就可以得到一个有序数组，题目要找Kth，就直接中序遍历，在输出的字符串"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Binary Search Tree",
      "item": "/post/binary-search-tree/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Binary Search Tree",
  "name": "Binary Search Tree",
  "description": "LeetCode 230. Kth Smallest Element in a BST Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. 解析：中序遍历BST就可以得到一个有序数组，题目要找Kth，就直接中序遍历，在输出的字符串",
  "keywords": [
    "DFS", "BST"
  ],
  "articleBody": "LeetCode 230. Kth Smallest Element in a BST Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.\n解析：中序遍历BST就可以得到一个有序数组，题目要找Kth，就直接中序遍历，在输出的字符串中找Kth。此处有一个优化技巧，提前计算每个节点的左子树的子节点的数量，就不需要全部遍历再按序查找。直接在树中找到结果，算是一个变相的二分查找。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int calcTreeSize(TreeNode* root){ if (root == NULL) return 0; return 1+calcTreeSize(root-left) + calcTreeSize(root-right); } int kthSmallest(TreeNode* root, int k) {//中序遍历可以得到排序结果  if (root == NULL) return 0; int leftSize = calcTreeSize(root-left); //计算左节点个数  if (k == leftSize+1){ //结果就是根节点  return root-val; }else if (leftSize = k){ //结果在左子树中  return kthSmallest(root-left,k); }else{ //结果在右子树中  return kthSmallest(root-right, k-leftSize-1); } } };   LeetCode 501. Find Mode in Binary Search Tree Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.\nAssume a BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than or equal to the node’s key. The right subtree of a node contains only nodes with keys greater than or equal to the node’s key. Both the left and right subtrees must also be binary search trees.\n解析：二叉搜索树的中序遍历的结果恰好是所有数的递增序列，根据中序遍历结果。中序遍历整棵树，相当于遍历一个递增数组，设2个全局变量保存最大值和出现次数，设2个局部变量保存当前数值和累计出现次数。然后像数组处理那样做就行了。不需要返回值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vectorint findMode(TreeNode* root) { inorder(root); return result; } private: vectorint result; int maxCount = 0, currentVal, tempCount = 0; //标记maxCount为最大出现次数，tempCount为当前数字出现的次数，currentVal为当前保存的值。  void inorder(TreeNode* root) { if (root == NULL) return;//递归终止条件  inorder(root-left); if (root-val != currentVal) {//当前值为新值，重置计数  currentVal = root-val; tempCount = 0; } tempCount++; if (tempCount  maxCount) {//如果当前值最大，清空结果数组并维护最大值  maxCount = tempCount; result.clear(); result.push_back(root-val); } else if (tempCount == maxCount) {//如果相等，直接放入  result.push_back(root-val); } inorder(root-right); } };   LeetCode 173. Binary Search Tree Iterator Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.\nCalling next() will return the next smallest number in the BST.\nNote: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.\n解析：此题为设计题，要求实现迭代器。next()寻找次小的元素。根据先序遍历可以形成有序数组的性质，将中序遍历的递推方法拆分一下就可以得到本题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  /** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class BSTIterator { public: stackTreeNode * snode; TreeNode * t; BSTIterator(TreeNode *root) {//构造函数找到最小值 //在搜索最小值的时候，先把根节点开始的左子叶放入栈中，那么这时栈顶的元素（假设为a）就是最小值。  t=root; while(t!=NULL) { snode.push(t); t=t-left;//注意：最小值是没有入栈的，只保存在t内  } } /** @return whether we have a next smallest number */ bool hasNext() { //只要栈不空，就还存在次小的节点  if(snode.empty()) return false; else return true; } /** @return the next smallest number */ int next() { //当寻找下一个最小值时就不是栈内的下一个元素了（栈顶元素设为a，栈内下一个设为b），这时a为b的左子叶， //当a存在右子叶时，a右子叶下面的值一定小于b的值，因为a为b左子叶。所以这时还需要将a的右子叶及右子叶 //下的所有左子叶压栈。  int result; t = snode.top();栈顶节点就是所求结果，将b更新为a result=t-val; snode.pop();//a出栈  if(t-right != NULL){//处理a的右子树，维护栈，使栈顶保存次小值  t = t-right;//右孩子  while(t){//右孩子的最左端  snode.push(t); t = t-left; } } return result; } }; /** * Your BSTIterator will be called like this: * BSTIterator i = BSTIterator(root); * while (i.hasNext()) cout */   LeetCode 284. Peeking Iterator Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation – it essentially peek() at the element that will be returned by the next call to next().\nHere is an example. Assume that the iterator is initialized to the beginning of the list: [1, 2, 3].\nCall next() gets you 1, the first element in the list.\nNow you call peek() and it returns 2, the next element. Calling next() after that still return 2.\nYou call next() the final time and it returns 3, the last element. Calling hasNext() after that should return false.\n解析：给定一个派生类，这个派生类只继承了基类的next()和hasNext()方法，现在要求重写派生类的next(),hasNext()和peek() ，方法peek()始终取next指针的后一个元素,并且不能移动next指针，重点在于peek函数是否被调用直接影响到next的操作，所以用一个vis标志来记录是否执行过peek即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  // Below is the interface for Iterator, which is already defined for you. // **DO NOT** modify the interface for Iterator. class Iterator { struct Data; Data* data; public: Iterator(const vectorint\u0026 nums); Iterator(const Iterator\u0026 iter); virtual ~Iterator(); // Returns the next element in the iteration. int next(); // Returns true if the iteration has more elements. bool hasNext() const; }; class PeekingIterator : public Iterator { private: int cache;//保存peek操作后得到的值，也就是next所指元素的下一位 int isvis;//表示指针是否正常（是否执行过peek） public: PeekingIterator(const vectorint\u0026 nums) : Iterator(nums) { // Initialize any member here.  // **DO NOT** save a copy of nums and manipulate it directly.  // You should only use the Iterator interface methods.  isvis=0; } // Returns the next element in the iteration without advancing the iterator. int peek() { if(!isvis){ isvis=1; return cache=Iterator::next(); } else return cache; } // hasNext() and next() should behave the same as in the Iterator interface. // Override them if needed. int next() { if(!isvis) return Iterator::next(); //isvis=0，说明没有用peek，next指针指向正确的位置，调用next()，取得下一个值并移动指针  else{ //isvis=1，说明用了peek，next指针指向的是正确位置的下一个位置，不能调用next()，因为指针其实已经被peek移动过  isvis=0; return cache; } } bool hasNext() const { if(isvis) return true;//如果sivis为真，肯定有  return Iterator::hasNext();//否则利用基类函数 } };   ",
  "wordCount" : "2148",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-25T02:26:31Z",
  "dateModified": "2019-09-29T20:52:47+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/binary-search-tree/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Binary Search Tree
    </h1>
    <div class="post-meta">June 25, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="leetcode-230-kth-smallest-element-in-a-bst">LeetCode 230. Kth Smallest Element in a BST<a hidden class="anchor" aria-hidden="true" href="#leetcode-230-kth-smallest-element-in-a-bst">#</a></h1>
<p>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.</p>
<p>解析：中序遍历BST就可以得到一个有序数组，题目要找Kth，就直接中序遍历，在输出的字符串中找Kth。此处有一个优化技巧，提前计算每个节点的左子树的子节点的数量，就不需要全部遍历再按序查找。直接在树中找到结果，算是一个变相的二分查找。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>  
<span class="nl">public</span><span class="p">:</span>  
<span class="kt">int</span> <span class="n">calcTreeSize</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>  
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
    <span class="k">return</span> <span class="mi">1</span><span class="o">+</span><span class="n">calcTreeSize</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">calcTreeSize</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>          
<span class="p">}</span>  
<span class="kt">int</span> <span class="n">kthSmallest</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span><span class="c1">//中序遍历可以得到排序结果  
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>  
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">leftSize</span> <span class="o">=</span> <span class="n">calcTreeSize</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>  <span class="c1">//计算左节点个数
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">leftSize</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>  <span class="c1">//结果就是根节点
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>  
    <span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">leftSize</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">){</span>  <span class="c1">//结果在左子树中
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">kthSmallest</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span><span class="n">k</span><span class="p">);</span>  
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>  <span class="c1">//结果在右子树中
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">kthSmallest</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="n">leftSize</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>  
    <span class="p">}</span>  
<span class="p">}</span>  
<span class="p">};</span>  
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-501-find-mode-in-binary-search-tree">LeetCode 501. Find Mode in Binary Search Tree<a hidden class="anchor" aria-hidden="true" href="#leetcode-501-find-mode-in-binary-search-tree">#</a></h1>
<p>Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.</p>
<p>Assume a BST is defined as follows:</p>
<p>The left subtree of a node contains only nodes with keys less than or equal to the node’s key.
The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.
Both the left and right subtrees must also be binary search trees.</p>
<p>解析：二叉搜索树的中序遍历的结果恰好是所有数的递增序列，根据中序遍历结果。中序遍历整棵树，相当于遍历一个递增数组，设2个全局变量保存最大值和出现次数，设2个局部变量保存当前数值和累计出现次数。然后像数组处理那样做就行了。不需要返回值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">findMode</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">private</span><span class="p">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">maxCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">currentVal</span><span class="p">,</span> <span class="n">tempCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">//标记maxCount为最大出现次数，tempCount为当前数字出现的次数，currentVal为当前保存的值。
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span><span class="c1">//递归终止条件
</span><span class="c1"></span>        <span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="n">currentVal</span><span class="p">)</span> <span class="p">{</span><span class="c1">//当前值为新值，重置计数
</span><span class="c1"></span>            <span class="n">currentVal</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
            <span class="n">tempCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">tempCount</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tempCount</span> <span class="o">&gt;</span> <span class="n">maxCount</span><span class="p">)</span> <span class="p">{</span><span class="c1">//如果当前值最大，清空结果数组并维护最大值
</span><span class="c1"></span>            <span class="n">maxCount</span> <span class="o">=</span> <span class="n">tempCount</span><span class="p">;</span>
            <span class="n">result</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tempCount</span> <span class="o">==</span> <span class="n">maxCount</span><span class="p">)</span> <span class="p">{</span><span class="c1">//如果相等，直接放入
</span><span class="c1"></span>            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-173-binary-search-tree-iterator">LeetCode 173. Binary Search Tree Iterator<a hidden class="anchor" aria-hidden="true" href="#leetcode-173-binary-search-tree-iterator">#</a></h1>
<p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>
<p>Calling next() will return the next smallest number in the BST.</p>
<p>Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.</p>
<p>解析：此题为设计题，要求实现迭代器。next()寻找次小的元素。根据先序遍历可以形成有序数组的性质，将中序遍历的递推方法拆分一下就可以得到本题。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for binary tree
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>

<span class="n">class</span> <span class="n">BSTIterator</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">snode</span><span class="p">;</span>
<span class="n">TreeNode</span> <span class="o">*</span> <span class="n">t</span><span class="p">;</span>
<span class="n">BSTIterator</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span><span class="c1">//构造函数找到最小值
</span><span class="c1">//在搜索最小值的时候，先把根节点开始的左子叶放入栈中，那么这时栈顶的元素（假设为a）就是最小值。
</span><span class="c1"></span>    <span class="n">t</span><span class="o">=</span><span class="n">root</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">t</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">snode</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
        <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span><span class="c1">//注意：最小值是没有入栈的，只保存在t内
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/** @return whether we have a next smallest number */</span>
<span class="kt">bool</span> <span class="n">hasNext</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//只要栈不空，就还存在次小的节点
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">snode</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** @return the next smallest number */</span>
<span class="kt">int</span> <span class="n">next</span><span class="p">()</span> <span class="p">{</span>
<span class="c1">//当寻找下一个最小值时就不是栈内的下一个元素了（栈顶元素设为a，栈内下一个设为b），这时a为b的左子叶，
</span><span class="c1">//当a存在右子叶时，a右子叶下面的值一定小于b的值，因为a为b左子叶。所以这时还需要将a的右子叶及右子叶
</span><span class="c1">//下的所有左子叶压栈。
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
     <span class="n">t</span> <span class="o">=</span> <span class="n">snode</span><span class="p">.</span><span class="n">top</span><span class="p">();</span><span class="err">栈顶节点就是所求结果，将</span><span class="n">b更新为a</span>
     <span class="n">result</span><span class="o">=</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
     <span class="n">snode</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="c1">//a出栈
</span><span class="c1"></span>     <span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span><span class="c1">//处理a的右子树，维护栈，使栈顶保存次小值
</span><span class="c1"></span>        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span><span class="c1">//右孩子
</span><span class="c1"></span>        <span class="k">while</span><span class="p">(</span><span class="n">t</span><span class="p">){</span><span class="c1">//右孩子的最左端
</span><span class="c1"></span>            <span class="n">snode</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
<span class="cm">/**
</span><span class="cm"> * Your BSTIterator will be called like this:
</span><span class="cm"> * BSTIterator i = BSTIterator(root);
</span><span class="cm"> * while (i.hasNext()) cout &lt;&lt; i.next();
</span><span class="cm"> */</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-284-peeking-iterator">LeetCode 284. Peeking Iterator<a hidden class="anchor" aria-hidden="true" href="#leetcode-284-peeking-iterator">#</a></h1>
<p>Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation – it essentially peek() at the element that will be returned by the next call to next().</p>
<p>Here is an example. Assume that the iterator is initialized to the beginning of the list: [1, 2, 3].</p>
<p>Call next() gets you 1, the first element in the list.</p>
<p>Now you call peek() and it returns 2, the next element. Calling next() after that still return 2.</p>
<p>You call next() the final time and it returns 3, the last element. Calling hasNext() after that should return false.</p>
<p>解析：给定一个派生类，这个派生类只继承了基类的next()和hasNext()方法，现在要求重写派生类的next(),hasNext()和peek() ，方法peek()始终取next指针的后一个元素,并且不能移动next指针，重点在于peek函数是否被调用直接影响到next的操作，所以用一个vis标志来记录是否执行过peek即可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">// Below is the interface for Iterator, which is already defined for you.
</span><span class="c1">// **DO NOT** modify the interface for Iterator.
</span><span class="c1"></span><span class="n">class</span> <span class="n">Iterator</span> <span class="p">{</span>
<span class="k">struct</span> <span class="n">Data</span><span class="p">;</span>
<span class="n">Data</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">Iterator</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">);</span>
<span class="n">Iterator</span><span class="p">(</span><span class="k">const</span> <span class="n">Iterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">);</span>
<span class="n">virtual</span> <span class="o">~</span><span class="n">Iterator</span><span class="p">();</span>
<span class="c1">// Returns the next element in the iteration.
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">next</span><span class="p">();</span>
<span class="c1">// Returns true if the iteration has more elements.
</span><span class="c1"></span><span class="kt">bool</span> <span class="nf">hasNext</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>


<span class="n">class</span> <span class="nl">PeekingIterator</span> <span class="p">:</span> <span class="n">public</span> <span class="n">Iterator</span> <span class="p">{</span>
<span class="nl">private</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">cache</span><span class="p">;</span><span class="c1">//保存peek操作后得到的值，也就是next所指元素的下一位
</span><span class="c1"></span><span class="kt">int</span> <span class="n">isvis</span><span class="p">;</span><span class="c1">//表示指针是否正常（是否执行过peek）
</span><span class="c1"></span><span class="nl">public</span><span class="p">:</span>
<span class="n">PeekingIterator</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="o">:</span> <span class="n">Iterator</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Initialize any member here.
</span><span class="c1"></span>    <span class="c1">// **DO NOT** save a copy of nums and manipulate it directly.
</span><span class="c1"></span>    <span class="c1">// You should only use the Iterator interface methods.
</span><span class="c1"></span>    <span class="n">isvis</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Returns the next element in the iteration without advancing the iterator.
</span><span class="c1"></span><span class="kt">int</span> <span class="n">peek</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">isvis</span><span class="p">){</span>
        <span class="n">isvis</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">cache</span><span class="o">=</span><span class="n">Iterator</span><span class="o">::</span><span class="n">next</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">return</span> <span class="n">cache</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// hasNext() and next() should behave the same as in the Iterator interface.
</span><span class="c1">// Override them if needed.
</span><span class="c1"></span><span class="kt">int</span> <span class="n">next</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">isvis</span><span class="p">)</span> <span class="k">return</span> <span class="n">Iterator</span><span class="o">::</span><span class="n">next</span><span class="p">();</span>
<span class="c1">//isvis=0，说明没有用peek，next指针指向正确的位置，调用next()，取得下一个值并移动指针
</span><span class="c1"></span>    <span class="k">else</span><span class="p">{</span>
<span class="c1">//isvis=1，说明用了peek，next指针指向的是正确位置的下一个位置，不能调用next()，因为指针其实已经被peek移动过
</span><span class="c1"></span>        <span class="n">isvis</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">cache</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="n">hasNext</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">isvis</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span><span class="c1">//如果sivis为真，肯定有
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">Iterator</span><span class="o">::</span><span class="n">hasNext</span><span class="p">();</span><span class="c1">//否则利用基类函数
</span><span class="c1"></span><span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/dfs/">DFS</a></li>
      <li><a href="/tags/bst/">BST</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
