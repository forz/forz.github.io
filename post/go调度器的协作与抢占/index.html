<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go调度器的协作与抢占 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="前言 如果某个 G 执行时间过长，其他的 G 如何才能被正常的调度？ 这便涉及到有关调度的两个理念：协作式调度与抢占式调度。 协作式和抢占式这两个理念解释" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.91.2 with theme even" />


<link rel="canonical" href="/post/go%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E5%8D%8F%E4%BD%9C%E4%B8%8E%E6%8A%A2%E5%8D%A0/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go调度器的协作与抢占" />
<meta property="og:description" content="前言 如果某个 G 执行时间过长，其他的 G 如何才能被正常的调度？ 这便涉及到有关调度的两个理念：协作式调度与抢占式调度。 协作式和抢占式这两个理念解释" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E5%8D%8F%E4%BD%9C%E4%B8%8E%E6%8A%A2%E5%8D%A0/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-11-27T17:25:33+00:00" />
<meta property="article:modified_time" content="2020-11-27T17:25:33+00:00" />

<meta itemprop="name" content="Go调度器的协作与抢占">
<meta itemprop="description" content="前言 如果某个 G 执行时间过长，其他的 G 如何才能被正常的调度？ 这便涉及到有关调度的两个理念：协作式调度与抢占式调度。 协作式和抢占式这两个理念解释"><meta itemprop="datePublished" content="2020-11-27T17:25:33+00:00" />
<meta itemprop="dateModified" content="2020-11-27T17:25:33+00:00" />
<meta itemprop="wordCount" content="10849">
<meta itemprop="keywords" content="Go源码," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go调度器的协作与抢占"/>
<meta name="twitter:description" content="前言 如果某个 G 执行时间过长，其他的 G 如何才能被正常的调度？ 这便涉及到有关调度的两个理念：协作式调度与抢占式调度。 协作式和抢占式这两个理念解释"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go调度器的协作与抢占</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-11-27 </span>
        <div class="post-category">
            <a href="/categories/go%E6%BA%90%E7%A0%81/"> Go源码 </a>
            </div>
          <span class="more-meta"> 约 10849 字 </span>
          <span class="more-meta"> 预计阅读 22 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#协作式调度">协作式调度</a>
      <ul>
        <li><a href="#主动用户让权gosched">主动用户让权：Gosched</a></li>
        <li><a href="#主动调度弃权栈扩张与抢占标记">主动调度弃权：栈扩张与抢占标记</a></li>
      </ul>
    </li>
    <li><a href="#基于协作的抢占式调度preemptone">基于协作的抢占式调度(preemptone)</a>
      <ul>
        <li><a href="#设计原理">设计原理</a></li>
        <li><a href="#源码剖析">源码剖析</a></li>
      </ul>
    </li>
    <li><a href="#基于信号的抢占式调度preemptm">基于信号的抢占式调度(preemptM)</a>
      <ul>
        <li><a href="#抢占信号的选取">抢占信号的选取</a></li>
        <li><a href="#抢占调用的注入">抢占调用的注入</a></li>
        <li><a href="#sysmon抢占gopreempt_m">sysmon抢占(gopreempt_m)</a></li>
        <li><a href="#gc抢占preemptpark">GC抢占(preemptPark)</a></li>
      </ul>
    </li>
    <li><a href="#小结">小结</a></li>
    <li><a href="#转载">转载</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="前言">前言</h2>
<p>如果某个 G 执行时间过长，其他的 G 如何才能被正常的调度？ 这便涉及到有关调度的两个理念：协作式调度与抢占式调度。</p>
<p>协作式和抢占式这两个理念解释起来很简单： 协作式调度依靠被调度方主动弃权；抢占式调度则依靠调度器强制将被调度方被动中断。 这两个概念其实描述了调度的两种截然不同的策略，这两种决策模式，在调度理论中其实已经研究得很透彻了。</p>
<p>Go 的运行时并不具备操作系统内核级的硬件中断能力，基于工作窃取的调度器实现，本质上属于 先来先服务的协作式调度，为了解决响应时间可能较高的问题，目前运行时实现了两种不同的调度策略、 每种策略各两个形式。保证在大部分情况下，不同的 G 能够获得均匀的时间片：</p>
<ul>
<li>同步协作式调度
<ol>
<li>主动用户让权：通过 runtime.Gosched 调用主动让出执行机会；</li>
<li>主动调度弃权：当发生执行栈分段时，检查自身的抢占标记，决定是否继续执行；</li>
</ol>
</li>
<li>异步抢占式调度
<ol>
<li>被动监控抢占：P长时间运行或进行系统调用，系统监控会将 P 从 M 上抢夺并分配给其他的 M 来执行其他的 G，而位于被抢夺 P 的 M 本地调度队列中 的 G 则可能会被偷取到其他 M 中。</li>
<li>被动 GC 抢占：当需要进行垃圾回收时，为了保证不具备主动抢占处理的函数执行时间过长，导致垃圾回收迟迟不得执行而导致的高延迟，而强制停止 G 并转为执行垃圾回收,该抢占在第一次STW时进行.</li>
</ol>
</li>
</ul>
<h2 id="协作式调度">协作式调度</h2>
<h3 id="主动用户让权gosched">主动用户让权：Gosched</h3>
<p>Gosched 是一种主动放弃执行的手段，用户态代码通过调用此接口来出让执行机会，使其他人也能在 密集的执行过程中获得被调度的机会。</p>
<p>当然，尽管具有主动弃权的能力，但它对 Go 语言的用户要求比较高， 因为用户在编写并发逻辑的时候需要自行甄别是否需要让出时间片，这并非用户友好的， 而且很多 Go 的新用户并不会了解到这个问题的存在，我们在随后的抢占式调度中再进一步展开讨论。</p>
<h3 id="主动调度弃权栈扩张与抢占标记">主动调度弃权：栈扩张与抢占标记</h3>
<p>另一种主动放弃的方式是通过抢占标记的方式实现的。基本想法是在每个函数调用的序言 （函数调用的最前方）插入抢占检测指令，当检测到当前 Goroutine 被标记为被应该被抢占时， 则主动中断执行，让出执行权利。</p>
<h2 id="基于协作的抢占式调度preemptone">基于协作的抢占式调度(preemptone)</h2>
<h3 id="设计原理">设计原理</h3>
<p>我们知道现代操作系统的调度器多为抢占式调度，其实现方式通过硬件中断来支持线程的切换， 进而能安全的保存运行上下文。在 Go 运行时实现抢占式调度同样也可以使用类似的方式，通过 向线程发送系统信号的方式来中断 M 的执行，进而达到抢占的目的。 但与操作系统的不同之处在于，由于运行时诸多机制的存在（例如垃圾回收器），还必须能够在 Goroutine 被停止时，保存充足的上下文信息。 这就给中断信号带来了麻烦，如果中断信号恰好发生在一些关键阶段（例如写屏障期间）， 则无法保证程序的正确性。这也就要求我们需要严格考虑触发异步抢占的时机。</p>
<p>异步抢占式调度的一种方式就与运行时系统监控有关，监控循环会将发生阻塞的 Goroutine 抢占， 解绑 P 与 M，从而让其他的线程能够获得 P 继续执行其他的 Goroutine。 这得益于 sysmon 中调用的 retake 方法。这个方法处理了两种抢占情况， 一是抢占阻塞在系统调用上的 P，二是抢占运行时间过长的 G。 其中抢占运行时间过长的 G 这一方式还会出现在垃圾回收需要进入 STW 时。</p>
<p>我们可以在 pkg/runtime/proc.c 文件中找到引入基于协作的抢占式调度后的调度器。Go 语言会在分段栈的机制上实现抢占调度，利用编译器在分段栈上插入的函数，所有 Goroutine 在函数调用时都有机会进入运行时检查是否需要执行抢占。Go 团队通过以下的多个提交实现该特性：</p>
<ul>
<li>runtime: add stackguard0 to G
<ul>
<li>为 Goroutine 引入 stackguard0 字段，该字段被设置成 StackPreempt 意味着当前 Goroutine 发出了抢占请求；</li>
</ul>
</li>
<li>runtime: introduce preemption function (not used for now)
<ul>
<li>引入抢占函数 runtime.preemptone 和 runtime.preemptall，这两个函数会改变 Goroutine 的 stackguard0 字段发出抢占请求；</li>
<li>定义抢占请求 StackPreempt；</li>
</ul>
</li>
<li>runtime: preempt goroutines for GC
<ul>
<li>在 runtime.stoptheworld 中调用 runtime.preemptall 设置所有处理器上正在运行的 Goroutine 的 stackguard0 为 StackPreempt；</li>
<li>在 runtime.newstack 函数中增加抢占的代码，当 stackguard0 等于 StackPreempt 时触发调度器抢占让出线程；</li>
</ul>
</li>
<li>runtime: preempt long-running goroutines
<ul>
<li>在系统监控中，如果一个 Goroutine 的运行时间超过 10ms，就会调用 runtime.retake 和 runtime.preemptone；</li>
</ul>
</li>
<li>runtime: more reliable preemption
<ul>
<li>修复 Goroutine 因为周期性执行非阻塞的 CGO 或者系统调用不会被抢占的问题；</li>
</ul>
</li>
</ul>
<p>上面的多个提交实现了抢占式调度，但是还缺少最关键的一个环节 — 编译器如何在函数调用前插入函数，我们能在非常古老的提交 runtime: stack growth adjustments, cleanup 中找到编译器插入函数的出行，最新版本的 Go 语言会通过 cmd/internal/obj/x86.stacksplit 插入 runtime.morestack 函数，该函数可能会调用 runtime.newstack 触发抢占。从上面的多个提交中，我们能归纳出基于协作的抢占式调度的工作原理：</p>
<ol>
<li>编译器会在调用函数前插入 runtime.morestack；</li>
<li>Go 语言运行时会在垃圾回收暂停程序、系统监控发现 Goroutine 运行超过 10ms 时发出抢占请求 StackPreempt；</li>
<li>当发生函数调用时，可能会执行编译器插入的 runtime.morestack 函数，它调用的 runtime.newstack 会检查 Goroutine 的 stackguard0 字段是否为 StackPreempt；</li>
<li>如果 stackguard0 是 StackPreempt，就会触发抢占让出当前线程；</li>
</ol>
<p>这种实现方式虽然增加了运行时的复杂度，但是实现相对简单，也没有带来过多的额外开销，总体来看还是比较成功的实现，也在 Go 语言中使用了 10 几个版本。因为这里的抢占是通过编译器插入函数实现的，还是需要函数调用作为入口才能触发抢占，所以这是一种协作式的抢占式调度。</p>
<h3 id="源码剖析">源码剖析</h3>
<p>preemptone 本质是将正在 P 上执行的 M 的 curg 的标志位置为 true.这之后的流程需要正在运行的 goroutine 来配合.</p>
<p>调用preemptone函数抢占该P，这也是go抢占式调度的体现。不过该函数只能告知在这个P上运行的G应该停止了。首先它不一定能正确的告知正确的G，其次即使告知被正确传递给了正确的G，这个G也可能忽略掉这个告知。也就是说preemptone函数只能告诉你我尽力而为，既不能保证告知正确到达，也不能保证那个G做出相应。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Tell the goroutine running on processor P to stop.
</span><span class="c1">// This function is purely best-effort. It can incorrectly fail to inform the
</span><span class="c1">// goroutine. It can send inform the wrong goroutine. Even if it informs the
</span><span class="c1">// correct goroutine, that goroutine might ignore the request if it is
</span><span class="c1">// simultaneously executing newstack.
</span><span class="c1">// No lock needs to be held.
</span><span class="c1">// Returns true if preemption request was issued.
</span><span class="c1">// The actual preemption will happen at some point in the future
</span><span class="c1">// and will be indicated by the gp-&gt;status no longer being
</span><span class="c1">// Grunning
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">preemptone</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// 检查 M 与 P 是否绑定
</span><span class="c1"></span>	<span class="nx">mp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">mp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">mp</span> <span class="o">==</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">curg</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">gp</span> <span class="o">==</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">// 将 G 标记为抢占
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">true</span>

	<span class="c1">// Every call in a go routine checks for stack overflow by
</span><span class="c1"></span>	<span class="c1">// comparing the current stack pointer to gp-&gt;stackguard0.
</span><span class="c1"></span>	<span class="c1">// Setting gp-&gt;stackguard0 to StackPreempt folds
</span><span class="c1"></span>	<span class="c1">// preemption into the normal stack overflow check.
</span><span class="c1"></span>	<span class="c1">// 一个 Goroutine 中的每个调用都会通过比较当前栈指针和 gp.stackgard0
</span><span class="c1"></span>	<span class="c1">// 来检查栈是否溢出。
</span><span class="c1"></span>	<span class="c1">// 设置 gp.stackgard0 为 StackPreempt 来将抢占转换为正常的栈溢出检查。
</span><span class="c1"></span>	<span class="c1">// 在 goroutine 内部的每次调用都会比较栈顶指针和 g.stackguard0，
</span><span class="c1"></span>    	<span class="c1">// 来判断是否发生了栈溢出。stackPreempt 非常大的一个数，比任何栈都大
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span>

	<span class="c1">// Request an async preemption of this P.
</span><span class="c1"></span>	<span class="c1">// 请求该 P 的异步抢占
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">preemptMSupported</span> <span class="o">&amp;&amp;</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">asyncpreemptoff</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nf">preemptM</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>有两个标志,实际起作用的是G.stackguard0. G.preempt只是后备,以便在stackguard()做回溢出检查标志时,依然可用preempt恢复抢占状态.</p>
<p>当morestack调用newstack扩容时会检查抢占标志,并决定是否暂停当前任务,当然这发生在实际扩容之前.</p>
<p>go程序在执行G的每次调用时，都会通过比较当前堆栈指针和G的stackguard0字段来判断栈溢出。这里将当前G的stackguard0字段赋值为stackPreempt就会该G在下一次函数调用时栈空间检查失败，接下来就是一些列的函数调用，最终将这个G调度出去。</p>
<p>在讲述这一些列函数调用之前，我们先来认识一下stackPreempt。</p>
<p>它是在stack.go中定义的一个常量。在64位机器上，stackPreempt的值是0xfffffffffffffade，在32位机器上它的值是0xfffffade。表示的是栈指针sp的最大值，所以现在你知道为什么将stackguard0的值设置成它就能导致栈溢出了吧。它的计算出来需要用到uintptrMask，它是一个指针掩码，也就是一个所有位全为1的指针，32位机器上是0xffffffff，64位机器上是0xffffffffffffffff。在计算uintptrMask时用到的sys.PtrSize在sys包中的stubs.go文件中定义。^uintptr(0)得到的是一个各位都为1的值，32位机器上就是32个1,64位机器上就是64个1。左移63位后，如果是32位机器，结果就是0，接下来4右移0位还是4；64位机器结果是1，4右移1位后结果是8。所以PtrSize表示的就是一个指针长度的字节数。而一个字节的长度是8，所以在计算uintptrMask时用8乘以sys.PtrSize得到的就是一个指针的位数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="cm">/* stack.go */</span>
<span class="c1">// Goroutine 抢占请求
</span><span class="c1">// 存储到 g.stackguard0 来导致栈分段检查失败
</span><span class="c1">// 必须比任何实际的 SP 都要大
</span><span class="c1">// 十六进制为：0xfffffade
</span><span class="c1"></span><span class="kd">const</span> <span class="p">(</span>
   <span class="nx">uintptrMask</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="nx">stackPreempt</span> <span class="p">=</span> <span class="nx">uintptrMask</span> <span class="o">&amp;</span> <span class="o">-</span><span class="mi">1314</span>
<span class="p">)</span>

<span class="cm">/* package sys */</span>
<span class="kd">const</span> <span class="nx">PtrSize</span> <span class="p">=</span> <span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="p">(^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">63</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>举一个简单的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>执行命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nx">tool</span> <span class="nx">compile</span> <span class="o">-</span><span class="nx">S</span> <span class="nx">main</span><span class="p">.</span><span class="k">go</span>
</code></pre></td></tr></table>
</div>
</div><p>得到汇编代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">main</span> <span class="nx">STEXT</span> <span class="nx">size</span><span class="p">=</span><span class="mi">120</span> <span class="nx">args</span><span class="p">=</span><span class="mh">0x0</span> <span class="nx">locals</span><span class="p">=</span><span class="mh">0x48</span>
    <span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">TEXT</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nf">main</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="err">$</span><span class="mi">72</span><span class="o">-</span><span class="mi">0</span>
    <span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nf">MOVQ</span>    <span class="p">(</span><span class="nx">TLS</span><span class="p">),</span> <span class="nx">CX</span>
    <span class="mh">0x0009</span> <span class="mo">0000</span><span class="mi">9</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">CMPQ</span>    <span class="nx">SP</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
    <span class="mh">0x000d</span> <span class="mo">00013</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">JLS</span>    <span class="mi">113</span>
    <span class="mh">0x000f</span> <span class="mo">00015</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">SUBQ</span>    <span class="err">$</span><span class="mi">72</span><span class="p">,</span> <span class="nx">SP</span>
    <span class="mh">0x0013</span> <span class="mo">0001</span><span class="mi">9</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="nx">BP</span><span class="p">,</span> <span class="mi">64</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x0018</span> <span class="mo">00024</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">LEAQ</span>    <span class="mi">64</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BP</span>
    <span class="mh">0x001d</span> <span class="mo">0002</span><span class="mi">9</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">FUNCDATA</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nx">gclocals</span><span class="err">·</span><span class="mi">69</span><span class="nf">c1753bd5f81501d95132d08af04464</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
    <span class="mh">0x001d</span> <span class="mo">0002</span><span class="mi">9</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">FUNCDATA</span>    <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="nx">gclocals</span><span class="err">·</span><span class="nf">e226d4ae4a7cad8835311c6a4683c14f</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
    <span class="mh">0x001d</span> <span class="mo">0002</span><span class="mi">9</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">..</span><span class="nx">autotmp_0</span><span class="o">+</span><span class="mi">48</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x0026</span> <span class="mo">0003</span><span class="mi">8</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">..</span><span class="nx">autotmp_0</span><span class="o">+</span><span class="mi">56</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x002f</span> <span class="mo">00047</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">LEAQ</span>    <span class="kd">type</span><span class="p">.</span><span class="nb">string</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
    <span class="mh">0x0036</span> <span class="mo">00054</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">..</span><span class="nx">autotmp_0</span><span class="o">+</span><span class="mi">48</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x003b</span> <span class="mo">0005</span><span class="mi">9</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">LEAQ</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nf">statictmp_0</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
    <span class="mh">0x0042</span> <span class="mo">00066</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">..</span><span class="nx">autotmp_0</span><span class="o">+</span><span class="mi">56</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x0047</span> <span class="mo">00071</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">LEAQ</span>    <span class="s">&#34;&#34;</span><span class="p">..</span><span class="nx">autotmp_0</span><span class="o">+</span><span class="mi">48</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>
    <span class="mh">0x004c</span> <span class="mo">00076</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x0050</span> <span class="mo">000</span><span class="mi">80</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x0059</span> <span class="mo">000</span><span class="mi">89</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x0062</span> <span class="mo">000</span><span class="mi">98</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">PCDATA</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="err">$</span><span class="mi">1</span>
    <span class="mh">0x0062</span> <span class="mo">000</span><span class="mi">98</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">CALL</span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
    <span class="mh">0x0067</span> <span class="mo">00103</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="mi">64</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BP</span>
    <span class="mh">0x006c</span> <span class="mo">0010</span><span class="mi">8</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>    <span class="nx">ADDQ</span>    <span class="err">$</span><span class="mi">72</span><span class="p">,</span> <span class="nx">SP</span>
    <span class="mh">0x0070</span> <span class="mo">00112</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>    <span class="nx">RET</span>
    <span class="mh">0x0071</span> <span class="mo">00113</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>    <span class="nx">NOP</span>
    <span class="mh">0x0071</span> <span class="mo">00113</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">PCDATA</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="err">$</span><span class="o">-</span><span class="mi">1</span>
    <span class="mh">0x0071</span> <span class="mo">00113</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="p">.</span><span class="nf">morestack_noctxt</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
    <span class="mh">0x0076</span> <span class="mo">0011</span><span class="mi">8</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">JMP</span>    <span class="mi">0</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nf">MOVQ</span>    <span class="p">(</span><span class="nx">TLS</span><span class="p">),</span> <span class="nx">CX</span>
</code></pre></td></tr></table>
</div>
</div><p>将本地存储 tls 保存到 CX 寄存器中，（TLS）表示它所关联的 g，这里就是前面所讲到的 main gouroutine。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="mh">0x0009</span> <span class="mo">0000</span><span class="mi">9</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">CMPQ</span>    <span class="nx">SP</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>比较 SP 寄存器（代表当前 main goroutine 的栈顶寄存器）和 16(CX)，我们看下 g 结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// goroutine 使用的栈
</span><span class="c1"></span>    <span class="nx">stack</span>       <span class="nx">stack</span>   <span class="c1">// offset known to runtime/cgo
</span><span class="c1"></span>    <span class="c1">// 用于栈的扩张和收缩检查
</span><span class="c1"></span>    <span class="nx">stackguard0</span> <span class="kt">uintptr</span> <span class="c1">// offset known to liblink
</span><span class="c1"></span>    <span class="c1">// ……………………
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>对象 g 的第一个字段是 stack 结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">stack</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">lo</span> <span class="kt">uintptr</span>
    <span class="nx">hi</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>共 16 字节。而 16(CX) 表示 g 对象的第 16 个字节，跳过了 g 的第一个字段，也就是 g.stackguard0 字段。</p>
<p>如果 SP 小于 g.stackguard0，这是必然的，因为前面已经把 g.stackguard0 设置成了一个非常大的值，因此跳转到了 113 行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="mh">0x0071</span> <span class="mo">00113</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>    <span class="nx">NOP</span>
<span class="mh">0x0071</span> <span class="mo">00113</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">PCDATA</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="err">$</span><span class="o">-</span><span class="mi">1</span>
<span class="mh">0x0071</span> <span class="mo">00113</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="p">.</span><span class="nf">morestack_noctxt</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
<span class="mh">0x0076</span> <span class="mo">0011</span><span class="mi">8</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">JMP</span>    <span class="mi">0</span>
</code></pre></td></tr></table>
</div>
</div><p>调用 runtime.morestack_noctxt 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/asm_amd64.s
</span><span class="c1"></span><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">morestack_noctxt</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span><span class="nx">NOSPLIT</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span>
    <span class="nx">MOVL</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nx">DX</span>
	<span class="nx">JMP</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">morestack</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>直接跳转到 morestack 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">morestack</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span><span class="nx">NOSPLIT</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">0</span>
    <span class="c1">// Cannot grow scheduler stack (m-&gt;g0).
</span><span class="c1"></span>    <span class="nf">get_tls</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
    <span class="c1">// BX = g，g 表示 main goroutine
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">BX</span>
    <span class="c1">// BX = g.m
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nf">g_m</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BX</span>
    <span class="c1">// SI = g.m.g0
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nf">m_g0</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">SI</span>
    <span class="nx">CMPQ</span>    <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">SI</span>
    <span class="nx">JNE</span>    <span class="mi">3</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>
    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">badmorestackg0</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
    <span class="nx">INT</span>    <span class="err">$</span><span class="mi">3</span>

    <span class="c1">// ……………………
</span><span class="c1"></span>
    <span class="c1">// Set g-&gt;sched to context in f.
</span><span class="c1"></span>    <span class="c1">// 将函数的返回地址保存到 AX 寄存器
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="mi">0</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span> <span class="c1">// f&#39;s PC
</span><span class="c1"></span>    <span class="c1">// 将函数的返回地址保存到 g.sched.pc
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_pc</span><span class="p">)(</span><span class="nx">SI</span><span class="p">)</span>
    <span class="c1">// g.sched.g = g
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">SI</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_g</span><span class="p">)(</span><span class="nx">SI</span><span class="p">)</span>
    <span class="c1">// 取地址操作符，调用 morestack_noctxt 之前的 rsp
</span><span class="c1"></span>    <span class="nx">LEAQ</span>    <span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span> <span class="c1">// f&#39;s SP
</span><span class="c1"></span>    <span class="c1">// 将 main 函数的栈顶地址保存到 g.sched.sp
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">SI</span><span class="p">)</span>
    <span class="c1">// 将 BP 寄存器保存到 g.sched.bp
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">BP</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_bp</span><span class="p">)(</span><span class="nx">SI</span><span class="p">)</span>
    <span class="c1">// newstack will fill gobuf.ctxt.
</span><span class="c1"></span>
    <span class="c1">// Call newstack on m-&gt;g0&#39;s stack.
</span><span class="c1"></span>    <span class="c1">// BX = g.m.g0
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nf">m_g0</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BX</span>
    <span class="c1">// 将 g0 保存到本地存储 tls
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">BX</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
    <span class="c1">// 把 g0 栈的栈顶寄存器的值恢复到 CPU 的寄存器 SP，达到切换栈的目的，下面这一条指令执行之前，
</span><span class="c1"></span>    <span class="c1">// CPU 还是使用的调用此函数的 g 的栈，执行之后 CPU 就开始使用 g0 的栈了
</span><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">SP</span>
    <span class="c1">// 准备参数
</span><span class="c1"></span>    <span class="nx">PUSHQ</span>    <span class="nx">DX</span>    <span class="c1">// ctxt argument
</span><span class="c1"></span>    <span class="c1">// 不返回
</span><span class="c1"></span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">newstack</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x1003</span>    <span class="c1">// crash if newstack returns
</span><span class="c1"></span>    <span class="nx">POPQ</span>    <span class="nx">DX</span>    <span class="c1">// keep balance check happy
</span><span class="c1"></span>	<span class="nx">RET</span>
</code></pre></td></tr></table>
</div>
</div><p>主要做的工作就是将当前 goroutine，也就是 main goroutine 的和调度相关的信息保存到 g.sched 中，以便在调度到它执行时，可以恢复。</p>
<p>最后，将 g0 的地址保存到 tls 本地存储，并且切到 g0 栈执行之后的代码。继续调用 newstack 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newstack</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">thisg</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="c1">// TODO: double check all gp. shouldn&#39;t be getg().
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">stackguard0</span> <span class="o">==</span> <span class="nx">stackFork</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stack growth after fork&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: newstack called from g=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">g</span><span class="p">),</span> <span class="s">&#34;\n&#34;</span><span class="o">+</span><span class="s">&#34;\tm=&#34;</span><span class="p">,</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="s">&#34; m-&gt;curg=&#34;</span><span class="p">,</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span><span class="p">,</span> <span class="s">&#34; m-&gt;g0=&#34;</span><span class="p">,</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span><span class="p">,</span> <span class="s">&#34; m-&gt;gsignal=&#34;</span><span class="p">,</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nx">morebuf</span> <span class="o">:=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span>
		<span class="nf">traceback</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span><span class="p">,</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">lr</span><span class="p">,</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: wrong goroutine in newstack&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>

	<span class="k">if</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span><span class="p">.</span><span class="nx">throwsplit</span> <span class="p">{</span>
		<span class="c1">// Update syscallsp, syscallpc in case traceback uses them.
</span><span class="c1"></span>		<span class="nx">morebuf</span> <span class="o">:=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">=</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">syscallpc</span> <span class="p">=</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span>
		<span class="nx">pcname</span><span class="p">,</span> <span class="nx">pcoff</span> <span class="o">:=</span> <span class="s">&#34;(unknown)&#34;</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="nx">f</span> <span class="o">:=</span> <span class="nf">findfunc</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">f</span><span class="p">.</span><span class="nf">valid</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">pcname</span> <span class="p">=</span> <span class="nf">funcname</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
			<span class="nx">pcoff</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="o">-</span> <span class="nx">f</span><span class="p">.</span><span class="nx">entry</span>
		<span class="p">}</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: newstack at &#34;</span><span class="p">,</span> <span class="nx">pcname</span><span class="p">,</span> <span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">pcoff</span><span class="p">),</span>
			<span class="s">&#34; sp=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; stack=[&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="s">&#34;, &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="p">),</span> <span class="s">&#34;]\n&#34;</span><span class="p">,</span>
			<span class="s">&#34;\tmorebuf={pc:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span><span class="p">),</span> <span class="s">&#34; sp:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; lr:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">lr</span><span class="p">),</span> <span class="s">&#34;}\n&#34;</span><span class="p">,</span>
			<span class="s">&#34;\tsched={pc:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span><span class="p">),</span> <span class="s">&#34; sp:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; lr:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lr</span><span class="p">),</span> <span class="s">&#34; ctxt:&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ctxt</span><span class="p">,</span> <span class="s">&#34;}\n&#34;</span><span class="p">)</span>

		<span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">traceback</span> <span class="p">=</span> <span class="mi">2</span> <span class="c1">// Include runtime frames
</span><span class="c1"></span>		<span class="nf">traceback</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span><span class="p">,</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">lr</span><span class="p">,</span> <span class="nx">gp</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: stack split at bad time&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">morebuf</span> <span class="o">:=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span>
	<span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">lr</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="c1">// NOTE: stackguard0 may change underfoot, if another thread
</span><span class="c1"></span>	<span class="c1">// is about to try to preempt gp. Read it just once and use that same
</span><span class="c1"></span>	<span class="c1">// value now and below.
</span><span class="c1"></span>	<span class="c1">// 如果是发起的抢占请求而非真正的栈分段
</span><span class="c1"></span>	<span class="nx">preempt</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Loaduintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span><span class="p">)</span> <span class="o">==</span> <span class="nx">stackPreempt</span>

	<span class="c1">// Be conservative about where we preempt.
</span><span class="c1"></span>	<span class="c1">// We are interested in preempting user Go code, not runtime code.
</span><span class="c1"></span>	<span class="c1">// If we&#39;re holding locks, mallocing, or preemption is disabled, don&#39;t
</span><span class="c1"></span>	<span class="c1">// preempt.
</span><span class="c1"></span>	<span class="c1">// This check is very early in newstack so that even the status change
</span><span class="c1"></span>	<span class="c1">// from Grunning to Gwaiting and back doesn&#39;t happen in this case.
</span><span class="c1"></span>	<span class="c1">// That status change by itself can be viewed as a small preemption,
</span><span class="c1"></span>	<span class="c1">// because the GC might change Gwaiting to Gscanwaiting, and then
</span><span class="c1"></span>	<span class="c1">// this goroutine has to wait for the GC to finish before continuing.
</span><span class="c1"></span>	<span class="c1">// If the GC is in some way dependent on this goroutine (for example,
</span><span class="c1"></span>	<span class="c1">// it needs a lock held by the goroutine), that small preemption turns
</span><span class="c1"></span>	<span class="c1">// into a real deadlock.
</span><span class="c1"></span>	<span class="c1">// 保守的对用户态代码进行抢占，而非抢占运行时代码
</span><span class="c1"></span>	<span class="c1">// 如果正持有锁、分配内存或抢占被禁用，则不发生抢占
</span><span class="c1"></span>	<span class="c1">// gopreempt_m 将当前的 goroutine 放进了全局队列
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">preempt</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nf">canPreemptM</span><span class="p">(</span><span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Let the goroutine keep running for now.
</span><span class="c1"></span>			<span class="c1">// gp-&gt;preempt is set, so it will be preempted next time.
</span><span class="c1"></span>			<span class="c1">//stackguard0恢复溢出检查用途,下次用G.preempt恢复
</span><span class="c1"></span>			<span class="c1">// 还原 stackguard0 为正常值，表示我们已经处理过抢占请求了
</span><span class="c1"></span>			<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
			<span class="c1">// 不抢占，调用 gogo 继续运行当前这个 g，不需要调用 schedule 函数去挑选另一个 goroutine
</span><span class="c1"></span>			<span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span> <span class="c1">// never return
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;missing stack in newstack&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">sp</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span>
	<span class="k">if</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">ArchFamily</span> <span class="o">==</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">AMD64</span> <span class="o">||</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">ArchFamily</span> <span class="o">==</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">I386</span> <span class="o">||</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">ArchFamily</span> <span class="o">==</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">WASM</span> <span class="p">{</span>
		<span class="c1">// The call to morestack cost a word.
</span><span class="c1"></span>		<span class="nx">sp</span> <span class="o">-=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">stackDebug</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">sp</span> <span class="p">&lt;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: newstack sp=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; stack=[&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="s">&#34;, &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="p">),</span> <span class="s">&#34;]\n&#34;</span><span class="p">,</span>
			<span class="s">&#34;\tmorebuf={pc:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span><span class="p">),</span> <span class="s">&#34; sp:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; lr:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">lr</span><span class="p">),</span> <span class="s">&#34;}\n&#34;</span><span class="p">,</span>
			<span class="s">&#34;\tsched={pc:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span><span class="p">),</span> <span class="s">&#34; sp:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; lr:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lr</span><span class="p">),</span> <span class="s">&#34; ctxt:&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ctxt</span><span class="p">,</span> <span class="s">&#34;}\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">sp</span> <span class="p">&lt;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: gp=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="s">&#34;, goid=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">goid</span><span class="p">,</span> <span class="s">&#34;, gp-&gt;status=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)),</span> <span class="s">&#34;\n &#34;</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: split stack overflow: &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; &lt; &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: split stack overflow&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果需要对栈进行调整
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">preempt</span> <span class="p">{</span>
		<span class="c1">//垃圾回收本身也算一次抢占,忽略本次抢占调度
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: preempt g0&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: g is running but p is not&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptShrink</span> <span class="p">{</span>
			<span class="c1">// 我们正在一个同步安全点，因此等待栈收缩
</span><span class="c1"></span>			<span class="c1">// We&#39;re at a synchronous safe point now, so
</span><span class="c1"></span>			<span class="c1">// do the pending stack shrink.
</span><span class="c1"></span>			<span class="nx">gp</span><span class="p">.</span><span class="nx">preemptShrink</span> <span class="p">=</span> <span class="kc">false</span>
			<span class="nf">shrinkstack</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptStop</span> <span class="p">{</span>
			<span class="nf">preemptPark</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="c1">// never returns
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="c1">// 调用 gopreempt_m 把 gp 切换出去
</span><span class="c1"></span>		<span class="c1">// Act like goroutine called runtime.Gosched.
</span><span class="c1"></span>		<span class="c1">// 表现得像是调用了 runtime.Gosched，主动让权
</span><span class="c1"></span>		<span class="nf">gopreempt_m</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="c1">// never return
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="c1">// Allocate a bigger segment and move the stack.
</span><span class="c1"></span>	<span class="nx">oldsize</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span>
	<span class="nx">newsize</span> <span class="o">:=</span> <span class="nx">oldsize</span> <span class="o">*</span> <span class="mi">2</span>

	<span class="c1">// Make sure we grow at least as much as needed to fit the new frame.
</span><span class="c1"></span>	<span class="c1">// (This is just an optimization - the caller of morestack will
</span><span class="c1"></span>	<span class="c1">// recheck the bounds on return.)
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">f</span> <span class="o">:=</span> <span class="nf">findfunc</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span><span class="p">);</span> <span class="nx">f</span><span class="p">.</span><span class="nf">valid</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">max</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">funcMaxSPDelta</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span>
		<span class="k">for</span> <span class="nx">newsize</span><span class="o">-</span><span class="nx">oldsize</span> <span class="p">&lt;</span> <span class="nx">max</span><span class="o">+</span><span class="nx">_StackGuard</span> <span class="p">{</span>
			<span class="nx">newsize</span> <span class="o">*=</span> <span class="mi">2</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">newsize</span> <span class="p">&gt;</span> <span class="nx">maxstacksize</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: goroutine stack exceeds &#34;</span><span class="p">,</span> <span class="nx">maxstacksize</span><span class="p">,</span> <span class="s">&#34;-byte limit\n&#34;</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: sp=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; stack=[&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="s">&#34;, &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="p">),</span> <span class="s">&#34;]\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stack overflow&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// The goroutine must be executing in order to call newstack,
</span><span class="c1"></span>	<span class="c1">// so it must be Grunning (or Gscanrunning).
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gcopystack</span><span class="p">)</span>

	<span class="c1">// The concurrent GC will not scan the stack while we are doing the copy since
</span><span class="c1"></span>	<span class="c1">// the gp is in a Gcopystack status.
</span><span class="c1"></span>	<span class="nf">copystack</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">newsize</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">stackDebug</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;stack grow done\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gcopystack</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
	<span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中的 canPreemptM 验证了可以被抢占的条件：</p>
<ol>
<li>运行时没有禁止抢占（m.locks == 0）</li>
<li>运行时没有在执行内存分配（m.mallocing == 0）</li>
<li>运行时没有关闭抢占机制（m.preemptoff == &ldquo;&quot;）</li>
<li>M 与 P 绑定且没有进入系统调用（p.status == _Prunning）</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// canPreemptM 报告 mp 是否处于可抢占的安全状态。
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">canPreemptM</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">//如果M持有锁,或者正在进行内存分配,垃圾回收等操作,不抢占,留待下次
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">locks</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">status</span> <span class="o">==</span> <span class="nx">_Prunning</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>第一次判断 preempt 标志是 true 时，检查了 g 的状态，发现不能抢占，例如它所绑定的 P 的状态不是 _Prunning，那就恢复它的 stackguard0 字段，下次就不会走这一套流程了。然后，调用 gogo(&amp;gp.sched) 继续执行当前的 goroutine。</p>
<p>中间又处理了很多判断流程，再次判断 preempt 标志是 true 时，调用 gopreempt_m(gp) 将 gp 切换出去。</p>
<p>gopreempt_m函数在proc.go中定义，它的参数是需要停止的G。它就干了一件事，调用goschedImpl函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gopreempt_m</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGoPreempt</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nf">goschedImpl</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>goschedImpl函数也在proc.go文件中，参数是要停止的G。该函数首先把这个G从Grunning状态转到Grunnable状态。然后调用dropg函数解除这个G与当前M的关联。再把这个G放入调度器的可运行G队列，最后调用schedule函数进行一轮调度，为当前P找一个新的可运行G来运行。至此抢占结束。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">goschedImpl</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">status</span><span class="o">&amp;^</span><span class="nx">_Gscan</span> <span class="o">!=</span> <span class="nx">_Grunning</span> <span class="p">{</span>
		<span class="nf">dumpgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad g status&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 更改 gp 的状态
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
	<span class="c1">// 解除 m 和 g 的关系
</span><span class="c1"></span>	<span class="nf">dropg</span><span class="p">()</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">// 将 gp 放入全局可运行队列
</span><span class="c1"></span>	<span class="nf">globrunqput</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">// 进入新一轮的调度循环
</span><span class="c1"></span>	<span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>将 gp 的状态改为 _Grunnable，放入全局可运行队列，等待下次有 m 来全局队列找工作时才能继续运行，毕竟你已经运行这么长时间了，给别人一点机会嘛。</p>
<p>最后，调用 schedule() 函数进入新一轮的调度循环，会找出一个 goroutine 来运行，永不返回。</p>
<p>从可被抢占的条件来看，能够对一个 G 进行抢占其实是呈保守状态的。 这一保守体现在抢占对很多运行时所需的条件进行了判断，这也理所当然是因为 运行时优先级更高，不应该轻易发生抢占， 但与此同时由于又需要对用户态代码进行抢占，于是先作出一次不需要抢占的判断（快速路径）， 确定不能抢占时返回并继续调度，如果真的需要进行抢占，则转入调用 gopreempt_m， 放弃当前 G 的执行权，将其加入全局队列，重新进入调度循环。</p>
<p>什么时候会会给 stackguard0 设置抢占标记 stackPreempt 呢？ 一共有以下几种情况：</p>
<ol>
<li>进入系统调用时（runtime.reentersyscall，注意这种情况是为了保证不会发生栈分裂， 真正的抢占是异步的通过系统监控进行的）</li>
<li>任何运行时不再持有锁的时候（m.locks == 0）</li>
<li>当垃圾回收器需要停止所有用户 Goroutine 时</li>
</ol>
<h2 id="基于信号的抢占式调度preemptm">基于信号的抢占式调度(preemptM)</h2>
<p>从上面提到的调度逻辑我们可以看出，这种需要用户代码来主动配合的调度方式存在 一些致命的缺陷：一个没有主动放弃执行权、且不参与任何函数调用的函数，直到执行完毕之前， 是不会被抢占的。那么这种不会被抢占的函数会导致什么严重的问题呢？回答是，由于运行时无法 停止该用户代码，则当需要进行垃圾回收时，无法及时进行；对于一些实时性要求较高的用户态 Goroutine 而言，也久久得不到调度。我们直接来看一个非常简单的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 此程序在 Go 1.14 之前的版本不会输出 OK
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;runtime&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
	<span class="nb">println</span><span class="p">(</span><span class="s">&#34;OK&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这段代码中处于死循环的 Goroutine 永远无法被抢占，其中创建的 Goroutine 会执行一个不产生任何调用、不主动放弃执行权的死循环。由于主 Goroutine 优先调用了 休眠，此时唯一的 P 会转去执行 for 循环所创建的 Goroutine。进而主 Goroutine 永远不会再被调度，进而程序彻底阻塞在了这四个 Goroutine 上，永远无法退出.如果有多个P并发执行,此时一个P死循环,因为垃圾回收触发时无法抢占该Goroutine,垃圾回收在STW阶段会一直卡住,最终导致进程假死。这样的例子 非常多，但追根溯源，均为此问题导致</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210822160930.png" alt=""></p>
<p>Go 语言在 1.14 版本中实现了非协作的抢占式调度，在实现的过程中我们重构已有的逻辑并为 Goroutine 增加新的状态和字段来支持抢占。Go 团队通过下面的一系列提交实现了这一功能，我们可以按时间顺序分析相关提交理解它的工作原理：</p>
<ul>
<li>runtime: add general suspendG/resumeG
<ul>
<li>挂起 Goroutine 的过程是在垃圾回收的栈扫描时完成的，我们通过 runtime.suspendG 和 runtime.resumeG 两个函数重构栈扫描这一过程；</li>
<li>调用 runtime.suspendG 函数时会将处于运行状态的 Goroutine 的 preemptStop 标记成 true；</li>
<li>调用 runtime.preemptPark 函数可以挂起当前 Goroutine、将其状态更新成 _Gpreempted 并触发调度器的重新调度，该函数能够交出线程控制权；</li>
</ul>
</li>
<li>runtime: asynchronous preemption function for x86
<ul>
<li>在 x86 架构上增加异步抢占的函数 runtime.asyncPreempt 和 runtime.asyncPreempt2；</li>
</ul>
</li>
<li>runtime: use signals to preempt Gs for suspendG
<ul>
<li>支持通过向线程发送信号的方式暂停运行的 Goroutine；</li>
<li>在 runtime.sighandler 函数中注册 SIGURG 信号的处理函数 runtime.doSigPreempt；</li>
<li>实现 runtime.preemptM 函数，它可以通过 SIGURG 信号向线程发送抢占请求；</li>
</ul>
</li>
<li>runtime: implement async scheduler preemption
<ul>
<li>修改 runtime.preemptone 函数的实现，加入异步抢占的逻辑；</li>
</ul>
</li>
</ul>
<p>目前的抢占式调度也只会在垃圾回收扫描任务时触发，我们可以梳理一下上述代码实现的抢占式调度过程：</p>
<ol>
<li>程序启动时，在 runtime.sighandler 函数中注册 SIGURG 信号的处理函数 runtime.doSigPreempt；</li>
<li>在触发垃圾回收的栈扫描时会调用 runtime.suspendG 挂起 Goroutine，该函数会执行下面的逻辑：
<ol>
<li>将 _Grunning 状态的 Goroutine 标记成可以被抢占，即将 preemptStop 设置成 true；</li>
<li>调用 runtime.preemptM 触发抢占；</li>
</ol>
</li>
<li>runtime.preemptM 会调用 runtime.signalM 向线程发送信号 SIGURG；</li>
<li>操作系统会中断正在运行的线程并执行预先注册的信号处理函数 runtime.doSigPreempt；</li>
<li>runtime.doSigPreempt 函数会处理抢占信号，获取当前的 SP 和 PC 寄存器并调用 runtime.sigctxt.pushCall；</li>
<li>runtime.sigctxt.pushCall 会修改寄存器并在程序回到用户态时执行 runtime.asyncPreempt；</li>
<li>汇编指令 runtime.asyncPreempt 会调用运行时函数 runtime.asyncPreempt2；</li>
<li>runtime.asyncPreempt2 会调用 runtime.preemptPark；</li>
<li>runtime.preemptPark 会修改当前 Goroutine 的状态到_Gpreempted 并调用 runtime.schedule 让当前函数陷入休眠并让出线程，调度器会选择其它的 Goroutine 继续执行；</li>
</ol>
<p>上述 9 个步骤展示了基于信号的抢占式调度的执行过程。除了分析抢占的过程之外，我们还需要讨论一下抢占信号的选择，提案根据以下的四个原因选择 SIGURG 作为触发异步抢占的信号；</p>
<ol>
<li>该信号需要被调试器透传；</li>
<li>该信号不会被内部的 libc 库使用并拦截；</li>
<li>该信号可以随意出现并且不触发任何后果；</li>
<li>我们需要处理多个平台上的不同信号；</li>
</ol>
<p>STW 和栈扫描是一个可以抢占的安全点（Safe-points），所以 Go 语言会在这里先加入抢占功能。基于信号的抢占式调度只解决了垃圾回收和栈扫描时存在的问题，它到目前为止没有解决全部问题，但是这种真抢占式调度时调度器走向完备的开始，相信在未来我们可以会更多的地方触发抢占。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Tell the goroutine running on processor P to stop.
</span><span class="c1">// This function is purely best-effort. It can incorrectly fail to inform the
</span><span class="c1">// goroutine. It can send inform the wrong goroutine. Even if it informs the
</span><span class="c1">// correct goroutine, that goroutine might ignore the request if it is
</span><span class="c1">// simultaneously executing newstack.
</span><span class="c1">// No lock needs to be held.
</span><span class="c1">// Returns true if preemption request was issued.
</span><span class="c1">// The actual preemption will happen at some point in the future
</span><span class="c1">// and will be indicated by the gp-&gt;status no longer being
</span><span class="c1">// Grunning
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">preemptone</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="o">...</span>
	<span class="c1">// Request an async preemption of this P.
</span><span class="c1"></span>	<span class="c1">// 请求该 P 的异步抢占
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">preemptMSupported</span> <span class="o">&amp;&amp;</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">asyncpreemptoff</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nf">preemptM</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="抢占信号的选取">抢占信号的选取</h3>
<p>preemptM 完成了信号的发送，其实现也非常直接，直接向需要进行抢占的 M 发送 SIGURG 信号 即可。但是真正的重要的问题是，为什么是 SIGURG 信号而不是其他的信号？如何才能保证该信号 不与用户态产生的信号产生冲突？这里面有几个原因：</p>
<ol>
<li>默认情况下，SIGURG 已经用于调试器传递信号。</li>
<li>SIGRUURG 可以不加选择地虚假发生的信号。例如，我们不能选择 SIGALRM，因为 信号处理程序无法分辨它是否是由实际过程引起的（可以说这意味着信号已损坏）。 而常见的用户自定义信号 SIGUSR1 和 SIGUSR2 也不够好，因为用户态代码可能会将其进行使用</li>
<li>需要处理没有实时信号的平台（例如 macOS）</li>
</ol>
<p>考虑以上的观点，SIGURG 其实是一个很好的、满足所有这些条件、且极不可能因被用户态代码 进行使用的一种信号。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">sigPreempt</span> <span class="p">=</span> <span class="nx">_SIGURG</span>

<span class="c1">// preemptM 向 mp 发送抢占请求。该请求可以异步处理，也可以与对 M 的其他请求合并。
</span><span class="c1">// 接收到该请求后，如果正在运行的 G 或 P 被标记为抢占，并且 Goroutine 处于异步安全点，
</span><span class="c1">// 它将抢占 Goroutine。在处理抢占请求后，它始终以原子方式递增 mp.preemptGen。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">preemptM</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nf">signalM</span><span class="p">(</span><span class="nx">mp</span><span class="p">,</span> <span class="nx">sigPreempt</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">signalM</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">,</span> <span class="nx">sig</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">tgkill</span><span class="p">(</span><span class="nf">getpid</span><span class="p">(),</span> <span class="nb">int</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">procid</span><span class="p">),</span> <span class="nx">sig</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>通过系统调用 tgkill，给特定的线程发信号</p>
<h3 id="抢占调用的注入">抢占调用的注入</h3>
<p>Go 运行时进行信号处理的基本做法，其核心是注册 sighandler 函数，并在信号到达后， 由操作系统中断转入内核空间，而后将所中断线程的执行上下文参数（例如寄存器 rip, rep 等） 传递给处理函数。如果在 sighandler 中修改了这个上下文参数，操作系统则会根据修改后的 上下文信息恢复执行，这也就为抢占提供了机会。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sighandler</span><span class="p">(</span><span class="nx">sig</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">info</span> <span class="o">*</span><span class="nx">siginfo</span><span class="p">,</span> <span class="nx">ctxt</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sigctxt</span><span class="p">{</span><span class="nx">info</span><span class="p">,</span> <span class="nx">ctxt</span><span class="p">}</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nx">sig</span> <span class="o">==</span> <span class="nx">sigPreempt</span> <span class="p">{</span>
		<span class="c1">// 可能是一个抢占信号
</span><span class="c1"></span>		<span class="nf">doSigPreempt</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
		<span class="c1">// 即便这是一个抢占信号，它也可能与其他信号进行混合，因此我们
</span><span class="c1"></span>		<span class="c1">// 继续进行处理。
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// doSigPreempt handles a preemption signal on gp.
</span><span class="c1">// doSigPreempt 处理了 gp 上的抢占信号
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">doSigPreempt</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">ctxt</span> <span class="o">*</span><span class="nx">sigctxt</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Check if this G wants to be preempted and is safe to
</span><span class="c1"></span>	<span class="c1">// preempt.
</span><span class="c1"></span>	<span class="c1">// 检查 G 是否需要被抢占、抢占是否安全
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">wantAsyncPreempt</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">ok</span><span class="p">,</span> <span class="nx">newpc</span> <span class="o">:=</span> <span class="nf">isAsyncSafePoint</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">ctxt</span><span class="p">.</span><span class="nf">sigpc</span><span class="p">(),</span> <span class="nx">ctxt</span><span class="p">.</span><span class="nf">sigsp</span><span class="p">(),</span> <span class="nx">ctxt</span><span class="p">.</span><span class="nf">siglr</span><span class="p">());</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="c1">// Adjust the PC and inject a call to asyncPreempt.
</span><span class="c1"></span>			<span class="c1">// 插入抢占调用
</span><span class="c1"></span>			<span class="nx">ctxt</span><span class="p">.</span><span class="nf">pushCall</span><span class="p">(</span><span class="nf">funcPC</span><span class="p">(</span><span class="nx">asyncPreempt</span><span class="p">),</span> <span class="nx">newpc</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Acknowledge the preemption.
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptGen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">signalPending</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="c1">// 记录抢占
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;darwin&#34;</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pendingPreemptSignals</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在 ctxt.pushCall 之前， ctxt.rip() 和 ctxt.rep() 都保存了被中断的 Goroutine 所在的位置， 但是 pushCall 直接修改了这些寄存器，进而当从 sighandler 返回用户态 Goroutine 时， 能够从注入的 asyncPreempt 开始执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">sigctxt</span><span class="p">)</span> <span class="nf">pushCall</span><span class="p">(</span><span class="nx">targetPC</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">pc</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">rip</span><span class="p">())</span>
	<span class="nx">sp</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">rsp</span><span class="p">())</span>
	<span class="nx">sp</span> <span class="o">-=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span> <span class="p">=</span> <span class="nx">pc</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">set_rsp</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">set_rip</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">targetPC</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>完成 sighandler 之后，我们成功恢复到 asyncPreempt 调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// asyncPreempt 保存了所有用户寄存器，并调用 asyncPreempt2
</span><span class="c1">//
</span><span class="c1">// 当栈扫描遭遇 asyncPreempt 栈帧时，将会保守的扫描调用方栈帧
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">asyncPreempt</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>该函数的主要目的是保存用户态寄存器，并且在调用完毕前恢复所有的寄存器上下文， 就好像什么事情都没有发生过一样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">TEXT</span> ·<span class="nf">asyncPreempt</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span><span class="n">NOSPLIT</span><span class="o">|</span><span class="n">NOFRAME</span><span class="p">,</span><span class="o">$</span><span class="m">0-0</span>
	<span class="kc">...</span>
	<span class="n">MOVQ</span> <span class="n">AX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
	<span class="kc">...</span>
	<span class="n">MOVUPS</span> <span class="n">X15</span><span class="p">,</span> <span class="m">352</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
	<span class="n">CALL</span> ·<span class="nf">asyncPreempt2</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
	<span class="n">MOVUPS</span> <span class="m">352</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">X15</span>
	<span class="kc">...</span>
	<span class="n">MOVQ</span> <span class="m">0</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">AX</span>
	<span class="kc">...</span>
	<span class="n">RET</span>
</code></pre></td></tr></table>
</div>
</div><p>当调用 asyncPreempt2 时，会根据 preemptPark 或者 gopreempt_m 重新切换回调度循环，从而打断密集循环的继续执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">asyncPreempt2</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">asyncSafePoint</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptStop</span> <span class="p">{</span>
		<span class="nf">mcall</span><span class="p">(</span><span class="nx">preemptPark</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nf">mcall</span><span class="p">(</span><span class="nx">gopreempt_m</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 异步抢占过程结束
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">asyncSafePoint</span> <span class="p">=</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>至此，异步抢占过程结束。我们总结一下抢占调用的整体逻辑：</p>
<ol>
<li>M1 发送中断信号（signalM(mp, sigPreempt)）</li>
<li>M2 收到信号，操作系统中断其执行代码，并切换到信号处理函数（sighandler(signum, info, ctxt, gp)）</li>
<li>M2 修改执行的上下文，并恢复到修改后的位置（asyncPreempt）</li>
<li>重新进入调度循环进而调度其他 Goroutine（preemptPark 和 gopreempt_m）</li>
</ol>
<h3 id="sysmon抢占gopreempt_m">sysmon抢占(gopreempt_m)</h3>
<p>sysmon 抢占流程:</p>
<p>sysmon -&gt; retake -&gt; preemptone -&gt; asyncPreempt -&gt; globalrunqput</p>
<p>sysmon抢占后会把g放到全局队列中.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gopreempt_m</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGoPreempt</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nf">goschedImpl</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">goschedImpl</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">status</span><span class="o">&amp;^</span><span class="nx">_Gscan</span> <span class="o">!=</span> <span class="nx">_Grunning</span> <span class="p">{</span>
		<span class="nf">dumpgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad g status&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
	<span class="nf">dropg</span><span class="p">()</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nf">globrunqput</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="gc抢占preemptpark">GC抢占(preemptPark)</h3>
<p>GC 抢占流程:</p>
<p>markroot -&gt; allgs[i] -&gt; g -&gt; suspendG(g) -&gt; scan g stack -&gt; resumeG</p>
<p>resumeG会执行runqput,当g被其他线程调度到时,从asyncPreempt的下半部分继续执行.</p>
<p>GC走的是preemptPark分支,M和G解除绑定,G暂停执行,M继续调度其他G.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// preemptPark parks gp and puts it in _Gpreempted.
</span><span class="c1">//
</span><span class="c1">//go:systemstack
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">preemptPark</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGoPark</span><span class="p">(</span><span class="nx">traceEvGoBlock</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">status</span><span class="o">&amp;^</span><span class="nx">_Gscan</span> <span class="o">!=</span> <span class="nx">_Grunning</span> <span class="p">{</span>
		<span class="nf">dumpgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad g status&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="nx">waitReasonPreempted</span>
	<span class="c1">// Transition from _Grunning to _Gscan|_Gpreempted. We can&#39;t
</span><span class="c1"></span>	<span class="c1">// be in _Grunning when we dropg because then we&#39;d be running
</span><span class="c1"></span>	<span class="c1">// without an M, but the moment we&#39;re in _Gpreempted,
</span><span class="c1"></span>	<span class="c1">// something could claim this G before we&#39;ve fully cleaned it
</span><span class="c1"></span>	<span class="c1">// up. Hence, we set the scan bit to lock down further
</span><span class="c1"></span>	<span class="c1">// transitions until we can dropg.
</span><span class="c1"></span>	<span class="nf">casGToPreemptScan</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gscan</span><span class="p">|</span><span class="nx">_Gpreempted</span><span class="p">)</span>
	<span class="nf">dropg</span><span class="p">()</span>
	<span class="nf">casfrom_Gscanstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gscan</span><span class="p">|</span><span class="nx">_Gpreempted</span><span class="p">,</span> <span class="nx">_Gpreempted</span><span class="p">)</span>
	<span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="小结">小结</h2>
<p>总的来说，应用层的调度策略不易实现，因此实现上也并不是特别紧急。我们回顾 Go 语言调度策略的演变过程 不难发现，实现它们的动力是从实际需求出发的。Go 语言从设计之初并没有刻意的去考虑对 Goroutine 的抢占机制。 从早期无法对 Goroutine 进行抢占的原始时代，到现在的协作与抢占同时配合的调度策略， 其问题的核心是垃圾回收等运行时机制的需要。</p>
<p>当运行时需要执行垃圾回收时，协作式调度能够保证具备函数调用的用户 Goroutine 正常停止； 抢占式调度则能避免由于死循环导致的任意时间的垃圾回收延迟。有了这两种不同的调度策略， Go 语言的用户可以放心的写出各种形式的代码逻辑，即使运行时垃圾回收也能够在适当的时候及时中断用户代码， 不至于导致整个系统进入不可预测的停顿。</p>
<h2 id="转载">转载</h2>
<p><a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/preemption/#heading">6.8 协作与抢占</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-11-27
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go%E6%BA%90%E7%A0%81/">Go源码</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go的垃圾回收源码剖析</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/go%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
            <span class="next-text nav-default">Go的信号处理源码剖析</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
