<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go调度器的协作与抢占 | Forz Blog</title>
<meta name="keywords" content="Go源码" />
<meta name="description" content="前言 如果某个 G 执行时间过长，其他的 G 如何才能被正常的调度？ 这便涉及到有关调度的两个理念：协作式调度与抢占式调度。 协作式和抢占式这两个理念解释">
<meta name="author" content="">
<link rel="canonical" href="/post/go%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E5%8D%8F%E4%BD%9C%E4%B8%8E%E6%8A%A2%E5%8D%A0/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Go调度器的协作与抢占" />
<meta property="og:description" content="前言 如果某个 G 执行时间过长，其他的 G 如何才能被正常的调度？ 这便涉及到有关调度的两个理念：协作式调度与抢占式调度。 协作式和抢占式这两个理念解释" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E5%8D%8F%E4%BD%9C%E4%B8%8E%E6%8A%A2%E5%8D%A0/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-11-27T17:25:33&#43;00:00" />
<meta property="article:modified_time" content="2020-11-27T17:25:33&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go调度器的协作与抢占"/>
<meta name="twitter:description" content="前言 如果某个 G 执行时间过长，其他的 G 如何才能被正常的调度？ 这便涉及到有关调度的两个理念：协作式调度与抢占式调度。 协作式和抢占式这两个理念解释"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Go调度器的协作与抢占",
      "item": "/post/go%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E5%8D%8F%E4%BD%9C%E4%B8%8E%E6%8A%A2%E5%8D%A0/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go调度器的协作与抢占",
  "name": "Go调度器的协作与抢占",
  "description": "前言 如果某个 G 执行时间过长，其他的 G 如何才能被正常的调度？ 这便涉及到有关调度的两个理念：协作式调度与抢占式调度。 协作式和抢占式这两个理念解释",
  "keywords": [
    "Go源码"
  ],
  "articleBody": "前言 如果某个 G 执行时间过长，其他的 G 如何才能被正常的调度？ 这便涉及到有关调度的两个理念：协作式调度与抢占式调度。\n协作式和抢占式这两个理念解释起来很简单： 协作式调度依靠被调度方主动弃权；抢占式调度则依靠调度器强制将被调度方被动中断。 这两个概念其实描述了调度的两种截然不同的策略，这两种决策模式，在调度理论中其实已经研究得很透彻了。\nGo 的运行时并不具备操作系统内核级的硬件中断能力，基于工作窃取的调度器实现，本质上属于 先来先服务的协作式调度，为了解决响应时间可能较高的问题，目前运行时实现了两种不同的调度策略、 每种策略各两个形式。保证在大部分情况下，不同的 G 能够获得均匀的时间片：\n 同步协作式调度  主动用户让权：通过 runtime.Gosched 调用主动让出执行机会； 主动调度弃权：当发生执行栈分段时，检查自身的抢占标记，决定是否继续执行；   异步抢占式调度  被动监控抢占：P长时间运行或进行系统调用，系统监控会将 P 从 M 上抢夺并分配给其他的 M 来执行其他的 G，而位于被抢夺 P 的 M 本地调度队列中 的 G 则可能会被偷取到其他 M 中。 被动 GC 抢占：当需要进行垃圾回收时，为了保证不具备主动抢占处理的函数执行时间过长，导致垃圾回收迟迟不得执行而导致的高延迟，而强制停止 G 并转为执行垃圾回收,该抢占在第一次STW时进行.    协作式调度 主动用户让权：Gosched Gosched 是一种主动放弃执行的手段，用户态代码通过调用此接口来出让执行机会，使其他人也能在 密集的执行过程中获得被调度的机会。\n当然，尽管具有主动弃权的能力，但它对 Go 语言的用户要求比较高， 因为用户在编写并发逻辑的时候需要自行甄别是否需要让出时间片，这并非用户友好的， 而且很多 Go 的新用户并不会了解到这个问题的存在，我们在随后的抢占式调度中再进一步展开讨论。\n主动调度弃权：栈扩张与抢占标记 另一种主动放弃的方式是通过抢占标记的方式实现的。基本想法是在每个函数调用的序言 （函数调用的最前方）插入抢占检测指令，当检测到当前 Goroutine 被标记为被应该被抢占时， 则主动中断执行，让出执行权利。\n基于协作的抢占式调度(preemptone) 设计原理 我们知道现代操作系统的调度器多为抢占式调度，其实现方式通过硬件中断来支持线程的切换， 进而能安全的保存运行上下文。在 Go 运行时实现抢占式调度同样也可以使用类似的方式，通过 向线程发送系统信号的方式来中断 M 的执行，进而达到抢占的目的。 但与操作系统的不同之处在于，由于运行时诸多机制的存在（例如垃圾回收器），还必须能够在 Goroutine 被停止时，保存充足的上下文信息。 这就给中断信号带来了麻烦，如果中断信号恰好发生在一些关键阶段（例如写屏障期间）， 则无法保证程序的正确性。这也就要求我们需要严格考虑触发异步抢占的时机。\n异步抢占式调度的一种方式就与运行时系统监控有关，监控循环会将发生阻塞的 Goroutine 抢占， 解绑 P 与 M，从而让其他的线程能够获得 P 继续执行其他的 Goroutine。 这得益于 sysmon 中调用的 retake 方法。这个方法处理了两种抢占情况， 一是抢占阻塞在系统调用上的 P，二是抢占运行时间过长的 G。 其中抢占运行时间过长的 G 这一方式还会出现在垃圾回收需要进入 STW 时。\n我们可以在 pkg/runtime/proc.c 文件中找到引入基于协作的抢占式调度后的调度器。Go 语言会在分段栈的机制上实现抢占调度，利用编译器在分段栈上插入的函数，所有 Goroutine 在函数调用时都有机会进入运行时检查是否需要执行抢占。Go 团队通过以下的多个提交实现该特性：\n runtime: add stackguard0 to G  为 Goroutine 引入 stackguard0 字段，该字段被设置成 StackPreempt 意味着当前 Goroutine 发出了抢占请求；   runtime: introduce preemption function (not used for now)  引入抢占函数 runtime.preemptone 和 runtime.preemptall，这两个函数会改变 Goroutine 的 stackguard0 字段发出抢占请求； 定义抢占请求 StackPreempt；   runtime: preempt goroutines for GC  在 runtime.stoptheworld 中调用 runtime.preemptall 设置所有处理器上正在运行的 Goroutine 的 stackguard0 为 StackPreempt； 在 runtime.newstack 函数中增加抢占的代码，当 stackguard0 等于 StackPreempt 时触发调度器抢占让出线程；   runtime: preempt long-running goroutines  在系统监控中，如果一个 Goroutine 的运行时间超过 10ms，就会调用 runtime.retake 和 runtime.preemptone；   runtime: more reliable preemption  修复 Goroutine 因为周期性执行非阻塞的 CGO 或者系统调用不会被抢占的问题；    上面的多个提交实现了抢占式调度，但是还缺少最关键的一个环节 — 编译器如何在函数调用前插入函数，我们能在非常古老的提交 runtime: stack growth adjustments, cleanup 中找到编译器插入函数的出行，最新版本的 Go 语言会通过 cmd/internal/obj/x86.stacksplit 插入 runtime.morestack 函数，该函数可能会调用 runtime.newstack 触发抢占。从上面的多个提交中，我们能归纳出基于协作的抢占式调度的工作原理：\n 编译器会在调用函数前插入 runtime.morestack； Go 语言运行时会在垃圾回收暂停程序、系统监控发现 Goroutine 运行超过 10ms 时发出抢占请求 StackPreempt； 当发生函数调用时，可能会执行编译器插入的 runtime.morestack 函数，它调用的 runtime.newstack 会检查 Goroutine 的 stackguard0 字段是否为 StackPreempt； 如果 stackguard0 是 StackPreempt，就会触发抢占让出当前线程；  这种实现方式虽然增加了运行时的复杂度，但是实现相对简单，也没有带来过多的额外开销，总体来看还是比较成功的实现，也在 Go 语言中使用了 10 几个版本。因为这里的抢占是通过编译器插入函数实现的，还是需要函数调用作为入口才能触发抢占，所以这是一种协作式的抢占式调度。\n源码剖析 preemptone 本质是将正在 P 上执行的 M 的 curg 的标志位置为 true.这之后的流程需要正在运行的 goroutine 来配合.\n调用preemptone函数抢占该P，这也是go抢占式调度的体现。不过该函数只能告知在这个P上运行的G应该停止了。首先它不一定能正确的告知正确的G，其次即使告知被正确传递给了正确的G，这个G也可能忽略掉这个告知。也就是说preemptone函数只能告诉你我尽力而为，既不能保证告知正确到达，也不能保证那个G做出相应。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  // Tell the goroutine running on processor P to stop. // This function is purely best-effort. It can incorrectly fail to inform the // goroutine. It can send inform the wrong goroutine. Even if it informs the // correct goroutine, that goroutine might ignore the request if it is // simultaneously executing newstack. // No lock needs to be held. // Returns true if preemption request was issued. // The actual preemption will happen at some point in the future // and will be indicated by the gp-status no longer being // Grunning func preemptone(_p_ *p) bool { // 检查 M 与 P 是否绑定 \tmp := _p_.m.ptr() if mp == nil || mp == getg().m { return false } gp := mp.curg if gp == nil || gp == mp.g0 { return false } // 将 G 标记为抢占 \tgp.preempt = true // Every call in a go routine checks for stack overflow by \t// comparing the current stack pointer to gp-stackguard0. \t// Setting gp-stackguard0 to StackPreempt folds \t// preemption into the normal stack overflow check. \t// 一个 Goroutine 中的每个调用都会通过比较当前栈指针和 gp.stackgard0 \t// 来检查栈是否溢出。 \t// 设置 gp.stackgard0 为 StackPreempt 来将抢占转换为正常的栈溢出检查。 \t// 在 goroutine 内部的每次调用都会比较栈顶指针和 g.stackguard0，  // 来判断是否发生了栈溢出。stackPreempt 非常大的一个数，比任何栈都大 \tgp.stackguard0 = stackPreempt // Request an async preemption of this P. \t// 请求该 P 的异步抢占 \tif preemptMSupported \u0026\u0026 debug.asyncpreemptoff == 0 { _p_.preempt = true preemptM(mp) } return true }   有两个标志,实际起作用的是G.stackguard0. G.preempt只是后备,以便在stackguard()做回溢出检查标志时,依然可用preempt恢复抢占状态.\n当morestack调用newstack扩容时会检查抢占标志,并决定是否暂停当前任务,当然这发生在实际扩容之前.\ngo程序在执行G的每次调用时，都会通过比较当前堆栈指针和G的stackguard0字段来判断栈溢出。这里将当前G的stackguard0字段赋值为stackPreempt就会该G在下一次函数调用时栈空间检查失败，接下来就是一些列的函数调用，最终将这个G调度出去。\n在讲述这一些列函数调用之前，我们先来认识一下stackPreempt。\n它是在stack.go中定义的一个常量。在64位机器上，stackPreempt的值是0xfffffffffffffade，在32位机器上它的值是0xfffffade。表示的是栈指针sp的最大值，所以现在你知道为什么将stackguard0的值设置成它就能导致栈溢出了吧。它的计算出来需要用到uintptrMask，它是一个指针掩码，也就是一个所有位全为1的指针，32位机器上是0xffffffff，64位机器上是0xffffffffffffffff。在计算uintptrMask时用到的sys.PtrSize在sys包中的stubs.go文件中定义。^uintptr(0)得到的是一个各位都为1的值，32位机器上就是32个1,64位机器上就是64个1。左移63位后，如果是32位机器，结果就是0，接下来4右移0位还是4；64位机器结果是1，4右移1位后结果是8。所以PtrSize表示的就是一个指针长度的字节数。而一个字节的长度是8，所以在计算uintptrMask时用8乘以sys.PtrSize得到的就是一个指针的位数。\n1 2 3 4 5 6 7 8 9 10 11 12  /* stack.go */ // Goroutine 抢占请求 // 存储到 g.stackguard0 来导致栈分段检查失败 // 必须比任何实际的 SP 都要大 // 十六进制为：0xfffffade const ( uintptrMask = 1(8*sys.PtrSize) - 1 stackPreempt = uintptrMask \u0026 -1314 ) /* package sys */ const PtrSize = 4  (^uintptr(0)  63)   举一个简单的例子：\n1 2 3 4 5 6 7  package main import \"fmt\" func main() { fmt.Println(\"hello\") }   执行命令：\n1  go tool compile -S main.go   得到汇编代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  \"\".main STEXT size=120 args=0x0 locals=0x48 0x0000 00000 (test26.go:5) TEXT \"\".main(SB), $72-0 0x0000 00000 (test26.go:5) MOVQ (TLS), CX 0x0009 00009 (test26.go:5) CMPQ SP, 16(CX) 0x000d 00013 (test26.go:5) JLS 113 0x000f 00015 (test26.go:5) SUBQ $72, SP 0x0013 00019 (test26.go:5) MOVQ BP, 64(SP) 0x0018 00024 (test26.go:5) LEAQ 64(SP), BP 0x001d 00029 (test26.go:5) FUNCDATA $0, gclocals·69c1753bd5f81501d95132d08af04464(SB) 0x001d 00029 (test26.go:5) FUNCDATA $1, gclocals·e226d4ae4a7cad8835311c6a4683c14f(SB) 0x001d 00029 (test26.go:6) MOVQ $0, \"\"..autotmp_0+48(SP) 0x0026 00038 (test26.go:6) MOVQ $0, \"\"..autotmp_0+56(SP) 0x002f 00047 (test26.go:6) LEAQ type.string(SB), AX 0x0036 00054 (test26.go:6) MOVQ AX, \"\"..autotmp_0+48(SP) 0x003b 00059 (test26.go:6) LEAQ \"\".statictmp_0(SB), AX 0x0042 00066 (test26.go:6) MOVQ AX, \"\"..autotmp_0+56(SP) 0x0047 00071 (test26.go:6) LEAQ \"\"..autotmp_0+48(SP), AX 0x004c 00076 (test26.go:6) MOVQ AX, (SP) 0x0050 00080 (test26.go:6) MOVQ $1, 8(SP) 0x0059 00089 (test26.go:6) MOVQ $1, 16(SP) 0x0062 00098 (test26.go:6) PCDATA $0, $1 0x0062 00098 (test26.go:6) CALL fmt.Println(SB) 0x0067 00103 (test26.go:7) MOVQ 64(SP), BP 0x006c 00108 (test26.go:7) ADDQ $72, SP 0x0070 00112 (test26.go:7) RET 0x0071 00113 (test26.go:7) NOP 0x0071 00113 (test26.go:5) PCDATA $0, $-1 0x0071 00113 (test26.go:5) CALL runtime.morestack_noctxt(SB) 0x0076 00118 (test26.go:5) JMP 0   1  0x0000 00000 (test26.go:5) MOVQ (TLS), CX   将本地存储 tls 保存到 CX 寄存器中，（TLS）表示它所关联的 g，这里就是前面所讲到的 main gouroutine。\n1  0x0009 00009 (test26.go:5) CMPQ SP, 16(CX)   比较 SP 寄存器（代表当前 main goroutine 的栈顶寄存器）和 16(CX)，我们看下 g 结构体：\n1 2 3 4 5 6 7  type g struct { // goroutine 使用的栈  stack stack // offset known to runtime/cgo  // 用于栈的扩张和收缩检查  stackguard0 uintptr // offset known to liblink  // …………………… }   对象 g 的第一个字段是 stack 结构体：\n1 2 3 4  type stack struct { lo uintptr hi uintptr }   共 16 字节。而 16(CX) 表示 g 对象的第 16 个字节，跳过了 g 的第一个字段，也就是 g.stackguard0 字段。\n如果 SP 小于 g.stackguard0，这是必然的，因为前面已经把 g.stackguard0 设置成了一个非常大的值，因此跳转到了 113 行。\n1 2 3 4  0x0071 00113 (test26.go:7) NOP 0x0071 00113 (test26.go:5) PCDATA $0, $-1 0x0071 00113 (test26.go:5) CALL runtime.morestack_noctxt(SB) 0x0076 00118 (test26.go:5) JMP 0   调用 runtime.morestack_noctxt 函数：\n1 2 3 4  // src/runtime/asm_amd64.s TEXT runtime·morestack_noctxt(SB),NOSPLIT,$0 MOVL $0, DX JMP runtime·morestack(SB)   直接跳转到 morestack 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  TEXT runtime·morestack(SB),NOSPLIT,$0-0 // Cannot grow scheduler stack (m-g0).  get_tls(CX) // BX = g，g 表示 main goroutine  MOVQ g(CX), BX // BX = g.m  MOVQ g_m(BX), BX // SI = g.m.g0  MOVQ m_g0(BX), SI CMPQ g(CX), SI JNE 3(PC) CALL runtime·badmorestackg0(SB) INT $3 // ……………………  // Set g-sched to context in f.  // 将函数的返回地址保存到 AX 寄存器  MOVQ 0(SP), AX // f's PC  // 将函数的返回地址保存到 g.sched.pc  MOVQ AX, (g_sched+gobuf_pc)(SI) // g.sched.g = g  MOVQ SI, (g_sched+gobuf_g)(SI) // 取地址操作符，调用 morestack_noctxt 之前的 rsp  LEAQ 8(SP), AX // f's SP  // 将 main 函数的栈顶地址保存到 g.sched.sp  MOVQ AX, (g_sched+gobuf_sp)(SI) // 将 BP 寄存器保存到 g.sched.bp  MOVQ BP, (g_sched+gobuf_bp)(SI) // newstack will fill gobuf.ctxt.  // Call newstack on m-g0's stack.  // BX = g.m.g0  MOVQ m_g0(BX), BX // 将 g0 保存到本地存储 tls  MOVQ BX, g(CX) // 把 g0 栈的栈顶寄存器的值恢复到 CPU 的寄存器 SP，达到切换栈的目的，下面这一条指令执行之前，  // CPU 还是使用的调用此函数的 g 的栈，执行之后 CPU 就开始使用 g0 的栈了  MOVQ (g_sched+gobuf_sp)(BX), SP // 准备参数  PUSHQ DX // ctxt argument  // 不返回  CALL runtime·newstack(SB) MOVQ $0, 0x1003 // crash if newstack returns  POPQ DX // keep balance check happy \tRET   主要做的工作就是将当前 goroutine，也就是 main goroutine 的和调度相关的信息保存到 g.sched 中，以便在调度到它执行时，可以恢复。\n最后，将 g0 的地址保存到 tls 本地存储，并且切到 g0 栈执行之后的代码。继续调用 newstack 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153  func newstack() { thisg := getg() // TODO: double check all gp. shouldn't be getg(). \tif thisg.m.morebuf.g.ptr().stackguard0 == stackFork { throw(\"stack growth after fork\") } if thisg.m.morebuf.g.ptr() != thisg.m.curg { print(\"runtime: newstack called from g=\", hex(thisg.m.morebuf.g), \"\\n\"+\"\\tm=\", thisg.m, \" m-curg=\", thisg.m.curg, \" m-g0=\", thisg.m.g0, \" m-gsignal=\", thisg.m.gsignal, \"\\n\") morebuf := thisg.m.morebuf traceback(morebuf.pc, morebuf.sp, morebuf.lr, morebuf.g.ptr()) throw(\"runtime: wrong goroutine in newstack\") } gp := thisg.m.curg if thisg.m.curg.throwsplit { // Update syscallsp, syscallpc in case traceback uses them. \tmorebuf := thisg.m.morebuf gp.syscallsp = morebuf.sp gp.syscallpc = morebuf.pc pcname, pcoff := \"(unknown)\", uintptr(0) f := findfunc(gp.sched.pc) if f.valid() { pcname = funcname(f) pcoff = gp.sched.pc - f.entry } print(\"runtime: newstack at \", pcname, \"+\", hex(pcoff), \" sp=\", hex(gp.sched.sp), \" stack=[\", hex(gp.stack.lo), \", \", hex(gp.stack.hi), \"]\\n\", \"\\tmorebuf={pc:\", hex(morebuf.pc), \" sp:\", hex(morebuf.sp), \" lr:\", hex(morebuf.lr), \"}\\n\", \"\\tsched={pc:\", hex(gp.sched.pc), \" sp:\", hex(gp.sched.sp), \" lr:\", hex(gp.sched.lr), \" ctxt:\", gp.sched.ctxt, \"}\\n\") thisg.m.traceback = 2 // Include runtime frames \ttraceback(morebuf.pc, morebuf.sp, morebuf.lr, gp) throw(\"runtime: stack split at bad time\") } morebuf := thisg.m.morebuf thisg.m.morebuf.pc = 0 thisg.m.morebuf.lr = 0 thisg.m.morebuf.sp = 0 thisg.m.morebuf.g = 0 // NOTE: stackguard0 may change underfoot, if another thread \t// is about to try to preempt gp. Read it just once and use that same \t// value now and below. \t// 如果是发起的抢占请求而非真正的栈分段 \tpreempt := atomic.Loaduintptr(\u0026gp.stackguard0) == stackPreempt // Be conservative about where we preempt. \t// We are interested in preempting user Go code, not runtime code. \t// If we're holding locks, mallocing, or preemption is disabled, don't \t// preempt. \t// This check is very early in newstack so that even the status change \t// from Grunning to Gwaiting and back doesn't happen in this case. \t// That status change by itself can be viewed as a small preemption, \t// because the GC might change Gwaiting to Gscanwaiting, and then \t// this goroutine has to wait for the GC to finish before continuing. \t// If the GC is in some way dependent on this goroutine (for example, \t// it needs a lock held by the goroutine), that small preemption turns \t// into a real deadlock. \t// 保守的对用户态代码进行抢占，而非抢占运行时代码 \t// 如果正持有锁、分配内存或抢占被禁用，则不发生抢占 \t// gopreempt_m 将当前的 goroutine 放进了全局队列 \tif preempt { if !canPreemptM(thisg.m) { // Let the goroutine keep running for now. \t// gp-preempt is set, so it will be preempted next time. \t//stackguard0恢复溢出检查用途,下次用G.preempt恢复 \t// 还原 stackguard0 为正常值，表示我们已经处理过抢占请求了 \tgp.stackguard0 = gp.stack.lo + _StackGuard // 不抢占，调用 gogo 继续运行当前这个 g，不需要调用 schedule 函数去挑选另一个 goroutine \tgogo(\u0026gp.sched) // never return \t} } if gp.stack.lo == 0 { throw(\"missing stack in newstack\") } sp := gp.sched.sp if sys.ArchFamily == sys.AMD64 || sys.ArchFamily == sys.I386 || sys.ArchFamily == sys.WASM { // The call to morestack cost a word. \tsp -= sys.PtrSize } if stackDebug = 1 || sp  gp.stack.lo { print(\"runtime: newstack sp=\", hex(sp), \" stack=[\", hex(gp.stack.lo), \", \", hex(gp.stack.hi), \"]\\n\", \"\\tmorebuf={pc:\", hex(morebuf.pc), \" sp:\", hex(morebuf.sp), \" lr:\", hex(morebuf.lr), \"}\\n\", \"\\tsched={pc:\", hex(gp.sched.pc), \" sp:\", hex(gp.sched.sp), \" lr:\", hex(gp.sched.lr), \" ctxt:\", gp.sched.ctxt, \"}\\n\") } if sp  gp.stack.lo { print(\"runtime: gp=\", gp, \", goid=\", gp.goid, \", gp-status=\", hex(readgstatus(gp)), \"\\n \") print(\"runtime: split stack overflow: \", hex(sp), \" , hex(gp.stack.lo), \"\\n\") throw(\"runtime: split stack overflow\") } // 如果需要对栈进行调整 \tif preempt { //垃圾回收本身也算一次抢占,忽略本次抢占调度 \tif gp == thisg.m.g0 { throw(\"runtime: preempt g0\") } if thisg.m.p == 0 \u0026\u0026 thisg.m.locks == 0 { throw(\"runtime: g is running but p is not\") } if gp.preemptShrink { // 我们正在一个同步安全点，因此等待栈收缩 \t// We're at a synchronous safe point now, so \t// do the pending stack shrink. \tgp.preemptShrink = false shrinkstack(gp) } if gp.preemptStop { preemptPark(gp) // never returns \t} // 调用 gopreempt_m 把 gp 切换出去 \t// Act like goroutine called runtime.Gosched. \t// 表现得像是调用了 runtime.Gosched，主动让权 \tgopreempt_m(gp) // never return \t} // Allocate a bigger segment and move the stack. \toldsize := gp.stack.hi - gp.stack.lo newsize := oldsize * 2 // Make sure we grow at least as much as needed to fit the new frame. \t// (This is just an optimization - the caller of morestack will \t// recheck the bounds on return.) \tif f := findfunc(gp.sched.pc); f.valid() { max := uintptr(funcMaxSPDelta(f)) for newsize-oldsize  max+_StackGuard { newsize *= 2 } } if newsize  maxstacksize { print(\"runtime: goroutine stack exceeds \", maxstacksize, \"-byte limit\\n\") print(\"runtime: sp=\", hex(sp), \" stack=[\", hex(gp.stack.lo), \", \", hex(gp.stack.hi), \"]\\n\") throw(\"stack overflow\") } // The goroutine must be executing in order to call newstack, \t// so it must be Grunning (or Gscanrunning). \tcasgstatus(gp, _Grunning, _Gcopystack) // The concurrent GC will not scan the stack while we are doing the copy since \t// the gp is in a Gcopystack status. \tcopystack(gp, newsize) if stackDebug = 1 { print(\"stack grow done\\n\") } casgstatus(gp, _Gcopystack, _Grunning) gogo(\u0026gp.sched) }   其中的 canPreemptM 验证了可以被抢占的条件：\n 运行时没有禁止抢占（m.locks == 0） 运行时没有在执行内存分配（m.mallocing == 0） 运行时没有关闭抢占机制（m.preemptoff == “\"） M 与 P 绑定且没有进入系统调用（p.status == _Prunning）  1 2 3 4 5 6  // canPreemptM 报告 mp 是否处于可抢占的安全状态。 //go:nosplit func canPreemptM(mp *m) bool { //如果M持有锁,或者正在进行内存分配,垃圾回收等操作,不抢占,留待下次 \treturn mp.locks == 0 \u0026\u0026 mp.mallocing == 0 \u0026\u0026 mp.preemptoff == \"\" \u0026\u0026 mp.p.ptr().status == _Prunning }   第一次判断 preempt 标志是 true 时，检查了 g 的状态，发现不能抢占，例如它所绑定的 P 的状态不是 _Prunning，那就恢复它的 stackguard0 字段，下次就不会走这一套流程了。然后，调用 gogo(\u0026gp.sched) 继续执行当前的 goroutine。\n中间又处理了很多判断流程，再次判断 preempt 标志是 true 时，调用 gopreempt_m(gp) 将 gp 切换出去。\ngopreempt_m函数在proc.go中定义，它的参数是需要停止的G。它就干了一件事，调用goschedImpl函数。\n1 2 3 4 5 6  func gopreempt_m(gp *g) { if trace.enabled { traceGoPreempt() } goschedImpl(gp) }   goschedImpl函数也在proc.go文件中，参数是要停止的G。该函数首先把这个G从Grunning状态转到Grunnable状态。然后调用dropg函数解除这个G与当前M的关联。再把这个G放入调度器的可运行G队列，最后调用schedule函数进行一轮调度，为当前P找一个新的可运行G来运行。至此抢占结束。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func goschedImpl(gp *g) { status := readgstatus(gp) if status\u0026^_Gscan != _Grunning { dumpgstatus(gp) throw(\"bad g status\") } // 更改 gp 的状态 \tcasgstatus(gp, _Grunning, _Grunnable) // 解除 m 和 g 的关系 \tdropg() lock(\u0026sched.lock) // 将 gp 放入全局可运行队列 \tglobrunqput(gp) unlock(\u0026sched.lock) // 进入新一轮的调度循环 \tschedule() }   将 gp 的状态改为 _Grunnable，放入全局可运行队列，等待下次有 m 来全局队列找工作时才能继续运行，毕竟你已经运行这么长时间了，给别人一点机会嘛。\n最后，调用 schedule() 函数进入新一轮的调度循环，会找出一个 goroutine 来运行，永不返回。\n从可被抢占的条件来看，能够对一个 G 进行抢占其实是呈保守状态的。 这一保守体现在抢占对很多运行时所需的条件进行了判断，这也理所当然是因为 运行时优先级更高，不应该轻易发生抢占， 但与此同时由于又需要对用户态代码进行抢占，于是先作出一次不需要抢占的判断（快速路径）， 确定不能抢占时返回并继续调度，如果真的需要进行抢占，则转入调用 gopreempt_m， 放弃当前 G 的执行权，将其加入全局队列，重新进入调度循环。\n什么时候会会给 stackguard0 设置抢占标记 stackPreempt 呢？ 一共有以下几种情况：\n 进入系统调用时（runtime.reentersyscall，注意这种情况是为了保证不会发生栈分裂， 真正的抢占是异步的通过系统监控进行的） 任何运行时不再持有锁的时候（m.locks == 0） 当垃圾回收器需要停止所有用户 Goroutine 时  基于信号的抢占式调度(preemptM) 从上面提到的调度逻辑我们可以看出，这种需要用户代码来主动配合的调度方式存在 一些致命的缺陷：一个没有主动放弃执行权、且不参与任何函数调用的函数，直到执行完毕之前， 是不会被抢占的。那么这种不会被抢占的函数会导致什么严重的问题呢？回答是，由于运行时无法 停止该用户代码，则当需要进行垃圾回收时，无法及时进行；对于一些实时性要求较高的用户态 Goroutine 而言，也久久得不到调度。我们直接来看一个非常简单的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 此程序在 Go 1.14 之前的版本不会输出 OK package main import ( \"runtime\" \"time\" ) func main() { runtime.GOMAXPROCS(1) go func() { for { } }() time.Sleep(time.Millisecond) println(\"OK\") }   这段代码中处于死循环的 Goroutine 永远无法被抢占，其中创建的 Goroutine 会执行一个不产生任何调用、不主动放弃执行权的死循环。由于主 Goroutine 优先调用了 休眠，此时唯一的 P 会转去执行 for 循环所创建的 Goroutine。进而主 Goroutine 永远不会再被调度，进而程序彻底阻塞在了这四个 Goroutine 上，永远无法退出.如果有多个P并发执行,此时一个P死循环,因为垃圾回收触发时无法抢占该Goroutine,垃圾回收在STW阶段会一直卡住,最终导致进程假死。这样的例子 非常多，但追根溯源，均为此问题导致\nGo 语言在 1.14 版本中实现了非协作的抢占式调度，在实现的过程中我们重构已有的逻辑并为 Goroutine 增加新的状态和字段来支持抢占。Go 团队通过下面的一系列提交实现了这一功能，我们可以按时间顺序分析相关提交理解它的工作原理：\n runtime: add general suspendG/resumeG  挂起 Goroutine 的过程是在垃圾回收的栈扫描时完成的，我们通过 runtime.suspendG 和 runtime.resumeG 两个函数重构栈扫描这一过程； 调用 runtime.suspendG 函数时会将处于运行状态的 Goroutine 的 preemptStop 标记成 true； 调用 runtime.preemptPark 函数可以挂起当前 Goroutine、将其状态更新成 _Gpreempted 并触发调度器的重新调度，该函数能够交出线程控制权；   runtime: asynchronous preemption function for x86  在 x86 架构上增加异步抢占的函数 runtime.asyncPreempt 和 runtime.asyncPreempt2；   runtime: use signals to preempt Gs for suspendG  支持通过向线程发送信号的方式暂停运行的 Goroutine； 在 runtime.sighandler 函数中注册 SIGURG 信号的处理函数 runtime.doSigPreempt； 实现 runtime.preemptM 函数，它可以通过 SIGURG 信号向线程发送抢占请求；   runtime: implement async scheduler preemption  修改 runtime.preemptone 函数的实现，加入异步抢占的逻辑；    目前的抢占式调度也只会在垃圾回收扫描任务时触发，我们可以梳理一下上述代码实现的抢占式调度过程：\n 程序启动时，在 runtime.sighandler 函数中注册 SIGURG 信号的处理函数 runtime.doSigPreempt； 在触发垃圾回收的栈扫描时会调用 runtime.suspendG 挂起 Goroutine，该函数会执行下面的逻辑：  将 _Grunning 状态的 Goroutine 标记成可以被抢占，即将 preemptStop 设置成 true； 调用 runtime.preemptM 触发抢占；   runtime.preemptM 会调用 runtime.signalM 向线程发送信号 SIGURG； 操作系统会中断正在运行的线程并执行预先注册的信号处理函数 runtime.doSigPreempt； runtime.doSigPreempt 函数会处理抢占信号，获取当前的 SP 和 PC 寄存器并调用 runtime.sigctxt.pushCall； runtime.sigctxt.pushCall 会修改寄存器并在程序回到用户态时执行 runtime.asyncPreempt； 汇编指令 runtime.asyncPreempt 会调用运行时函数 runtime.asyncPreempt2； runtime.asyncPreempt2 会调用 runtime.preemptPark； runtime.preemptPark 会修改当前 Goroutine 的状态到_Gpreempted 并调用 runtime.schedule 让当前函数陷入休眠并让出线程，调度器会选择其它的 Goroutine 继续执行；  上述 9 个步骤展示了基于信号的抢占式调度的执行过程。除了分析抢占的过程之外，我们还需要讨论一下抢占信号的选择，提案根据以下的四个原因选择 SIGURG 作为触发异步抢占的信号；\n 该信号需要被调试器透传； 该信号不会被内部的 libc 库使用并拦截； 该信号可以随意出现并且不触发任何后果； 我们需要处理多个平台上的不同信号；  STW 和栈扫描是一个可以抢占的安全点（Safe-points），所以 Go 语言会在这里先加入抢占功能。基于信号的抢占式调度只解决了垃圾回收和栈扫描时存在的问题，它到目前为止没有解决全部问题，但是这种真抢占式调度时调度器走向完备的开始，相信在未来我们可以会更多的地方触发抢占。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // Tell the goroutine running on processor P to stop. // This function is purely best-effort. It can incorrectly fail to inform the // goroutine. It can send inform the wrong goroutine. Even if it informs the // correct goroutine, that goroutine might ignore the request if it is // simultaneously executing newstack. // No lock needs to be held. // Returns true if preemption request was issued. // The actual preemption will happen at some point in the future // and will be indicated by the gp-status no longer being // Grunning func preemptone(_p_ *p) bool { ... // Request an async preemption of this P. \t// 请求该 P 的异步抢占 \tif preemptMSupported \u0026\u0026 debug.asyncpreemptoff == 0 { _p_.preempt = true preemptM(mp) } return true }   抢占信号的选取 preemptM 完成了信号的发送，其实现也非常直接，直接向需要进行抢占的 M 发送 SIGURG 信号 即可。但是真正的重要的问题是，为什么是 SIGURG 信号而不是其他的信号？如何才能保证该信号 不与用户态产生的信号产生冲突？这里面有几个原因：\n 默认情况下，SIGURG 已经用于调试器传递信号。 SIGRUURG 可以不加选择地虚假发生的信号。例如，我们不能选择 SIGALRM，因为 信号处理程序无法分辨它是否是由实际过程引起的（可以说这意味着信号已损坏）。 而常见的用户自定义信号 SIGUSR1 和 SIGUSR2 也不够好，因为用户态代码可能会将其进行使用 需要处理没有实时信号的平台（例如 macOS）  考虑以上的观点，SIGURG 其实是一个很好的、满足所有这些条件、且极不可能因被用户态代码 进行使用的一种信号。\n1 2 3 4 5 6 7 8 9 10 11 12  const sigPreempt = _SIGURG // preemptM 向 mp 发送抢占请求。该请求可以异步处理，也可以与对 M 的其他请求合并。 // 接收到该请求后，如果正在运行的 G 或 P 被标记为抢占，并且 Goroutine 处于异步安全点， // 它将抢占 Goroutine。在处理抢占请求后，它始终以原子方式递增 mp.preemptGen。 func preemptM(mp *m) { ... signalM(mp, sigPreempt) } func signalM(mp *m, sig int) { tgkill(getpid(), int(mp.procid), sig) }   通过系统调用 tgkill，给特定的线程发信号\n抢占调用的注入 Go 运行时进行信号处理的基本做法，其核心是注册 sighandler 函数，并在信号到达后， 由操作系统中断转入内核空间，而后将所中断线程的执行上下文参数（例如寄存器 rip, rep 等） 传递给处理函数。如果在 sighandler 中修改了这个上下文参数，操作系统则会根据修改后的 上下文信息恢复执行，这也就为抢占提供了机会。\n1 2 3 4 5 6 7 8 9 10 11 12 13  //go:nowritebarrierrec func sighandler(sig uint32, info *siginfo, ctxt unsafe.Pointer, gp *g) { ... c := \u0026sigctxt{info, ctxt} ... if sig == sigPreempt { // 可能是一个抢占信号 \tdoSigPreempt(gp, c) // 即便这是一个抢占信号，它也可能与其他信号进行混合，因此我们 \t// 继续进行处理。 \t} ... }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // doSigPreempt handles a preemption signal on gp. // doSigPreempt 处理了 gp 上的抢占信号 func doSigPreempt(gp *g, ctxt *sigctxt) { // Check if this G wants to be preempted and is safe to \t// preempt. \t// 检查 G 是否需要被抢占、抢占是否安全 \tif wantAsyncPreempt(gp) { if ok, newpc := isAsyncSafePoint(gp, ctxt.sigpc(), ctxt.sigsp(), ctxt.siglr()); ok { // Adjust the PC and inject a call to asyncPreempt. \t// 插入抢占调用 \tctxt.pushCall(funcPC(asyncPreempt), newpc) } } // Acknowledge the preemption. \tatomic.Xadd(\u0026gp.m.preemptGen, 1) atomic.Store(\u0026gp.m.signalPending, 0) // 记录抢占 \tif GOOS == \"darwin\" { atomic.Xadd(\u0026pendingPreemptSignals, -1) } }   在 ctxt.pushCall 之前， ctxt.rip() 和 ctxt.rep() 都保存了被中断的 Goroutine 所在的位置， 但是 pushCall 直接修改了这些寄存器，进而当从 sighandler 返回用户态 Goroutine 时， 能够从注入的 asyncPreempt 开始执行：\n1 2 3 4 5 6 7 8  func (c *sigctxt) pushCall(targetPC uintptr) { pc := uintptr(c.rip()) sp := uintptr(c.rsp()) sp -= sys.PtrSize *(*uintptr)(unsafe.Pointer(sp)) = pc c.set_rsp(uint64(sp)) c.set_rip(uint64(targetPC)) }   完成 sighandler 之后，我们成功恢复到 asyncPreempt 调用：\n1 2 3 4  // asyncPreempt 保存了所有用户寄存器，并调用 asyncPreempt2 // // 当栈扫描遭遇 asyncPreempt 栈帧时，将会保守的扫描调用方栈帧 func asyncPreempt()   该函数的主要目的是保存用户态寄存器，并且在调用完毕前恢复所有的寄存器上下文， 就好像什么事情都没有发生过一样：\n1 2 3 4 5 6 7 8 9 10 11  TEXT ·asyncPreempt(SB),NOSPLIT|NOFRAME,$0-0 ... MOVQ AX, 0(SP) ... MOVUPS X15, 352(SP) CALL ·asyncPreempt2(SB) MOVUPS 352(SP), X15 ... MOVQ 0(SP), AX ... RET   当调用 asyncPreempt2 时，会根据 preemptPark 或者 gopreempt_m 重新切换回调度循环，从而打断密集循环的继续执行。\n1 2 3 4 5 6 7 8 9 10 11 12  //go:nosplit func asyncPreempt2() { gp := getg() gp.asyncSafePoint = true if gp.preemptStop { mcall(preemptPark) } else { mcall(gopreempt_m) } // 异步抢占过程结束 \tgp.asyncSafePoint = false }   至此，异步抢占过程结束。我们总结一下抢占调用的整体逻辑：\n M1 发送中断信号（signalM(mp, sigPreempt)） M2 收到信号，操作系统中断其执行代码，并切换到信号处理函数（sighandler(signum, info, ctxt, gp)） M2 修改执行的上下文，并恢复到修改后的位置（asyncPreempt） 重新进入调度循环进而调度其他 Goroutine（preemptPark 和 gopreempt_m）  sysmon抢占(gopreempt_m) sysmon 抢占流程:\nsysmon - retake - preemptone - asyncPreempt - globalrunqput\nsysmon抢占后会把g放到全局队列中.\n1 2 3 4 5 6  func gopreempt_m(gp *g) { if trace.enabled { traceGoPreempt() } goschedImpl(gp) }   1 2 3 4 5 6 7 8 9 10 11 12 13 14  func goschedImpl(gp *g) { status := readgstatus(gp) if status\u0026^_Gscan != _Grunning { dumpgstatus(gp) throw(\"bad g status\") } casgstatus(gp, _Grunning, _Grunnable) dropg() lock(\u0026sched.lock) globrunqput(gp) unlock(\u0026sched.lock) schedule() }   GC抢占(preemptPark) GC 抢占流程:\nmarkroot - allgs[i] - g - suspendG(g) - scan g stack - resumeG\nresumeG会执行runqput,当g被其他线程调度到时,从asyncPreempt的下半部分继续执行.\nGC走的是preemptPark分支,M和G解除绑定,G暂停执行,M继续调度其他G.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // preemptPark parks gp and puts it in _Gpreempted. // //go:systemstack func preemptPark(gp *g) { if trace.enabled { traceGoPark(traceEvGoBlock, 0) } status := readgstatus(gp) if status\u0026^_Gscan != _Grunning { dumpgstatus(gp) throw(\"bad g status\") } gp.waitreason = waitReasonPreempted // Transition from _Grunning to _Gscan|_Gpreempted. We can't \t// be in _Grunning when we dropg because then we'd be running \t// without an M, but the moment we're in _Gpreempted, \t// something could claim this G before we've fully cleaned it \t// up. Hence, we set the scan bit to lock down further \t// transitions until we can dropg. \tcasGToPreemptScan(gp, _Grunning, _Gscan|_Gpreempted) dropg() casfrom_Gscanstatus(gp, _Gscan|_Gpreempted, _Gpreempted) schedule() }   小结 总的来说，应用层的调度策略不易实现，因此实现上也并不是特别紧急。我们回顾 Go 语言调度策略的演变过程 不难发现，实现它们的动力是从实际需求出发的。Go 语言从设计之初并没有刻意的去考虑对 Goroutine 的抢占机制。 从早期无法对 Goroutine 进行抢占的原始时代，到现在的协作与抢占同时配合的调度策略， 其问题的核心是垃圾回收等运行时机制的需要。\n当运行时需要执行垃圾回收时，协作式调度能够保证具备函数调用的用户 Goroutine 正常停止； 抢占式调度则能避免由于死循环导致的任意时间的垃圾回收延迟。有了这两种不同的调度策略， Go 语言的用户可以放心的写出各种形式的代码逻辑，即使运行时垃圾回收也能够在适当的时候及时中断用户代码， 不至于导致整个系统进入不可预测的停顿。\n转载 6.8 协作与抢占\n",
  "wordCount" : "10849",
  "inLanguage": "zh-cn",
  "datePublished": "2020-11-27T17:25:33Z",
  "dateModified": "2020-11-27T17:25:33Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/go%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E5%8D%8F%E4%BD%9C%E4%B8%8E%E6%8A%A2%E5%8D%A0/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Go调度器的协作与抢占
    </h1>
    <div class="post-meta">November 27, 2020
</div>
  </header> 
  <div class="post-content"><h2 id="前言">前言<a hidden class="anchor" aria-hidden="true" href="#前言">#</a></h2>
<p>如果某个 G 执行时间过长，其他的 G 如何才能被正常的调度？ 这便涉及到有关调度的两个理念：协作式调度与抢占式调度。</p>
<p>协作式和抢占式这两个理念解释起来很简单： 协作式调度依靠被调度方主动弃权；抢占式调度则依靠调度器强制将被调度方被动中断。 这两个概念其实描述了调度的两种截然不同的策略，这两种决策模式，在调度理论中其实已经研究得很透彻了。</p>
<p>Go 的运行时并不具备操作系统内核级的硬件中断能力，基于工作窃取的调度器实现，本质上属于 先来先服务的协作式调度，为了解决响应时间可能较高的问题，目前运行时实现了两种不同的调度策略、 每种策略各两个形式。保证在大部分情况下，不同的 G 能够获得均匀的时间片：</p>
<ul>
<li>同步协作式调度
<ol>
<li>主动用户让权：通过 runtime.Gosched 调用主动让出执行机会；</li>
<li>主动调度弃权：当发生执行栈分段时，检查自身的抢占标记，决定是否继续执行；</li>
</ol>
</li>
<li>异步抢占式调度
<ol>
<li>被动监控抢占：P长时间运行或进行系统调用，系统监控会将 P 从 M 上抢夺并分配给其他的 M 来执行其他的 G，而位于被抢夺 P 的 M 本地调度队列中 的 G 则可能会被偷取到其他 M 中。</li>
<li>被动 GC 抢占：当需要进行垃圾回收时，为了保证不具备主动抢占处理的函数执行时间过长，导致垃圾回收迟迟不得执行而导致的高延迟，而强制停止 G 并转为执行垃圾回收,该抢占在第一次STW时进行.</li>
</ol>
</li>
</ul>
<h2 id="协作式调度">协作式调度<a hidden class="anchor" aria-hidden="true" href="#协作式调度">#</a></h2>
<h3 id="主动用户让权gosched">主动用户让权：Gosched<a hidden class="anchor" aria-hidden="true" href="#主动用户让权gosched">#</a></h3>
<p>Gosched 是一种主动放弃执行的手段，用户态代码通过调用此接口来出让执行机会，使其他人也能在 密集的执行过程中获得被调度的机会。</p>
<p>当然，尽管具有主动弃权的能力，但它对 Go 语言的用户要求比较高， 因为用户在编写并发逻辑的时候需要自行甄别是否需要让出时间片，这并非用户友好的， 而且很多 Go 的新用户并不会了解到这个问题的存在，我们在随后的抢占式调度中再进一步展开讨论。</p>
<h3 id="主动调度弃权栈扩张与抢占标记">主动调度弃权：栈扩张与抢占标记<a hidden class="anchor" aria-hidden="true" href="#主动调度弃权栈扩张与抢占标记">#</a></h3>
<p>另一种主动放弃的方式是通过抢占标记的方式实现的。基本想法是在每个函数调用的序言 （函数调用的最前方）插入抢占检测指令，当检测到当前 Goroutine 被标记为被应该被抢占时， 则主动中断执行，让出执行权利。</p>
<h2 id="基于协作的抢占式调度preemptone">基于协作的抢占式调度(preemptone)<a hidden class="anchor" aria-hidden="true" href="#基于协作的抢占式调度preemptone">#</a></h2>
<h3 id="设计原理">设计原理<a hidden class="anchor" aria-hidden="true" href="#设计原理">#</a></h3>
<p>我们知道现代操作系统的调度器多为抢占式调度，其实现方式通过硬件中断来支持线程的切换， 进而能安全的保存运行上下文。在 Go 运行时实现抢占式调度同样也可以使用类似的方式，通过 向线程发送系统信号的方式来中断 M 的执行，进而达到抢占的目的。 但与操作系统的不同之处在于，由于运行时诸多机制的存在（例如垃圾回收器），还必须能够在 Goroutine 被停止时，保存充足的上下文信息。 这就给中断信号带来了麻烦，如果中断信号恰好发生在一些关键阶段（例如写屏障期间）， 则无法保证程序的正确性。这也就要求我们需要严格考虑触发异步抢占的时机。</p>
<p>异步抢占式调度的一种方式就与运行时系统监控有关，监控循环会将发生阻塞的 Goroutine 抢占， 解绑 P 与 M，从而让其他的线程能够获得 P 继续执行其他的 Goroutine。 这得益于 sysmon 中调用的 retake 方法。这个方法处理了两种抢占情况， 一是抢占阻塞在系统调用上的 P，二是抢占运行时间过长的 G。 其中抢占运行时间过长的 G 这一方式还会出现在垃圾回收需要进入 STW 时。</p>
<p>我们可以在 pkg/runtime/proc.c 文件中找到引入基于协作的抢占式调度后的调度器。Go 语言会在分段栈的机制上实现抢占调度，利用编译器在分段栈上插入的函数，所有 Goroutine 在函数调用时都有机会进入运行时检查是否需要执行抢占。Go 团队通过以下的多个提交实现该特性：</p>
<ul>
<li>runtime: add stackguard0 to G
<ul>
<li>为 Goroutine 引入 stackguard0 字段，该字段被设置成 StackPreempt 意味着当前 Goroutine 发出了抢占请求；</li>
</ul>
</li>
<li>runtime: introduce preemption function (not used for now)
<ul>
<li>引入抢占函数 runtime.preemptone 和 runtime.preemptall，这两个函数会改变 Goroutine 的 stackguard0 字段发出抢占请求；</li>
<li>定义抢占请求 StackPreempt；</li>
</ul>
</li>
<li>runtime: preempt goroutines for GC
<ul>
<li>在 runtime.stoptheworld 中调用 runtime.preemptall 设置所有处理器上正在运行的 Goroutine 的 stackguard0 为 StackPreempt；</li>
<li>在 runtime.newstack 函数中增加抢占的代码，当 stackguard0 等于 StackPreempt 时触发调度器抢占让出线程；</li>
</ul>
</li>
<li>runtime: preempt long-running goroutines
<ul>
<li>在系统监控中，如果一个 Goroutine 的运行时间超过 10ms，就会调用 runtime.retake 和 runtime.preemptone；</li>
</ul>
</li>
<li>runtime: more reliable preemption
<ul>
<li>修复 Goroutine 因为周期性执行非阻塞的 CGO 或者系统调用不会被抢占的问题；</li>
</ul>
</li>
</ul>
<p>上面的多个提交实现了抢占式调度，但是还缺少最关键的一个环节 — 编译器如何在函数调用前插入函数，我们能在非常古老的提交 runtime: stack growth adjustments, cleanup 中找到编译器插入函数的出行，最新版本的 Go 语言会通过 cmd/internal/obj/x86.stacksplit 插入 runtime.morestack 函数，该函数可能会调用 runtime.newstack 触发抢占。从上面的多个提交中，我们能归纳出基于协作的抢占式调度的工作原理：</p>
<ol>
<li>编译器会在调用函数前插入 runtime.morestack；</li>
<li>Go 语言运行时会在垃圾回收暂停程序、系统监控发现 Goroutine 运行超过 10ms 时发出抢占请求 StackPreempt；</li>
<li>当发生函数调用时，可能会执行编译器插入的 runtime.morestack 函数，它调用的 runtime.newstack 会检查 Goroutine 的 stackguard0 字段是否为 StackPreempt；</li>
<li>如果 stackguard0 是 StackPreempt，就会触发抢占让出当前线程；</li>
</ol>
<p>这种实现方式虽然增加了运行时的复杂度，但是实现相对简单，也没有带来过多的额外开销，总体来看还是比较成功的实现，也在 Go 语言中使用了 10 几个版本。因为这里的抢占是通过编译器插入函数实现的，还是需要函数调用作为入口才能触发抢占，所以这是一种协作式的抢占式调度。</p>
<h3 id="源码剖析">源码剖析<a hidden class="anchor" aria-hidden="true" href="#源码剖析">#</a></h3>
<p>preemptone 本质是将正在 P 上执行的 M 的 curg 的标志位置为 true.这之后的流程需要正在运行的 goroutine 来配合.</p>
<p>调用preemptone函数抢占该P，这也是go抢占式调度的体现。不过该函数只能告知在这个P上运行的G应该停止了。首先它不一定能正确的告知正确的G，其次即使告知被正确传递给了正确的G，这个G也可能忽略掉这个告知。也就是说preemptone函数只能告诉你我尽力而为，既不能保证告知正确到达，也不能保证那个G做出相应。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Tell the goroutine running on processor P to stop.
</span><span class="c1">// This function is purely best-effort. It can incorrectly fail to inform the
</span><span class="c1">// goroutine. It can send inform the wrong goroutine. Even if it informs the
</span><span class="c1">// correct goroutine, that goroutine might ignore the request if it is
</span><span class="c1">// simultaneously executing newstack.
</span><span class="c1">// No lock needs to be held.
</span><span class="c1">// Returns true if preemption request was issued.
</span><span class="c1">// The actual preemption will happen at some point in the future
</span><span class="c1">// and will be indicated by the gp-&gt;status no longer being
</span><span class="c1">// Grunning
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">preemptone</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// 检查 M 与 P 是否绑定
</span><span class="c1"></span>	<span class="nx">mp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">mp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">mp</span> <span class="o">==</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">curg</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">gp</span> <span class="o">==</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">// 将 G 标记为抢占
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">true</span>

	<span class="c1">// Every call in a go routine checks for stack overflow by
</span><span class="c1"></span>	<span class="c1">// comparing the current stack pointer to gp-&gt;stackguard0.
</span><span class="c1"></span>	<span class="c1">// Setting gp-&gt;stackguard0 to StackPreempt folds
</span><span class="c1"></span>	<span class="c1">// preemption into the normal stack overflow check.
</span><span class="c1"></span>	<span class="c1">// 一个 Goroutine 中的每个调用都会通过比较当前栈指针和 gp.stackgard0
</span><span class="c1"></span>	<span class="c1">// 来检查栈是否溢出。
</span><span class="c1"></span>	<span class="c1">// 设置 gp.stackgard0 为 StackPreempt 来将抢占转换为正常的栈溢出检查。
</span><span class="c1"></span>	<span class="c1">// 在 goroutine 内部的每次调用都会比较栈顶指针和 g.stackguard0，
</span><span class="c1"></span>    	<span class="c1">// 来判断是否发生了栈溢出。stackPreempt 非常大的一个数，比任何栈都大
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span>

	<span class="c1">// Request an async preemption of this P.
</span><span class="c1"></span>	<span class="c1">// 请求该 P 的异步抢占
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">preemptMSupported</span> <span class="o">&amp;&amp;</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">asyncpreemptoff</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nf">preemptM</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>有两个标志,实际起作用的是G.stackguard0. G.preempt只是后备,以便在stackguard()做回溢出检查标志时,依然可用preempt恢复抢占状态.</p>
<p>当morestack调用newstack扩容时会检查抢占标志,并决定是否暂停当前任务,当然这发生在实际扩容之前.</p>
<p>go程序在执行G的每次调用时，都会通过比较当前堆栈指针和G的stackguard0字段来判断栈溢出。这里将当前G的stackguard0字段赋值为stackPreempt就会该G在下一次函数调用时栈空间检查失败，接下来就是一些列的函数调用，最终将这个G调度出去。</p>
<p>在讲述这一些列函数调用之前，我们先来认识一下stackPreempt。</p>
<p>它是在stack.go中定义的一个常量。在64位机器上，stackPreempt的值是0xfffffffffffffade，在32位机器上它的值是0xfffffade。表示的是栈指针sp的最大值，所以现在你知道为什么将stackguard0的值设置成它就能导致栈溢出了吧。它的计算出来需要用到uintptrMask，它是一个指针掩码，也就是一个所有位全为1的指针，32位机器上是0xffffffff，64位机器上是0xffffffffffffffff。在计算uintptrMask时用到的sys.PtrSize在sys包中的stubs.go文件中定义。^uintptr(0)得到的是一个各位都为1的值，32位机器上就是32个1,64位机器上就是64个1。左移63位后，如果是32位机器，结果就是0，接下来4右移0位还是4；64位机器结果是1，4右移1位后结果是8。所以PtrSize表示的就是一个指针长度的字节数。而一个字节的长度是8，所以在计算uintptrMask时用8乘以sys.PtrSize得到的就是一个指针的位数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="cm">/* stack.go */</span>
<span class="c1">// Goroutine 抢占请求
</span><span class="c1">// 存储到 g.stackguard0 来导致栈分段检查失败
</span><span class="c1">// 必须比任何实际的 SP 都要大
</span><span class="c1">// 十六进制为：0xfffffade
</span><span class="c1"></span><span class="kd">const</span> <span class="p">(</span>
   <span class="nx">uintptrMask</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="nx">stackPreempt</span> <span class="p">=</span> <span class="nx">uintptrMask</span> <span class="o">&amp;</span> <span class="o">-</span><span class="mi">1314</span>
<span class="p">)</span>

<span class="cm">/* package sys */</span>
<span class="kd">const</span> <span class="nx">PtrSize</span> <span class="p">=</span> <span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="p">(^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">63</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>举一个简单的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>执行命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nx">tool</span> <span class="nx">compile</span> <span class="o">-</span><span class="nx">S</span> <span class="nx">main</span><span class="p">.</span><span class="k">go</span>
</code></pre></td></tr></table>
</div>
</div><p>得到汇编代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">main</span> <span class="nx">STEXT</span> <span class="nx">size</span><span class="p">=</span><span class="mi">120</span> <span class="nx">args</span><span class="p">=</span><span class="mh">0x0</span> <span class="nx">locals</span><span class="p">=</span><span class="mh">0x48</span>
    <span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">TEXT</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nf">main</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="err">$</span><span class="mi">72</span><span class="o">-</span><span class="mi">0</span>
    <span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nf">MOVQ</span>    <span class="p">(</span><span class="nx">TLS</span><span class="p">),</span> <span class="nx">CX</span>
    <span class="mh">0x0009</span> <span class="mo">0000</span><span class="mi">9</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">CMPQ</span>    <span class="nx">SP</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
    <span class="mh">0x000d</span> <span class="mo">00013</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">JLS</span>    <span class="mi">113</span>
    <span class="mh">0x000f</span> <span class="mo">00015</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">SUBQ</span>    <span class="err">$</span><span class="mi">72</span><span class="p">,</span> <span class="nx">SP</span>
    <span class="mh">0x0013</span> <span class="mo">0001</span><span class="mi">9</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="nx">BP</span><span class="p">,</span> <span class="mi">64</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x0018</span> <span class="mo">00024</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">LEAQ</span>    <span class="mi">64</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BP</span>
    <span class="mh">0x001d</span> <span class="mo">0002</span><span class="mi">9</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">FUNCDATA</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nx">gclocals</span><span class="err">·</span><span class="mi">69</span><span class="nf">c1753bd5f81501d95132d08af04464</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
    <span class="mh">0x001d</span> <span class="mo">0002</span><span class="mi">9</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">FUNCDATA</span>    <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="nx">gclocals</span><span class="err">·</span><span class="nf">e226d4ae4a7cad8835311c6a4683c14f</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
    <span class="mh">0x001d</span> <span class="mo">0002</span><span class="mi">9</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">..</span><span class="nx">autotmp_0</span><span class="o">+</span><span class="mi">48</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x0026</span> <span class="mo">0003</span><span class="mi">8</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">..</span><span class="nx">autotmp_0</span><span class="o">+</span><span class="mi">56</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x002f</span> <span class="mo">00047</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">LEAQ</span>    <span class="kd">type</span><span class="p">.</span><span class="nb">string</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
    <span class="mh">0x0036</span> <span class="mo">00054</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">..</span><span class="nx">autotmp_0</span><span class="o">+</span><span class="mi">48</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x003b</span> <span class="mo">0005</span><span class="mi">9</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">LEAQ</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nf">statictmp_0</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
    <span class="mh">0x0042</span> <span class="mo">00066</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">..</span><span class="nx">autotmp_0</span><span class="o">+</span><span class="mi">56</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x0047</span> <span class="mo">00071</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">LEAQ</span>    <span class="s">&#34;&#34;</span><span class="p">..</span><span class="nx">autotmp_0</span><span class="o">+</span><span class="mi">48</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>
    <span class="mh">0x004c</span> <span class="mo">00076</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x0050</span> <span class="mo">000</span><span class="mi">80</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x0059</span> <span class="mo">000</span><span class="mi">89</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x0062</span> <span class="mo">000</span><span class="mi">98</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">PCDATA</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="err">$</span><span class="mi">1</span>
    <span class="mh">0x0062</span> <span class="mo">000</span><span class="mi">98</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">CALL</span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
    <span class="mh">0x0067</span> <span class="mo">00103</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="mi">64</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BP</span>
    <span class="mh">0x006c</span> <span class="mo">0010</span><span class="mi">8</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>    <span class="nx">ADDQ</span>    <span class="err">$</span><span class="mi">72</span><span class="p">,</span> <span class="nx">SP</span>
    <span class="mh">0x0070</span> <span class="mo">00112</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>    <span class="nx">RET</span>
    <span class="mh">0x0071</span> <span class="mo">00113</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>    <span class="nx">NOP</span>
    <span class="mh">0x0071</span> <span class="mo">00113</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">PCDATA</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="err">$</span><span class="o">-</span><span class="mi">1</span>
    <span class="mh">0x0071</span> <span class="mo">00113</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="p">.</span><span class="nf">morestack_noctxt</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
    <span class="mh">0x0076</span> <span class="mo">0011</span><span class="mi">8</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">JMP</span>    <span class="mi">0</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nf">MOVQ</span>    <span class="p">(</span><span class="nx">TLS</span><span class="p">),</span> <span class="nx">CX</span>
</code></pre></td></tr></table>
</div>
</div><p>将本地存储 tls 保存到 CX 寄存器中，（TLS）表示它所关联的 g，这里就是前面所讲到的 main gouroutine。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="mh">0x0009</span> <span class="mo">0000</span><span class="mi">9</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">CMPQ</span>    <span class="nx">SP</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>比较 SP 寄存器（代表当前 main goroutine 的栈顶寄存器）和 16(CX)，我们看下 g 结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// goroutine 使用的栈
</span><span class="c1"></span>    <span class="nx">stack</span>       <span class="nx">stack</span>   <span class="c1">// offset known to runtime/cgo
</span><span class="c1"></span>    <span class="c1">// 用于栈的扩张和收缩检查
</span><span class="c1"></span>    <span class="nx">stackguard0</span> <span class="kt">uintptr</span> <span class="c1">// offset known to liblink
</span><span class="c1"></span>    <span class="c1">// ……………………
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>对象 g 的第一个字段是 stack 结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">stack</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">lo</span> <span class="kt">uintptr</span>
    <span class="nx">hi</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>共 16 字节。而 16(CX) 表示 g 对象的第 16 个字节，跳过了 g 的第一个字段，也就是 g.stackguard0 字段。</p>
<p>如果 SP 小于 g.stackguard0，这是必然的，因为前面已经把 g.stackguard0 设置成了一个非常大的值，因此跳转到了 113 行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="mh">0x0071</span> <span class="mo">00113</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>    <span class="nx">NOP</span>
<span class="mh">0x0071</span> <span class="mo">00113</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">PCDATA</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="err">$</span><span class="o">-</span><span class="mi">1</span>
<span class="mh">0x0071</span> <span class="mo">00113</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="p">.</span><span class="nf">morestack_noctxt</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
<span class="mh">0x0076</span> <span class="mo">0011</span><span class="mi">8</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">JMP</span>    <span class="mi">0</span>
</code></pre></td></tr></table>
</div>
</div><p>调用 runtime.morestack_noctxt 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/asm_amd64.s
</span><span class="c1"></span><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">morestack_noctxt</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span><span class="nx">NOSPLIT</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span>
    <span class="nx">MOVL</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nx">DX</span>
	<span class="nx">JMP</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">morestack</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>直接跳转到 morestack 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">morestack</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span><span class="nx">NOSPLIT</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">0</span>
    <span class="c1">// Cannot grow scheduler stack (m-&gt;g0).
</span><span class="c1"></span>    <span class="nf">get_tls</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
    <span class="c1">// BX = g，g 表示 main goroutine
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">BX</span>
    <span class="c1">// BX = g.m
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nf">g_m</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BX</span>
    <span class="c1">// SI = g.m.g0
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nf">m_g0</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">SI</span>
    <span class="nx">CMPQ</span>    <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">SI</span>
    <span class="nx">JNE</span>    <span class="mi">3</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>
    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">badmorestackg0</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
    <span class="nx">INT</span>    <span class="err">$</span><span class="mi">3</span>

    <span class="c1">// ……………………
</span><span class="c1"></span>
    <span class="c1">// Set g-&gt;sched to context in f.
</span><span class="c1"></span>    <span class="c1">// 将函数的返回地址保存到 AX 寄存器
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="mi">0</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span> <span class="c1">// f&#39;s PC
</span><span class="c1"></span>    <span class="c1">// 将函数的返回地址保存到 g.sched.pc
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_pc</span><span class="p">)(</span><span class="nx">SI</span><span class="p">)</span>
    <span class="c1">// g.sched.g = g
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">SI</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_g</span><span class="p">)(</span><span class="nx">SI</span><span class="p">)</span>
    <span class="c1">// 取地址操作符，调用 morestack_noctxt 之前的 rsp
</span><span class="c1"></span>    <span class="nx">LEAQ</span>    <span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span> <span class="c1">// f&#39;s SP
</span><span class="c1"></span>    <span class="c1">// 将 main 函数的栈顶地址保存到 g.sched.sp
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">SI</span><span class="p">)</span>
    <span class="c1">// 将 BP 寄存器保存到 g.sched.bp
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">BP</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_bp</span><span class="p">)(</span><span class="nx">SI</span><span class="p">)</span>
    <span class="c1">// newstack will fill gobuf.ctxt.
</span><span class="c1"></span>
    <span class="c1">// Call newstack on m-&gt;g0&#39;s stack.
</span><span class="c1"></span>    <span class="c1">// BX = g.m.g0
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nf">m_g0</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BX</span>
    <span class="c1">// 将 g0 保存到本地存储 tls
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">BX</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
    <span class="c1">// 把 g0 栈的栈顶寄存器的值恢复到 CPU 的寄存器 SP，达到切换栈的目的，下面这一条指令执行之前，
</span><span class="c1"></span>    <span class="c1">// CPU 还是使用的调用此函数的 g 的栈，执行之后 CPU 就开始使用 g0 的栈了
</span><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">SP</span>
    <span class="c1">// 准备参数
</span><span class="c1"></span>    <span class="nx">PUSHQ</span>    <span class="nx">DX</span>    <span class="c1">// ctxt argument
</span><span class="c1"></span>    <span class="c1">// 不返回
</span><span class="c1"></span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">newstack</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x1003</span>    <span class="c1">// crash if newstack returns
</span><span class="c1"></span>    <span class="nx">POPQ</span>    <span class="nx">DX</span>    <span class="c1">// keep balance check happy
</span><span class="c1"></span>	<span class="nx">RET</span>
</code></pre></td></tr></table>
</div>
</div><p>主要做的工作就是将当前 goroutine，也就是 main goroutine 的和调度相关的信息保存到 g.sched 中，以便在调度到它执行时，可以恢复。</p>
<p>最后，将 g0 的地址保存到 tls 本地存储，并且切到 g0 栈执行之后的代码。继续调用 newstack 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newstack</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">thisg</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="c1">// TODO: double check all gp. shouldn&#39;t be getg().
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">stackguard0</span> <span class="o">==</span> <span class="nx">stackFork</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stack growth after fork&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: newstack called from g=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">g</span><span class="p">),</span> <span class="s">&#34;\n&#34;</span><span class="o">+</span><span class="s">&#34;\tm=&#34;</span><span class="p">,</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="s">&#34; m-&gt;curg=&#34;</span><span class="p">,</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span><span class="p">,</span> <span class="s">&#34; m-&gt;g0=&#34;</span><span class="p">,</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span><span class="p">,</span> <span class="s">&#34; m-&gt;gsignal=&#34;</span><span class="p">,</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nx">morebuf</span> <span class="o">:=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span>
		<span class="nf">traceback</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span><span class="p">,</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">lr</span><span class="p">,</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: wrong goroutine in newstack&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>

	<span class="k">if</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span><span class="p">.</span><span class="nx">throwsplit</span> <span class="p">{</span>
		<span class="c1">// Update syscallsp, syscallpc in case traceback uses them.
</span><span class="c1"></span>		<span class="nx">morebuf</span> <span class="o">:=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">=</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">syscallpc</span> <span class="p">=</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span>
		<span class="nx">pcname</span><span class="p">,</span> <span class="nx">pcoff</span> <span class="o">:=</span> <span class="s">&#34;(unknown)&#34;</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="nx">f</span> <span class="o">:=</span> <span class="nf">findfunc</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">f</span><span class="p">.</span><span class="nf">valid</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">pcname</span> <span class="p">=</span> <span class="nf">funcname</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
			<span class="nx">pcoff</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="o">-</span> <span class="nx">f</span><span class="p">.</span><span class="nx">entry</span>
		<span class="p">}</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: newstack at &#34;</span><span class="p">,</span> <span class="nx">pcname</span><span class="p">,</span> <span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">pcoff</span><span class="p">),</span>
			<span class="s">&#34; sp=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; stack=[&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="s">&#34;, &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="p">),</span> <span class="s">&#34;]\n&#34;</span><span class="p">,</span>
			<span class="s">&#34;\tmorebuf={pc:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span><span class="p">),</span> <span class="s">&#34; sp:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; lr:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">lr</span><span class="p">),</span> <span class="s">&#34;}\n&#34;</span><span class="p">,</span>
			<span class="s">&#34;\tsched={pc:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span><span class="p">),</span> <span class="s">&#34; sp:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; lr:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lr</span><span class="p">),</span> <span class="s">&#34; ctxt:&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ctxt</span><span class="p">,</span> <span class="s">&#34;}\n&#34;</span><span class="p">)</span>

		<span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">traceback</span> <span class="p">=</span> <span class="mi">2</span> <span class="c1">// Include runtime frames
</span><span class="c1"></span>		<span class="nf">traceback</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span><span class="p">,</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">lr</span><span class="p">,</span> <span class="nx">gp</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: stack split at bad time&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">morebuf</span> <span class="o">:=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span>
	<span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">lr</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="c1">// NOTE: stackguard0 may change underfoot, if another thread
</span><span class="c1"></span>	<span class="c1">// is about to try to preempt gp. Read it just once and use that same
</span><span class="c1"></span>	<span class="c1">// value now and below.
</span><span class="c1"></span>	<span class="c1">// 如果是发起的抢占请求而非真正的栈分段
</span><span class="c1"></span>	<span class="nx">preempt</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Loaduintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span><span class="p">)</span> <span class="o">==</span> <span class="nx">stackPreempt</span>

	<span class="c1">// Be conservative about where we preempt.
</span><span class="c1"></span>	<span class="c1">// We are interested in preempting user Go code, not runtime code.
</span><span class="c1"></span>	<span class="c1">// If we&#39;re holding locks, mallocing, or preemption is disabled, don&#39;t
</span><span class="c1"></span>	<span class="c1">// preempt.
</span><span class="c1"></span>	<span class="c1">// This check is very early in newstack so that even the status change
</span><span class="c1"></span>	<span class="c1">// from Grunning to Gwaiting and back doesn&#39;t happen in this case.
</span><span class="c1"></span>	<span class="c1">// That status change by itself can be viewed as a small preemption,
</span><span class="c1"></span>	<span class="c1">// because the GC might change Gwaiting to Gscanwaiting, and then
</span><span class="c1"></span>	<span class="c1">// this goroutine has to wait for the GC to finish before continuing.
</span><span class="c1"></span>	<span class="c1">// If the GC is in some way dependent on this goroutine (for example,
</span><span class="c1"></span>	<span class="c1">// it needs a lock held by the goroutine), that small preemption turns
</span><span class="c1"></span>	<span class="c1">// into a real deadlock.
</span><span class="c1"></span>	<span class="c1">// 保守的对用户态代码进行抢占，而非抢占运行时代码
</span><span class="c1"></span>	<span class="c1">// 如果正持有锁、分配内存或抢占被禁用，则不发生抢占
</span><span class="c1"></span>	<span class="c1">// gopreempt_m 将当前的 goroutine 放进了全局队列
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">preempt</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nf">canPreemptM</span><span class="p">(</span><span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Let the goroutine keep running for now.
</span><span class="c1"></span>			<span class="c1">// gp-&gt;preempt is set, so it will be preempted next time.
</span><span class="c1"></span>			<span class="c1">//stackguard0恢复溢出检查用途,下次用G.preempt恢复
</span><span class="c1"></span>			<span class="c1">// 还原 stackguard0 为正常值，表示我们已经处理过抢占请求了
</span><span class="c1"></span>			<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
			<span class="c1">// 不抢占，调用 gogo 继续运行当前这个 g，不需要调用 schedule 函数去挑选另一个 goroutine
</span><span class="c1"></span>			<span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span> <span class="c1">// never return
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;missing stack in newstack&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">sp</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span>
	<span class="k">if</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">ArchFamily</span> <span class="o">==</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">AMD64</span> <span class="o">||</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">ArchFamily</span> <span class="o">==</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">I386</span> <span class="o">||</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">ArchFamily</span> <span class="o">==</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">WASM</span> <span class="p">{</span>
		<span class="c1">// The call to morestack cost a word.
</span><span class="c1"></span>		<span class="nx">sp</span> <span class="o">-=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">stackDebug</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">sp</span> <span class="p">&lt;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: newstack sp=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; stack=[&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="s">&#34;, &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="p">),</span> <span class="s">&#34;]\n&#34;</span><span class="p">,</span>
			<span class="s">&#34;\tmorebuf={pc:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span><span class="p">),</span> <span class="s">&#34; sp:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; lr:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">lr</span><span class="p">),</span> <span class="s">&#34;}\n&#34;</span><span class="p">,</span>
			<span class="s">&#34;\tsched={pc:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span><span class="p">),</span> <span class="s">&#34; sp:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; lr:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lr</span><span class="p">),</span> <span class="s">&#34; ctxt:&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ctxt</span><span class="p">,</span> <span class="s">&#34;}\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">sp</span> <span class="p">&lt;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: gp=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="s">&#34;, goid=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">goid</span><span class="p">,</span> <span class="s">&#34;, gp-&gt;status=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)),</span> <span class="s">&#34;\n &#34;</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: split stack overflow: &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; &lt; &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: split stack overflow&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果需要对栈进行调整
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">preempt</span> <span class="p">{</span>
		<span class="c1">//垃圾回收本身也算一次抢占,忽略本次抢占调度
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: preempt g0&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: g is running but p is not&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptShrink</span> <span class="p">{</span>
			<span class="c1">// 我们正在一个同步安全点，因此等待栈收缩
</span><span class="c1"></span>			<span class="c1">// We&#39;re at a synchronous safe point now, so
</span><span class="c1"></span>			<span class="c1">// do the pending stack shrink.
</span><span class="c1"></span>			<span class="nx">gp</span><span class="p">.</span><span class="nx">preemptShrink</span> <span class="p">=</span> <span class="kc">false</span>
			<span class="nf">shrinkstack</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptStop</span> <span class="p">{</span>
			<span class="nf">preemptPark</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="c1">// never returns
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="c1">// 调用 gopreempt_m 把 gp 切换出去
</span><span class="c1"></span>		<span class="c1">// Act like goroutine called runtime.Gosched.
</span><span class="c1"></span>		<span class="c1">// 表现得像是调用了 runtime.Gosched，主动让权
</span><span class="c1"></span>		<span class="nf">gopreempt_m</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="c1">// never return
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="c1">// Allocate a bigger segment and move the stack.
</span><span class="c1"></span>	<span class="nx">oldsize</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span>
	<span class="nx">newsize</span> <span class="o">:=</span> <span class="nx">oldsize</span> <span class="o">*</span> <span class="mi">2</span>

	<span class="c1">// Make sure we grow at least as much as needed to fit the new frame.
</span><span class="c1"></span>	<span class="c1">// (This is just an optimization - the caller of morestack will
</span><span class="c1"></span>	<span class="c1">// recheck the bounds on return.)
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">f</span> <span class="o">:=</span> <span class="nf">findfunc</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span><span class="p">);</span> <span class="nx">f</span><span class="p">.</span><span class="nf">valid</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">max</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">funcMaxSPDelta</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span>
		<span class="k">for</span> <span class="nx">newsize</span><span class="o">-</span><span class="nx">oldsize</span> <span class="p">&lt;</span> <span class="nx">max</span><span class="o">+</span><span class="nx">_StackGuard</span> <span class="p">{</span>
			<span class="nx">newsize</span> <span class="o">*=</span> <span class="mi">2</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">newsize</span> <span class="p">&gt;</span> <span class="nx">maxstacksize</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: goroutine stack exceeds &#34;</span><span class="p">,</span> <span class="nx">maxstacksize</span><span class="p">,</span> <span class="s">&#34;-byte limit\n&#34;</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: sp=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; stack=[&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="s">&#34;, &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="p">),</span> <span class="s">&#34;]\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stack overflow&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// The goroutine must be executing in order to call newstack,
</span><span class="c1"></span>	<span class="c1">// so it must be Grunning (or Gscanrunning).
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gcopystack</span><span class="p">)</span>

	<span class="c1">// The concurrent GC will not scan the stack while we are doing the copy since
</span><span class="c1"></span>	<span class="c1">// the gp is in a Gcopystack status.
</span><span class="c1"></span>	<span class="nf">copystack</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">newsize</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">stackDebug</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;stack grow done\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gcopystack</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
	<span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中的 canPreemptM 验证了可以被抢占的条件：</p>
<ol>
<li>运行时没有禁止抢占（m.locks == 0）</li>
<li>运行时没有在执行内存分配（m.mallocing == 0）</li>
<li>运行时没有关闭抢占机制（m.preemptoff == &ldquo;&quot;）</li>
<li>M 与 P 绑定且没有进入系统调用（p.status == _Prunning）</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// canPreemptM 报告 mp 是否处于可抢占的安全状态。
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">canPreemptM</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">//如果M持有锁,或者正在进行内存分配,垃圾回收等操作,不抢占,留待下次
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">locks</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">status</span> <span class="o">==</span> <span class="nx">_Prunning</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>第一次判断 preempt 标志是 true 时，检查了 g 的状态，发现不能抢占，例如它所绑定的 P 的状态不是 _Prunning，那就恢复它的 stackguard0 字段，下次就不会走这一套流程了。然后，调用 gogo(&amp;gp.sched) 继续执行当前的 goroutine。</p>
<p>中间又处理了很多判断流程，再次判断 preempt 标志是 true 时，调用 gopreempt_m(gp) 将 gp 切换出去。</p>
<p>gopreempt_m函数在proc.go中定义，它的参数是需要停止的G。它就干了一件事，调用goschedImpl函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gopreempt_m</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGoPreempt</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nf">goschedImpl</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>goschedImpl函数也在proc.go文件中，参数是要停止的G。该函数首先把这个G从Grunning状态转到Grunnable状态。然后调用dropg函数解除这个G与当前M的关联。再把这个G放入调度器的可运行G队列，最后调用schedule函数进行一轮调度，为当前P找一个新的可运行G来运行。至此抢占结束。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">goschedImpl</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">status</span><span class="o">&amp;^</span><span class="nx">_Gscan</span> <span class="o">!=</span> <span class="nx">_Grunning</span> <span class="p">{</span>
		<span class="nf">dumpgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad g status&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 更改 gp 的状态
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
	<span class="c1">// 解除 m 和 g 的关系
</span><span class="c1"></span>	<span class="nf">dropg</span><span class="p">()</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">// 将 gp 放入全局可运行队列
</span><span class="c1"></span>	<span class="nf">globrunqput</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">// 进入新一轮的调度循环
</span><span class="c1"></span>	<span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>将 gp 的状态改为 _Grunnable，放入全局可运行队列，等待下次有 m 来全局队列找工作时才能继续运行，毕竟你已经运行这么长时间了，给别人一点机会嘛。</p>
<p>最后，调用 schedule() 函数进入新一轮的调度循环，会找出一个 goroutine 来运行，永不返回。</p>
<p>从可被抢占的条件来看，能够对一个 G 进行抢占其实是呈保守状态的。 这一保守体现在抢占对很多运行时所需的条件进行了判断，这也理所当然是因为 运行时优先级更高，不应该轻易发生抢占， 但与此同时由于又需要对用户态代码进行抢占，于是先作出一次不需要抢占的判断（快速路径）， 确定不能抢占时返回并继续调度，如果真的需要进行抢占，则转入调用 gopreempt_m， 放弃当前 G 的执行权，将其加入全局队列，重新进入调度循环。</p>
<p>什么时候会会给 stackguard0 设置抢占标记 stackPreempt 呢？ 一共有以下几种情况：</p>
<ol>
<li>进入系统调用时（runtime.reentersyscall，注意这种情况是为了保证不会发生栈分裂， 真正的抢占是异步的通过系统监控进行的）</li>
<li>任何运行时不再持有锁的时候（m.locks == 0）</li>
<li>当垃圾回收器需要停止所有用户 Goroutine 时</li>
</ol>
<h2 id="基于信号的抢占式调度preemptm">基于信号的抢占式调度(preemptM)<a hidden class="anchor" aria-hidden="true" href="#基于信号的抢占式调度preemptm">#</a></h2>
<p>从上面提到的调度逻辑我们可以看出，这种需要用户代码来主动配合的调度方式存在 一些致命的缺陷：一个没有主动放弃执行权、且不参与任何函数调用的函数，直到执行完毕之前， 是不会被抢占的。那么这种不会被抢占的函数会导致什么严重的问题呢？回答是，由于运行时无法 停止该用户代码，则当需要进行垃圾回收时，无法及时进行；对于一些实时性要求较高的用户态 Goroutine 而言，也久久得不到调度。我们直接来看一个非常简单的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 此程序在 Go 1.14 之前的版本不会输出 OK
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;runtime&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
	<span class="nb">println</span><span class="p">(</span><span class="s">&#34;OK&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这段代码中处于死循环的 Goroutine 永远无法被抢占，其中创建的 Goroutine 会执行一个不产生任何调用、不主动放弃执行权的死循环。由于主 Goroutine 优先调用了 休眠，此时唯一的 P 会转去执行 for 循环所创建的 Goroutine。进而主 Goroutine 永远不会再被调度，进而程序彻底阻塞在了这四个 Goroutine 上，永远无法退出.如果有多个P并发执行,此时一个P死循环,因为垃圾回收触发时无法抢占该Goroutine,垃圾回收在STW阶段会一直卡住,最终导致进程假死。这样的例子 非常多，但追根溯源，均为此问题导致</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210822160930.png" alt=""  />
</p>
<p>Go 语言在 1.14 版本中实现了非协作的抢占式调度，在实现的过程中我们重构已有的逻辑并为 Goroutine 增加新的状态和字段来支持抢占。Go 团队通过下面的一系列提交实现了这一功能，我们可以按时间顺序分析相关提交理解它的工作原理：</p>
<ul>
<li>runtime: add general suspendG/resumeG
<ul>
<li>挂起 Goroutine 的过程是在垃圾回收的栈扫描时完成的，我们通过 runtime.suspendG 和 runtime.resumeG 两个函数重构栈扫描这一过程；</li>
<li>调用 runtime.suspendG 函数时会将处于运行状态的 Goroutine 的 preemptStop 标记成 true；</li>
<li>调用 runtime.preemptPark 函数可以挂起当前 Goroutine、将其状态更新成 _Gpreempted 并触发调度器的重新调度，该函数能够交出线程控制权；</li>
</ul>
</li>
<li>runtime: asynchronous preemption function for x86
<ul>
<li>在 x86 架构上增加异步抢占的函数 runtime.asyncPreempt 和 runtime.asyncPreempt2；</li>
</ul>
</li>
<li>runtime: use signals to preempt Gs for suspendG
<ul>
<li>支持通过向线程发送信号的方式暂停运行的 Goroutine；</li>
<li>在 runtime.sighandler 函数中注册 SIGURG 信号的处理函数 runtime.doSigPreempt；</li>
<li>实现 runtime.preemptM 函数，它可以通过 SIGURG 信号向线程发送抢占请求；</li>
</ul>
</li>
<li>runtime: implement async scheduler preemption
<ul>
<li>修改 runtime.preemptone 函数的实现，加入异步抢占的逻辑；</li>
</ul>
</li>
</ul>
<p>目前的抢占式调度也只会在垃圾回收扫描任务时触发，我们可以梳理一下上述代码实现的抢占式调度过程：</p>
<ol>
<li>程序启动时，在 runtime.sighandler 函数中注册 SIGURG 信号的处理函数 runtime.doSigPreempt；</li>
<li>在触发垃圾回收的栈扫描时会调用 runtime.suspendG 挂起 Goroutine，该函数会执行下面的逻辑：
<ol>
<li>将 _Grunning 状态的 Goroutine 标记成可以被抢占，即将 preemptStop 设置成 true；</li>
<li>调用 runtime.preemptM 触发抢占；</li>
</ol>
</li>
<li>runtime.preemptM 会调用 runtime.signalM 向线程发送信号 SIGURG；</li>
<li>操作系统会中断正在运行的线程并执行预先注册的信号处理函数 runtime.doSigPreempt；</li>
<li>runtime.doSigPreempt 函数会处理抢占信号，获取当前的 SP 和 PC 寄存器并调用 runtime.sigctxt.pushCall；</li>
<li>runtime.sigctxt.pushCall 会修改寄存器并在程序回到用户态时执行 runtime.asyncPreempt；</li>
<li>汇编指令 runtime.asyncPreempt 会调用运行时函数 runtime.asyncPreempt2；</li>
<li>runtime.asyncPreempt2 会调用 runtime.preemptPark；</li>
<li>runtime.preemptPark 会修改当前 Goroutine 的状态到_Gpreempted 并调用 runtime.schedule 让当前函数陷入休眠并让出线程，调度器会选择其它的 Goroutine 继续执行；</li>
</ol>
<p>上述 9 个步骤展示了基于信号的抢占式调度的执行过程。除了分析抢占的过程之外，我们还需要讨论一下抢占信号的选择，提案根据以下的四个原因选择 SIGURG 作为触发异步抢占的信号；</p>
<ol>
<li>该信号需要被调试器透传；</li>
<li>该信号不会被内部的 libc 库使用并拦截；</li>
<li>该信号可以随意出现并且不触发任何后果；</li>
<li>我们需要处理多个平台上的不同信号；</li>
</ol>
<p>STW 和栈扫描是一个可以抢占的安全点（Safe-points），所以 Go 语言会在这里先加入抢占功能。基于信号的抢占式调度只解决了垃圾回收和栈扫描时存在的问题，它到目前为止没有解决全部问题，但是这种真抢占式调度时调度器走向完备的开始，相信在未来我们可以会更多的地方触发抢占。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Tell the goroutine running on processor P to stop.
</span><span class="c1">// This function is purely best-effort. It can incorrectly fail to inform the
</span><span class="c1">// goroutine. It can send inform the wrong goroutine. Even if it informs the
</span><span class="c1">// correct goroutine, that goroutine might ignore the request if it is
</span><span class="c1">// simultaneously executing newstack.
</span><span class="c1">// No lock needs to be held.
</span><span class="c1">// Returns true if preemption request was issued.
</span><span class="c1">// The actual preemption will happen at some point in the future
</span><span class="c1">// and will be indicated by the gp-&gt;status no longer being
</span><span class="c1">// Grunning
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">preemptone</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="o">...</span>
	<span class="c1">// Request an async preemption of this P.
</span><span class="c1"></span>	<span class="c1">// 请求该 P 的异步抢占
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">preemptMSupported</span> <span class="o">&amp;&amp;</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">asyncpreemptoff</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nf">preemptM</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="抢占信号的选取">抢占信号的选取<a hidden class="anchor" aria-hidden="true" href="#抢占信号的选取">#</a></h3>
<p>preemptM 完成了信号的发送，其实现也非常直接，直接向需要进行抢占的 M 发送 SIGURG 信号 即可。但是真正的重要的问题是，为什么是 SIGURG 信号而不是其他的信号？如何才能保证该信号 不与用户态产生的信号产生冲突？这里面有几个原因：</p>
<ol>
<li>默认情况下，SIGURG 已经用于调试器传递信号。</li>
<li>SIGRUURG 可以不加选择地虚假发生的信号。例如，我们不能选择 SIGALRM，因为 信号处理程序无法分辨它是否是由实际过程引起的（可以说这意味着信号已损坏）。 而常见的用户自定义信号 SIGUSR1 和 SIGUSR2 也不够好，因为用户态代码可能会将其进行使用</li>
<li>需要处理没有实时信号的平台（例如 macOS）</li>
</ol>
<p>考虑以上的观点，SIGURG 其实是一个很好的、满足所有这些条件、且极不可能因被用户态代码 进行使用的一种信号。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">sigPreempt</span> <span class="p">=</span> <span class="nx">_SIGURG</span>

<span class="c1">// preemptM 向 mp 发送抢占请求。该请求可以异步处理，也可以与对 M 的其他请求合并。
</span><span class="c1">// 接收到该请求后，如果正在运行的 G 或 P 被标记为抢占，并且 Goroutine 处于异步安全点，
</span><span class="c1">// 它将抢占 Goroutine。在处理抢占请求后，它始终以原子方式递增 mp.preemptGen。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">preemptM</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nf">signalM</span><span class="p">(</span><span class="nx">mp</span><span class="p">,</span> <span class="nx">sigPreempt</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">signalM</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">,</span> <span class="nx">sig</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">tgkill</span><span class="p">(</span><span class="nf">getpid</span><span class="p">(),</span> <span class="nb">int</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">procid</span><span class="p">),</span> <span class="nx">sig</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>通过系统调用 tgkill，给特定的线程发信号</p>
<h3 id="抢占调用的注入">抢占调用的注入<a hidden class="anchor" aria-hidden="true" href="#抢占调用的注入">#</a></h3>
<p>Go 运行时进行信号处理的基本做法，其核心是注册 sighandler 函数，并在信号到达后， 由操作系统中断转入内核空间，而后将所中断线程的执行上下文参数（例如寄存器 rip, rep 等） 传递给处理函数。如果在 sighandler 中修改了这个上下文参数，操作系统则会根据修改后的 上下文信息恢复执行，这也就为抢占提供了机会。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sighandler</span><span class="p">(</span><span class="nx">sig</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">info</span> <span class="o">*</span><span class="nx">siginfo</span><span class="p">,</span> <span class="nx">ctxt</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sigctxt</span><span class="p">{</span><span class="nx">info</span><span class="p">,</span> <span class="nx">ctxt</span><span class="p">}</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nx">sig</span> <span class="o">==</span> <span class="nx">sigPreempt</span> <span class="p">{</span>
		<span class="c1">// 可能是一个抢占信号
</span><span class="c1"></span>		<span class="nf">doSigPreempt</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
		<span class="c1">// 即便这是一个抢占信号，它也可能与其他信号进行混合，因此我们
</span><span class="c1"></span>		<span class="c1">// 继续进行处理。
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// doSigPreempt handles a preemption signal on gp.
</span><span class="c1">// doSigPreempt 处理了 gp 上的抢占信号
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">doSigPreempt</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">ctxt</span> <span class="o">*</span><span class="nx">sigctxt</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Check if this G wants to be preempted and is safe to
</span><span class="c1"></span>	<span class="c1">// preempt.
</span><span class="c1"></span>	<span class="c1">// 检查 G 是否需要被抢占、抢占是否安全
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">wantAsyncPreempt</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">ok</span><span class="p">,</span> <span class="nx">newpc</span> <span class="o">:=</span> <span class="nf">isAsyncSafePoint</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">ctxt</span><span class="p">.</span><span class="nf">sigpc</span><span class="p">(),</span> <span class="nx">ctxt</span><span class="p">.</span><span class="nf">sigsp</span><span class="p">(),</span> <span class="nx">ctxt</span><span class="p">.</span><span class="nf">siglr</span><span class="p">());</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="c1">// Adjust the PC and inject a call to asyncPreempt.
</span><span class="c1"></span>			<span class="c1">// 插入抢占调用
</span><span class="c1"></span>			<span class="nx">ctxt</span><span class="p">.</span><span class="nf">pushCall</span><span class="p">(</span><span class="nf">funcPC</span><span class="p">(</span><span class="nx">asyncPreempt</span><span class="p">),</span> <span class="nx">newpc</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Acknowledge the preemption.
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptGen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">signalPending</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="c1">// 记录抢占
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;darwin&#34;</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pendingPreemptSignals</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在 ctxt.pushCall 之前， ctxt.rip() 和 ctxt.rep() 都保存了被中断的 Goroutine 所在的位置， 但是 pushCall 直接修改了这些寄存器，进而当从 sighandler 返回用户态 Goroutine 时， 能够从注入的 asyncPreempt 开始执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">sigctxt</span><span class="p">)</span> <span class="nf">pushCall</span><span class="p">(</span><span class="nx">targetPC</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">pc</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">rip</span><span class="p">())</span>
	<span class="nx">sp</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">rsp</span><span class="p">())</span>
	<span class="nx">sp</span> <span class="o">-=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span> <span class="p">=</span> <span class="nx">pc</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">set_rsp</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">set_rip</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">targetPC</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>完成 sighandler 之后，我们成功恢复到 asyncPreempt 调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// asyncPreempt 保存了所有用户寄存器，并调用 asyncPreempt2
</span><span class="c1">//
</span><span class="c1">// 当栈扫描遭遇 asyncPreempt 栈帧时，将会保守的扫描调用方栈帧
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">asyncPreempt</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>该函数的主要目的是保存用户态寄存器，并且在调用完毕前恢复所有的寄存器上下文， 就好像什么事情都没有发生过一样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">TEXT</span> ·<span class="nf">asyncPreempt</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span><span class="n">NOSPLIT</span><span class="o">|</span><span class="n">NOFRAME</span><span class="p">,</span><span class="o">$</span><span class="m">0-0</span>
	<span class="kc">...</span>
	<span class="n">MOVQ</span> <span class="n">AX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
	<span class="kc">...</span>
	<span class="n">MOVUPS</span> <span class="n">X15</span><span class="p">,</span> <span class="m">352</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
	<span class="n">CALL</span> ·<span class="nf">asyncPreempt2</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
	<span class="n">MOVUPS</span> <span class="m">352</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">X15</span>
	<span class="kc">...</span>
	<span class="n">MOVQ</span> <span class="m">0</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">AX</span>
	<span class="kc">...</span>
	<span class="n">RET</span>
</code></pre></td></tr></table>
</div>
</div><p>当调用 asyncPreempt2 时，会根据 preemptPark 或者 gopreempt_m 重新切换回调度循环，从而打断密集循环的继续执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">asyncPreempt2</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">asyncSafePoint</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptStop</span> <span class="p">{</span>
		<span class="nf">mcall</span><span class="p">(</span><span class="nx">preemptPark</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nf">mcall</span><span class="p">(</span><span class="nx">gopreempt_m</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 异步抢占过程结束
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">asyncSafePoint</span> <span class="p">=</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>至此，异步抢占过程结束。我们总结一下抢占调用的整体逻辑：</p>
<ol>
<li>M1 发送中断信号（signalM(mp, sigPreempt)）</li>
<li>M2 收到信号，操作系统中断其执行代码，并切换到信号处理函数（sighandler(signum, info, ctxt, gp)）</li>
<li>M2 修改执行的上下文，并恢复到修改后的位置（asyncPreempt）</li>
<li>重新进入调度循环进而调度其他 Goroutine（preemptPark 和 gopreempt_m）</li>
</ol>
<h3 id="sysmon抢占gopreempt_m">sysmon抢占(gopreempt_m)<a hidden class="anchor" aria-hidden="true" href="#sysmon抢占gopreempt_m">#</a></h3>
<p>sysmon 抢占流程:</p>
<p>sysmon -&gt; retake -&gt; preemptone -&gt; asyncPreempt -&gt; globalrunqput</p>
<p>sysmon抢占后会把g放到全局队列中.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gopreempt_m</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGoPreempt</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nf">goschedImpl</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">goschedImpl</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">status</span><span class="o">&amp;^</span><span class="nx">_Gscan</span> <span class="o">!=</span> <span class="nx">_Grunning</span> <span class="p">{</span>
		<span class="nf">dumpgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad g status&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
	<span class="nf">dropg</span><span class="p">()</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nf">globrunqput</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="gc抢占preemptpark">GC抢占(preemptPark)<a hidden class="anchor" aria-hidden="true" href="#gc抢占preemptpark">#</a></h3>
<p>GC 抢占流程:</p>
<p>markroot -&gt; allgs[i] -&gt; g -&gt; suspendG(g) -&gt; scan g stack -&gt; resumeG</p>
<p>resumeG会执行runqput,当g被其他线程调度到时,从asyncPreempt的下半部分继续执行.</p>
<p>GC走的是preemptPark分支,M和G解除绑定,G暂停执行,M继续调度其他G.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// preemptPark parks gp and puts it in _Gpreempted.
</span><span class="c1">//
</span><span class="c1">//go:systemstack
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">preemptPark</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGoPark</span><span class="p">(</span><span class="nx">traceEvGoBlock</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">status</span><span class="o">&amp;^</span><span class="nx">_Gscan</span> <span class="o">!=</span> <span class="nx">_Grunning</span> <span class="p">{</span>
		<span class="nf">dumpgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad g status&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="nx">waitReasonPreempted</span>
	<span class="c1">// Transition from _Grunning to _Gscan|_Gpreempted. We can&#39;t
</span><span class="c1"></span>	<span class="c1">// be in _Grunning when we dropg because then we&#39;d be running
</span><span class="c1"></span>	<span class="c1">// without an M, but the moment we&#39;re in _Gpreempted,
</span><span class="c1"></span>	<span class="c1">// something could claim this G before we&#39;ve fully cleaned it
</span><span class="c1"></span>	<span class="c1">// up. Hence, we set the scan bit to lock down further
</span><span class="c1"></span>	<span class="c1">// transitions until we can dropg.
</span><span class="c1"></span>	<span class="nf">casGToPreemptScan</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gscan</span><span class="p">|</span><span class="nx">_Gpreempted</span><span class="p">)</span>
	<span class="nf">dropg</span><span class="p">()</span>
	<span class="nf">casfrom_Gscanstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gscan</span><span class="p">|</span><span class="nx">_Gpreempted</span><span class="p">,</span> <span class="nx">_Gpreempted</span><span class="p">)</span>
	<span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h2>
<p>总的来说，应用层的调度策略不易实现，因此实现上也并不是特别紧急。我们回顾 Go 语言调度策略的演变过程 不难发现，实现它们的动力是从实际需求出发的。Go 语言从设计之初并没有刻意的去考虑对 Goroutine 的抢占机制。 从早期无法对 Goroutine 进行抢占的原始时代，到现在的协作与抢占同时配合的调度策略， 其问题的核心是垃圾回收等运行时机制的需要。</p>
<p>当运行时需要执行垃圾回收时，协作式调度能够保证具备函数调用的用户 Goroutine 正常停止； 抢占式调度则能避免由于死循环导致的任意时间的垃圾回收延迟。有了这两种不同的调度策略， Go 语言的用户可以放心的写出各种形式的代码逻辑，即使运行时垃圾回收也能够在适当的时候及时中断用户代码， 不至于导致整个系统进入不可预测的停顿。</p>
<h2 id="转载">转载<a hidden class="anchor" aria-hidden="true" href="#转载">#</a></h2>
<p><a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/preemption/#heading">6.8 协作与抢占</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go%E6%BA%90%E7%A0%81/">Go源码</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
