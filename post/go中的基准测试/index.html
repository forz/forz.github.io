<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go中的基准测试 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author"
  content="Forz" /><meta name="description" content="基准测试的基本规则 在进行基准测试之前，我们必须要有一个稳定的环境来获得可重现的结果。 机器必须是空闲的——不要运行在共享硬件上，在长时间运行基" /><meta name="keywords"
  content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.68.1 with theme even" />


<link rel="canonical" href="/post/go%E4%B8%AD%E7%9A%84%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link rel="stylesheet" href="/css/search.css" />


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go中的基准测试" />
<meta property="og:description" content="基准测试的基本规则 在进行基准测试之前，我们必须要有一个稳定的环境来获得可重现的结果。 机器必须是空闲的——不要运行在共享硬件上，在长时间运行基" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E4%B8%AD%E7%9A%84%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/" />
<meta property="article:published_time" content="2020-01-30T15:46:41+00:00" />
<meta property="article:modified_time" content="2020-01-30T15:46:41+00:00" />
<meta itemprop="name" content="Go中的基准测试">
<meta itemprop="description" content="基准测试的基本规则 在进行基准测试之前，我们必须要有一个稳定的环境来获得可重现的结果。 机器必须是空闲的——不要运行在共享硬件上，在长时间运行基">
<meta itemprop="datePublished" content="2020-01-30T15:46:41&#43;00:00" />
<meta itemprop="dateModified" content="2020-01-30T15:46:41&#43;00:00" />
<meta itemprop="wordCount" content="4530">



<meta itemprop="keywords" content="Go,benchmark," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go中的基准测试"/>
<meta name="twitter:description" content="基准测试的基本规则 在进行基准测试之前，我们必须要有一个稳定的环境来获得可重现的结果。 机器必须是空闲的——不要运行在共享硬件上，在长时间运行基"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="clearfix">
  <div class="logo-wrapper">
    <a href="/" class="logo">Forz Blog</a>
  </div>

  <nav class="site-navbar">
    <ul id="menu" class="menu">
      <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
    </ul>
  </nav>
</div>


<div class="search-container">
  <div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="Search for titles or URIs..."
        name="search" autocomplete="off" />
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path
            d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js"></script>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js"></script>
<script>
    var client = algoliasearch("IAR2EF5L65", "b4b9da2eba53aa6dabe4b8ac9e8676e1");
    var index = client.initIndex('forz.forzvina.com');
    autocomplete('#aa-search-input',
        { hint: false }, {
        source: autocomplete.sources.hits(index, { hitsPerPage: 8 }),
        displayKey: 'name',
        templates: {
            suggestion: function (suggestion) {
                var reg = /([A-Z]+)/ig
                var title = suggestion.uri.replace(reg, function (m) {
                    return m.toLowerCase()
                })
                return '<span class="search-item">' + '<a href="\/' + title + '">' +
                    suggestion._highlightResult.title.value + '</a></span>';
            }
        }
    });
</script>
</div>


    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go中的基准测试</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-01-30 </span>
        <div class="post-category">
            <a href="/categories/go%E8%B0%83%E4%BC%98/"> Go调优 </a>
            </div>
          <span class="more-meta"> 约 4530 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#基准测试的基本规则">基准测试的基本规则</a></li>
    <li><a href="#使用测试包进行基准测试">使用测试包进行基准测试</a>
      <ul>
        <li><a href="#运行包的基准测试">运行包的基准测试</a></li>
        <li><a href="#基准测试的工作原理">基准测试的工作原理</a></li>
        <li><a href="#提高基准测试的精度">提高基准测试的精度</a></li>
      </ul>
    </li>
    <li><a href="#benchstat">Benchstat</a></li>
    <li><a href="#对比标准-benchmarks-和-benchstat">对比标准 benchmarks 和 benchstat</a></li>
    <li><a href="#提升-fib-性能">提升 <code>Fib</code> 性能</a></li>
    <li><a href="#避免基准测试的启动成本">避免基准测试的启动成本</a></li>
    <li><a href="#内存分配的基准测试">内存分配的基准测试</a>
      <ul>
        <li><a href="#注意编译优化">注意编译优化</a></li>
        <li><a href="#优化是一件好事">优化是一件好事</a></li>
        <li><a href="#修复基准测试">修复基准测试</a></li>
      </ul>
    </li>
    <li><a href="#错误的基准测试">错误的基准测试</a></li>
    <li><a href="#分析基准测试的结果">分析基准测试的结果</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="基准测试的基本规则">基准测试的基本规则</h2>
<p>在进行基准测试之前，我们必须要有一个稳定的环境来获得可重现的结果。</p>
<ul>
<li>机器必须是空闲的——不要运行在共享硬件上，在长时间运行基准测试时不要进行其他操作</li>
<li>注意节电和热缩放（主要指 CPU 受温度影响导致频率不稳定）</li>
<li>避免虚拟机和共享云托管; 它们太乱，无法进行一致的测量。</li>
</ul>
<p>如果你负担得起，最好购买专用的性能测试硬件。并禁用所有电源管理和热缩放，保持机器上的软件版本不变。</p>
<p>对于其他人，请使用前后样本并多次运行它们以获得一致的结果。</p>
<h2 id="使用测试包进行基准测试">使用测试包进行基准测试</h2>
<p><code>testing</code> 包已经内置了支持基准测试的能力. 比如你有一个简单的函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 此函数计算斐波那契数列中第 N 个数字
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Fib</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="nx">n</span> <span class="p">{</span>
        <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
        <span class="k">default</span><span class="p">:</span>
                <span class="k">return</span> <span class="nf">Fib</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">Fib</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们可以使用 <code>testing</code> 包以如下形式为此函数写一个基准测试。基准测试函数也写在以 <code>_test.go</code> 结尾的文件里，它和<code>test</code>函数共存.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BenchmarkFib20</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
                <span class="nf">Fib</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="c1">// 运行 Fib 函数 N 次
</span><span class="c1"></span>        <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这是一个基准测试的例子，从中我们可以看出以下规则：</p>
<ul>
<li>基准测试的代码文件必须以_test.go结尾</li>
<li>基准测试的函数必须以Benchmark开头，必须是可导出的</li>
<li>基准测试函数必须接受一个指向Benchmark类型的指针作为唯一参数</li>
<li>基准测试函数不能有返回值</li>
<li>最后的for循环很重要，被测试的代码要放到循环里</li>
<li>b.N是基准测试框架提供的，表示循环的次数，因为需要反复调用测试的代码，才可以评估性能</li>
</ul>
<p>基准测试和普通单元测试类似。 唯一的区别是基准测试接收的参数是<code>*testing.B</code> 而不是 <code>*testing.T</code>。 这两种类型都实现了 <code>testing.TB</code> 接口，这个接口提供了一些比较常用的方法 <code>Errorf()</code>, <code>Fatalf()</code>, and <code>FailNow()</code>。</p>
<h3 id="运行包的基准测试">运行包的基准测试</h3>
<p>因为基准测试使用<code>testing</code> 包，它们同样通过 go test 命令执行。但是，默认情况下，当你调用<code>go test</code>时，基准测试是不执行的。</p>
<p>要显式地执行基准测试请使用 <code>-bench</code> 标识。 <code>-bench</code> 接收一个与待运行的基准测试名称相匹配的正则表达式，因此，如果要运行包中所有的基准测试，最常见的方法是这样写 <code>-bench=.</code>。例如:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">% go test -bench=. ./examples/fib/
goos: darwin
goarch: amd64
BenchmarkFib20-8           30000             44514 ns/op
PASS
ok      _/Users/dfc/devel/gophercon2018-performance-tuning-workshop/2-benchmarking/examples/fib 1.795s
</code></pre></td></tr></table>
</div>
</div><p><em>注意</em>: <code>go test</code> 会在运行基准测试之前之前执行包里所有的单元测试，所有如果你的包里有很多单元测试，或者它们会运行很长时间，你也可以通过 <code>go test</code> 的<code>-run</code> 标识排除这些单元测试，不让它们执行； 比如： <code>go test -run=^$</code>。</p>
<h3 id="基准测试的工作原理">基准测试的工作原理</h3>
<p>基准测试函数会被一直调用直到<code>b.N</code>无效，它是基准测试循环的次数</p>
<p><code>b.N</code> 从 1 开始，如果基准测试函数在1秒内就完成 (默认值)，则 <code>b.N</code> 增加，并再次运行基准测试函数。</p>
<p><code>b.N</code> 在近似这样的序列中不断增加；1, 2, 3, 5, 10, 20, 30, 50, 100 等等。 基准框架试图变得聪明，如果它看到当<code>b.N</code>较小而且测试很快就完成的时候，它将让序列增加地更快。</p>
<p>看上面的例子， <code>BenchmarkFib20-8</code> 发现约 30000 次迭代只需要1秒钟。 From there the benchmark framework computed that</p>
<p><em>注意</em>: The <code>-8</code> 后缀和用于运行次测试的 <code>GOMAXPROCS</code> 值有关。 与<code>GOMAXPROCS</code>一样，此数字默认为启动时Go进程可见的CPU数。 你可以使用<code>-cpu</code>标识更改此值，可以传入多个值以列表形式来运行基准测试。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">% go test -bench=. -cpu=1,2,4 ./examples/fib/
goos: darwin
goarch: amd64
BenchmarkFib20             30000             44644 ns/op
BenchmarkFib20-2           30000             44504 ns/op
BenchmarkFib20-4           30000             44848 ns/op
PASS
</code></pre></td></tr></table>
</div>
</div><h3 id="提高基准测试的精度">提高基准测试的精度</h3>
<p><code>fib</code> 函数是一个模拟的例子 — 除非你编写 TechPower 服务器基准测试来验证，否则你的业务不太可能是你计算斐波那契数列中第20个数字的速度。 但是，基准确实展现了我认为有效的基准。</p>
<p>具体来说，当你的基准测试运行几千次迭代的时候，我们可以认为获得了一个每次运行的平均值，而如果基准测试只运行几十次，那么这个平均值很可能不稳定，也就不能说明问题。</p>
<p>要增加迭代次数，可以使用<code>-benchtime</code>标识增加运行时间，例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">% go test -bench=. -benchtime=10s ./examples/fib/
goos: darwin
goarch: amd64
BenchmarkFib20-8          300000             44616 ns/op
</code></pre></td></tr></table>
</div>
</div><p>运行一个相同的基准测试，直到它到达<code>b.N</code>的值，运行时间超过10秒。当我们运行时间是10倍的时候，迭代次数也会增加到10倍。然而每一次执行的结果却没有什么变化，这正是我们所预期的。</p>
<p>如果你有一个基准测试，它运行数百万次或数十亿次迭代，每次操作的时间都在微秒或纳秒级，那么你可能会发现基准测试结果不稳定，因为热缩放、内存局部性、后台处理、gc活动等等。</p>
<p>对于每次操作是以10或个位数纳秒为单位计算的函数来说，指令重新排序和代码对齐的相对效应都将对结果产生影响。</p>
<p>可以使用<code>-count</code> 标识多次运行基准测试来解决这个问题：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">% go test -bench=Fib1 -count=10 ./examples/fib/
goos: darwin
goarch: amd64
BenchmarkFib1-8         2000000000               1.99 ns/op
BenchmarkFib1-8         1000000000               1.95 ns/op
BenchmarkFib1-8         2000000000               1.99 ns/op
BenchmarkFib1-8         2000000000               1.97 ns/op
BenchmarkFib1-8         2000000000               1.99 ns/op
BenchmarkFib1-8         2000000000               1.96 ns/op
BenchmarkFib1-8         2000000000               1.99 ns/op
BenchmarkFib1-8         2000000000               2.01 ns/op
BenchmarkFib1-8         2000000000               1.99 ns/op
BenchmarkFib1-8         1000000000               2.00 ns/op
</code></pre></td></tr></table>
</div>
</div><p>得出<code>Fib(1)</code>的基准测试在2纳秒左右，方差为正负2%.</p>
<p><em>提示:</em> 如果你发现需要针对特定的包调整不同的默认值，我建议使用<code>Makefile</code>中完成这些设定，这样每个想要运行基准测试的人都可以使用相同的配置进行编码。</p>
<h2 id="benchstat">Benchstat</h2>
<p>在上一节中，我建议多次运行基准测试以获得更多的平均数据。对于任何基准测试来说，这都是一个很好的建议，因为测试过程会受到电源管理、后台进程和热管理的影响，这个问题我在本章的开头已经提到过。</p>
<p>下面我将介绍一个由 Russ Cox 编写的测试工具 <a href="https://godoc.org/golang.org/x/perf/cmd/benchstat">benchstat</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">% go get golang.org/x/perf/cmd/benchstat
</code></pre></td></tr></table>
</div>
</div><p>Benchstat 可以获取一组基准测试数据，并告诉你它的稳定性如何。以下是使用电池时的数据：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">% go test -bench=Fib20 -count=10 ./examples/fib/ | tee old.txt
goos: darwin
goarch: amd64
BenchmarkFib20-8           30000             46295 ns/op
BenchmarkFib20-8           30000             41589 ns/op
BenchmarkFib20-8           30000             42204 ns/op
BenchmarkFib20-8           30000             43923 ns/op
BenchmarkFib20-8           30000             44339 ns/op
BenchmarkFib20-8           30000             45340 ns/op
BenchmarkFib20-8           30000             45754 ns/op
BenchmarkFib20-8           30000             45373 ns/op
BenchmarkFib20-8           30000             44283 ns/op
BenchmarkFib20-8           30000             43812 ns/op
PASS
ok      _/Users/dfc/devel/gophercon2018-performance-tuning-workshop/2-benchmarking/examples/fib 17.865s
% benchstat old.txt
name     time/op
Fib20-8  44.3µs ± 6%
</code></pre></td></tr></table>
</div>
</div><p><code>benchstat</code> 告诉我们，平均值为44.3微秒，样本间的波动区间为正负 6％。 这对电池电量来说在意料之中。</p>
<ul>
<li>第一次运行是最慢的，因为操作系统的 CPU 时钟频率已经降低以节省功耗。</li>
<li>接下来的两次运行是最快的，因为操作系统识别到有一个较大的工作负载加入，就会提高 CPU 时钟速度，以尽快通过工作。</li>
<li>剩下的是当 CPU 高速运转发热，因为功耗导致又被限制，所以又慢了下来。</li>
</ul>
<h2 id="对比标准-benchmarks-和-benchstat">对比标准 benchmarks 和 benchstat</h2>
<p>确定两组基准测试结果之间的差异可能是单调乏味且容易出错的。  Benchstat 可以帮助我们解决这个问题。</p>
<p><em>提示</em>: 保存基准运行的输出很有用，但你也可以保存生成它的二进制文件。 为此，请使用<code>-c</code>标志来保存测试二进制文件；我经常将这个二进制文件从<code>.test</code>重命名为<code>.golden</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">% go test -c
% mv fib.test fib.golden
</code></pre></td></tr></table>
</div>
</div><h2 id="提升-fib-性能">提升 <code>Fib</code> 性能</h2>
<p>先前的<code>Fib</code>函数对斐波纳契数列中的第0和第1个数字进行了硬编码。 之后，代码以递归方式调用自身。 我们将在后边讨论递归的代价，但目前，假设它有代价，特别当我们的算法是指数级复杂度的时候。</p>
<p>要解决这个问题，最简单的方法就是硬编码斐波那契数列中的另一个数字，将每次调用的深度减少一个。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Fib</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="nx">n</span> <span class="p">{</span>
        <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
        <span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
        <span class="k">default</span><span class="p">:</span>
                <span class="k">return</span> <span class="nf">Fib</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">Fib</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>为了比较我们的新版本，我们编译了一个新的测试二进制文件并对它们都进行了基准测试，并使用<code>benchstat</code>对输出进行比较。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">% go test -c
% ./fib.golden -test.bench=. -test.count=10 &gt; old.txt
% ./fib.test -test.bench=. -test.count=10 &gt; new.txt
% benchstat old.txt new.txt
name     old time/op  new time/op  delta
Fib20-8  44.3µs ± 6%  25.6µs ± 2%  -42.31%  (p=0.000 n=10+10)
</code></pre></td></tr></table>
</div>
</div><p>比较基准测试时需要检查三件事</p>
<ul>
<li>新老两次的方差。1-2% 是不错的， 3-5% 也还行，但是大于5%的话，可能不太可靠。 在比较一方具有高差异的基准时要小心，您可能看不到改进。</li>
<li>p值。p值低于0.05是比较好的情况，大于0.05则意味着基准测试结果可能没有统计学意义。</li>
<li>样本不足。benchstat将报告它认为有效的新旧样本的数量，有时你可能只发现9个报告，即使你设置了<code>-count=10</code>。拒绝率小于10%一般是没问题的，而高于10%可能表明你的设置是不稳定的，也可能是比较的样本太少了。</li>
</ul>
<h2 id="避免基准测试的启动成本">避免基准测试的启动成本</h2>
<p>有时候每次基准测试运行前都有一些初始化操作。 <code>b.ResetTimer()</code>将让你跳过这些运行时间。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BenchmarkExpensive</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">boringAndExpensiveSetup</span><span class="p">()</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">ResetTimer</span><span class="p">()</span> <span class="c1">// HL
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
                <span class="c1">// 被测试的功能
</span><span class="c1"></span>        <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果每次循环迭代内部都有一些高成本的其他逻辑，请使用<code>b.StopTimer()</code>和<code>b.StartTimer()</code>来暂停基准计时器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BenchmarkComplicated</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
                <span class="nx">b</span><span class="p">.</span><span class="nf">StopTimer</span><span class="p">()</span> <span class="c1">// HL
</span><span class="c1"></span>                <span class="nf">complicatedSetup</span><span class="p">()</span>
                <span class="nx">b</span><span class="p">.</span><span class="nf">StartTimer</span><span class="p">()</span> <span class="c1">// HL
</span><span class="c1"></span>                <span class="c1">// 被测试的功能
</span><span class="c1"></span>        <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="内存分配的基准测试">内存分配的基准测试</h2>
<p>分配计数和大小与基准测试的执行时间密切相关。 你可以告诉测试框架记录被测代码所做的分配数量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BenchmarkRead</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">ReportAllocs</span><span class="p">()</span>
        <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
                <span class="c1">// 被测试的功能
</span><span class="c1"></span>        <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>以下是使用bufio软件包基准测试的示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">% go test -run=^$ -bench=. bufio
goos: darwin
goarch: amd64
pkg: bufio
BenchmarkReaderCopyOptimal-8            20000000               103 ns/op
BenchmarkReaderCopyUnoptimal-8          10000000               159 ns/op
BenchmarkReaderCopyNoWriteTo-8            500000              3644 ns/op
BenchmarkReaderWriteToOptimal-8          5000000               344 ns/op
BenchmarkWriterCopyOptimal-8            20000000                98.6 ns/op
BenchmarkWriterCopyUnoptimal-8          10000000               131 ns/op
BenchmarkWriterCopyNoReadFrom-8           300000              3955 ns/op
BenchmarkReaderEmpty-8                   2000000               789 ns/op            4224 B/op          3 allocs/op
BenchmarkWriterEmpty-8                   2000000               683 ns/op            4096 B/op          1 allocs/op
BenchmarkWriterFlush-8                  100000000               17.0 ns/op             0 B/op          0 allocs/op
</code></pre></td></tr></table>
</div>
</div><p><em>注意:</em> 想对所有基准测试都生效，你也可以使用<code>go test -benchmem</code>标识。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">% go test -run=^$ -bench=. -benchmem bufio
goos: darwin
goarch: amd64
pkg: bufio
BenchmarkReaderCopyOptimal-8            20000000                93.5 ns/op            16 B/op          1 allocs/op
BenchmarkReaderCopyUnoptimal-8          10000000               155 ns/op              32 B/op          2 allocs/op
BenchmarkReaderCopyNoWriteTo-8            500000              3238 ns/op           32800 B/op          3 allocs/op
BenchmarkReaderWriteToOptimal-8          5000000               335 ns/op              16 B/op          1 allocs/op
BenchmarkWriterCopyOptimal-8            20000000                96.7 ns/op            16 B/op          1 allocs/op
BenchmarkWriterCopyUnoptimal-8          10000000               124 ns/op              32 B/op          2 allocs/op
BenchmarkWriterCopyNoReadFrom-8           500000              3219 ns/op           32800 B/op          3 allocs/op
BenchmarkReaderEmpty-8                   2000000               748 ns/op            4224 B/op          3 allocs/op
BenchmarkWriterEmpty-8                   2000000               662 ns/op            4096 B/op          1 allocs/op
BenchmarkWriterFlush-8                  100000000               16.9 ns/op             0 B/op          0 allocs/op
PASS
ok      bufio   20.366s
</code></pre></td></tr></table>
</div>
</div><h3 id="注意编译优化">注意编译优化</h3>
<p>这个例子来自 <a href="https://github.com/golang/go/issues/14813#issue-140603392">issue 14813</a>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">m1</span> <span class="p">=</span> <span class="mh">0x5555555555555555</span>
<span class="kd">const</span> <span class="nx">m2</span> <span class="p">=</span> <span class="mh">0x3333333333333333</span>
<span class="kd">const</span> <span class="nx">m4</span> <span class="p">=</span> <span class="mh">0x0f0f0f0f0f0f0f0f</span>
<span class="kd">const</span> <span class="nx">h01</span> <span class="p">=</span> <span class="mh">0x0101010101010101</span>

<span class="kd">func</span> <span class="nf">popcnt</span><span class="p">(</span><span class="nx">x</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
        <span class="nx">x</span> <span class="o">-=</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nx">m1</span>
        <span class="nx">x</span> <span class="p">=</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&amp;</span> <span class="nx">m2</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="nx">x</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nx">m2</span><span class="p">)</span>
        <span class="nx">x</span> <span class="p">=</span> <span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&amp;</span> <span class="nx">m4</span>
        <span class="k">return</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span> <span class="nx">h01</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">56</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">BenchmarkPopcnt</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
                <span class="nf">popcnt</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>你觉得这个基准测试会有多快？让我们来看看。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">% go test -bench=. ./examples/popcnt/
goos: darwin
goarch: amd64
BenchmarkPopcnt-8       2000000000               0.30 ns/op
PASS
</code></pre></td></tr></table>
</div>
</div><p>0.3 纳秒，这基本上是一个时钟周期。即使假设CPU每个时钟周期内会执行多条指令，这个数字似乎也不合理地低。 发生了什么？</p>
<p>要了解发生了什么，我们必须看看benchmark下的函数popcnt。  popcnt是一个叶子函数 - 它不调用任何其他函数 - 因此编译器可以内联它。</p>
<p>因为函数是内联的，所以编译器现在可以看到它没有副作用。  popcnt不会影响任何全局变量的状态。 这样，调用就被消除了。 这是编译器看到的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BenchmarkPopcnt</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
                <span class="c1">// 优化了
</span><span class="c1"></span>        <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在所有版本的Go编译器上，仍然会生成循环。 但是英特尔CPU非常擅长优化循环，尤其是空循环。</p>
<h3 id="优化是一件好事">优化是一件好事</h3>
<p>需要去掉的是，通过删除不必要的计算使真正的代码快速运行的优化，与删除没有明显副作用的基准测试的优化是相同的。</p>
<p>随着Go编译器的改进，这只会变得更加普遍。</p>
<h3 id="修复基准测试">修复基准测试</h3>
<p>要修复此基准测试，我们必须确保编译器无法检验<code>BenchmarkPopcnt</code>的主体不会导致全局状态发生变化。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">Result</span> <span class="kt">uint64</span>

<span class="kd">func</span> <span class="nf">BenchmarkPopcnt</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">r</span> <span class="kt">uint64</span>
        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
                <span class="nx">r</span> <span class="p">=</span> <span class="nf">popcnt</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="nx">Result</span> <span class="p">=</span> <span class="nx">r</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这是确保编译器无法优化循环体的推荐方法。</p>
<p>首先，我们通过将调用<code>popcnt</code>的结果存储在<code>r</code>中。 然后，当测试基准结束时，<code>r</code>在<code>BenchmarkPopcnt</code>的范围内被声明，<code>r</code>的结果对于程序的另一部分是不可见的，所以最终，我们将<code>r</code>值赋给包级别的公共变量<code>Result</code>。</p>
<p>因为<code>Result</code>是公共的，所以编译器无法证明导入此类的另一个包将无法看到<code>Result</code>随时间变化的值，因此它无法优化导致其赋值的任何操作。</p>
<h2 id="错误的基准测试">错误的基准测试</h2>
<p><code>for</code> 循环对基准测试的执行非常重要</p>
<p>下面是两个错误的的基准测试例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BenchmarkFibWrong</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fib</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BenchmarkFibWrong2</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
                <span class="nf">Fib</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>结果是，它们会一直执行下去</p>
<h2 id="分析基准测试的结果">分析基准测试的结果</h2>
<p><code>testing</code>包内置了支持生成CPU，内存和阻塞情况的 profile 文件。</p>
<ul>
<li><code>-cpuprofile=$FILE</code> 将 CPU 分析结果写入 <code>$FILE</code>.</li>
<li><code>-memprofile=$FILE</code> 将内存分析结果写入 <code>$FILE</code>, <code>-memprofilerate=N</code> 调整记录速率为 <code>1/N</code>.</li>
<li><code>-blockprofile=$FILE</code>, 将阻塞分析结果写入 <code>$FILE</code>.</li>
</ul>
<p>使用这些标识中的任何一个同时都会保留二进制文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">% go test -run=XXX -bench=. -cpuprofile=c.p bytes
% go tool pprof c.p
</code></pre></td></tr></table>
</div>
</div><p>转载:<a href="https://github.com/sxs2473/go-performane-tuning">https://github.com/sxs2473/go-performane-tuning</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-01-30
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go/">Go</a>
          <a href="/tags/benchmark/">benchmark</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go%E7%9A%84%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%86%85%E8%81%94%E4%B8%8E%E6%AD%BB%E7%A0%81%E6%B6%88%E9%99%A4/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go的编译优化:内联与死码消除</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/packagehttptest1.13/">
            <span class="next-text nav-default">Package:httptest(1.13)</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Forz</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
