<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>PushConsumer源码分析 | Forz Blog</title>
<meta name="keywords" content="rocketmq" />
<meta name="description" content="整体流程 NewPushConsumer 创建pushConsumer对象.配置负载均衡策略. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39">
<meta name="author" content="">
<link rel="canonical" href="/post/pushconsumer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="PushConsumer源码分析" />
<meta property="og:description" content="整体流程 NewPushConsumer 创建pushConsumer对象.配置负载均衡策略. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/pushconsumer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-04-23T14:42:04&#43;00:00" />
<meta property="article:modified_time" content="2020-04-23T14:42:04&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="PushConsumer源码分析"/>
<meta name="twitter:description" content="整体流程 NewPushConsumer 创建pushConsumer对象.配置负载均衡策略. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "PushConsumer源码分析",
      "item": "/post/pushconsumer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "PushConsumer源码分析",
  "name": "PushConsumer源码分析",
  "description": "整体流程 NewPushConsumer 创建pushConsumer对象.配置负载均衡策略. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39",
  "keywords": [
    "rocketmq"
  ],
  "articleBody": "整体流程 NewPushConsumer 创建pushConsumer对象.配置负载均衡策略.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  func NewPushConsumer(opts ...Option) (*pushConsumer, error) { defaultOpts := defaultPushConsumerOptions() for _, apply := range opts { apply(\u0026defaultOpts) } srvs, err := internal.NewNamesrv(defaultOpts.NameServerAddrs) if err != nil { return nil, errors.Wrap(err, \"new Namesrv failed.\") } if !defaultOpts.Credentials.IsEmpty() { srvs.SetCredentials(defaultOpts.Credentials) } defaultOpts.Namesrv = srvs if defaultOpts.Namespace != \"\" { defaultOpts.GroupName = defaultOpts.Namespace + \"%\" + defaultOpts.GroupName } dc := \u0026defaultConsumer{ client: internal.GetOrNewRocketMQClient(defaultOpts.ClientOptions, nil), consumerGroup: defaultOpts.GroupName, cType: _PushConsume, state: int32(internal.StateCreateJust), prCh: make(chan PullRequest, 4), model: defaultOpts.ConsumerModel, consumeOrderly: defaultOpts.ConsumeOrderly, fromWhere: defaultOpts.FromWhere, allocate: defaultOpts.Strategy, option: defaultOpts, namesrv: srvs, } p := \u0026pushConsumer{ defaultConsumer: dc, subscribedTopic: make(map[string]string, 0), queueLock: newQueueLock(), done: make(chan struct{}, 1), consumeFunc: utils.NewSet(), } dc.mqChanged = p.messageQueueChanged if p.consumeOrderly { p.submitToConsume = p.consumeMessageOrderly } else { p.submitToConsume = p.consumeMessageCurrently } p.interceptor = primitive.ChainInterceptors(p.option.Interceptors...) return p, nil }   Start Start方法整体代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85  func (pc *pushConsumer) Start() error { var err error pc.once.Do(func() { rlog.Info(\"the consumer start beginning\", map[string]interface{}{ rlog.LogKeyConsumerGroup: pc.consumerGroup, \"messageModel\": pc.model, \"unitMode\": pc.unitMode, }) atomic.StoreInt32(\u0026pc.state, int32(internal.StateStartFailed)) pc.validate() err = pc.client.RegisterConsumer(pc.consumerGroup, pc) if err != nil { rlog.Error(\"the consumer group has been created, specify another one\", map[string]interface{}{ rlog.LogKeyConsumerGroup: pc.consumerGroup, }) err = ErrCreated return } err = pc.defaultConsumer.start() if err != nil { return } go func() { // todo start clean msg expired \tfor { select { case pr := pc.prCh: go func() { pc.pullMessage(\u0026pr) }() case pc.done: rlog.Info(\"push consumer close pullConsumer listener.\", map[string]interface{}{ rlog.LogKeyConsumerGroup: pc.consumerGroup, }) return } } }() go primitive.WithRecover(func() { // initial lock. \tif !pc.consumeOrderly { return } time.Sleep(1000 * time.Millisecond) pc.lockAll() lockTicker := time.NewTicker(pc.option.RebalanceLockInterval) defer lockTicker.Stop() for { select { case lockTicker.C: pc.lockAll() case pc.done: rlog.Info(\"push consumer close tick.\", map[string]interface{}{ rlog.LogKeyConsumerGroup: pc.consumerGroup, }) return } } }) }) if err != nil { return err } pc.client.UpdateTopicRouteInfo() for k := range pc.subscribedTopic { _, exist := pc.topicSubscribeInfoTable.Load(k) if !exist { pc.client.Shutdown() return fmt.Errorf(\"the topic=%s route info not found, it may not exist\", k) } } pc.client.CheckClientInBroker() pc.client.SendHeartbeatToAllBrokerWithLock() pc.client.RebalanceImmediately() return err }   defaultConsumer.start 根据消费消息方式的不同，OffsetStore 的类型也不同。如果是BROADCASTING模式，使用的是LocalFileOffsetStore，Offset 存到本地；如果是CLUSTERING模式，使用的是RemoteBrokerOffsetStore，Offset 存到Broker机器上。\n然后调用start方法,开始获取数据.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func (dc *defaultConsumer) start() error { if len(dc.option.NameServerAddrs) == 0 { dc.namesrv.UpdateNameServerAddress(dc.option.NameServerDomain, dc.option.InstanceName) } if dc.model == Clustering { // set retry topic \tretryTopic := internal.GetRetryTopic(dc.consumerGroup) sub := buildSubscriptionData(retryTopic, MessageSelector{TAG, _SubAll}) dc.subscriptionDataTable.Store(retryTopic, sub) } if dc.model == Clustering { dc.option.ChangeInstanceNameToPID() dc.storage = NewRemoteOffsetStore(dc.consumerGroup, dc.client, dc.namesrv) } else { dc.storage = NewLocalFileOffsetStore(dc.consumerGroup, dc.client.ClientID()) } dc.client.Start() atomic.StoreInt32(\u0026dc.state, int32(internal.StateRunning)) dc.consumerStartTimestamp = time.Now().UnixNano() / int64(time.Millisecond) return nil }   pullMessage 获取消息的逻辑实现在pullMessage函数中，这是一个很大的函数，前半部分是进行一些判断，是进行流量控制的逻辑；中间是对返回消息结果做处理的逻辑；后面是发送获取消息请求的逻辑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  cachedMessageSizeInMiB := int(pq.cachedMsgSize / Mb) if pq.cachedMsgCount  pc.option.PullThresholdForQueue { if pc.queueFlowControlTimes%1000 == 0 { rlog.Warning(\"the cached message count exceeds the threshold, so do flow control\", map[string]interface{}{ \"PullThresholdForQueue\": pc.option.PullThresholdForQueue, \"minOffset\": pq.Min(), \"maxOffset\": pq.Max(), \"count\": pq.msgCache, \"size(MiB)\": cachedMessageSizeInMiB, \"flowControlTimes\": pc.queueFlowControlTimes, rlog.LogKeyPullRequest: request.String(), }) } pc.queueFlowControlTimes++ sleepTime = _PullDelayTimeWhenFlowControl goto NEXT } if cachedMessageSizeInMiB  pc.option.PullThresholdSizeForQueue { if pc.queueFlowControlTimes%1000 == 0 { rlog.Warning(\"the cached message size exceeds the threshold, so do flow control\", map[string]interface{}{ \"PullThresholdSizeForQueue\": pc.option.PullThresholdSizeForQueue, \"minOffset\": pq.Min(), \"maxOffset\": pq.Max(), \"count\": pq.msgCache, \"size(MiB)\": cachedMessageSizeInMiB, \"flowControlTimes\": pc.queueFlowControlTimes, rlog.LogKeyPullRequest: request.String(), }) } pc.queueFlowControlTimes++ sleepTime = _PullDelayTimeWhenFlowControl goto NEXT }   通过判断未处理消息的个数和总大小来控制是否继续请求消息。对于顺序消息还有一些特殊判断逻辑。获取的消息返回后,根据返回状态,调用相应的处理方法.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  switch result.Status { case primitive.PullFound: rlog.Debug(fmt.Sprintf(\"Topic: %s, QueueId: %d found messages.\", request.mq.Topic, request.mq.QueueId), nil) prevRequestOffset := request.nextOffset request.nextOffset = result.NextBeginOffset rt := time.Now().Sub(beginTime) / time.Millisecond increasePullRT(pc.consumerGroup, request.mq.Topic, int64(rt)) pc.processPullResult(request.mq, result, sd) msgFounded := result.GetMessageExts() firstMsgOffset := int64(math.MaxInt64) if msgFounded != nil \u0026\u0026 len(msgFounded) != 0 { firstMsgOffset = msgFounded[0].QueueOffset increasePullTPS(pc.consumerGroup, request.mq.Topic, len(msgFounded)) pq.putMessage(msgFounded...) } if result.NextBeginOffset  prevRequestOffset || firstMsgOffset  prevRequestOffset { rlog.Warning(\"[BUG] pull message result maybe data wrong\", map[string]interface{}{ \"nextBeginOffset\": result.NextBeginOffset, \"firstMsgOffset\": firstMsgOffset, \"prevRequestOffset\": prevRequestOffset, }) } case primitive.PullNoNewMsg: rlog.Debug(fmt.Sprintf(\"Topic: %s, QueueId: %d no more msg, current offset: %d, next offset: %d\", request.mq.Topic, request.mq.QueueId, pullRequest.QueueOffset, result.NextBeginOffset), nil) case primitive.PullNoMsgMatched: request.nextOffset = result.NextBeginOffset pc.correctTagsOffset(request) case primitive.PullOffsetIllegal: rlog.Warning(\"the pull request offset illegal\", map[string]interface{}{ rlog.LogKeyPullRequest: request.String(), \"result\": result.String(), }) request.nextOffset = result.NextBeginOffset pq.WithDropped(true) time.Sleep(10 * time.Second) pc.storage.update(request.mq, request.nextOffset, false) pc.storage.persist([]*primitive.MessageQueue{request.mq}) pc.processQueueTable.Delete(request.mq) rlog.Warning(fmt.Sprintf(\"fix the pull request offset: %s\", request.String()), nil) default: rlog.Warning(fmt.Sprintf(\"unknown pull status: %v\", result.Status), nil) sleepTime = _PullDelayTimeWhenError }   最后是发送获取消息请求，这三个阶段不停地循环执行，直到程序被停止.\n并发处理流程 处理效率的高低是反应 Consumer实现好坏的重要指标\n从 Broker获取到一批消息以后,根据 BatchSize的设置,把一批消息封装到一个PullRequest中,然后把这个PullRequest提交到prCh中执行.\n1 2 3 4 5 6 7  type PullRequest struct { consumerGroup string mq *primitive.MessageQueue pq *processQueue nextOffset int64 lockedFirst bool }   下面让我们一一来介绍一下PullRequest的核心属性:\n String consumerGroup： 消费者组。 MessageQueue messageQueue：待拉取消费队列。 ProcessQueue processQueue：消息处理队列，从Broker 拉取到的消息先存人ProccessQueue，然后再提交到消费者消费线程池消费。 long nextOffset：待拉取的MessageQueue偏移量。 Boolean lockedFirst： 是否被锁定。  消息的处理结果可能有不同的值,主要的两个是 CONSUME_SUCCESS和RECONSUME_LATER。如果消费不成功,要把消息5秒后再执行;如果消费模式是 CLUSTERING模式,未消费成功的消息会先被发送回 Broker,供这个 Consumer Group里的其他 Consumer消费,如果发送回 Broker失败,再调用 RECONSUME LATER.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  if result == ConsumeSuccess { increaseConsumeOKTPS(pc.consumerGroup, mq.Topic, len(subMsgs)) } else { increaseConsumeFailedTPS(pc.consumerGroup, mq.Topic, len(subMsgs)) if pc.model == BroadCasting { for i := 0; i  len(msgs); i++ { rlog.Warning(\"BROADCASTING, the message consume failed, drop it\", map[string]interface{}{ \"message\": subMsgs[i], }) } } else { for i := 0; i  len(msgs); i++ { msg := msgs[i] if !pc.sendMessageBack(mq.BrokerName, msg, concurrentCtx.DelayLevelWhenNextConsume) { msg.ReconsumeTimes += 1 msgBackFailed = append(msgBackFailed, msg) } } } }   ProcessQueue对象 在前面的源码中,有个 Process Queue类型的对象,这个对象的功能是什么呢?从Broker获得的消息,因为是提交到线程池里并行执行,很难监控和控制执行状态,比如如何获得当前消息堆积的数量,如何解决处理超时情况等。\nRocketMQ定义了一个快照类 ProcessQueue来解决这些问题,在 PushConsumer运行的时候,每个 Message Queue都会有一个对应的 Process Queue对象,保存了这个 Message Queue消息处理状态的快照.\nProcess Queue对象里主要的内容是一个TreeMap和一个读写锁。TreeMap里以Message Queue的oset作为Key,以消息内容的引用为 Value,保存了所有从 MessageQueue获取到但是还未被处理的消息,读写锁控制着多个线程对TreeMap对象的并发访问。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  type processQueue struct { cachedMsgCount int64 cachedMsgSize int64 tryUnlockTimes int64 queueOffsetMax int64 msgAccCnt int64 msgCache *treemap.Map mutex sync.RWMutex consumeLock sync.Mutex consumingMsgOrderlyTreeMap *treemap.Map dropped *uatomic.Bool lastPullTime time.Time lastConsumeTime atomic.Value locked *uatomic.Bool lastLockTime atomic.Value consuming bool lockConsume sync.Mutex msgCh chan []*primitive.MessageExt order bool }   有了 Process Queue对象,可以随时停止、启动消息的消费,同时也可用于帮助实现顺序消费消息。顺序消息是通过 ConsumeMessageOrderly实现的,主要流程和 ConsumeMessage Concurrently类似,区别只是在对并发消费的控制上.\n并发消费 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101  func (pc *pushConsumer) consumeMessageCurrently(pq *processQueue, mq *primitive.MessageQueue) { msgs := pq.getMessages() if msgs == nil { return } for count := 0; count  len(msgs); count++ { var subMsgs []*primitive.MessageExt if count+pc.option.ConsumeMessageBatchMaxSize  len(msgs) { subMsgs = msgs[count:] count = len(msgs) } else { next := count + pc.option.ConsumeMessageBatchMaxSize subMsgs = msgs[count:next] count = next - 1 } go primitive.WithRecover(func() { RETRY: if pq.IsDroppd() { rlog.Info(\"the message queue not be able to consume, because it was dropped\", map[string]interface{}{ rlog.LogKeyMessageQueue: mq.String(), rlog.LogKeyConsumerGroup: pc.consumerGroup, }) return } beginTime := time.Now() pc.resetRetryAndNamespace(subMsgs) var result ConsumeResult var err error msgCtx := \u0026primitive.ConsumeMessageContext{ Properties: make(map[string]string), ConsumerGroup: pc.consumerGroup, MQ: mq, Msgs: msgs, } ctx := context.Background() ctx = primitive.WithConsumerCtx(ctx, msgCtx) ctx = primitive.WithMethod(ctx, primitive.ConsumerPush) concurrentCtx := primitive.NewConsumeConcurrentlyContext() concurrentCtx.MQ = *mq ctx = primitive.WithConcurrentlyCtx(ctx, concurrentCtx) result, err = pc.consumeInner(ctx, subMsgs) consumeRT := time.Now().Sub(beginTime) if err != nil { msgCtx.Properties[primitive.PropCtxType] = string(primitive.ExceptionReturn) } else if consumeRT = pc.option.ConsumeTimeout { msgCtx.Properties[primitive.PropCtxType] = string(primitive.TimeoutReturn) } else if result == ConsumeSuccess { msgCtx.Properties[primitive.PropCtxType] = string(primitive.SuccessReturn) } else if result == ConsumeRetryLater { msgCtx.Properties[primitive.PropCtxType] = string(primitive.FailedReturn) } increaseConsumeRT(pc.consumerGroup, mq.Topic, int64(consumeRT/time.Millisecond)) if !pq.IsDroppd() { msgBackFailed := make([]*primitive.MessageExt, 0) if result == ConsumeSuccess { increaseConsumeOKTPS(pc.consumerGroup, mq.Topic, len(subMsgs)) } else { increaseConsumeFailedTPS(pc.consumerGroup, mq.Topic, len(subMsgs)) if pc.model == BroadCasting { for i := 0; i  len(msgs); i++ { rlog.Warning(\"BROADCASTING, the message consume failed, drop it\", map[string]interface{}{ \"message\": subMsgs[i], }) } } else { for i := 0; i  len(msgs); i++ { msg := msgs[i] if !pc.sendMessageBack(mq.BrokerName, msg, concurrentCtx.DelayLevelWhenNextConsume) { msg.ReconsumeTimes += 1 msgBackFailed = append(msgBackFailed, msg) } } } } offset := pq.removeMessage(subMsgs...) if offset = 0 \u0026\u0026 !pq.IsDroppd() { pc.storage.update(mq, int64(offset), true) } if len(msgBackFailed)  0 { subMsgs = msgBackFailed time.Sleep(5 * time.Second) goto RETRY } } else { rlog.Warning(\"processQueue is dropped without process consume result.\", map[string]interface{}{ rlog.LogKeyMessageQueue: mq, \"message\": msgs, }) } }) } }   顺序消费 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143  func (pc *pushConsumer) consumeMessageOrderly(pq *processQueue, mq *primitive.MessageQueue) { if pq.IsDroppd() { rlog.Warning(\"the message queue not be able to consume, because it's dropped.\", map[string]interface{}{ rlog.LogKeyMessageQueue: mq.String(), }) return } lock := pc.queueLock.fetchLock(*mq) lock.Lock() defer lock.Unlock() if pc.model == BroadCasting || (pq.IsLock() \u0026\u0026 !pq.isLockExpired()) { beginTime := time.Now() continueConsume := true for continueConsume { if pq.IsDroppd() { rlog.Warning(\"the message queue not be able to consume, because it's dropped.\", map[string]interface{}{ rlog.LogKeyMessageQueue: mq.String(), }) break } if pc.model == Clustering { if !pq.IsLock() { rlog.Warning(\"the message queue not locked, so consume later\", map[string]interface{}{ rlog.LogKeyMessageQueue: mq.String(), }) pc.tryLockLaterAndReconsume(mq, 10) return } if pq.isLockExpired() { rlog.Warning(\"the message queue lock expired, so consume later\", map[string]interface{}{ rlog.LogKeyMessageQueue: mq.String(), }) pc.tryLockLaterAndReconsume(mq, 10) return } } interval := time.Now().Sub(beginTime) if interval  pc.option.MaxTimeConsumeContinuously { time.Sleep(10 * time.Millisecond) return } batchSize := pc.option.ConsumeMessageBatchMaxSize msgs := pq.takeMessages(batchSize) pc.resetRetryAndNamespace(msgs) if len(msgs) == 0 { continueConsume = false break } // TODO: add message consumer hook \tbeginTime = time.Now() ctx := context.Background() msgCtx := \u0026primitive.ConsumeMessageContext{ Properties: make(map[string]string), ConsumerGroup: pc.consumerGroup, MQ: mq, Msgs: msgs, } ctx = primitive.WithConsumerCtx(ctx, msgCtx) ctx = primitive.WithMethod(ctx, primitive.ConsumerPush) orderlyCtx := primitive.NewConsumeOrderlyContext() orderlyCtx.MQ = *mq ctx = primitive.WithOrderlyCtx(ctx, orderlyCtx) pq.lockConsume.Lock() result, _ := pc.consumeInner(ctx, msgs) pq.lockConsume.Unlock() if result == Rollback || result == SuspendCurrentQueueAMoment { rlog.Warning(\"consumeMessage Orderly return not OK\", map[string]interface{}{ rlog.LogKeyConsumerGroup: pc.consumerGroup, \"messages\": msgs, rlog.LogKeyMessageQueue: mq, }) } // jsut put consumeResult in consumerMessageCtx \t//interval = time.Now().Sub(beginTime) \t//consumeReult := SuccessReturn \t//if interval  pc.option.ConsumeTimeout { \t//\tconsumeReult = TimeoutReturn \t//} else if SuspendCurrentQueueAMoment == result { \t//\tconsumeReult = FailedReturn \t//} else if ConsumeSuccess == result { \t//\tconsumeReult = SuccessReturn \t//}  // process result \tcommitOffset := int64(-1) if pc.option.AutoCommit { switch result { case Commit, Rollback: rlog.Warning(\"the message queue consume result is illegal, we think you want to ack these message: %v\", map[string]interface{}{ rlog.LogKeyMessageQueue: mq, }) case ConsumeSuccess: commitOffset = pq.commit() case SuspendCurrentQueueAMoment: if pc.checkReconsumeTimes(msgs) { pq.putMessage(msgs...) time.Sleep(time.Duration(orderlyCtx.SuspendCurrentQueueTimeMillis) * time.Millisecond) continueConsume = false } else { commitOffset = pq.commit() } default: } } else { switch result { case ConsumeSuccess: case Commit: commitOffset = pq.commit() case Rollback: // pq.rollback \ttime.Sleep(time.Duration(orderlyCtx.SuspendCurrentQueueTimeMillis) * time.Millisecond) continueConsume = false case SuspendCurrentQueueAMoment: if pc.checkReconsumeTimes(msgs) { time.Sleep(time.Duration(orderlyCtx.SuspendCurrentQueueTimeMillis) * time.Millisecond) continueConsume = false } default: } } if commitOffset  0 \u0026\u0026 !pq.IsDroppd() { _ = pc.updateOffset(mq, commitOffset) } } } else { if pq.IsDroppd() { rlog.Warning(\"the message queue not be able to consume, because it's dropped.\", map[string]interface{}{ rlog.LogKeyMessageQueue: mq.String(), }) } pc.tryLockLaterAndReconsume(mq, 100) } }   ",
  "wordCount" : "3319",
  "inLanguage": "zh-cn",
  "datePublished": "2020-04-23T14:42:04Z",
  "dateModified": "2020-04-23T14:42:04Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/pushconsumer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      PushConsumer源码分析
    </h1>
    <div class="post-meta">April 23, 2020
</div>
  </header> 
  <div class="post-content"><h1 id="整体流程">整体流程<a hidden class="anchor" aria-hidden="true" href="#整体流程">#</a></h1>
<h2 id="newpushconsumer">NewPushConsumer<a hidden class="anchor" aria-hidden="true" href="#newpushconsumer">#</a></h2>
<p>创建pushConsumer对象.配置负载均衡策略.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewPushConsumer</span><span class="p">(</span><span class="nx">opts</span> <span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">pushConsumer</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">defaultOpts</span> <span class="o">:=</span> <span class="nf">defaultPushConsumerOptions</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">apply</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
		<span class="nf">apply</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">defaultOpts</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">srvs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">internal</span><span class="p">.</span><span class="nf">NewNamesrv</span><span class="p">(</span><span class="nx">defaultOpts</span><span class="p">.</span><span class="nx">NameServerAddrs</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrap</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;new Namesrv failed.&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">defaultOpts</span><span class="p">.</span><span class="nx">Credentials</span><span class="p">.</span><span class="nf">IsEmpty</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">srvs</span><span class="p">.</span><span class="nf">SetCredentials</span><span class="p">(</span><span class="nx">defaultOpts</span><span class="p">.</span><span class="nx">Credentials</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">defaultOpts</span><span class="p">.</span><span class="nx">Namesrv</span> <span class="p">=</span> <span class="nx">srvs</span>

	<span class="k">if</span> <span class="nx">defaultOpts</span><span class="p">.</span><span class="nx">Namespace</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">defaultOpts</span><span class="p">.</span><span class="nx">GroupName</span> <span class="p">=</span> <span class="nx">defaultOpts</span><span class="p">.</span><span class="nx">Namespace</span> <span class="o">+</span> <span class="s">&#34;%&#34;</span> <span class="o">+</span> <span class="nx">defaultOpts</span><span class="p">.</span><span class="nx">GroupName</span>
	<span class="p">}</span>

	<span class="nx">dc</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">defaultConsumer</span><span class="p">{</span>
		<span class="nx">client</span><span class="p">:</span>         <span class="nx">internal</span><span class="p">.</span><span class="nf">GetOrNewRocketMQClient</span><span class="p">(</span><span class="nx">defaultOpts</span><span class="p">.</span><span class="nx">ClientOptions</span><span class="p">,</span> <span class="kc">nil</span><span class="p">),</span>
		<span class="nx">consumerGroup</span><span class="p">:</span>  <span class="nx">defaultOpts</span><span class="p">.</span><span class="nx">GroupName</span><span class="p">,</span>
		<span class="nx">cType</span><span class="p">:</span>          <span class="nx">_PushConsume</span><span class="p">,</span>
		<span class="nx">state</span><span class="p">:</span>          <span class="nb">int32</span><span class="p">(</span><span class="nx">internal</span><span class="p">.</span><span class="nx">StateCreateJust</span><span class="p">),</span>
		<span class="nx">prCh</span><span class="p">:</span>           <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">PullRequest</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="nx">model</span><span class="p">:</span>          <span class="nx">defaultOpts</span><span class="p">.</span><span class="nx">ConsumerModel</span><span class="p">,</span>
		<span class="nx">consumeOrderly</span><span class="p">:</span> <span class="nx">defaultOpts</span><span class="p">.</span><span class="nx">ConsumeOrderly</span><span class="p">,</span>
		<span class="nx">fromWhere</span><span class="p">:</span>      <span class="nx">defaultOpts</span><span class="p">.</span><span class="nx">FromWhere</span><span class="p">,</span>
		<span class="nx">allocate</span><span class="p">:</span>       <span class="nx">defaultOpts</span><span class="p">.</span><span class="nx">Strategy</span><span class="p">,</span>
		<span class="nx">option</span><span class="p">:</span>         <span class="nx">defaultOpts</span><span class="p">,</span>
		<span class="nx">namesrv</span><span class="p">:</span>        <span class="nx">srvs</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">pushConsumer</span><span class="p">{</span>
		<span class="nx">defaultConsumer</span><span class="p">:</span> <span class="nx">dc</span><span class="p">,</span>
		<span class="nx">subscribedTopic</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="nx">queueLock</span><span class="p">:</span>       <span class="nf">newQueueLock</span><span class="p">(),</span>
		<span class="nx">done</span><span class="p">:</span>            <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">1</span><span class="p">),</span>
		<span class="nx">consumeFunc</span><span class="p">:</span>     <span class="nx">utils</span><span class="p">.</span><span class="nf">NewSet</span><span class="p">(),</span>
	<span class="p">}</span>
	<span class="nx">dc</span><span class="p">.</span><span class="nx">mqChanged</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">messageQueueChanged</span>
	<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">consumeOrderly</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">submitToConsume</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">consumeMessageOrderly</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">submitToConsume</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">consumeMessageCurrently</span>
	<span class="p">}</span>

	<span class="nx">p</span><span class="p">.</span><span class="nx">interceptor</span> <span class="p">=</span> <span class="nx">primitive</span><span class="p">.</span><span class="nf">ChainInterceptors</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">option</span><span class="p">.</span><span class="nx">Interceptors</span><span class="o">...</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">p</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="start">Start<a hidden class="anchor" aria-hidden="true" href="#start">#</a></h2>
<p>Start方法整体代码如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">pc</span> <span class="o">*</span><span class="nx">pushConsumer</span><span class="p">)</span> <span class="nf">Start</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="nx">pc</span><span class="p">.</span><span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">rlog</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="s">&#34;the consumer start beginning&#34;</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
			<span class="nx">rlog</span><span class="p">.</span><span class="nx">LogKeyConsumerGroup</span><span class="p">:</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">consumerGroup</span><span class="p">,</span>
			<span class="s">&#34;messageModel&#34;</span><span class="p">:</span>           <span class="nx">pc</span><span class="p">.</span><span class="nx">model</span><span class="p">,</span>
			<span class="s">&#34;unitMode&#34;</span><span class="p">:</span>               <span class="nx">pc</span><span class="p">.</span><span class="nx">unitMode</span><span class="p">,</span>
		<span class="p">})</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pc</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">internal</span><span class="p">.</span><span class="nx">StateStartFailed</span><span class="p">))</span>
		<span class="nx">pc</span><span class="p">.</span><span class="nf">validate</span><span class="p">()</span>

		<span class="nx">err</span> <span class="p">=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">RegisterConsumer</span><span class="p">(</span><span class="nx">pc</span><span class="p">.</span><span class="nx">consumerGroup</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">rlog</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="s">&#34;the consumer group has been created, specify another one&#34;</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
				<span class="nx">rlog</span><span class="p">.</span><span class="nx">LogKeyConsumerGroup</span><span class="p">:</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">consumerGroup</span><span class="p">,</span>
			<span class="p">})</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">ErrCreated</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="nx">err</span> <span class="p">=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">defaultConsumer</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// todo start clean msg expired
</span><span class="c1"></span>			<span class="k">for</span> <span class="p">{</span>
				<span class="k">select</span> <span class="p">{</span>
				<span class="k">case</span> <span class="nx">pr</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">pc</span><span class="p">.</span><span class="nx">prCh</span><span class="p">:</span>
					<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
						<span class="nx">pc</span><span class="p">.</span><span class="nf">pullMessage</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pr</span><span class="p">)</span>
					<span class="p">}()</span>
				<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">pc</span><span class="p">.</span><span class="nx">done</span><span class="p">:</span>
					<span class="nx">rlog</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="s">&#34;push consumer close pullConsumer listener.&#34;</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
						<span class="nx">rlog</span><span class="p">.</span><span class="nx">LogKeyConsumerGroup</span><span class="p">:</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">consumerGroup</span><span class="p">,</span>
					<span class="p">})</span>
					<span class="k">return</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}()</span>

		<span class="k">go</span> <span class="nx">primitive</span><span class="p">.</span><span class="nf">WithRecover</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// initial lock.
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">pc</span><span class="p">.</span><span class="nx">consumeOrderly</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>

			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1000</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nf">lockAll</span><span class="p">()</span>

			<span class="nx">lockTicker</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="nx">pc</span><span class="p">.</span><span class="nx">option</span><span class="p">.</span><span class="nx">RebalanceLockInterval</span><span class="p">)</span>
			<span class="k">defer</span> <span class="nx">lockTicker</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
			<span class="k">for</span> <span class="p">{</span>
				<span class="k">select</span> <span class="p">{</span>
				<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">lockTicker</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
					<span class="nx">pc</span><span class="p">.</span><span class="nf">lockAll</span><span class="p">()</span>
				<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">pc</span><span class="p">.</span><span class="nx">done</span><span class="p">:</span>
					<span class="nx">rlog</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="s">&#34;push consumer close tick.&#34;</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
						<span class="nx">rlog</span><span class="p">.</span><span class="nx">LogKeyConsumerGroup</span><span class="p">:</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">consumerGroup</span><span class="p">,</span>
					<span class="p">})</span>
					<span class="k">return</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">})</span>
	<span class="p">})</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">pc</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">UpdateTopicRouteInfo</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">subscribedTopic</span> <span class="p">{</span>
		<span class="nx">_</span><span class="p">,</span> <span class="nx">exist</span> <span class="o">:=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">topicSubscribeInfoTable</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">exist</span> <span class="p">{</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">Shutdown</span><span class="p">()</span>
			<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;the topic=%s route info not found, it may not exist&#34;</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">pc</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">CheckClientInBroker</span><span class="p">()</span>
	<span class="nx">pc</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">SendHeartbeatToAllBrokerWithLock</span><span class="p">()</span>
	<span class="nx">pc</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">RebalanceImmediately</span><span class="p">()</span>

	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="defaultconsumerstart">defaultConsumer.start<a hidden class="anchor" aria-hidden="true" href="#defaultconsumerstart">#</a></h3>
<p>根据消费消息方式的不同，OffsetStore 的类型也不同。如果是BROADCASTING模式，使用的是LocalFileOffsetStore，Offset 存到本地；如果是CLUSTERING模式，使用的是RemoteBrokerOffsetStore，Offset 存到Broker机器上。</p>
<p>然后调用start方法,开始获取数据.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">dc</span> <span class="o">*</span><span class="nx">defaultConsumer</span><span class="p">)</span> <span class="nf">start</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dc</span><span class="p">.</span><span class="nx">option</span><span class="p">.</span><span class="nx">NameServerAddrs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">dc</span><span class="p">.</span><span class="nx">namesrv</span><span class="p">.</span><span class="nf">UpdateNameServerAddress</span><span class="p">(</span><span class="nx">dc</span><span class="p">.</span><span class="nx">option</span><span class="p">.</span><span class="nx">NameServerDomain</span><span class="p">,</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">option</span><span class="p">.</span><span class="nx">InstanceName</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">model</span> <span class="o">==</span> <span class="nx">Clustering</span> <span class="p">{</span>
		<span class="c1">// set retry topic
</span><span class="c1"></span>		<span class="nx">retryTopic</span> <span class="o">:=</span> <span class="nx">internal</span><span class="p">.</span><span class="nf">GetRetryTopic</span><span class="p">(</span><span class="nx">dc</span><span class="p">.</span><span class="nx">consumerGroup</span><span class="p">)</span>
		<span class="nx">sub</span> <span class="o">:=</span> <span class="nf">buildSubscriptionData</span><span class="p">(</span><span class="nx">retryTopic</span><span class="p">,</span> <span class="nx">MessageSelector</span><span class="p">{</span><span class="nx">TAG</span><span class="p">,</span> <span class="nx">_SubAll</span><span class="p">})</span>
		<span class="nx">dc</span><span class="p">.</span><span class="nx">subscriptionDataTable</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">retryTopic</span><span class="p">,</span> <span class="nx">sub</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">model</span> <span class="o">==</span> <span class="nx">Clustering</span> <span class="p">{</span>
		<span class="nx">dc</span><span class="p">.</span><span class="nx">option</span><span class="p">.</span><span class="nf">ChangeInstanceNameToPID</span><span class="p">()</span>
		<span class="nx">dc</span><span class="p">.</span><span class="nx">storage</span> <span class="p">=</span> <span class="nf">NewRemoteOffsetStore</span><span class="p">(</span><span class="nx">dc</span><span class="p">.</span><span class="nx">consumerGroup</span><span class="p">,</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">client</span><span class="p">,</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">namesrv</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">dc</span><span class="p">.</span><span class="nx">storage</span> <span class="p">=</span> <span class="nf">NewLocalFileOffsetStore</span><span class="p">(</span><span class="nx">dc</span><span class="p">.</span><span class="nx">consumerGroup</span><span class="p">,</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">ClientID</span><span class="p">())</span>
	<span class="p">}</span>

	<span class="nx">dc</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dc</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">internal</span><span class="p">.</span><span class="nx">StateRunning</span><span class="p">))</span>
	<span class="nx">dc</span><span class="p">.</span><span class="nx">consumerStartTimestamp</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">()</span> <span class="o">/</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="pullmessage">pullMessage<a hidden class="anchor" aria-hidden="true" href="#pullmessage">#</a></h2>
<p>获取消息的逻辑实现在pullMessage函数中，这是一个很大的函数，前半部分是进行一些判断，是进行流量控制的逻辑；中间是对返回消息结果做处理的逻辑；后面是发送获取消息请求的逻辑。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">		<span class="nx">cachedMessageSizeInMiB</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">pq</span><span class="p">.</span><span class="nx">cachedMsgSize</span> <span class="o">/</span> <span class="nx">Mb</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">pq</span><span class="p">.</span><span class="nx">cachedMsgCount</span> <span class="p">&gt;</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">option</span><span class="p">.</span><span class="nx">PullThresholdForQueue</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">queueFlowControlTimes</span><span class="o">%</span><span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">rlog</span><span class="p">.</span><span class="nf">Warning</span><span class="p">(</span><span class="s">&#34;the cached message count exceeds the threshold, so do flow control&#34;</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
					<span class="s">&#34;PullThresholdForQueue&#34;</span><span class="p">:</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">option</span><span class="p">.</span><span class="nx">PullThresholdForQueue</span><span class="p">,</span>
					<span class="s">&#34;minOffset&#34;</span><span class="p">:</span>             <span class="nx">pq</span><span class="p">.</span><span class="nf">Min</span><span class="p">(),</span>
					<span class="s">&#34;maxOffset&#34;</span><span class="p">:</span>             <span class="nx">pq</span><span class="p">.</span><span class="nf">Max</span><span class="p">(),</span>
					<span class="s">&#34;count&#34;</span><span class="p">:</span>                 <span class="nx">pq</span><span class="p">.</span><span class="nx">msgCache</span><span class="p">,</span>
					<span class="s">&#34;size(MiB)&#34;</span><span class="p">:</span>             <span class="nx">cachedMessageSizeInMiB</span><span class="p">,</span>
					<span class="s">&#34;flowControlTimes&#34;</span><span class="p">:</span>      <span class="nx">pc</span><span class="p">.</span><span class="nx">queueFlowControlTimes</span><span class="p">,</span>
					<span class="nx">rlog</span><span class="p">.</span><span class="nx">LogKeyPullRequest</span><span class="p">:</span>  <span class="nx">request</span><span class="p">.</span><span class="nf">String</span><span class="p">(),</span>
				<span class="p">})</span>
			<span class="p">}</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">queueFlowControlTimes</span><span class="o">++</span>
			<span class="nx">sleepTime</span> <span class="p">=</span> <span class="nx">_PullDelayTimeWhenFlowControl</span>
			<span class="k">goto</span> <span class="nx">NEXT</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">cachedMessageSizeInMiB</span> <span class="p">&gt;</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">option</span><span class="p">.</span><span class="nx">PullThresholdSizeForQueue</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">queueFlowControlTimes</span><span class="o">%</span><span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">rlog</span><span class="p">.</span><span class="nf">Warning</span><span class="p">(</span><span class="s">&#34;the cached message size exceeds the threshold, so do flow control&#34;</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
					<span class="s">&#34;PullThresholdSizeForQueue&#34;</span><span class="p">:</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">option</span><span class="p">.</span><span class="nx">PullThresholdSizeForQueue</span><span class="p">,</span>
					<span class="s">&#34;minOffset&#34;</span><span class="p">:</span>                 <span class="nx">pq</span><span class="p">.</span><span class="nf">Min</span><span class="p">(),</span>
					<span class="s">&#34;maxOffset&#34;</span><span class="p">:</span>                 <span class="nx">pq</span><span class="p">.</span><span class="nf">Max</span><span class="p">(),</span>
					<span class="s">&#34;count&#34;</span><span class="p">:</span>                     <span class="nx">pq</span><span class="p">.</span><span class="nx">msgCache</span><span class="p">,</span>
					<span class="s">&#34;size(MiB)&#34;</span><span class="p">:</span>                 <span class="nx">cachedMessageSizeInMiB</span><span class="p">,</span>
					<span class="s">&#34;flowControlTimes&#34;</span><span class="p">:</span>          <span class="nx">pc</span><span class="p">.</span><span class="nx">queueFlowControlTimes</span><span class="p">,</span>
					<span class="nx">rlog</span><span class="p">.</span><span class="nx">LogKeyPullRequest</span><span class="p">:</span>      <span class="nx">request</span><span class="p">.</span><span class="nf">String</span><span class="p">(),</span>
				<span class="p">})</span>
			<span class="p">}</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">queueFlowControlTimes</span><span class="o">++</span>
			<span class="nx">sleepTime</span> <span class="p">=</span> <span class="nx">_PullDelayTimeWhenFlowControl</span>
			<span class="k">goto</span> <span class="nx">NEXT</span>
		<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>通过判断未处理消息的个数和总大小来控制是否继续请求消息。对于顺序消息还有一些特殊判断逻辑。获取的消息返回后,根据返回状态,调用相应的处理方法.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">		<span class="k">switch</span> <span class="nx">result</span><span class="p">.</span><span class="nx">Status</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">primitive</span><span class="p">.</span><span class="nx">PullFound</span><span class="p">:</span>
			<span class="nx">rlog</span><span class="p">.</span><span class="nf">Debug</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;Topic: %s, QueueId: %d found messages.&#34;</span><span class="p">,</span> <span class="nx">request</span><span class="p">.</span><span class="nx">mq</span><span class="p">.</span><span class="nx">Topic</span><span class="p">,</span> <span class="nx">request</span><span class="p">.</span><span class="nx">mq</span><span class="p">.</span><span class="nx">QueueId</span><span class="p">),</span> <span class="kc">nil</span><span class="p">)</span>
			<span class="nx">prevRequestOffset</span> <span class="o">:=</span> <span class="nx">request</span><span class="p">.</span><span class="nx">nextOffset</span>
			<span class="nx">request</span><span class="p">.</span><span class="nx">nextOffset</span> <span class="p">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">NextBeginOffset</span>

			<span class="nx">rt</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">beginTime</span><span class="p">)</span> <span class="o">/</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span>
			<span class="nf">increasePullRT</span><span class="p">(</span><span class="nx">pc</span><span class="p">.</span><span class="nx">consumerGroup</span><span class="p">,</span> <span class="nx">request</span><span class="p">.</span><span class="nx">mq</span><span class="p">.</span><span class="nx">Topic</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">rt</span><span class="p">))</span>

			<span class="nx">pc</span><span class="p">.</span><span class="nf">processPullResult</span><span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">mq</span><span class="p">,</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">sd</span><span class="p">)</span>

			<span class="nx">msgFounded</span> <span class="o">:=</span> <span class="nx">result</span><span class="p">.</span><span class="nf">GetMessageExts</span><span class="p">()</span>
			<span class="nx">firstMsgOffset</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt64</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">msgFounded</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">msgFounded</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">firstMsgOffset</span> <span class="p">=</span> <span class="nx">msgFounded</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">QueueOffset</span>
				<span class="nf">increasePullTPS</span><span class="p">(</span><span class="nx">pc</span><span class="p">.</span><span class="nx">consumerGroup</span><span class="p">,</span> <span class="nx">request</span><span class="p">.</span><span class="nx">mq</span><span class="p">.</span><span class="nx">Topic</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">msgFounded</span><span class="p">))</span>
				<span class="nx">pq</span><span class="p">.</span><span class="nf">putMessage</span><span class="p">(</span><span class="nx">msgFounded</span><span class="o">...</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">result</span><span class="p">.</span><span class="nx">NextBeginOffset</span> <span class="p">&lt;</span> <span class="nx">prevRequestOffset</span> <span class="o">||</span> <span class="nx">firstMsgOffset</span> <span class="p">&lt;</span> <span class="nx">prevRequestOffset</span> <span class="p">{</span>
				<span class="nx">rlog</span><span class="p">.</span><span class="nf">Warning</span><span class="p">(</span><span class="s">&#34;[BUG] pull message result maybe data wrong&#34;</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
					<span class="s">&#34;nextBeginOffset&#34;</span><span class="p">:</span>   <span class="nx">result</span><span class="p">.</span><span class="nx">NextBeginOffset</span><span class="p">,</span>
					<span class="s">&#34;firstMsgOffset&#34;</span><span class="p">:</span>    <span class="nx">firstMsgOffset</span><span class="p">,</span>
					<span class="s">&#34;prevRequestOffset&#34;</span><span class="p">:</span> <span class="nx">prevRequestOffset</span><span class="p">,</span>
				<span class="p">})</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="nx">primitive</span><span class="p">.</span><span class="nx">PullNoNewMsg</span><span class="p">:</span>
			<span class="nx">rlog</span><span class="p">.</span><span class="nf">Debug</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;Topic: %s, QueueId: %d no more msg, current offset: %d, next offset: %d&#34;</span><span class="p">,</span>
				<span class="nx">request</span><span class="p">.</span><span class="nx">mq</span><span class="p">.</span><span class="nx">Topic</span><span class="p">,</span> <span class="nx">request</span><span class="p">.</span><span class="nx">mq</span><span class="p">.</span><span class="nx">QueueId</span><span class="p">,</span> <span class="nx">pullRequest</span><span class="p">.</span><span class="nx">QueueOffset</span><span class="p">,</span> <span class="nx">result</span><span class="p">.</span><span class="nx">NextBeginOffset</span><span class="p">),</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">primitive</span><span class="p">.</span><span class="nx">PullNoMsgMatched</span><span class="p">:</span>
			<span class="nx">request</span><span class="p">.</span><span class="nx">nextOffset</span> <span class="p">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">NextBeginOffset</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nf">correctTagsOffset</span><span class="p">(</span><span class="nx">request</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">primitive</span><span class="p">.</span><span class="nx">PullOffsetIllegal</span><span class="p">:</span>
			<span class="nx">rlog</span><span class="p">.</span><span class="nf">Warning</span><span class="p">(</span><span class="s">&#34;the pull request offset illegal&#34;</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
				<span class="nx">rlog</span><span class="p">.</span><span class="nx">LogKeyPullRequest</span><span class="p">:</span> <span class="nx">request</span><span class="p">.</span><span class="nf">String</span><span class="p">(),</span>
				<span class="s">&#34;result&#34;</span><span class="p">:</span>               <span class="nx">result</span><span class="p">.</span><span class="nf">String</span><span class="p">(),</span>
			<span class="p">})</span>
			<span class="nx">request</span><span class="p">.</span><span class="nx">nextOffset</span> <span class="p">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">NextBeginOffset</span>
			<span class="nx">pq</span><span class="p">.</span><span class="nf">WithDropped</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">storage</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">mq</span><span class="p">,</span> <span class="nx">request</span><span class="p">.</span><span class="nx">nextOffset</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">storage</span><span class="p">.</span><span class="nf">persist</span><span class="p">([]</span><span class="o">*</span><span class="nx">primitive</span><span class="p">.</span><span class="nx">MessageQueue</span><span class="p">{</span><span class="nx">request</span><span class="p">.</span><span class="nx">mq</span><span class="p">})</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">processQueueTable</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">mq</span><span class="p">)</span>
			<span class="nx">rlog</span><span class="p">.</span><span class="nf">Warning</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;fix the pull request offset: %s&#34;</span><span class="p">,</span> <span class="nx">request</span><span class="p">.</span><span class="nf">String</span><span class="p">()),</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nx">rlog</span><span class="p">.</span><span class="nf">Warning</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;unknown pull status: %v&#34;</span><span class="p">,</span> <span class="nx">result</span><span class="p">.</span><span class="nx">Status</span><span class="p">),</span> <span class="kc">nil</span><span class="p">)</span>
			<span class="nx">sleepTime</span> <span class="p">=</span> <span class="nx">_PullDelayTimeWhenError</span>
		<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>最后是发送获取消息请求，这三个阶段不停地循环执行，直到程序被停止.</p>
<h1 id="并发处理流程">并发处理流程<a hidden class="anchor" aria-hidden="true" href="#并发处理流程">#</a></h1>
<p>处理效率的高低是反应 Consumer实现好坏的重要指标</p>
<p>从 Broker获取到一批消息以后,根据 BatchSize的设置,把一批消息封装到一个PullRequest中,然后把这个PullRequest提交到prCh中执行.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">PullRequest</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">consumerGroup</span> <span class="kt">string</span>
	<span class="nx">mq</span>            <span class="o">*</span><span class="nx">primitive</span><span class="p">.</span><span class="nx">MessageQueue</span>
	<span class="nx">pq</span>            <span class="o">*</span><span class="nx">processQueue</span>
	<span class="nx">nextOffset</span>    <span class="kt">int64</span>
	<span class="nx">lockedFirst</span>   <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>下面让我们一一来介绍一下PullRequest的核心属性:</p>
<ul>
<li>String consumerGroup： 消费者组。</li>
<li>MessageQueue messageQueue：待拉取消费队列。</li>
<li>ProcessQueue processQueue：消息处理队列，从Broker 拉取到的消息先存人ProccessQueue，然后再提交到消费者消费线程池消费。</li>
<li>long nextOffset：待拉取的MessageQueue偏移量。</li>
<li>Boolean lockedFirst： 是否被锁定。</li>
</ul>
<p>消息的处理结果可能有不同的值,主要的两个是 CONSUME_SUCCESS和RECONSUME_LATER。如果消费不成功,要把消息5秒后再执行;如果消费模式是 CLUSTERING模式,未消费成功的消息会先被发送回 Broker,供这个 Consumer Group里的其他 Consumer消费,如果发送回 Broker失败,再调用 RECONSUME LATER.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">				<span class="k">if</span> <span class="nx">result</span> <span class="o">==</span> <span class="nx">ConsumeSuccess</span> <span class="p">{</span>
					<span class="nf">increaseConsumeOKTPS</span><span class="p">(</span><span class="nx">pc</span><span class="p">.</span><span class="nx">consumerGroup</span><span class="p">,</span> <span class="nx">mq</span><span class="p">.</span><span class="nx">Topic</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">subMsgs</span><span class="p">))</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nf">increaseConsumeFailedTPS</span><span class="p">(</span><span class="nx">pc</span><span class="p">.</span><span class="nx">consumerGroup</span><span class="p">,</span> <span class="nx">mq</span><span class="p">.</span><span class="nx">Topic</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">subMsgs</span><span class="p">))</span>
					<span class="k">if</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">model</span> <span class="o">==</span> <span class="nx">BroadCasting</span> <span class="p">{</span>
						<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">msgs</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
							<span class="nx">rlog</span><span class="p">.</span><span class="nf">Warning</span><span class="p">(</span><span class="s">&#34;BROADCASTING, the message consume failed, drop it&#34;</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
								<span class="s">&#34;message&#34;</span><span class="p">:</span> <span class="nx">subMsgs</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span>
							<span class="p">})</span>
						<span class="p">}</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">msgs</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
							<span class="nx">msg</span> <span class="o">:=</span> <span class="nx">msgs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
							<span class="k">if</span> <span class="p">!</span><span class="nx">pc</span><span class="p">.</span><span class="nf">sendMessageBack</span><span class="p">(</span><span class="nx">mq</span><span class="p">.</span><span class="nx">BrokerName</span><span class="p">,</span> <span class="nx">msg</span><span class="p">,</span> <span class="nx">concurrentCtx</span><span class="p">.</span><span class="nx">DelayLevelWhenNextConsume</span><span class="p">)</span> <span class="p">{</span>
								<span class="nx">msg</span><span class="p">.</span><span class="nx">ReconsumeTimes</span> <span class="o">+=</span> <span class="mi">1</span>
								<span class="nx">msgBackFailed</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">msgBackFailed</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
							<span class="p">}</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="processqueue对象">ProcessQueue对象<a hidden class="anchor" aria-hidden="true" href="#processqueue对象">#</a></h1>
<p>在前面的源码中,有个 Process Queue类型的对象,这个对象的功能是什么呢?从Broker获得的消息,因为是提交到线程池里并行执行,很难监控和控制执行状态,比如如何获得当前消息堆积的数量,如何解决处理超时情况等。</p>
<p>RocketMQ定义了一个快照类 ProcessQueue来解决这些问题,在 PushConsumer运行的时候,每个 Message Queue都会有一个对应的 Process Queue对象,保存了这个 Message Queue消息处理状态的快照.</p>
<p>Process Queue对象里主要的内容是一个TreeMap和一个读写锁。TreeMap里以Message Queue的oset作为Key,以消息内容的引用为 Value,保存了所有从 MessageQueue获取到但是还未被处理的消息,读写锁控制着多个线程对TreeMap对象的并发访问。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">processQueue</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">cachedMsgCount</span>             <span class="kt">int64</span>
	<span class="nx">cachedMsgSize</span>              <span class="kt">int64</span>
	<span class="nx">tryUnlockTimes</span>             <span class="kt">int64</span>
	<span class="nx">queueOffsetMax</span>             <span class="kt">int64</span>
	<span class="nx">msgAccCnt</span>                  <span class="kt">int64</span>
	<span class="nx">msgCache</span>                   <span class="o">*</span><span class="nx">treemap</span><span class="p">.</span><span class="nx">Map</span>
	<span class="nx">mutex</span>                      <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
	<span class="nx">consumeLock</span>                <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">consumingMsgOrderlyTreeMap</span> <span class="o">*</span><span class="nx">treemap</span><span class="p">.</span><span class="nx">Map</span>
	<span class="nx">dropped</span>                    <span class="o">*</span><span class="nx">uatomic</span><span class="p">.</span><span class="nx">Bool</span>
	<span class="nx">lastPullTime</span>               <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
	<span class="nx">lastConsumeTime</span>            <span class="nx">atomic</span><span class="p">.</span><span class="nx">Value</span>
	<span class="nx">locked</span>                     <span class="o">*</span><span class="nx">uatomic</span><span class="p">.</span><span class="nx">Bool</span>
	<span class="nx">lastLockTime</span>               <span class="nx">atomic</span><span class="p">.</span><span class="nx">Value</span>
	<span class="nx">consuming</span>                  <span class="kt">bool</span>
	<span class="nx">lockConsume</span>                <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">msgCh</span>                      <span class="kd">chan</span> <span class="p">[]</span><span class="o">*</span><span class="nx">primitive</span><span class="p">.</span><span class="nx">MessageExt</span>
	<span class="nx">order</span>                      <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>有了 Process Queue对象,可以随时停止、启动消息的消费,同时也可用于帮助实现顺序消费消息。顺序消息是通过 ConsumeMessageOrderly实现的,主要流程和 ConsumeMessage Concurrently类似,区别只是在对并发消费的控制上.</p>
<h1 id="并发消费">并发消费<a hidden class="anchor" aria-hidden="true" href="#并发消费">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="p">(</span><span class="nx">pc</span> <span class="o">*</span><span class="nx">pushConsumer</span><span class="p">)</span> <span class="nf">consumeMessageCurrently</span><span class="p">(</span><span class="nx">pq</span> <span class="o">*</span><span class="nx">processQueue</span><span class="p">,</span> <span class="nx">mq</span> <span class="o">*</span><span class="nx">primitive</span><span class="p">.</span><span class="nx">MessageQueue</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">msgs</span> <span class="o">:=</span> <span class="nx">pq</span><span class="p">.</span><span class="nf">getMessages</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">msgs</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">count</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">msgs</span><span class="p">);</span> <span class="nx">count</span><span class="o">++</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">subMsgs</span> <span class="p">[]</span><span class="o">*</span><span class="nx">primitive</span><span class="p">.</span><span class="nx">MessageExt</span>
		<span class="k">if</span> <span class="nx">count</span><span class="o">+</span><span class="nx">pc</span><span class="p">.</span><span class="nx">option</span><span class="p">.</span><span class="nx">ConsumeMessageBatchMaxSize</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">msgs</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">subMsgs</span> <span class="p">=</span> <span class="nx">msgs</span><span class="p">[</span><span class="nx">count</span><span class="p">:]</span>
			<span class="nx">count</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">msgs</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">next</span> <span class="o">:=</span> <span class="nx">count</span> <span class="o">+</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">option</span><span class="p">.</span><span class="nx">ConsumeMessageBatchMaxSize</span>
			<span class="nx">subMsgs</span> <span class="p">=</span> <span class="nx">msgs</span><span class="p">[</span><span class="nx">count</span><span class="p">:</span><span class="nx">next</span><span class="p">]</span>
			<span class="nx">count</span> <span class="p">=</span> <span class="nx">next</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="p">}</span>
		<span class="k">go</span> <span class="nx">primitive</span><span class="p">.</span><span class="nf">WithRecover</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">RETRY</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">pq</span><span class="p">.</span><span class="nf">IsDroppd</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">rlog</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="s">&#34;the message queue not be able to consume, because it was dropped&#34;</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
					<span class="nx">rlog</span><span class="p">.</span><span class="nx">LogKeyMessageQueue</span><span class="p">:</span>  <span class="nx">mq</span><span class="p">.</span><span class="nf">String</span><span class="p">(),</span>
					<span class="nx">rlog</span><span class="p">.</span><span class="nx">LogKeyConsumerGroup</span><span class="p">:</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">consumerGroup</span><span class="p">,</span>
				<span class="p">})</span>
				<span class="k">return</span>
			<span class="p">}</span>

			<span class="nx">beginTime</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nf">resetRetryAndNamespace</span><span class="p">(</span><span class="nx">subMsgs</span><span class="p">)</span>
			<span class="kd">var</span> <span class="nx">result</span> <span class="nx">ConsumeResult</span>

			<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
			<span class="nx">msgCtx</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">primitive</span><span class="p">.</span><span class="nx">ConsumeMessageContext</span><span class="p">{</span>
				<span class="nx">Properties</span><span class="p">:</span>    <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
				<span class="nx">ConsumerGroup</span><span class="p">:</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">consumerGroup</span><span class="p">,</span>
				<span class="nx">MQ</span><span class="p">:</span>            <span class="nx">mq</span><span class="p">,</span>
				<span class="nx">Msgs</span><span class="p">:</span>          <span class="nx">msgs</span><span class="p">,</span>
			<span class="p">}</span>
			<span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">()</span>
			<span class="nx">ctx</span> <span class="p">=</span> <span class="nx">primitive</span><span class="p">.</span><span class="nf">WithConsumerCtx</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">msgCtx</span><span class="p">)</span>
			<span class="nx">ctx</span> <span class="p">=</span> <span class="nx">primitive</span><span class="p">.</span><span class="nf">WithMethod</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">primitive</span><span class="p">.</span><span class="nx">ConsumerPush</span><span class="p">)</span>
			<span class="nx">concurrentCtx</span> <span class="o">:=</span> <span class="nx">primitive</span><span class="p">.</span><span class="nf">NewConsumeConcurrentlyContext</span><span class="p">()</span>
			<span class="nx">concurrentCtx</span><span class="p">.</span><span class="nx">MQ</span> <span class="p">=</span> <span class="o">*</span><span class="nx">mq</span>
			<span class="nx">ctx</span> <span class="p">=</span> <span class="nx">primitive</span><span class="p">.</span><span class="nf">WithConcurrentlyCtx</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">concurrentCtx</span><span class="p">)</span>

			<span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">consumeInner</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">subMsgs</span><span class="p">)</span>

			<span class="nx">consumeRT</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">beginTime</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">msgCtx</span><span class="p">.</span><span class="nx">Properties</span><span class="p">[</span><span class="nx">primitive</span><span class="p">.</span><span class="nx">PropCtxType</span><span class="p">]</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">primitive</span><span class="p">.</span><span class="nx">ExceptionReturn</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">consumeRT</span> <span class="o">&gt;=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">option</span><span class="p">.</span><span class="nx">ConsumeTimeout</span> <span class="p">{</span>
				<span class="nx">msgCtx</span><span class="p">.</span><span class="nx">Properties</span><span class="p">[</span><span class="nx">primitive</span><span class="p">.</span><span class="nx">PropCtxType</span><span class="p">]</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">primitive</span><span class="p">.</span><span class="nx">TimeoutReturn</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">result</span> <span class="o">==</span> <span class="nx">ConsumeSuccess</span> <span class="p">{</span>
				<span class="nx">msgCtx</span><span class="p">.</span><span class="nx">Properties</span><span class="p">[</span><span class="nx">primitive</span><span class="p">.</span><span class="nx">PropCtxType</span><span class="p">]</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">primitive</span><span class="p">.</span><span class="nx">SuccessReturn</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">result</span> <span class="o">==</span> <span class="nx">ConsumeRetryLater</span> <span class="p">{</span>
				<span class="nx">msgCtx</span><span class="p">.</span><span class="nx">Properties</span><span class="p">[</span><span class="nx">primitive</span><span class="p">.</span><span class="nx">PropCtxType</span><span class="p">]</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">primitive</span><span class="p">.</span><span class="nx">FailedReturn</span><span class="p">)</span>
			<span class="p">}</span>

			<span class="nf">increaseConsumeRT</span><span class="p">(</span><span class="nx">pc</span><span class="p">.</span><span class="nx">consumerGroup</span><span class="p">,</span> <span class="nx">mq</span><span class="p">.</span><span class="nx">Topic</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">consumeRT</span><span class="o">/</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">))</span>

			<span class="k">if</span> <span class="p">!</span><span class="nx">pq</span><span class="p">.</span><span class="nf">IsDroppd</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">msgBackFailed</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">primitive</span><span class="p">.</span><span class="nx">MessageExt</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">result</span> <span class="o">==</span> <span class="nx">ConsumeSuccess</span> <span class="p">{</span>
					<span class="nf">increaseConsumeOKTPS</span><span class="p">(</span><span class="nx">pc</span><span class="p">.</span><span class="nx">consumerGroup</span><span class="p">,</span> <span class="nx">mq</span><span class="p">.</span><span class="nx">Topic</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">subMsgs</span><span class="p">))</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nf">increaseConsumeFailedTPS</span><span class="p">(</span><span class="nx">pc</span><span class="p">.</span><span class="nx">consumerGroup</span><span class="p">,</span> <span class="nx">mq</span><span class="p">.</span><span class="nx">Topic</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">subMsgs</span><span class="p">))</span>
					<span class="k">if</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">model</span> <span class="o">==</span> <span class="nx">BroadCasting</span> <span class="p">{</span>
						<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">msgs</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
							<span class="nx">rlog</span><span class="p">.</span><span class="nf">Warning</span><span class="p">(</span><span class="s">&#34;BROADCASTING, the message consume failed, drop it&#34;</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
								<span class="s">&#34;message&#34;</span><span class="p">:</span> <span class="nx">subMsgs</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span>
							<span class="p">})</span>
						<span class="p">}</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">msgs</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
							<span class="nx">msg</span> <span class="o">:=</span> <span class="nx">msgs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
							<span class="k">if</span> <span class="p">!</span><span class="nx">pc</span><span class="p">.</span><span class="nf">sendMessageBack</span><span class="p">(</span><span class="nx">mq</span><span class="p">.</span><span class="nx">BrokerName</span><span class="p">,</span> <span class="nx">msg</span><span class="p">,</span> <span class="nx">concurrentCtx</span><span class="p">.</span><span class="nx">DelayLevelWhenNextConsume</span><span class="p">)</span> <span class="p">{</span>
								<span class="nx">msg</span><span class="p">.</span><span class="nx">ReconsumeTimes</span> <span class="o">+=</span> <span class="mi">1</span>
								<span class="nx">msgBackFailed</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">msgBackFailed</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
							<span class="p">}</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>

				<span class="nx">offset</span> <span class="o">:=</span> <span class="nx">pq</span><span class="p">.</span><span class="nf">removeMessage</span><span class="p">(</span><span class="nx">subMsgs</span><span class="o">...</span><span class="p">)</span>

				<span class="k">if</span> <span class="nx">offset</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">pq</span><span class="p">.</span><span class="nf">IsDroppd</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">pc</span><span class="p">.</span><span class="nx">storage</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="nx">mq</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">offset</span><span class="p">),</span> <span class="kc">true</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">msgBackFailed</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="nx">subMsgs</span> <span class="p">=</span> <span class="nx">msgBackFailed</span>
					<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
					<span class="k">goto</span> <span class="nx">RETRY</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">rlog</span><span class="p">.</span><span class="nf">Warning</span><span class="p">(</span><span class="s">&#34;processQueue is dropped without process consume result.&#34;</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
					<span class="nx">rlog</span><span class="p">.</span><span class="nx">LogKeyMessageQueue</span><span class="p">:</span> <span class="nx">mq</span><span class="p">,</span>
					<span class="s">&#34;message&#34;</span><span class="p">:</span>               <span class="nx">msgs</span><span class="p">,</span>
				<span class="p">})</span>
			<span class="p">}</span>
		<span class="p">})</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="顺序消费">顺序消费<a hidden class="anchor" aria-hidden="true" href="#顺序消费">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">pc</span> <span class="o">*</span><span class="nx">pushConsumer</span><span class="p">)</span> <span class="nf">consumeMessageOrderly</span><span class="p">(</span><span class="nx">pq</span> <span class="o">*</span><span class="nx">processQueue</span><span class="p">,</span> <span class="nx">mq</span> <span class="o">*</span><span class="nx">primitive</span><span class="p">.</span><span class="nx">MessageQueue</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">pq</span><span class="p">.</span><span class="nf">IsDroppd</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">rlog</span><span class="p">.</span><span class="nf">Warning</span><span class="p">(</span><span class="s">&#34;the message queue not be able to consume, because it&#39;s dropped.&#34;</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
			<span class="nx">rlog</span><span class="p">.</span><span class="nx">LogKeyMessageQueue</span><span class="p">:</span> <span class="nx">mq</span><span class="p">.</span><span class="nf">String</span><span class="p">(),</span>
		<span class="p">})</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">lock</span> <span class="o">:=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">queueLock</span><span class="p">.</span><span class="nf">fetchLock</span><span class="p">(</span><span class="o">*</span><span class="nx">mq</span><span class="p">)</span>
	<span class="nx">lock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">model</span> <span class="o">==</span> <span class="nx">BroadCasting</span> <span class="o">||</span> <span class="p">(</span><span class="nx">pq</span><span class="p">.</span><span class="nf">IsLock</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">pq</span><span class="p">.</span><span class="nf">isLockExpired</span><span class="p">())</span> <span class="p">{</span>
		<span class="nx">beginTime</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>

		<span class="nx">continueConsume</span> <span class="o">:=</span> <span class="kc">true</span>
		<span class="k">for</span> <span class="nx">continueConsume</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">pq</span><span class="p">.</span><span class="nf">IsDroppd</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">rlog</span><span class="p">.</span><span class="nf">Warning</span><span class="p">(</span><span class="s">&#34;the message queue not be able to consume, because it&#39;s dropped.&#34;</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
					<span class="nx">rlog</span><span class="p">.</span><span class="nx">LogKeyMessageQueue</span><span class="p">:</span> <span class="nx">mq</span><span class="p">.</span><span class="nf">String</span><span class="p">(),</span>
				<span class="p">})</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">model</span> <span class="o">==</span> <span class="nx">Clustering</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">!</span><span class="nx">pq</span><span class="p">.</span><span class="nf">IsLock</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">rlog</span><span class="p">.</span><span class="nf">Warning</span><span class="p">(</span><span class="s">&#34;the message queue not locked, so consume later&#34;</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
						<span class="nx">rlog</span><span class="p">.</span><span class="nx">LogKeyMessageQueue</span><span class="p">:</span> <span class="nx">mq</span><span class="p">.</span><span class="nf">String</span><span class="p">(),</span>
					<span class="p">})</span>
					<span class="nx">pc</span><span class="p">.</span><span class="nf">tryLockLaterAndReconsume</span><span class="p">(</span><span class="nx">mq</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
					<span class="k">return</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">pq</span><span class="p">.</span><span class="nf">isLockExpired</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">rlog</span><span class="p">.</span><span class="nf">Warning</span><span class="p">(</span><span class="s">&#34;the message queue lock expired, so consume later&#34;</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
						<span class="nx">rlog</span><span class="p">.</span><span class="nx">LogKeyMessageQueue</span><span class="p">:</span> <span class="nx">mq</span><span class="p">.</span><span class="nf">String</span><span class="p">(),</span>
					<span class="p">})</span>
					<span class="nx">pc</span><span class="p">.</span><span class="nf">tryLockLaterAndReconsume</span><span class="p">(</span><span class="nx">mq</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
					<span class="k">return</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="nx">interval</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">beginTime</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">interval</span> <span class="p">&gt;</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">option</span><span class="p">.</span><span class="nx">MaxTimeConsumeContinuously</span> <span class="p">{</span>
				<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="nx">batchSize</span> <span class="o">:=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">option</span><span class="p">.</span><span class="nx">ConsumeMessageBatchMaxSize</span>
			<span class="nx">msgs</span> <span class="o">:=</span> <span class="nx">pq</span><span class="p">.</span><span class="nf">takeMessages</span><span class="p">(</span><span class="nx">batchSize</span><span class="p">)</span>

			<span class="nx">pc</span><span class="p">.</span><span class="nf">resetRetryAndNamespace</span><span class="p">(</span><span class="nx">msgs</span><span class="p">)</span>

			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">msgs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">continueConsume</span> <span class="p">=</span> <span class="kc">false</span>
				<span class="k">break</span>
			<span class="p">}</span>

			<span class="c1">// TODO: add message consumer hook
</span><span class="c1"></span>			<span class="nx">beginTime</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>

			<span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">()</span>
			<span class="nx">msgCtx</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">primitive</span><span class="p">.</span><span class="nx">ConsumeMessageContext</span><span class="p">{</span>
				<span class="nx">Properties</span><span class="p">:</span>    <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
				<span class="nx">ConsumerGroup</span><span class="p">:</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">consumerGroup</span><span class="p">,</span>
				<span class="nx">MQ</span><span class="p">:</span>            <span class="nx">mq</span><span class="p">,</span>
				<span class="nx">Msgs</span><span class="p">:</span>          <span class="nx">msgs</span><span class="p">,</span>
			<span class="p">}</span>
			<span class="nx">ctx</span> <span class="p">=</span> <span class="nx">primitive</span><span class="p">.</span><span class="nf">WithConsumerCtx</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">msgCtx</span><span class="p">)</span>
			<span class="nx">ctx</span> <span class="p">=</span> <span class="nx">primitive</span><span class="p">.</span><span class="nf">WithMethod</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">primitive</span><span class="p">.</span><span class="nx">ConsumerPush</span><span class="p">)</span>

			<span class="nx">orderlyCtx</span> <span class="o">:=</span> <span class="nx">primitive</span><span class="p">.</span><span class="nf">NewConsumeOrderlyContext</span><span class="p">()</span>
			<span class="nx">orderlyCtx</span><span class="p">.</span><span class="nx">MQ</span> <span class="p">=</span> <span class="o">*</span><span class="nx">mq</span>
			<span class="nx">ctx</span> <span class="p">=</span> <span class="nx">primitive</span><span class="p">.</span><span class="nf">WithOrderlyCtx</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">orderlyCtx</span><span class="p">)</span>

			<span class="nx">pq</span><span class="p">.</span><span class="nx">lockConsume</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
			<span class="nx">result</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">consumeInner</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">msgs</span><span class="p">)</span>
			<span class="nx">pq</span><span class="p">.</span><span class="nx">lockConsume</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

			<span class="k">if</span> <span class="nx">result</span> <span class="o">==</span> <span class="nx">Rollback</span> <span class="o">||</span> <span class="nx">result</span> <span class="o">==</span> <span class="nx">SuspendCurrentQueueAMoment</span> <span class="p">{</span>
				<span class="nx">rlog</span><span class="p">.</span><span class="nf">Warning</span><span class="p">(</span><span class="s">&#34;consumeMessage Orderly return not OK&#34;</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
					<span class="nx">rlog</span><span class="p">.</span><span class="nx">LogKeyConsumerGroup</span><span class="p">:</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">consumerGroup</span><span class="p">,</span>
					<span class="s">&#34;messages&#34;</span><span class="p">:</span>               <span class="nx">msgs</span><span class="p">,</span>
					<span class="nx">rlog</span><span class="p">.</span><span class="nx">LogKeyMessageQueue</span><span class="p">:</span>  <span class="nx">mq</span><span class="p">,</span>
				<span class="p">})</span>
			<span class="p">}</span>

			<span class="c1">// jsut put consumeResult in consumerMessageCtx
</span><span class="c1"></span>			<span class="c1">//interval = time.Now().Sub(beginTime)
</span><span class="c1"></span>			<span class="c1">//consumeReult := SuccessReturn
</span><span class="c1"></span>			<span class="c1">//if interval &gt; pc.option.ConsumeTimeout {
</span><span class="c1"></span>			<span class="c1">//	consumeReult = TimeoutReturn
</span><span class="c1"></span>			<span class="c1">//} else if SuspendCurrentQueueAMoment == result {
</span><span class="c1"></span>			<span class="c1">//	consumeReult = FailedReturn
</span><span class="c1"></span>			<span class="c1">//} else if ConsumeSuccess == result {
</span><span class="c1"></span>			<span class="c1">//	consumeReult = SuccessReturn
</span><span class="c1"></span>			<span class="c1">//}
</span><span class="c1"></span>
			<span class="c1">// process result
</span><span class="c1"></span>			<span class="nx">commitOffset</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">option</span><span class="p">.</span><span class="nx">AutoCommit</span> <span class="p">{</span>
				<span class="k">switch</span> <span class="nx">result</span> <span class="p">{</span>
				<span class="k">case</span> <span class="nx">Commit</span><span class="p">,</span> <span class="nx">Rollback</span><span class="p">:</span>
					<span class="nx">rlog</span><span class="p">.</span><span class="nf">Warning</span><span class="p">(</span><span class="s">&#34;the message queue consume result is illegal, we think you want to ack these message: %v&#34;</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
						<span class="nx">rlog</span><span class="p">.</span><span class="nx">LogKeyMessageQueue</span><span class="p">:</span> <span class="nx">mq</span><span class="p">,</span>
					<span class="p">})</span>
				<span class="k">case</span> <span class="nx">ConsumeSuccess</span><span class="p">:</span>
					<span class="nx">commitOffset</span> <span class="p">=</span> <span class="nx">pq</span><span class="p">.</span><span class="nf">commit</span><span class="p">()</span>
				<span class="k">case</span> <span class="nx">SuspendCurrentQueueAMoment</span><span class="p">:</span>
					<span class="k">if</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">checkReconsumeTimes</span><span class="p">(</span><span class="nx">msgs</span><span class="p">)</span> <span class="p">{</span>
						<span class="nx">pq</span><span class="p">.</span><span class="nf">putMessage</span><span class="p">(</span><span class="nx">msgs</span><span class="o">...</span><span class="p">)</span>
						<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">orderlyCtx</span><span class="p">.</span><span class="nx">SuspendCurrentQueueTimeMillis</span><span class="p">)</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
						<span class="nx">continueConsume</span> <span class="p">=</span> <span class="kc">false</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="nx">commitOffset</span> <span class="p">=</span> <span class="nx">pq</span><span class="p">.</span><span class="nf">commit</span><span class="p">()</span>
					<span class="p">}</span>
				<span class="k">default</span><span class="p">:</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">switch</span> <span class="nx">result</span> <span class="p">{</span>
				<span class="k">case</span> <span class="nx">ConsumeSuccess</span><span class="p">:</span>
				<span class="k">case</span> <span class="nx">Commit</span><span class="p">:</span>
					<span class="nx">commitOffset</span> <span class="p">=</span> <span class="nx">pq</span><span class="p">.</span><span class="nf">commit</span><span class="p">()</span>
				<span class="k">case</span> <span class="nx">Rollback</span><span class="p">:</span>
					<span class="c1">// pq.rollback
</span><span class="c1"></span>					<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">orderlyCtx</span><span class="p">.</span><span class="nx">SuspendCurrentQueueTimeMillis</span><span class="p">)</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
					<span class="nx">continueConsume</span> <span class="p">=</span> <span class="kc">false</span>
				<span class="k">case</span> <span class="nx">SuspendCurrentQueueAMoment</span><span class="p">:</span>
					<span class="k">if</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">checkReconsumeTimes</span><span class="p">(</span><span class="nx">msgs</span><span class="p">)</span> <span class="p">{</span>
						<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">orderlyCtx</span><span class="p">.</span><span class="nx">SuspendCurrentQueueTimeMillis</span><span class="p">)</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
						<span class="nx">continueConsume</span> <span class="p">=</span> <span class="kc">false</span>
					<span class="p">}</span>
				<span class="k">default</span><span class="p">:</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">commitOffset</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">pq</span><span class="p">.</span><span class="nf">IsDroppd</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">_</span> <span class="p">=</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">updateOffset</span><span class="p">(</span><span class="nx">mq</span><span class="p">,</span> <span class="nx">commitOffset</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">pq</span><span class="p">.</span><span class="nf">IsDroppd</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">rlog</span><span class="p">.</span><span class="nf">Warning</span><span class="p">(</span><span class="s">&#34;the message queue not be able to consume, because it&#39;s dropped.&#34;</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
				<span class="nx">rlog</span><span class="p">.</span><span class="nx">LogKeyMessageQueue</span><span class="p">:</span> <span class="nx">mq</span><span class="p">.</span><span class="nf">String</span><span class="p">(),</span>
			<span class="p">})</span>
		<span class="p">}</span>
		<span class="nx">pc</span><span class="p">.</span><span class="nf">tryLockLaterAndReconsume</span><span class="p">(</span><span class="nx">mq</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/rocketmq/">rocketmq</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
