<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>父子进程的联系 | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="两者联系 子进程得到父进程的数据空间，堆和栈的副本，但是两者是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程">
<meta name="author" content="">
<link rel="canonical" href="/post/%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%81%94%E7%B3%BB/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="父子进程的联系" />
<meta property="og:description" content="两者联系 子进程得到父进程的数据空间，堆和栈的副本，但是两者是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%81%94%E7%B3%BB/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-25T14:22:23&#43;00:00" />
<meta property="article:modified_time" content="2017-06-25T14:22:23&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="父子进程的联系"/>
<meta name="twitter:description" content="两者联系 子进程得到父进程的数据空间，堆和栈的副本，但是两者是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "父子进程的联系",
      "item": "/post/%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%81%94%E7%B3%BB/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "父子进程的联系",
  "name": "父子进程的联系",
  "description": "两者联系 子进程得到父进程的数据空间，堆和栈的副本，但是两者是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程",
  "keywords": [
    
  ],
  "articleBody": "两者联系 子进程得到父进程的数据空间，堆和栈的副本，但是两者是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同，也就是说，子进程是从fork返回处开始执行的），但有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。\n由子进程自父进程继承到：   进程的资格(真实(real)/有效(effective)/已保存(saved)用户号(UIDs)和组号(GIDs))\n  环境(environment) 子进程复制的不仅是父进程的代码和数据，还包括状态，这个状态就包含有PC指针寄存器的值。也就是说子进程创建完成后，他和父进程一样，PC指针都指向下一条语句，因此子进程是从自身创建完成后的地方继续运行，而父进程运行过得代码将不再运行。\n  堆栈\n  内存\n  打开文件的描述符(注意对应的文件的位置由父子进程共享，这会引起含糊情况)\n  执行时关闭(close-on-exec) 标志 (译者注：close-on-exec标志可通过fnctl()对文件描述符设置，POSIX.1要求所有目录流都必须在exec函数调用时关闭。更详细说明，参见《UNIX环境高级编程》 W. R. Stevens, 1993, 尤晋元等译(以下简称《高级编程》), 3.13节和8.9节)\n  信号(signal)控制设定\n  nice值 (译者注：nice值由nice函数设定，该值表示进程的优先级，数值越小，优先级越高)\n  进程调度类别(scheduler class)(译者注：进程调度类别指进程在系统中被调度时所属的类别，不同类别有不同优先级，根据进程调度类别和nice值，进程调度程序可计算出每个进程的全局优先级(Global process prority)，优先级高的进程优先执行)\n  进程组号\n  对话期ID(Session ID) (译者注：译文取自《高级编程》，指：进程所属的对话期(session)ID， 一个对话期包括一个或多个进程组， 更详细说明参见《高级编程》9.5节)\n  当前工作目录\n  根目录 (译者注：根目录不一定是“/”，它可由chroot函数改变)\n  文件方式创建屏蔽字(file mode creation mask (umask))(译者注：译文取自《高级编程》，指：创建新文件的缺省屏蔽字)\n  资源限制\n  控制终端\n  注意：\n  Linux系统中采用“写时拷贝”的技术，创建进程时，父子共享同一个地址空间，在需要写入的时候才进行地址空间的复制。\n  打开的文件描述符在父子进程之间是共享的。当close一个文件描述符时候会将文件描述符的引用计数-1。只有当引用计数为0才能真正关闭该文件描述符；\n  子进程所独有：   fork的返回值\n  进程ID\n  不同的父进程ID\n  子进程的tms_utime,tms_stime,tms_cutime以及tms_ustime设置为0\n  父进程设置的锁，子进程不继承\n  子进程的未决告警被清除\n  子进程的未决信号集设置为空集\n  特别注意 程序中fork与I/O函数之间的关系 write是不带缓冲的，因为在fork之前调⽤用write，所以其数据只写到标准输出一次。\n标准I/O是缓冲的，如果标准输出到终端设备，则它是行缓冲，否则它是全缓冲。\n当以交互方式运行该程序时，只得到printf输出的⾏一次，因为标准输出到终端缓冲区由换⾏行符冲洗。\n将标准输出重定向到⼀个文件时，由于缓冲区是全缓冲，遇到换⾏行符不输出，当调用fork时，其printf的数据仍然在缓冲区中，缓冲区被复制到子进程中。于是父⼦进程都有了带该行内容的标准I/O缓冲区，所以每个进程终⽌时，会冲洗其缓冲区中的数据，得到一个printf输出两次。\n子进程会影响父进程的变量 不同的进程使用不同的地址空间，子进程被创建之后，父进程的全局变量、静态变量和 fork 处的静态变量会复制到子进程的地址空间中，自此以后，二者开始“各行其是”，互不干扰，所以，所有的“变量”都将各自独立。而对于指针来说，虽然复制过，指针做为“变量”已经互不干扰，但是你在进行指针操作的时候，会通过物理地址的映射反映到父进程当中。\n",
  "wordCount" : "1663",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-25T14:22:23Z",
  "dateModified": "2017-06-25T14:22:23Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%81%94%E7%B3%BB/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      父子进程的联系
    </h1>
    <div class="post-meta">June 25, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="两者联系">两者联系<a hidden class="anchor" aria-hidden="true" href="#两者联系">#</a></h1>
<p>子进程得到父进程的数据空间，堆和栈的副本，但是两者是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同，也就是说，子进程是从fork返回处开始执行的），但有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。</p>
<h1 id="由子进程自父进程继承到">由子进程自父进程继承到：<a hidden class="anchor" aria-hidden="true" href="#由子进程自父进程继承到">#</a></h1>
<ol>
<li>
<p>进程的资格(真实(real)/有效(effective)/已保存(saved)用户号(UIDs)和组号(GIDs))</p>
</li>
<li>
<p>环境(environment)
子进程复制的不仅是父进程的代码和数据，还包括状态，这个状态就包含有PC指针寄存器的值。也就是说子进程创建完成后，他和父进程一样，PC指针都指向下一条语句，因此子进程是从自身创建完成后的地方继续运行，而父进程运行过得代码将不再运行。</p>
</li>
<li>
<p>堆栈</p>
</li>
<li>
<p>内存</p>
</li>
<li>
<p>打开文件的描述符(注意对应的文件的位置由父子进程共享，这会引起含糊情况)</p>
</li>
<li>
<p>执行时关闭(close-on-exec) 标志 (译者注：close-on-exec标志可通过fnctl()对文件描述符设置，POSIX.1要求所有目录流都必须在exec函数调用时关闭。更详细说明，参见《UNIX环境高级编程》 W. R. Stevens, 1993, 尤晋元等译(以下简称《高级编程》), 3.13节和8.9节)</p>
</li>
<li>
<p>信号(signal)控制设定</p>
</li>
<li>
<p>nice值 (译者注：nice值由nice函数设定，该值表示进程的优先级，数值越小，优先级越高)</p>
</li>
<li>
<p>进程调度类别(scheduler class)(译者注：进程调度类别指进程在系统中被调度时所属的类别，不同类别有不同优先级，根据进程调度类别和nice值，进程调度程序可计算出每个进程的全局优先级(Global process prority)，优先级高的进程优先执行)</p>
</li>
<li>
<p>进程组号</p>
</li>
<li>
<p>对话期ID(Session ID) (译者注：译文取自《高级编程》，指：进程所属的对话期(session)ID， 一个对话期包括一个或多个进程组， 更详细说明参见《高级编程》9.5节)</p>
</li>
<li>
<p>当前工作目录</p>
</li>
<li>
<p>根目录 (译者注：根目录不一定是“/”，它可由chroot函数改变)</p>
</li>
<li>
<p>文件方式创建屏蔽字(file mode creation mask (umask))(译者注：译文取自《高级编程》，指：创建新文件的缺省屏蔽字)</p>
</li>
<li>
<p>资源限制</p>
</li>
<li>
<p>控制终端</p>
</li>
</ol>
<p>注意：</p>
<ol>
<li>
<p>Linux系统中采用“写时拷贝”的技术，创建进程时，父子共享同一个地址空间，在需要写入的时候才进行地址空间的复制。</p>
</li>
<li>
<p>打开的文件描述符在父子进程之间是共享的。当close一个文件描述符时候会将文件描述符的引用计数-1。只有当引用计数为0才能真正关闭该文件描述符；</p>
</li>
</ol>
<h1 id="子进程所独有">子进程所独有：<a hidden class="anchor" aria-hidden="true" href="#子进程所独有">#</a></h1>
<ol>
<li>
<p>fork的返回值</p>
</li>
<li>
<p>进程ID</p>
</li>
<li>
<p>不同的父进程ID</p>
</li>
<li>
<p>子进程的tms_utime,tms_stime,tms_cutime以及tms_ustime设置为0</p>
</li>
<li>
<p>父进程设置的锁，子进程不继承</p>
</li>
<li>
<p>子进程的未决告警被清除</p>
</li>
<li>
<p>子进程的未决信号集设置为空集</p>
</li>
</ol>
<h1 id="特别注意">特别注意<a hidden class="anchor" aria-hidden="true" href="#特别注意">#</a></h1>
<h2 id="程序中fork与io函数之间的关系">程序中fork与I/O函数之间的关系<a hidden class="anchor" aria-hidden="true" href="#程序中fork与io函数之间的关系">#</a></h2>
<p>write是不带缓冲的，因为在fork之前调⽤用write，所以其数据只写到标准输出一次。</p>
<p>标准I/O是缓冲的，如果标准输出到终端设备，则它是行缓冲，否则它是全缓冲。</p>
<p>当以交互方式运行该程序时，只得到printf输出的⾏一次，因为标准输出到终端缓冲区由换⾏行符冲洗。</p>
<p>将标准输出重定向到⼀个文件时，由于缓冲区是全缓冲，遇到换⾏行符不输出，当调用fork时，其printf的数据仍然在缓冲区中，缓冲区被复制到子进程中。于是父⼦进程都有了带该行内容的标准I/O缓冲区，所以每个进程终⽌时，会冲洗其缓冲区中的数据，得到一个printf输出两次。</p>
<h2 id="子进程会影响父进程的变量">子进程会影响父进程的变量<a hidden class="anchor" aria-hidden="true" href="#子进程会影响父进程的变量">#</a></h2>
<p>不同的进程使用不同的地址空间，子进程被创建之后，父进程的全局变量、静态变量和 fork 处的静态变量会复制到子进程的地址空间中，自此以后，二者开始“各行其是”，互不干扰，所以，所有的“变量”都将各自独立。而对于指针来说，虽然复制过，指针做为“变量”已经互不干扰，但是你在进行指针操作的时候，会通过物理地址的映射反映到父进程当中。</p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
