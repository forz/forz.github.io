<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go中unsafe使用实践 | Forz Blog</title>
<meta name="keywords" content="Go" />
<meta name="description" content="指针类型 在正式介绍 unsafe 包之前，需要着重介绍 Go 语言中的指针类型。 举一个例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import &#34;fmt&#34; func double(x int) { x &#43;= x } func main() { var a = 3 double(a) fmt.Println(a)">
<meta name="author" content="">
<link rel="canonical" href="/post/go%E4%B8%ADunsafe%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Go中unsafe使用实践" />
<meta property="og:description" content="指针类型 在正式介绍 unsafe 包之前，需要着重介绍 Go 语言中的指针类型。 举一个例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import &#34;fmt&#34; func double(x int) { x &#43;= x } func main() { var a = 3 double(a) fmt.Println(a)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E4%B8%ADunsafe%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2018-11-27T19:58:06&#43;00:00" />
<meta property="article:modified_time" content="2018-11-27T19:58:06&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go中unsafe使用实践"/>
<meta name="twitter:description" content="指针类型 在正式介绍 unsafe 包之前，需要着重介绍 Go 语言中的指针类型。 举一个例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import &#34;fmt&#34; func double(x int) { x &#43;= x } func main() { var a = 3 double(a) fmt.Println(a)"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Go中unsafe使用实践",
      "item": "/post/go%E4%B8%ADunsafe%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go中unsafe使用实践",
  "name": "Go中unsafe使用实践",
  "description": "指针类型 在正式介绍 unsafe 包之前，需要着重介绍 Go 语言中的指针类型。 举一个例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; func double(x int) { x += x } func main() { var a = 3 double(a) fmt.Println(a)",
  "keywords": [
    "Go"
  ],
  "articleBody": "指针类型 在正式介绍 unsafe 包之前，需要着重介绍 Go 语言中的指针类型。\n举一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13  package main import \"fmt\" func double(x int) { x += x } func main() { var a = 3 double(a) fmt.Println(a) // 3 }   非常简单，我想在 double 函数里将 a 翻倍，但是例子中的函数却做不到。为什么？因为 Go 语言的函数传参都是值传递。double 函数里的 x 只是实参 a 的一个拷贝，在函数内部对 x 的操作不能反馈到实参 a。\n如果这时，有一个指针就可以解决问题了！这也是我们常用的“伎俩”。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  package main import \"fmt\" func double(x *int) { *x += *x x = nil } func main() { var a = 3 double(\u0026a) fmt.Println(a) // 6  p := \u0026a double(p) fmt.Println(a, p == nil) // 12 false }   很常规的操作，不用多解释。唯一可能有些疑惑的在这一句：\n1  x = nil   这得稍微思考一下，才能得出这一行代码根本不影响的结论。因为是值传递，所以 x 也只是对 \u0026a 的一个拷贝。\n1  *x += *x   这一句把 x 指向的值（也就是 \u0026a 指向的值，即变量 a）变为原来的 2 倍。但是对 x 本身（一个指针）的操作却不会影响外层的 a，所以 x = nil 掀不起任何大风大浪。\n下面的这张图可以“自证清白”：\n然而，相比于 C 语言中指针的灵活，Go 的指针多了一些限制。但这也算是 Go 的成功之处：既可以享受指针带来的便利，又避免了指针的危险性。\n限制一：Go 的指针不能进行数学运算。\n来看一个简单的例子：\n1 2 3 4 5  a := 5 p := \u0026a p++ p = \u0026a + 3   上面的代码将不能通过编译，会报编译错误：invalid operation，也就是说不能对指针做数学运算。\n限制二：不同类型的指针不能相互转换。\n例如下面这个简短的例子：\n1 2 3 4 5 6  func main() { a := int(100) var f *float64 f = \u0026a }   也会报编译错误：\n1  cannot use \u0026a (type *int) as type *float64 in assignment   限制三：不同类型的指针不能使用 == 或 != 比较。\n只有在两个指针类型相同或者可以相互转换的情况下，才可以对两者进行比较。另外，指针可以通过 == 和 != 直接和 nil 作比较。\n限制四：不同类型的指针变量不能相互赋值。\n这一点同限制三。\n什么是 unsafe 前面所说的指针是类型安全的，但它有很多限制。Go 还有非类型安全的指针，这就是 unsafe 包提供的 unsafe.Pointer。在某些情况下，它会使代码更高效，当然，也更危险。\nunsafe 包用于 Go 编译器，在编译阶段使用。从名字就可以看出来，它是不安全的，官方并不建议使用。我在用 unsafe 包的时候会有一种不舒服的感觉，可能这也是语言设计者的意图吧。\n但是高阶的 Gopher，怎么能不会使用 unsafe 包呢？它可以绕过 Go 语言的类型系统，直接操作内存。例如，一般我们不能操作一个结构体的未导出成员，但是通过 unsafe 包就能做到。unsafe 包让我可以直接读写内存，还管你什么导出还是未导出。\n为什么有 unsafe Go 语言类型系统是为了安全和效率设计的，有时，安全会导致效率低下。有了 unsafe 包，高阶的程序员就可以利用它绕过类型系统的低效。因此，它就有了存在的意义，阅读 Go 源码，会发现有大量使用 unsafe 包的例子。\nunsafe 实现原理\n我们来看源码：\n1 2 3  type ArbitraryType int type Pointer *ArbitraryType   从命名来看，Arbitrary 是任意的意思，也就是说 Pointer 可以指向任意类型，实际上它类似于 C 语言里的 void*。\nunsafe 包还有其他三个函数：\n1 2 3  func Sizeof(x ArbitraryType) uintptr func Offsetof(x ArbitraryType) uintptr func Alignof(x ArbitraryType) uintptr    Sizeof 返回类型 x 所占据的字节数，但不包含 x 所指向的内容的大小。例如，对于一个指针，函数返回的大小为 8 字节（64位机上），一个 slice 的大小则为 slice header 的大小。 Offsetof 返回结构体成员在内存中的位置离结构体起始处的字节数，所传参数必须是结构体的成员。 Alignof 返回 m，m 是指当类型进行内存对齐时，它分配到的内存地址能整除 m。  uintptr与unsafe.Pointer 注意到以上三个函数返回的结果都是 uintptr 类型，这和 unsafe.Pointer 可以相互转换。三个函数都是在编译期间执行，它们的结果可以直接赋给 const 型变量。另外，因为三个函数执行的结果和操作系统、编译器相关，所以是不可移植的。\n综上所述，unsafe 包提供了 2 点重要的能力：\n 任何类型的指针和 unsafe.Pointer 可以相互转换。 uintptr 类型和 unsafe.Pointer 可以相互转换。  pointer 不能直接进行数学运算，但可以把它转换成 uintptr，对 uintptr 类型进行数学运算，再转换成 pointer 类型。\n1 2  // uintptr 是一个整数类型，它足够大，可以存储 type uintptr uintptr   unsafe.Pointer在Golang中是用于各种类型转化的桥梁，Pointer代表了一个指向任意类型的指针。uintptr是Golang的内置类型，是能存储指针的整型，uintptr的底层类型是int，它和unsafe.Pointer可相互转换。\nPointer与uintptr的区别在于：\n unsafe.Pointer只是一个指针的类型，但是不能像C中的指针那样作计算，而只能用于转化不同类型的指针；如果unsafe.Pointer变量仍然有效，则由unsafe.Pointer变量表示的地址处的数据不会被GC回收； uintptr是可以用于指针运算的，但是无法持有对象，GC并不把uintptr当做指针，所以uintptr类型的目标会被回收。  在Golang中出于安全的原因，不允许两个不同指针类型的值去直接转换；也不允许指针类型和uintptr的值去直接转换。但是借助unsafe.Pointer，我们\n 任何类型的指针值都可以转换为unsafe.Pointer； unsafe.Pointer可以转换为任何类型的指针值； uintptr可以转换为unsafe.Pointer； unsafe.Pointer可以转换为uintptr。  unsafe 包中的几个函数都是在编译期间执行完毕，毕竟，编译器对内存分配这些操作“了然于胸”。在 /usr/local/go/src/cmd/compile/internal/gc/unsafe.go 路径下，可以看到编译期间 Go 对 unsafe 包中函数的处理。\n强制类型转换 在此之前提示一下这里我们说的类型的转化，是转化前后变量为同一变量，而不是这样为两个变量：\n1 2 3 4 5 6  func main() { var a int64 = 3 var b float64 = float64(a) fmt.Println(\u0026a) // 0xc42000e248  fmt.Println(\u0026b) // 0xc42000e250 }   如果我们要来做一个强制的转化的话，a = float64(a),Golang会报错：cannot use float64(a) (type float64) as type int64 in assignment。\n使用unsafe.Pointer来将T1转化为T2，一个大致的语法为*(*T2)(unsafe.Pointer(\u0026t1))\n1 2 3 4 5 6 7 8 9 10 11  func main() { var n int64 = 3 var pn = \u0026n // n的指针  var pf = (*float64)(unsafe.Pointer(pn)) // 通过Pointer来将n的类型转为float  fmt.Println(*pf) // 2.5e-323  *pf = 3.5 fmt.Println(n) // 4615063718147915776  fmt.Println(pf) // 0xc42007a050  fmt.Println(pn) // 0xc42007a050 }   这个例子虽然没有实际的意义，但是绕过了Golang类型系统和内存安全，将一个变量的类型作了转化。\n修改结构体私有成员 我们知道在Golang中指针是不能用来计算的，但是借助uintptr我们可以作计算：\n1 2 3 4 5 6 7  func main() { a := [4]int{0, 1, 2, 3} p1 := unsafe.Pointer(\u0026a[1]) // index为1的元素  p3 := unsafe.Pointer(uintptr(p1) + 2 * unsafe.Sizeof(a[0])) // 拿到index为3的指针  *(*int)(p3) = 4 // 重新赋值  fmt.Println(a) // a = [0 1 2 4] }   对于一个结构体，通过 offset 函数可以获取结构体成员的偏移量，进而获取成员的地址，读写该地址的内存，就可以达到改变成员值的目的。\n这里有一个内存分配相关的事实：结构体会被分配一块连续的内存，结构体的地址也代表了第一个成员的地址。\n我们来看一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  package main import ( \"fmt\" \"unsafe\" ) type Programmer struct { name string language string } func main() { p := Programmer{\"stefno\", \"go\"} fmt.Println(p) name := (*string)(unsafe.Pointer(\u0026p)) *name = \"qcrao\" lang := (*string)(unsafe.Pointer(uintptr(unsafe.Pointer(\u0026p)) + unsafe.Offsetof(p.language))) *lang = \"Golang\" fmt.Println(p) }   运行代码，输出：\n1 2  {stefno go} {qcrao Golang}   name 是结构体的第一个成员，因此可以直接将 \u0026p 解析成 *string。这一点，在前面获取 map 的 count 成员时，用的是同样的原理。\n对于结构体的私有成员，现在有办法可以通过 unsafe.Pointer 改变它的值了。\n我把 Programmer 结构体升级，多加一个字段：\n1 2 3 4 5  type Programmer struct { name string age int language string }   并且放在其他包，这样在 main 函数中，它的三个字段都是私有成员变量，不能直接修改。但我通过 unsafe.Sizeof() 函数可以获取成员大小，进而计算出成员的地址，直接修改内存。\n1 2 3 4 5 6 7 8 9  func main() { p := Programmer{\"stefno\", 18, \"go\"} fmt.Println(p) lang := (*string)(unsafe.Pointer(uintptr(unsafe.Pointer(\u0026p)) + unsafe.Sizeof(int(0)) + unsafe.Sizeof(string(\"\")))) *lang = \"Golang\" fmt.Println(p) }   输出：\n1 2  {stefno 18 go} {stefno 18 Golang}   string与[]byte相互转换 我们在写程序的时候会经常遇到string与[]byte相互转换的情况，这种转化其实代价很高，因为string与[]byte的内存空间不共享，所以每次转换都伴随着内存的分配与底层字节的拷贝。而我们使用unsafe就可以避开这些，从而提升性能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func string2byte(s string) []byte { sh := (*reflect.StringHeader)(unsafe.Pointer(\u0026s)) bh := reflect.SliceHeader{ Data: sh.Data, Len: sh.Len, Cap: sh.Len, } return *(*[]byte)(unsafe.Pointer(\u0026bh)) } func byte2string(b []byte) string{ bh := (*reflect.SliceHeader)(unsafe.Pointer(\u0026b)) sh := reflect.StringHeader{ Data: bh.Data, Len: bh.Len, } return *(*string)(unsafe.Pointer(\u0026sh)) }   这样的转化过程依赖于二者的数据结构：\n1 2 3 4 5 6 7 8 9 10  struct string{ uint8 *str; int len; } struct []uint8{ uint8 *array; int len; int cap; }   注意，这样虽然可以实现，但强烈推荐不要使用这种方法来转换类型，因为这样会导致修改转化过后的值会影响之前的变量。\n修改私有成员变量 在Golang中对于不在同一个package里面的对象的私有变量(小写的)是不能直接修改的，但是使用unsafe可以做到：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  package p import ( \"fmt\" ) type V struct { i int32 j int64 } func (this V) PrintI() { fmt.Printf(\"i=%d\\n\", this.i) } func (this V) PrintJ() { fmt.Printf(\"j=%d\\n\", this.j) }   我们在mian里面实现来直接修改i,j的值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  package main import ( \"p\" \"unsafe\" ) func main() { var v *p.V = new(p.V) var i *int32 = (*int32)(unsafe.Pointer(v)) *i = int32(1) var j *int64 = (*int64)(unsafe.Pointer(uintptr(unsafe.Pointer(v)) +unsafe.Sizeof(int32(0)))) *j = int64(2) v.PrintI() v.PrintJ() }   其实在上面用uintptr计算偏移量介绍的那样，这样可以达到修改私有变量的目的。虽然达到了目的，但是在开发中其实并不建议这么干。\n在反射中使用 reflect包中Value类型的方法中名称为Pointer和UnsafeAddr的方法的返回值类型是uintptr而不是unsafe.Pointer,目的是为了使调用者可以将结果转为任意类型而不用导入unsafe包。然而，这意味着调用结果必须马上再调用完成后转为Pointer,并且是在同一个表达式中完成；如下：\n1  p := (*int)(unsafe.Pointer(reflect.ValueOf(new(int)).Pointer()))   获取 slice 长度 通过前面关于 slice 的文章，我们知道了 slice header 的结构体定义：\n1 2 3 4 5 6  // runtime/slice.go type slice struct { array unsafe.Pointer // 元素指针  len int // 长度  cap int // 容量 }   调用 make 函数新建一个 slice，底层调用的是 makeslice 函数，返回的是 slice 结构体：\n1  func makeslice(et *_type, len, cap int) slice   因此我们可以通过 unsafe.Pointer 和 uintptr 进行转换，得到 slice 的字段值。\n1 2 3 4 5 6 7 8  func main() { s := make([]int, 9, 20) var Len = *(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(\u0026s)) + uintptr(8))) fmt.Println(Len, len(s)) // 9 9  var Cap = *(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(\u0026s)) + uintptr(16))) fmt.Println(Cap, cap(s)) // 20 20 }   Len，cap 的转换流程如下：\n1 2  Len: \u0026s = pointer = uintptr = pointer = *int = int Cap: \u0026s = pointer = uintptr = pointer =*int = int   获取 map 长度 再来看一下我们讲到的 map：\n1 2 3 4 5 6 7 8 9 10 11 12 13  type hmap struct { count int flags uint8 B uint8 noverflow uint16 hash0 uint32 buckets unsafe.Pointer oldbuckets unsafe.Pointer nevacuate uintptr extra *mapextra }   和 slice 不同的是，makemap 函数返回的是 hmap 的指针，注意是指针：\n1  func makemap(t *maptype, hint int64, h*hmap, bucket unsafe.Pointer) *hmap   我们依然能通过 unsafe.Pointer 和 uintptr 进行转换，得到 hamp 字段的值，只不过，现在 count 变成二级指针了：\n1 2 3 4 5 6 7 8  func main() { mp := make(map[string]int) mp[\"qcrao\"] = 100 mp[\"stefno\"] = 18 count := **(**int)(unsafe.Pointer(\u0026mp)) fmt.Println(count, len(mp)) // 2 2 }   count 的转换过程：\n1  \u0026mp = pointer = **int = int   在 map 源码中，mapaccess1、mapassign、mapdelete 函数中，需要定位 key 的位置，会先对 key 做哈希运算。\n例如：\n1  b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + (hash\u0026m)*uintptr(t.bucketsize)))   h.buckets 是一个 unsafe.Pointer，将它转换成 uintptr，然后加上 (hash\u0026m)*uintptr(t.bucketsize)，二者相加的结果再次转换成 unsafe.Pointer，最后，转换成 bmap 指针，得到 key 所落入的 bucket 位置。\n上面举的例子相对简单，来看一个关于赋值的更难一点的例子：\n1 2 3 4 5 6 7 8 9 10 11 12  // store new key/value at insert position if t.indirectkey { kmem := newobject(t.key) *(*unsafe.Pointer)(insertk) = kmem insertk = kmem } if t.indirectvalue { vmem := newobject(t.elem) *(*unsafe.Pointer)(val) = vmem } typedmemmove(t.key, insertk, key)   这段代码是在找到了 key 要插入的位置后，进行“赋值”操作。insertk 和 val 分别表示 key 和 value 所要“放置”的地址。如果 t.indirectkey 为真，说明 bucket 中存储的是 key 的指针，因此需要将 insertk 看成指针的指针，这样才能将 bucket 中的相应位置的值设置成指向真实 key 的地址值，也就是说 key 存放的是指针。\n下面这张图展示了设置 key 的全部操作：\nobj 是真实的 key 存放的地方。第 4 号图，obj 表示执行完 typedmemmove 函数后，被成功赋值。\n总结 其实说了这么多，大部分使用在日常的开发中都不怎么会用到。所以文中有不止一处说了“不建议”，那是因为用的时候的确有很多需要注意的地方，但是如果你可以很准确地控制，那么使用\"unsafe\"则可能成为一把利剑。\n参考 深度解密Go语言之unsafe\n",
  "wordCount" : "4726",
  "inLanguage": "zh-cn",
  "datePublished": "2018-11-27T19:58:06Z",
  "dateModified": "2018-11-27T19:58:06Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/go%E4%B8%ADunsafe%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Go中unsafe使用实践
    </h1>
    <div class="post-meta">November 27, 2018
</div>
  </header> 
  <div class="post-content"><h2 id="指针类型">指针类型<a hidden class="anchor" aria-hidden="true" href="#指针类型">#</a></h2>
<p>在正式介绍 unsafe 包之前，需要着重介绍 Go 语言中的指针类型。</p>
<p>举一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">double</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">x</span> <span class="o">+=</span> <span class="nx">x</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="mi">3</span>
	<span class="nf">double</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="c1">// 3
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>非常简单，我想在 double 函数里将 a 翻倍，但是例子中的函数却做不到。为什么？因为 Go 语言的函数传参都是值传递。double 函数里的 x 只是实参 a 的一个拷贝，在函数内部对 x 的操作不能反馈到实参 a。</p>
<p>如果这时，有一个指针就可以解决问题了！这也是我们常用的“伎俩”。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">double</span><span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">*</span><span class="nx">x</span> <span class="o">+=</span> <span class="o">*</span><span class="nx">x</span>
	<span class="nx">x</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="mi">3</span>
	<span class="nf">double</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">a</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="c1">// 6
</span><span class="c1"></span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">a</span>
	<span class="nf">double</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span> <span class="c1">// 12 false
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>很常规的操作，不用多解释。唯一可能有些疑惑的在这一句：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">x</span> <span class="p">=</span> <span class="kc">nil</span>
</code></pre></td></tr></table>
</div>
</div><p>这得稍微思考一下，才能得出这一行代码根本不影响的结论。因为是值传递，所以 x 也只是对 &amp;a 的一个拷贝。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="o">*</span><span class="nx">x</span> <span class="o">+=</span> <span class="o">*</span><span class="nx">x</span>
</code></pre></td></tr></table>
</div>
</div><p>这一句把 x 指向的值（也就是 &amp;a 指向的值，即变量 a）变为原来的 2 倍。但是对 x 本身（一个指针）的操作却不会影响外层的 a，所以 x = nil 掀不起任何大风大浪。</p>
<p>下面的这张图可以“自证清白”：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210706210545.png" alt=""  />
</p>
<p>然而，相比于 C 语言中指针的灵活，Go 的指针多了一些限制。但这也算是 Go 的成功之处：既可以享受指针带来的便利，又避免了指针的危险性。</p>
<p>限制一：Go 的指针不能进行数学运算。</p>
<p>来看一个简单的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">a</span> <span class="o">:=</span> <span class="mi">5</span>
<span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">a</span>

<span class="nx">p</span><span class="o">++</span>
<span class="nx">p</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">a</span> <span class="o">+</span> <span class="mi">3</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的代码将不能通过编译，会报编译错误：invalid operation，也就是说不能对指针做数学运算。</p>
<p>限制二：不同类型的指针不能相互转换。</p>
<p>例如下面这个简短的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">f</span> <span class="o">*</span><span class="kt">float64</span>

	<span class="nx">f</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">a</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>也会报编译错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">cannot</span> <span class="n">use</span> <span class="o">&amp;</span><span class="nf">a </span><span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">int</span><span class="p">)</span> <span class="n">as</span> <span class="n">type</span> <span class="o">*</span><span class="n">float64</span> <span class="n">in</span> <span class="n">assignment</span>
</code></pre></td></tr></table>
</div>
</div><p>限制三：不同类型的指针不能使用 == 或 != 比较。</p>
<p>只有在两个指针类型相同或者可以相互转换的情况下，才可以对两者进行比较。另外，指针可以通过 == 和 != 直接和 nil 作比较。</p>
<p>限制四：不同类型的指针变量不能相互赋值。</p>
<p>这一点同限制三。</p>
<h2 id="什么是-unsafe">什么是 unsafe<a hidden class="anchor" aria-hidden="true" href="#什么是-unsafe">#</a></h2>
<p>前面所说的指针是类型安全的，但它有很多限制。Go 还有非类型安全的指针，这就是 unsafe 包提供的 <code>unsafe.Pointer</code>。在某些情况下，它会使代码更高效，当然，也更危险。</p>
<p>unsafe 包用于 Go 编译器，在编译阶段使用。从名字就可以看出来，它是不安全的，官方并不建议使用。我在用 unsafe 包的时候会有一种不舒服的感觉，可能这也是语言设计者的意图吧。</p>
<p>但是高阶的 Gopher，怎么能不会使用 unsafe 包呢？它可以绕过 Go 语言的类型系统，直接操作内存。例如，一般我们不能操作一个结构体的未导出成员，但是通过 unsafe 包就能做到。unsafe 包让我可以直接读写内存，还管你什么导出还是未导出。</p>
<h2 id="为什么有-unsafe">为什么有 unsafe<a hidden class="anchor" aria-hidden="true" href="#为什么有-unsafe">#</a></h2>
<p>Go 语言类型系统是为了安全和效率设计的，有时，安全会导致效率低下。有了 unsafe 包，高阶的程序员就可以利用它绕过类型系统的低效。因此，它就有了存在的意义，阅读 Go 源码，会发现有大量使用 unsafe 包的例子。</p>
<p>unsafe 实现原理</p>
<p>我们来看源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ArbitraryType</span> <span class="kt">int</span>

<span class="kd">type</span> <span class="nx">Pointer</span> <span class="o">*</span><span class="nx">ArbitraryType</span>
</code></pre></td></tr></table>
</div>
</div><p>从命名来看，Arbitrary 是任意的意思，也就是说 Pointer 可以指向任意类型，实际上它类似于 C 语言里的 void*。</p>
<p>unsafe 包还有其他三个函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Sizeof</span><span class="p">(</span><span class="nx">x</span> <span class="nx">ArbitraryType</span><span class="p">)</span> <span class="kt">uintptr</span>
<span class="kd">func</span> <span class="nf">Offsetof</span><span class="p">(</span><span class="nx">x</span> <span class="nx">ArbitraryType</span><span class="p">)</span> <span class="kt">uintptr</span>
<span class="kd">func</span> <span class="nf">Alignof</span><span class="p">(</span><span class="nx">x</span> <span class="nx">ArbitraryType</span><span class="p">)</span> <span class="kt">uintptr</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Sizeof 返回类型 x 所占据的字节数，但不包含 x 所指向的内容的大小。例如，对于一个指针，函数返回的大小为 8 字节（64位机上），一个 slice 的大小则为 slice header 的大小。</li>
<li>Offsetof 返回结构体成员在内存中的位置离结构体起始处的字节数，所传参数必须是结构体的成员。</li>
<li>Alignof 返回 m，m 是指当类型进行内存对齐时，它分配到的内存地址能整除 m。</li>
</ul>
<h2 id="uintptr与unsafepointer">uintptr与unsafe.Pointer<a hidden class="anchor" aria-hidden="true" href="#uintptr与unsafepointer">#</a></h2>
<p>注意到以上三个函数返回的结果都是 uintptr 类型，这和 unsafe.Pointer 可以相互转换。三个函数都是在编译期间执行，它们的结果可以直接赋给 const 型变量。另外，因为三个函数执行的结果和操作系统、编译器相关，所以是不可移植的。</p>
<p>综上所述，unsafe 包提供了 2 点重要的能力：</p>
<ul>
<li>任何类型的指针和 unsafe.Pointer 可以相互转换。</li>
<li>uintptr 类型和 unsafe.Pointer 可以相互转换。</li>
</ul>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210706211522.png" alt=""  />
</p>
<p>pointer 不能直接进行数学运算，但可以把它转换成 uintptr，对 uintptr 类型进行数学运算，再转换成 pointer 类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// uintptr 是一个整数类型，它足够大，可以存储
</span><span class="c1"></span><span class="kd">type</span> <span class="kt">uintptr</span> <span class="kt">uintptr</span>
</code></pre></td></tr></table>
</div>
</div><p>unsafe.Pointer在Golang中是用于各种类型转化的桥梁，Pointer代表了一个指向任意类型的指针。uintptr是Golang的内置类型，是能存储指针的整型，uintptr的底层类型是int，它和unsafe.Pointer可相互转换。</p>
<p>Pointer与uintptr的区别在于：</p>
<ol>
<li>unsafe.Pointer只是一个指针的类型，但是不能像C中的指针那样作计算，而只能用于转化不同类型的指针；如果unsafe.Pointer变量仍然有效，则由unsafe.Pointer变量表示的地址处的数据不会被GC回收；</li>
<li>uintptr是可以用于指针运算的，但是无法持有对象，GC并不把uintptr当做指针，所以uintptr类型的目标会被回收。</li>
</ol>
<p>在Golang中出于安全的原因，不允许两个不同指针类型的值去直接转换；也不允许指针类型和uintptr的值去直接转换。但是借助unsafe.Pointer，我们</p>
<ol>
<li>任何类型的指针值都可以转换为unsafe.Pointer；</li>
<li>unsafe.Pointer可以转换为任何类型的指针值；</li>
<li>uintptr可以转换为unsafe.Pointer；</li>
<li>unsafe.Pointer可以转换为uintptr。</li>
</ol>
<p>unsafe 包中的几个函数都是在编译期间执行完毕，毕竟，编译器对内存分配这些操作“了然于胸”。在 /usr/local/go/src/cmd/compile/internal/gc/unsafe.go 路径下，可以看到编译期间 Go 对 unsafe 包中函数的处理。</p>
<h2 id="强制类型转换">强制类型转换<a hidden class="anchor" aria-hidden="true" href="#强制类型转换">#</a></h2>
<p>在此之前提示一下这里我们说的类型的转化，是转化前后变量为同一变量，而不是这样为两个变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="kt">int64</span> <span class="p">=</span> <span class="mi">3</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="kt">float64</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">a</span><span class="p">)</span> <span class="c1">// 0xc42000e248
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">)</span> <span class="c1">// 0xc42000e250
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果我们要来做一个强制的转化的话，<code>a = float64(a)</code>,Golang会报错：<code>cannot use float64(a) (type float64) as type int64 in assignment</code>。</p>
<p>使用<code>unsafe.Pointer</code>来将T1转化为T2，一个大致的语法为*(*T2)(unsafe.Pointer(&amp;t1))</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">n</span> <span class="kt">int64</span> <span class="p">=</span> <span class="mi">3</span>
    <span class="kd">var</span> <span class="nx">pn</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">n</span> <span class="c1">// n的指针
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">pf</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="kt">float64</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">pn</span><span class="p">))</span> <span class="c1">// 通过Pointer来将n的类型转为float
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">pf</span><span class="p">)</span> <span class="c1">// 2.5e-323
</span><span class="c1"></span>    <span class="o">*</span><span class="nx">pf</span> <span class="p">=</span> <span class="mf">3.5</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="c1">// 4615063718147915776
</span><span class="c1"></span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">pf</span><span class="p">)</span> <span class="c1">// 0xc42007a050
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">pn</span><span class="p">)</span> <span class="c1">// 0xc42007a050
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个例子虽然没有实际的意义，但是绕过了Golang类型系统和内存安全，将一个变量的类型作了转化。</p>
<h2 id="修改结构体私有成员">修改结构体私有成员<a hidden class="anchor" aria-hidden="true" href="#修改结构体私有成员">#</a></h2>
<p>我们知道在Golang中指针是不能用来计算的，但是借助uintptr我们可以作计算：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
    <span class="nx">p1</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1">// index为1的元素
</span><span class="c1"></span>    <span class="nx">p3</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">p1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="c1">// 拿到index为3的指针
</span><span class="c1"></span>    <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="nx">p3</span><span class="p">)</span> <span class="p">=</span> <span class="mi">4</span> <span class="c1">// 重新赋值
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="c1">// a = [0 1 2 4]
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>对于一个结构体，通过 offset 函数可以获取结构体成员的偏移量，进而获取成员的地址，读写该地址的内存，就可以达到改变成员值的目的。</p>
<p>这里有一个内存分配相关的事实：结构体会被分配一块连续的内存，结构体的地址也代表了第一个成员的地址。</p>
<p>我们来看一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;unsafe&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Programmer</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span> <span class="kt">string</span>
	<span class="nx">language</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">Programmer</span><span class="p">{</span><span class="s">&#34;stefno&#34;</span><span class="p">,</span> <span class="s">&#34;go&#34;</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>

	<span class="nx">name</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">))</span>
	<span class="o">*</span><span class="nx">name</span> <span class="p">=</span> <span class="s">&#34;qcrao&#34;</span>

	<span class="nx">lang</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">))</span> <span class="o">+</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Offsetof</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">language</span><span class="p">)))</span>
	<span class="o">*</span><span class="nx">lang</span> <span class="p">=</span> <span class="s">&#34;Golang&#34;</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行代码，输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="p">{</span><span class="n">stefno</span> <span class="n">go</span><span class="p">}</span>
<span class="p">{</span><span class="n">qcrao</span> <span class="n">Golang</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>name 是结构体的第一个成员，因此可以直接将 <code>&amp;p</code> 解析成 <code>*string</code>。这一点，在前面获取 map 的 count 成员时，用的是同样的原理。</p>
<p>对于结构体的私有成员，现在有办法可以通过 <code>unsafe.Pointer</code> 改变它的值了。</p>
<p>我把 Programmer 结构体升级，多加一个字段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Programmer</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span> <span class="kt">string</span>
	<span class="nx">age</span> <span class="kt">int</span>
	<span class="nx">language</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>并且放在其他包，这样在 main 函数中，它的三个字段都是私有成员变量，不能直接修改。但我通过 <code>unsafe.Sizeof()</code> 函数可以获取成员大小，进而计算出成员的地址，直接修改内存。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">Programmer</span><span class="p">{</span><span class="s">&#34;stefno&#34;</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="s">&#34;go&#34;</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>

	<span class="nx">lang</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">))</span> <span class="o">+</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">+</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">))))</span>
	<span class="o">*</span><span class="nx">lang</span> <span class="p">=</span> <span class="s">&#34;Golang&#34;</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="p">{</span><span class="n">stefno</span> <span class="m">18</span> <span class="n">go</span><span class="p">}</span>
<span class="p">{</span><span class="n">stefno</span> <span class="m">18</span> <span class="n">Golang</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="string与byte相互转换">string与[]byte相互转换<a hidden class="anchor" aria-hidden="true" href="#string与byte相互转换">#</a></h2>
<p>我们在写程序的时候会经常遇到string与<code>[]byte</code>相互转换的情况，这种转化其实代价很高，因为string与<code>[]byte</code>的内存空间不共享，所以每次转换都伴随着内存的分配与底层字节的拷贝。而我们使用unsafe就可以避开这些，从而提升性能。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">string2byte</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
    <span class="nx">sh</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">StringHeader</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">))</span>
    <span class="nx">bh</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">SliceHeader</span><span class="p">{</span>
        <span class="nx">Data</span><span class="p">:</span> <span class="nx">sh</span><span class="p">.</span><span class="nx">Data</span><span class="p">,</span>
        <span class="nx">Len</span><span class="p">:</span>  <span class="nx">sh</span><span class="p">.</span><span class="nx">Len</span><span class="p">,</span>
        <span class="nx">Cap</span><span class="p">:</span>  <span class="nx">sh</span><span class="p">.</span><span class="nx">Len</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">[]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">bh</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">byte2string</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">string</span><span class="p">{</span>
    <span class="nx">bh</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">SliceHeader</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">))</span>
    <span class="nx">sh</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">StringHeader</span><span class="p">{</span>
        <span class="nx">Data</span><span class="p">:</span> <span class="nx">bh</span><span class="p">.</span><span class="nx">Data</span><span class="p">,</span>
        <span class="nx">Len</span><span class="p">:</span>  <span class="nx">bh</span><span class="p">.</span><span class="nx">Len</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sh</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这样的转化过程依赖于二者的数据结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">struct</span> <span class="kt">string</span><span class="p">{</span>
    <span class="kt">uint8</span> <span class="o">*</span><span class="nx">str</span><span class="p">;</span>
    <span class="kt">int</span> <span class="nx">len</span><span class="p">;</span>
  <span class="p">}</span>

<span class="kd">struct</span> <span class="p">[]</span><span class="kt">uint8</span><span class="p">{</span>
    <span class="kt">uint8</span> <span class="o">*</span><span class="nx">array</span><span class="p">;</span>
    <span class="kt">int</span> <span class="nx">len</span><span class="p">;</span>
    <span class="kt">int</span> <span class="nx">cap</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意，这样虽然可以实现，但强烈推荐不要使用这种方法来转换类型，因为这样会导致修改转化过后的值会影响之前的变量。</p>
<h2 id="修改私有成员变量">修改私有成员变量<a hidden class="anchor" aria-hidden="true" href="#修改私有成员变量">#</a></h2>
<p>在Golang中对于不在同一个package里面的对象的私有变量(小写的)是不能直接修改的，但是使用unsafe可以做到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">p</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">V</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">i</span> <span class="kt">int32</span>
    <span class="nx">j</span> <span class="kt">int64</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="nx">V</span><span class="p">)</span> <span class="nf">PrintI</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;i=%d\n&#34;</span><span class="p">,</span> <span class="nx">this</span><span class="p">.</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="nx">V</span><span class="p">)</span> <span class="nf">PrintJ</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;j=%d\n&#34;</span><span class="p">,</span> <span class="nx">this</span><span class="p">.</span><span class="nx">j</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们在mian里面实现来直接修改i,j的值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;p&#34;</span>
    <span class="s">&#34;unsafe&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">v</span> <span class="o">*</span><span class="nx">p</span><span class="p">.</span><span class="nx">V</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">V</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">i</span> <span class="o">*</span><span class="kt">int32</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="kt">int32</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
    <span class="o">*</span><span class="nx">i</span> <span class="p">=</span> <span class="nb">int32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">j</span> <span class="o">*</span><span class="kt">int64</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="kt">int64</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span> <span class="o">+</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nb">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">))))</span>
    <span class="o">*</span><span class="nx">j</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="nx">v</span><span class="p">.</span><span class="nf">PrintI</span><span class="p">()</span>
    <span class="nx">v</span><span class="p">.</span><span class="nf">PrintJ</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其实在上面用uintptr计算偏移量介绍的那样，这样可以达到修改私有变量的目的。虽然达到了目的，但是在开发中其实并不建议这么干。</p>
<h3 id="在反射中使用">在反射中使用<a hidden class="anchor" aria-hidden="true" href="#在反射中使用">#</a></h3>
<p>reflect包中Value类型的方法中名称为Pointer和UnsafeAddr的方法的返回值类型是uintptr而不是unsafe.Pointer,目的是为了使调用者可以将结果转为任意类型而不用导入unsafe包。然而，这意味着调用结果必须马上再调用完成后转为Pointer,并且是在同一个表达式中完成；如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">p</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)).</span><span class="nf">Pointer</span><span class="p">()))</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="获取-slice-长度">获取 slice 长度<a hidden class="anchor" aria-hidden="true" href="#获取-slice-长度">#</a></h2>
<p>通过前面关于 slice 的文章，我们知道了 slice header 的结构体定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// runtime/slice.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">slice</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">array</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 元素指针
</span><span class="c1"></span>    <span class="nx">len</span>   <span class="kt">int</span> <span class="c1">// 长度
</span><span class="c1"></span>    <span class="nx">cap</span>   <span class="kt">int</span> <span class="c1">// 容量
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>调用 make 函数新建一个 slice，底层调用的是 makeslice 函数，返回的是 slice 结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makeslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">slice</span>
</code></pre></td></tr></table>
</div>
</div><p>因此我们可以通过 unsafe.Pointer 和 uintptr 进行转换，得到 slice 的字段值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">Len</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">))</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">8</span><span class="p">)))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">Len</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span> <span class="c1">// 9 9
</span><span class="c1"></span>
	<span class="kd">var</span> <span class="nx">Cap</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">))</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">16</span><span class="p">)))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">Cap</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span> <span class="c1">// 20 20
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Len，cap 的转换流程如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">Len</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">=&gt;</span> <span class="n">pointer</span> <span class="o">=&gt;</span> <span class="n">uintptr</span> <span class="o">=&gt;</span> <span class="n">pointer</span> <span class="o">=&gt;</span> <span class="o">*</span><span class="n">int</span> <span class="o">=&gt;</span> <span class="n">int</span>
<span class="n">Cap</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">=&gt;</span> <span class="n">pointer</span> <span class="o">=&gt;</span> <span class="n">uintptr</span> <span class="o">=&gt;</span> <span class="n">pointer</span> <span class="o">=&gt;*</span><span class="n">int</span> <span class="o">=&gt;</span> <span class="n">int</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="获取-map-长度">获取 map 长度<a hidden class="anchor" aria-hidden="true" href="#获取-map-长度">#</a></h2>
<p>再来看一下我们讲到的 map：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">hmap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">count</span>     <span class="kt">int</span>
	<span class="nx">flags</span>     <span class="kt">uint8</span>
	<span class="nx">B</span>         <span class="kt">uint8</span>
	<span class="nx">noverflow</span> <span class="kt">uint16</span>
	<span class="nx">hash0</span>     <span class="kt">uint32</span>

	<span class="nx">buckets</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="nx">oldbuckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="nx">nevacuate</span>  <span class="kt">uintptr</span>

	<span class="nx">extra</span> <span class="o">*</span><span class="nx">mapextra</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>和 slice 不同的是，makemap 函数返回的是 hmap 的指针，注意是指针：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makemap</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">hint</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">h</span><span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">bucket</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="o">*</span><span class="nx">hmap</span>
</code></pre></td></tr></table>
</div>
</div><p>我们依然能通过 unsafe.Pointer 和 uintptr 进行转换，得到 hamp 字段的值，只不过，现在 count 变成二级指针了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">mp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="nx">mp</span><span class="p">[</span><span class="s">&#34;qcrao&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">100</span>
	<span class="nx">mp</span><span class="p">[</span><span class="s">&#34;stefno&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">18</span>

	<span class="nx">count</span> <span class="o">:=</span> <span class="o">**</span><span class="p">(</span><span class="o">**</span><span class="kt">int</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">count</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">mp</span><span class="p">))</span> <span class="c1">// 2 2
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>count 的转换过程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">&amp;</span><span class="n">mp</span> <span class="o">=&gt;</span> <span class="n">pointer</span> <span class="o">=&gt;</span> <span class="o">**</span><span class="n">int</span> <span class="o">=&gt;</span> <span class="n">int</span>
</code></pre></td></tr></table>
</div>
</div><p>在 map 源码中，mapaccess1、mapassign、mapdelete 函数中，需要定位 key 的位置，会先对 key 做哈希运算。</p>
<p>例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
</code></pre></td></tr></table>
</div>
</div><p>h.buckets 是一个 unsafe.Pointer，将它转换成 uintptr，然后加上 <code>(hash&amp;m)*uintptr(t.bucketsize)</code>，二者相加的结果再次转换成 unsafe.Pointer，最后，转换成 bmap 指针，得到 key 所落入的 bucket 位置。</p>
<p>上面举的例子相对简单，来看一个关于赋值的更难一点的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// store new key/value at insert position
</span><span class="c1"></span><span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">indirectkey</span> <span class="p">{</span>
	<span class="nx">kmem</span> <span class="o">:=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span>
	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">insertk</span><span class="p">)</span> <span class="p">=</span> <span class="nx">kmem</span>
	<span class="nx">insertk</span> <span class="p">=</span> <span class="nx">kmem</span>
<span class="p">}</span>
<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">indirectvalue</span> <span class="p">{</span>
	<span class="nx">vmem</span> <span class="o">:=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">val</span><span class="p">)</span> <span class="p">=</span> <span class="nx">vmem</span>
<span class="p">}</span>

<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">insertk</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这段代码是在找到了 key 要插入的位置后，进行“赋值”操作。insertk 和 val 分别表示 key 和 value 所要“放置”的地址。如果 t.indirectkey 为真，说明 bucket 中存储的是 key 的指针，因此需要将 insertk 看成指针的指针，这样才能将 bucket 中的相应位置的值设置成指向真实 key 的地址值，也就是说 key 存放的是指针。</p>
<p>下面这张图展示了设置 key 的全部操作：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210706213646.png" alt=""  />
</p>
<p>obj 是真实的 key 存放的地方。第 4 号图，obj 表示执行完 typedmemmove 函数后，被成功赋值。</p>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<p>其实说了这么多，大部分使用在日常的开发中都不怎么会用到。所以文中有不止一处说了“不建议”，那是因为用的时候的确有很多需要注意的地方，但是如果你可以很准确地控制，那么使用&quot;unsafe&quot;则可能成为一把利剑。</p>
<h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<p><a href="https://www.cnblogs.com/qcrao-2018/p/10964692.html#offsetof-%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%81%8F%E7%A7%BB%E9%87%8F">深度解密Go语言之unsafe</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go/">Go</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
