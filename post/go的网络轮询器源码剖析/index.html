<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go的网络轮询器源码剖析 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author"
  content="Forz" /><meta name="description" content="导言 Go 基于 I/O multiplexing 和 goroutine scheduler 构建了一个简洁而高性能的原生网络模型(基于 Go 的 I/O 多路复用 netpoller )，提供了 goroutine-per-connection 这样简单的网络编程模式。在这种模式下，开发者使用的" /><meta name="keywords"
  content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.68.1 with theme even" />


<link rel="canonical" href="/post/go%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BD%AE%E8%AF%A2%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link rel="stylesheet" href="/css/search.css" />


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go的网络轮询器源码剖析" />
<meta property="og:description" content="导言 Go 基于 I/O multiplexing 和 goroutine scheduler 构建了一个简洁而高性能的原生网络模型(基于 Go 的 I/O 多路复用 netpoller )，提供了 goroutine-per-connection 这样简单的网络编程模式。在这种模式下，开发者使用的" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BD%AE%E8%AF%A2%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<meta property="article:published_time" content="2020-11-14T22:52:29+00:00" />
<meta property="article:modified_time" content="2020-11-14T22:52:29+00:00" />
<meta itemprop="name" content="Go的网络轮询器源码剖析">
<meta itemprop="description" content="导言 Go 基于 I/O multiplexing 和 goroutine scheduler 构建了一个简洁而高性能的原生网络模型(基于 Go 的 I/O 多路复用 netpoller )，提供了 goroutine-per-connection 这样简单的网络编程模式。在这种模式下，开发者使用的">
<meta itemprop="datePublished" content="2020-11-14T22:52:29&#43;00:00" />
<meta itemprop="dateModified" content="2020-11-14T22:52:29&#43;00:00" />
<meta itemprop="wordCount" content="14993">



<meta itemprop="keywords" content="Go源码," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go的网络轮询器源码剖析"/>
<meta name="twitter:description" content="导言 Go 基于 I/O multiplexing 和 goroutine scheduler 构建了一个简洁而高性能的原生网络模型(基于 Go 的 I/O 多路复用 netpoller )，提供了 goroutine-per-connection 这样简单的网络编程模式。在这种模式下，开发者使用的"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="clearfix">
  <div class="logo-wrapper">
    <a href="/" class="logo">Forz Blog</a>
  </div>

  <nav class="site-navbar">
    <ul id="menu" class="menu">
      <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
    </ul>
  </nav>
</div>


<div class="search-container">
  <div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="Search for titles or URIs..."
        name="search" autocomplete="off" />
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path
            d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js"></script>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js"></script>
<script>
    var client = algoliasearch("IAR2EF5L65", "b4b9da2eba53aa6dabe4b8ac9e8676e1");
    var index = client.initIndex('forz.forzvina.com');
    autocomplete('#aa-search-input',
        { hint: false }, {
        source: autocomplete.sources.hits(index, { hitsPerPage: 8 }),
        displayKey: 'name',
        templates: {
            suggestion: function (suggestion) {
                var reg = /([A-Z]+)/ig
                var title = suggestion.uri.replace(reg, function (m) {
                    return m.toLowerCase()
                })
                return '<span class="search-item">' + '<a href="\/' + title + '">' +
                    suggestion._highlightResult.title.value + '</a></span>';
            }
        }
    });
</script>
</div>


    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go的网络轮询器源码剖析</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-11-14 </span>
        <div class="post-category">
            <a href="/categories/go%E6%BA%90%E7%A0%81/"> Go源码 </a>
            </div>
          <span class="more-meta"> 约 14993 字 </span>
          <span class="more-meta"> 预计阅读 30 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#导言">导言</a></li>
    <li><a href="#基本原理">基本原理</a></li>
    <li><a href="#polldesc">pollDesc</a></li>
    <li><a href="#pollcache">pollCache</a></li>
    <li><a href="#运行机制">运行机制</a>
      <ul>
        <li><a href="#初始化">初始化</a></li>
        <li><a href="#轮询事件">轮询事件</a></li>
        <li><a href="#事件循环">事件循环</a></li>
      </ul>
    </li>
    <li><a href="#tcp-server">TCP Server</a>
      <ul>
        <li><a href="#netfd">netFD</a></li>
        <li><a href="#netlisten">net.Listen</a></li>
        <li><a href="#listeneraccept">Listener.Accept</a></li>
        <li><a href="#connreadconnwrite">Conn.Read/Conn.Write</a></li>
        <li><a href="#总结">总结</a></li>
      </ul>
    </li>
    <li><a href="#价值">价值</a></li>
    <li><a href="#问题">问题</a></li>
    <li><a href="#reactor-网络模型">Reactor 网络模型</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="导言">导言</h2>
<p>Go 基于 I/O multiplexing 和 goroutine scheduler 构建了一个简洁而高性能的原生网络模型(基于 Go 的 I/O 多路复用 netpoller )，提供了 goroutine-per-connection 这样简单的网络编程模式。在这种模式下，开发者使用的是同步的模式去编写异步的逻辑，极大地降低了开发者编写网络应用时的心智负担，且借助于 Go runtime scheduler 对 goroutines 的高效调度，这个原生网络模型不论从适用性还是性能上都足以满足绝大部分的应用场景。</p>
<p>然而，在工程性上能做到如此高的普适性和兼容性，最终暴露给开发者提供接口/模式如此简洁，其底层必然是基于非常复杂的封装，做了很多取舍，也有可能放弃了一些追求极致性能的设计和理念。事实上 Go netpoller 底层就是基于 epoll/kqueue/iocp 这些 I/O 多路复用技术来做封装的，最终暴露出 goroutine-per-connection 这样的极简的开发模式给使用者。</p>
<p>Go netpoller 在不同的操作系统，其底层使用的 I/O 多路复用技术也不一样，可以从 Go 源码目录结构和对应代码文件了解 Go 在不同平台下的网络 I/O 模式的实现。比如，在 Linux 系统下基于 epoll，freeBSD 系统下基于 kqueue，以及 Windows 系统下基于 iocp。</p>
<p>本文将基于 Linux 平台来解析 Go netpoller 之 I/O 多路复用的底层是如何基于 epoll 封装实现的，从源码层层推进，全面而深度地解析 Go netpoller 的设计理念和实现原理，以及 Go 是如何利用 netpoller 来构建它的原生网络模型的。</p>
<h2 id="基本原理">基本原理</h2>
<p>Go netpoller 通过在底层对 epoll/kqueue/iocp 的封装，从而实现了使用同步编程模式达到异步执行的效果。总结来说，所有的网络操作都以网络描述符 netFD 为中心实现。netFD 与底层 PollDesc 结构绑定，当在一个 netFD 上读写遇到 EAGAIN 错误时，就将当前 goroutine 存储到这个 netFD 对应的 PollDesc 中，同时调用 gopark 把当前 goroutine 给 park 住，直到这个 netFD 上再次发生读写事件，才将此 goroutine 给 ready 激活重新运行。显然，在底层通知 goroutine 再次发生读写等事件的方式就是 epoll/kqueue/iocp 等事件驱动机制。</p>
<p>总所周知，Go 是一门跨平台的编程语言，而不同平台针对特定的功能有不用的实现，这当然也包括了 I/O 多路复用技术，比如 Linux 里的 I/O 多路复用有 select、poll 和 epoll，而 freeBSD 或者 MacOS 里则是 kqueue，而 Windows 里则是基于异步 I/O 实现的 iocp，等等；因此，Go 为了实现底层 I/O 多路复用的跨平台，分别基于上述的这些不同平台的系统调用实现了多版本的 netpollers，具体的源码路径如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="nx">netpoll_epoll</span><span class="p">.</span><span class="k">go</span>
<span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="nx">netpoll_kqueue</span><span class="p">.</span><span class="k">go</span>
<span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="nx">netpoll_solaris</span><span class="p">.</span><span class="k">go</span>
<span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="nx">netpoll_windows</span><span class="p">.</span><span class="k">go</span>
<span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="nx">netpoll_aix</span><span class="p">.</span><span class="k">go</span>
<span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="nx">netpoll_fake</span><span class="p">.</span><span class="k">go</span>
</code></pre></td></tr></table>
</div>
</div><p>本文的解析基于 epoll 版本，如果读者对其他平台的 netpoller 底层实现感兴趣，可以在阅读完本文后自行翻阅其他 netpoller 源码，所有实现版本的机制和原理基本类似，所以了解了 epoll 版本的实现后再去学习其他版本实现应该没什么障碍。</p>
<p>epoll、kqueue、solaries 等多路复用模块都要实现以下五个函数，这五个函数构成一个虚拟的接口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">netpollinit</span><span class="p">()</span>
<span class="kd">func</span> <span class="nf">netpollopen</span><span class="p">(</span><span class="nx">fd</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">pd</span> <span class="o">*</span><span class="nx">pollDesc</span><span class="p">)</span> <span class="kt">int32</span>
<span class="kd">func</span> <span class="nf">netpoll</span><span class="p">(</span><span class="nx">delta</span> <span class="kt">int64</span><span class="p">)</span> <span class="nx">gList</span>
<span class="kd">func</span> <span class="nf">netpollBreak</span><span class="p">()</span>
<span class="kd">func</span> <span class="nf">netpollIsPollDescriptor</span><span class="p">(</span><span class="nx">fd</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>上述函数在网络轮询器中分别扮演了不同的作用：</p>
<ul>
<li>runtime.netpollinit — 初始化网络轮询器，通过 sync.Once 和 netpollInited 变量保证函数只会调用一次；</li>
<li>runtime.netpollopen — 监听文件描述符上的边缘触发事件，创建事件并加入监听；</li>
<li>runtime.netpoll — 轮询网络并返回一组已经准备就绪的 Goroutine，传入的参数会决定它的行为；
<ul>
<li>如果参数小于 0，无限期等待文件描述符就绪；</li>
<li>如果参数等于 0，非阻塞地轮询网络；</li>
<li>如果参数大于 0，阻塞特定时间轮询网络；</li>
</ul>
</li>
<li>runtime.netpollBreak — 唤醒网络轮询器，例如：计时器向前修改时间时会通过该函数中断网络轮询器；</li>
<li>runtime.netpollIsPollDescriptor — 判断文件描述符是否被轮询器使用；</li>
</ul>
<p>接下来让我们全面剖析一下整个 Go netpoller 的运行机制和流程。</p>
<h2 id="polldesc">pollDesc</h2>
<p>操作系统中 I/O 多路复用函数会监控文件描述符的可读或者可写，而 Go 语言网络轮询器会监听 runtime.pollDesc 结构体的状态，该结构会封装操作系统的文件描述符：</p>
<p>前面提到了 pollDesc 是底层事件驱动的封装，netFD 通过它来完成各种 I/O 相关的操作，它的定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">pollDesc</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">runtimeCtx</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里的 struct 只包含了一个指针，而通过 pollDesc 的 init 方法，我们可以找到它具体的定义是在 runtime.pollDesc 这里：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Network poller descriptor.
</span><span class="c1">//
</span><span class="c1">// No heap pointers.
</span><span class="c1">//
</span><span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">pollDesc</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">link</span> <span class="o">*</span><span class="nx">pollDesc</span> <span class="c1">// in pollcache, protected by pollcache.lock
</span><span class="c1"></span>
	<span class="c1">// The lock protects pollOpen, pollSetDeadline, pollUnblock and deadlineimpl operations.
</span><span class="c1"></span>	<span class="c1">// This fully covers seq, rt and wt variables. fd is constant throughout the PollDesc lifetime.
</span><span class="c1"></span>	<span class="c1">// pollReset, pollWait, pollWaitCanceled and runtime·netpollready (IO readiness notification)
</span><span class="c1"></span>	<span class="c1">// proceed w/o taking the lock. So closing, everr, rg, rd, wg and wd are manipulated
</span><span class="c1"></span>	<span class="c1">// in a lock-free way by all operations.
</span><span class="c1"></span>	<span class="c1">// NOTE(dvyukov): the following code uses uintptr to store *g (rg/wg),
</span><span class="c1"></span>	<span class="c1">// that will blow up when GC starts moving objects.
</span><span class="c1"></span>	<span class="nx">lock</span>    <span class="nx">mutex</span> <span class="c1">// protects the following fields
</span><span class="c1"></span>	<span class="nx">fd</span>      <span class="kt">uintptr</span>
	<span class="nx">closing</span> <span class="kt">bool</span>
	<span class="nx">everr</span>   <span class="kt">bool</span>    <span class="c1">// marks event scanning error happened
</span><span class="c1"></span>	<span class="nx">user</span>    <span class="kt">uint32</span>  <span class="c1">// user settable cookie
</span><span class="c1"></span>	<span class="nx">rseq</span>    <span class="kt">uintptr</span> <span class="c1">// protects from stale read timers
</span><span class="c1"></span>	<span class="nx">rg</span>      <span class="kt">uintptr</span> <span class="c1">// pdReady, pdWait, G waiting for read or nil
</span><span class="c1"></span>	<span class="nx">rt</span>      <span class="nx">timer</span>   <span class="c1">// read deadline timer (set if rt.f != nil)
</span><span class="c1"></span>	<span class="nx">rd</span>      <span class="kt">int64</span>   <span class="c1">// read deadline
</span><span class="c1"></span>	<span class="nx">wseq</span>    <span class="kt">uintptr</span> <span class="c1">// protects from stale write timers
</span><span class="c1"></span>	<span class="nx">wg</span>      <span class="kt">uintptr</span> <span class="c1">// pdReady, pdWait, G waiting for write or nil
</span><span class="c1"></span>	<span class="nx">wt</span>      <span class="nx">timer</span>   <span class="c1">// write deadline timer
</span><span class="c1"></span>	<span class="nx">wd</span>      <span class="kt">int64</span>   <span class="c1">// write deadline
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该结构体中包含用于监控可读和可写状态的变量，我们按照功能将它们分成以下四组：</p>
<ul>
<li>rseq 和 wseq — 表示文件描述符被重用或者计时器被重置5；</li>
<li>rg 和 wg — 表示二进制的信号量，可能为 pdReady、pdWait、等待文件描述符可读或者可写的 Goroutine 以及 nil；它们是实现唤醒 goroutine 的关键。</li>
<li>rd 和 wd — 等待文件描述符可读或者可写的截止日期；</li>
<li>rt 和 wt — 用于等待文件描述符的计时器；</li>
</ul>
<h2 id="pollcache">pollCache</h2>
<p>runtime.pollDesc 包含自身类型的一个指针，用来保存下一个 runtime.pollDesc 的地址，以此来实现链表，可以减少数据结构的大小，所有的 runtime.pollDesc 保存在 runtime.pollCache 结构中，定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">pollCache</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span>  <span class="nx">mutex</span>
	<span class="nx">first</span> <span class="o">*</span><span class="nx">pollDesc</span>
	<span class="c1">// PollDesc objects must be type-stable,
</span><span class="c1"></span>	<span class="c1">// because we can get ready notification from epoll/kqueue
</span><span class="c1"></span>	<span class="c1">// after the descriptor is closed/reused.
</span><span class="c1"></span>	<span class="c1">// Stale notifications are detected using seq variable,
</span><span class="c1"></span>	<span class="c1">// seq is incremented when deadlines are changed or descriptor is reused.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>因为 runtime.pollCache 是一个在 runtime 包里的全局变量，因此需要用一个互斥锁来避免 data race 问题，从它的名字也能看出这是一个用于缓存的数据结构，也就是用来提高性能的，具体如何实现呢？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">pollBlockSize</span> <span class="p">=</span> <span class="mi">4</span> <span class="o">*</span><span class="mi">1024</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">pollCache</span><span class="p">)</span> <span class="nf">alloc</span><span class="p">()</span> <span class="o">*</span><span class="nx">pollDesc</span> <span class="p">{</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">first</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="kd">const</span> <span class="nx">pdSize</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">pollDesc</span><span class="p">{})</span>
		<span class="nx">n</span> <span class="o">:=</span> <span class="nx">pollBlockSize</span> <span class="o">/</span> <span class="nx">pdSize</span>
		<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">n</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="p">}</span>
		<span class="c1">// Must be in non-GC memory because can be referenced
</span><span class="c1"></span>		<span class="c1">// only from epoll/kqueue internals.
</span><span class="c1"></span>		<span class="nx">mem</span> <span class="o">:=</span> <span class="nf">persistentalloc</span><span class="p">(</span><span class="nx">n</span><span class="o">*</span><span class="nx">pdSize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">other_sys</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">pd</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">pollDesc</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">i</span><span class="o">*</span><span class="nx">pdSize</span><span class="p">))</span>
			<span class="nx">pd</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">first</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">first</span> <span class="p">=</span> <span class="nx">pd</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">pd</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">first</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">first</span> <span class="p">=</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">link</span>
	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pd</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankPollDesc</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">pd</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Go runtime 会在调用 poll_runtime_pollOpen 往 epoll 实例注册 fd 之时首次调用 runtime.pollCache.alloc方法时批量初始化大小 4KB 的 runtime.pollDesc 结构体的链表，初始化过程中会调用 runtime.persistentalloc 来为这些数据结构分配不会被 GC 回收的内存，确保这些数据结构只能被 epoll和kqueue 在内核空间去引用。</p>
<p>再往后每次调用这个方法则会先判断链表头是否已经分配过值了，若是，则直接返回表头这个 pollDesc，这种批量初始化数据进行缓存而后每次都直接从缓存取数据的方式是一种很常见的性能优化手段，在这里这种方式可以有效地提升 netpoller 的吞吐量。</p>
<p>Go runtime 会在关闭 pollDesc 之时调用 runtime.pollCache.free 释放内存,它会直接将结构体插入链表的最前面：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">pollCache</span><span class="p">)</span> <span class="nf">free</span><span class="p">(</span><span class="nx">pd</span> <span class="o">*</span><span class="nx">pollDesc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">pd</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">first</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">first</span> <span class="p">=</span> <span class="nx">pd</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述方法没有重置 runtime.pollDesc 结构体中的字段，该结构体被重复利用时才会由 runtime.poll_runtime_pollOpen 函数重置。</p>
<h2 id="运行机制">运行机制</h2>
<p>网络轮询器实际上就是对 I/O 多路复用技术的封装，本节将通过以下的三个过程分析网络轮询器的实现原理：</p>
<ol>
<li>网络轮询器的初始化；</li>
<li>如何向网络轮询器中加入待监控的任务；</li>
<li>如何从网络轮询器中获取触发的事件；</li>
</ol>
<p>上述三个过程包含了网络轮询器相关的方方面面，能够让我们对其实现有完整的理解。需要注意的是，我们在分析实现时会遵循以下两个规则：</p>
<ol>
<li>因为不同 I/O 多路复用模块的实现大同小异，本节会使用 Linux 操作系统上的 epoll 实现；</li>
<li>因为处理读事件和写事件的逻辑类似，本节会省略写事件相关的代码；</li>
</ol>
<h3 id="初始化">初始化</h3>
<p>因为文件 I/O、网络 I/O 以及计时器都依赖网络轮询器，所以 Go 语言会通过以下两条不同路径初始化网络轮询器：</p>
<ol>
<li>internal/poll.pollDesc.init — 通过 net.netFD.init 和 os.newFile 初始化网络 I/O 和文件 I/O 的轮询信息时；</li>
<li>runtime.doaddtimer — 向处理器中增加新的计时器时；</li>
</ol>
<p>网络轮询器的初始化会使用 runtime.poll_runtime_pollServerInit 和 runtime.netpollGenericInit 两个函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 使用 sync.Once 来确保一个 listener 只持有一个 epoll 实例
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">serverInit</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>

<span class="c1">// 它会创建 epoll 实例并把 listener fd 加入监听队列
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">pd</span> <span class="o">*</span><span class="nx">pollDesc</span><span class="p">)</span> <span class="nf">init</span><span class="p">(</span><span class="nx">fd</span> <span class="o">*</span><span class="nx">FD</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">serverInit</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">runtime_pollServerInit</span><span class="p">)</span>
	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">errno</span> <span class="o">:=</span> <span class="nf">runtime_pollOpen</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">Sysfd</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">errno</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">ctx</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">runtime_pollUnblock</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
			<span class="nf">runtime_pollClose</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nf">errnoErr</span><span class="p">(</span><span class="nx">syscall</span><span class="p">.</span><span class="nf">Errno</span><span class="p">(</span><span class="nx">errno</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nx">pd</span><span class="p">.</span><span class="nx">runtimeCtx</span> <span class="p">=</span> <span class="nx">ctx</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">runtime_pollServerInit</span><span class="p">()</span>
<span class="kd">func</span> <span class="nf">poll_runtime_pollServerInit</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">netpollGenericInit</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">netpollGenericInit</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollInited</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollInitLock</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">netpollInited</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">netpollinit</span><span class="p">()</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollInited</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollInitLock</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime.netpollGenericInit 会调用平台上特定实现的 runtime.netpollinit 函数，即 Linux 上的 epoll，它主要做了以下几件事情：</p>
<ol>
<li>调用 epollcreate1 创建一个新的 epoll 文件描述符，这个文件描述符会在整个程序的生命周期中使用；</li>
<li>通过 runtime.nonblockingPipe 创建一个用于通信的管道；</li>
<li>使用 epollctl 将用于读取数据的文件描述符打包成 epollevent 事件加入监听；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
	<span class="c1">// 全局唯一的 epoll fd，只在 listener fd 初始化之时被指定一次
</span><span class="c1"></span>	<span class="nx">epfd</span> <span class="kt">int32</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">// epoll descriptor
</span><span class="c1"></span><span class="p">)</span>
<span class="c1">// netpollinit 会创建一个 epoll 实例，然后把 epoll fd 赋值给 epfd，
</span><span class="c1">// 后续 listener 以及它 accept 的所有 sockets 有关 epoll 的操作都是基于这个全局的 epfd
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">netpollinit</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">epfd</span> <span class="p">=</span> <span class="nf">epollcreate1</span><span class="p">(</span><span class="nx">_EPOLL_CLOEXEC</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">epfd</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">epfd</span> <span class="p">=</span> <span class="nf">epollcreate</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">epfd</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: epollcreate failed with&#34;</span><span class="p">,</span> <span class="o">-</span><span class="nx">epfd</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: netpollinit failed&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">closeonexec</span><span class="p">(</span><span class="nx">epfd</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">r</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">errno</span> <span class="o">:=</span> <span class="nf">nonblockingPipe</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">errno</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: pipe failed with&#34;</span><span class="p">,</span> <span class="o">-</span><span class="nx">errno</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: pipe failed&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">ev</span> <span class="o">:=</span> <span class="nx">epollevent</span><span class="p">{</span>
		<span class="nx">events</span><span class="p">:</span> <span class="nx">_EPOLLIN</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ev</span><span class="p">.</span><span class="nx">data</span><span class="p">))</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">netpollBreakRd</span>
	<span class="nx">errno</span> <span class="p">=</span> <span class="nf">epollctl</span><span class="p">(</span><span class="nx">epfd</span><span class="p">,</span> <span class="nx">_EPOLL_CTL_ADD</span><span class="p">,</span> <span class="nx">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">ev</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">errno</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: epollctl failed with&#34;</span><span class="p">,</span> <span class="o">-</span><span class="nx">errno</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: epollctl failed&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">netpollBreakRd</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
	<span class="nx">netpollBreakWr</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">nonblockingPipe</span><span class="p">()</span> <span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">w</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">errno</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">errno</span> <span class="p">=</span> <span class="nf">pipe</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">errno</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">errno</span>
	<span class="p">}</span>
	<span class="nf">closeonexec</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
	<span class="nf">setNonblock</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
	<span class="nf">closeonexec</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
	<span class="nf">setNonblock</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">errno</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>初始化的管道为我们提供了中断多路复用等待文件描述符中事件的方法，runtime.netpollBreak 函数会向管道中写入数据唤醒 epoll：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">netpollBreak</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">b</span> <span class="kt">byte</span>
		<span class="nx">n</span> <span class="o">:=</span> <span class="nf">write</span><span class="p">(</span><span class="nx">netpollBreakWr</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="o">-</span><span class="nx">_EINTR</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="o">-</span><span class="nx">_EAGAIN</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>因为目前的计时器由网络轮询器管理和触发，它能够让网络轮询器立刻返回并让运行时检查是否有需要触发的计时器。</p>
<h3 id="轮询事件">轮询事件</h3>
<p>调用 internal/poll.pollDesc.init 初始化文件描述符时不只会初始化网络轮询器，还会通过 runtime.poll_runtime_pollOpen 函数重置轮询信息 runtime.pollDesc 并调用 runtime.netpollopen 初始化轮询事件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">runtime_pollOpen</span><span class="p">(</span><span class="nx">fd</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">(</span><span class="kt">uintptr</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span>
<span class="kd">func</span> <span class="nf">poll_runtime_pollOpen</span><span class="p">(</span><span class="nx">fd</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">pollDesc</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">pd</span> <span class="o">:=</span> <span class="nx">pollcache</span><span class="p">.</span><span class="nf">alloc</span><span class="p">()</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pd</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">wg</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">wg</span> <span class="o">!=</span> <span class="nx">pdReady</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: blocked write on free polldesc&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="o">...</span>
	<span class="nx">pd</span><span class="p">.</span><span class="nx">fd</span> <span class="p">=</span> <span class="nx">fd</span>
	<span class="nx">pd</span><span class="p">.</span><span class="nx">closing</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">pd</span><span class="p">.</span><span class="nx">everr</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="o">...</span>
	<span class="nx">pd</span><span class="p">.</span><span class="nx">wseq</span><span class="o">++</span>
	<span class="nx">pd</span><span class="p">.</span><span class="nx">wg</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">pd</span><span class="p">.</span><span class="nx">wd</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pd</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">errno</span> <span class="kt">int32</span>
	<span class="nx">errno</span> <span class="p">=</span> <span class="nf">netpollopen</span><span class="p">(</span><span class="nx">fd</span><span class="p">,</span> <span class="nx">pd</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">pd</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">errno</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime.netpollopen 的实现非常简单，它会调用 epollctl 向全局的轮询文件描述符 epfd 中加入新的轮询事件监听文件描述符的可读和可写状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// netpollopen 会被 runtime_pollOpen 调用，注册 fd 到 epoll 实例，
</span><span class="c1">// 注意这里使用的是 epoll 的 ET 模式，同时会利用万能指针把 pollDesc 保存到 epollevent 的一个 8 位的字节数组 data 里
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">netpollopen</span><span class="p">(</span><span class="nx">fd</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">pd</span> <span class="o">*</span><span class="nx">pollDesc</span><span class="p">)</span> <span class="kt">int32</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">ev</span> <span class="nx">epollevent</span>
	<span class="nx">ev</span><span class="p">.</span><span class="nx">events</span> <span class="p">=</span> <span class="nx">_EPOLLIN</span> <span class="p">|</span> <span class="nx">_EPOLLOUT</span> <span class="p">|</span> <span class="nx">_EPOLLRDHUP</span> <span class="p">|</span> <span class="nx">_EPOLLET</span>
	<span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="nx">pollDesc</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ev</span><span class="p">.</span><span class="nx">data</span><span class="p">))</span> <span class="p">=</span> <span class="nx">pd</span>
	<span class="k">return</span> <span class="o">-</span><span class="nf">epollctl</span><span class="p">(</span><span class="nx">epfd</span><span class="p">,</span> <span class="nx">_EPOLL_CTL_ADD</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">fd</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">ev</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从全局的 epfd 中删除待监听的文件描述符可以使用 runtime.netpollclose 函数，因为该函数的实现与 runtime.netpollopen 比较相似，所以这里就不展开分析了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:linkname poll_runtime_pollClose internal/poll.runtime_pollClose
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">poll_runtime_pollClose</span><span class="p">(</span><span class="nx">pd</span> <span class="o">*</span><span class="nx">pollDesc</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">pd</span><span class="p">.</span><span class="nx">closing</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: close polldesc w/o unblock&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">wg</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">wg</span> <span class="o">!=</span> <span class="nx">pdReady</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: blocked write on closing polldesc&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">rg</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">rg</span> <span class="o">!=</span> <span class="nx">pdReady</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: blocked read on closing polldesc&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">netpollclose</span><span class="p">(</span><span class="nx">pd</span><span class="p">.</span><span class="nx">fd</span><span class="p">)</span>
	<span class="nx">pollcache</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="nx">pd</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">netpollclose</span><span class="p">(</span><span class="nx">fd</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">int32</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">ev</span> <span class="nx">epollevent</span>
	<span class="k">return</span> <span class="o">-</span><span class="nf">epollctl</span><span class="p">(</span><span class="nx">epfd</span><span class="p">,</span> <span class="nx">_EPOLL_CTL_DEL</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">fd</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">ev</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="事件循环">事件循环</h3>
<p>本节将继续介绍网络轮询器的核心逻辑，也就是事件循环。我们将从以下的两个部分介绍事件循环的实现原理：</p>
<ul>
<li>Goroutine 让出线程并等待读写事件；</li>
<li>多路复用等待读写事件的发生并返回；</li>
</ul>
<p>上述过程连接了操作系统中的 I/O 多路复用机制和 Go 语言的运行时，在两个不同体系之间构建了桥梁，我们将分别介绍上述的两个过程。</p>
<h4 id="等待事件">等待事件</h4>
<p>当我们在文件描述符上执行读写操作时，如果文件描述符不可读或者不可写，当前 Goroutine 就会执行 runtime.poll_runtime_pollWait 检查 runtime.pollDesc 的状态并调用 runtime.netpollblock 等待文件描述符的可读或者可写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:linkname poll_runtime_pollWait internal/poll.runtime_pollWait
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">poll_runtime_pollWait</span><span class="p">(</span><span class="nx">pd</span> <span class="o">*</span><span class="nx">pollDesc</span><span class="p">,</span> <span class="nx">mode</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nf">netpollcheckerr</span><span class="p">(</span><span class="nx">pd</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">mode</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">pollNoError</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="c1">// As for now only Solaris, illumos, and AIX use level-triggered IO.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;solaris&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;illumos&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;aix&#34;</span> <span class="p">{</span>
		<span class="nf">netpollarm</span><span class="p">(</span><span class="nx">pd</span><span class="p">,</span> <span class="nx">mode</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 进入 netpollblock 并且判断是否有期待的 I/O 事件发生，
</span><span class="c1"></span>	<span class="c1">// 这里的 for 循环是为了一直等到 io ready
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">!</span><span class="nf">netpollblock</span><span class="p">(</span><span class="nx">pd</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">mode</span><span class="p">),</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="p">=</span> <span class="nf">netpollcheckerr</span><span class="p">(</span><span class="nx">pd</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">mode</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="c1">// Can happen if timeout has fired and unblocked us,
</span><span class="c1"></span>		<span class="c1">// but before we had a chance to run, timeout has been reset.
</span><span class="c1"></span>		<span class="c1">// Pretend it has not happened and retry.
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="c1">// returns true if IO is ready, or false if timedout or closed
</span><span class="c1">// waitio - wait only for completed IO, ignore errors
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">netpollblock</span><span class="p">(</span><span class="nx">pd</span> <span class="o">*</span><span class="nx">pollDesc</span><span class="p">,</span> <span class="nx">mode</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">waitio</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// gpp 保存的是 goroutine 的数据结构 g，这里会根据 mode 的值决定是 rg 还是 wg，
</span><span class="c1"></span>	<span class="c1">// 前面提到过，rg 和 wg 是用来保存等待 I/O 就绪的 gorouine 的，后面调用 gopark 之后，
</span><span class="c1"></span>	<span class="c1">// 会把当前的 goroutine 的抽象数据结构 g 存入 gpp 这个指针，也就是 rg 或者 wg
</span><span class="c1"></span>	<span class="nx">gpp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">pd</span><span class="p">.</span><span class="nx">rg</span>
	<span class="k">if</span> <span class="nx">mode</span> <span class="o">==</span> <span class="sc">&#39;w&#39;</span> <span class="p">{</span>
		<span class="nx">gpp</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">pd</span><span class="p">.</span><span class="nx">wg</span>
	<span class="p">}</span>

	<span class="c1">// set the gpp semaphore to WAIT
</span><span class="c1"></span>	<span class="c1">// 这个 for 循环是为了等待 io ready 或者 io wait
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">old</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">gpp</span>
		<span class="c1">// gpp == pdReady 表示此时已有期待的 I/O 事件发生，
</span><span class="c1"></span>		<span class="c1">// 可以直接返回 unblock 当前 goroutine 并执行响应的 I/O 操作
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">old</span> <span class="o">==</span> <span class="nx">pdReady</span> <span class="p">{</span>
			<span class="o">*</span><span class="nx">gpp</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">old</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: double wait&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 如果没有期待的 I/O 事件发生，则通过原子操作把 gpp 的值置为 pdWait 并退出 for 循环
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Casuintptr</span><span class="p">(</span><span class="nx">gpp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">pdWait</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// need to recheck error states after setting gpp to WAIT
</span><span class="c1"></span>	<span class="c1">// this is necessary because runtime_pollUnblock/runtime_pollSetDeadline/deadlineimpl
</span><span class="c1"></span>	<span class="c1">// do the opposite: store to closing/rd/wd, membarrier, load of rg/wg
</span><span class="c1"></span>
	<span class="c1">// waitio 此时是 false，netpollcheckerr 方法会检查当前 pollDesc 对应的 fd 是否是正常的，
</span><span class="c1"></span>	<span class="c1">// 通常来说  netpollcheckerr(pd, mode) == 0 是成立的，所以这里会执行 gopark
</span><span class="c1"></span>	<span class="c1">// 把当前 goroutine 给 park 住，直至对应的 fd 上发生可读/可写或者其他『期待的』I/O 事件为止，
</span><span class="c1"></span>	<span class="c1">// 然后 unpark 返回，在 gopark 内部会把当前 goroutine 的抽象数据结构 g 存入
</span><span class="c1"></span>	<span class="c1">// gpp(pollDesc.rg/pollDesc.wg) 指针里，以便在后面的 netpoll 函数取出 pollDesc 之后，
</span><span class="c1"></span>	<span class="c1">// 把 g 添加到链表里返回，接着重新调度 goroutine
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">waitio</span> <span class="o">||</span> <span class="nf">netpollcheckerr</span><span class="p">(</span><span class="nx">pd</span><span class="p">,</span> <span class="nx">mode</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 注册 netpollblockcommit 回调给 gopark，在 gopark 内部会执行它，保存当前 goroutine 到 gpp
</span><span class="c1"></span>		<span class="nf">gopark</span><span class="p">(</span><span class="nx">netpollblockcommit</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gpp</span><span class="p">),</span> <span class="nx">waitReasonIOWait</span><span class="p">,</span> <span class="nx">traceEvGoBlockNet</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// be careful to not lose concurrent READY notification
</span><span class="c1"></span>	<span class="nx">old</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xchguintptr</span><span class="p">(</span><span class="nx">gpp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">old</span> <span class="p">&gt;</span> <span class="nx">pdWait</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: corrupted polldesc&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">old</span> <span class="o">==</span> <span class="nx">pdReady</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>gopark 会停住当前的 goroutine 并且调用传递进来的回调函数 unlockf，从上面的源码我们可以知道这个函数是netpollblockcommit,调用 netpollblockcommit，把当前的 goroutine，也就是 g 数据结构保存到 pollDesc 的 rg 或者 wg 指针里</p>
<p>gopark 最终会调用 park_m，在这个函数内部会调用 unlockf，也就是 netpollblockcommit，然后会把当前的 goroutine，也就是 g 数据结构保存到 pollDesc 的 rg 或者 wg 指针里</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// netpollblockcommit 在 gopark 函数里被调用
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">netpollblockcommit</span><span class="p">(</span><span class="nx">gp</span><span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">gpp</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// 通过原子操作把当前 goroutine 抽象的数据结构 g，也就是这里的参数 gp 存入 gpp 指针，
</span><span class="c1"></span>	<span class="c1">// 此时 gpp 的值是 pollDesc 的 rg 或者 wg 指针
</span><span class="c1"></span>	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Casuintptr</span><span class="p">((</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">gpp</span><span class="p">),</span> <span class="nx">pdWait</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">)))</span>
	<span class="k">if</span> <span class="nx">r</span> <span class="p">{</span>
		<span class="c1">// Bump the count of goroutines waiting for the poller.
</span><span class="c1"></span>		<span class="c1">// The scheduler uses this to decide whether to block
</span><span class="c1"></span>		<span class="c1">// waiting for the poller if there is nothing else to do.
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollWaiters</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime.netpollblock 是 Goroutine 等待 I/O 事件的关键函数，它会使用运行时提供的 runtime.gopark 让出当前线程，将 Goroutine 转换到休眠状态并等待运行时的唤醒。</p>
<h4 id="轮询等待">轮询等待</h4>
<p>Go 语言的运行时会在调度或者系统监控中调用 runtime.netpoll 轮询网络，该函数的执行过程可以分成以下几个部分：</p>
<ol>
<li>根据调用方的入参 delay，设置对应的调用 epollwait 的 timeout 值；</li>
<li>调用 epollwait 等待发生了可读/可写事件的 fd；</li>
<li>循环 epollwait 返回的事件列表，处理对应的事件类型，组装可运行的 goroutine 链表并返回。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// netpoll checks for ready network connections.
</span><span class="c1">// Returns list of goroutines that become runnable.
</span><span class="c1">// delay &lt; 0: blocks indefinitely
</span><span class="c1">// delay == 0: does not block, just polls
</span><span class="c1">// delay &gt; 0: block for up to that many nanoseconds
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">netpoll</span><span class="p">(</span><span class="nx">delay</span> <span class="kt">int64</span><span class="p">)</span> <span class="nx">gList</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">epfd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">gList</span><span class="p">{}</span>
	<span class="p">}</span>

	<span class="c1">// 根据特定的规则把 delay 值转换为 epollwait 的 timeout 值
</span><span class="c1"></span>	<span class="c1">//因为传入 delay 的单位是纳秒，下面这段代码会将纳秒转换成毫秒：
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">waitms</span> <span class="kt">int32</span>
	<span class="k">if</span> <span class="nx">delay</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">waitms</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">delay</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">waitms</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">delay</span> <span class="p">&lt;</span> <span class="mf">1e6</span> <span class="p">{</span>
		<span class="nx">waitms</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">delay</span> <span class="p">&lt;</span> <span class="mf">1e15</span> <span class="p">{</span>
		<span class="nx">waitms</span> <span class="p">=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">delay</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// An arbitrary cap on how long to wait for a timer.
</span><span class="c1"></span>		<span class="c1">// 1e9 ms == ~11.5 days.
</span><span class="c1"></span>		<span class="nx">waitms</span> <span class="p">=</span> <span class="mf">1e9</span>
	<span class="p">}</span>
	<span class="c1">//计算了需要等待的时间之后，runtime.netpoll 会执行 epollwait 等待文件描述符转换成可读或者可写，如果该函数返回了负值，就可能返回空的 Goroutine 列表或者重新调用 epollwait 陷入等待：
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">events</span> <span class="p">[</span><span class="mi">128</span><span class="p">]</span><span class="nx">epollevent</span>
<span class="nx">retry</span><span class="p">:</span>
	<span class="c1">// 超时等待就绪的 fd 读写事件
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="nf">epollwait</span><span class="p">(</span><span class="nx">epfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">events</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">events</span><span class="p">)),</span> <span class="nx">waitms</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">n</span> <span class="o">!=</span> <span class="o">-</span><span class="nx">_EINTR</span> <span class="p">{</span>
			<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: epollwait on fd&#34;</span><span class="p">,</span> <span class="nx">epfd</span><span class="p">,</span> <span class="s">&#34;failed with&#34;</span><span class="p">,</span> <span class="o">-</span><span class="nx">n</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: netpoll failed&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// If a timed sleep was interrupted, just return to
</span><span class="c1"></span>		<span class="c1">// recalculate how long we should sleep now.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">waitms</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">gList</span><span class="p">{}</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="nx">retry</span>
	<span class="p">}</span>
	<span class="c1">//当 epollwait 函数返回的值大于 0 时，就意味着被监控的文件描述符出现了待处理的事件，我们在如下所示的循环中就会依次处理这些事件：
</span><span class="c1"></span>	<span class="c1">// toRun 是一个 g 的链表，存储要恢复的 goroutines，最后返回给调用方
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">toRun</span> <span class="nx">gList</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">ev</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">events</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">events</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="c1">// Go scheduler 在调用 findrunnable() 寻找 goroutine 去执行的时候，
</span><span class="c1"></span>		<span class="c1">// 在调用 netpoll 之时会检查当前是否有其他线程同步阻塞在 netpoll，
</span><span class="c1"></span>		<span class="c1">// 若是，则调用 netpollBreak 来唤醒那个线程，避免它长时间阻塞
</span><span class="c1"></span>		<span class="k">if</span> <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ev</span><span class="p">.</span><span class="nx">data</span><span class="p">))</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">netpollBreakRd</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">events</span> <span class="o">!=</span> <span class="nx">_EPOLLIN</span> <span class="p">{</span>
				<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: netpoll: break fd ready for&#34;</span><span class="p">,</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">events</span><span class="p">)</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: netpoll: break fd ready for something unexpected&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">delay</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// netpollBreak could be picked up by a
</span><span class="c1"></span>				<span class="c1">// nonblocking poll. Only read the byte
</span><span class="c1"></span>				<span class="c1">// if blocking.
</span><span class="c1"></span>				<span class="kd">var</span> <span class="nx">tmp</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="kt">byte</span>
				<span class="nf">read</span><span class="p">(</span><span class="nb">int32</span><span class="p">(</span><span class="nx">netpollBreakRd</span><span class="p">),</span> <span class="nf">noescape</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">tmp</span><span class="p">)))</span>
				<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollWakeSig</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="c1">// 判断发生的事件类型，读类型或者写类型等，然后给 mode 复制相应的值，
</span><span class="c1"></span>		<span class="c1">// mode 用来决定从 pollDesc 里的 rg 还是 wg 里取出 goroutine
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">mode</span> <span class="kt">int32</span>
		<span class="k">if</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">events</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">_EPOLLIN</span><span class="p">|</span><span class="nx">_EPOLLRDHUP</span><span class="p">|</span><span class="nx">_EPOLLHUP</span><span class="p">|</span><span class="nx">_EPOLLERR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">mode</span> <span class="o">+=</span> <span class="sc">&#39;r&#39;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">events</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">_EPOLLOUT</span><span class="p">|</span><span class="nx">_EPOLLHUP</span><span class="p">|</span><span class="nx">_EPOLLERR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">mode</span> <span class="o">+=</span> <span class="sc">&#39;w&#39;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">mode</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// 取出保存在 epollevent 里的 pollDesc
</span><span class="c1"></span>			<span class="nx">pd</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="nx">pollDesc</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ev</span><span class="p">.</span><span class="nx">data</span><span class="p">))</span>
			<span class="nx">pd</span><span class="p">.</span><span class="nx">everr</span> <span class="p">=</span> <span class="kc">false</span>
			<span class="k">if</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">events</span> <span class="o">==</span> <span class="nx">_EPOLLERR</span> <span class="p">{</span>
				<span class="nx">pd</span><span class="p">.</span><span class="nx">everr</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="p">}</span>
			<span class="c1">// 调用 netpollready，传入就绪 fd 的 pollDesc，
</span><span class="c1"></span>			<span class="c1">// 把 fd 对应的 goroutine 添加到链表 toRun 中
</span><span class="c1"></span>			<span class="nf">netpollready</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">toRun</span><span class="p">,</span> <span class="nx">pd</span><span class="p">,</span> <span class="nx">mode</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">toRun</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>处理的事件总共包含两种:</p>
<p>一种是调用 runtime.netpollBreak 函数触发的事件，该函数的作用是中断网络轮询器；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// netpollBreak 往通信管道里写入信号去唤醒 epollwait
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">netpollBreak</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 通过 CAS 避免重复的唤醒信号被写入管道，
</span><span class="c1"></span>	<span class="c1">// 从而减少系统调用并节省一些系统资源
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollWakeSig</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="nx">b</span> <span class="kt">byte</span>
			<span class="nx">n</span> <span class="o">:=</span> <span class="nf">write</span><span class="p">(</span><span class="nx">netpollBreakWr</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="o">-</span><span class="nx">_EINTR</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="o">-</span><span class="nx">_EAGAIN</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: netpollBreak write failed with&#34;</span><span class="p">,</span> <span class="o">-</span><span class="nx">n</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: netpollBreak write failed&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>另一种是其他文件描述符的正常读写事件，对于这些事件，我们会交给 runtime.netpollready 处理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// netpollready 调用 netpollunblock 返回就绪 fd 对应的 goroutine 的抽象数据结构 g
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">netpollready</span><span class="p">(</span><span class="nx">toRun</span> <span class="o">*</span><span class="nx">gList</span><span class="p">,</span> <span class="nx">pd</span><span class="o">*</span><span class="nx">pollDesc</span><span class="p">,</span> <span class="nx">mode</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">rg</span><span class="p">,</span> <span class="nx">wg</span> <span class="o">*</span><span class="nx">g</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nx">mode</span> <span class="o">==</span> <span class="sc">&#39;w&#39;</span> <span class="o">||</span> <span class="nx">mode</span> <span class="o">==</span> <span class="sc">&#39;r&#39;</span><span class="o">+</span><span class="sc">&#39;w&#39;</span> <span class="p">{</span>
		<span class="nx">wg</span> <span class="p">=</span> <span class="nf">netpollunblock</span><span class="p">(</span><span class="nx">pd</span><span class="p">,</span> <span class="sc">&#39;w&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nx">wg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">toRun</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">wg</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime.netpollunblock 会在读写事件发生时，将 runtime.pollDesc 中的读或者写信号量转换成 pdReady 并返回其中存储的 Goroutine；如果返回的 Goroutine 不会为空，那么该 Goroutine 就会被加入 toRun 列表，运行时会将列表中的全部 Goroutine 加入运行队列并等待调度器的调度。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// netpollunblock 会依据传入的 mode 决定从 pollDesc 的 rg 或者 wg 取出当时 gopark 之时存入的
</span><span class="c1">// goroutine 抽象数据结构 g 并返回
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">netpollunblock</span><span class="p">(</span><span class="nx">pd</span> <span class="o">*</span><span class="nx">pollDesc</span><span class="p">,</span> <span class="nx">mode</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">ioready</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
	<span class="c1">// mode == &#39;r&#39; 代表当时 gopark 是为了等待读事件，而 mode == &#39;w&#39; 则代表是等待写事件
</span><span class="c1"></span>	<span class="nx">gpp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">pd</span><span class="p">.</span><span class="nx">rg</span>
	<span class="k">if</span> <span class="nx">mode</span> <span class="o">==</span> <span class="sc">&#39;w&#39;</span> <span class="p">{</span>
		<span class="nx">gpp</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">pd</span><span class="p">.</span><span class="nx">wg</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// 取出 gpp 存储的 g
</span><span class="c1"></span>		<span class="nx">old</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">gpp</span>
		<span class="k">if</span> <span class="nx">old</span> <span class="o">==</span> <span class="nx">pdReady</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">old</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">ioready</span> <span class="p">{</span>
			<span class="c1">// Only set READY for ioready. runtime_pollWait
</span><span class="c1"></span>			<span class="c1">// will check for timeout/cancel before waiting.
</span><span class="c1"></span>			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="kd">var</span> <span class="nx">new</span> <span class="kt">uintptr</span>
		<span class="k">if</span> <span class="nx">ioready</span> <span class="p">{</span>
			<span class="nx">new</span> <span class="p">=</span> <span class="nx">pdReady</span>
		<span class="p">}</span>
		<span class="c1">// 重置 pollDesc 的 rg 或者 wg
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Casuintptr</span><span class="p">(</span><span class="nx">gpp</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">new</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 如果该 goroutine 还是必须等待，则返回 nil
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">old</span> <span class="o">==</span> <span class="nx">pdWait</span> <span class="p">{</span>
				<span class="nx">old</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="p">}</span>
			<span class="c1">// 通过万能指针还原成 g 并返回
</span><span class="c1"></span>			<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">g</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">old</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>netpoll 里会调用 epoll_wait 从 epoll 的 eventpoll.rdllist 就绪双向链表返回，从而得到 I/O 就绪的 socket fd 列表，并根据取出最初调用 epoll_ctl 时保存的上下文信息，恢复 g。所以执行完netpoll 之后，会返回一个就绪 fd 列表对应的 goroutine 链表.</p>
<p>runtime.netpoll 函数返回的 Goroutine 列表都会被 runtime.injectglist 注入到处理器或者全局的运行队列上，其中因为系统监控 Goroutine 直接运行在线程上，所以它获取的 Goroutine 列表会直接加入全局的运行队列，其他 Goroutine 获取的列表都会加入 Goroutine 所在处理器的运行队列上。</p>
<p>netpoll 通过 park goroutine 从而达到阻塞 Accept/Read/Write 的效果，而通过调用 gopark，goroutine 会被放置在某个等待队列中，这里是放到了 epoll 的 &ldquo;interest list&rdquo; 里，底层数据结构是由红黑树实现的 eventpoll.rbr，此时 G 的状态由 _Grunning为_Gwaitting ，因此 G 必须被手动唤醒(通过 goready )，否则会丢失任务，应用层阻塞通常使用这种方式。</p>
<p>Go 在多种场景下都可能会调用 netpoll 检查文件描述符状态:</p>
<ol>
<li>在 Go runtime scheduler 的核心方法 runtime.schedule() 里会调用一个叫 runtime.findrunable() 的方法获取可运行的 goroutine 来执行，而在 runtime.findrunable() 方法里就调用了 runtime.netpoll 获取已就绪的 fd 列表对应的 goroutine 列表</li>
<li>sysmon 监控线程会在循环过程中检查距离上一次 runtime.netpoll 被调用是否超过了 10ms，若是则会去调用它拿到可运行的 goroutine 列表并通过调用 injectglist 把 g 列表放入全局调度队列或者当前 P 本地调度队列等待被执行.</li>
</ol>
<h4 id="截止日期">截止日期</h4>
<p>网络轮询器和计时器的关系非常紧密，这不仅仅是因为网络轮询器负责计时器的唤醒，还因为文件和网络 I/O 的截止日期也由网络轮询器负责处理。截止日期在 I/O 操作中，尤其是网络调用中很关键，网络请求存在很高的不确定因素，我们需要设置一个截止日期保证程序的正常运行，这时就需要用到网络轮询器中的 runtime.poll_runtime_pollSetDeadline 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">poll_runtime_pollSetDeadline</span><span class="p">(</span><span class="nx">pd</span> <span class="o">*</span><span class="nx">pollDesc</span><span class="p">,</span> <span class="nx">d</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">mode</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rd0</span><span class="p">,</span> <span class="nx">wd0</span> <span class="o">:=</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">rd</span><span class="p">,</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">wd</span>
	<span class="k">if</span> <span class="nx">d</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">d</span> <span class="o">+=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">pd</span><span class="p">.</span><span class="nx">rd</span> <span class="p">=</span> <span class="nx">d</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">rt</span><span class="p">.</span><span class="nx">f</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">rd</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">pd</span><span class="p">.</span><span class="nx">rt</span><span class="p">.</span><span class="nx">f</span> <span class="p">=</span> <span class="nx">netpollReadDeadline</span>
			<span class="nx">pd</span><span class="p">.</span><span class="nx">rt</span><span class="p">.</span><span class="nx">arg</span> <span class="p">=</span> <span class="nx">pd</span>
			<span class="nx">pd</span><span class="p">.</span><span class="nx">rt</span><span class="p">.</span><span class="nx">seq</span> <span class="p">=</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">rseq</span>
			<span class="nf">resettimer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pd</span><span class="p">.</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">rd</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">rd</span> <span class="o">!=</span> <span class="nx">rd0</span> <span class="p">{</span>
		<span class="nx">pd</span><span class="p">.</span><span class="nx">rseq</span><span class="o">++</span>
		<span class="k">if</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">rd</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">modtimer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pd</span><span class="p">.</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">rd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">rtf</span><span class="p">,</span> <span class="nx">pd</span><span class="p">,</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">rseq</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">deltimer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pd</span><span class="p">.</span><span class="nx">rt</span><span class="p">)</span>
			<span class="nx">pd</span><span class="p">.</span><span class="nx">rt</span><span class="p">.</span><span class="nx">f</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该函数会先使用截止日期计算出过期的时间点，然后根据 runtime.pollDesc 的状态做出以下不同的处理：</p>
<ol>
<li>如果结构体中的计时器没有设置执行的函数时，该函数会设置计时器到期后执行的函数、传入的参数并调用 runtime.resettimer 重置计时器；</li>
<li>如果结构体的读截止日期已经被改变，我们会根据新的截止日期做出不同的处理：
<ol>
<li>如果新的截止日期大于 0，调用 runtime.modtimer 修改计时器；</li>
<li>如果新的截止日期小于 0，调用 runtime.deltimer 删除计时器；</li>
</ol>
</li>
</ol>
<p>在 runtime.poll_runtime_pollSetDeadline 函数的最后，会重新检查轮询信息中存储的截止日期：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">	<span class="kd">var</span> <span class="nx">rg</span> <span class="o">*</span><span class="nx">g</span>
	<span class="k">if</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">rd</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">rd</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">rg</span> <span class="p">=</span> <span class="nf">netpollunblock</span><span class="p">(</span><span class="nx">pd</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="o">...</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">rg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">netpollgoready</span><span class="p">(</span><span class="nx">rg</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果截止日期小于 0，上述代码会调用 runtime.netpollgoready 直接唤醒对应的 Goroutine。</p>
<p>在 runtime.poll_runtime_pollSetDeadline 函数中直接调用 runtime.netpollgoready 是相对比较特殊的情况。在正常情况下，运行时都会在计时器到期时调用 runtime.netpollDeadline、runtime.netpollReadDeadline 和 runtime.netpollWriteDeadline 三个函数：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201119224335.png" alt=""></p>
<p>上述三个函数都会通过 runtime.netpolldeadlineimpl 调用 runtime.netpollgoready 直接唤醒相应的 Goroutine:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">netpolldeadlineimpl</span><span class="p">(</span><span class="nx">pd</span> <span class="o">*</span><span class="nx">pollDesc</span><span class="p">,</span> <span class="nx">seq</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">read</span><span class="p">,</span> <span class="nx">write</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">currentSeq</span> <span class="o">:=</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">rseq</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">read</span> <span class="p">{</span>
		<span class="nx">currentSeq</span> <span class="p">=</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">wseq</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">seq</span> <span class="o">!=</span> <span class="nx">currentSeq</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
<span class="kd">var</span> <span class="nx">rg</span> <span class="o">*</span><span class="nx">g</span>
	<span class="k">if</span> <span class="nx">read</span> <span class="p">{</span>
		<span class="nx">pd</span><span class="p">.</span><span class="nx">rd</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">StorepNoWB</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pd</span><span class="p">.</span><span class="nx">rt</span><span class="p">.</span><span class="nx">f</span><span class="p">),</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="nx">rg</span> <span class="p">=</span> <span class="nf">netpollunblock</span><span class="p">(</span><span class="nx">pd</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nx">rg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">netpollgoready</span><span class="p">(</span><span class="nx">rg</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Goroutine 在被唤醒之后就会意识到当前的 I/O 操作已经超时，可以根据需要选择重试请求或者中止调用。</p>
<h2 id="tcp-server">TCP Server</h2>
<p>使用 Go 编写一个典型的 TCP echo server:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">listen</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:8888&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;listen error: &#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">listen</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;accept error: &#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="k">break</span>
		<span class="p">}</span>

		<span class="c1">// start a new goroutine to handle the new connection.
</span><span class="c1"></span>		<span class="k">go</span> <span class="nf">HandleConn</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">HandleConn</span><span class="p">(</span><span class="nx">conn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="nx">packet</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// block here if socket is not available for reading data.
</span><span class="c1"></span>		<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">packet</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;read socket error: &#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="c1">// same as above, block here if socket is not available for writing.
</span><span class="c1"></span>		<span class="nx">_</span><span class="p">,</span><span class="nx">_</span> <span class="p">=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">packet</span><span class="p">[:</span><span class="nx">n</span><span class="p">])</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面是一个基于 Go 原生网络模型（基于 netpoller）编写的一个 TCP server，模式是 goroutine-per-connection ，在这种模式下，开发者使用的是同步的模式去编写异步的逻辑而且对于开发者来说 I/O 是否阻塞是无感知的，也就是说开发者无需考虑 goroutines 甚至更底层的线程、进程的调度和上下文切换。而 Go netpoller 最底层的事件驱动技术肯定是基于 epoll/kqueue/iocp 这一类的 I/O 事件驱动技术，只不过是把这些调度和上下文切换的工作转移到了 runtime 的 Go scheduler，让它来负责调度 goroutines，从而极大地降低了程序员的心智负担！</p>
<p>Go 的这种同步模式的网络服务器的基本架构通常如下：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201119150735.png" alt=""></p>
<p>上面的示例代码中相关的在源码里的几个数据结构和方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// TCPListener is a TCP network listener. Clients should typically
</span><span class="c1">// use variables of type Listener instead of assuming TCP.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">TCPListener</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">fd</span> <span class="o">*</span><span class="nx">netFD</span>
	<span class="nx">lc</span> <span class="nx">ListenConfig</span>
<span class="p">}</span>

<span class="c1">// Accept implements the Accept method in the Listener interface; it
</span><span class="c1">// waits for the next call and returns a generic Conn.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span><span class="o">*</span><span class="nx">TCPListener</span><span class="p">)</span> <span class="nf">Accept</span><span class="p">()</span> <span class="p">(</span><span class="nx">Conn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">l</span><span class="p">.</span><span class="nf">ok</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EINVAL</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">accept</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">OpError</span><span class="p">{</span><span class="nx">Op</span><span class="p">:</span> <span class="s">&#34;accept&#34;</span><span class="p">,</span> <span class="nx">Net</span><span class="p">:</span> <span class="nx">l</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nx">net</span><span class="p">,</span> <span class="nx">Source</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">Addr</span><span class="p">:</span> <span class="nx">l</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nx">laddr</span><span class="p">,</span> <span class="nx">Err</span><span class="p">:</span> <span class="nx">err</span><span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ln</span> <span class="o">*</span><span class="nx">TCPListener</span><span class="p">)</span> <span class="nf">accept</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">TCPConn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fd</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nf">accept</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">tc</span> <span class="o">:=</span> <span class="nf">newTCPConn</span><span class="p">(</span><span class="nx">fd</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">lc</span><span class="p">.</span><span class="nx">KeepAlive</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">setKeepAlive</span><span class="p">(</span><span class="nx">fd</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
		<span class="nx">ka</span> <span class="o">:=</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">lc</span><span class="p">.</span><span class="nx">KeepAlive</span>
		<span class="k">if</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">lc</span><span class="p">.</span><span class="nx">KeepAlive</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">ka</span> <span class="p">=</span> <span class="nx">defaultTCPKeepAlive</span>
		<span class="p">}</span>
		<span class="nf">setKeepAlivePeriod</span><span class="p">(</span><span class="nx">fd</span><span class="p">,</span> <span class="nx">ka</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">tc</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// TCPConn is an implementation of the Conn interface for TCP network
</span><span class="c1">// connections.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">TCPConn</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">conn</span>
<span class="p">}</span>

<span class="c1">// Conn
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">conn</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">fd</span> <span class="o">*</span><span class="nx">netFD</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">conn</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">fd</span><span class="o">*</span><span class="nx">netFD</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">conn</span><span class="p">)</span> <span class="nf">ok</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">}</span>

<span class="c1">// Implementation of the Conn interface.
</span><span class="c1"></span>
<span class="c1">// Read implements the Conn Read method.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span><span class="o">*</span><span class="nx">conn</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nf">ok</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EINVAL</span>
	<span class="p">}</span>
	<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">OpError</span><span class="p">{</span><span class="nx">Op</span><span class="p">:</span> <span class="s">&#34;read&#34;</span><span class="p">,</span> <span class="nx">Net</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nx">net</span><span class="p">,</span> <span class="nx">Source</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nx">laddr</span><span class="p">,</span> <span class="nx">Addr</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nx">raddr</span><span class="p">,</span> <span class="nx">Err</span><span class="p">:</span> <span class="nx">err</span><span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="c1">// Write implements the Conn Write method.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">conn</span><span class="p">)</span> <span class="nf">Write</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nf">ok</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EINVAL</span>
	<span class="p">}</span>
	<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">OpError</span><span class="p">{</span><span class="nx">Op</span><span class="p">:</span> <span class="s">&#34;write&#34;</span><span class="p">,</span> <span class="nx">Net</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nx">net</span><span class="p">,</span> <span class="nx">Source</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nx">laddr</span><span class="p">,</span> <span class="nx">Addr</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nx">raddr</span><span class="p">,</span> <span class="nx">Err</span><span class="p">:</span> <span class="nx">err</span><span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="netfd">netFD</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:8888&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>方法返回了一个 <code>*TCPListener</code>，它是一个实现了 net.Listener 接口的 struct，而通过 listener.Accept() 接收的新连接*TCPConn 则是一个实现了 net.Conn 接口的 struct，它内嵌了 net.conn struct。</p>
<p>仔细阅读上面的源码可以发现，不管是 Listener 的 Accept 还是 Conn 的 Read/Write 方法，都是基于一个 netFD 的数据结构的操作， netFD 是一个网络描述符，类似于 Linux 的文件描述符的概念，netFD 中包含一个 poll.FD 数据结构，而 poll.FD 中包含两个重要的数据结构 Sysfd 和 pollDesc，前者是真正的系统文件描述符，后者对是底层事件驱动的封装，所有的读写超时等操作都是通过调用后者的对应方法实现的。</p>
<p>netFD 和 poll.FD 的源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// Network file descriptor.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">netFD</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">pfd</span> <span class="nx">poll</span><span class="p">.</span><span class="nx">FD</span>

	<span class="c1">// immutable until Close
</span><span class="c1"></span>	<span class="nx">family</span>      <span class="kt">int</span>
	<span class="nx">sotype</span>      <span class="kt">int</span>
	<span class="nx">isConnected</span> <span class="kt">bool</span> <span class="c1">// handshake completed or use of association with peer
</span><span class="c1"></span>	<span class="nx">net</span>         <span class="kt">string</span>
	<span class="nx">laddr</span>       <span class="nx">Addr</span>
	<span class="nx">raddr</span>       <span class="nx">Addr</span>
<span class="p">}</span>

<span class="c1">// FD is a file descriptor. The net and os packages use this type as a
</span><span class="c1">// field of a larger type representing a network connection or OS file.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">FD</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Lock sysfd and serialize access to Read and Write methods.
</span><span class="c1"></span>	<span class="nx">fdmu</span> <span class="nx">fdMutex</span>

	<span class="c1">// System file descriptor. Immutable until Close.
</span><span class="c1"></span>	<span class="nx">Sysfd</span> <span class="kt">int</span>

	<span class="c1">// I/O poller.
</span><span class="c1"></span>	<span class="nx">pd</span> <span class="nx">pollDesc</span>

	<span class="c1">// Writev cache.
</span><span class="c1"></span>	<span class="nx">iovecs</span> <span class="o">*</span><span class="p">[]</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">Iovec</span>

	<span class="c1">// Semaphore signaled when file is closed.
</span><span class="c1"></span>	<span class="nx">csema</span> <span class="kt">uint32</span>

	<span class="c1">// Non-zero if this file has been set to blocking mode.
</span><span class="c1"></span>	<span class="nx">isBlocking</span> <span class="kt">uint32</span>

	<span class="c1">// Whether this is a streaming descriptor, as opposed to a
</span><span class="c1"></span>	<span class="c1">// packet-based descriptor like a UDP socket. Immutable.
</span><span class="c1"></span>	<span class="nx">IsStream</span> <span class="kt">bool</span>

	<span class="c1">// Whether a zero byte read indicates EOF. This is false for a
</span><span class="c1"></span>	<span class="c1">// message based socket connection.
</span><span class="c1"></span>	<span class="nx">ZeroReadIsEOF</span> <span class="kt">bool</span>

	<span class="c1">// Whether this is a file rather than a network socket.
</span><span class="c1"></span>	<span class="nx">isFile</span> <span class="kt">bool</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h3 id="netlisten">net.Listen</h3>
<p>调用 net.Listen 之后，底层调用 Linux 的系统调用 socket.</p>
<p>socket方法创建一个 fd 分配给 listener，并用以来初始化 listener 的 netFD ，接着调用 netFD 的 listenStream 方法完成对 socket 的 bind&amp;listen 操作以及对 netFD 的初始化（主要是对 netFD 里的 pollDesc 的初始化），调用链是 <code>runtime.runtime_pollServerInit --&gt; runtime.poll_runtime_pollServerInit --&gt; runtime.netpollGenericInit</code>.</p>
<p>runtime.netpollGenericInit 会调用平台上特定实现的 runtime.netpollinit 函数，即 Linux 上的 epoll，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Listen</span><span class="p">(</span><span class="nx">network</span><span class="p">,</span> <span class="nx">address</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Listener</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">lc</span> <span class="nx">ListenConfig</span>
	<span class="k">return</span> <span class="nx">lc</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">network</span><span class="p">,</span> <span class="nx">address</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Listen announces on the local network address.
</span><span class="c1">//
</span><span class="c1">// See func Listen for a description of the network and address
</span><span class="c1">// parameters.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">lc</span> <span class="o">*</span><span class="nx">ListenConfig</span><span class="p">)</span> <span class="nf">Listen</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">network</span><span class="p">,</span> <span class="nx">address</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Listener</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">addrs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">DefaultResolver</span><span class="p">.</span><span class="nf">resolveAddrList</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;listen&#34;</span><span class="p">,</span> <span class="nx">network</span><span class="p">,</span> <span class="nx">address</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">OpError</span><span class="p">{</span><span class="nx">Op</span><span class="p">:</span> <span class="s">&#34;listen&#34;</span><span class="p">,</span> <span class="nx">Net</span><span class="p">:</span> <span class="nx">network</span><span class="p">,</span> <span class="nx">Source</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">Addr</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">Err</span><span class="p">:</span> <span class="nx">err</span><span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">sl</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sysListener</span><span class="p">{</span>
		<span class="nx">ListenConfig</span><span class="p">:</span> <span class="o">*</span><span class="nx">lc</span><span class="p">,</span>
		<span class="nx">network</span><span class="p">:</span>      <span class="nx">network</span><span class="p">,</span>
		<span class="nx">address</span><span class="p">:</span>      <span class="nx">address</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">l</span> <span class="nx">Listener</span>
	<span class="nx">la</span> <span class="o">:=</span> <span class="nx">addrs</span><span class="p">.</span><span class="nf">first</span><span class="p">(</span><span class="nx">isIPv4</span><span class="p">)</span>
	<span class="k">switch</span> <span class="nx">la</span> <span class="o">:=</span> <span class="nx">la</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">*</span><span class="nx">TCPAddr</span><span class="p">:</span>
		<span class="nx">l</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">sl</span><span class="p">.</span><span class="nf">listenTCP</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">la</span><span class="p">)</span>
	<span class="k">case</span> <span class="o">*</span><span class="nx">UnixAddr</span><span class="p">:</span>
		<span class="nx">l</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">sl</span><span class="p">.</span><span class="nf">listenUnix</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">la</span><span class="p">)</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">OpError</span><span class="p">{</span><span class="nx">Op</span><span class="p">:</span> <span class="s">&#34;listen&#34;</span><span class="p">,</span> <span class="nx">Net</span><span class="p">:</span> <span class="nx">sl</span><span class="p">.</span><span class="nx">network</span><span class="p">,</span> <span class="nx">Source</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">Addr</span><span class="p">:</span> <span class="nx">la</span><span class="p">,</span> <span class="nx">Err</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">AddrError</span><span class="p">{</span><span class="nx">Err</span><span class="p">:</span> <span class="s">&#34;unexpected address type&#34;</span><span class="p">,</span> <span class="nx">Addr</span><span class="p">:</span> <span class="nx">address</span><span class="p">}}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">OpError</span><span class="p">{</span><span class="nx">Op</span><span class="p">:</span> <span class="s">&#34;listen&#34;</span><span class="p">,</span> <span class="nx">Net</span><span class="p">:</span> <span class="nx">sl</span><span class="p">.</span><span class="nx">network</span><span class="p">,</span> <span class="nx">Source</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">Addr</span><span class="p">:</span> <span class="nx">la</span><span class="p">,</span> <span class="nx">Err</span><span class="p">:</span> <span class="nx">err</span><span class="p">}</span> <span class="c1">// l is non-nil interface containing nil pointer
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">l</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sl</span> <span class="o">*</span><span class="nx">sysListener</span><span class="p">)</span> <span class="nf">listenTCP</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">laddr</span> <span class="o">*</span><span class="nx">TCPAddr</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">TCPListener</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fd</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">internetSocket</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">sl</span><span class="p">.</span><span class="nx">network</span><span class="p">,</span> <span class="nx">laddr</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;listen&#34;</span><span class="p">,</span> <span class="nx">sl</span><span class="p">.</span><span class="nx">ListenConfig</span><span class="p">.</span><span class="nx">Control</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">TCPListener</span><span class="p">{</span><span class="nx">fd</span><span class="p">:</span> <span class="nx">fd</span><span class="p">,</span> <span class="nx">lc</span><span class="p">:</span> <span class="nx">sl</span><span class="p">.</span><span class="nx">ListenConfig</span><span class="p">},</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">internetSocket</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">net</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">laddr</span><span class="p">,</span> <span class="nx">raddr</span> <span class="nx">sockaddr</span><span class="p">,</span> <span class="nx">sotype</span><span class="p">,</span> <span class="nx">proto</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">mode</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ctrlFn</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">RawConn</span><span class="p">)</span> <span class="kt">error</span><span class="p">)</span> <span class="p">(</span><span class="nx">fd</span> <span class="o">*</span><span class="nx">netFD</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;aix&#34;</span> <span class="o">||</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;windows&#34;</span> <span class="o">||</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;openbsd&#34;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">mode</span> <span class="o">==</span> <span class="s">&#34;dial&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">raddr</span><span class="p">.</span><span class="nf">isWildcard</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">raddr</span> <span class="p">=</span> <span class="nx">raddr</span><span class="p">.</span><span class="nf">toLocal</span><span class="p">(</span><span class="nx">net</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">family</span><span class="p">,</span> <span class="nx">ipv6only</span> <span class="o">:=</span> <span class="nf">favoriteAddrFamily</span><span class="p">(</span><span class="nx">net</span><span class="p">,</span> <span class="nx">laddr</span><span class="p">,</span> <span class="nx">raddr</span><span class="p">,</span> <span class="nx">mode</span><span class="p">)</span>
	<span class="k">return</span> <span class="nf">socket</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">net</span><span class="p">,</span> <span class="nx">family</span><span class="p">,</span> <span class="nx">sotype</span><span class="p">,</span> <span class="nx">proto</span><span class="p">,</span> <span class="nx">ipv6only</span><span class="p">,</span> <span class="nx">laddr</span><span class="p">,</span> <span class="nx">raddr</span><span class="p">,</span> <span class="nx">ctrlFn</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// socket returns a network file descriptor that is ready for
</span><span class="c1">// asynchronous I/O using the network poller.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">socket</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">net</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">family</span><span class="p">,</span> <span class="nx">sotype</span><span class="p">,</span> <span class="nx">proto</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">ipv6only</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">laddr</span><span class="p">,</span> <span class="nx">raddr</span> <span class="nx">sockaddr</span><span class="p">,</span> <span class="nx">ctrlFn</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">RawConn</span><span class="p">)</span> <span class="kt">error</span><span class="p">)</span> <span class="p">(</span><span class="nx">fd</span> <span class="o">*</span><span class="nx">netFD</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">s</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">sysSocket</span><span class="p">(</span><span class="nx">family</span><span class="p">,</span> <span class="nx">sotype</span><span class="p">,</span> <span class="nx">proto</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">setDefaultSockopts</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">family</span><span class="p">,</span> <span class="nx">sotype</span><span class="p">,</span> <span class="nx">ipv6only</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">poll</span><span class="p">.</span><span class="nf">CloseFunc</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="c1">// 用上面创建的 listener fd 初始化 listener netFD
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">fd</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">newFD</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">family</span><span class="p">,</span> <span class="nx">sotype</span><span class="p">,</span> <span class="nx">net</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">poll</span><span class="p">.</span><span class="nf">CloseFunc</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="c1">// This function makes a network file descriptor for the
</span><span class="c1"></span>	<span class="c1">// following applications:
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// - An endpoint holder that opens a passive stream
</span><span class="c1"></span>	<span class="c1">//   connection, known as a stream listener
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// - An endpoint holder that opens a destination-unspecific
</span><span class="c1"></span>	<span class="c1">//   datagram connection, known as a datagram listener
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// - An endpoint holder that opens an active stream or a
</span><span class="c1"></span>	<span class="c1">//   destination-specific datagram connection, known as a
</span><span class="c1"></span>	<span class="c1">//   dialer
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// - An endpoint holder that opens the other connection, such
</span><span class="c1"></span>	<span class="c1">//   as talking to the protocol stack inside the kernel
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For stream and datagram listeners, they will only require
</span><span class="c1"></span>	<span class="c1">// named sockets, so we can assume that it&#39;s just a request
</span><span class="c1"></span>	<span class="c1">// from stream or datagram listeners when laddr is not nil but
</span><span class="c1"></span>	<span class="c1">// raddr is nil. Otherwise we assume it&#39;s just for dialers or
</span><span class="c1"></span>	<span class="c1">// the other connection holders.
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nx">laddr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">raddr</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="nx">sotype</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SOCK_STREAM</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SOCK_SEQPACKET</span><span class="p">:</span>
			<span class="c1">// 对 listener fd 进行 bind&amp;listen 操作，并且调用 init 方法完成初始化
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fd</span><span class="p">.</span><span class="nf">listenStream</span><span class="p">(</span><span class="nx">laddr</span><span class="p">,</span> <span class="nf">listenerBacklog</span><span class="p">(),</span> <span class="nx">ctrlFn</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">fd</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nx">fd</span><span class="p">,</span> <span class="kc">nil</span>
		<span class="k">case</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SOCK_DGRAM</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fd</span><span class="p">.</span><span class="nf">listenDatagram</span><span class="p">(</span><span class="nx">laddr</span><span class="p">,</span> <span class="nx">ctrlFn</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">fd</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nx">fd</span><span class="p">,</span> <span class="kc">nil</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fd</span><span class="p">.</span><span class="nf">dial</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">laddr</span><span class="p">,</span> <span class="nx">raddr</span><span class="p">,</span> <span class="nx">ctrlFn</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fd</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">fd</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">testHookDialChannel</span>  <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// for golang.org/issue/5349
</span><span class="c1"></span>	<span class="nx">testHookCanceledDial</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// for golang.org/issue/16523
</span><span class="c1"></span>
	<span class="c1">// Placeholders for socket system calls.
</span><span class="c1"></span>	<span class="nx">socketFunc</span>        <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>  <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">Socket</span>
	<span class="nx">connectFunc</span>       <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">Sockaddr</span><span class="p">)</span> <span class="kt">error</span> <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">Connect</span>
	<span class="nx">listenFunc</span>        <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">error</span>              <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">Listen</span>
	<span class="nx">getsockoptIntFunc</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>  <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">GetsockoptInt</span>
<span class="p">)</span>
<span class="c1">// Wrapper around the socket system call that marks the returned file
</span><span class="c1">// descriptor as nonblocking and close-on-exec.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sysSocket</span><span class="p">(</span><span class="nx">family</span><span class="p">,</span> <span class="nx">sotype</span><span class="p">,</span> <span class="nx">proto</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 调用 linux 系统调用 socket 创建 listener fd 并设置为为阻塞 I/O
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">socketFunc</span><span class="p">(</span><span class="nx">family</span><span class="p">,</span> <span class="nx">sotype</span><span class="p">|</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">SOCK_NONBLOCK</span><span class="p">|</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">SOCK_CLOEXEC</span><span class="p">,</span> <span class="nx">proto</span><span class="p">)</span>
	<span class="c1">// On Linux the SOCK_NONBLOCK and SOCK_CLOEXEC flags were
</span><span class="c1"></span>	<span class="c1">// introduced in 2.6.27 kernel and on FreeBSD both flags were
</span><span class="c1"></span>	<span class="c1">// introduced in 10 kernel. If we get an EINVAL error on Linux
</span><span class="c1"></span>	<span class="c1">// or EPROTONOSUPPORT error on FreeBSD, fall back to using
</span><span class="c1"></span>	<span class="c1">// socket without them.
</span><span class="c1"></span>	<span class="k">switch</span> <span class="nx">err</span> <span class="p">{</span>
	<span class="k">case</span> <span class="kc">nil</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">s</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nf">NewSyscallError</span><span class="p">(</span><span class="s">&#34;socket&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EPROTONOSUPPORT</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EINVAL</span><span class="p">:</span>
	<span class="p">}</span>

	<span class="c1">// See ../syscall/exec_unix.go for description of ForkLock.
</span><span class="c1"></span>	<span class="nx">syscall</span><span class="p">.</span><span class="nx">ForkLock</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
	<span class="nx">s</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">socketFunc</span><span class="p">(</span><span class="nx">family</span><span class="p">,</span> <span class="nx">sotype</span><span class="p">,</span> <span class="nx">proto</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">syscall</span><span class="p">.</span><span class="nf">CloseOnExec</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">syscall</span><span class="p">.</span><span class="nx">ForkLock</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nf">NewSyscallError</span><span class="p">(</span><span class="s">&#34;socket&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">SetNonblock</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">poll</span><span class="p">.</span><span class="nf">CloseFunc</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nf">NewSyscallError</span><span class="p">(</span><span class="s">&#34;setnonblock&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">s</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">newFD</span><span class="p">(</span><span class="nx">sysfd</span><span class="p">,</span> <span class="nx">family</span><span class="p">,</span> <span class="nx">sotype</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">net</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">netFD</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">netFD</span><span class="p">{</span>
		<span class="nx">pfd</span><span class="p">:</span> <span class="nx">poll</span><span class="p">.</span><span class="nx">FD</span><span class="p">{</span>
			<span class="nx">Sysfd</span><span class="p">:</span>         <span class="nx">sysfd</span><span class="p">,</span>
			<span class="nx">IsStream</span><span class="p">:</span>      <span class="nx">sotype</span> <span class="o">==</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SOCK_STREAM</span><span class="p">,</span>
			<span class="nx">ZeroReadIsEOF</span><span class="p">:</span> <span class="nx">sotype</span> <span class="o">!=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SOCK_DGRAM</span> <span class="o">&amp;&amp;</span> <span class="nx">sotype</span> <span class="o">!=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SOCK_RAW</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="nx">family</span><span class="p">:</span> <span class="nx">family</span><span class="p">,</span>
		<span class="nx">sotype</span><span class="p">:</span> <span class="nx">sotype</span><span class="p">,</span>
		<span class="nx">net</span><span class="p">:</span>    <span class="nx">net</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ret</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>


<span class="c1">// 对 listener fd 进行 bind&amp;listen 操作，并且调用 init 方法完成初始化
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">fd</span> <span class="o">*</span><span class="nx">netFD</span><span class="p">)</span> <span class="nf">listenStream</span><span class="p">(</span><span class="nx">laddr</span> <span class="nx">sockaddr</span><span class="p">,</span> <span class="nx">backlog</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">ctrlFn</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">RawConn</span><span class="p">)</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="o">...</span>
  
	<span class="c1">// 完成绑定操作
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">Bind</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">pfd</span><span class="p">.</span><span class="nx">Sysfd</span><span class="p">,</span> <span class="nx">lsa</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">os</span><span class="p">.</span><span class="nf">NewSyscallError</span><span class="p">(</span><span class="s">&#34;bind&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 完成监听操作
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">listenFunc</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">pfd</span><span class="p">.</span><span class="nx">Sysfd</span><span class="p">,</span> <span class="nx">backlog</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">os</span><span class="p">.</span><span class="nf">NewSyscallError</span><span class="p">(</span><span class="s">&#34;listen&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
  
	<span class="c1">// 调用 init，内部会调用 poll.FD.Init，最后调用 pollDesc.init
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">fd</span><span class="p">.</span><span class="nf">init</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">lsa</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">Getsockname</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">pfd</span><span class="p">.</span><span class="nx">Sysfd</span><span class="p">)</span>
	<span class="nx">fd</span><span class="p">.</span><span class="nf">setAddr</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nf">addrFunc</span><span class="p">()(</span><span class="nx">lsa</span><span class="p">),</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="listeneraccept">Listener.Accept</h3>
<p>netpoll accept socket 的工作流程如下：</p>
<ol>
<li>服务端的 netFD 在 listen 时会创建 epoll 的实例，并将 listenerFD 加入 epoll 的事件队列</li>
<li>netFD 在 accept 时将返回的 connFD 也加入 epoll 的事件队列</li>
<li>netFD 在读写时出现 syscall.EAGAIN 错误，通过 pollDesc 的 waitRead 方法将当前的 goroutine park 住，直到 ready，从 pollDesc 的 waitRead 中返回</li>
</ol>
<p>Listener.Accept() 接收来自客户端的新连接，具体还是调用 netFD.accept 方法来完成这个功能：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Accept implements the Accept method in the Listener interface; it
</span><span class="c1">// waits for the next call and returns a generic Conn.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">TCPListener</span><span class="p">)</span> <span class="nf">Accept</span><span class="p">()</span> <span class="p">(</span><span class="nx">Conn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">l</span><span class="p">.</span><span class="nf">ok</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EINVAL</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">accept</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">OpError</span><span class="p">{</span><span class="nx">Op</span><span class="p">:</span> <span class="s">&#34;accept&#34;</span><span class="p">,</span> <span class="nx">Net</span><span class="p">:</span> <span class="nx">l</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nx">net</span><span class="p">,</span> <span class="nx">Source</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">Addr</span><span class="p">:</span> <span class="nx">l</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nx">laddr</span><span class="p">,</span> <span class="nx">Err</span><span class="p">:</span> <span class="nx">err</span><span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ln</span> <span class="o">*</span><span class="nx">TCPListener</span><span class="p">)</span> <span class="nf">accept</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">TCPConn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fd</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nf">accept</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">tc</span> <span class="o">:=</span> <span class="nf">newTCPConn</span><span class="p">(</span><span class="nx">fd</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">lc</span><span class="p">.</span><span class="nx">KeepAlive</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">setKeepAlive</span><span class="p">(</span><span class="nx">fd</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
		<span class="nx">ka</span> <span class="o">:=</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">lc</span><span class="p">.</span><span class="nx">KeepAlive</span>
		<span class="k">if</span> <span class="nx">ln</span><span class="p">.</span><span class="nx">lc</span><span class="p">.</span><span class="nx">KeepAlive</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">ka</span> <span class="p">=</span> <span class="nx">defaultTCPKeepAlive</span>
		<span class="p">}</span>
		<span class="nf">setKeepAlivePeriod</span><span class="p">(</span><span class="nx">fd</span><span class="p">,</span> <span class="nx">ka</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">tc</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">fd</span> <span class="o">*</span><span class="nx">netFD</span><span class="p">)</span> <span class="nf">accept</span><span class="p">()</span> <span class="p">(</span><span class="nx">netfd</span> <span class="o">*</span><span class="nx">netFD</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 调用 poll.FD 的 Accept 方法接受新的 socket 连接，返回 socket 的 fd
</span><span class="c1"></span>	<span class="nx">d</span><span class="p">,</span> <span class="nx">rsa</span><span class="p">,</span> <span class="nx">errcall</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">pfd</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">errcall</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nf">wrapSyscallError</span><span class="p">(</span><span class="nx">errcall</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="c1">// 以 socket fd 构造一个新的 netFD，代表这个新的 socket
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">netfd</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">newFD</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">family</span><span class="p">,</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">sotype</span><span class="p">,</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">net</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">poll</span><span class="p">.</span><span class="nf">CloseFunc</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="c1">// 调用 netFD 的 init 方法完成初始化
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">netfd</span><span class="p">.</span><span class="nf">init</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fd</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">lsa</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">Getsockname</span><span class="p">(</span><span class="nx">netfd</span><span class="p">.</span><span class="nx">pfd</span><span class="p">.</span><span class="nx">Sysfd</span><span class="p">)</span><span class="nx">fff</span>
	<span class="nx">netfd</span><span class="p">.</span><span class="nf">setAddr</span><span class="p">(</span><span class="nx">netfd</span><span class="p">.</span><span class="nf">addrFunc</span><span class="p">()(</span><span class="nx">lsa</span><span class="p">),</span> <span class="nx">netfd</span><span class="p">.</span><span class="nf">addrFunc</span><span class="p">()(</span><span class="nx">rsa</span><span class="p">))</span>
	<span class="k">return</span> <span class="nx">netfd</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>netFD.accept 方法里会再调用 poll.FD.Accept ，最后会使用 Linux 的系统调用 accept 来完成新连接的接收，并且会把 accept 的 socket 设置成非阻塞 I/O 模式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Accept wraps the accept network call.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">fd</span> <span class="o">*</span><span class="nx">FD</span><span class="p">)</span> <span class="nf">Accept</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">Sockaddr</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fd</span><span class="p">.</span><span class="nf">readLock</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">fd</span><span class="p">.</span><span class="nf">readUnlock</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">pd</span><span class="p">.</span><span class="nf">prepareRead</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">isFile</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// 使用 linux 系统调用 accept 接收新连接，创建对应的 socket
</span><span class="c1"></span>		<span class="nx">s</span><span class="p">,</span> <span class="nx">rsa</span><span class="p">,</span> <span class="nx">errcall</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">accept</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">Sysfd</span><span class="p">)</span>
		<span class="c1">// 因为 listener fd 在创建的时候已经设置成非阻塞的了，
</span><span class="c1"></span>		<span class="c1">// 所以 accept 方法会直接返回，不管有没有新连接到来；如果 err == nil 则表示正常建立新连接，直接返回
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">rsa</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="c1">// 如果 err != nil，则判断 err == syscall.EAGAIN，符合条件则进入 pollDesc.waitRead 方法
</span><span class="c1"></span>		<span class="k">switch</span> <span class="nx">err</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EAGAIN</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">pd</span><span class="p">.</span><span class="nf">pollable</span><span class="p">()</span> <span class="p">{</span>
				<span class="c1">// 如果当前没有发生期待的 I/O 事件，那么 waitRead 会通过 park goroutine 让逻辑 block 在这里
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">pd</span><span class="p">.</span><span class="nf">waitRead</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">isFile</span><span class="p">);</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="k">continue</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">ECONNABORTED</span><span class="p">:</span>
			<span class="c1">// This means that a socket on the listen
</span><span class="c1"></span>			<span class="c1">// queue was closed before we Accept()ed it;
</span><span class="c1"></span>			<span class="c1">// it&#39;s a silly error, so try again.
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errcall</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 使用 linux 的 accept 系统调用接收新连接并把这个 socket fd 设置成非阻塞 I/O
</span><span class="c1"></span><span class="nx">ns</span><span class="p">,</span> <span class="nx">sa</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">Accept4Func</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SOCK_NONBLOCK</span><span class="p">|</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">SOCK_CLOEXEC</span><span class="p">)</span>
<span class="c1">// On Linux the accept4 system call was introduced in 2.6.28
</span><span class="c1">// kernel and on FreeBSD it was introduced in 10 kernel. If we
</span><span class="c1">// get an ENOSYS error on both Linux and FreeBSD, or EINVAL
</span><span class="c1">// error on Linux, fall back to using accept.
</span><span class="c1"></span>
<span class="c1">// Accept4Func is used to hook the accept4 call.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">Accept4Func</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">Sockaddr</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">Accept4</span>
</code></pre></td></tr></table>
</div>
</div><p>pollDesc.waitRead 方法主要负责检测当前这个 pollDesc 的上层 netFD 对应的 fd 是否有『期待的』I/O 事件发生，如果有就直接返回，否则就 park 住当前的 goroutine 并持续等待直至对应的 fd 上发生可读/可写或者其他『期待的』I/O 事件为止，然后它就会返回到外层的 for 循环，让 goroutine 继续执行逻辑。</p>
<p>poll.FD.Accept() 返回之后，会构造一个对应这个新 socket 的 netFD，然后调用 init() 方法完成初始化，这个 init 过程和前面 net.Listen() 是一样的，调用链：netFD.init() &ndash;&gt; poll.FD.Init() &ndash;&gt; poll.pollDesc.init()</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Init initializes the FD. The Sysfd field should already be set.
</span><span class="c1">// This can be called multiple times on a single FD.
</span><span class="c1">// The net argument is a network name from the net package (e.g., &#34;tcp&#34;),
</span><span class="c1">// or &#34;file&#34;.
</span><span class="c1">// Set pollable to true if fd should be managed by runtime netpoll.
</span><span class="c1">// netFD.init 会调用 poll.FD.Init 并最终调用到 pollDesc.init，
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">fd</span> <span class="o">*</span><span class="nx">FD</span><span class="p">)</span> <span class="nf">Init</span><span class="p">(</span><span class="nx">net</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">pollable</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">// We don&#39;t actually care about the various network types.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">net</span> <span class="o">==</span> <span class="s">&#34;file&#34;</span> <span class="p">{</span>
		<span class="nx">fd</span><span class="p">.</span><span class="nx">isFile</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">pollable</span> <span class="p">{</span>
		<span class="nx">fd</span><span class="p">.</span><span class="nx">isBlocking</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="c1">// netFD.init 会调用 poll.FD.Init 并最终调用到 pollDesc.init，
</span><span class="c1"></span>	<span class="c1">// 它会创建 epoll 实例并把 listener fd 加入监听队列
</span><span class="c1"></span>	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">pd</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">fd</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// If we could not initialize the runtime poller,
</span><span class="c1"></span>		<span class="c1">// assume we are using blocking mode.
</span><span class="c1"></span>		<span class="nx">fd</span><span class="p">.</span><span class="nx">isBlocking</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>然后把这个 socket fd 注册到 listener 的 epoll 实例的事件队列中去，等待 I/O 事件。</p>
<h3 id="connreadconnwrite">Conn.Read/Conn.Write</h3>
<p>我们先来看看 Conn.Read 方法是如何实现的，原理其实和 Listener.Accept 是一样的，具体调用链还是首先调用 conn 的 netFD.Read ，然后内部再调用 poll.FD.Read ，最后使用 Linux 的系统调用 read: syscall.Read 完成数据读取：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Implementation of the Conn interface.
</span><span class="c1"></span>
<span class="c1">// Read implements the Conn Read method.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">conn</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nf">ok</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EINVAL</span>
	<span class="p">}</span>
	<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">OpError</span><span class="p">{</span><span class="nx">Op</span><span class="p">:</span> <span class="s">&#34;read&#34;</span><span class="p">,</span> <span class="nx">Net</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nx">net</span><span class="p">,</span> <span class="nx">Source</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nx">laddr</span><span class="p">,</span> <span class="nx">Addr</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nx">raddr</span><span class="p">,</span> <span class="nx">Err</span><span class="p">:</span> <span class="nx">err</span><span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">fd</span><span class="o">*</span><span class="nx">netFD</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">pfd</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
	<span class="nx">runtime</span><span class="p">.</span><span class="nf">KeepAlive</span><span class="p">(</span><span class="nx">fd</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="nf">wrapSyscallError</span><span class="p">(</span><span class="s">&#34;read&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Read implements io.Reader.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">fd</span> <span class="o">*</span><span class="nx">FD</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fd</span><span class="p">.</span><span class="nf">readLock</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">fd</span><span class="p">.</span><span class="nf">readUnlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// If the caller wanted a zero byte read, return immediately
</span><span class="c1"></span>		<span class="c1">// without trying (but after acquiring the readLock).
</span><span class="c1"></span>		<span class="c1">// Otherwise syscall.Read returns 0, nil which looks like
</span><span class="c1"></span>		<span class="c1">// io.EOF.
</span><span class="c1"></span>		<span class="c1">// TODO(bradfitz): make it wait for readability? (Issue 15735)
</span><span class="c1"></span>		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">pd</span><span class="p">.</span><span class="nf">prepareRead</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">isFile</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">IsStream</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">maxRW</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nx">p</span><span class="p">[:</span><span class="nx">maxRW</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// 尝试从该 socket 读取数据，因为 socket 在被 listener accept 的时候设置成
</span><span class="c1"></span>		<span class="c1">// 了非阻塞 I/O，所以这里同样也是直接返回，不管有没有可读的数据
</span><span class="c1"></span>		<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">Sysfd</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">n</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="c1">// err == syscall.EAGAIN 表示当前没有期待的 I/O 事件发生，也就是 socket 不可读
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EAGAIN</span> <span class="o">&amp;&amp;</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">pd</span><span class="p">.</span><span class="nf">pollable</span><span class="p">()</span> <span class="p">{</span>
				<span class="c1">// 如果当前没有发生期待的 I/O 事件，那么 waitRead
</span><span class="c1"></span>				<span class="c1">// 会通过 park goroutine 让逻辑 block 在这里
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">pd</span><span class="p">.</span><span class="nf">waitRead</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">isFile</span><span class="p">);</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="k">continue</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="c1">// On MacOS we can see EINTR here if the user
</span><span class="c1"></span>			<span class="c1">// pressed ^Z.  See issue #22838.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;darwin&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EINTR</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">err</span> <span class="p">=</span> <span class="nx">fd</span><span class="p">.</span><span class="nf">eofError</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>conn.Write 和 conn.Read 的原理是一致的，它也是通过类似 pollDesc.waitRead 的 pollDesc.waitWrite 来 park 住 goroutine 直至期待的 I/O 事件发生才返回恢复执行。</p>
<p>pollDesc.waitRead 内部调用了 poll.runtime_pollWait &ndash;&gt; runtime.poll_runtime_pollWait 来达成无 I/O 事件时 park 住 goroutine 的目的</p>
<p>pollDesc.waitWrite 的内部实现原理和 pollDesc.waitRead 是一样的，都是基于 poll.runtime_pollWait &ndash;&gt; runtime.poll_runtime_pollWait，这里就不再赘述。</p>
<h3 id="总结">总结</h3>
<p>所以我们现在可以来从整体的层面来概括 Go 的网络业务 goroutine 是如何被规划调度的了：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201119153905.png" alt=""></p>
<p>首先，client 连接 server 的时候，listener 通过 accept 调用接收新 connection，每一个新 connection 都启动一个 goroutine 处理，accept 调用会把该 connection 的 fd 连带所在的 goroutine 上下文信息封装注册到 epoll 的监听列表里去，当 goroutine 调用 conn.Read 或者 conn.Write 等需要阻塞等待的函数时，会被 gopark 给封存起来并使之休眠，让 P 去执行本地调度队列里的下一个可执行的 goroutine，往后 Go scheduler 会在循环调度的 runtime.schedule() 函数以及 sysmon 监控线程中调用 runtime.nepoll 以获取可运行的 goroutine 列表并通过调用 injectglist 把剩下的 g 放入全局调度队列或者当前 P 本地调度队列去重新执行。</p>
<p>综上，Go 借助于 epoll/kqueue/iocp 和 runtime scheduler 等的帮助，设计出了自己的 I/O 多路复用 netpoller，成功地让 Listener.Accept / conn.Read / conn.Write 等方法从开发者的角度看来是同步模式。</p>
<h2 id="价值">价值</h2>
<p>通过前面对源码的分析，我们现在知道 Go netpoller 依托于 runtime scheduler，为开发者提供了一种强大的同步网络编程模式；然而，Go netpoller 存在的意义却远不止于此，Go netpoller I/O 多路复用搭配 Non-blocking I/O 而打造出来的这个原生网络模型，它最大的价值是把网络 I/O 的控制权牢牢掌握在 Go 自己的 runtime 里.</p>
<p>G 在运行过程中如果被阻塞在某个 system call 操作上，那么不光 G 会阻塞，执行该 G 的 M 也会解绑 P，与 G 一起进入 sleep 状态。</p>
<p>如果此时有 idle 的 M，则 P 与其绑定继续执行其他 G；如果没有 idle M，但仍然有其他 G 要去执行，那么就会创建一个新的 M。当阻塞在 system call 上的 G 完成 syscall 调用后，G 会去尝试获取一个可用的 P，如果没有可用的 P，那么 G 会被标记为 _Grunnable 并把它放入全局的 runqueue 中等待调度，之前的那个 sleep 的 M 将再次进入 sleep。</p>
<p>现在清楚为什么 netpoll 为什么一定要使用非阻塞 I/O 了吧？</p>
<p>就是为了避免让操作网络 I/O 的 goroutine 陷入到系统调用从而进入内核态，因为一旦进入内核态，整个程序的控制权就会发生转移(到内核)，不再属于用户进程了，那么也就无法借助于 Go 强大的 runtime scheduler 来调度业务程序的并发了.</p>
<p>而有了 netpoll 之后，借助于非阻塞 I/O ，G 就再也不会因为系统调用的读写而 (长时间) 陷入内核态，当 G 被阻塞在某个 network I/O 操作上时，实际上它不是因为陷入内核态被阻塞住了，而是被 Go runtime 调用 gopark 给 park 住了，此时 G 会被放置到某个 wait queue 中，而 M 会尝试运行下一个 _Grunnable 的 G，如果此时没有_Grunnable 的 G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态。</p>
<p>当 I/O available，在 epoll 的 eventpoll.rdr 中等待的 G 会被放到 eventpoll.rdllist 链表里并通过 netpoll 中的 epoll_wait 系统调用返回放置到全局调度队列或者 P 的本地调度队列，标记为_Grunnable ，等待 P 绑定 M 恢复执行。</p>
<h2 id="问题">问题</h2>
<p>Go netpoller 的设计不可谓不精巧、性能也不可谓不高，配合 goroutine 开发网络应用的时候就一个字：爽。因此 Go 的网络编程模式是及其简洁高效的，然而，没有任何一种设计和架构是完美的.</p>
<p>goroutine-per-connection 这种模式虽然简单高效，但是在某些极端的场景下也会暴露出问题：goroutine 虽然非常轻量，它的自定义栈内存初始值仅为 2KB，后面按需扩容；海量连接的业务场景下， goroutine-per-connection ，此时 goroutine 数量以及消耗的资源就会呈线性趋势暴涨.</p>
<p>虽然 Go scheduler 内部做了 g 的缓存链表，可以一定程度上缓解高频创建销毁 goroutine 的压力，但是对于瞬时性暴涨的长连接场景就无能为力了，大量的 goroutines 会被不断创建出来，从而对 Go runtime scheduler 造成极大的调度压力和侵占系统资源，然后资源被侵占又反过来影响 Go scheduler 的调度，进而导致性能下降。</p>
<h2 id="reactor-网络模型">Reactor 网络模型</h2>
<p>目前 Linux 平台上主流的高性能网络库/框架中，大都采用 Reactor 模式，比如 netty、libevent、libev、ACE，POE(Perl)、Twisted(Python)等。</p>
<p>Reactor 模式本质上指的是使用 I/O 多路复用(I/O multiplexing) + 非阻塞 I/O(non-blocking I/O) 的模式。</p>
<p>通常设置一个主线程负责做 event-loop 事件循环和 I/O 读写，通过 select/poll/epoll_wait 等系统调用监听 I/O 事件，业务逻辑提交给其他工作线程去做。而所谓『非阻塞 I/O』的核心思想是指避免阻塞在 read() 或者 write() 或者其他的 I/O 系统调用上，这样可以最大限度的复用 event-loop 线程，让一个线程能服务于多个 sockets。在 Reactor 模式中，I/O 线程只能阻塞在 I/O multiplexing 函数上（select/poll/epoll_wait）。</p>
<p>Reactor 模式的基本工作流程如下：</p>
<ol>
<li>Server 端完成在 bind&amp;listen 之后，将 listenfd 注册到 epollfd 中，最后进入 event-loop 事件循环。循环过程中会调用 select/poll/epoll_wait 阻塞等待，若有在 listenfd 上的新连接事件则解除阻塞返回，并调用 socket.accept 接收新连接 connfd，并将 connfd 加入到 epollfd 的 I/O 复用（监听）队列。</li>
<li>当 connfd 上发生可读/可写事件也会解除 select/poll/epoll_wait 的阻塞等待，然后进行 I/O 读写操作，这里读写 I/O 都是非阻塞 I/O，这样才不会阻塞 event-loop 的下一个循环。然而，这样容易割裂业务逻辑，不易理解和维护。</li>
<li>调用 read 读取数据之后进行解码并放入队列中，等待工作线程处理。</li>
<li>工作线程处理完数据之后，返回到 event-loop 线程，由这个线程负责调用 write 把数据写回 client。</li>
</ol>
<p>accept 连接以及 conn 上的读写操作若是在主线程完成，则要求是非阻塞 I/O，因为 Reactor 模式一条最重要的原则就是：I/O 操作不能阻塞 event-loop 事件循环。实际上 event loop 可能也可以是多线程的，只是一个线程里只有一个 select/poll/epoll_wait。</p>
<p>上面提到了 Go netpoller 在某些场景下可能因为创建太多的 goroutine 而过多地消耗系统资源，而在现实世界的网络业务中，服务器持有的海量连接中在极短的时间窗口内只有极少数是 active 而大多数则是 idle，就像这样（非真实数据，仅仅是为了比喻）：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201119165211.png" alt=""></p>
<p>那么为每一个连接指派一个 goroutine 就显得太过奢侈了，而 Reactor 模式这种利用 I/O 多路复用进而只需要使用少量线程即可管理海量连接的设计就可以在这样网络业务中大显身手了：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201119165231.png" alt=""></p>
<p>在绝大部分应用场景下，我推荐大家还是遵循 Go 的 best practices，使用原生的 Go 网络库来构建自己的网络应用。然而，在某些极度追求性能、压榨系统资源以及技术栈必须是原生 Go （不考虑 C/C++ 写中间层而 Go 写业务层）的业务场景下，我们可以考虑自己构建 Reactor 网络模型。</p>
<p>参考:<br>
<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/">6.6 网络轮询器</a>
<a href="https://strikefreedom.top/go-netpoll-io-multiplexing-reactor#b3_solo_h2_16%EF%BC%8C%E4%BB%8E%E5%85%A8%E9%9D%A2%E6%80%A7%E5%92%8C%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%9D%A5%E8%AF%B4%E6%88%91%E8%BF%98%E6%98%AF%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8">go netpoller 原生网络模型之源码全面解析</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-11-14
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go%E6%BA%90%E7%A0%81/">Go源码</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go的程序生命周期源码剖析</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/go%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
            <span class="next-text nav-default">Go的系统监控源码剖析</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Forz</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
