<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>最大区域面积 | Forz Blog</title>
<meta name="keywords" content="DP, 单调栈" />
<meta name="description" content="LeetCode 84. Largest Rectangle in Histogram Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area =">
<meta name="author" content="">
<link rel="canonical" href="/post/%E6%9C%80%E5%A4%A7%E5%8C%BA%E5%9F%9F%E9%9D%A2%E7%A7%AF/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="最大区域面积" />
<meta property="og:description" content="LeetCode 84. Largest Rectangle in Histogram Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area =" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E6%9C%80%E5%A4%A7%E5%8C%BA%E5%9F%9F%E9%9D%A2%E7%A7%AF/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-24T20:29:09&#43;00:00" />
<meta property="article:modified_time" content="2017-06-24T20:29:09&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="最大区域面积"/>
<meta name="twitter:description" content="LeetCode 84. Largest Rectangle in Histogram Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area ="/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "最大区域面积",
      "item": "/post/%E6%9C%80%E5%A4%A7%E5%8C%BA%E5%9F%9F%E9%9D%A2%E7%A7%AF/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "最大区域面积",
  "name": "最大区域面积",
  "description": "LeetCode 84. Largest Rectangle in Histogram Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area =",
  "keywords": [
    "DP", "单调栈"
  ],
  "articleBody": "LeetCode 84. Largest Rectangle in Histogram Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.\nAbove is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].\nThe largest rectangle is shown in the shaded area, which has area = 10 unit.\nFor example, Given heights = [2,1,5,6,2,3],\nreturn 10.\n解析：\n求解面积的最大值，其实就是求每一个上升序列组成的矩形的面积，然后求最大值。\n单调栈求最大上升序列，栈顶维护单调递增序列（对于每个高度，比它大的都可以看作它本身，只需考虑比它小的高度）\n通过单调栈求得最大上升序列，而不是所有的上升序列，序列越长，不代表结果越大。这需要在退栈的时候不断维护最大面积。\n因为扫描结束后还会存在以最后一个元素为结尾的最大上升序列等待处理，可以在height的最后放入一个较小的数字作为哨兵元素，这样就能保证栈最后为空了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Solution { public: int largestRectangleArea(vectorint\u0026 heights) { if(heights.size() ==0) return 0; heights.push_back(0); int len = heights.size(), ans = 0; stackint st; for(int i = 0; i  len; i++)//i表示扫描位置  { while(!st.empty() \u0026\u0026 heights[i]  heights[st.top()]) {//每出现一个值比当前栈顶小，就说明当前栈顶的最大上升序列完结，需要退栈求结果  auto val = st.top(); st.pop(); ans = max(ans, heights[val]*(i-1-(st.empty()?-1:st.top())));//维护最大值max(height[i]*(size-i)) //如果栈已经为空，说明到目前为止所有元素（当前下标元素除外）都比出栈元素高度要大（否则栈中肯定还有元素）， //所以矩阵面积就是高度乘以当前下标i。（最大矩形以栈顶元素的高为宽，扫描位置i为长） //如果栈不为空，那么最大矩形面积就是以当前栈顶元素的高为宽，栈顶元素到扫描位置的前一位的距离为长 //所以矩阵面积就是高度乘以当前下标i减栈顶元素再减1。（i-1表示扫描位置的前一位，表示第一次出栈的位置。）  } st.push(i);//序号入栈  } return ans; } };   LeetCode 221. Maximal Square Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.\nFor example, given the following matrix:\n1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0  Return 4.\n解析：\n因为本题求的是正方形的最大面积，变化量只有边长，所以可以用DP来记录。dp[i][j]表示以i,j为右下角的正方形的边长\ndp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n可以用滚动数组来优化空间复杂度，按列扫描，滚动维护该列所有行的数据\ndp[i] = min(dp[i], min(dp[i - 1], pre)) + 1;\n每当我们更新dp[i] [j]时，我们只需要上一行和上一列内容，所以我们不需要维护完整的m * n矩阵\n在扫描的过程中，为了简化代码，可以在第一行前面填充1行0，保证数组不越界。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution { int maximalSquare(vectorvectorchar\u0026 matrix) { if (matrix.empty()) return 0; int m = matrix.size(), n = matrix[0].size();//m为行，n为列 vectorint dp(m + 1, 0);//多一行，因为上面填充了0，保证数组不越界 int maxsize = 0, pre = 0;//上一列 for (int j = 0; j  n; j++) { for (int i = 1; i  m; i++) {//扫描每一列，从1开始，因为第0行填充为0  int temp = dp[i]; if (matrix[i - 1][j] == '1') { //因为填充了一行边界，dp[i]实际对应位置为matrix[i-1][j]  dp[i] = min(dp[i], min(dp[i - 1], pre)) + 1; //dp[i]保存的是上一列的内容  maxsize = max(maxsize, dp[i]); } else dp[i] = 0; pre = temp;//保存上一行的内容  } } return maxsize * maxsize; } };   LeetCode 85. Maximal Rectangle Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.\nFor example, given the following matrix:\n1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0  Return 6.\n解析：\n本题解除了必须为正方形的限制。长和宽都是可变的，所以不能像上题那样将每个点都看作正方形的右下角，记录最大边长了。可以枚举每一行，在每一行上求当前最大面积，这需要将本题转化为84题，用单调栈来解。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class Solution { public: int maximalRectangle(vectorvectorchar  \u0026matrix) { if(matrix.size() == 0 || matrix[0].size() == 0) return 0; int res = 0; vectorint height(matrix[0].size(), 0); for(int i = 0; i  matrix.size(); ++ i) { for(int j = 0; j  matrix[0].size(); ++ j) height[j] = matrix[i][j] == '0' ? 0 : height[j] + 1;//将矩阵转换为矩形高度，向84题靠近。  res = max(res, largestRectangleArea(height)); } return res; } private: int largestRectangleArea(vectorint\u0026 heights) { if(heights.size() ==0) return 0; heights.push_back(0);//在height的最后放入一个较小的数字作为哨兵元素，这样就能保证栈最后为空了。  int len = heights.size(), ans = 0; stackint st; for(int i = 0; i  len; i++)//i表示扫描位置  { while(!st.empty() \u0026\u0026 heights[i]  heights[st.top()]) { auto val = st.top(); st.pop(); ans = max(ans, heights[val]*(i-1-(st.empty()?-1:st.top())));//维护最大值max(height[i]*(size-i))  } st.push(i);//序号入栈  } return ans; } };   补充:DP解法\n思路同样是从第一行开始一行一行地处理，使[i, j]处最大子矩阵的面积是(right(i, j)-left(i, j))*height(i, j)。\n其中height统计当前位置及往上’1’的数量；left和right是高度是当前点的height值得左右边界，即是以当前点为中心，以height为高度向两边扩散的左右边界。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class Solution { public: int maximalRectangle(vectorvectorchar  \u0026matrix) { if(matrix.empty()) return 0; const int m = matrix.size(); const int n = matrix[0].size(); int left[n], right[n], height[n]; fill_n(left,n,0); fill_n(right,n,n); fill_n(height,n,0); int maxA = 0; for(int i=0; im; i++) { int cur_left=0, cur_right=n; for(int j=0; jn; j++) { // compute height (can do this from either side)  if(matrix[i][j]=='1') height[j]++; else height[j]=0; } for(int j=0; jn; j++) { // compute left (from left to right)  if(matrix[i][j]=='1') left[j]=max(left[j],cur_left); else {left[j]=0; cur_left=j+1;} } // compute right (from right to left)  for(int j=n-1; j=0; j--) { if(matrix[i][j]=='1') right[j]=min(right[j],cur_right); else {right[j]=n; cur_right=j;} } // compute the area of rectangle (can do this from either side)  for(int j=0; jn; j++) maxA = max(maxA,(right[j]-left[j])*height[j]); } return maxA; }   ",
  "wordCount" : "2029",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-24T20:29:09Z",
  "dateModified": "2017-06-24T20:29:09Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E6%9C%80%E5%A4%A7%E5%8C%BA%E5%9F%9F%E9%9D%A2%E7%A7%AF/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      最大区域面积
    </h1>
    <div class="post-meta">June 24, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="leetcode-84-largest-rectangle-in-histogram">LeetCode 84. Largest Rectangle in Histogram<a hidden class="anchor" aria-hidden="true" href="#leetcode-84-largest-rectangle-in-histogram">#</a></h1>
<p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/histogram.png" alt=""  />
</p>
<p>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/histogram_area.png" alt=""  />
</p>
<p>The largest rectangle is shown in the shaded area, which has area = 10 unit.</p>
<p>For example, <br>
Given heights = [2,1,5,6,2,3],</p>
<p>return 10.</p>
<p>解析：</p>
<p>求解面积的最大值，其实就是求每一个上升序列组成的矩形的面积，然后求最大值。</p>
<p>单调栈求最大上升序列，栈顶维护单调递增序列（对于每个高度，比它大的都可以看作它本身，只需考虑比它小的高度）</p>
<p>通过单调栈求得最大上升序列，而不是所有的上升序列，序列越长，不代表结果越大。这需要在退栈的时候不断维护最大面积。</p>
<p>因为扫描结束后还会存在以最后一个元素为结尾的最大上升序列等待处理，可以在height的最后放入一个较小的数字作为哨兵元素，这样就能保证栈最后为空了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">largestRectangleArea</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">heights</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">heights</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">heights</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">heights</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">st</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//i表示扫描位置
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">heights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">heights</span><span class="p">[</span><span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">()])</span>
        <span class="p">{</span><span class="c1">//每出现一个值比当前栈顶小，就说明当前栈顶的最大上升序列完结，需要退栈求结果
</span><span class="c1"></span>            <span class="k">auto</span> <span class="n">val</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
            <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">heights</span><span class="p">[</span><span class="n">val</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="o">?-</span><span class="mi">1</span><span class="o">:</span><span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">())));</span><span class="c1">//维护最大值max(height[i]*(size-i))
</span><span class="c1">//如果栈已经为空，说明到目前为止所有元素（当前下标元素除外）都比出栈元素高度要大（否则栈中肯定还有元素），
</span><span class="c1">//所以矩阵面积就是高度乘以当前下标i。（最大矩形以栈顶元素的高为宽，扫描位置i为长）
</span><span class="c1">//如果栈不为空，那么最大矩形面积就是以当前栈顶元素的高为宽，栈顶元素到扫描位置的前一位的距离为长
</span><span class="c1">//所以矩阵面积就是高度乘以当前下标i减栈顶元素再减1。（i-1表示扫描位置的前一位，表示第一次出栈的位置。）
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="c1">//序号入栈
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-221-maximal-square">LeetCode 221. Maximal Square<a hidden class="anchor" aria-hidden="true" href="#leetcode-221-maximal-square">#</a></h1>
<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p>
<p>For example, given the following matrix:</p>
<pre><code>1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
</code></pre>
<p>Return 4.</p>
<p>解析：</p>
<p>因为本题求的是正方形的最大面积，变化量只有边长，所以可以用DP来记录。dp[i][j]表示以i,j为右下角的正方形的边长</p>
<p>dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1</p>
<p>可以用滚动数组来优化空间复杂度，按列扫描，滚动维护该列所有行的数据</p>
<p>dp[i] = min(dp[i], min(dp[i - 1], pre)) + 1;</p>
<p>每当我们更新dp[i] [j]时，我们只需要上一行和上一列内容，所以我们不需要维护完整的m * n矩阵</p>
<p>在扫描的过程中，为了简化代码，可以在第一行前面填充1行0，保证数组不越界。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">maximalSquare</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;&amp;</span> <span class="n">matrix</span><span class="p">)</span> <span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="c1">//m为行，n为列
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span><span class="c1">//多一行，因为上面填充了0，保证数组不越界
</span><span class="c1"></span><span class="kt">int</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pre</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//上一列
</span><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="c1">//扫描每一列，从1开始，因为第0行填充为0
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//因为填充了一行边界，dp[i]实际对应位置为matrix[i-1][j]
</span><span class="c1"></span>            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pre</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="c1">//dp[i]保存的是上一列的内容
</span><span class="c1"></span>            <span class="n">maxsize</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxsize</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
        <span class="n">pre</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span><span class="c1">//保存上一行的内容
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">maxsize</span> <span class="o">*</span> <span class="n">maxsize</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-85-maximal-rectangle">LeetCode 85. Maximal Rectangle<a hidden class="anchor" aria-hidden="true" href="#leetcode-85-maximal-rectangle">#</a></h1>
<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p>
<p>For example, given the following matrix:</p>
<pre><code>1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
</code></pre>
<p>Return 6.</p>
<p>解析：</p>
<p>本题解除了必须为正方形的限制。长和宽都是可变的，所以不能像上题那样将每个点都看作正方形的右下角，记录最大边长了。可以枚举每一行，在每一行上求当前最大面积，这需要将本题转化为84题，用单调栈来解。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span>
<span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">maximalRectangle</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">matrix</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">height</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span> <span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">height</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">height</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//将矩阵转换为矩形高度，向84题靠近。
</span><span class="c1"></span>            <span class="n">res</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">largestRectangleArea</span><span class="p">(</span><span class="n">height</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">private</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">largestRectangleArea</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">heights</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">heights</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">heights</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="c1">//在height的最后放入一个较小的数字作为哨兵元素，这样就能保证栈最后为空了。
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">heights</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">st</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//i表示扫描位置
</span><span class="c1"></span>        <span class="p">{</span>
            <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">heights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">heights</span><span class="p">[</span><span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">()])</span>
            <span class="p">{</span>
                <span class="k">auto</span> <span class="n">val</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
                <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">heights</span><span class="p">[</span><span class="n">val</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="o">?-</span><span class="mi">1</span><span class="o">:</span><span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">())));</span><span class="c1">//维护最大值max(height[i]*(size-i))
</span><span class="c1"></span>            <span class="p">}</span>
            <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="c1">//序号入栈
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>补充:DP解法</p>
<p>思路同样是从第一行开始一行一行地处理，使[i, j]处最大子矩阵的面积是(right(i, j)-left(i, j))*height(i, j)。</p>
<p>其中height统计当前位置及往上’1’的数量；left和right是高度是当前点的height值得左右边界，即是以当前点为中心，以height为高度向两边扩散的左右边界。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">maximalRectangle</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">matrix</span><span class="p">)</span> <span class="p">{</span>
<span class="k">if</span><span class="p">(</span><span class="n">matrix</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">left</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">right</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">height</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="n">fill_n</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span> <span class="n">fill_n</span><span class="p">(</span><span class="n">right</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">);</span> <span class="n">fill_n</span><span class="p">(</span><span class="n">height</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">maxA</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">cur_left</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">cur_right</span><span class="o">=</span><span class="n">n</span><span class="p">;</span> 
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// compute height (can do this from either side)
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="sc">&#39;1&#39;</span><span class="p">)</span> <span class="n">height</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> 
        <span class="k">else</span> <span class="n">height</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// compute left (from left to right)
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="sc">&#39;1&#39;</span><span class="p">)</span> <span class="n">left</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">cur_left</span><span class="p">);</span>
        <span class="k">else</span> <span class="p">{</span><span class="n">left</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">cur_left</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">;}</span>
    <span class="p">}</span>
    <span class="c1">// compute right (from right to left)
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="sc">&#39;1&#39;</span><span class="p">)</span> <span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">min</span><span class="p">(</span><span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">cur_right</span><span class="p">);</span>
        <span class="k">else</span> <span class="p">{</span><span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">n</span><span class="p">;</span> <span class="n">cur_right</span><span class="o">=</span><span class="n">j</span><span class="p">;}</span>    
    <span class="p">}</span>
    <span class="c1">// compute the area of rectangle (can do this from either side)
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">maxA</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxA</span><span class="p">,(</span><span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">left</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">height</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">maxA</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/dp/">DP</a></li>
      <li><a href="/tags/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
