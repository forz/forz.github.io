<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go的内存分配源码剖析 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="设计原理 内存管理的三个角色: Mutator:fancy(花哨的) word for application，其实就是你写的应用程序，它会不断地修改对象的引用" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.92.1 with theme even" />


<link rel="canonical" href="/post/go%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go的内存分配源码剖析" />
<meta property="og:description" content="设计原理 内存管理的三个角色: Mutator:fancy(花哨的) word for application，其实就是你写的应用程序，它会不断地修改对象的引用" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-11-23T10:26:14+00:00" />
<meta property="article:modified_time" content="2020-11-23T10:26:14+00:00" />

<meta itemprop="name" content="Go的内存分配源码剖析">
<meta itemprop="description" content="设计原理 内存管理的三个角色: Mutator:fancy(花哨的) word for application，其实就是你写的应用程序，它会不断地修改对象的引用"><meta itemprop="datePublished" content="2020-11-23T10:26:14+00:00" />
<meta itemprop="dateModified" content="2020-11-23T10:26:14+00:00" />
<meta itemprop="wordCount" content="35857">
<meta itemprop="keywords" content="Go源码," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go的内存分配源码剖析"/>
<meta name="twitter:description" content="设计原理 内存管理的三个角色: Mutator:fancy(花哨的) word for application，其实就是你写的应用程序，它会不断地修改对象的引用"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go的内存分配源码剖析</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-11-23 </span>
        <div class="post-category">
            <a href="/categories/go%E6%BA%90%E7%A0%81/"> Go源码 </a>
            </div>
          <span class="more-meta"> 约 35857 字 </span>
          <span class="more-meta"> 预计阅读 72 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#设计原理">设计原理</a>
      <ul>
        <li><a href="#分级分配">分级分配</a></li>
        <li><a href="#虚拟内存布局">虚拟内存布局</a></li>
        <li><a href="#系统级内存管理调用">系统级内存管理调用</a></li>
      </ul>
    </li>
    <li><a href="#整体架构">整体架构</a></li>
    <li><a href="#虚拟地址空间heaparena">虚拟地址空间:heapArena</a>
      <ul>
        <li><a href="#arenahint">arenaHint</a></li>
      </ul>
    </li>
    <li><a href="#内存基本单元mspan">内存基本单元:mspan</a>
      <ul>
        <li><a href="#spanclass">spanClass</a></li>
        <li><a href="#状态">状态</a></li>
        <li><a href="#alloccache">allocCache</a></li>
      </ul>
    </li>
    <li><a href="#微小对象分配器mcache">微小对象分配器:mcache</a>
      <ul>
        <li><a href="#初始化">初始化</a></li>
        <li><a href="#refill">refill</a></li>
        <li><a href="#releaseall">releaseAll</a></li>
        <li><a href="#per-p">per-P</a></li>
      </ul>
    </li>
    <li><a href="#中心缓存mcentral">中心缓存:mcentral</a>
      <ul>
        <li><a href="#cachespan">cacheSpan</a></li>
        <li><a href="#grow">grow</a></li>
      </ul>
    </li>
    <li><a href="#页堆mheap">页堆:mheap</a>
      <ul>
        <li><a href="#init">init</a></li>
        <li><a href="#fixalloc">fixalloc</a></li>
        <li><a href="#alloc">alloc</a></li>
        <li><a href="#grow-1">grow</a></li>
        <li><a href="#linearalloc">linearAlloc</a></li>
        <li><a href="#堆内存释放">堆内存释放</a></li>
      </ul>
    </li>
    <li><a href="#分配内存newobject">分配内存:newobject</a>
      <ul>
        <li><a href="#mallocgc">mallocgc</a></li>
        <li><a href="#nextfreefast">nextFreeFast</a></li>
        <li><a href="#nextfree">nextFree</a></li>
        <li><a href="#largealloc">largeAlloc</a></li>
        <li><a href="#memclrnoheappointers">memclrNoHeapPointers</a></li>
      </ul>
    </li>
    <li><a href="#程序初始化mallocinit">程序初始化:mallocinit</a></li>
    <li><a href="#小结">小结</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="设计原理">设计原理</h2>
<p>内存管理的三个角色:</p>
<ul>
<li>
<p>Mutator:fancy(花哨的) word for application，其实就是你写的应用程序，它会不断地修改对象的引用关系，即对象图。</p>
</li>
<li>
<p>Allocator:内存分配器，负责管理从操作系统中分配出的内存空间， malloc 其实底层就有一个内存分配器的实现(glibc 中)，tcmalloc 是 malloc 多线程改进版。Go 中的实现类似 tcmalloc。</p>
</li>
<li>
<p>Collector:垃圾收集器，负责清理死对象，释放内存空间。</p>
</li>
</ul>
<p>Mutator、Allocator、Collector 概览:</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210811141235.png" alt=""></p>
<h3 id="分级分配">分级分配</h3>
<p>线程缓存分配（Thread-Caching Malloc，TCMalloc）是用于分配内存的机制，它比 glibc 中的 malloc 函数还要快很多.Go 语言的内存分配器就借鉴了 TCMalloc 的设计实现高速的内存分配，它的核心理念是使用多级缓存将对象根据大小分类，并按照类别实施不同的分配策略。</p>
<h4 id="对象大小">对象大小</h4>
<p>Go 语言的内存分配器会根据申请分配的内存大小选择不同的处理逻辑，运行时根据对象的大小将对象分成微对象、小对象和大对象三种：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>微对象</td>
<td>(0, 16B)</td>
</tr>
<tr>
<td>小对象</td>
<td>[16B, 32KB]</td>
</tr>
<tr>
<td>大对象</td>
<td>(32KB, +∞)</td>
</tr>
</tbody>
</table>
<p>因为程序中的绝大多数对象的大小都在 32KB 以下，而申请的内存大小影响 Go 语言运行时分配内存的过程和开销，所以分别处理大对象和小对象有利于提高内存分配器的性能。</p>
<h4 id="多级缓存">多级缓存</h4>
<p>内存分配器不仅会区别对待大小不同的对象，还会将内存分成不同的级别分别管理，TCMalloc 和 Go 运行时分配器都会引入线程缓存（Thread Cache）、中心缓存（Central Cache）和页堆（Page Heap）三个组件分级管理内存：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123144212.png" alt=""></p>
<p>线程缓存属于每一个独立的线程，它能够满足线程上绝大多数的内存分配需求，因为不涉及多线程，所以也不需要使用互斥锁来保护内存，这能够减少锁竞争带来的性能损耗。当线程缓存不能满足需求时，就会使用中心缓存作为补充解决小对象的内存分配问题；在遇到 32KB 以上的对象时，内存分配器就会选择页堆直接分配大量的内存。</p>
<p>这种多层级的内存分配设计与计算机操作系统中的多级缓存也有些类似，因为多数的对象都是小对象，我们可以通过线程缓存和中心缓存提供足够的内存空间，发现资源不足时就从上一级组件中获取更多的内存资源。</p>
<h3 id="虚拟内存布局">虚拟内存布局</h3>
<p>这里会介绍 Go 语言堆区内存地址空间的设计以及演进过程，在 Go 语言 1.10 以前的版本，堆区的内存空间都是连续的；但是在 1.11 版本，Go 团队使用稀疏的堆内存空间替代了连续的内存，解决了连续内存带来的限制以及在特殊场景下可能出现的问题。</p>
<h4 id="线性内存">线性内存</h4>
<p>Go 语言程序的 1.10 版本在启动时会初始化整片虚拟内存区域，如下所示的三个区域 spans、bitmap 和 arena 分别预留了 512MB、16GB 以及 512GB 的内存空间，这些内存并不是真正存在的物理内存，而是虚拟内存：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123144624.png" alt=""></p>
<ul>
<li>spans 区域存储了指向mspan runtime.mspan 的指针，每个内存单元会管理几页的内存空间，每页大小为 8KB；</li>
<li>bitmap 用于标识 arena 区域中的那些地址保存了对象，位图中的每个字节都会表示堆区中的 32 字节是否包含空闲；</li>
<li>arena 区域是真正的堆区，运行时会将 8KB 看做一页，这些内存页中存储了所有在堆上初始化的对象；</li>
</ul>
<p>对于任意一个地址，我们都可以根据 arena 的基地址计算该地址所在的页数并通过 spans 数组获得管理该片内存的管理单元 runtime.mspan，spans 数组中多个连续的位置可能对应同一个 runtime.mspan。</p>
<p>Go 语言在垃圾回收时会根据指针的地址判断对象是否在堆中，并通过上一段中介绍的过程找到管理该对象的 runtime.mspan。这些都建立在堆区的内存是连续的这一假设上。这种设计虽然简单并且方便，但是在 C 和 Go 混合使用时会导致程序崩溃：</p>
<ol>
<li>分配的内存地址会发生冲突，导致堆的初始化和扩容失败；</li>
<li>没有被预留的大块内存可能会被分配给 C 语言的二进制，导致扩容后的堆不连续；</li>
</ol>
<p>线性的堆内存需要预留大块的内存空间，但是申请大块的内存空间而不使用是不切实际的，不预留内存空间却会在特殊场景下造成程序崩溃。虽然连续内存的实现比较简单，但是这些问题我们也没有办法忽略。</p>
<h4 id="稀疏内存">稀疏内存</h4>
<p>稀疏内存是 Go 语言在 1.11 中提出的方案，使用稀疏的内存布局不仅能移除堆大小的上限，还能解决 C 和 Go 混合使用时的地址空间冲突问题。不过因为基于稀疏内存的内存管理失去了内存的连续性这一假设，这也使内存管理变得更加复杂：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123145800.png" alt=""></p>
<p>如上图所示，运行时使用二维的 runtime.heapArena 数组管理所有的内存，每个单元都会管理 64MB 的内存空间：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">heapArena</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">bitmap</span> <span class="p">[</span><span class="nx">heapArenaBitmapBytes</span><span class="p">]</span><span class="kt">byte</span>
	<span class="nx">spans</span> <span class="p">[</span><span class="nx">pagesPerArena</span><span class="p">]</span><span class="o">*</span><span class="nx">mspan</span>
	<span class="nx">pageInUse</span> <span class="p">[</span><span class="nx">pagesPerArena</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span><span class="kt">uint8</span>
	<span class="nx">pageMarks</span> <span class="p">[</span><span class="nx">pagesPerArena</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span><span class="kt">uint8</span>
	<span class="nx">zeroedBase</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该结构体中的 bitmap 和 spans 与线性内存中的 bitmap 和 spans 区域一一对应，zeroedBase 字段指向了该结构体管理的内存的基地址。这种设计将原有的连续大内存切分成稀疏的小内存，而用于管理这些内存的元信息也被切分成了小块。</p>
<p>不同平台和架构的二维数组大小可能完全不同，如果我们的 Go 语言服务在 Linux 的 x86-64 架构上运行，二维数组的一维大小会是 1，而二维大小是 4,194,304，因为每一个指针占用 8 字节的内存空间，所以元信息的总大小为 32MB。由于每个 runtime.heapArena 都会管理 64MB 的内存，整个堆区最多可以管理 256TB 的内存，这比之前的 512GB 多好几个数量级。</p>
<p>Go 语言团队在 1.11 版本中通过以下几个提交将线性内存变成稀疏内存，移除了 512GB 的内存上限以及堆区内存连续性的假设：</p>
<p>由于内存的管理变得更加复杂，上述改动对垃圾回收稍有影响，大约会增加 1% 的垃圾回收开销，不过这也是我们为了解决已有问题必须付出的成本。</p>
<h3 id="系统级内存管理调用">系统级内存管理调用</h3>
<p>因为所有的内存最终都是要从操作系统中申请的，所以 Go 语言的运行时构建了操作系统的内存管理抽象层，该抽象层将运行时管理的地址空间分成以下的四种状态：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210811141335.png" alt=""></p>
<table>
<thead>
<tr>
<th>状态</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>内存没有被保留或者映射，是地址空间的默认状态</td>
</tr>
<tr>
<td>Reserved</td>
<td>运行时持有该地址空间，但是访问该内存会导致错误</td>
</tr>
<tr>
<td>Prepared</td>
<td>内存被保留，一般没有对应的物理内存访问该片内存的行为是未定义的可以快速转换到 Ready 状态</td>
</tr>
<tr>
<td>Ready</td>
<td>可以被安全访问</td>
</tr>
</tbody>
</table>
<p>每一个不同的操作系统都会包含一组特定的方法，这些方法可以让内存地址空间在不同的状态之间做出转换，我们可以通过下图了解不同状态之间的转换过程：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123150141.png" alt=""></p>
<p>运行时中包含多个操作系统对状态转换方法的实现，所有的实现都包含在以 mem_ 开头的文件中，本节将介绍 Linux 操作系统对上图中方法的实现：</p>
<ul>
<li>runtime.sysAlloc 会从操作系统中获取一大块可用的内存空间，可能为几百 KB 或者几 MB；</li>
<li>runtime.sysFree 会在程序发生内存不足（Out-of Memory，OOM）时调用并无条件地返回内存；</li>
<li>runtime.sysReserve 会保留操作系统中的一片内存区域，对这片内存的访问会触发异常；</li>
<li>runtime.sysMap 保证内存区域可以快速转换至准备就绪；</li>
<li>runtime.sysUsed 通知操作系统应用程序需要使用该内存区域，需要保证内存区域可以安全访问；</li>
<li>runtime.sysUnused 通知操作系统虚拟内存对应的物理内存已经不再需要了，它可以重用物理内存；</li>
<li>runtime.sysFault 将内存区域转换成保留状态，主要用于运行时的调试；</li>
</ul>
<p>其中 sysAlloc、sysReserve 和 sysMap 都是向操作系统申请内存的操作，他们均涉及关于内存分配的系统调用就是 mmap，区别在于：</p>
<ul>
<li>sysAlloc 是从操作系统上申请清零后的内存，调用参数是 _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE；</li>
<li>sysReserve 是从操作系统中保留内存的地址空间，并未直接分配内存，调用参数是 _PROT_NONE,_MAP_ANON|_MAP_PRIVATE，；</li>
<li>sysMap 则是用于通知操作系统使用先前已经保留好的空间，参数是 _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_FIXED|_MAP_PRIVATE。</li>
</ul>
<p>不过 sysAlloc 和 sysReserve 都是操作系统对齐的内存，但堆分配器可能使用更大的对齐方式，因此这部分获得的内存都需要额外进行一些重排的工作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// runtime/mem_linux.go
</span><span class="c1"></span>
<span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sysAlloc</span><span class="p">(</span><span class="nx">n</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">sysStat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">mmap</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">_PROT_READ</span><span class="p">|</span><span class="nx">_PROT_WRITE</span><span class="p">,</span> <span class="nx">_MAP_ANON</span><span class="p">|</span><span class="nx">_MAP_PRIVATE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">_EACCES</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: mmap: access denied\n&#34;</span><span class="p">)</span>
			<span class="nf">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">_EAGAIN</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: mmap: too much locked memory (check &#39;ulimit -l&#39;).\n&#34;</span><span class="p">)</span>
			<span class="nf">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">p</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">sysReserve</span><span class="p">(</span><span class="nx">v</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">mmap</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">_PROT_NONE</span><span class="p">,</span> <span class="nx">_MAP_ANON</span><span class="p">|</span><span class="nx">_MAP_PRIVATE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">p</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">sysMap</span><span class="p">(</span><span class="nx">v</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">sysStat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">mmap</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">_PROT_READ</span><span class="p">|</span><span class="nx">_PROT_WRITE</span><span class="p">,</span> <span class="nx">_MAP_ANON</span><span class="p">|</span><span class="nx">_MAP_FIXED</span><span class="p">|</span><span class="nx">_MAP_PRIVATE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">_ENOMEM</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: out of memory&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="nx">v</span> <span class="o">||</span> <span class="nx">err</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: cannot map pages in arena address space&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>进程虚拟内存分布:</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210812175148.png" alt=""></p>
<p>Linux 下内存分配调用有多个：</p>
<ul>
<li>brk: 可以让进程的堆指针增长，从逻辑上消耗一块虚拟地址空间,只能通过调整 program break位置推动堆增⻓.</li>
<li>mmap: 可以让进程的虚拟地址空间切分出一块指定大小的虚拟地址空间，mmap 映射返回的地址也是从逻辑上被消耗的，需要通过 unmap 进行回收。可以从任意未分配位置映射内存</li>
</ul>
<p>熟悉 C 语言的读者应该知道 malloc，它只是 C 语言的标准库函数，本质上是通过上述两个系统调用完成， 当分配内存较小时调用 brk，反之则会调用 mmap。不过 64 位系统上的 Go 运行时并没有使用 brk，目的很明显， 是为了能够更加灵活的控制虚拟地址空间。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210812175016.png" alt=""></p>
<p>而对于 unmap 操作，它被封装在了 sysFree 中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sysFree</span><span class="p">(</span><span class="nx">v</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">sysStat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
	<span class="nf">munmap</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>sysUnused、sysUsed 是 madvice 的封装，我们知道 madvice 用于向操作系统通知某段内存区域是否被应用所使用。sysFault 用于将 sysAlloc 获得的内存区域标记为故障，只用于运行时调试。</p>
<p>最后我们来理一下这些系统级调用的关系：</p>
<ul>
<li>当开始保留内存地址时，调用 sysReserve；</li>
<li>当需要使用或不适用保留的内存区域时通知操作系统，调用 sysUnused、sysUsed；</li>
<li>正式使用保留的地址，使用 sysMap；</li>
<li>释放时使用 sysFree 以及调试时使用 sysFault；</li>
<li>非用户态的调试、堆外内存则使用 sysAlloc 直接向操作系统获得清零的内存。</li>
</ul>
<p>运行时使用 Linux 提供的 mmap、munmap 和 madvise 等系统调用实现了操作系统的内存管理抽象层，抹平了不同操作系统的差异，为运行时提供了更加方便的接口，除了 Linux 之外，运行时还实现了 BSD、Darwin、Plan9 以及 Windows 等平台上抽象层。</p>
<h2 id="整体架构">整体架构</h2>
<p>Go 的内存分配器主要包含以下几个核心组件：</p>
<ul>
<li>heapArena: 保留整个虚拟地址空间</li>
<li>mheap：分配的堆，在页大小为 8KB 的粒度上进行管理</li>
<li>mspan：是 mheap 上管理的一连串的页</li>
<li>mcentral：收集了给定大小等级的所有 span</li>
<li>mcache：为 per-P 的缓存。</li>
</ul>
<p>其中页是向操作系统申请内存的最小单位，目前设计为 8KB。</p>
<p>传统意义上的栈被 Go 的运行时霸占，不开放给用户态代码；而传统意义上的堆内存，又被 Go 运行时划分为了两个部分， 一个是 Go 运行时自身所需的堆内存，即堆外内存；另一部分则用于 Go 用户态代码所使用的堆内存，也叫做 Go 堆。 Go 堆负责了用户态对象的存放以及 goroutine 的执行栈。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123150846.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210817225406.png" alt=""></p>
<p>所有的 Go 语言程序都会在启动时初始化如上图所示的内存布局，每一个处理器都会被分配一个线程缓存 runtime.mcache 用于处理微对象和小对象的分配，它们会持有runtime.mspan。</p>
<p>每个类型的mspan都会管理特定大小的对象，当mspan中不存在空闲对象时，它们会从 runtime.mheap 持有的 134 个中心缓存 runtime.mcentral 中获取新的内存单元，中心缓存属于全局的堆结构体 runtime.mheap，它会从操作系统中申请内存。</p>
<p>在 amd64 的 Linux 操作系统上，runtime.mheap 会持有 4,194,304 runtime.heapArena，每一个 runtime.heapArena 都会管理 64MB 的内存，单个 Go 语言程序的内存上限也就是 256TB。</p>
<h2 id="虚拟地址空间heaparena">虚拟地址空间:heapArena</h2>
<p>Go 堆被视为由多个 arena 组成，每个 arena 在 64 位机器上为 64MB，且起始地址与 arena 的大小对齐， 所有的 arena 覆盖了整个 Go 堆的地址空间。</p>
<p>Go语言中对于heapArena有精准的管理，精准到每一个指针大小的内存信息，每一个page对应的mspan信息都有记录。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">pageSize</span>             <span class="p">=</span> <span class="mi">8192</span>                       <span class="c1">// 8KB
</span><span class="c1"></span>	<span class="nx">heapArenaBytes</span>       <span class="p">=</span> <span class="mi">67108864</span>                   <span class="c1">// 64MB
</span><span class="c1"></span>	<span class="nx">heapArenaBitmapBytes</span> <span class="p">=</span> <span class="nx">heapArenaBytes</span> <span class="o">/</span> <span class="mi">32</span>        <span class="c1">// 2097152
</span><span class="c1"></span>	<span class="nx">pagesPerArena</span>        <span class="p">=</span> <span class="nx">heapArenaBytes</span> <span class="o">/</span> <span class="nx">pageSize</span>  <span class="c1">// 8192
</span><span class="c1"></span><span class="p">)</span>

<span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">heapArena</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// heapArena中bitmap用每2个bit记录一个指针大小（8byte）的内存信息，主要用于gc
</span><span class="c1"></span>	<span class="nx">bitmap</span>     <span class="p">[</span><span class="nx">heapArenaBitmapBytes</span><span class="p">]</span><span class="kt">byte</span>
	<span class="c1">// spans 将 page ID 对应到 arena 里的 mspan
</span><span class="c1"></span>	<span class="nx">spans</span>      <span class="p">[</span><span class="nx">pagesPerArena</span><span class="p">]</span><span class="o">*</span><span class="nx">mspan</span>
	<span class="nx">pageInUse</span>  <span class="p">[</span><span class="nx">pagesPerArena</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span><span class="kt">uint8</span>
	<span class="nx">pageMarks</span>  <span class="p">[</span><span class="nx">pagesPerArena</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span><span class="kt">uint8</span>
	<span class="nx">zeroedBase</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="arenahint">arenaHint</h3>
<p>结构比较简单，是 arenaHint 链表的节点结构，保存了 arena 的起始地址、是否为最后一个 arena，以及下一个 arenaHint 指针。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">arenaHint</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">addr</span> <span class="kt">uintptr</span>
	<span class="nx">down</span> <span class="kt">bool</span>
	<span class="nx">next</span> <span class="o">*</span><span class="nx">arenaHint</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="内存基本单元mspan">内存基本单元:mspan</h2>
<p>runtime.mspan 是 Go 语言内存管理的基本单元.</p>
<p>管理 arena 如此粒度的内存并不符合实践，相反，所有的堆对象都通过 span 按照预先设定好的 大小等级分别分配，小于 32KB 的小对象则分配在固定大小等级的 span 上，否则直接从 mheap 上进行分配。</p>
<p>mspan 是相同大小等级的 span 的双向链表的一个节点，每个节点还记录了自己的起始地址、 指向的 span 中页的数量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:notinheap
</span><span class="c1">// 双向链表
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">mspan</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// 链表中的下一个 span，如果为空则为 nil
</span><span class="c1"></span>	<span class="nx">next</span> <span class="o">*</span><span class="nx">mspan</span>     <span class="c1">// next span in list, or nil if none
</span><span class="c1"></span>	<span class="c1">// 链表中的前一个 span，如果为空则为 nil
</span><span class="c1"></span>	<span class="nx">prev</span> <span class="o">*</span><span class="nx">mspan</span>     <span class="c1">// previous span in list, or nil if none
</span><span class="c1"></span>	<span class="nx">list</span> <span class="o">*</span><span class="nx">mSpanList</span> <span class="c1">// For debugging. TODO: Remove.
</span><span class="c1"></span>	<span class="c1">// startAddr 和 npages 确定该结构体管理的多个页所在的内存，每个页的大小都是 8KB；
</span><span class="c1"></span>	<span class="c1">// span 的第一个字节的地址，即 s.base()
</span><span class="c1"></span>	<span class="nx">startAddr</span> <span class="kt">uintptr</span> <span class="c1">// address of first byte of span aka s.base()
</span><span class="c1"></span>	<span class="c1">// 一个 span 中的 page 数量
</span><span class="c1"></span>	<span class="nx">npages</span>    <span class="kt">uintptr</span> <span class="c1">// number of pages in span
</span><span class="c1"></span>	<span class="c1">// mSpanManual span 的释放对象链表
</span><span class="c1"></span>	<span class="nx">manualFreeList</span> <span class="nx">gclinkptr</span> <span class="c1">// list of free objects in mSpanManual spans
</span><span class="c1"></span>
	<span class="c1">// freeindex is the slot index between 0 and nelems at which to begin scanning
</span><span class="c1"></span>	<span class="c1">// for the next free object in this span.
</span><span class="c1"></span>	<span class="c1">// Each allocation scans allocBits starting at freeindex until it encounters a 0
</span><span class="c1"></span>	<span class="c1">// indicating a free object. freeindex is then adjusted so that subsequent scans begin
</span><span class="c1"></span>	<span class="c1">// just past the newly discovered free object.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If freeindex == nelem, this span has no free objects.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// allocBits is a bitmap of objects in this span.
</span><span class="c1"></span>	<span class="c1">// If n &gt;= freeindex and allocBits[n/8] &amp; (1&lt;&lt;(n%8)) is 0
</span><span class="c1"></span>	<span class="c1">// then object n is free;
</span><span class="c1"></span>	<span class="c1">// otherwise, object n is allocated. Bits starting at nelem are
</span><span class="c1"></span>	<span class="c1">// undefined and should never be referenced.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Object n starts at address n*elemsize + (start &lt;&lt; pageShift).
</span><span class="c1"></span>	<span class="c1">//扫描页中空闲对象的初始索引
</span><span class="c1"></span>	<span class="nx">freeindex</span> <span class="kt">uintptr</span>
	<span class="c1">// TODO: Look up nelems from sizeclass and remove this field if it
</span><span class="c1"></span>	<span class="c1">// helps performance.
</span><span class="c1"></span>	<span class="c1">// span 中对象的数量
</span><span class="c1"></span>	<span class="nx">nelems</span> <span class="kt">uintptr</span> <span class="c1">// number of object in the span.
</span><span class="c1"></span>
	<span class="c1">// Cache of the allocBits at freeindex. allocCache is shifted
</span><span class="c1"></span>	<span class="c1">// such that the lowest bit corresponds to the bit freeindex.
</span><span class="c1"></span>	<span class="c1">// allocCache holds the complement of allocBits, thus allowing
</span><span class="c1"></span>	<span class="c1">// ctz (count trailing zero) to use it directly.
</span><span class="c1"></span>	<span class="c1">// allocCache may contain bits beyond s.nelems; the caller must ignore
</span><span class="c1"></span>	<span class="c1">// these.
</span><span class="c1"></span>	<span class="c1">//allocBits 的补码，可以用于快速查找内存中未被使用的内存；
</span><span class="c1"></span>	<span class="nx">allocCache</span> <span class="kt">uint64</span>

	<span class="c1">// allocBits and gcmarkBits hold pointers to a span&#39;s mark and
</span><span class="c1"></span>	<span class="c1">// allocation bits. The pointers are 8 byte aligned.
</span><span class="c1"></span>	<span class="c1">// There are three arenas where this data is held.
</span><span class="c1"></span>	<span class="c1">// free: Dirty arenas that are no longer accessed
</span><span class="c1"></span>	<span class="c1">//       and can be reused.
</span><span class="c1"></span>	<span class="c1">// next: Holds information to be used in the next GC cycle.
</span><span class="c1"></span>	<span class="c1">// current: Information being used during this GC cycle.
</span><span class="c1"></span>	<span class="c1">// previous: Information being used during the last GC cycle.
</span><span class="c1"></span>	<span class="c1">// A new GC cycle starts with the call to finishsweep_m.
</span><span class="c1"></span>	<span class="c1">// finishsweep_m moves the previous arena to the free arena,
</span><span class="c1"></span>	<span class="c1">// the current arena to the previous arena, and
</span><span class="c1"></span>	<span class="c1">// the next arena to the current arena.
</span><span class="c1"></span>	<span class="c1">// The next arena is populated as the spans request
</span><span class="c1"></span>	<span class="c1">// memory to hold gcmarkBits for the next GC cycle as well
</span><span class="c1"></span>	<span class="c1">// as allocBits for newly allocated spans.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The pointer arithmetic is done &#34;by hand&#34; instead of using
</span><span class="c1"></span>	<span class="c1">// arrays to avoid bounds checks along critical performance
</span><span class="c1"></span>	<span class="c1">// paths.
</span><span class="c1"></span>	<span class="c1">// The sweep will free the old allocBits and set allocBits to the
</span><span class="c1"></span>	<span class="c1">// gcmarkBits. The gcmarkBits are replaced with a fresh zeroed
</span><span class="c1"></span>	<span class="c1">// out memory.
</span><span class="c1"></span>	<span class="c1">//分别用于标记内存的占用和回收情况；
</span><span class="c1"></span>	<span class="nx">allocBits</span>  <span class="o">*</span><span class="nx">gcBits</span>
	<span class="nx">gcmarkBits</span> <span class="o">*</span><span class="nx">gcBits</span>

	<span class="c1">// sweep generation:
</span><span class="c1"></span>	<span class="c1">// if sweepgen == h-&gt;sweepgen - 2, the span needs sweeping
</span><span class="c1"></span>	<span class="c1">// if sweepgen == h-&gt;sweepgen - 1, the span is currently being swept
</span><span class="c1"></span>	<span class="c1">// if sweepgen == h-&gt;sweepgen, the span is swept and ready to use
</span><span class="c1"></span>	<span class="c1">// if sweepgen == h-&gt;sweepgen + 1, the span was cached before sweep began and is still cached, and needs sweeping
</span><span class="c1"></span>	<span class="c1">// if sweepgen == h-&gt;sweepgen + 3, the span was swept and then cached and is still cached
</span><span class="c1"></span>	<span class="c1">// h-&gt;sweepgen is incremented by 2 after every GC
</span><span class="c1"></span>
	<span class="nx">sweepgen</span>    <span class="kt">uint32</span>
	<span class="nx">divMul</span>      <span class="kt">uint16</span>        <span class="c1">// for divide by elemsize - divMagic.mul
</span><span class="c1"></span>	<span class="nx">baseMask</span>    <span class="kt">uint16</span>        <span class="c1">// if non-0, elemsize is a power of 2, &amp; this will get object allocation base
</span><span class="c1"></span>	<span class="c1">// 分配对象的数量
</span><span class="c1"></span>	<span class="nx">allocCount</span>  <span class="kt">uint16</span>        <span class="c1">// number of allocated objects
</span><span class="c1"></span>	<span class="c1">// 大小等级与 noscan (uint8)
</span><span class="c1"></span>	<span class="nx">spanclass</span>   <span class="nx">spanClass</span>     <span class="c1">// size class and noscan (uint8)
</span><span class="c1"></span>	<span class="c1">// mspaninuse 等等信息
</span><span class="c1"></span>	<span class="c1">// mspan状态，共有四种状态
</span><span class="c1"></span>  	<span class="c1">// _MSpanDead、_MSpanInUse、_MSpanManual、_MSpanFree
</span><span class="c1"></span>	<span class="nx">state</span>       <span class="nx">mSpanStateBox</span> <span class="c1">// mSpanInUse etc; accessed atomically (get/set methods)
</span><span class="c1"></span> 	<span class="c1">// 从当前mspan分配对象时，是否需要将对象的内存空间初始化为0
</span><span class="c1"></span>	<span class="nx">needzero</span>    <span class="kt">uint8</span>         <span class="c1">// needs to be zeroed before allocation
</span><span class="c1"></span>	<span class="nx">divShift</span>    <span class="kt">uint8</span>         <span class="c1">// for divide by elemsize - divMagic.shift
</span><span class="c1"></span>	<span class="nx">divShift2</span>   <span class="kt">uint8</span>         <span class="c1">// for divide by elemsize - divMagic.shift2
</span><span class="c1"></span>	<span class="c1">// mspan能分配的对象大小
</span><span class="c1"></span>	<span class="nx">elemsize</span>    <span class="kt">uintptr</span>       <span class="c1">// computed from sizeclass or from npages
</span><span class="c1"></span>	<span class="c1">// 当前mspan指向空间的结束为止+1字节
</span><span class="c1"></span>	<span class="nx">limit</span>       <span class="kt">uintptr</span>       <span class="c1">// end of data in span
</span><span class="c1"></span>	<span class="nx">speciallock</span> <span class="nx">mutex</span>         <span class="c1">// guards specials list
</span><span class="c1"></span>	<span class="nx">specials</span>    <span class="o">*</span><span class="nx">special</span>      <span class="c1">// linked list of special records sorted by offset.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>串联后的上述结构体会构成如下双向链表，运行时会使用 runtime.mSpanList 存储双向链表的头结点和尾节点并在线程缓存以及中心缓存中使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">mSpanList</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">first</span> <span class="o">*</span><span class="nx">mspan</span> <span class="c1">// first span in list, or nil if none
</span><span class="c1"></span>	<span class="nx">last</span>  <span class="o">*</span><span class="nx">mspan</span> <span class="c1">// last span in list, or nil if none
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123151356.png" alt=""></p>
<p>因为相邻的管理单元会互相引用，所以我们可以从任意一个结构体访问双向链表中的其他节点。</p>
<p>每个 runtime.mspan 都管理 npages 个大小为 8KB 的页，这里的页不是操作系统中的内存页，它们是操作系统内存页的整数倍</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">_PageShift</span>      <span class="p">=</span> <span class="mi">13</span>
<span class="nx">_PageSize</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">_PageShift</span>
</code></pre></td></tr></table>
</div>
</div><p>该结构体会使用下面的这些字段来管理内存页的分配和回收：</p>
<ul>
<li>startAddr 和 npages — 确定该结构体管理的多个页所在的内存，每个页的大小都是 8KB；</li>
<li>freeindex — 扫描页中空闲对象的初始索引；</li>
<li>allocBits 和 gcmarkBits — 分别用于标记内存的占用和回收情况；</li>
<li>allocCache — allocBits 的补码，可以用于快速查找内存中未被使用的内存；</li>
</ul>
<p>runtime.mspan 会以两种不同的视角看待管理的内存，当结构体管理的内存不足时，运行时会以页为单位向堆申请内存：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123152539.png" alt=""></p>
<ul>
<li>
<p>nelems代表这个mspan中可以存放多少对象，等于<code>(npages * pageSize)/elemsize</code>；</p>
</li>
<li>
<p>elemsize表示一个对象会占用多个个bytes，等于<code>class_to_size[sizeclass]</code>，需要注意的是sizeclass每次获取的时候会sizeclass方法，将sizeclass&raquo;1；</p>
</li>
<li>
<p>limit表示span结束的地址值，等于<code>startAddr+ npages*pageSize</code>；</p>
</li>
</ul>
<p>当用户程序或者线程向 runtime.mspan 申请内存时，该结构会使用 allocCache 字段以对象为单位在管理的内存中快速查找待分配的空间：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123152923.png" alt=""></p>
<p>堆中无论是空闲还是使用中的内存，都使用mspan对象来表达。mspan中持有系统页整数倍的内存空间。通过state状态标记来标识当前mspan是被使用中还是空闲中。</p>
<p>mspan中持有的空间，可用来分配一个或多个相同类型的对象空间，elemsize表明了对象类型占用的空间大小。nelems表明了当前mspan下可以分配对象的最大数量。</p>
<p>mspan在mheap、mcentral、mcache中都有缓存。</p>
<p>区别在于，在mheap中缓存的mspan对象是以page为单位的，npages表明了mheap中的mspan对象所持有的系统页数量。mheap分配空间时，根据需求的page数量，分配合适的mspan给使用者。mheap不会分配半个mspan给使用者。</p>
<p>而在mcentral、mcache中的mspan，是以spanclass来划分的，spanclass可以理解为一个限定的对象大小。一个mspan被分配到mcentral或mcache后，它的spanclass是固定的，意味着在这个mspan上，只能分配大小固定的对象。详见spanclass。</p>
<h3 id="spanclass">spanClass</h3>
<p>runtime.spanClass 是 runtime.mspan 结构体的跨度类，它决定了mspan中存储的对象大小和个数：</p>
<p>Go 语言的内存管理模块中一共包含 67 种跨度类，每一个跨度类都会存储特定大小的对象并且包含特定数量的页数以及对象，所有的数据都会被预选计算好并存储在 runtime.class_to_size 和 runtime.class_to_allocnpages 等变量中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">class_to_size</span> <span class="p">=</span> <span class="p">[</span><span class="nx">_NumSizeClasses</span><span class="p">]</span><span class="kt">uint16</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">48</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">96</span><span class="p">,</span> <span class="mi">112</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">144</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">176</span><span class="p">,</span> <span class="mi">192</span><span class="p">,</span> <span class="mi">208</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">288</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">352</span><span class="p">,</span> <span class="mi">384</span><span class="p">,</span> <span class="mi">416</span><span class="p">,</span> <span class="mi">448</span><span class="p">,</span> <span class="mi">480</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">576</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">704</span><span class="p">,</span> <span class="mi">768</span><span class="p">,</span> <span class="mi">896</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="mi">1152</span><span class="p">,</span> <span class="mi">1280</span><span class="p">,</span> <span class="mi">1408</span><span class="p">,</span> <span class="mi">1536</span><span class="p">,</span> <span class="mi">1792</span><span class="p">,</span> <span class="mi">2048</span><span class="p">,</span> <span class="mi">2304</span><span class="p">,</span> <span class="mi">2688</span><span class="p">,</span> <span class="mi">3072</span><span class="p">,</span> <span class="mi">3200</span><span class="p">,</span> <span class="mi">3456</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="mi">4864</span><span class="p">,</span> <span class="mi">5376</span><span class="p">,</span> <span class="mi">6144</span><span class="p">,</span> <span class="mi">6528</span><span class="p">,</span> <span class="mi">6784</span><span class="p">,</span> <span class="mi">6912</span><span class="p">,</span> <span class="mi">8192</span><span class="p">,</span> <span class="mi">9472</span><span class="p">,</span> <span class="mi">9728</span><span class="p">,</span> <span class="mi">10240</span><span class="p">,</span> <span class="mi">10880</span><span class="p">,</span> <span class="mi">12288</span><span class="p">,</span> <span class="mi">13568</span><span class="p">,</span> <span class="mi">14336</span><span class="p">,</span> <span class="mi">16384</span><span class="p">,</span> <span class="mi">18432</span><span class="p">,</span> <span class="mi">19072</span><span class="p">,</span> <span class="mi">20480</span><span class="p">,</span> <span class="mi">21760</span><span class="p">,</span> <span class="mi">24576</span><span class="p">,</span> <span class="mi">27264</span><span class="p">,</span> <span class="mi">28672</span><span class="p">,</span> <span class="mi">32768</span><span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><table>
<thead>
<tr>
<th>class</th>
<th>bytes/obj</th>
<th>bytes/span</th>
<th>objects</th>
<th>tail waste</th>
<th>max waste</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>8</td>
<td>8192</td>
<td>1024</td>
<td>0</td>
<td>87.50%</td>
</tr>
<tr>
<td>2</td>
<td>16</td>
<td>8192</td>
<td>512</td>
<td>0</td>
<td>43.75%</td>
</tr>
<tr>
<td>3</td>
<td>32</td>
<td>8192</td>
<td>256</td>
<td>0</td>
<td>46.88%</td>
</tr>
<tr>
<td>4</td>
<td>48</td>
<td>8192</td>
<td>170</td>
<td>32</td>
<td>31.52%</td>
</tr>
<tr>
<td>5</td>
<td>64</td>
<td>8192</td>
<td>128</td>
<td>0</td>
<td>23.44%</td>
</tr>
<tr>
<td>6</td>
<td>80</td>
<td>8192</td>
<td>102</td>
<td>32</td>
<td>19.07%</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>66</td>
<td>32768</td>
<td>32768</td>
<td>1</td>
<td>0</td>
<td>12.50%</td>
</tr>
</tbody>
</table>
<p>上表展示了对象大小从 8B 到 32KB，总共 66 种跨度类的大小、存储的对象数以及浪费的内存空间，以表中的第四个跨度类为例，跨度类为 4 的 runtime.mspan 中对象的大小上限为 48 字节、管理 1 个页、最多可以存储 170 个对象。因为内存需要按照页进行管理，所以在尾部会浪费 32 字节的内存，当页中存储的对象都是 33 字节时，最多会浪费 31.52% 的资源：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123154041.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123154327.png" alt=""></p>
<p>除了上述 66 个跨度类之外，运行时中还包含 ID 为 0 的特殊跨度类，它能够管理大于 32KB 的特殊对象，我们会在后面详细介绍大对象的分配过程，在这里就不展开说明了。</p>
<p>跨度类中除了存储类别的 ID 之外，它还会存储一个 noscan 标记位，该标记位表示对象是否包含指针，垃圾回收会对包含指针的 runtime.mspan 结构体进行扫描。我们可以通过下面的几个函数和方法了解 ID 和标记位的底层存储方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makeSpanClass</span><span class="p">(</span><span class="nx">sizeclass</span> <span class="kt">uint8</span><span class="p">,</span> <span class="nx">noscan</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">spanClass</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">spanClass</span><span class="p">(</span><span class="nx">sizeclass</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="p">|</span> <span class="nf">spanClass</span><span class="p">(</span><span class="nf">bool2int</span><span class="p">(</span><span class="nx">noscan</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sc</span> <span class="nx">spanClass</span><span class="p">)</span> <span class="nf">sizeclass</span><span class="p">()</span> <span class="kt">int8</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">int8</span><span class="p">(</span><span class="nx">sc</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sc</span> <span class="nx">spanClass</span><span class="p">)</span> <span class="nf">noscan</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">sc</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime.spanClass 是一个 uint8 类型的整数，它的前 7 位存储着跨度类的 ID，最后一位表示是否包含指针，该类型提供的两个方法能够帮我们快速获取对应的字段。</p>
<p>我们如何判定一个span占用几页呢？ 实际上占用的页数与我们刚才选定的切分的大小是一一对应的，在sizeclasses.go中还有一个长度为67的数组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">class_to_allocnpages</span> <span class="p">=</span> <span class="p">[</span><span class="nx">_NumSizeClasses</span><span class="p">]</span><span class="kt">uint8</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>比如说，当我们选定spanclass为3时，我们要切分的大小为32字节，那么我们分配span的页数就是1。</p>
<h3 id="状态">状态</h3>
<p>运行时会使用 runtime.mSpanStateBox 结构体存储mspan的状态 runtime.mSpanState：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="c1">// 当mspan被创建和初始化时，状态为dead
</span><span class="c1"></span>	<span class="nx">_MSpanDead</span>   <span class="nx">mSpanState</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="c1">// 无论是在mcentral、mcache中缓存的mspan，还是通过largeAlloc分配的大
</span><span class="c1"></span>	<span class="c1">// 内存mspan，只要是存在于mheap的busy列表中的mspan，都会被置为inuse状态
</span><span class="c1"></span>	<span class="nx">_MSpanInUse</span>
	<span class="c1">// Manual申请的内存，会被标记为Manual，这部分内存不会通过GC来归还，需要
</span><span class="c1"></span>	<span class="c1">// 使用者显式调用freeManual归还到堆缓存
</span><span class="c1"></span>	<span class="c1">// 此外allocSpanLocked中堆返回内存量大于请求量时，归还部分内存会暂时把
</span><span class="c1"></span>	<span class="c1">// 两个连续mspan的状态置为Manual，避免free合并刚申请的空间。
</span><span class="c1"></span>	<span class="nx">_MSpanManual</span>
	<span class="c1">// 处于堆缓存free列表和mtreap的mspan会被置为free状态。
</span><span class="c1"></span>	<span class="nx">_MSpanFree</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>该状态可能处于 mSpanDead、mSpanInUse、mSpanManual 和 mSpanFree 四种情况。当 runtime.mspan 在空闲堆中，它会处于 mSpanFree 状态；当 runtime.mspan 已经被分配时，它会处于 mSpanInUse、mSpanManual 状态，这些状态会在遵循以下规则发生转换：</p>
<ul>
<li>在垃圾回收的任意阶段，可能从 mSpanFree 转换到 mSpanInUse 和 mSpanManual；</li>
<li>在垃圾回收的清除阶段，可能从 mSpanInUse 和 mSpanManual 转换到 mSpanFree；</li>
<li>在垃圾回收的标记阶段，不能从 mSpanInUse 和 mSpanManual 转换到 mSpanFree；</li>
</ul>
<p>设置 runtime.mspan 结构体状态的读写操作必须是原子性的避免垃圾回收造成的线程竞争问题。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201227175238.png" alt=""></p>
<h3 id="alloccache">allocCache</h3>
<p>mspan中拥有allocCache字段，其作为一个位图，用于标记span元素中的大小。由于allocCache元素为uint64大小，因此其最多一次缓存64位的大小。</p>
<p>allocCache使用从后往前的方式与span中元素对应起来。例如allocCache中最后一个bit位对应的是span元素中最前的一个元素。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210816185332.png" alt=""></p>
<p>有时候，span中元素的个数大于64个，因此需要专门有一个字段freeindex来标识当前span中元素分配到了哪里。在span中小于freeindex序号的元素意味着都已经分配了，将从freeindex开始继续分配。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210816185522.png" alt=""></p>
<p>因此，只要从acclocCache开始找到哪一位为0即可。假如找到了X位为0，那么X + freeindex 为当前span中可用的元素序号。当allocCache中全部都已经标记为1后，就需要移动freeindex ，并更新allocCache。一直到达span元素末尾为止。</p>
<h2 id="微小对象分配器mcache">微小对象分配器:mcache</h2>
<p>runtime.mcache 是 Go 语言中的线程缓存，它会与线程上的处理器一一绑定，是一个 per-P 的缓存,主要用来缓存用户程序申请的微小对象。每一个线程缓存都持有 67 * 2 个 runtime.mspan，这些mspan都存储在结构体的 alloc 字段中：</p>
<p>mcache 是一个 per-P 的缓存，因此每个线程都只访问自身的 mcache，因此也就不会出现并发，也就省去了对其进行加锁步骤。</p>
<p>它是一个包含不同大小等级的 span 链表的数组，其中 mcache.alloc 的每一个数组元素 都是某一个特定大小的 mspan 的链表头指针。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210817182027.png" alt=""></p>
<p>图中alloc是一个拥有134个元素的mspan数组，mspan数组管理数个page大小的内存，每个page是8k，page的数量由spanclass规格决定。</p>
<p>线程缓存在刚刚被初始化时是不包含 runtime.mspan 的，只有当用户程序申请内存时才会从上一级组件获取新的 runtime.mspan 满足内存分配的需求。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Per-thread (in Go, per-P) cache for small objects.
</span><span class="c1">// No locking needed because it is per-thread (per-P).
</span><span class="c1">//
</span><span class="c1">// mcaches are allocated from non-GC&#39;d memory, so any heap pointers
</span><span class="c1">// must be specially handled.
</span><span class="c1">//
</span><span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">mcache</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// The following members are accessed on every malloc,
</span><span class="c1"></span>	<span class="c1">// so they are grouped here for better caching.
</span><span class="c1"></span>	<span class="c1">// 分配这么多字节后触发堆样本
</span><span class="c1"></span>	<span class="nx">next_sample</span> <span class="kt">uintptr</span> <span class="c1">// trigger heap sample after allocating this many bytes
</span><span class="c1"></span>	<span class="c1">// 分配的可扫描堆的字节数
</span><span class="c1"></span>	<span class="nx">local_scan</span>  <span class="kt">uintptr</span> <span class="c1">// bytes of scannable heap allocated
</span><span class="c1"></span>
	<span class="c1">// Allocator cache for tiny objects w/o pointers.
</span><span class="c1"></span>	<span class="c1">// See &#34;Tiny allocator&#34; comment in malloc.go.
</span><span class="c1"></span>
	<span class="c1">// tiny points to the beginning of the current tiny block, or
</span><span class="c1"></span>	<span class="c1">// nil if there is no current tiny block.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// tiny is a heap pointer. Since mcache is in non-GC&#39;d memory,
</span><span class="c1"></span>	<span class="c1">// we handle it by clearing it in releaseAll during mark
</span><span class="c1"></span>	<span class="c1">// termination.
</span><span class="c1"></span>	<span class="c1">// 没有指针的微小对象的分配器缓存。
</span><span class="c1"></span>	<span class="c1">// tiny 指向当前 tiny 块的起始位置，或当没有 tiny 块时候为 nil
</span><span class="c1"></span>	<span class="c1">// tiny 是一个堆指针。由于 mcache 在非 GC 内存中，我们通过在
</span><span class="c1"></span>	<span class="c1">// mark termination 期间在 releaseAll 中清除它来处理它。
</span><span class="c1"></span>	<span class="nx">tiny</span>             <span class="kt">uintptr</span>
	<span class="c1">// tinyOffset 是下一个空闲内存所在的偏移量
</span><span class="c1"></span>	<span class="nx">tinyoffset</span>       <span class="kt">uintptr</span>
	<span class="c1">// 不计入其他统计的极小分配的数量
</span><span class="c1"></span>	<span class="c1">//已经分配的对象个数
</span><span class="c1"></span>	<span class="nx">local_tinyallocs</span> <span class="kt">uintptr</span> <span class="c1">// number of tiny allocs not counted in other stats
</span><span class="c1"></span>
	<span class="c1">// The rest is not accessed on every malloc.
</span><span class="c1"></span>	<span class="c1">// 用来分配的 spans，由 spanClass 索引
</span><span class="c1"></span>	<span class="c1">// 申请的134个span
</span><span class="c1"></span>	<span class="nx">alloc</span> <span class="p">[</span><span class="nx">numSpanClasses</span><span class="p">]</span><span class="o">*</span><span class="nx">mspan</span> <span class="c1">// spans to allocate from, indexed by spanClass
</span><span class="c1"></span>	<span class="c1">// 栈链表
</span><span class="c1"></span>	<span class="nx">stackcache</span> <span class="p">[</span><span class="nx">_NumStackOrders</span><span class="p">]</span><span class="nx">stackfreelist</span>
	<span class="c1">// 本地分配器统计，在 GC 期间被刷新
</span><span class="c1"></span>	<span class="c1">// Local allocator stats, flushed during GC.
</span><span class="c1"></span>	<span class="nx">local_largefree</span>  <span class="kt">uintptr</span>                  <span class="c1">// bytes freed for large objects (&gt;maxsmallsize)
</span><span class="c1"></span>	<span class="nx">local_nlargefree</span> <span class="kt">uintptr</span>                  <span class="c1">// number of frees for large objects (&gt;maxsmallsize)
</span><span class="c1"></span>	<span class="nx">local_nsmallfree</span> <span class="p">[</span><span class="nx">_NumSizeClasses</span><span class="p">]</span><span class="kt">uintptr</span> <span class="c1">// number of frees for small objects (&lt;=maxsmallsize)
</span><span class="c1"></span>
	<span class="c1">// flushGen indicates the sweepgen during which this mcache
</span><span class="c1"></span>	<span class="c1">// was last flushed. If flushGen != mheap_.sweepgen, the spans
</span><span class="c1"></span>	<span class="c1">// in this mcache are stale and need to the flushed so they
</span><span class="c1"></span>	<span class="c1">// can be swept. This is done in acquirep.
</span><span class="c1"></span>	<span class="nx">flushGen</span> <span class="kt">uint32</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当 mcache 中 span 的数量不够使用时，会向 mcentral 的 nonempty 列表中获得新的 span。</p>
<p>线程缓存中还包含几个用于分配微对象的字段，下面的这三个字段组成了微对象分配器，专门为 16 字节以下的对象申请和管理内存：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">mcache</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">tiny</span>             <span class="kt">uintptr</span>
	<span class="nx">tinyoffset</span>       <span class="kt">uintptr</span>
	<span class="nx">local_tinyallocs</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>微分配器只会用于分配非指针类型的内存，上述三个字段中 tiny 会指向堆中的一片内存，tinyOffset 是下一个空闲内存所在的偏移量，最后的 local_tinyallocs 会记录内存分配器中分配的对象个数。</p>
<p>Go 语言运行时将小于 16 字节的对象划分为微对象，它会使用线程缓存上的微分配器提高微对象分配的性能，我们主要使用它来分配较小的字符串以及逃逸的临时变量。微分配器可以将多个较小的内存分配请求合入同一个内存块中，只有当内存块中的所有对象都需要被回收时，整片内存才可能被回收。</p>
<p>微分配器管理的对象不可以是指针类型，管理多个对象的内存块大小 maxTinySize 是可以调整的，在默认情况下，内存块的大小为 16 字节。maxTinySize 的值越大，组合多个对象的可能性就越高，内存浪费也就越严重；maxTinySize 越小，内存浪费就会越少，不过无论如何调整，8 的倍数都是一个很好的选择。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123224958.png" alt=""></p>
<p>如上图所示，微分配器已经在 16 字节的内存块中分配了 12 字节的对象，如果下一个待分配的对象小于 4 字节，它就会直接使用上述内存块的剩余部分，减少内存碎片，不过该内存块只有在 3 个对象都被标记为垃圾时才会被回收。</p>
<p>寻找 span 的过程其实与小对象分配完全一致，区别在于微对象分配只寻找 tinySpanClass 大小等级的 span。 而且不会对这部分内存进行清零。</p>
<p>小对象是指大小为 16 字节到 32,768 字节的对象以及所有小于 16 字节的指针类型的对象.</p>
<p>当对一个小对象（&lt;32KB）分配内存时，会将该对象所需的内存大小调整到某个能够容纳该对象的大小等级（size class）， 并查看 mcache 中对应等级的 mspan，通过扫描 mspan 的 freeindex 来确定是否能够进行分配。</p>
<p>当没有可分配的 mspan 时，会从 mcentral 中获取一个所需大小空间的新的 mspan，从 mcentral 中分配会对其进行加锁， 但一次性获取整个 span 的过程均摊了对 mcentral 加锁的成本。</p>
<p>如果 mcentral 的 mspan 也为空时，则它也会发生增长，从而从 mheap 中获取一连串的页，作为一个新的 mspan 进行提供。 而如果 mheap 仍然为空，或者没有足够大的对象来进行分配时，则会从操作系统中分配一组新的页（至少 1MB）， 从而均摊与操作系统沟通的成本。</p>
<h3 id="初始化">初始化</h3>
<p>运行时在初始化处理器时会调用 runtime.allocmcache 初始化线程缓存，该函数会在系统栈中使用 runtime.mheap 中的线程缓存分配器初始化新的 runtime.mcache 结构体：</p>
<p>由于 mheap 是全局的，因此在分配期必须对其进行加锁，而分配通过 fixAlloc 组件完成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 虚拟的MSpan，不包含任何对象。
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">emptymspan</span> <span class="nx">mspan</span>
<span class="kd">func</span> <span class="nf">allocmcache</span><span class="p">()</span> <span class="o">*</span><span class="nx">mcache</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">mcache</span><span class="p">)(</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">cachealloc</span><span class="p">.</span><span class="nf">alloc</span><span class="p">())</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">flushGen</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span> <span class="p">{</span>
		<span class="c1">// 暂时指向虚拟的 mspan 中
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">emptymspan</span>
	<span class="p">}</span>
	<span class="c1">// 返回下一个采样点，是服从泊松过程的随机数
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">next_sample</span> <span class="p">=</span> <span class="nf">nextSample</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>就像我们在上面提到的，初始化后的 runtime.mcache 中的所有 runtime.mspan 都是空的占位符 emptymspan。</p>
<p>由于运行时提供了采样过程堆分析的支持， 由于我们的采样的目标是平均每个 MemProfileRate 字节对分配进行采样， 显然，在整个时间线上的分配情况应该是完全随机分布的，这是一个泊松过程。 因此最佳的采样点应该是服从指数分布 exp(MemProfileRate) 的随机数，其中 MemProfileRate 为均值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">nextSample</span><span class="p">()</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;plan9&#34;</span> <span class="p">{</span>
		<span class="c1">// Plan 9 doesn&#39;t support floating point in note handler.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">g</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">();</span> <span class="nx">g</span> <span class="o">==</span> <span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">gsignal</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nf">nextSampleNoFP</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">fastexprand</span><span class="p">(</span><span class="nx">MemProfileRate</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>MemProfileRate 是一个公共变量，可以在用户态代码进行修改：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">MemProfileRate</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">512</span> <span class="o">*</span> <span class="mi">1024</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="refill">refill</h3>
<p>runtime.mcache.refill 方法会为线程缓存获取一个指定跨度类的mspan，被替换的单元不能包含空闲的内存空间，而获取的单元中需要至少包含一个空闲对象用于分配内存：</p>
<p>可以看到 refill 其实是从 mcentral 调用 cacheSpan 方法来获得 span：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// refill acquires a new span of span class spc for c. This span will
</span><span class="c1">// have at least one free object. The current span in c must be full.
</span><span class="c1">//
</span><span class="c1">// Must run in a non-preemptible context since otherwise the owner of
</span><span class="c1">// c could change.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span><span class="p">)</span> <span class="nf">refill</span><span class="p">(</span><span class="nx">spc</span> <span class="nx">spanClass</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Return the current cached span to the central lists.
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>

	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;refill of span with free space remaining&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">emptymspan</span> <span class="p">{</span>
		<span class="c1">// Mark this span as no longer cached.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">!=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="o">+</span><span class="mi">3</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad sweepgen in refill&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">spc</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">uncacheSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Get a new cached span from the central lists.
</span><span class="c1"></span>	<span class="c1">// 向central进行申请
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">spc</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">cacheSpan</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;span has no free space&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Indicate that this span is cached and prevent asynchronous
</span><span class="c1"></span>	<span class="c1">// sweeping in the next sweep phase.
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">+</span> <span class="mi">3</span>

	<span class="c1">// Assume all objects from this span will be allocated in the
</span><span class="c1"></span>	<span class="c1">// mcache. If it gets uncached, we&#39;ll adjust this.
</span><span class="c1"></span>	<span class="nx">stats</span> <span class="o">:=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heapStats</span><span class="p">.</span><span class="nf">acquire</span><span class="p">()</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadduintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">stats</span><span class="p">.</span><span class="nx">smallAllocCount</span><span class="p">[</span><span class="nx">spc</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()],</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span><span class="o">-</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">))</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">heapStats</span><span class="p">.</span><span class="nf">release</span><span class="p">()</span>

	<span class="c1">// Update heap_live with the same assumption.
</span><span class="c1"></span>	<span class="nx">usedBytes</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">*</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="o">*</span><span class="nx">pageSize</span><span class="p">)</span><span class="o">-</span><span class="nb">int64</span><span class="p">(</span><span class="nx">usedBytes</span><span class="p">))</span>

	<span class="c1">// Flush tinyAllocs.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">spc</span> <span class="o">==</span> <span class="nx">tinySpanClass</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">tinyallocs</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">tinyAllocs</span><span class="p">))</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">tinyAllocs</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="c1">// While we&#39;re here, flush scanAlloc, since we have to call
</span><span class="c1"></span>	<span class="c1">// revise anyway.
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_scan</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">scanAlloc</span><span class="p">))</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">scanAlloc</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="c1">// heap_live changed.
</span><span class="c1"></span>		<span class="nf">traceHeapAlloc</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// heap_live and heap_scan changed.
</span><span class="c1"></span>		<span class="nx">gcController</span><span class="p">.</span><span class="nf">revise</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如上述代码所示，该函数会从中心缓存中申请新的 runtime.mspan 存储到线程缓存中，这也是向线程缓存中插入mspan的唯一方法。</p>
<h3 id="releaseall">releaseAll</h3>
<p>由于 mcache 从非 GC 内存上进行分配，因此出现的任何堆指针都必须进行特殊处理。 所以在释放前，需要调用 <code>mcache.releaseAll</code> 将堆指针进行处理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span><span class="p">)</span> <span class="nf">releaseAll</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span> <span class="p">{</span>
		<span class="nx">s</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">emptymspan</span> <span class="p">{</span>
			<span class="c1">// 将 span 归还
</span><span class="c1"></span>			<span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">uncacheSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">emptymspan</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 清空 tinyalloc 池.
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">freemcache</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// 归还 span
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">releaseAll</span><span class="p">()</span>
		<span class="c1">// 释放 stack
</span><span class="c1"></span>		<span class="nf">stackcache_clear</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>

		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="c1">// 记录局部统计
</span><span class="c1"></span>		<span class="nf">purgecachedstats</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
		<span class="c1">// 将 mcache 释放
</span><span class="c1"></span>		<span class="nx">mheap_</span><span class="p">.</span><span class="nx">cachealloc</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="p">})</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="per-p">per-P</h3>
<p>首先，mcache 是一个 per-P 的 mcache，我们很自然的疑问就是，这个 mcache 在 p/m 这两个结构体上都有成员：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">p</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">mcache</span>      <span class="o">*</span><span class="nf">mcache</span>
	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">m</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">mcache</span>      <span class="o">*</span><span class="nf">mcache</span>
	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>那么 mcache 是跟着谁跑的？结合调度器的知识不难发现，m 在执行时需要持有一个 p 才具备执行能力。 有利的证据是，当调用 runtime.procresize 时，初始化新的 P 时，mcache 是直接分配到 p 的； 回收 p 时，mcache 是直接从 p 上获取：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">procresize</span><span class="p">(</span><span class="nx">nprocs</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">p</span> <span class="p">{</span>
	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
	<span class="c1">// 初始化新的 P
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">nprocs</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">pp</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">(</span><span class="o">...</span><span class="p">)</span>
		<span class="c1">// 为 P 分配 cache 对象
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">mcache</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">old</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;missing mcache?&#34;</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nx">pp</span><span class="p">.</span><span class="nx">mcache</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="c1">// 创建 cache
</span><span class="c1"></span>				<span class="nx">pp</span><span class="p">.</span><span class="nx">mcache</span> <span class="p">=</span> <span class="nf">allocmcache</span><span class="p">()</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="p">(</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 释放未使用的 P
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">nprocs</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">old</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">(</span><span class="o">...</span><span class="p">)</span>
		<span class="c1">// 释放当前 P 绑定的 cache
</span><span class="c1"></span>		<span class="nf">freemcache</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">mcache</span><span class="p">)</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">mcache</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">(</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>因而我们可以明确：</p>
<ul>
<li>mcache 会被 P 持有，当 M 和 P 绑定时，M 同样会保留 mcache 的指针</li>
<li>mcache 直接向操作系统申请内存，且常驻运行时</li>
<li>P 通过 make 命令进行分配，会分配在 Go 堆上</li>
</ul>
<h2 id="中心缓存mcentral">中心缓存:mcentral</h2>
<p>runtime.mcentral 是内存分配器的中心缓存，与线程缓存不同，访问中心缓存中的mspan需要使用互斥锁：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Central list of free objects of a given size.
</span><span class="c1">//
</span><span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">mcentral</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span>      <span class="nx">mutex</span>
	<span class="nx">spanclass</span> <span class="nx">spanClass</span>

	<span class="c1">// For !go115NewMCentralImpl.
</span><span class="c1"></span>	<span class="c1">// 不包含空闲对象的链表
</span><span class="c1"></span>	<span class="nx">nonempty</span> <span class="nx">mSpanList</span> <span class="c1">// list of spans with a free object, ie a nonempty free list
</span><span class="c1"></span>	<span class="c1">// 包含空闲对象的列表
</span><span class="c1"></span>	<span class="nx">empty</span>    <span class="nx">mSpanList</span> <span class="c1">// list of spans with no free objects (or cached in an mcache)
</span><span class="c1"></span>
	<span class="c1">// partial and full contain two mspan sets: one of swept in-use
</span><span class="c1"></span>	<span class="c1">// spans, and one of unswept in-use spans. These two trade
</span><span class="c1"></span>	<span class="c1">// roles on each GC cycle. The unswept set is drained either by
</span><span class="c1"></span>	<span class="c1">// allocation or by the background sweeper in every GC cycle,
</span><span class="c1"></span>	<span class="c1">// so only two roles are necessary.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// sweepgen is increased by 2 on each GC cycle, so the swept
</span><span class="c1"></span>	<span class="c1">// spans are in partial[sweepgen/2%2] and the unswept spans are in
</span><span class="c1"></span>	<span class="c1">// partial[1-sweepgen/2%2]. Sweeping pops spans from the
</span><span class="c1"></span>	<span class="c1">// unswept set and pushes spans that are still in-use on the
</span><span class="c1"></span>	<span class="c1">// swept set. Likewise, allocating an in-use span pushes it
</span><span class="c1"></span>	<span class="c1">// on the swept set.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Some parts of the sweeper can sweep arbitrary spans, and hence
</span><span class="c1"></span>	<span class="c1">// can&#39;t remove them from the unswept set, but will add the span
</span><span class="c1"></span>	<span class="c1">// to the appropriate swept list. As a result, the parts of the
</span><span class="c1"></span>	<span class="c1">// sweeper and mcentral that do consume from the unswept list may
</span><span class="c1"></span>	<span class="c1">// encounter swept spans, and these should be ignored.
</span><span class="c1"></span>	<span class="c1">// 空闲的span列表
</span><span class="c1"></span>	<span class="nx">partial</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="nx">spanSet</span> <span class="c1">// list of spans with a free object
</span><span class="c1"></span>	<span class="c1">// 已经被使用的span列表
</span><span class="c1"></span>	<span class="nx">full</span>    <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="nx">spanSet</span> <span class="c1">// list of spans with no free objects
</span><span class="c1"></span>
	<span class="c1">// nmalloc is the cumulative count of objects allocated from
</span><span class="c1"></span>	<span class="c1">// this mcentral, assuming all spans in mcaches are
</span><span class="c1"></span>	<span class="c1">// fully-allocated. Written atomically, read under STW.
</span><span class="c1"></span>	<span class="c1">// nmalloc 字段也记录了该结构体中分配的对象个数
</span><span class="c1"></span>	<span class="nx">nmalloc</span> <span class="kt">uint64</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>每一个中心缓存都会管理某个跨度类的mspan，它会同时持有两个 runtime.mSpanList，分别存储包含空闲对象的列表和不包含空闲对象的链表：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123210846.png" alt=""></p>
<p>既然是没有空闲元素的empty列表，怎么还需要去遍历呢？这是由于有些span可能已经被垃圾回收器标记为空闲了，只是还没有来得及清理。这些Span在清扫后仍然是可以使用的，因此需要遍历。</p>
<p>当 mcentral 中 nonempty 列表中也没有可分配的 span 时，则会向 mheap 提出请求，从而获得 新的 span，并进而交给 mcache。</p>
<p>该结构体在初始化时，两个链表都不包含任何内存，程序运行时会扩容结构体持有的两个链表，nmalloc 字段也记录了该结构体中分配的对象个数。</p>
<p>runtime.mcentral的数据会由两个spanSet托管，partial负责空闲的列表，full负责已被使用的列表。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">headTailIndex</span> <span class="kt">uint64</span>
<span class="c1">// A spanSet is a set of *mspans.
</span><span class="c1">//
</span><span class="c1">// spanSet is safe for concurrent push and pop operations.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">spanSet</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// A spanSet is a two-level data structure consisting of a
</span><span class="c1"></span>	<span class="c1">// growable spine that points to fixed-sized blocks. The spine
</span><span class="c1"></span>	<span class="c1">// can be accessed without locks, but adding a block or
</span><span class="c1"></span>	<span class="c1">// growing it requires taking the spine lock.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Because each mspan covers at least 8K of heap and takes at
</span><span class="c1"></span>	<span class="c1">// most 8 bytes in the spanSet, the growth of the spine is
</span><span class="c1"></span>	<span class="c1">// quite limited.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The spine and all blocks are allocated off-heap, which
</span><span class="c1"></span>	<span class="c1">// allows this to be used in the memory manager and avoids the
</span><span class="c1"></span>	<span class="c1">// need for write barriers on all of these. spanSetBlocks are
</span><span class="c1"></span>	<span class="c1">// managed in a pool, though never freed back to the operating
</span><span class="c1"></span>	<span class="c1">// system. We never release spine memory because there could be
</span><span class="c1"></span>	<span class="c1">// concurrent lock-free access and we&#39;re likely to reuse it
</span><span class="c1"></span>	<span class="c1">// anyway. (In principle, we could do this during STW.)
</span><span class="c1"></span>
	<span class="nx">spineLock</span> <span class="nx">mutex</span>
	<span class="c1">// 数据块的指针
</span><span class="c1"></span>	<span class="nx">spine</span>     <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// *[N]*spanSetBlock, accessed atomically
</span><span class="c1"></span>	<span class="nx">spineLen</span>  <span class="kt">uintptr</span>        <span class="c1">// Spine array length, accessed atomically
</span><span class="c1"></span>	<span class="nx">spineCap</span>  <span class="kt">uintptr</span>        <span class="c1">// Spine array cap, accessed under lock
</span><span class="c1"></span>
	<span class="c1">// index is the head and tail of the spanSet in a single field.
</span><span class="c1"></span>	<span class="c1">// The head and the tail both represent an index into the logical
</span><span class="c1"></span>	<span class="c1">// concatenation of all blocks, with the head always behind or
</span><span class="c1"></span>	<span class="c1">// equal to the tail (indicating an empty set). This field is
</span><span class="c1"></span>	<span class="c1">// always accessed atomically.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The head and the tail are only 32 bits wide, which means we
</span><span class="c1"></span>	<span class="c1">// can only support up to 2^32 pushes before a reset. If every
</span><span class="c1"></span>	<span class="c1">// span in the heap were stored in this set, and each span were
</span><span class="c1"></span>	<span class="c1">// the minimum size (1 runtime page, 8 KiB), then roughly the
</span><span class="c1"></span>	<span class="c1">// smallest heap which would be unrepresentable is 32 TiB in size.
</span><span class="c1"></span>	<span class="c1">// 头尾的指针，前32位是头指针，后32位是尾指针
</span><span class="c1"></span>	<span class="nx">index</span> <span class="nx">headTailIndex</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>spanSet这个数据结构里面有一个由index组成的头尾指针，pop数据的时候会从头获取，push数据的时候从tail放入，spine相当于数据块的指针，通过head和tail的位置可以算出每个数据块的具体位置:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// partialUnswept returns the spanSet which holds partially-filled
</span><span class="c1">// unswept spans for this sweepgen.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nf">partialUnswept</span><span class="p">(</span><span class="nx">sweepgen</span> <span class="kt">uint32</span><span class="p">)</span> <span class="o">*</span><span class="nx">spanSet</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">partial</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="nx">sweepgen</span><span class="o">/</span><span class="mi">2</span><span class="o">%</span><span class="mi">2</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// partialSwept returns the spanSet which holds partially-filled
</span><span class="c1">// swept spans for this sweepgen.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nf">partialSwept</span><span class="p">(</span><span class="nx">sweepgen</span> <span class="kt">uint32</span><span class="p">)</span> <span class="o">*</span><span class="nx">spanSet</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">partial</span><span class="p">[</span><span class="nx">sweepgen</span><span class="o">/</span><span class="mi">2</span><span class="o">%</span><span class="mi">2</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// fullUnswept returns the spanSet which holds unswept spans without any
</span><span class="c1">// free slots for this sweepgen.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nf">fullUnswept</span><span class="p">(</span><span class="nx">sweepgen</span> <span class="kt">uint32</span><span class="p">)</span> <span class="o">*</span><span class="nx">spanSet</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">full</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="nx">sweepgen</span><span class="o">/</span><span class="mi">2</span><span class="o">%</span><span class="mi">2</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// fullSwept returns the spanSet which holds swept spans without any
</span><span class="c1">// free slots for this sweepgen.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nf">fullSwept</span><span class="p">(</span><span class="nx">sweepgen</span> <span class="kt">uint32</span><span class="p">)</span> <span class="o">*</span><span class="nx">spanSet</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">full</span><span class="p">[</span><span class="nx">sweepgen</span><span class="o">/</span><span class="mi">2</span><span class="o">%</span><span class="mi">2</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>数据块由spanSetBlock表示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">spanSetBlockEntries</span> <span class="p">=</span> <span class="mi">512</span>
<span class="kd">type</span> <span class="nx">spanSetBlock</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nx">spans</span> <span class="p">[</span><span class="nx">spanSetBlockEntries</span><span class="p">]</span><span class="o">*</span><span class="nx">mspan</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>spanSetBlock是一个存放mspan的数据块，里面会包含一个存放512个mspan的数据指针。所以mcentral的总体数据结构如下：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210817182910.png" alt=""></p>
<h3 id="cachespan">cacheSpan</h3>
<p>线程缓存会通过中心缓存的 runtime.mcentral.cacheSpan 方法获取新的mspan，该方法的实现比较复杂，我们可以将其分成以下几个部分：</p>
<ol>
<li>从有空闲对象的 runtime.mspan 链表中查找可以使用的mspan；</li>
<li>从没有空闲对象的 runtime.mspan 链表中查找可以使用的mspan；</li>
<li>调用 runtime.mcentral.grow 从堆中申请新的mspan；</li>
<li>更新mspan的 allocCache 等字段帮助快速分配内存；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Allocate a span to use in an mcache.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nf">cacheSpan</span><span class="p">()</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">go115NewMCentralImpl</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">oldCacheSpan</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="o">...</span><span class="p">.</span>
<span class="p">}</span>
<span class="c1">// Allocate a span to use in an mcache.
</span><span class="c1">//
</span><span class="c1">// For !go115NewMCentralImpl.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nf">oldCacheSpan</span><span class="p">()</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="c1">// Deduct credit for this span allocation and sweep if necessary.
</span><span class="c1"></span>	<span class="nx">spanBytes</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_allocnpages</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()])</span> <span class="o">*</span> <span class="nx">_PageSize</span>
	<span class="nf">deductSweepCredit</span><span class="p">(</span><span class="nx">spanBytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">traceDone</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCSweepStart</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span>
<span class="nx">retry</span><span class="p">:</span>
	<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
	<span class="c1">//首先我们会在中心缓存的非空链表中查找可用的 runtime.mspan，根据 sweepgen 字段分别进行不同的处理：
</span><span class="c1"></span>	<span class="c1">// 从nonempty链表查找空闲span
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">nonempty</span><span class="p">.</span><span class="nx">first</span><span class="p">;</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">{</span>
		<span class="c1">//1. 当内存单元等待回收时，将其插入 empty 链表、调用 runtime.mspan.sweep 清理该单元并返回；
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="c1">// 等待回收
</span><span class="c1"></span>			<span class="c1">// 在nonempty链表删除该span
</span><span class="c1"></span>			<span class="nx">c</span><span class="p">.</span><span class="nx">nonempty</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="c1">// 在empty链表增加该span
</span><span class="c1"></span>			<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">sweep</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
			<span class="k">goto</span> <span class="nx">havespan</span>
		<span class="c1">//2. 当内存单元正在被后台回收时，跳过该内存单元；
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span><span class="c1">// 正在回收
</span><span class="c1"></span>			<span class="c1">// the span is being swept by background sweeper, skip
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">//3. 当内存单元已经被回收时，将内存单元插入 empty 链表并返回；
</span><span class="c1"></span>		<span class="c1">// we have a nonempty span that does not require sweeping, allocate from it
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">nonempty</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="c1">// 已经回收
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="nx">havespan</span>
	<span class="p">}</span>
	<span class="c1">//如果中心缓存没有在 nonempty 中找到可用的mspan，就会继续遍历其持有的 empty 链表，我们在这里的处理与包含空闲对象的链表几乎完全相同。当找到需要回收的内存单元时，我们也会触发 runtime.mspan.sweep 进行清理，如果清理后的内存单元仍然不包含空闲对象，就会重新执行相应的代码：
</span><span class="c1"></span>	<span class="c1">// 在empty链表查找是否有可用的span,是因为某些span可能被垃圾回收标记为空闲但是还没清理
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nx">first</span><span class="p">;</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// we have an empty span that requires sweeping,
</span><span class="c1"></span>			<span class="c1">// sweep it and see if we can free some space in it
</span><span class="c1"></span>			<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="c1">// swept spans are at the end of the list
</span><span class="c1"></span>			<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">sweep</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
			<span class="nx">freeIndex</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">nextFreeIndex</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">freeIndex</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
				<span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="nx">freeIndex</span>
				<span class="k">goto</span> <span class="nx">havespan</span>
			<span class="p">}</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="c1">// the span is still empty after sweep
</span><span class="c1"></span>			<span class="c1">// it is already in the empty list, so just retry
</span><span class="c1"></span>			<span class="k">goto</span> <span class="nx">retry</span><span class="c1">// 不包含空闲对象
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
			<span class="c1">// the span is being swept by background sweeper, skip
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// already swept empty span,
</span><span class="c1"></span>		<span class="c1">// all subsequent ones must also be either swept or in process of sweeping
</span><span class="c1"></span>		<span class="k">break</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCSweepDone</span><span class="p">()</span>
		<span class="nx">traceDone</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">//如果 runtime.mcentral 在两个链表中都没有找到可用的内存单元，它会调用 runtime.mcentral.grow 触发扩容操作从堆中申请新的内存：
</span><span class="c1"></span>	<span class="c1">// Replenish central list if empty.
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">grow</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// At this point s is a non-empty span, queued at the end of the empty list,
</span><span class="c1"></span>	<span class="c1">// c is unlocked.
</span><span class="c1"></span><span class="nx">havespan</span><span class="p">:</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">traceDone</span> <span class="p">{</span>
		<span class="nf">traceGCSweepDone</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="o">||</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;span has no free objects&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// Assume all objects from this span will be allocated in the
</span><span class="c1"></span>	<span class="c1">// mcache. If it gets uncached, we&#39;ll adjust this.
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">nmalloc</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
	<span class="nx">usedBytes</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">*</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">spanBytes</span><span class="p">)</span><span class="o">-</span><span class="nb">int64</span><span class="p">(</span><span class="nx">usedBytes</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="c1">// heap_live changed.
</span><span class="c1"></span>		<span class="nf">traceHeapAlloc</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// heap_live changed.
</span><span class="c1"></span>		<span class="nx">gcController</span><span class="p">.</span><span class="nf">revise</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">freeByteBase</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">whichByte</span> <span class="o">:=</span> <span class="nx">freeByteBase</span> <span class="o">/</span> <span class="mi">8</span>
	<span class="c1">// Init alloc bits cache.
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nf">refillAllocCache</span><span class="p">(</span><span class="nx">whichByte</span><span class="p">)</span>

	<span class="c1">// Adjust the allocCache so that s.freeindex corresponds to the low bit in
</span><span class="c1"></span>	<span class="c1">// s.allocCache.
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">allocCache</span> <span class="o">&gt;&gt;=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">%</span> <span class="mi">64</span>

	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>无论通过哪种方法获取到了内存单元，该方法的最后都会对内存单元的 allocBits 和 allocCache 等字段进行更新，让运行时在分配内存时能够快速找到空闲的对象。</p>
<h3 id="grow">grow</h3>
<p>中心缓存的扩容方法 runtime.mcentral.grow 会根据预先计算的 class_to_allocnpages 和 class_to_size 获取待分配的页数以及跨度类并调用 runtime.mheap.alloc 获取新的 runtime.mspan 结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// grow allocates a new empty span from the heap and initializes it for c&#39;s size class.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nf">grow</span><span class="p">()</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="c1">//查表获取其需要多少页
</span><span class="c1"></span>	<span class="nx">npages</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_allocnpages</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()])</span>
	<span class="nx">size</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()])</span>

	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="c1">// Use division by multiplication and shifts to quickly compute:
</span><span class="c1"></span>	<span class="c1">// n := (npages &lt;&lt; _PageShift) / size
</span><span class="c1"></span>	<span class="c1">// 计算object数量
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">npages</span> <span class="o">&lt;&lt;</span> <span class="nx">_PageShift</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">divShift</span> <span class="o">*</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">divMul</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">divShift2</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">limit</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">size</span><span class="o">*</span><span class="nx">n</span>
	<span class="nf">heapBitsForAddr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()).</span><span class="nf">initSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>获取了 runtime.mspan 之后，我们会在上述方法中初始化 limit 字段并清除该结构在堆上对应的位图。</p>
<h2 id="页堆mheap">页堆:mheap</h2>
<p>运行时对于大于 32KB 的大对象会单独处理，我们不会从线程缓存或者中心缓存中获取mspan，而是直接在系统的栈中调用 runtime.largeAlloc 函数分配大片的内存：</p>
<p>runtime.mheap 是内存分配的核心结构体，Go 语言程序只会存在一个全局的结构，而堆上初始化的所有对象都由该结构体统一管理，该结构体中包含两组非常重要的字段，其中一个是全局的中心缓存列表 central，另一个是管理堆区内存区域的 arenas 以及相关字段。</p>
<p>页堆中包含一个长度为 134 的 runtime.mcentral 数组，其中 67 个为跨度类需要 scan 的中心缓存，另外的 67 个是 noscan 的中心缓存：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123220227.png" alt=""></p>
<p>Go 语言所有的内存空间都由如下所示的二维矩阵 runtime.heapArena 管理的，这个二维矩阵管理的内存可以是不连续的：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123220444.png" alt=""></p>
<p>在除了 Windows 以外的 64 位操作系统中，每一个 runtime.heapArena 都会管理 64MB 的内存空间，如下所示的表格展示了不同平台上 Go 语言程序管理的堆区大小以及 runtime.heapArena 占用的内存空间：</p>
<table>
<thead>
<tr>
<th>平台</th>
<th>地址位数</th>
<th>Arena 大小</th>
<th>一维大小</th>
<th>二维大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>*/64-bit</td>
<td>48</td>
<td>64MB</td>
<td>1</td>
<td>4M (32MB)</td>
</tr>
<tr>
<td>windows/64-bit</td>
<td>48</td>
<td>4MB</td>
<td>64</td>
<td>1M (8MB)</td>
</tr>
<tr>
<td>*/32-bit</td>
<td>32</td>
<td>4MB</td>
<td>1</td>
<td>1024 (4KB)</td>
</tr>
<tr>
<td>*/mips(le)</td>
<td>31</td>
<td>4MB</td>
<td>1</td>
<td>512 (2KB)</td>
</tr>
</tbody>
</table>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210817183844.png" alt=""></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Main malloc heap.
</span><span class="c1">// The heap itself is the &#34;free&#34; and &#34;scav&#34; treaps,
</span><span class="c1">// but all the other global data is here too.
</span><span class="c1">//
</span><span class="c1">// mheap must not be heap-allocated because it contains mSpanLists,
</span><span class="c1">// which must not be heap-allocated.
</span><span class="c1">//
</span><span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">mheap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// lock must only be acquired on the system stack, otherwise a g
</span><span class="c1"></span>	<span class="c1">// could self-deadlock if its stack grows with the lock held.
</span><span class="c1"></span>	<span class="c1">// 互斥锁
</span><span class="c1"></span>	<span class="nx">lock</span>      <span class="nx">mutex</span>
	<span class="nx">pages</span>     <span class="nx">pageAlloc</span> <span class="c1">// page allocation data structure
</span><span class="c1"></span>	<span class="c1">// GC相关
</span><span class="c1"></span>	<span class="nx">sweepgen</span>  <span class="kt">uint32</span>    <span class="c1">// sweep generation, see comment in mspan; written during STW
</span><span class="c1"></span>	<span class="c1">// GC相关
</span><span class="c1"></span>	<span class="nx">sweepdone</span> <span class="kt">uint32</span>    <span class="c1">// all spans are swept
</span><span class="c1"></span>	<span class="c1">// GC相关
</span><span class="c1"></span>	<span class="nx">sweepers</span>  <span class="kt">uint32</span>    <span class="c1">// number of active sweepone calls
</span><span class="c1"></span>
	<span class="c1">// allspans is a slice of all mspans ever created. Each mspan
</span><span class="c1"></span>	<span class="c1">// appears exactly once.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The memory for allspans is manually managed and can be
</span><span class="c1"></span>	<span class="c1">// reallocated and move as the heap grows.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// In general, allspans is protected by mheap_.lock, which
</span><span class="c1"></span>	<span class="c1">// prevents concurrent access as well as freeing the backing
</span><span class="c1"></span>	<span class="c1">// store. Accesses during STW might not hold the lock, but
</span><span class="c1"></span>	<span class="c1">// must ensure that allocation cannot happen around the
</span><span class="c1"></span>	<span class="c1">// access (since that may free the backing store).
</span><span class="c1"></span>	<span class="c1">// 所有 spans 从这里分配出去
</span><span class="c1"></span>	<span class="nx">allspans</span> <span class="p">[]</span><span class="o">*</span><span class="nx">mspan</span> <span class="c1">// all spans out there
</span><span class="c1"></span>
	<span class="c1">// sweepSpans contains two mspan stacks: one of swept in-use
</span><span class="c1"></span>	<span class="c1">// spans, and one of unswept in-use spans. These two trade
</span><span class="c1"></span>	<span class="c1">// roles on each GC cycle. Since the sweepgen increases by 2
</span><span class="c1"></span>	<span class="c1">// on each cycle, this means the swept spans are in
</span><span class="c1"></span>	<span class="c1">// sweepSpans[sweepgen/2%2] and the unswept spans are in
</span><span class="c1"></span>	<span class="c1">// sweepSpans[1-sweepgen/2%2]. Sweeping pops spans from the
</span><span class="c1"></span>	<span class="c1">// unswept stack and pushes spans that are still in-use on the
</span><span class="c1"></span>	<span class="c1">// swept stack. Likewise, allocating an in-use span pushes it
</span><span class="c1"></span>	<span class="c1">// on the swept stack.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For !go115NewMCentralImpl.
</span><span class="c1"></span>	<span class="nx">sweepSpans</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="nx">gcSweepBuf</span>

	<span class="nx">_</span> <span class="kt">uint32</span> <span class="c1">// align uint64 fields on 32-bit for atomics
</span><span class="c1"></span>
	<span class="c1">// Proportional sweep
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// These parameters represent a linear function from heap_live
</span><span class="c1"></span>	<span class="c1">// to page sweep count. The proportional sweep system works to
</span><span class="c1"></span>	<span class="c1">// stay in the black by keeping the current page sweep count
</span><span class="c1"></span>	<span class="c1">// above this line at the current heap_live.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The line has slope sweepPagesPerByte and passes through a
</span><span class="c1"></span>	<span class="c1">// basis point at (sweepHeapLiveBasis, pagesSweptBasis). At
</span><span class="c1"></span>	<span class="c1">// any given time, the system is at (memstats.heap_live,
</span><span class="c1"></span>	<span class="c1">// pagesSwept) in this space.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// It&#39;s important that the line pass through a point we
</span><span class="c1"></span>	<span class="c1">// control rather than simply starting at a (0,0) origin
</span><span class="c1"></span>	<span class="c1">// because that lets us adjust sweep pacing at any time while
</span><span class="c1"></span>	<span class="c1">// accounting for current progress. If we could only adjust
</span><span class="c1"></span>	<span class="c1">// the slope, it would create a discontinuity in debt if any
</span><span class="c1"></span>	<span class="c1">// progress has already been made.
</span><span class="c1"></span>	<span class="nx">pagesInUse</span>         <span class="kt">uint64</span>  <span class="c1">// pages of spans in stats mSpanInUse; updated atomically
</span><span class="c1"></span>	<span class="nx">pagesSwept</span>         <span class="kt">uint64</span>  <span class="c1">// pages swept this cycle; updated atomically
</span><span class="c1"></span>	<span class="nx">pagesSweptBasis</span>    <span class="kt">uint64</span>  <span class="c1">// pagesSwept to use as the origin of the sweep ratio; updated atomically
</span><span class="c1"></span>	<span class="nx">sweepHeapLiveBasis</span> <span class="kt">uint64</span>  <span class="c1">// value of heap_live to use as the origin of sweep ratio; written with lock, read without
</span><span class="c1"></span>	<span class="nx">sweepPagesPerByte</span>  <span class="kt">float64</span> <span class="c1">// proportional sweep ratio; written with lock, read without
</span><span class="c1"></span>	<span class="c1">// TODO(austin): pagesInUse should be a uintptr, but the 386
</span><span class="c1"></span>	<span class="c1">// compiler can&#39;t 8-byte align fields.
</span><span class="c1"></span>
	<span class="c1">// scavengeGoal is the amount of total retained heap memory (measured by
</span><span class="c1"></span>	<span class="c1">// heapRetained) that the runtime will try to maintain by returning memory
</span><span class="c1"></span>	<span class="c1">// to the OS.
</span><span class="c1"></span>	<span class="nx">scavengeGoal</span> <span class="kt">uint64</span>

	<span class="c1">// Page reclaimer state
</span><span class="c1"></span>
	<span class="c1">// reclaimIndex is the page index in allArenas of next page to
</span><span class="c1"></span>	<span class="c1">// reclaim. Specifically, it refers to page (i %
</span><span class="c1"></span>	<span class="c1">// pagesPerArena) of arena allArenas[i / pagesPerArena].
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If this is &gt;= 1&lt;&lt;63, the page reclaimer is done scanning
</span><span class="c1"></span>	<span class="c1">// the page marks.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This is accessed atomically.
</span><span class="c1"></span>	<span class="nx">reclaimIndex</span> <span class="kt">uint64</span>
	<span class="c1">// reclaimCredit is spare credit for extra pages swept. Since
</span><span class="c1"></span>	<span class="c1">// the page reclaimer works in large chunks, it may reclaim
</span><span class="c1"></span>	<span class="c1">// more than requested. Any spare pages released go to this
</span><span class="c1"></span>	<span class="c1">// credit pool.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This is accessed atomically.
</span><span class="c1"></span>	<span class="nx">reclaimCredit</span> <span class="kt">uintptr</span>

	<span class="c1">// Malloc stats.
</span><span class="c1"></span>	<span class="nx">largealloc</span>  <span class="kt">uint64</span>                  <span class="c1">// bytes allocated for large objects
</span><span class="c1"></span>	<span class="nx">nlargealloc</span> <span class="kt">uint64</span>                  <span class="c1">// number of large object allocations
</span><span class="c1"></span>	<span class="nx">largefree</span>   <span class="kt">uint64</span>                  <span class="c1">// bytes freed for large objects (&gt;maxsmallsize)
</span><span class="c1"></span>	<span class="nx">nlargefree</span>  <span class="kt">uint64</span>                  <span class="c1">// number of frees for large objects (&gt;maxsmallsize)
</span><span class="c1"></span>	<span class="nx">nsmallfree</span>  <span class="p">[</span><span class="nx">_NumSizeClasses</span><span class="p">]</span><span class="kt">uint64</span> <span class="c1">// number of frees for small objects (&lt;=maxsmallsize)
</span><span class="c1"></span>
	<span class="c1">// arenas is the heap arena map. It points to the metadata for
</span><span class="c1"></span>	<span class="c1">// the heap for every arena frame of the entire usable virtual
</span><span class="c1"></span>	<span class="c1">// address space.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Use arenaIndex to compute indexes into this array.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For regions of the address space that are not backed by the
</span><span class="c1"></span>	<span class="c1">// Go heap, the arena map contains nil.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Modifications are protected by mheap_.lock. Reads can be
</span><span class="c1"></span>	<span class="c1">// performed without locking; however, a given entry can
</span><span class="c1"></span>	<span class="c1">// transition from nil to non-nil at any time when the lock
</span><span class="c1"></span>	<span class="c1">// isn&#39;t held. (Entries never transitions back to nil.)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// In general, this is a two-level mapping consisting of an L1
</span><span class="c1"></span>	<span class="c1">// map and possibly many L2 maps. This saves space when there
</span><span class="c1"></span>	<span class="c1">// are a huge number of arena frames. However, on many
</span><span class="c1"></span>	<span class="c1">// platforms (even 64-bit), arenaL1Bits is 0, making this
</span><span class="c1"></span>	<span class="c1">// effectively a single-level map. In this case, arenas[0]
</span><span class="c1"></span>	<span class="c1">// will never be nil.
</span><span class="c1"></span>	<span class="c1">// arenas数组集合,一个二维数组
</span><span class="c1"></span>	<span class="nx">arenas</span> <span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">arenaL1Bits</span><span class="p">]</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">arenaL2Bits</span><span class="p">]</span><span class="o">*</span><span class="nx">heapArena</span>

	<span class="c1">// heapArenaAlloc is pre-reserved space for allocating heapArena
</span><span class="c1"></span>	<span class="c1">// objects. This is only used on 32-bit, where we pre-reserve
</span><span class="c1"></span>	<span class="c1">// this space to avoid interleaving it with the heap itself.
</span><span class="c1"></span>	<span class="nx">heapArenaAlloc</span> <span class="nx">linearAlloc</span>

	<span class="c1">// arenaHints is a list of addresses at which to attempt to
</span><span class="c1"></span>	<span class="c1">// add more heap arenas. This is initially populated with a
</span><span class="c1"></span>	<span class="c1">// set of general hint addresses, and grown with the bounds of
</span><span class="c1"></span>	<span class="c1">// actual heap arena ranges.
</span><span class="c1"></span>	<span class="nx">arenaHints</span> <span class="o">*</span><span class="nx">arenaHint</span>

	<span class="c1">// arena is a pre-reserved space for allocating heap arenas
</span><span class="c1"></span>	<span class="c1">// (the actual arenas). This is only used on 32-bit.
</span><span class="c1"></span>	<span class="nx">arena</span> <span class="nx">linearAlloc</span>

	<span class="c1">// allArenas is the arenaIndex of every mapped arena. This can
</span><span class="c1"></span>	<span class="c1">// be used to iterate through the address space.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Access is protected by mheap_.lock. However, since this is
</span><span class="c1"></span>	<span class="c1">// append-only and old backing arrays are never freed, it is
</span><span class="c1"></span>	<span class="c1">// safe to acquire mheap_.lock, copy the slice header, and
</span><span class="c1"></span>	<span class="c1">// then release mheap_.lock.
</span><span class="c1"></span>	<span class="nx">allArenas</span> <span class="p">[]</span><span class="nx">arenaIdx</span>

	<span class="c1">// sweepArenas is a snapshot of allArenas taken at the
</span><span class="c1"></span>	<span class="c1">// beginning of the sweep cycle. This can be read safely by
</span><span class="c1"></span>	<span class="c1">// simply blocking GC (by disabling preemption).
</span><span class="c1"></span>	<span class="nx">sweepArenas</span> <span class="p">[]</span><span class="nx">arenaIdx</span>

	<span class="c1">// markArenas is a snapshot of allArenas taken at the beginning
</span><span class="c1"></span>	<span class="c1">// of the mark cycle. Because allArenas is append-only, neither
</span><span class="c1"></span>	<span class="c1">// this slice nor its contents will change during the mark, so
</span><span class="c1"></span>	<span class="c1">// it can be read safely.
</span><span class="c1"></span>	<span class="nx">markArenas</span> <span class="p">[]</span><span class="nx">arenaIdx</span>

	<span class="c1">// curArena is the arena that the heap is currently growing
</span><span class="c1"></span>	<span class="c1">// into. This should always be physPageSize-aligned.
</span><span class="c1"></span>	<span class="nx">curArena</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">base</span><span class="p">,</span> <span class="nx">end</span> <span class="kt">uintptr</span>
	<span class="p">}</span>

	<span class="c1">// _ uint32 // ensure 64-bit alignment of central
</span><span class="c1"></span>
	<span class="c1">// central free lists for small size classes.
</span><span class="c1"></span>	<span class="c1">// the padding makes sure that the mcentrals are
</span><span class="c1"></span>	<span class="c1">// spaced CacheLinePadSize bytes apart, so that each mcentral.lock
</span><span class="c1"></span>	<span class="c1">// gets its own cache line.
</span><span class="c1"></span>	<span class="c1">// central is indexed by spanClass.
</span><span class="c1"></span>	<span class="c1">// mcentral 内存分配中心，mcache没有足够的内存分配的时候，会从mcentral分配
</span><span class="c1"></span>    	<span class="c1">// mcentral 是mheap在管理
</span><span class="c1"></span>	<span class="nx">central</span> <span class="p">[</span><span class="nx">numSpanClasses</span><span class="p">]</span><span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">mcentral</span> <span class="nx">mcentral</span>
		<span class="nx">pad</span>      <span class="p">[</span><span class="nx">cpu</span><span class="p">.</span><span class="nx">CacheLinePadSize</span> <span class="o">-</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">mcentral</span><span class="p">{})</span><span class="o">%</span><span class="nx">cpu</span><span class="p">.</span><span class="nx">CacheLinePadSize</span><span class="p">]</span><span class="kt">byte</span>
	<span class="p">}</span>
	<span class="c1">// span* 分配器
</span><span class="c1"></span>	<span class="nx">spanalloc</span>             <span class="nx">fixalloc</span> <span class="c1">// allocator for span*
</span><span class="c1"></span>	<span class="c1">// mcache* 分配器
</span><span class="c1"></span>	<span class="nx">cachealloc</span>            <span class="nx">fixalloc</span> <span class="c1">// allocator for mcache*
</span><span class="c1"></span>	<span class="c1">// specialfinalizer* 分配器
</span><span class="c1"></span>	<span class="nx">specialfinalizeralloc</span> <span class="nx">fixalloc</span> <span class="c1">// allocator for specialfinalizer*
</span><span class="c1"></span>	<span class="c1">// specialprofile* 分配器
</span><span class="c1"></span>	<span class="nx">specialprofilealloc</span>   <span class="nx">fixalloc</span> <span class="c1">// allocator for specialprofile*
</span><span class="c1"></span>	<span class="c1">// 特殊记录分配器的锁
</span><span class="c1"></span>	<span class="nx">speciallock</span>           <span class="nx">mutex</span>    <span class="c1">// lock for special record allocators.
</span><span class="c1"></span>	<span class="c1">// arenaHints 分配器
</span><span class="c1"></span>	<span class="nx">arenaHintAlloc</span>        <span class="nx">fixalloc</span> <span class="c1">// allocator for arenaHints
</span><span class="c1"></span>
	<span class="nx">unused</span> <span class="o">*</span><span class="nx">specialfinalizer</span> <span class="c1">// never set, just here to force the specialfinalizer type into DWARF
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="init">init</h3>
<p>堆区的初始化会使用 runtime.mheap.init 方法，我们能看到该方法初始化了非常多的结构体和字段，不过其中初始化的两类变量比较重要：</p>
<ol>
<li>spanalloc、cachealloc 以及 arenaHintAlloc 等 runtime.fixalloc 类型的空闲链表分配器；</li>
<li>central 切片中 runtime.mcentral 类型的中心缓存；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Initialize the heap.
</span><span class="c1">// 堆初始化
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 初始化堆中各个组件的分配器
</span><span class="c1"></span>	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankMheap</span><span class="p">)</span>
	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">spineLock</span><span class="p">,</span> <span class="nx">lockRankSpine</span><span class="p">)</span>
	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">spineLock</span><span class="p">,</span> <span class="nx">lockRankSpine</span><span class="p">)</span>
	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">speciallock</span><span class="p">,</span> <span class="nx">lockRankMheapSpecial</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">.</span><span class="nx">spanalloc</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">mspan</span><span class="p">{}),</span> <span class="nx">recordspan</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">mspan_sys</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">cachealloc</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">mcache</span><span class="p">{}),</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">mcache_sys</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">specialfinalizeralloc</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">specialfinalizer</span><span class="p">{}),</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">other_sys</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">specialprofilealloc</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">specialprofile</span><span class="p">{}),</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">other_sys</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">arenaHintAlloc</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">arenaHint</span><span class="p">{}),</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">other_sys</span><span class="p">)</span>

	<span class="c1">// Don&#39;t zero mspan allocations. Background sweeping can
</span><span class="c1"></span>	<span class="c1">// inspect a span concurrently with allocating it, so it&#39;s
</span><span class="c1"></span>	<span class="c1">// important that the span&#39;s sweepgen survive across freeing
</span><span class="c1"></span>	<span class="c1">// and re-allocating a span to prevent background sweeping
</span><span class="c1"></span>	<span class="c1">// from improperly cas&#39;ing it from 0.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This is safe because mspan contains no heap pointers.
</span><span class="c1"></span>	<span class="c1">// 不对 mspan 的分配清零，后台扫描可以通过分配它来并发的检查一个 span
</span><span class="c1"></span>	<span class="c1">// 因此 span 的 sweepgen 在释放和重新分配时候能存活，从而可以防止后台扫描
</span><span class="c1"></span>	<span class="c1">// 不正确的将其从 0 进行 CAS。
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 因为 mspan 不包含堆指针，因此它是安全的
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">spanalloc</span><span class="p">.</span><span class="nx">zero</span> <span class="p">=</span> <span class="kc">false</span>

	<span class="c1">// h-&gt;mapcache needs no init
</span><span class="c1"></span>	<span class="c1">// h-&gt;mapcache 不需要初始化
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">h</span><span class="p">.</span><span class="nx">central</span> <span class="p">{</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nf">spanClass</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="nx">h</span><span class="p">.</span><span class="nx">pages</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_sys</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>堆中初始化的多个空闲链表分配器与我们在设计原理一节中提到的分配器没有太多区别，当我们调用 runtime.fixalloc.init 初始化分配器时，需要传入待初始化的结构体大小等信息，这会帮助分配器分割待分配的内存，该分配器提供了以下两个用于分配和释放内存的方法：</p>
<ul>
<li>runtime.fixalloc.alloc — 获取下一个空闲的内存空间；</li>
<li>runtime.fixalloc.free — 释放指针指向的内存空间；</li>
</ul>
<p>除了这些空闲链表分配器之外，我们还会在该方法中初始化所有的中心缓存，这些中心缓存会维护全局的mspan，各个线程会通过中心缓存获取新的内存单元。</p>
<h3 id="fixalloc">fixalloc</h3>
<p>fixalloc 是一个基于自由列表的固定大小的分配器。其核心原理是将若干未分配的内存块连接起来， 将未分配的区域的第一个字为指向下一个未分配区域的指针使用。</p>
<p>Go 的主分配堆中 malloc（span、cache、treap、finalizer、profile、arena hint 等） 均 围绕它为实体进行固定分配和回收。</p>
<p>fixalloc 作为抽象，非常简洁，只包含三个基本操作：初始化、分配、回收</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// fixalloc 是一个简单的固定大小对象的自由表内存分配器。
</span><span class="c1">// Malloc 使用围绕 sysAlloc 的 fixalloc 来管理其 MCache 和 MSpan 对象。
</span><span class="c1">//
</span><span class="c1">// fixalloc.alloc 返回的内存默认为零，但调用者可以通过将 zero 标志设置为 false
</span><span class="c1">// 来自行负责将分配归零。如果这部分内存永远不包含堆指针，则这样的操作是安全的。
</span><span class="c1">//
</span><span class="c1">// 调用方负责锁定 fixalloc 调用。调用方可以在对象中保持状态，
</span><span class="c1">// 但当释放和重新分配时第一个字会被破坏。
</span><span class="c1">//
</span><span class="c1">// 考虑使 fixalloc 的类型变为 go:notinheap.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">fixalloc</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">size</span>   <span class="kt">uintptr</span>
	<span class="nx">first</span>  <span class="kd">func</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span> <span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="c1">// 首次调用时返回 p
</span><span class="c1"></span>	<span class="nx">arg</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="nx">list</span>   <span class="o">*</span><span class="nx">mlink</span>
	<span class="nx">chunk</span>  <span class="kt">uintptr</span> <span class="c1">// 使用 uintptr 而非 unsafe.Pointer 来避免 write barrier
</span><span class="c1"></span>	<span class="nx">nchunk</span> <span class="kt">uint32</span>
	<span class="nx">inuse</span>  <span class="kt">uintptr</span> <span class="c1">// 正在使用的字节
</span><span class="c1"></span>	<span class="nx">stat</span>   <span class="o">*</span><span class="kt">uint64</span>
	<span class="nx">zero</span>   <span class="kt">bool</span> <span class="c1">// 归零的分配
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="初始化-1">初始化</h4>
<p>Go 语言对于零值有自己的规定，自然也就体现在内存分配器上。而 fixalloc 作为内存分配器内部组件的来源于 操作系统的内存，自然需要自行初始化，因此，fixalloc 的初始化也就不可避免的需要将自身的各个字段归零：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 初始化 f 来分配给定大小的对象。
</span><span class="c1">// 使用分配器来按 chunk 获取
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">fixalloc</span><span class="p">)</span> <span class="nf">init</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">first</span> <span class="kd">func</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span> <span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">),</span> <span class="nx">arg</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">stat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">size</span> <span class="p">=</span> <span class="nx">size</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">first</span> <span class="p">=</span> <span class="nx">first</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">arg</span> <span class="p">=</span> <span class="nx">arg</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">list</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">chunk</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">nchunk</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">inuse</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">stat</span> <span class="p">=</span> <span class="nx">stat</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">zero</span> <span class="p">=</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="分配">分配</h4>
<p>fixalloc 基于自由表策略进行实现，分为两种情况：</p>
<ol>
<li>存在被释放、可复用的内存</li>
<li>不存在可复用的内存</li>
</ol>
<p>对于第一种情况，也就是在运行时内存被释放，但这部分内存并不会被立即回收给操作系统， 我们直接从自由表中获得即可，但需要注意按需将这部分内存进行清零操作。</p>
<p>对于第二种情况，我们直接向操作系统申请固定大小的内存，然后扣除分配的大小即可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> 	<span class="nx">_FixAllocChunk</span> <span class="p">=</span> <span class="mi">16</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span>               <span class="c1">// FixAlloc 一个 Chunk 的大小
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">fixalloc</span><span class="p">)</span> <span class="nf">alloc</span><span class="p">()</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="c1">// fixalloc 的个字段必须先被 init
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">f</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: use of FixAlloc_Alloc before FixAlloc_Init\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: internal error&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 如果 f.list 不是 nil, 则说明还存在已经释放、可复用的内存，直接将其分配
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">f</span><span class="p">.</span><span class="nx">list</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 取出 f.list
</span><span class="c1"></span>		<span class="nx">v</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">list</span><span class="p">)</span>
		<span class="c1">// 并将其指向下一段区域
</span><span class="c1"></span>		<span class="nx">f</span><span class="p">.</span><span class="nx">list</span> <span class="p">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nx">next</span>
		<span class="c1">// 增加使用的(分配)大小
</span><span class="c1"></span>		<span class="nx">f</span><span class="p">.</span><span class="nx">inuse</span> <span class="o">+=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">size</span>
		<span class="c1">// 如果需要对内存清零，则对取出的内存执行初始化
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">f</span><span class="p">.</span><span class="nx">zero</span> <span class="p">{</span>
			<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">f</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 返回分配的内存
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">v</span>
	<span class="p">}</span>

	<span class="c1">// f.list 中没有可复用的内存
</span><span class="c1"></span>
	<span class="c1">// 如果此时 nchunk 不足以分配一个 size
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">nchunk</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">f</span><span class="p">.</span><span class="nx">size</span> <span class="p">{</span>
		<span class="c1">// 则向操作系统申请内存，大小为 16 &lt;&lt; 10 pow(2,14)
</span><span class="c1"></span>		<span class="nx">f</span><span class="p">.</span><span class="nx">chunk</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">persistentalloc</span><span class="p">(</span><span class="nx">_FixAllocChunk</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">f</span><span class="p">.</span><span class="nx">stat</span><span class="p">))</span>
		<span class="nx">f</span><span class="p">.</span><span class="nx">nchunk</span> <span class="p">=</span> <span class="nx">_FixAllocChunk</span>
	<span class="p">}</span>

	<span class="c1">// 指向申请好的内存
</span><span class="c1"></span>	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">chunk</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">f</span><span class="p">.</span><span class="nx">first</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// first 只有在 fixalloc 作为 spanalloc 时候，才会被设置为 recordspan
</span><span class="c1"></span>		<span class="nx">f</span><span class="p">.</span><span class="nf">first</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">arg</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> <span class="c1">// 用于为 heap.allspans 添加新的 span
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="c1">// 扣除并保留 size 大小的空间
</span><span class="c1"></span>	<span class="nx">f</span><span class="p">.</span><span class="nx">chunk</span> <span class="p">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">chunk</span> <span class="o">+</span> <span class="nx">f</span><span class="p">.</span><span class="nx">size</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">nchunk</span> <span class="o">-=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">inuse</span> <span class="o">+=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">size</span> <span class="c1">// 记录已经使用的大小
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">v</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="回收">回收</h4>
<p>回收就更加简单了，直接将回收的地址指针放回到自由表中即可：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">fixalloc</span><span class="p">)</span> <span class="nf">free</span><span class="p">(</span><span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 减少使用的字节数
</span><span class="c1"></span>	<span class="nx">f</span><span class="p">.</span><span class="nx">inuse</span> <span class="o">-=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">size</span>
	<span class="c1">// 将要释放的内存地址作为 mlink 指针插入到 f.list 内，完成回收
</span><span class="c1"></span>	<span class="nx">v</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">mlink</span><span class="p">)(</span><span class="nx">p</span><span class="p">)</span>
	<span class="nx">v</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">list</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">list</span> <span class="p">=</span> <span class="nx">v</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="alloc">alloc</h3>
<p>runtime.mheap 是内存分配器中的核心组件，运行时会通过它的 runtime.mheap.alloc 方法在系统栈中获取新的 runtime.mspan：</p>
<p>在分配内存的时候是按页来进行分配的，每个页的大小是_PageSize（8K），然后需要根据传入的size来判断需要分多少页，最后调用alloc从堆上分配。</p>
<p>这个方法需要指明要分配的页数、span 的大小等级、是否为大对象、是否清零：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// alloc allocates a new span of npage pages from the GC&#39;d heap.
</span><span class="c1">//
</span><span class="c1">// spanclass indicates the span&#39;s size class and scannability.
</span><span class="c1">//
</span><span class="c1">// If needzero is true, the memory for the returned span will be zeroed.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">spanclass</span> <span class="nx">spanClass</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="c1">// Don&#39;t do any operations that lock the heap on the G stack.
</span><span class="c1"></span>	<span class="c1">// It might trigger stack growth, and the stack growth code needs
</span><span class="c1"></span>	<span class="c1">// to be able to allocate heap.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// To prevent excessive heap growth, before allocating n pages
</span><span class="c1"></span>		<span class="c1">// we need to sweep and reclaim at least n pages.
</span><span class="c1"></span>		<span class="c1">//为了阻止内存的大量占用和堆的增长，我们在分配对应页数的内存前需要先调用 runtime.mheap.reclaim 方法回收一部分内存
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">sweepdone</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nf">reclaim</span><span class="p">(</span><span class="nx">npages</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">//接下来我们将通过 runtime.mheap.allocSpan 分配新的mspan，
</span><span class="c1"></span>		<span class="nx">s</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">allocSpan</span><span class="p">(</span><span class="nx">npages</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">spanclass</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_inuse</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 需要清零时，对分配的 span 进行清零
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">needzero</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()),</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="o">&lt;&lt;</span><span class="nx">_PageShift</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 标记已经清零
</span><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h4 id="allocspan">allocSpan</h4>
<p>我们会将mheap.allocSpan的执行过程拆分成两个部分：</p>
<ol>
<li>从堆上分配新的内存页和mspan runtime.mspan；</li>
<li>初始化mspan并将其加入 runtime.mheap 持有内存单元列表；</li>
</ol>
<p>allocSpan方法会通过处理器的页缓存 runtime.pageCache 或者全局的页分配器 runtime.pageAlloc 两种途径从堆中申请内存：</p>
<ol>
<li>如果申请的内存比较小，获取申请内存的处理器并尝试调用 runtime.pageCache.alloc 获取内存区域的基地址和大小；</li>
<li>如果申请的内存比较大或者线程的页缓存中内存不足，会通过 runtime.pageAlloc.alloc 在页堆上申请内存；</li>
<li>如果发现页堆上的内存不足，会尝试通过 runtime.mheap.grow 进行扩容并重新调用 runtime.pageAlloc.alloc 申请内存；
<ol>
<li>如果申请到内存，意味着扩容成功；</li>
<li>如果没有申请到内存，意味着扩容失败，宿主机可能不存在空闲内存，运行时会直接中止当前程序；</li>
</ol>
</li>
</ol>
<p>无论通过哪种方式获得内存页，我们都会在该函数中分配新的 runtime.mspan 结构体；该方法的剩余部分会通过页数、内存空间以及跨度类等参数初始化它的多个字段：</p>
<p>在allocSpan中，我们通过调用 runtime.mspan.init 方法以及设置参数初始化刚刚分配的 runtime.mspan 结构并通过 runtime.mheaps.setSpans 方法建立页堆与内存单元的联系。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// allocSpan allocates an mspan which owns npages worth of memory.
</span><span class="c1">//
</span><span class="c1">// If manual == false, allocSpan allocates a heap span of class spanclass
</span><span class="c1">// and updates heap accounting. If manual == true, allocSpan allocates a
</span><span class="c1">// manually-managed span (spanclass is ignored), and the caller is
</span><span class="c1">// responsible for any accounting related to its use of the span. Either
</span><span class="c1">// way, allocSpan will atomically add the bytes in the newly allocated
</span><span class="c1">// span to *sysStat.
</span><span class="c1">//
</span><span class="c1">// The returned span is fully initialized.
</span><span class="c1">//
</span><span class="c1">// h must not be locked.
</span><span class="c1">//
</span><span class="c1">// allocSpan must be called on the system stack both because it acquires
</span><span class="c1">// the heap lock and because it must block GC transitions.
</span><span class="c1">//
</span><span class="c1">//go:systemstack
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">allocSpan</span><span class="p">(</span><span class="nx">npages</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">manual</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">spanclass</span> <span class="nx">spanClass</span><span class="p">,</span> <span class="nx">sysStat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Function-global state.
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>	<span class="c1">// 获取当前协程
</span><span class="c1"></span>	<span class="nx">base</span><span class="p">,</span> <span class="nx">scav</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>	<span class="c1">// 基址，回收地址(bit位)
</span><span class="c1"></span>
	<span class="c1">// If the allocation is small enough, try the page cache!
</span><span class="c1"></span>	<span class="c1">// 当申请页数小于 8*64/4=128时从P的pageCache申请
</span><span class="c1"></span>    	<span class="c1">// 注意pageCache是连续的
</span><span class="c1"></span>	<span class="nx">pp</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="c1">// 申请的内存比较小,尝试从pcache申请内存
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">pp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">npages</span> <span class="p">&lt;</span> <span class="nx">pageCachePages</span><span class="o">/</span><span class="mi">4</span> <span class="p">{</span>
		<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">pcache</span>
		<span class="c1">// p对应的pageCache为空，则申请cache内存
</span><span class="c1"></span>		<span class="c1">// If the cache is empty, refill it.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="c1">// 填充本地的pageCache
</span><span class="c1"></span>			<span class="o">*</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">pages</span><span class="p">.</span><span class="nf">allocToCache</span><span class="p">()</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// Try to allocate from the cache.
</span><span class="c1"></span>		<span class="c1">// 1、先从p的页缓存获取内存区域的基地址和大小
</span><span class="c1"></span>		<span class="nx">base</span><span class="p">,</span> <span class="nx">scav</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span><span class="p">)</span>
		<span class="c1">// 申请成功
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">base</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// 对应span
</span><span class="c1"></span>			<span class="nx">s</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">tryAllocMSpan</span><span class="p">()</span>

			<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">gcBlackenEnabled</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">manual</span> <span class="o">||</span> <span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">HaveSpan</span>
			<span class="p">}</span>
			<span class="c1">// We&#39;re either running duing GC, failed to acquire a mspan,
</span><span class="c1"></span>			<span class="c1">// or the allocation is for a large object. This means we
</span><span class="c1"></span>			<span class="c1">// have to lock the heap and do a bunch of extra work,
</span><span class="c1"></span>			<span class="c1">// so go down the HaveBaseLocked path.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// We must do this during GC to avoid skew with heap_scan
</span><span class="c1"></span>			<span class="c1">// since we flush mcache stats whenever we lock.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// TODO(mknyszek): It would be nice to not have to
</span><span class="c1"></span>			<span class="c1">// lock the heap if it&#39;s a large allocation, but
</span><span class="c1"></span>			<span class="c1">// it&#39;s fine for now. The critical section here is
</span><span class="c1"></span>			<span class="c1">// short and large object allocations are relatively
</span><span class="c1"></span>			<span class="c1">// infrequent.
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// For one reason or another, we couldn&#39;t get the
</span><span class="c1"></span>	<span class="c1">// whole job done without the heap lock.
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">// 2、P的页缓存没有足够的内存，则在页堆上申请内存
</span><span class="c1"></span>	<span class="c1">// 内存比较大或者线程的页缓存中内存不足，从mheap的pages上获取内存
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">base</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Try to acquire a base address.
</span><span class="c1"></span>		<span class="c1">// mheap全局堆区
</span><span class="c1"></span>		<span class="nx">base</span><span class="p">,</span> <span class="nx">scav</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">pages</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span><span class="p">)</span>
		<span class="c1">// 内存也不够，那么进行扩容
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">base</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">grow</span><span class="p">(</span><span class="nx">npages</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// 从系统申请固定页数大小的内存区域
</span><span class="c1"></span>				<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
				<span class="k">return</span> <span class="kc">nil</span>
			<span class="p">}</span>
			<span class="c1">// 重新申请内存
</span><span class="c1"></span>			<span class="nx">base</span><span class="p">,</span> <span class="nx">scav</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">pages</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span><span class="p">)</span> <span class="c1">//重新从mheap获取
</span><span class="c1"></span>			<span class="c1">// 内存不足，抛出异常
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">base</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;grew heap, but no adequate free space found&#34;</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// We failed to get an mspan earlier, so grab
</span><span class="c1"></span>		<span class="c1">// one now that we have the heap lock.
</span><span class="c1"></span>		<span class="c1">// 分配一个mspan对象
</span><span class="c1"></span>		<span class="nx">s</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">allocMSpanLocked</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">manual</span> <span class="p">{</span>
		<span class="c1">// This is a heap span, so we should do some additional accounting
</span><span class="c1"></span>		<span class="c1">// which may only be done with the heap locked.
</span><span class="c1"></span>
		<span class="c1">// Transfer stats from mcache to global.
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span>
		<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">c</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">mcache</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// This case occurs while bootstrapping.
</span><span class="c1"></span>			<span class="c1">// See the similar code in mallocgc.
</span><span class="c1"></span>			<span class="nx">c</span> <span class="p">=</span> <span class="nx">mcache0</span>
			<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;mheap.allocSpan called with no P&#34;</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_scan</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">local_scan</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">local_scan</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">memstats</span><span class="p">.</span><span class="nx">tinyallocs</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">local_tinyallocs</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">local_tinyallocs</span> <span class="p">=</span> <span class="mi">0</span>

		<span class="c1">// Do some additional accounting if it&#39;s a large allocation.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">mheap_</span><span class="p">.</span><span class="nx">largealloc</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">npages</span> <span class="o">*</span> <span class="nx">pageSize</span><span class="p">)</span>
			<span class="nx">mheap_</span><span class="p">.</span><span class="nx">nlargealloc</span><span class="o">++</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">npages</span><span class="o">*</span><span class="nx">pageSize</span><span class="p">))</span>
		<span class="p">}</span>

		<span class="c1">// Either heap_live or heap_scan could have been updated.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">gcController</span><span class="p">.</span><span class="nf">revise</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

<span class="nx">HaveSpan</span><span class="p">:</span>
	<span class="c1">// At this point, both s != nil and base != 0, and the heap
</span><span class="c1"></span>	<span class="c1">// lock is no longer held. Initialize the span.
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">base</span><span class="p">,</span> <span class="nx">npages</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">allocNeedsZero</span><span class="p">(</span><span class="nx">base</span><span class="p">,</span> <span class="nx">npages</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="nx">nbytes</span> <span class="o">:=</span> <span class="nx">npages</span> <span class="o">*</span> <span class="nx">pageSize</span>
	<span class="k">if</span> <span class="nx">manual</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">manualFreeList</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">limit</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="o">*</span><span class="nx">pageSize</span>
		<span class="c1">// Manually managed memory doesn&#39;t count toward heap_sys.
</span><span class="c1"></span>		<span class="nf">mSysStatDec</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_sys</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="o">*</span><span class="nx">pageSize</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">mSpanManual</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// We must set span properties before the span is published anywhere
</span><span class="c1"></span>		<span class="c1">// since we&#39;re not holding the heap lock.
</span><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nx">spanclass</span> <span class="p">=</span> <span class="nx">spanclass</span>
		<span class="k">if</span> <span class="nx">sizeclass</span> <span class="o">:=</span> <span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">();</span> <span class="nx">sizeclass</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nx">nbytes</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">=</span> <span class="mi">1</span>

			<span class="nx">s</span><span class="p">.</span><span class="nx">divShift</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divMul</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divShift2</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">baseMask</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">sizeclass</span><span class="p">])</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">=</span> <span class="nx">nbytes</span> <span class="o">/</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>

			<span class="nx">m</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">class_to_divmagic</span><span class="p">[</span><span class="nx">sizeclass</span><span class="p">]</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divShift</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">shift</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divMul</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">mul</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divShift2</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">shift2</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">baseMask</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">baseMask</span>
		<span class="p">}</span>

		<span class="c1">// Initialize mark and allocation structures.
</span><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">allocCache</span> <span class="p">=</span> <span class="p">^</span><span class="nb">uint64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// all 1s indicating all free.
</span><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nx">gcmarkBits</span> <span class="p">=</span> <span class="nf">newMarkBits</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">allocBits</span> <span class="p">=</span> <span class="nf">newAllocBits</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span>

		<span class="c1">// It&#39;s safe to access h.sweepgen without the heap lock because it&#39;s
</span><span class="c1"></span>		<span class="c1">// only ever updated with the world stopped and we run on the
</span><span class="c1"></span>		<span class="c1">// systemstack which blocks a STW transition.
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">)</span>

		<span class="c1">// Now that the span is filled in, set its state. This
</span><span class="c1"></span>		<span class="c1">// is a publication barrier for the other fields in
</span><span class="c1"></span>		<span class="c1">// the span. While valid pointers into this span
</span><span class="c1"></span>		<span class="c1">// should never be visible until the span is returned,
</span><span class="c1"></span>		<span class="c1">// if the garbage collector finds an invalid pointer,
</span><span class="c1"></span>		<span class="c1">// access to the span may race with initialization of
</span><span class="c1"></span>		<span class="c1">// the span. We resolve this race by atomically
</span><span class="c1"></span>		<span class="c1">// setting the state after the span is fully
</span><span class="c1"></span>		<span class="c1">// initialized, and atomically checking the state in
</span><span class="c1"></span>		<span class="c1">// any situation where a pointer is suspect.
</span><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">mSpanInUse</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Commit and account for any scavenged memory that the span now owns.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">scav</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// sysUsed all the pages that are actually available
</span><span class="c1"></span>		<span class="c1">// in the span since some of them might be scavenged.
</span><span class="c1"></span>		<span class="nf">sysUsed</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">base</span><span class="p">),</span> <span class="nx">nbytes</span><span class="p">)</span>
		<span class="nf">mSysStatDec</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_released</span><span class="p">,</span> <span class="nx">scav</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// Update stats.
</span><span class="c1"></span>	<span class="nf">mSysStatInc</span><span class="p">(</span><span class="nx">sysStat</span><span class="p">,</span> <span class="nx">nbytes</span><span class="p">)</span>
	<span class="nf">mSysStatDec</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_idle</span><span class="p">,</span> <span class="nx">nbytes</span><span class="p">)</span>

	<span class="c1">// Publish the span in various locations.
</span><span class="c1"></span>
	<span class="c1">// This is safe to call without the lock held because the slots
</span><span class="c1"></span>	<span class="c1">// related to this span will only ever be read or modified by
</span><span class="c1"></span>	<span class="c1">// this thread until pointers into the span are published (and
</span><span class="c1"></span>	<span class="c1">// we execute a publication barrier at the end of this function
</span><span class="c1"></span>	<span class="c1">// before that happens) or pageInUse is updated.
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nf">setSpans</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">(),</span> <span class="nx">npages</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">manual</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">go115NewMCentralImpl</span> <span class="p">{</span>
			<span class="c1">// Add to swept in-use list.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// This publishes the span to root marking.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// h.sweepgen is guaranteed to only change during STW,
</span><span class="c1"></span>			<span class="c1">// and preemption is disabled in the page allocator.
</span><span class="c1"></span>			<span class="nx">h</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="nx">h</span><span class="p">.</span><span class="nx">sweepgen</span><span class="o">/</span><span class="mi">2</span><span class="o">%</span><span class="mi">2</span><span class="p">].</span><span class="nf">push</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// Mark in-use span in arena page bitmap.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// This publishes the span to the page sweeper, so
</span><span class="c1"></span>		<span class="c1">// it&#39;s imperative that the span be completely initialized
</span><span class="c1"></span>		<span class="c1">// prior to this line.
</span><span class="c1"></span>		<span class="nx">arena</span><span class="p">,</span> <span class="nx">pageIdx</span><span class="p">,</span> <span class="nx">pageMask</span> <span class="o">:=</span> <span class="nf">pageIndexOf</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Or8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arena</span><span class="p">.</span><span class="nx">pageInUse</span><span class="p">[</span><span class="nx">pageIdx</span><span class="p">],</span> <span class="nx">pageMask</span><span class="p">)</span>

		<span class="c1">// Update related page sweeper stats.
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">pagesInUse</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">npages</span><span class="p">))</span>

		<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
			<span class="c1">// Trace that a heap alloc occurred.
</span><span class="c1"></span>			<span class="nf">traceHeapAlloc</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Make sure the newly allocated span will be observed
</span><span class="c1"></span>	<span class="c1">// by the GC before pointers into the span are published.
</span><span class="c1"></span>	<span class="nf">publicationBarrier</span><span class="p">()</span>

	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="pagecache">pageCache</h4>
<p>在Go1.12的时候,Go语言采用了Treap 进行内存的管理，Treap 是一种引入了随机数的二叉树搜索树，其实现简单，并且引入的随机数以及必要时的旋转保证了比较好的平衡特性。Michael Knyszek 提出这种方式具有扩展性的问题，由于这棵树是mheap管理，当操作此二叉树的时候都需要维持一个lock。这在密集的对象分配以及逻辑处理器P过多的时候，会导致更长的等待时间。Michael Knyszek 提出用bitmap来管理内存页,并在每个P中维护一份page cache。这就是现在Go语言实现的方式。因此在go1.14之后，我们会看到在每个逻辑处理器P内部都有一个cache。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">pageCache</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">base</span>  <span class="kt">uintptr</span> <span class="c1">// 虚拟内存的基址 base address of the chunk
</span><span class="c1"></span>	<span class="nx">cache</span> <span class="kt">uint64</span>  <span class="c1">// bit位标记内存是否被分配
</span><span class="c1"></span>	<span class="nx">scav</span>  <span class="kt">uint64</span>  <span class="c1">// bit位标记内存是否被回收
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210817174705.png" alt=""></p>
<p>一位表示一页(8KB)，所以最大表示8KB*64=512KB缓存。当需要分配的页数小于 512/4=128KB时，需要首先从cache中分配</p>
<p>若页缓存没有足够的页，则向虚拟内存申请页</p>
<p>mheap会首先查找在每个逻辑处理器P中pageCache字段的cache。cache也是一个位图，其每一位都代表了一个page(8 KB) 因此，由于cache为uint64类型，其一共可以存储64*8=512KB的缓存。这512KB是连续的虚拟内存。在cache中，1代表未分配的内存，而0代表已分配的内存。base代表该虚拟内存的基地址。当需要分配的页数小于 512/4=128KB时，需要首先从cache中分配。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210816190154.png" alt=""></p>
<p>例如，假如要分配n pages，就需要查找cache中是否有连续n个1位。如果存在，则说明在缓存中查找到了合适的内存，用于初始化span。</p>
<p>从页缓存申请，只能申请连续个页，若不能连续则返回失败</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// alloc allocates npages from the page cache and is the main entry
</span><span class="c1">// point for allocation.
</span><span class="c1">//
</span><span class="c1">// Returns a base address and the amount of scavenged memory in the
</span><span class="c1">// allocated region in bytes.
</span><span class="c1">//
</span><span class="c1">// Returns a base address of zero on failure, in which case the
</span><span class="c1">// amount of scavenged memory should be ignored.
</span><span class="c1">// 申请pageCache
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">pageCache</span><span class="p">)</span> <span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">(</span><span class="kt">uintptr</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">cache</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="c1">// 页数为1
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">npages</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nf">TrailingZeros64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">cache</span><span class="p">))</span>
		<span class="nx">scav</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">scav</span> <span class="o">&gt;&gt;</span> <span class="nx">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
		<span class="c1">// 把使用的页数对应的bit位置为0 set bit to mark in-use
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">cache</span> <span class="o">&amp;^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">i</span> <span class="c1">// set bit to mark in-use
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">scav</span> <span class="o">&amp;^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">i</span>  <span class="c1">// clear bit to mark unscavenged
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">base</span> <span class="o">+</span> <span class="nx">i</span><span class="o">*</span><span class="nx">pageSize</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">scav</span><span class="p">)</span> <span class="o">*</span> <span class="nx">pageSize</span>
	<span class="p">}</span>
	<span class="c1">// 申请连续的n页
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">allocN</span><span class="p">(</span><span class="nx">npages</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// allocN is a helper which attempts to allocate npages worth of pages
</span><span class="c1">// from the cache. It represents the general case for allocating from
</span><span class="c1">// the page cache.
</span><span class="c1">//
</span><span class="c1">// Returns a base address and the amount of scavenged memory in the
</span><span class="c1">// allocated region in bytes.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">pageCache</span><span class="p">)</span> <span class="nf">allocN</span><span class="p">(</span><span class="nx">npages</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">(</span><span class="kt">uintptr</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="nf">findBitRange64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">cache</span><span class="p">,</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">npages</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">64</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">mask</span> <span class="o">:=</span> <span class="p">((</span><span class="nb">uint64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">npages</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">i</span>
	<span class="nx">scav</span> <span class="o">:=</span> <span class="nx">sys</span><span class="p">.</span><span class="nf">OnesCount64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">scav</span> <span class="o">&amp;</span> <span class="nx">mask</span><span class="p">)</span>
	<span class="c1">// 把使用的页数对应的bit位置为0 mark in-use bits  例如1110&amp;^10=1100
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">cache</span> <span class="o">&amp;^=</span> <span class="nx">mask</span> <span class="c1">// mark in-use bits
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">scav</span> <span class="o">&amp;^=</span> <span class="nx">mask</span>  <span class="c1">// clear scavenged bits
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">base</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">i</span><span class="o">*</span><span class="nx">pageSize</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">scav</span><span class="p">)</span> <span class="o">*</span> <span class="nx">pageSize</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="pagealloc">pageAlloc</h4>
<p>当要分配的page过大或者在逻辑处理器P的cache中没有找到可用的页数时，就需要对mheap加锁，并在整个mheap管理的虚拟地址空间的位图中查找是否有可用的pages。而且其在本质上涉及到Go语言是如何对线性的地址空间进行位图管理的。</p>
<p>管理线性的地址空间的位图结构叫做基数树（radix tree）， 他和一般的基数树结构有点不太一样，这个名字很大一部分是由于父节点包含了子节点的若干信息。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210817152655.png" alt=""></p>
<p>在该树中的每一个节点对应一个pallocSum结构。其中最底层的叶子节点对应的一个pallocSum结构包含了一个chunk的信息（512 <em>8 KB）,而除了叶子节点外的节点都包含了连续8个子节点的内存信息。例如,倒数第二层的节点包含了8个叶子节点（即8</em>chunk）的连续内存信息。因此，越上层的节点，其对应的内存就越多。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// pallocSum is a packed summary type which packs three numbers: start, max,
</span><span class="c1">// and end into a single 8-byte value. Each of these values are a summary of
</span><span class="c1">// a bitmap and are thus counts, each of which may have a maximum value of
</span><span class="c1">// 2^21 - 1, or all three may be equal to 2^21. The latter case is represented
</span><span class="c1">// by just setting the 64th bit.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">pallocSum</span> <span class="kt">uint64</span>

<span class="c1">// packPallocSum takes a start, max, and end value and produces a pallocSum.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">packPallocSum</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">max</span><span class="p">,</span> <span class="nx">end</span> <span class="kt">uint</span><span class="p">)</span> <span class="nx">pallocSum</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">max</span> <span class="o">==</span> <span class="nx">maxPackedValue</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">pallocSum</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">pallocSum</span><span class="p">((</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">start</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">maxPackedValue</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">|</span>
		<span class="p">((</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">max</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">maxPackedValue</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="nx">logMaxPackedValue</span><span class="p">)</span> <span class="p">|</span>
		<span class="p">((</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">end</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">maxPackedValue</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">logMaxPackedValue</span><span class="p">)))</span>
<span class="p">}</span>

<span class="c1">// start extracts the start value from a packed sum.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">pallocSum</span><span class="p">)</span> <span class="nf">start</span><span class="p">()</span> <span class="kt">uint</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span><span class="o">&amp;</span><span class="nb">uint64</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">63</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">maxPackedValue</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">uint</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">maxPackedValue</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// max extracts the max value from a packed sum.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">pallocSum</span><span class="p">)</span> <span class="nf">max</span><span class="p">()</span> <span class="kt">uint</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span><span class="o">&amp;</span><span class="nb">uint64</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">63</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">maxPackedValue</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">uint</span><span class="p">((</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nx">logMaxPackedValue</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">maxPackedValue</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// end extracts the end value from a packed sum.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">pallocSum</span><span class="p">)</span> <span class="nf">end</span><span class="p">()</span> <span class="kt">uint</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span><span class="o">&amp;</span><span class="nb">uint64</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">63</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">maxPackedValue</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">uint</span><span class="p">((</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">logMaxPackedValue</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">maxPackedValue</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>pallocSum虽然是一个简单的uint64类型，但是分成了开头、中间、末尾3个部分，开头语末尾部分占据了21bit,中间部分占据了22bit。它们分别包含了在这个区域中连续空闲内存页的信息。包括了在开头有多少连续内存页，最大有多少连续内存页，在末尾有多少连续内存页。对于最顶层的节点，由于其中间的max位为22bit，因此一颗完整的基数树最多代表2^21 pages=16G内存。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210817153203.png" alt=""></p>
<p>Go语言并不是一开始就直接从根节点往下查找的，而是首先做了一定的优化，类似于又一级别的缓存。在Go语言中，存储了一个特别的字段searchAddr，看名字就可以猜想到是用于搜索可用内存时使用的。searchAddr有一个重要的设定是在searchAddr地址之前一定是已经分配过的。因此在查找时，只需要往searchAddr地址的后方查找即可跳过查找的节点，减少查找的时间。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210817154546.png" alt=""></p>
<p>在第一次查找时，会首先从当前searchAddr的chunk块中查找是否有对应大小的连续空间。这种优化主要是针对比较小的内存分配（至少小于512KB）时使用的。Go语言对于内存有非常精细化的管理，chunk块的每一个page（8 KB）都有位图表明其是否已经被分配。</p>
<p>每一个chunk都有一个pallocData结构，其中pallocBits管理其分配的位图。pallocBits是一个uint64的大小为8的数组。由于每一位对应着一个page，因此pallocBits总共对应着64*8=512KB，恰好是一个chunk块的大小。位图的对应方式和之前是一样的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// pallocData encapsulates pallocBits and a bitmap for
</span><span class="c1">// whether or not a given page is scavenged in a single
</span><span class="c1">// structure. It&#39;s effectively a pallocBits with
</span><span class="c1">// additional functionality.
</span><span class="c1">//
</span><span class="c1">// Update the comment on (*pageAlloc).chunks should this
</span><span class="c1">// structure change.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">pallocData</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">pallocBits</span>
	<span class="nx">scavenged</span> <span class="nx">pageBits</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>而所有的chunk pallocData都在pageAlloc结构中进行管理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">pageAlloc</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Radix tree of summaries.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Each slice&#39;s cap represents the whole memory reservation.
</span><span class="c1"></span>	<span class="c1">// Each slice&#39;s len reflects the allocator&#39;s maximum known
</span><span class="c1"></span>	<span class="c1">// mapped heap address for that level.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The backing store of each summary level is reserved in init
</span><span class="c1"></span>	<span class="c1">// and may or may not be committed in grow (small address spaces
</span><span class="c1"></span>	<span class="c1">// may commit all the memory in init).
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The purpose of keeping len &lt;= cap is to enforce bounds checks
</span><span class="c1"></span>	<span class="c1">// on the top end of the slice so that instead of an unknown
</span><span class="c1"></span>	<span class="c1">// runtime segmentation fault, we get a much friendlier out-of-bounds
</span><span class="c1"></span>	<span class="c1">// error.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// To iterate over a summary level, use inUse to determine which ranges
</span><span class="c1"></span>	<span class="c1">// are currently available. Otherwise one might try to access
</span><span class="c1"></span>	<span class="c1">// memory which is only Reserved which may result in a hard fault.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// We may still get segmentation faults &lt; len since some of that
</span><span class="c1"></span>	<span class="c1">// memory may not be committed yet.
</span><span class="c1"></span>	<span class="nx">summary</span> <span class="p">[</span><span class="nx">summaryLevels</span><span class="p">][]</span><span class="nx">pallocSum</span>

	<span class="c1">// chunks is a slice of bitmap chunks.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The total size of chunks is quite large on most 64-bit platforms
</span><span class="c1"></span>	<span class="c1">// (O(GiB) or more) if flattened, so rather than making one large mapping
</span><span class="c1"></span>	<span class="c1">// (which has problems on some platforms, even when PROT_NONE) we use a
</span><span class="c1"></span>	<span class="c1">// two-level sparse array approach similar to the arena index in mheap.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// To find the chunk containing a memory address `a`, do:
</span><span class="c1"></span>	<span class="c1">//   chunkOf(chunkIndex(a))
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Below is a table describing the configuration for chunks for various
</span><span class="c1"></span>	<span class="c1">// heapAddrBits supported by the runtime.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// heapAddrBits | L1 Bits | L2 Bits | L2 Entry Size
</span><span class="c1"></span>	<span class="c1">// ------------------------------------------------
</span><span class="c1"></span>	<span class="c1">// 32           | 0       | 10      | 128 KiB
</span><span class="c1"></span>	<span class="c1">// 33 (iOS)     | 0       | 11      | 256 KiB
</span><span class="c1"></span>	<span class="c1">// 48           | 13      | 13      | 1 MiB
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// There&#39;s no reason to use the L1 part of chunks on 32-bit, the
</span><span class="c1"></span>	<span class="c1">// address space is small so the L2 is small. For platforms with a
</span><span class="c1"></span>	<span class="c1">// 48-bit address space, we pick the L1 such that the L2 is 1 MiB
</span><span class="c1"></span>	<span class="c1">// in size, which is a good balance between low granularity without
</span><span class="c1"></span>	<span class="c1">// making the impact on BSS too high (note the L1 is stored directly
</span><span class="c1"></span>	<span class="c1">// in pageAlloc).
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// To iterate over the bitmap, use inUse to determine which ranges
</span><span class="c1"></span>	<span class="c1">// are currently available. Otherwise one might iterate over unused
</span><span class="c1"></span>	<span class="c1">// ranges.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// TODO(mknyszek): Consider changing the definition of the bitmap
</span><span class="c1"></span>	<span class="c1">// such that 1 means free and 0 means in-use so that summaries and
</span><span class="c1"></span>	<span class="c1">// the bitmaps align better on zero-values.
</span><span class="c1"></span>	<span class="nx">chunks</span> <span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">pallocChunksL1Bits</span><span class="p">]</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">pallocChunksL2Bits</span><span class="p">]</span><span class="nx">pallocData</span>

	<span class="c1">// The address to start an allocation search with. It must never
</span><span class="c1"></span>	<span class="c1">// point to any memory that is not contained in inUse, i.e.
</span><span class="c1"></span>	<span class="c1">// inUse.contains(searchAddr.addr()) must always be true. The one
</span><span class="c1"></span>	<span class="c1">// exception to this rule is that it may take on the value of
</span><span class="c1"></span>	<span class="c1">// maxOffAddr to indicate that the heap is exhausted.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// We guarantee that all valid heap addresses below this value
</span><span class="c1"></span>	<span class="c1">// are allocated and not worth searching.
</span><span class="c1"></span>	<span class="nx">searchAddr</span> <span class="nx">offAddr</span>

	<span class="c1">// start and end represent the chunk indices
</span><span class="c1"></span>	<span class="c1">// which pageAlloc knows about. It assumes
</span><span class="c1"></span>	<span class="c1">// chunks in the range [start, end) are
</span><span class="c1"></span>	<span class="c1">// currently ready to use.
</span><span class="c1"></span>	<span class="nx">start</span><span class="p">,</span> <span class="nx">end</span> <span class="nx">chunkIdx</span>

	<span class="c1">// inUse is a slice of ranges of address space which are
</span><span class="c1"></span>	<span class="c1">// known by the page allocator to be currently in-use (passed
</span><span class="c1"></span>	<span class="c1">// to grow).
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This field is currently unused on 32-bit architectures but
</span><span class="c1"></span>	<span class="c1">// is harmless to track. We care much more about having a
</span><span class="c1"></span>	<span class="c1">// contiguous heap in these cases and take additional measures
</span><span class="c1"></span>	<span class="c1">// to ensure that, so in nearly all cases this should have just
</span><span class="c1"></span>	<span class="c1">// 1 element.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// All access is protected by the mheapLock.
</span><span class="c1"></span>	<span class="nx">inUse</span> <span class="nx">addrRanges</span>

	<span class="c1">// scav stores the scavenger state.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// All fields are protected by mheapLock.
</span><span class="c1"></span>	<span class="nx">scav</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="c1">// inUse is a slice of ranges of address space which have not
</span><span class="c1"></span>		<span class="c1">// yet been looked at by the scavenger.
</span><span class="c1"></span>		<span class="nx">inUse</span> <span class="nx">addrRanges</span>

		<span class="c1">// gen is the scavenge generation number.
</span><span class="c1"></span>		<span class="nx">gen</span> <span class="kt">uint32</span>

		<span class="c1">// reservationBytes is how large of a reservation should be made
</span><span class="c1"></span>		<span class="c1">// in bytes of address space for each scavenge iteration.
</span><span class="c1"></span>		<span class="nx">reservationBytes</span> <span class="kt">uintptr</span>

		<span class="c1">// released is the amount of memory released this generation.
</span><span class="c1"></span>		<span class="nx">released</span> <span class="kt">uintptr</span>

		<span class="c1">// scavLWM is the lowest (offset) address that the scavenger reached this
</span><span class="c1"></span>		<span class="c1">// scavenge generation.
</span><span class="c1"></span>		<span class="nx">scavLWM</span> <span class="nx">offAddr</span>

		<span class="c1">// freeHWM is the highest (offset) address of a page that was freed to
</span><span class="c1"></span>		<span class="c1">// the page allocator this scavenge generation.
</span><span class="c1"></span>		<span class="nx">freeHWM</span> <span class="nx">offAddr</span>
	<span class="p">}</span>

	<span class="c1">// mheap_.lock. This level of indirection makes it possible
</span><span class="c1"></span>	<span class="c1">// to test pageAlloc indepedently of the runtime allocator.
</span><span class="c1"></span>	<span class="nx">mheapLock</span> <span class="o">*</span><span class="nx">mutex</span>

	<span class="c1">// sysStat is the runtime memstat to update when new system
</span><span class="c1"></span>	<span class="c1">// memory is committed by the pageAlloc for allocation metadata.
</span><span class="c1"></span>	<span class="nx">sysStat</span> <span class="o">*</span><span class="nx">sysMemStat</span>

	<span class="c1">// Whether or not this struct is being used in tests.
</span><span class="c1"></span>	<span class="nx">test</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当所有的内存分配过大或者当前chunk块没有连续的npages空间时，就需要到基数树中从上到下进行查找。基数树有一个特性，即当要分配的内存越大时，它能够越快的查找到当前的基数树中是否有连续的空间能够满足。</p>
<p>在查找基数树的过程中，从上到下，从左到右的查找每一个节点是否符合要求。首先计算</p>
<p>pallocSum字段的开头start有多少连续的内存空间。如果start大于npages，说明我们已经查找到了可用的空间和地址。没有找到时，会计算pallocSum字段的max，即中间有多少连续的内存空间。如果max大于npages，我们需要继续往基数树当前节点对应的下一级继续查找。原因在于，max大于npages，表明当前一定有连续的空间满足npages，但是我们并不知道具体在哪一个位置，必须要继续往下一级查找时才能找到具体可用的地址。如果max也不满足，是不是就不满足了呢？不一定，因为有可能两个节点可以合并起来组成一个更大的连续空间。因此还需要将当前pallocSum计算的end与后一个节点的start加起来查看是否能够组合成大于npages的连续空间。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210817161612.png" alt=""></p>
<p>每一次从基数树中查找到内存，或者事后从操作系统分配内存的时候，都需要更新基数树中每一个节点的pallocSum。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// alloc allocates npages worth of memory from the page heap, returning the base
</span><span class="c1">// address for the allocation and the amount of scavenged memory in bytes
</span><span class="c1">// contained in the region [base address, base address + npages*pageSize).
</span><span class="c1">//
</span><span class="c1">// Returns a 0 base address on failure, in which case other returned values
</span><span class="c1">// should be ignored.
</span><span class="c1">//
</span><span class="c1">// p.mheapLock must be held.
</span><span class="c1">//
</span><span class="c1">// Must run on the system stack because p.mheapLock must be held.
</span><span class="c1">//
</span><span class="c1">//go:systemstack
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">pageAlloc</span><span class="p">)</span> <span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">(</span><span class="nx">addr</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">scav</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">assertLockHeld</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">mheapLock</span><span class="p">)</span>

	<span class="c1">// If the searchAddr refers to a region which has a higher address than
</span><span class="c1"></span>	<span class="c1">// any known chunk, then we know we&#39;re out of memory.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">chunkIndex</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">searchAddr</span><span class="p">.</span><span class="nf">addr</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">end</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="c1">// If npages has a chance of fitting in the chunk where the searchAddr is,
</span><span class="c1"></span>	<span class="c1">// search it directly.
</span><span class="c1"></span>	<span class="nx">searchAddr</span> <span class="o">:=</span> <span class="nx">minOffAddr</span>
	<span class="c1">// chunkPages总页数-当前使用页数&gt;=需要申请的页数 说明chunk满足申请的页数
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">pallocChunkPages</span><span class="o">-</span><span class="nf">chunkPageIndex</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">searchAddr</span><span class="p">.</span><span class="nf">addr</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">npages</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// npages is guaranteed to be no greater than pallocChunkPages here.
</span><span class="c1"></span>		<span class="nx">i</span> <span class="o">:=</span> <span class="nf">chunkIndex</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">searchAddr</span><span class="p">.</span><span class="nf">addr</span><span class="p">())</span>
		<span class="k">if</span> <span class="nx">max</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">summary</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">summary</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">i</span><span class="p">].</span><span class="nf">max</span><span class="p">();</span> <span class="nx">max</span> <span class="o">&gt;=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">npages</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">j</span><span class="p">,</span> <span class="nx">searchIdx</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">chunkOf</span><span class="p">(</span><span class="nx">i</span><span class="p">).</span><span class="nf">find</span><span class="p">(</span><span class="nx">npages</span><span class="p">,</span> <span class="nf">chunkPageIndex</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">searchAddr</span><span class="p">.</span><span class="nf">addr</span><span class="p">()))</span>
			<span class="k">if</span> <span class="nx">j</span> <span class="o">==</span> <span class="p">^</span><span class="nb">uint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: max = &#34;</span><span class="p">,</span> <span class="nx">max</span><span class="p">,</span> <span class="s">&#34;, npages = &#34;</span><span class="p">,</span> <span class="nx">npages</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
				<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: searchIdx = &#34;</span><span class="p">,</span> <span class="nf">chunkPageIndex</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">searchAddr</span><span class="p">.</span><span class="nf">addr</span><span class="p">()),</span> <span class="s">&#34;, p.searchAddr = &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">searchAddr</span><span class="p">.</span><span class="nf">addr</span><span class="p">()),</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad summary data&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">addr</span> <span class="p">=</span> <span class="nf">chunkBase</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">j</span><span class="p">)</span><span class="o">*</span><span class="nx">pageSize</span>
			<span class="nx">searchAddr</span> <span class="p">=</span> <span class="nx">offAddr</span><span class="p">{</span><span class="nf">chunkBase</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">searchIdx</span><span class="p">)</span><span class="o">*</span><span class="nx">pageSize</span><span class="p">}</span>
			<span class="k">goto</span> <span class="nx">Found</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// We failed to use a searchAddr for one reason or another, so try
</span><span class="c1"></span>	<span class="c1">// the slow path.
</span><span class="c1"></span>	<span class="nx">addr</span><span class="p">,</span> <span class="nx">searchAddr</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="nx">npages</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">addr</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">npages</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="c1">// We failed to find a single free page, the smallest unit
</span><span class="c1"></span>			<span class="c1">// of allocation. This means we know the heap is completely
</span><span class="c1"></span>			<span class="c1">// exhausted. Otherwise, the heap still might have free
</span><span class="c1"></span>			<span class="c1">// space in it, just not enough contiguous space to
</span><span class="c1"></span>			<span class="c1">// accommodate npages.
</span><span class="c1"></span>			<span class="nx">p</span><span class="p">.</span><span class="nx">searchAddr</span> <span class="p">=</span> <span class="nx">maxSearchAddr</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="p">}</span>
<span class="nx">Found</span><span class="p">:</span>
	<span class="c1">// Go ahead and actually mark the bits now that we have an address.
</span><span class="c1"></span>	<span class="nx">scav</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">allocRange</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">npages</span><span class="p">)</span>

	<span class="c1">// If we found a higher searchAddr, we know that all the
</span><span class="c1"></span>	<span class="c1">// heap memory before that searchAddr in an offset address space is
</span><span class="c1"></span>	<span class="c1">// allocated, so bump p.searchAddr up to the new one.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">searchAddr</span><span class="p">.</span><span class="nf">lessThan</span><span class="p">(</span><span class="nx">searchAddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">searchAddr</span> <span class="p">=</span> <span class="nx">searchAddr</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">scav</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="grow-1">grow</h3>
<p>当在基数树都查找不到可用的连续内存时，就需要从操作系统中索取内存。</p>
<p>每一次向操作系统申请内存时，Go语言规定必须为heapArena 大小的倍数。heapArena是和平台有关的内存大小，在unix 64位系统中，其大小为64M。这意味着即便需要的内存大小很少，最终也至少向操作系统申请64M。多申请的内存可以用于下次分配使用。</p>
<p>runtime.mheap.grow 方法会向操作系统申请更多的内存空间，传入的页数经过对齐可以得到期望的内存大小，我们可以将该方法的执行过程分成以下几个部分：</p>
<ol>
<li>通过传入的页数从已经保留的arena中获取期望分配的内存空间大小以及内存的基地址；</li>
<li>如果 arena 区域没有足够的空间，调用 runtime.mheap.sysAlloc 从操作系统中申请更多的内存；</li>
<li>扩容 runtime.mheap 持有的 arena 区域并更新页分配器的元信息；</li>
<li>在某些场景下，调用 runtime.pageAlloc.scavenge 回收不再使用的空闲内存页；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Try to add at least npage pages of memory to the heap,
</span><span class="c1">// returning whether it worked.
</span><span class="c1">//
</span><span class="c1">// h.lock must be held.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">grow</span><span class="p">(</span><span class="nx">npage</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// We must grow the heap in whole palloc chunks.
</span><span class="c1"></span>	<span class="nx">ask</span> <span class="o">:=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">npage</span><span class="p">,</span> <span class="nx">pallocChunkPages</span><span class="p">)</span> <span class="o">*</span> <span class="nx">pageSize</span>

	<span class="nx">totalGrowth</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="c1">// This may overflow because ask could be very large
</span><span class="c1"></span>	<span class="c1">// and is otherwise unrelated to h.curArena.base.
</span><span class="c1"></span>	<span class="nx">end</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">curArena</span><span class="p">.</span><span class="nx">base</span> <span class="o">+</span> <span class="nx">ask</span>
	<span class="nx">nBase</span> <span class="o">:=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">end</span><span class="p">,</span> <span class="nx">physPageSize</span><span class="p">)</span>
	<span class="c1">// 内存不够则调用sysAlloc申请内存
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">nBase</span> <span class="p">&gt;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">curArena</span><span class="p">.</span><span class="nx">end</span> <span class="o">||</span> <span class="cm">/* overflow */</span> <span class="nx">end</span> <span class="p">&lt;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">curArena</span><span class="p">.</span><span class="nx">base</span> <span class="p">{</span>
		<span class="c1">// Not enough room in the current arena. Allocate more
</span><span class="c1"></span>		<span class="c1">// arena space. This may not be contiguous with the
</span><span class="c1"></span>		<span class="c1">// current arena, so we have to request the full ask.
</span><span class="c1"></span>		<span class="nx">av</span><span class="p">,</span> <span class="nx">asize</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">sysAlloc</span><span class="p">(</span><span class="nx">ask</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">av</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: out of memory: cannot allocate &#34;</span><span class="p">,</span> <span class="nx">ask</span><span class="p">,</span> <span class="s">&#34;-byte block (&#34;</span><span class="p">,</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_sys</span><span class="p">,</span> <span class="s">&#34; in use)\n&#34;</span><span class="p">)</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
		<span class="c1">// 重新设置curArena的值
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">av</span><span class="p">)</span> <span class="o">==</span> <span class="nx">h</span><span class="p">.</span><span class="nx">curArena</span><span class="p">.</span><span class="nx">end</span> <span class="p">{</span>
			<span class="c1">// The new space is contiguous with the old
</span><span class="c1"></span>			<span class="c1">// space, so just extend the current space.
</span><span class="c1"></span>			<span class="nx">h</span><span class="p">.</span><span class="nx">curArena</span><span class="p">.</span><span class="nx">end</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">av</span><span class="p">)</span> <span class="o">+</span> <span class="nx">asize</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// The new space is discontiguous. Track what
</span><span class="c1"></span>			<span class="c1">// remains of the current space and switch to
</span><span class="c1"></span>			<span class="c1">// the new space. This should be rare.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">size</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">curArena</span><span class="p">.</span><span class="nx">end</span> <span class="o">-</span> <span class="nx">h</span><span class="p">.</span><span class="nx">curArena</span><span class="p">.</span><span class="nx">base</span><span class="p">;</span> <span class="nx">size</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">h</span><span class="p">.</span><span class="nx">pages</span><span class="p">.</span><span class="nf">grow</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">curArena</span><span class="p">.</span><span class="nx">base</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
				<span class="nx">totalGrowth</span> <span class="o">+=</span> <span class="nx">size</span>
			<span class="p">}</span>
			<span class="c1">// Switch to the new space.
</span><span class="c1"></span>			<span class="nx">h</span><span class="p">.</span><span class="nx">curArena</span><span class="p">.</span><span class="nx">base</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">av</span><span class="p">)</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">curArena</span><span class="p">.</span><span class="nx">end</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">av</span><span class="p">)</span> <span class="o">+</span> <span class="nx">asize</span>
		<span class="p">}</span>

		<span class="c1">// The memory just allocated counts as both released
</span><span class="c1"></span>		<span class="c1">// and idle, even though it&#39;s not yet backed by spans.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// The allocation is always aligned to the heap arena
</span><span class="c1"></span>		<span class="c1">// size which is always &gt; physPageSize, so its safe to
</span><span class="c1"></span>		<span class="c1">// just add directly to heap_released.
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_released</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">asize</span><span class="p">))</span>
		<span class="nx">stats</span> <span class="o">:=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heapStats</span><span class="p">.</span><span class="nf">acquire</span><span class="p">()</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">stats</span><span class="p">.</span><span class="nx">released</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">asize</span><span class="p">))</span>
		<span class="nx">memstats</span><span class="p">.</span><span class="nx">heapStats</span><span class="p">.</span><span class="nf">release</span><span class="p">()</span>

		<span class="c1">// Recalculate nBase.
</span><span class="c1"></span>		<span class="c1">// We know this won&#39;t overflow, because sysAlloc returned
</span><span class="c1"></span>		<span class="c1">// a valid region starting at h.curArena.base which is at
</span><span class="c1"></span>		<span class="c1">// least ask bytes in size.
</span><span class="c1"></span>		<span class="nx">nBase</span> <span class="p">=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">curArena</span><span class="p">.</span><span class="nx">base</span><span class="o">+</span><span class="nx">ask</span><span class="p">,</span> <span class="nx">physPageSize</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Grow into the current arena.
</span><span class="c1"></span>	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">curArena</span><span class="p">.</span><span class="nx">base</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">curArena</span><span class="p">.</span><span class="nx">base</span> <span class="p">=</span> <span class="nx">nBase</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">pages</span><span class="p">.</span><span class="nf">grow</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">nBase</span><span class="o">-</span><span class="nx">v</span><span class="p">)</span>
	<span class="nx">totalGrowth</span> <span class="o">+=</span> <span class="nx">nBase</span> <span class="o">-</span> <span class="nx">v</span>

	<span class="c1">// We just caused a heap growth, so scavenge down what will soon be used.
</span><span class="c1"></span>	<span class="c1">// By scavenging inline we deal with the failure to allocate out of
</span><span class="c1"></span>	<span class="c1">// memory fragments by scavenging the memory fragments that are least
</span><span class="c1"></span>	<span class="c1">// likely to be re-used.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">retained</span> <span class="o">:=</span> <span class="nf">heapRetained</span><span class="p">();</span> <span class="nx">retained</span><span class="o">+</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">totalGrowth</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">scavengeGoal</span> <span class="p">{</span>
		<span class="nx">todo</span> <span class="o">:=</span> <span class="nx">totalGrowth</span>
		<span class="k">if</span> <span class="nx">overage</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">retained</span> <span class="o">+</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">totalGrowth</span><span class="p">)</span> <span class="o">-</span> <span class="nx">h</span><span class="p">.</span><span class="nx">scavengeGoal</span><span class="p">);</span> <span class="nx">todo</span> <span class="p">&gt;</span> <span class="nx">overage</span> <span class="p">{</span>
			<span class="nx">todo</span> <span class="p">=</span> <span class="nx">overage</span>
		<span class="p">}</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">pages</span><span class="p">.</span><span class="nf">scavenge</span><span class="p">(</span><span class="nx">todo</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>grow会通过curArena的end值来判断是不是需要从系统申请内存；如果end小于nBase那么会调用runtime.mheap.sysAlloc方法从操作系统中申请更多的内存；</p>
<p>在页堆扩容的过程中，runtime.mheap.sysAlloc 是页堆用来申请虚拟内存的方法.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// sysAlloc allocates heap arena space for at least n bytes. The
</span><span class="c1">// returned pointer is always heapArenaBytes-aligned and backed by
</span><span class="c1">// h.arenas metadata. The returned size is always a multiple of
</span><span class="c1">// heapArenaBytes. sysAlloc returns nil on failure.
</span><span class="c1">// There is no corresponding free function.
</span><span class="c1">//
</span><span class="c1">// sysAlloc returns a memory region in the Prepared state. This region must
</span><span class="c1">// be transitioned to Ready before use.
</span><span class="c1">//
</span><span class="c1">// h must be locked.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">sysAlloc</span><span class="p">(</span><span class="nx">n</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="p">=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">heapArenaBytes</span><span class="p">)</span>
	<span class="c1">//首先，该方法会尝试在预保留的区域申请内存：
</span><span class="c1"></span>	<span class="c1">// First, try the arena pre-reservation.
</span><span class="c1"></span>	<span class="c1">//调用线性分配器的 runtime.linearAlloc.alloc 方法在预先保留的内存中申请一块可以使用的空间。
</span><span class="c1"></span>	<span class="c1">// 在预先保留的内存中申请一块可以使用的空间
</span><span class="c1"></span>	<span class="nx">v</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">arena</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">heapArenaBytes</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_sys</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">v</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">size</span> <span class="p">=</span> <span class="nx">n</span>
		<span class="k">goto</span> <span class="nx">mapped</span>
	<span class="p">}</span>

	<span class="c1">// Try to grow the heap at a hint address.
</span><span class="c1"></span>	<span class="c1">// 如果获取不到，再尝试增长 arena hint
</span><span class="c1"></span>	<span class="c1">//如果没有可用的空间，我们会根据页堆的 arenaHints 在目标地址上尝试扩容：
</span><span class="c1"></span>	<span class="c1">//runtime.sysReserve 和 runtime.sysMap 是代码的核心部分，它们会从操作系统中申请内存并将内存转换至 Prepared 状态。
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">h</span><span class="p">.</span><span class="nx">arenaHints</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">hint</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">arenaHints</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">hint</span><span class="p">.</span><span class="nx">addr</span>
		<span class="k">if</span> <span class="nx">hint</span><span class="p">.</span><span class="nx">down</span> <span class="p">{</span>
			<span class="nx">p</span> <span class="o">-=</span> <span class="nx">n</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">p</span><span class="o">+</span><span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">p</span> <span class="p">{</span><span class="c1">// 溢出
</span><span class="c1"></span>			<span class="c1">// We can&#39;t use this, so don&#39;t ask.
</span><span class="c1"></span>			<span class="nx">v</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nf">arenaIndex</span><span class="p">(</span><span class="nx">p</span><span class="o">+</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">arenaBits</span> <span class="p">{</span><span class="c1">// 溢出
</span><span class="c1"></span>			<span class="c1">// Outside addressable heap. Can&#39;t use.
</span><span class="c1"></span>			<span class="nx">v</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">v</span> <span class="p">=</span> <span class="nf">sysReserve</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="nx">n</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 获取成功，更新 arena hint
</span><span class="c1"></span>			<span class="c1">// Success. Update the hint.
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">hint</span><span class="p">.</span><span class="nx">down</span> <span class="p">{</span>
				<span class="nx">p</span> <span class="o">+=</span> <span class="nx">n</span>
			<span class="p">}</span>
			<span class="nx">hint</span><span class="p">.</span><span class="nx">addr</span> <span class="p">=</span> <span class="nx">p</span>
			<span class="nx">size</span> <span class="p">=</span> <span class="nx">n</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="c1">// Failed. Discard this hint and try the next.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// TODO: This would be cleaner if sysReserve could be
</span><span class="c1"></span>		<span class="c1">// told to only return the requested address. In
</span><span class="c1"></span>		<span class="c1">// particular, this is already how Windows behaves, so
</span><span class="c1"></span>		<span class="c1">// it would simplify things there.
</span><span class="c1"></span>		<span class="c1">// 失败，丢弃并重新尝试
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">v</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">sysFree</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">arenaHints</span> <span class="p">=</span> <span class="nx">hint</span><span class="p">.</span><span class="nx">next</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">arenaHintAlloc</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">hint</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="c1">// The race detector assumes the heap lives in
</span><span class="c1"></span>			<span class="c1">// [0x00c000000000, 0x00e000000000), but we
</span><span class="c1"></span>			<span class="c1">// just ran out of hints in this region. Give
</span><span class="c1"></span>			<span class="c1">// a nice failure.
</span><span class="c1"></span>			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;too many address space collisions for -race mode&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// All of the hints failed, so we&#39;ll take any
</span><span class="c1"></span>		<span class="c1">// (sufficiently aligned) address the kernel will give
</span><span class="c1"></span>		<span class="c1">// us.
</span><span class="c1"></span>		<span class="nx">v</span><span class="p">,</span> <span class="nx">size</span> <span class="p">=</span> <span class="nf">sysReserveAligned</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">heapArenaBytes</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span>
		<span class="p">}</span>

		<span class="c1">// Create new hints for extending this region.
</span><span class="c1"></span>		<span class="c1">// 创建新的 hint 来增长此区域
</span><span class="c1"></span>		<span class="nx">hint</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">arenaHint</span><span class="p">)(</span><span class="nx">h</span><span class="p">.</span><span class="nx">arenaHintAlloc</span><span class="p">.</span><span class="nf">alloc</span><span class="p">())</span>
		<span class="nx">hint</span><span class="p">.</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">hint</span><span class="p">.</span><span class="nx">down</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">),</span> <span class="kc">true</span>
		<span class="nx">hint</span><span class="p">.</span><span class="nx">next</span><span class="p">,</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenaHints</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenaHints</span><span class="p">,</span> <span class="nx">hint</span>
		<span class="nx">hint</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">arenaHint</span><span class="p">)(</span><span class="nx">h</span><span class="p">.</span><span class="nx">arenaHintAlloc</span><span class="p">.</span><span class="nf">alloc</span><span class="p">())</span>
		<span class="nx">hint</span><span class="p">.</span><span class="nx">addr</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="o">+</span> <span class="nx">size</span>
		<span class="nx">hint</span><span class="p">.</span><span class="nx">next</span><span class="p">,</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenaHints</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenaHints</span><span class="p">,</span> <span class="nx">hint</span>
	<span class="p">}</span>

	<span class="c1">// Check for bad pointers or pointers we can&#39;t use.
</span><span class="c1"></span>	<span class="c1">// 检查不能使用的指针
</span><span class="c1"></span>	<span class="p">{</span>
		<span class="kd">var</span> <span class="nx">bad</span> <span class="kt">string</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">p</span><span class="o">+</span><span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">p</span> <span class="p">{</span>
			<span class="nx">bad</span> <span class="p">=</span> <span class="s">&#34;region exceeds uintptr range&#34;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nf">arenaIndex</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">arenaBits</span> <span class="p">{</span>
			<span class="nx">bad</span> <span class="p">=</span> <span class="s">&#34;base outside usable address space&#34;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nf">arenaIndex</span><span class="p">(</span><span class="nx">p</span><span class="o">+</span><span class="nx">size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">arenaBits</span> <span class="p">{</span>
			<span class="nx">bad</span> <span class="p">=</span> <span class="s">&#34;end outside usable address space&#34;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">bad</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="c1">// This should be impossible on most architectures,
</span><span class="c1"></span>			<span class="c1">// but it would be really confusing to debug.
</span><span class="c1"></span>			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: memory allocated by OS [&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="s">&#34;, &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">p</span><span class="o">+</span><span class="nx">size</span><span class="p">),</span> <span class="s">&#34;) not in usable address space: &#34;</span><span class="p">,</span> <span class="nx">bad</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;memory reservation exceeds address space limit&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">heapArenaBytes</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;misrounded allocation in sysAlloc&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Transition from Reserved to Prepared.
</span><span class="c1"></span>	<span class="c1">// 正式开始使用保留的内存
</span><span class="c1"></span>	<span class="nf">sysMap</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_sys</span><span class="p">)</span>

<span class="nx">mapped</span><span class="p">:</span>
	<span class="c1">// Create arena metadata.
</span><span class="c1"></span>	<span class="c1">//runtime.mheap.sysAlloc 方法在最后会初始化一个新的 runtime.heapArena 结构体来管理刚刚申请的内存空间，该结构体会被加入页堆的二维矩阵中。
</span><span class="c1"></span>	<span class="c1">// 创建 arena 的 metadata
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">ri</span> <span class="o">:=</span> <span class="nf">arenaIndex</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">));</span> <span class="nx">ri</span> <span class="o">&lt;=</span> <span class="nf">arenaIndex</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span><span class="o">+</span><span class="nx">size</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="nx">ri</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">l2</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">arenas</span><span class="p">[</span><span class="nx">ri</span><span class="p">.</span><span class="nf">l1</span><span class="p">()]</span>
		<span class="k">if</span> <span class="nx">l2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// Allocate an L2 arena map.
</span><span class="c1"></span>			<span class="c1">// 分配 L2 arena map
</span><span class="c1"></span>			<span class="nx">l2</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">arenaL2Bits</span><span class="p">]</span><span class="o">*</span><span class="nx">heapArena</span><span class="p">)(</span><span class="nf">persistentalloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="o">*</span><span class="nx">l2</span><span class="p">),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">l2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory allocating heap arena map&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">StorepNoWB</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">arenas</span><span class="p">[</span><span class="nx">ri</span><span class="p">.</span><span class="nf">l1</span><span class="p">()]),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">l2</span><span class="p">))</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">l2</span><span class="p">[</span><span class="nx">ri</span><span class="p">.</span><span class="nf">l2</span><span class="p">()]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;arena already initialized&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="kd">var</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">heapArena</span>
		<span class="nx">r</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">heapArena</span><span class="p">)(</span><span class="nx">h</span><span class="p">.</span><span class="nx">heapArenaAlloc</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="o">*</span><span class="nx">r</span><span class="p">),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_sys</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">r</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">r</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">heapArena</span><span class="p">)(</span><span class="nf">persistentalloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="o">*</span><span class="nx">r</span><span class="p">),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_sys</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">r</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory allocating heap arena metadata&#34;</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// Add the arena to the arenas list.
</span><span class="c1"></span>		<span class="c1">// 将 arena 添加到 arena 列表中
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">)</span> <span class="o">==</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">size</span> <span class="o">:=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">))</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
			<span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">size</span> <span class="p">=</span> <span class="nx">physPageSize</span>
			<span class="p">}</span>
			<span class="nx">newArray</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">notInHeap</span><span class="p">)(</span><span class="nf">persistentalloc</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_sys</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">newArray</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory allocating allArenas&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">oldSlice</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span>
			<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">notInHeapSlice</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">))</span> <span class="p">=</span> <span class="nx">notInHeapSlice</span><span class="p">{</span><span class="nx">newArray</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="nx">size</span> <span class="o">/</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)}</span>
			<span class="nb">copy</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">,</span> <span class="nx">oldSlice</span><span class="p">)</span>
			<span class="c1">// Do not free the old backing array because
</span><span class="c1"></span>			<span class="c1">// there may be concurrent readers. Since we
</span><span class="c1"></span>			<span class="c1">// double the array each time, this can lead
</span><span class="c1"></span>			<span class="c1">// to at most 2x waste.
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">ri</span>

		<span class="c1">// Store atomically just in case an object from the
</span><span class="c1"></span>		<span class="c1">// new heap arena becomes visible before the heap lock
</span><span class="c1"></span>		<span class="c1">// is released (which shouldn&#39;t happen, but there&#39;s
</span><span class="c1"></span>		<span class="c1">// little downside to this).
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">StorepNoWB</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l2</span><span class="p">[</span><span class="nx">ri</span><span class="p">.</span><span class="nf">l2</span><span class="p">()]),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">r</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="c1">// Tell the race detector about the new heap memory.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">racemapshadow</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>这个过程略显复杂：</p>
<ol>
<li>首先会通过现有的 arena 中获得已经保留的内存区域，如果能获取到，则直接对 arena 进行初始化；</li>
<li>如果没有，则会通过 sysReserve 为 arena 保留新的内存区域，并通过 sysReserveAligned 对操作系统对齐的区域进行重排，而后使用 sysMap 正式使用所在区块的内存。</li>
<li>在 arena 初始化阶段，本质上是为 arena 创建 metadata，这部分内存属于堆外内存，即不会被 GC 所追踪的内存，因而通过 persistentalloc 进行分配。</li>
</ol>
<p>persistentalloc 是 sysAlloc 之上的一层封装，它分配到的内存用于不能被释放。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Wrapper around sysAlloc that can allocate small chunks.
</span><span class="c1">// There is no associated free operation.
</span><span class="c1">// Intended for things like function/type/debug-related persistent data.
</span><span class="c1">// If align is 0, uses default align (currently 8).
</span><span class="c1">// The returned memory will be zeroed.
</span><span class="c1">//
</span><span class="c1">// Consider marking persistentalloc&#39;d types go:notinheap.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">persistentalloc</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">align</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">sysStat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">p</span> <span class="o">*</span><span class="nx">notInHeap</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nf">persistentalloc1</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">align</span><span class="p">,</span> <span class="nx">sysStat</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Must run on system stack because stack growth can (re)invoke it.
</span><span class="c1">// See issue 9174.
</span><span class="c1">//go:systemstack
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">persistentalloc1</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">align</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">sysStat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="o">*</span><span class="nx">notInHeap</span> <span class="p">{</span>
	<span class="kd">const</span> <span class="p">(</span>
		<span class="nx">maxBlock</span> <span class="p">=</span> <span class="mi">64</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span> <span class="c1">// VM reservation granularity is 64K on windows
</span><span class="c1"></span>	<span class="p">)</span>
	<span class="c1">// 不允许分配大小为 0 的空间
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;persistentalloc: size == 0&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 对齐数必须为 2 的指数、且不大于 PageSize
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">align</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">align</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">align</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;persistentalloc: align is not a power of 2&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">align</span> <span class="p">&gt;</span> <span class="nx">_PageSize</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;persistentalloc: align is too large&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 若未指定则默认为 8
</span><span class="c1"></span>		<span class="nx">align</span> <span class="p">=</span> <span class="mi">8</span>
	<span class="p">}</span>
	<span class="c1">// 分配大内存：分配的大小如果超过最大的 block 大小，则直接调用 sysAlloc 进行分配
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">size</span> <span class="o">&gt;=</span> <span class="nx">maxBlock</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">notInHeap</span><span class="p">)(</span><span class="nf">sysAlloc</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">sysStat</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="c1">// 分配小内存：在 m 上进行
</span><span class="c1"></span>	<span class="c1">// 先获取 m
</span><span class="c1"></span>	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
	<span class="kd">var</span> <span class="nx">persistent</span> <span class="o">*</span><span class="nx">persistentAlloc</span>
	<span class="k">if</span> <span class="nx">mp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 如果能够获取到 m 且同时持有 p，则直接分配到 p 的 palloc 上
</span><span class="c1"></span>		<span class="nx">persistent</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">palloc</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 否则就分配到全局的 globalAlloc.persistentAlloc 上
</span><span class="c1"></span>		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">globalAlloc</span><span class="p">.</span><span class="nx">mutex</span><span class="p">)</span>
		<span class="nx">persistent</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">globalAlloc</span><span class="p">.</span><span class="nx">persistentAlloc</span>
	<span class="p">}</span>
	<span class="c1">// 四舍五入 off 到 align 的倍数
</span><span class="c1"></span>	<span class="nx">persistent</span><span class="p">.</span><span class="nx">off</span> <span class="p">=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">persistent</span><span class="p">.</span><span class="nx">off</span><span class="p">,</span> <span class="nx">align</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">persistent</span><span class="p">.</span><span class="nx">off</span><span class="o">+</span><span class="nx">size</span> <span class="p">&gt;</span> <span class="nx">persistentChunkSize</span> <span class="o">||</span> <span class="nx">persistent</span><span class="p">.</span><span class="nx">base</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">persistent</span><span class="p">.</span><span class="nx">base</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">notInHeap</span><span class="p">)(</span><span class="nf">sysAlloc</span><span class="p">(</span><span class="nx">persistentChunkSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">other_sys</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">persistent</span><span class="p">.</span><span class="nx">base</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">persistent</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">globalAlloc</span><span class="p">.</span><span class="nx">persistentAlloc</span> <span class="p">{</span>
				<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">globalAlloc</span><span class="p">.</span><span class="nx">mutex</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: cannot allocate memory&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// Add the new chunk to the persistentChunks list.
</span><span class="c1"></span>		<span class="k">for</span> <span class="p">{</span>
			<span class="nx">chunks</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">persistentChunks</span><span class="p">))</span>
			<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">persistent</span><span class="p">.</span><span class="nx">base</span><span class="p">))</span> <span class="p">=</span> <span class="nx">chunks</span>
			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Casuintptr</span><span class="p">((</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">persistentChunks</span><span class="p">)),</span> <span class="nx">chunks</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">persistent</span><span class="p">.</span><span class="nx">base</span><span class="p">)))</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">persistent</span><span class="p">.</span><span class="nx">off</span> <span class="p">=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="nx">align</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">persistent</span><span class="p">.</span><span class="nx">base</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">persistent</span><span class="p">.</span><span class="nx">off</span><span class="p">)</span>
	<span class="nx">persistent</span><span class="p">.</span><span class="nx">off</span> <span class="o">+=</span> <span class="nx">size</span>
	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">persistent</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">globalAlloc</span><span class="p">.</span><span class="nx">persistentAlloc</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">globalAlloc</span><span class="p">.</span><span class="nx">mutex</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">sysStat</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">other_sys</span> <span class="p">{</span>
		<span class="nf">mSysStatInc</span><span class="p">(</span><span class="nx">sysStat</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
		<span class="nf">mSysStatDec</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">other_sys</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">p</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，这里申请到的内存会被记录到 globalAlloc 中:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">globalAlloc</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">mutex</span>
	<span class="nx">persistentAlloc</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">persistentAlloc</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">base</span> <span class="o">*</span><span class="nx">notInHeap</span> <span class="c1">// 空结构，内存首地址
</span><span class="c1"></span>	<span class="nx">off</span>  <span class="kt">uintptr</span>    <span class="c1">// 偏移量
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="linearalloc">linearAlloc</h3>
<p>linearAlloc 是一个基于线性分配策略的分配器，但由于它只作为 mheap_.heapArenaAlloc 和 mheap_.arena 在 32 位系统上使用，这里不做详细分析。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// linearAlloc 是一个简单的线性分配器，它预留一块内存区域并按需将其映射到 Ready 状态。
</span><span class="c1">// 调用方有责任对齐进行加锁。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">linearAlloc</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">next</span>   <span class="kt">uintptr</span> <span class="c1">// 下一个可用的字节
</span><span class="c1"></span>	<span class="nx">mapped</span> <span class="kt">uintptr</span> <span class="c1">// 映射空间后的一个字节
</span><span class="c1"></span>	<span class="nx">end</span>    <span class="kt">uintptr</span> <span class="c1">// 保留空间的末尾
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">linearAlloc</span><span class="p">)</span> <span class="nf">init</span><span class="p">(</span><span class="nx">base</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">next</span><span class="p">,</span> <span class="nx">l</span><span class="p">.</span><span class="nx">mapped</span> <span class="p">=</span> <span class="nx">base</span><span class="p">,</span> <span class="nx">base</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">end</span> <span class="p">=</span> <span class="nx">base</span> <span class="o">+</span> <span class="nx">size</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">linearAlloc</span><span class="p">)</span> <span class="nf">alloc</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">align</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">sysStat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nf">round</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">next</span><span class="p">,</span> <span class="nx">align</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">p</span><span class="o">+</span><span class="nx">size</span> <span class="p">&gt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">end</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">p</span> <span class="o">+</span> <span class="nx">size</span>
	<span class="k">if</span> <span class="nx">pEnd</span> <span class="o">:=</span> <span class="nf">round</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">next</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">physPageSize</span><span class="p">);</span> <span class="nx">pEnd</span> <span class="p">&gt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">mapped</span> <span class="p">{</span>
		<span class="c1">// We need to map more of the reserved space.
</span><span class="c1"></span>		<span class="nf">sysMap</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">mapped</span><span class="p">),</span> <span class="nx">pEnd</span><span class="o">-</span><span class="nx">l</span><span class="p">.</span><span class="nx">mapped</span><span class="p">,</span> <span class="nx">sysStat</span><span class="p">)</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">mapped</span> <span class="p">=</span> <span class="nx">pEnd</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="堆内存释放">堆内存释放</h3>
<p>堆内存的分配释放主要通过allocSpanLocked和freeSpanLocked完成。</p>
<ul>
<li>allocSpanLocked优先从已分配堆内存中进行分配，如果没有合适的堆内存块（mspan），则触发堆增长，并再次申请。</li>
<li>freeSpanLocked将内存块归还到已分配堆内存队列中。一个额外动作是，通过检查当前mspan空间的和其连续空间的前后mspan是否均处于_MSpanFree状态，来决定是否要合并这些mspan。</li>
</ul>
<p>注意这两个方法的命名。Locked表示对这两个方法的调用需要使用mheap.lock加锁，因为其内部操作了mheap的缓存队列或mTreap。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">allocSpanLocked</span><span class="p">(</span><span class="nx">npage</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">stat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">list</span> <span class="o">*</span><span class="nx">mSpanList</span>
	<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>

	<span class="c1">// 如果需求page数量小于128，则优先从mheap.free中获取满足npage数量的mspan
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">npage</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">free</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">list</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">free</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">list</span><span class="p">.</span><span class="nf">isEmpty</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">s</span> <span class="p">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">first</span>
			<span class="nx">list</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="k">goto</span> <span class="nx">HaveSpan</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 如果npage大于128，则从mheap.freelarge树堆中分配满足npage数量的mspan
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">allocLarge</span><span class="p">(</span><span class="nx">npage</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// mheap.freelarge树堆中没有满足条件可用的mspan，则扩张堆空间。
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">grow</span><span class="p">(</span><span class="nx">npage</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="c1">// 再次尝试从堆中申请
</span><span class="c1"></span>		<span class="nx">s</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">allocLarge</span><span class="p">(</span><span class="nx">npage</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nx">HaveSpan</span><span class="p">:</span>
	<span class="c1">// ...
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="p">&gt;</span> <span class="nx">npage</span> <span class="p">{</span>
		<span class="c1">// 从mtreap中获得mspan为最小的满足npage需求的mspan，其实际空间可能大于需求量
</span><span class="c1"></span>		<span class="c1">// 如果实际分配的空间大于需求的空间，则使用多余出来的空间构造出一个新的mspan
</span><span class="c1"></span>		<span class="c1">// 将新的mspan归还给堆缓存
</span><span class="c1"></span>		<span class="nx">t</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">mspan</span><span class="p">)(</span><span class="nx">h</span><span class="p">.</span><span class="nx">spanalloc</span><span class="p">.</span><span class="nf">alloc</span><span class="p">())</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span><span class="o">+</span><span class="nx">npage</span><span class="o">&lt;&lt;</span><span class="nx">_PageShift</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="o">-</span><span class="nx">npage</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="p">=</span> <span class="nx">npage</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">setSpan</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">setSpan</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">base</span><span class="p">(),</span> <span class="nx">t</span><span class="p">)</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">setSpan</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span><span class="o">+</span><span class="nx">t</span><span class="p">.</span><span class="nx">npages</span><span class="o">*</span><span class="nx">pageSize</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">needzero</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">_MSpanManual</span>	<span class="c1">// s是最终要返回的mspan对象，由于其与t是连续的，为了避免free t时发生合并，暂时将s状态置为非_MSpanFree
</span><span class="c1"></span>		<span class="nx">t</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">_MSpanManual</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">freeSpanLocked</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">unusedsince</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">_MSpanFree</span>
	<span class="p">}</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">unusedsince</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="c1">// 更新heapArena
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nf">setSpans</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">(),</span> <span class="nx">npage</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>

	<span class="c1">// ...
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>allocSpanLocked仅会返回满足需求页数量的内存空间，如果查找到堆中的mspan拥有的系统页数量超过需求量，多余的系统页将被额外新创建的mspan持有，并写回堆缓存中。</p>
<p>allocSpanLocked主要完成空闲mspan从free、freelarge的脱链，返回的mspan处于_MSpanFree状态。</p>
<p>查找mheap.free时时间复杂度最大为O（N）</p>
<p>freeSpanLocked</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">freeSpanLocked</span><span class="p">(</span><span class="nx">s</span><span class="o">*</span><span class="nx">mspan</span><span class="p">,</span> <span class="nx">acctinuse</span><span class="p">,</span> <span class="nx">acctidle</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">unusedsince</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span>
	<span class="c1">// 将mspan从使用中列表脱链，修改状态为空闲状态
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">_MSpanFree</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">inList</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">busyList</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="p">).</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 如果与s连续内存的低地址方向也是一个已分配的空闲的mspan，则合并s和before
</span><span class="c1"></span>	<span class="c1">// 两个mspan
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">before</span> <span class="o">:=</span> <span class="nf">spanOf</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="nx">before</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">before</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">_MSpanFree</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">startAddr</span> <span class="p">=</span> <span class="nx">before</span><span class="p">.</span><span class="nx">startAddr</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="o">+=</span> <span class="nx">before</span><span class="p">.</span><span class="nx">npages</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">npreleased</span> <span class="p">=</span> <span class="nx">before</span><span class="p">.</span><span class="nx">npreleased</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="o">|=</span> <span class="nx">before</span><span class="p">.</span><span class="nx">needzero</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">setSpan</span><span class="p">(</span><span class="nx">before</span><span class="p">.</span><span class="nf">base</span><span class="p">(),</span> <span class="nx">s</span><span class="p">)</span>

		<span class="c1">// 从空闲列表中移除before mspan
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">isLargeSpan</span><span class="p">(</span><span class="nx">before</span><span class="p">.</span><span class="nx">npages</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">freelarge</span><span class="p">.</span><span class="nf">removeSpan</span><span class="p">(</span><span class="nx">before</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nf">freeList</span><span class="p">(</span><span class="nx">before</span><span class="p">.</span><span class="nx">npages</span><span class="p">).</span><span class="nf">remove</span><span class="p">(</span><span class="nx">before</span><span class="p">)</span>
		<span class="p">}</span>
    <span class="c1">// 释放before mspan对象，归还到spanalloc固定对象分配器中
</span><span class="c1"></span>		<span class="nx">before</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">_MSpanDead</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">spanalloc</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">before</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="c1">// 与before一样
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">after</span> <span class="o">:=</span> <span class="nf">spanOf</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="o">*</span><span class="nx">pageSize</span><span class="p">);</span> <span class="nx">after</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">after</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">_MSpanFree</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="o">+=</span> <span class="nx">after</span><span class="p">.</span><span class="nx">npages</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">npreleased</span> <span class="o">+=</span> <span class="nx">after</span><span class="p">.</span><span class="nx">npreleased</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="o">|=</span> <span class="nx">after</span><span class="p">.</span><span class="nx">needzero</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">setSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span><span class="o">+</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="o">*</span><span class="nx">pageSize</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">isLargeSpan</span><span class="p">(</span><span class="nx">after</span><span class="p">.</span><span class="nx">npages</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">freelarge</span><span class="p">.</span><span class="nf">removeSpan</span><span class="p">(</span><span class="nx">after</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nf">freeList</span><span class="p">(</span><span class="nx">after</span><span class="p">.</span><span class="nx">npages</span><span class="p">).</span><span class="nf">remove</span><span class="p">(</span><span class="nx">after</span><span class="p">)</span>
		<span class="p">}</span>
    <span class="c1">// 释放after mspan对象，归还到spanalloc固定对象分配器中，固定对象分配器
</span><span class="c1"></span>		<span class="c1">// 要求传入的mspan状态必须为_MSpanDead
</span><span class="c1"></span>		<span class="nx">after</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">_MSpanDead</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">spanalloc</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">after</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="c1">// 将前后合并后的s放到空闲mspan列表中。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">isLargeSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 如果是大于1MB的mspan，则插入到树堆中
</span><span class="c1"></span>		<span class="nx">h</span><span class="p">.</span><span class="nx">freelarge</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 如果是小于1MB的mspan，则插入到指定page数量的mspan链表中
</span><span class="c1"></span>		<span class="nx">h</span><span class="p">.</span><span class="nf">freeList</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="p">).</span><span class="nf">insert</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在busy列表中查找使用中的mspan，时间复杂度为常数级。</p>
<p>alloc/alloc_m</p>
<p>alloc通过调用alloc_m方法实现mspan的分配，并对分配空间进行了必要的清零工作。</p>
<p>实际内存分配的过程在alloc_m中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// alloc
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">alloc</span><span class="p">(</span><span class="nx">npage</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">spanclass</span> <span class="nx">spanClass</span><span class="p">,</span> <span class="nx">large</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span><span class="o">*</span><span class="nx">mspan</span>

<span class="c1">// alloc_m
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">alloc_m</span><span class="p">(</span><span class="nx">npage</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">spanclass</span> <span class="nx">spanClass</span><span class="p">,</span> <span class="nx">large</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="c1">//...
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">//...
</span><span class="c1"></span>
	<span class="c1">// 向堆中申请持有npage数量的mspan
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">allocSpanLocked</span><span class="p">(</span><span class="nx">npage</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_inuse</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>

		<span class="c1">//...
</span><span class="c1"></span>		<span class="c1">// 初始化mspan成员
</span><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">_MSpanInUse</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">spanclass</span> <span class="p">=</span> <span class="nx">spanclass</span>
		<span class="k">if</span> <span class="nx">sizeclass</span> <span class="o">:=</span> <span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">();</span> <span class="nx">sizeclass</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="o">&lt;&lt;</span> <span class="nx">_PageShift</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divShift</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divMul</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divShift2</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">baseMask</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">sizeclass</span><span class="p">])</span>
			<span class="nx">m</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">class_to_divmagic</span><span class="p">[</span><span class="nx">sizeclass</span><span class="p">]</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divShift</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">shift</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divMul</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">mul</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divShift2</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">shift2</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">baseMask</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">baseMask</span>
		<span class="p">}</span>

		<span class="c1">// 记录大内存使用量，并将mspan添加到busy链表
</span><span class="c1"></span>		<span class="nx">h</span><span class="p">.</span><span class="nx">pagesInUse</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">npage</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">large</span> <span class="p">{</span>
			<span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_objects</span><span class="o">++</span>
			<span class="nx">mheap_</span><span class="p">.</span><span class="nx">largealloc</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">)</span>
			<span class="nx">mheap_</span><span class="p">.</span><span class="nx">nlargealloc</span><span class="o">++</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">npage</span><span class="o">&lt;&lt;</span><span class="nx">_PageShift</span><span class="p">))</span>
			<span class="c1">//
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="p">&lt;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">busy</span><span class="p">))</span> <span class="p">{</span>
				<span class="nx">h</span><span class="p">.</span><span class="nx">busy</span><span class="p">[</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="p">].</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">h</span><span class="p">.</span><span class="nx">busylarge</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">//...
</span><span class="c1"></span>	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>alloc_m调用allocSpanLocked分配了合适的mspan，完成了mspan的初始化，修改mspan状态为_MSpanInUse，并将mspan追加到mheap的busy链表中。</p>
<p>此外，由于allocSpanLocked/freeSpanLocked是对堆缓存的主要操作方法，所以在调用这两个方法的位置需要加锁，使用的是mheap.lock对象。</p>
<h2 id="分配内存newobject">分配内存:newobject</h2>
<p>堆上所有的对象都会通过调用 runtime.newobject 函数分配内存.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// implementation of new builtin
</span><span class="c1">// compiler (both frontend and SSA backend) knows the signature
</span><span class="c1">// of this function
</span><span class="c1">// 创建一个新的对象
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">typ</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nx">typ</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span><span class="c1">// true 内存清零
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中 _type 为 Go 类型的实现，通过其 size 属性能够获得该类型所需要的大小。</p>
<h3 id="mallocgc">mallocgc</h3>
<p>该函数会调用 runtime.mallocgc 分配指定大小的内存空间，这也是用户程序向堆上申请内存空间的必经函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Allocate an object of size bytes.
</span><span class="c1">// Small objects are allocated from the per-P cache&#39;s free lists.
</span><span class="c1">// Large objects (&gt; 32 kB) are allocated straight from the heap.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">gcphase</span> <span class="o">==</span> <span class="nx">_GCmarktermination</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;mallocgc called with gcphase == _GCmarktermination&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 创建大小为零的对象，例如空结构体
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zerobase</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">sbrk</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">align</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">typ</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// TODO(austin): This should be just
</span><span class="c1"></span>			<span class="c1">//   align = uintptr(typ.align)
</span><span class="c1"></span>			<span class="c1">// but that&#39;s only 4 on 32-bit platforms,
</span><span class="c1"></span>			<span class="c1">// even if there&#39;s a uint64 field in typ (see #599).
</span><span class="c1"></span>			<span class="c1">// This causes 64-bit atomic accesses to panic.
</span><span class="c1"></span>			<span class="c1">// Hence, we use stricter alignment that matches
</span><span class="c1"></span>			<span class="c1">// the normal allocator better.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">7</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">align</span> <span class="p">=</span> <span class="mi">8</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">align</span> <span class="p">=</span> <span class="mi">4</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">align</span> <span class="p">=</span> <span class="mi">2</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">align</span> <span class="p">=</span> <span class="mi">1</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nf">persistentalloc</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">align</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">other_sys</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// assistG is the G to charge for this allocation, or nil if
</span><span class="c1"></span>	<span class="c1">// GC is not currently active.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">assistG</span> <span class="o">*</span><span class="nx">g</span>
	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Charge the current user G for this allocation.
</span><span class="c1"></span>		<span class="nx">assistG</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">assistG</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">assistG</span> <span class="p">=</span> <span class="nx">assistG</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
		<span class="p">}</span>
		<span class="c1">// Charge the allocation against the G. We&#39;ll account
</span><span class="c1"></span>		<span class="c1">// for internal fragmentation at the end of mallocgc.
</span><span class="c1"></span>		<span class="nx">assistG</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">-=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">assistG</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// This G is in debt. Assist the GC to correct
</span><span class="c1"></span>			<span class="c1">// this before allocating. This must happen
</span><span class="c1"></span>			<span class="c1">// before disabling preemption.
</span><span class="c1"></span>			<span class="nf">gcAssistAlloc</span><span class="p">(</span><span class="nx">assistG</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Set mp.mallocing to keep from being preempted by GC.
</span><span class="c1"></span>	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;malloc deadlock&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span> <span class="o">==</span> <span class="nf">getg</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;malloc during signal&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="p">=</span> <span class="mi">1</span>

	<span class="nx">shouldhelpgc</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="nx">dataSize</span> <span class="o">:=</span> <span class="nx">size</span>
	<span class="kd">var</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span>
	<span class="c1">// 获取当前 g 所在 M 所绑定 P 的 mcache
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">c</span> <span class="p">=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">mcache</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// We will be called without a P while bootstrapping,
</span><span class="c1"></span>		<span class="c1">// in which case we use mcache0, which is set in mallocinit.
</span><span class="c1"></span>		<span class="c1">// mcache0 is cleared when bootstrapping is complete,
</span><span class="c1"></span>		<span class="c1">// by procresize.
</span><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="nx">mcache0</span>
		<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;malloc called with no P&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">span</span> <span class="o">*</span><span class="nx">mspan</span>
	<span class="kd">var</span> <span class="nx">x</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="nx">noscan</span> <span class="o">:=</span> <span class="nx">typ</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span>
    	<span class="c1">// size &lt;= 32KB
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">maxSmallSize</span> <span class="p">{</span>
		<span class="c1">// 小于16B的时候Tiny对象申请
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">noscan</span> <span class="o">&amp;&amp;</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">maxTinySize</span> <span class="p">{</span>
			<span class="c1">// tiny对象的内存分配
</span><span class="c1"></span>			<span class="c1">// 微对象分配
</span><span class="c1"></span>			<span class="c1">// Tiny allocator.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// Tiny allocator combines several tiny allocation requests
</span><span class="c1"></span>			<span class="c1">// into a single memory block. The resulting memory block
</span><span class="c1"></span>			<span class="c1">// is freed when all subobjects are unreachable. The subobjects
</span><span class="c1"></span>			<span class="c1">// must be noscan (don&#39;t have pointers), this ensures that
</span><span class="c1"></span>			<span class="c1">// the amount of potentially wasted memory is bounded.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// Size of the memory block used for combining (maxTinySize) is tunable.
</span><span class="c1"></span>			<span class="c1">// Current setting is 16 bytes, which relates to 2x worst case memory
</span><span class="c1"></span>			<span class="c1">// wastage (when all but one subobjects are unreachable).
</span><span class="c1"></span>			<span class="c1">// 8 bytes would result in no wastage at all, but provides less
</span><span class="c1"></span>			<span class="c1">// opportunities for combining.
</span><span class="c1"></span>			<span class="c1">// 32 bytes provides more opportunities for combining,
</span><span class="c1"></span>			<span class="c1">// but can lead to 4x worst case wastage.
</span><span class="c1"></span>			<span class="c1">// The best case winning is 8x regardless of block size.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// Objects obtained from tiny allocator must not be freed explicitly.
</span><span class="c1"></span>			<span class="c1">// So when an object will be freed explicitly, we ensure that
</span><span class="c1"></span>			<span class="c1">// its size &gt;= maxTinySize.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// SetFinalizer has a special case for objects potentially coming
</span><span class="c1"></span>			<span class="c1">// from tiny allocator, it such case it allows to set finalizers
</span><span class="c1"></span>			<span class="c1">// for an inner byte of a memory block.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// The main targets of tiny allocator are small strings and
</span><span class="c1"></span>			<span class="c1">// standalone escaping variables. On a json benchmark
</span><span class="c1"></span>			<span class="c1">// the allocator reduces number of allocations by ~12% and
</span><span class="c1"></span>			<span class="c1">// reduces heap size by ~20%.
</span><span class="c1"></span>			<span class="c1">//线程缓存 runtime.mcache 中的 tiny 字段指向了 maxTinySize 大小的块，如果当前块中还包含大小合适的空闲内存，运行时会通过基地址和偏移量获取并返回这块内存：
</span><span class="c1"></span>			<span class="nx">off</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span>
			<span class="c1">// Align tiny pointer for required (conservative) alignment.
</span><span class="c1"></span>			<span class="c1">// 将微型指针对齐以进行所需（保守）对齐。
</span><span class="c1"></span>			<span class="c1">// 对齐 调整偏移量
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">7</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">off</span> <span class="p">=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">off</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">off</span> <span class="p">=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">off</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">off</span> <span class="p">=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">off</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 若偏移量+size小于16B 则进行微对象分配
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">off</span><span class="o">+</span><span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">maxTinySize</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// 能直接被当前的内存块容纳
</span><span class="c1"></span>				<span class="c1">// The object fits into existing tiny block.
</span><span class="c1"></span>				<span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">+</span> <span class="nx">off</span><span class="p">)</span>
				<span class="c1">// 增加 offset
</span><span class="c1"></span>				<span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="p">=</span> <span class="nx">off</span> <span class="o">+</span> <span class="nx">size</span>
				<span class="c1">// 统计数量
</span><span class="c1"></span>				<span class="nx">c</span><span class="p">.</span><span class="nx">local_tinyallocs</span><span class="o">++</span>
				<span class="c1">// 完成分配，释放 m
</span><span class="c1"></span>				<span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="p">=</span> <span class="mi">0</span>
				<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
				<span class="k">return</span> <span class="nx">x</span>
			<span class="p">}</span>
			<span class="c1">// Allocate a new maxTinySize block.
</span><span class="c1"></span>			<span class="c1">//当内存块中不包含空闲的内存时，下面的这段代码会先从线程缓存找到跨度类对应的mspan runtime.mspan，调用 runtime.nextFreeFast 获取空闲的内存；当不存在空闲内存时，我们会调用 runtime.mcache.nextFree 从中心缓存或者页堆中获取可分配的内存块：
</span><span class="c1"></span>			<span class="c1">// 根据 tinySpan 的大小等级获得对应的 span 链表
</span><span class="c1"></span>			<span class="c1">// 从而用于分配一个新的 maxTinySize 块，与小对象分配的过程一致
</span><span class="c1"></span>			<span class="c1">// 当前tiny 块内存空间不足，向mache申请一个span
</span><span class="c1"></span>			<span class="nx">span</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">tinySpanClass</span><span class="p">]</span>
			<span class="c1">// 尝试从当前的span 获取内存，获取不到返回0,也就是我需要大小为16B的span
</span><span class="c1"></span>			<span class="nx">v</span> <span class="o">:=</span> <span class="nf">nextFreeFast</span><span class="p">(</span><span class="nx">span</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// 没有从 allocCache 获取到内存，netxtFree函数
</span><span class="c1"></span>				<span class="c1">// 尝试从 mcentral获取一个新的对应规格的span内存
</span><span class="c1"></span>				<span class="c1">// 替换原先内存空间不足的内存块，并分配内存
</span><span class="c1"></span>				<span class="nx">v</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">nextFree</span><span class="p">(</span><span class="nx">tinySpanClass</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
			<span class="c1">//将申请的内存块全置为 0
</span><span class="c1"></span>			<span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">x</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="c1">// See if we need to replace the existing tiny block with the new one
</span><span class="c1"></span>			<span class="c1">// based on amount of remaining free space.
</span><span class="c1"></span>			<span class="c1">// 看看我们是否需要根据剩余可用空间量替换现有的小块
</span><span class="c1"></span>			<span class="c1">// 如果申请的内存块用不完，则将剩下的给 tiny，用 tinyoffset 记录分配了多少。
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="o">||</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="p">=</span> <span class="nx">size</span>
			<span class="p">}</span>
			<span class="c1">//获取新的空闲内存块之后，上述代码会清空空闲内存中的数据、更新构成微对象分配器的几个字段 tiny 和 tinyoffset 并返回新的空闲内存。
</span><span class="c1"></span>			<span class="nx">size</span> <span class="p">=</span> <span class="nx">maxTinySize</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 小对象分配
</span><span class="c1"></span>			<span class="c1">//1. 确定分配对象的大小以及跨度类 runtime.spanClass；
</span><span class="c1"></span>			<span class="c1">// 这里将所有级别分为2类
</span><span class="c1"></span>			<span class="c1">// 1) size &lt;= 1024-8
</span><span class="c1"></span>			<span class="c1">// 首先会先计算sizeclass 大小，计算 sizeclass 是通过预先定义两个数组：size_to_class8 和 size_to_class128。小于 1024 - 8 = 1016 （smallSizeMax=1024），使用 size_to_class8，否则使用数组 size_to_class128。
</span><span class="c1"></span>			<span class="c1">// 举个例子，比如要分配 20 byte 的内存，那么sizeclass = size_to_calss8[(20+7)/8] = size_to_class8[3] = 3。然后通过class_to_size[3]获取到对应的值32，表示应该要分配32bytes的内存值。
</span><span class="c1"></span>			<span class="kd">var</span> <span class="nx">sizeclass</span> <span class="kt">uint8</span>
			<span class="k">if</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">smallSizeMax</span><span class="o">-</span><span class="mi">8</span> <span class="p">{</span>
				<span class="c1">// eg: size =700 (size+smallSizeDiv-1)/smallSizeDiv = (700+8-1/8)= 88  sizeclass=28 =&gt;704
</span><span class="c1"></span>				<span class="c1">// 获取size对应的sizeclass
</span><span class="c1"></span>				<span class="nx">sizeclass</span> <span class="p">=</span> <span class="nx">size_to_class8</span><span class="p">[</span><span class="nf">divRoundUp</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">smallSizeDiv</span><span class="p">)]</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="c1">// 2) size &gt;1024-8
</span><span class="c1"></span>				<span class="c1">// 获取size对应的sizeclass
</span><span class="c1"></span>				<span class="nx">sizeclass</span> <span class="p">=</span> <span class="nx">size_to_class128</span><span class="p">[</span><span class="nf">divRoundUp</span><span class="p">(</span><span class="nx">size</span><span class="o">-</span><span class="nx">smallSizeMax</span><span class="p">,</span> <span class="nx">largeSizeDiv</span><span class="p">)]</span>
			<span class="p">}</span>
			<span class="c1">//2. 从线程缓存、中心缓存或者堆中获取mspan并从mspan找到空闲的内存空间；
</span><span class="c1"></span>			<span class="c1">// sizeclass对应的size，也就是span的大小
</span><span class="c1"></span>			<span class="nx">size</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">sizeclass</span><span class="p">])</span>
			<span class="nx">spc</span> <span class="o">:=</span> <span class="nf">makeSpanClass</span><span class="p">(</span><span class="nx">sizeclass</span><span class="p">,</span> <span class="nx">noscan</span><span class="p">)</span>
			<span class="c1">// 找到对应的span
</span><span class="c1"></span>			<span class="nx">span</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>
			<span class="c1">//尝试从 allocCache 获取内存，获取不到返回0
</span><span class="c1"></span>			<span class="nx">v</span> <span class="o">:=</span> <span class="nf">nextFreeFast</span><span class="p">(</span><span class="nx">span</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">v</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">nextFree</span><span class="p">(</span><span class="nx">spc</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
			<span class="c1">//3. 调用 runtime.memclrNoHeapPointers 清空空闲内存中的所有数据；
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">needzero</span> <span class="o">&amp;&amp;</span> <span class="nx">span</span><span class="p">.</span><span class="nx">needzero</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">),</span> <span class="nx">size</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 大对象分配
</span><span class="c1"></span>		<span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">span</span> <span class="p">=</span> <span class="nf">largeAlloc</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">needzero</span><span class="p">,</span> <span class="nx">noscan</span><span class="p">)</span>
		<span class="p">})</span>
		<span class="nx">span</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="nx">span</span><span class="p">.</span><span class="nx">allocCount</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
		<span class="nx">size</span> <span class="p">=</span> <span class="nx">span</span><span class="p">.</span><span class="nx">elemsize</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">scanSize</span> <span class="kt">uintptr</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">noscan</span> <span class="p">{</span>
		<span class="c1">// If allocating a defer+arg block, now that we&#39;ve picked a malloc size
</span><span class="c1"></span>		<span class="c1">// large enough to hold everything, cut the &#34;asked for&#34; size down to
</span><span class="c1"></span>		<span class="c1">// just the defer header, so that the GC bitmap will record the arg block
</span><span class="c1"></span>		<span class="c1">// as containing nothing at all (as if it were unused space at the end of
</span><span class="c1"></span>		<span class="c1">// a malloc block caused by size rounding).
</span><span class="c1"></span>		<span class="c1">// The defer arg areas are scanned as part of scanstack.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">typ</span> <span class="o">==</span> <span class="nx">deferType</span> <span class="p">{</span>
			<span class="nx">dataSize</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">_defer</span><span class="p">{})</span>
		<span class="p">}</span>
		<span class="nf">heapBitsSetType</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">dataSize</span><span class="p">,</span> <span class="nx">typ</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">dataSize</span> <span class="p">&gt;</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">size</span> <span class="p">{</span>
			<span class="c1">// Array allocation. If there are any
</span><span class="c1"></span>			<span class="c1">// pointers, GC has to scan to the last
</span><span class="c1"></span>			<span class="c1">// element.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">scanSize</span> <span class="p">=</span> <span class="nx">dataSize</span> <span class="o">-</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">size</span> <span class="o">+</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">ptrdata</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">scanSize</span> <span class="p">=</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">ptrdata</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">local_scan</span> <span class="o">+=</span> <span class="nx">scanSize</span>
	<span class="p">}</span>

	<span class="c1">// Ensure that the stores above that initialize x to
</span><span class="c1"></span>	<span class="c1">// type-safe memory and set the heap bits occur before
</span><span class="c1"></span>	<span class="c1">// the caller can make x observable to the garbage
</span><span class="c1"></span>	<span class="c1">// collector. Otherwise, on weakly ordered machines,
</span><span class="c1"></span>	<span class="c1">// the garbage collector could follow a pointer to x,
</span><span class="c1"></span>	<span class="c1">// but see uninitialized memory or stale heap bits.
</span><span class="c1"></span>	<span class="nf">publicationBarrier</span><span class="p">()</span>

	<span class="c1">// Allocate black during GC.
</span><span class="c1"></span>	<span class="c1">// All slots hold nil so no scanning is needed.
</span><span class="c1"></span>	<span class="c1">// This may be racing with GC so do it atomically if there can be
</span><span class="c1"></span>	<span class="c1">// a race marking the bit.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="p">{</span>
		<span class="nf">gcmarknewobject</span><span class="p">(</span><span class="nx">span</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">scanSize</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">racemalloc</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
		<span class="nf">msanmalloc</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">allocfreetrace</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">tracealloc</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">typ</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">rate</span> <span class="o">:=</span> <span class="nx">MemProfileRate</span><span class="p">;</span> <span class="nx">rate</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">rate</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">next_sample</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">next_sample</span> <span class="o">-=</span> <span class="nx">size</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
			<span class="nf">profilealloc</span><span class="p">(</span><span class="nx">mp</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
			<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">assistG</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Account for internal fragmentation in the assist
</span><span class="c1"></span>		<span class="c1">// debt now that we know it.
</span><span class="c1"></span>		<span class="nx">assistG</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">-=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">size</span> <span class="o">-</span> <span class="nx">dataSize</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">shouldhelpgc</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">t</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">gcTrigger</span><span class="p">{</span><span class="nx">kind</span><span class="p">:</span> <span class="nx">gcTriggerHeap</span><span class="p">});</span> <span class="nx">t</span><span class="p">.</span><span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">gcStart</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码使用 runtime.gomcache 获取了线程缓存并通过类型判断类型是否为指针类型。我们从这个代码片段可以看出 runtime.mallocgc 会根据对象的大小执行不同的分配逻辑，在前面的章节也曾经介绍过运行时根据对象大小将它们分成微对象、小对象和大对象，这里会根据大小选择不同的分配逻辑：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123224434.png" alt=""></p>
<ul>
<li>微对象 (0, 16B) — 先使用微型分配器，再依次尝试线程缓存、中心缓存和堆分配内存；</li>
<li>小对象 [16B, 32KB] — 依次尝试使用线程缓存、中心缓存和堆分配内存；</li>
<li>大对象 (32KB, +∞) — 直接在堆上分配内存；</li>
</ul>
<p>在分配过程中，我们会发现需要持有 M 才可进行分配，这是因为分配不仅可能涉及 mcache，还需要将正在分配的 M 标记为 mallocing，用于记录当前 M 的分配状态。</p>
<h3 id="nextfreefast">nextFreeFast</h3>
<p>nextFreeFast 不涉及正式的分配过程，只是简单的寻找一个能够容纳当前微对象的 span</p>
<p>runtime.nextFreeFast 会利用mspan中的 allocCache 字段，快速找到该字段中为 1 的位数，我们在上面介绍过1表示该位对应的内存空间是空闲的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// nextFreeFast returns the next free object if one is quickly available.
</span><span class="c1">// Otherwise it returns 0.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">nextFreeFast</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">)</span> <span class="nx">gclinkptr</span> <span class="p">{</span>
	<span class="nx">theBit</span> <span class="o">:=</span> <span class="nx">sys</span><span class="p">.</span><span class="nf">Ctz64</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCache</span><span class="p">)</span> <span class="c1">// Is there a free object in the allocCache?
</span><span class="c1"></span>	<span class="c1">// 如果小于 64 则说明可以直接使用
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">theBit</span> <span class="p">&lt;</span> <span class="mi">64</span> <span class="p">{</span>
		<span class="nx">result</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">theBit</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">result</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
			<span class="nx">freeidx</span> <span class="o">:=</span> <span class="nx">result</span> <span class="o">+</span> <span class="mi">1</span>
			<span class="k">if</span> <span class="nx">freeidx</span><span class="o">%</span><span class="mi">64</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">freeidx</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
				<span class="k">return</span> <span class="mi">0</span>
			<span class="p">}</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">allocCache</span> <span class="o">&gt;&gt;=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">theBit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="nx">freeidx</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="o">++</span>
			<span class="k">return</span> <span class="nf">gclinkptr</span><span class="p">(</span><span class="nx">result</span><span class="o">*</span><span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>allocCache 字段用于计算 freeindex 上的 allocBits 缓存，allocCache 进行了移位使其最低位对应于 freeindex 位。allocCache 保存 allocBits 的补码，从而尾零计数可以直接使用它。</p>
<p>找到了空闲的对象后，我们就可以更新mspan的 allocCache、freeindex 等字段并返回该片内存了</p>
<h3 id="nextfree">nextFree</h3>
<p>如果我们没有找到空闲的内存，运行时会通过 runtime.mcache.nextFree 找到新的mspan：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// nextFree returns the next free object from the cached span if one is available.
</span><span class="c1">// Otherwise it refills the cache with a span with an available object and
</span><span class="c1">// returns that object along with a flag indicating that this was a heavy
</span><span class="c1">// weight allocation. If it is a heavy weight allocation the caller must
</span><span class="c1">// determine whether a new GC cycle needs to be started or if the GC is active
</span><span class="c1">// whether this goroutine needs to assist the GC.
</span><span class="c1">//
</span><span class="c1">// Must run in a non-preemptible context since otherwise the owner of
</span><span class="c1">// c could change.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span><span class="p">)</span> <span class="nf">nextFree</span><span class="p">(</span><span class="nx">spc</span> <span class="nx">spanClass</span><span class="p">)</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">gclinkptr</span><span class="p">,</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">,</span> <span class="nx">shouldhelpgc</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>
	<span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="c1">// 获得 s.freeindex 中或之后 s 中下一个空闲对象的索引
</span><span class="c1"></span>	<span class="nx">freeIndex</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">nextFreeIndex</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">freeIndex</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="c1">// span 已满，进行填充
</span><span class="c1"></span>		<span class="c1">// The span is full.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
			<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: s.allocCount=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">,</span> <span class="s">&#34;s.nelems=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;s.allocCount != s.nelems &amp;&amp; freeIndex == s.nelems&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 这个地方 mcache 向 mcentral 申请
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">refill</span><span class="p">(</span><span class="nx">spc</span><span class="p">)</span>
		<span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>
		<span class="c1">// mcache 向 mcentral 申请完之后，再次从 mcache 申请
</span><span class="c1"></span>		<span class="nx">freeIndex</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">nextFreeIndex</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">freeIndex</span> <span class="o">&gt;=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;freeIndex is not valid&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 这部分内容需要被 gc 接管，因此需要计算位置
</span><span class="c1"></span>	<span class="nx">v</span> <span class="p">=</span> <span class="nf">gclinkptr</span><span class="p">(</span><span class="nx">freeIndex</span><span class="o">*</span><span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="o">++</span><span class="c1">// 分配计数
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="s">&#34;s.allocCount=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">,</span> <span class="s">&#34;s.nelems=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;s.allocCount &gt; s.nelems&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在上述方法中，如果我们在线程缓存中没有找到可用的mspan，会通过前面介绍的 runtime.mcache.refill 使用中心缓存中的mspan替换已经不存在可用对象的结构体，该方法会调用新结构体的 runtime.mspan.nextFreeIndex 获取空闲的内存并返回。</p>
<h3 id="largealloc">largeAlloc</h3>
<p>runtime.largeAlloc 函数会计算分配该对象所需要的页数，它会按照 8KB 的倍数为对象在堆上申请内存：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">largeAlloc</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">noscan</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="c1">// print(&#34;largeAlloc size=&#34;, size, &#34;\n&#34;)
</span><span class="c1"></span>	<span class="c1">// 对象太大，溢出
</span><span class="c1"></span>	<span class="c1">// _PageSize=8k,也就是表明对象太大，溢出
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">size</span><span class="o">+</span><span class="nx">_PageSize</span> <span class="p">&lt;</span> <span class="nx">size</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// _PageShift==13，计算需要分配的页数
</span><span class="c1"></span>	<span class="c1">// 计算出对象所需的页数 对于大于32K的大内存分配都是整数页
</span><span class="c1"></span>	<span class="c1">// 根据分配的大小计算需要分配的页数
</span><span class="c1"></span>	<span class="nx">npages</span> <span class="o">:=</span> <span class="nx">size</span> <span class="o">&gt;&gt;</span> <span class="nx">_PageShift</span>
	<span class="c1">// 如果不是整数，多出来一些，需要加1
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="nx">_PageMask</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">npages</span><span class="o">++</span>
	<span class="p">}</span>

	<span class="c1">// Deduct credit for this span allocation and sweep if
</span><span class="c1"></span>	<span class="c1">// necessary. mHeap_Alloc will also sweep npages, so this only
</span><span class="c1"></span>	<span class="c1">// pays the debt down to npage pages.
</span><span class="c1"></span>	<span class="nf">deductSweepCredit</span><span class="p">(</span><span class="nx">npages</span><span class="o">*</span><span class="nx">_PageSize</span><span class="p">,</span> <span class="nx">npages</span><span class="p">)</span>

	<span class="nx">spc</span> <span class="o">:=</span> <span class="nf">makeSpanClass</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">noscan</span><span class="p">)</span>
	<span class="c1">// 从堆上分配
</span><span class="c1"></span>	<span class="c1">// 分配函数的具体实现，使用span-&gt;sizeclass=0
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span><span class="p">,</span> <span class="nx">spc</span><span class="p">,</span> <span class="nx">needzero</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">go115NewMCentralImpl</span> <span class="p">{</span>
		<span class="c1">// Put the large span in the mcentral swept list so that it&#39;s
</span><span class="c1"></span>		<span class="c1">// visible to the background sweeper.
</span><span class="c1"></span>		<span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">spc</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">fullSwept</span><span class="p">(</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">).</span><span class="nf">push</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">limit</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">size</span>
	<span class="c1">// bitmap 记录分配的span
</span><span class="c1"></span>	<span class="nf">heapBitsForAddr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()).</span><span class="nf">initSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>申请内存时会创建一个跨度类为 0 的 runtime.spanClass 并调用 runtime.mheap.alloc 分配一个管理对应内存的管理单元。</p>
<h3 id="memclrnoheappointers">memclrNoHeapPointers</h3>
<p>memclrNoHeapPointers 用于清理不包含堆指针的内存区块：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// memclrNoHeapPointers 清除从 ptr 开始的 n 个字节
</span><span class="c1">// 通常情况下你应该使用 typedmemclr，而 memclrNoHeapPointers 应该仅在调用方知道 *ptr
</span><span class="c1">// 不包含堆指针的情况下使用，因为 *ptr 只能是下面两种情况：
</span><span class="c1">// 1. *ptr 是初始化过的内存，且其类型不是指针。
</span><span class="c1">// 2. *ptr 是未初始化的内存（例如刚被新分配时使用的内存），则指包含 &#34;junk&#34; 垃圾内存
</span><span class="c1">// 见 memclr_*.s
</span><span class="c1">//
</span><span class="c1">//go:noescape
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">ptr</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">uintptr</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>清理过程是汇编实现的，就是一些内存的归零工作，简单浏览一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">TEXT</span> <span class="n">runtime</span>·<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">NOSPLIT</span><span class="p">,</span> <span class="o">$</span><span class="m">0-8</span>
	<span class="n">MOVL</span>	<span class="n">ptr</span><span class="m">+0</span><span class="p">(</span><span class="n">FP</span><span class="p">),</span> <span class="n">DI</span>
	<span class="n">MOVL</span>	<span class="n">n</span><span class="m">+4</span><span class="p">(</span><span class="n">FP</span><span class="p">),</span> <span class="n">BX</span>
	<span class="n">XORL</span>	<span class="n">AX</span><span class="p">,</span> <span class="n">AX</span>

	<span class="o">//</span> <span class="n">MOVOU</span> 好像总是比 <span class="n">REP</span> <span class="n">STOSL</span> 快
<span class="n">tail</span><span class="o">:</span>
	<span class="p">(</span><span class="kc">...</span><span class="p">)</span>

<span class="n">loop</span><span class="o">:</span>
	<span class="n">MOVOU</span>	<span class="n">X0</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="n">DI</span><span class="p">)</span>
	<span class="n">MOVOU</span>	<span class="n">X0</span><span class="p">,</span> <span class="m">16</span><span class="p">(</span><span class="n">DI</span><span class="p">)</span>
	<span class="n">MOVOU</span>	<span class="n">X0</span><span class="p">,</span> <span class="m">32</span><span class="p">(</span><span class="n">DI</span><span class="p">)</span>
	<span class="n">MOVOU</span>	<span class="n">X0</span><span class="p">,</span> <span class="m">48</span><span class="p">(</span><span class="n">DI</span><span class="p">)</span>
	<span class="n">MOVOU</span>	<span class="n">X0</span><span class="p">,</span> <span class="m">64</span><span class="p">(</span><span class="n">DI</span><span class="p">)</span>
	<span class="n">MOVOU</span>	<span class="n">X0</span><span class="p">,</span> <span class="m">80</span><span class="p">(</span><span class="n">DI</span><span class="p">)</span>
	<span class="n">MOVOU</span>	<span class="n">X0</span><span class="p">,</span> <span class="m">96</span><span class="p">(</span><span class="n">DI</span><span class="p">)</span>
	<span class="p">(</span><span class="kc">...</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="程序初始化mallocinit">程序初始化:mallocinit</h2>
<p>除去执行栈外，内存分配器是最先完成初始化的，我们先来看这个初始化的过程。 内存分配器的初始化除去一些例行的检查之外，就是对堆的初始化了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mallocinit</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 一些涉及内存分配器的常量的检查，包括
</span><span class="c1"></span>	<span class="c1">// heapArenaBitmapBytes, physPageSize 等等
</span><span class="c1"></span>	<span class="o">...</span>

	<span class="c1">// 初始化堆
</span><span class="c1"></span>	<span class="nx">mheap_</span><span class="p">.</span><span class="nf">init</span><span class="p">()</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span> <span class="p">=</span> <span class="nf">allocmcache</span><span class="p">()</span>

	<span class="c1">// 创建初始的 arena 增长 hint
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">==</span> <span class="mi">8</span> <span class="o">&amp;&amp;</span> <span class="nx">GOARCH</span> <span class="o">!=</span> <span class="s">&#34;wasm&#34;</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mh">0x7f</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="nx">p</span> <span class="kt">uintptr</span>
			<span class="k">switch</span> <span class="p">{</span>
			<span class="k">case</span> <span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;arm64&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;darwin&#34;</span><span class="p">:</span>
				<span class="nx">p</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">40</span> <span class="p">|</span> <span class="nx">uintptrMask</span><span class="o">&amp;</span><span class="p">(</span><span class="mh">0x0013</span><span class="o">&lt;&lt;</span><span class="mi">28</span><span class="p">)</span>
			<span class="p">(</span><span class="o">...</span><span class="p">)</span>
			<span class="k">default</span><span class="p">:</span>
				<span class="nx">p</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">40</span> <span class="p">|</span> <span class="nx">uintptrMask</span><span class="o">&amp;</span><span class="p">(</span><span class="mh">0x00c0</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">hint</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">arenaHint</span><span class="p">)(</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenaHintAlloc</span><span class="p">.</span><span class="nf">alloc</span><span class="p">())</span>
			<span class="nx">hint</span><span class="p">.</span><span class="nx">addr</span> <span class="p">=</span> <span class="nx">p</span>
			<span class="nx">hint</span><span class="p">.</span><span class="nx">next</span><span class="p">,</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenaHints</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenaHints</span><span class="p">,</span> <span class="nx">hint</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 32 位机器，不关心
</span><span class="c1"></span>		<span class="p">(</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这个过程中还包含对 mcache 初始化 allocmcache()，这个 mcache 会在 procresize 中将 mcache 转移到 P 的门下，而并非属于 M.</p>
<h2 id="小结">小结</h2>
<p>展示了所有结构的关系。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/mem-struct.png" alt=""></p>
<p>heap 最中间的灰色区域 arena 覆盖了 Go 程序的整个虚拟内存， 每个 arena 包括一段 bitmap 和一段指向连续 span 的指针； 每个 span 由一串连续的页组成；每个 arena 的起始位置通过 arenaHint 进行记录。</p>
<p>分配的顺序从右向左，代价也就越来越大。 小对象和微对象优先从白色区域 per-P 的 mcache 分配 span，这个过程不需要加锁（白色）； 若失败则会从 mheap 持有的 mcentral 加锁获得新的 span，这个过程需要加锁，但只是局部（灰色）； 若仍失败则会从右侧的 free 或 scav 进行分配，这个过程需要对整个 heap 进行加锁，代价最大（黑色）。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210812212040.png" alt=""></p>
<h2 id="参考">参考</h2>
<p><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/">7.1 内存分配器</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch07alloc/basic/">7.1 设计原则</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/266496735">Go内存管理三部曲[1]- 内存分配</a></p>
<p><a href="https://www.cnblogs.com/luozhiyun/p/14349331.html">详解Go中内存分配源码实现</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-11-23
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go%E6%BA%90%E7%A0%81/">Go源码</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go的信号处理源码剖析</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/linux%E7%9A%84%E7%BD%91%E7%BB%9Cio%E6%A8%A1%E5%9E%8B/">
            <span class="next-text nav-default">Linux的网络IO模型</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
