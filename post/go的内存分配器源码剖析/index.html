<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go的内存分配器源码剖析 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author"
  content="Forz" /><meta name="description" content="设计原理 分级分配 线程缓存分配（Thread-Caching Malloc，TCMalloc）是用于分配内存的机制，它比 glibc 中的 malloc 函数还要快很多." /><meta name="keywords"
  content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.68.1 with theme even" />


<link rel="canonical" href="/post/go%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link rel="stylesheet" href="/css/search.css" />


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go的内存分配器源码剖析" />
<meta property="og:description" content="设计原理 分级分配 线程缓存分配（Thread-Caching Malloc，TCMalloc）是用于分配内存的机制，它比 glibc 中的 malloc 函数还要快很多." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<meta property="article:published_time" content="2020-11-23T10:26:14+00:00" />
<meta property="article:modified_time" content="2020-11-23T10:26:14+00:00" />
<meta itemprop="name" content="Go的内存分配器源码剖析">
<meta itemprop="description" content="设计原理 分级分配 线程缓存分配（Thread-Caching Malloc，TCMalloc）是用于分配内存的机制，它比 glibc 中的 malloc 函数还要快很多.">
<meta itemprop="datePublished" content="2020-11-23T10:26:14&#43;00:00" />
<meta itemprop="dateModified" content="2020-11-23T10:26:14&#43;00:00" />
<meta itemprop="wordCount" content="24040">



<meta itemprop="keywords" content="Go源码," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go的内存分配器源码剖析"/>
<meta name="twitter:description" content="设计原理 分级分配 线程缓存分配（Thread-Caching Malloc，TCMalloc）是用于分配内存的机制，它比 glibc 中的 malloc 函数还要快很多."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="clearfix">
  <div class="logo-wrapper">
    <a href="/" class="logo">Forz Blog</a>
  </div>

  <nav class="site-navbar">
    <ul id="menu" class="menu">
      <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
    </ul>
  </nav>
</div>


<div class="search-container">
  <div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="Search for titles or URIs..."
        name="search" autocomplete="off" />
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path
            d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js"></script>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js"></script>
<script>
    var client = algoliasearch("IAR2EF5L65", "b4b9da2eba53aa6dabe4b8ac9e8676e1");
    var index = client.initIndex('forz.forzvina.com');
    autocomplete('#aa-search-input',
        { hint: false }, {
        source: autocomplete.sources.hits(index, { hitsPerPage: 8 }),
        displayKey: 'name',
        templates: {
            suggestion: function (suggestion) {
                var reg = /([A-Z]+)/ig
                var title = suggestion.uri.replace(reg, function (m) {
                    return m.toLowerCase()
                })
                return '<span class="search-item">' + '<a href="\/' + title + '">' +
                    suggestion._highlightResult.title.value + '</a></span>';
            }
        }
    });
</script>
</div>


    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go的内存分配器源码剖析</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-11-23 </span>
        <div class="post-category">
            <a href="/categories/go%E6%BA%90%E7%A0%81/"> Go源码 </a>
            </div>
          <span class="more-meta"> 约 24040 字 </span>
          <span class="more-meta"> 预计阅读 48 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#设计原理">设计原理</a>
      <ul>
        <li><a href="#分级分配">分级分配</a></li>
        <li><a href="#虚拟内存布局">虚拟内存布局</a></li>
        <li><a href="#系统级内存管理调用">系统级内存管理调用</a></li>
      </ul>
    </li>
    <li><a href="#组件">组件</a>
      <ul>
        <li><a href="#arena">Arena</a></li>
        <li><a href="#mspan">mspan</a></li>
        <li><a href="#mcache">mcache</a></li>
        <li><a href="#mcentral">mcentral</a></li>
        <li><a href="#mheap">mheap</a></li>
        <li><a href="#小结">小结</a></li>
      </ul>
    </li>
    <li><a href="#内存分配">内存分配</a>
      <ul>
        <li><a href="#微对象">微对象</a></li>
        <li><a href="#小对象">小对象</a></li>
        <li><a href="#大对象">大对象</a></li>
        <li><a href="#nextfreefast">nextFreeFast</a></li>
        <li><a href="#nextfree">nextFree</a></li>
        <li><a href="#memclrnoheappointers">memclrNoHeapPointers</a></li>
      </ul>
    </li>
    <li><a href="#程序初始化">程序初始化</a></li>
    <li><a href="#小结-1">小结</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="设计原理">设计原理</h2>
<h3 id="分级分配">分级分配</h3>
<p>线程缓存分配（Thread-Caching Malloc，TCMalloc）是用于分配内存的机制，它比 glibc 中的 malloc 函数还要快很多.Go 语言的内存分配器就借鉴了 TCMalloc 的设计实现高速的内存分配，它的核心理念是使用多级缓存将对象根据大小分类，并按照类别实施不同的分配策略。</p>
<h4 id="对象大小">对象大小</h4>
<p>Go 语言的内存分配器会根据申请分配的内存大小选择不同的处理逻辑，运行时根据对象的大小将对象分成微对象、小对象和大对象三种：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>微对象</td>
<td>(0, 16B)</td>
</tr>
<tr>
<td>小对象</td>
<td>[16B, 32KB]</td>
</tr>
<tr>
<td>大对象</td>
<td>(32KB, +∞)</td>
</tr>
</tbody>
</table>
<p>因为程序中的绝大多数对象的大小都在 32KB 以下，而申请的内存大小影响 Go 语言运行时分配内存的过程和开销，所以分别处理大对象和小对象有利于提高内存分配器的性能。</p>
<h4 id="多级缓存">多级缓存</h4>
<p>内存分配器不仅会区别对待大小不同的对象，还会将内存分成不同的级别分别管理，TCMalloc 和 Go 运行时分配器都会引入线程缓存（Thread Cache）、中心缓存（Central Cache）和页堆（Page Heap）三个组件分级管理内存：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123144212.png" alt=""></p>
<p>线程缓存属于每一个独立的线程，它能够满足线程上绝大多数的内存分配需求，因为不涉及多线程，所以也不需要使用互斥锁来保护内存，这能够减少锁竞争带来的性能损耗。当线程缓存不能满足需求时，就会使用中心缓存作为补充解决小对象的内存分配问题；在遇到 32KB 以上的对象时，内存分配器就会选择页堆直接分配大量的内存。</p>
<p>这种多层级的内存分配设计与计算机操作系统中的多级缓存也有些类似，因为多数的对象都是小对象，我们可以通过线程缓存和中心缓存提供足够的内存空间，发现资源不足时就从上一级组件中获取更多的内存资源。</p>
<h3 id="虚拟内存布局">虚拟内存布局</h3>
<p>这里会介绍 Go 语言堆区内存地址空间的设计以及演进过程，在 Go 语言 1.10 以前的版本，堆区的内存空间都是连续的；但是在 1.11 版本，Go 团队使用稀疏的堆内存空间替代了连续的内存，解决了连续内存带来的限制以及在特殊场景下可能出现的问题。</p>
<h4 id="线性内存">线性内存</h4>
<p>Go 语言程序的 1.10 版本在启动时会初始化整片虚拟内存区域，如下所示的三个区域 spans、bitmap 和 arena 分别预留了 512MB、16GB 以及 512GB 的内存空间，这些内存并不是真正存在的物理内存，而是虚拟内存：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123144624.png" alt=""></p>
<ul>
<li>spans 区域存储了指向mspan runtime.mspan 的指针，每个内存单元会管理几页的内存空间，每页大小为 8KB；</li>
<li>bitmap 用于标识 arena 区域中的那些地址保存了对象，位图中的每个字节都会表示堆区中的 32 字节是否包含空闲；</li>
<li>arena 区域是真正的堆区，运行时会将 8KB 看做一页，这些内存页中存储了所有在堆上初始化的对象；</li>
</ul>
<p>对于任意一个地址，我们都可以根据 arena 的基地址计算该地址所在的页数并通过 spans 数组获得管理该片内存的管理单元 runtime.mspan，spans 数组中多个连续的位置可能对应同一个 runtime.mspan。</p>
<p>Go 语言在垃圾回收时会根据指针的地址判断对象是否在堆中，并通过上一段中介绍的过程找到管理该对象的 runtime.mspan。这些都建立在堆区的内存是连续的这一假设上。这种设计虽然简单并且方便，但是在 C 和 Go 混合使用时会导致程序崩溃：</p>
<ol>
<li>分配的内存地址会发生冲突，导致堆的初始化和扩容失败；</li>
<li>没有被预留的大块内存可能会被分配给 C 语言的二进制，导致扩容后的堆不连续；</li>
</ol>
<p>线性的堆内存需要预留大块的内存空间，但是申请大块的内存空间而不使用是不切实际的，不预留内存空间却会在特殊场景下造成程序崩溃。虽然连续内存的实现比较简单，但是这些问题我们也没有办法忽略。</p>
<h4 id="稀疏内存">稀疏内存</h4>
<p>稀疏内存是 Go 语言在 1.11 中提出的方案，使用稀疏的内存布局不仅能移除堆大小的上限，还能解决 C 和 Go 混合使用时的地址空间冲突问题。不过因为基于稀疏内存的内存管理失去了内存的连续性这一假设，这也使内存管理变得更加复杂：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123145800.png" alt=""></p>
<p>如上图所示，运行时使用二维的 runtime.heapArena 数组管理所有的内存，每个单元都会管理 64MB 的内存空间：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">heapArena</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">bitmap</span> <span class="p">[</span><span class="nx">heapArenaBitmapBytes</span><span class="p">]</span><span class="kt">byte</span>
	<span class="nx">spans</span> <span class="p">[</span><span class="nx">pagesPerArena</span><span class="p">]</span><span class="o">*</span><span class="nx">mspan</span>
	<span class="nx">pageInUse</span> <span class="p">[</span><span class="nx">pagesPerArena</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span><span class="kt">uint8</span>
	<span class="nx">pageMarks</span> <span class="p">[</span><span class="nx">pagesPerArena</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span><span class="kt">uint8</span>
	<span class="nx">zeroedBase</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该结构体中的 bitmap 和 spans 与线性内存中的 bitmap 和 spans 区域一一对应，zeroedBase 字段指向了该结构体管理的内存的基地址。这种设计将原有的连续大内存切分成稀疏的小内存，而用于管理这些内存的元信息也被切分成了小块。</p>
<p>不同平台和架构的二维数组大小可能完全不同，如果我们的 Go 语言服务在 Linux 的 x86-64 架构上运行，二维数组的一维大小会是 1，而二维大小是 4,194,304，因为每一个指针占用 8 字节的内存空间，所以元信息的总大小为 32MB。由于每个 runtime.heapArena 都会管理 64MB 的内存，整个堆区最多可以管理 256TB 的内存，这比之前的 512GB 多好几个数量级。</p>
<p>Go 语言团队在 1.11 版本中通过以下几个提交将线性内存变成稀疏内存，移除了 512GB 的内存上限以及堆区内存连续性的假设：</p>
<p>由于内存的管理变得更加复杂，上述改动对垃圾回收稍有影响，大约会增加 1% 的垃圾回收开销，不过这也是我们为了解决已有问题必须付出的成本7。</p>
<h3 id="系统级内存管理调用">系统级内存管理调用</h3>
<p>因为所有的内存最终都是要从操作系统中申请的，所以 Go 语言的运行时构建了操作系统的内存管理抽象层，该抽象层将运行时管理的地址空间分成以下的四种状态8：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>内存没有被保留或者映射，是地址空间的默认状态</td>
</tr>
<tr>
<td>Reserved</td>
<td>运行时持有该地址空间，但是访问该内存会导致错误</td>
</tr>
<tr>
<td>Prepared</td>
<td>内存被保留，一般没有对应的物理内存访问该片内存的行为是未定义的可以快速转换到 Ready 状态</td>
</tr>
<tr>
<td>Ready</td>
<td>可以被安全访问</td>
</tr>
</tbody>
</table>
<p>每一个不同的操作系统都会包含一组特定的方法，这些方法可以让内存地址空间在不同的状态之间做出转换，我们可以通过下图了解不同状态之间的转换过程：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123150141.png" alt=""></p>
<p>运行时中包含多个操作系统对状态转换方法的实现，所有的实现都包含在以 mem_ 开头的文件中，本节将介绍 Linux 操作系统对上图中方法的实现：</p>
<ul>
<li>runtime.sysAlloc 会从操作系统中获取一大块可用的内存空间，可能为几百 KB 或者几 MB；</li>
<li>runtime.sysFree 会在程序发生内存不足（Out-of Memory，OOM）时调用并无条件地返回内存；</li>
<li>runtime.sysReserve 会保留操作系统中的一片内存区域，对这片内存的访问会触发异常；</li>
<li>runtime.sysMap 保证内存区域可以快速转换至准备就绪；</li>
<li>runtime.sysUsed 通知操作系统应用程序需要使用该内存区域，需要保证内存区域可以安全访问；</li>
<li>runtime.sysUnused 通知操作系统虚拟内存对应的物理内存已经不再需要了，它可以重用物理内存；</li>
<li>runtime.sysFault 将内存区域转换成保留状态，主要用于运行时的调试；</li>
</ul>
<p>其中 sysAlloc、sysReserve 和 sysMap 都是向操作系统申请内存的操作，他们均涉及关于内存分配的系统调用就是 mmap，区别在于：</p>
<ul>
<li>sysAlloc 是从操作系统上申请清零后的内存，调用参数是 _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE；</li>
<li>sysReserve 是从操作系统中保留内存的地址空间，并未直接分配内存，调用参数是 _PROT_NONE, _MAP_ANON|_MAP_PRIVATE，；</li>
<li>sysMap 则是用于通知操作系统使用先前已经保留好的空间，参数是 _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_FIXED|_MAP_PRIVATE。</li>
</ul>
<p>不过 sysAlloc 和 sysReserve 都是操作系统对齐的内存，但堆分配器可能使用更大的对齐方式，因此这部分获得的内存都需要额外进行一些重排的工作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// runtime/mem_linux.go
</span><span class="c1"></span>
<span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sysAlloc</span><span class="p">(</span><span class="nx">n</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">sysStat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">mmap</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">_PROT_READ</span><span class="p">|</span><span class="nx">_PROT_WRITE</span><span class="p">,</span> <span class="nx">_MAP_ANON</span><span class="p">|</span><span class="nx">_MAP_PRIVATE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">_EACCES</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: mmap: access denied\n&#34;</span><span class="p">)</span>
			<span class="nf">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">_EAGAIN</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: mmap: too much locked memory (check &#39;ulimit -l&#39;).\n&#34;</span><span class="p">)</span>
			<span class="nf">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">p</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">sysReserve</span><span class="p">(</span><span class="nx">v</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">mmap</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">_PROT_NONE</span><span class="p">,</span> <span class="nx">_MAP_ANON</span><span class="p">|</span><span class="nx">_MAP_PRIVATE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">p</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">sysMap</span><span class="p">(</span><span class="nx">v</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">sysStat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">mmap</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">_PROT_READ</span><span class="p">|</span><span class="nx">_PROT_WRITE</span><span class="p">,</span> <span class="nx">_MAP_ANON</span><span class="p">|</span><span class="nx">_MAP_FIXED</span><span class="p">|</span><span class="nx">_MAP_PRIVATE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">_ENOMEM</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: out of memory&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="nx">v</span> <span class="o">||</span> <span class="nx">err</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: cannot map pages in arena address space&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Linux 下内存分配调用有多个：</p>
<ul>
<li>brk: 可以让进程的堆指针增长，从逻辑上消耗一块虚拟地址空间</li>
<li>mmap: 可以让进程的虚拟地址空间切分出一块指定大小的虚拟地址空间，mmap 映射返回的地址也是从逻辑上被消耗的，需要通过 unmap 进行回收。</li>
</ul>
<p>熟悉 C 语言的读者应该知道 malloc，它只是 C 语言的标准库函数，本质上是通过上述两个系统调用完成， 当分配内存较小时调用 brk，反之则会调用 mmap。不过 64 位系统上的 Go 运行时并没有使用 brk，目的很明显， 是为了能够更加灵活的控制虚拟地址空间。</p>
<p>而对于 unmap 操作，它被封装在了 sysFree 中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sysFree</span><span class="p">(</span><span class="nx">v</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">sysStat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
	<span class="nf">munmap</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>sysUnused、sysUsed 是 madvice 的封装，我们知道 madvice 用于向操作系统通知某段内存区域是否被应用所使用。sysFault 用于将 sysAlloc 获得的内存区域标记为故障，只用于运行时调试。</p>
<p>最后我们来理一下这些系统级调用的关系：</p>
<ul>
<li>当开始保留内存地址时，调用 sysReserve；</li>
<li>当需要使用或不适用保留的内存区域时通知操作系统，调用 sysUnused、sysUsed；</li>
<li>正式使用保留的地址，使用 sysMap；</li>
<li>释放时使用 sysFree 以及调试时使用 sysFault；</li>
<li>非用户态的调试、堆外内存则使用 sysAlloc 直接向操作系统获得清零的内存。</li>
</ul>
<p>运行时使用 Linux 提供的 mmap、munmap 和 madvise 等系统调用实现了操作系统的内存管理抽象层，抹平了不同操作系统的差异，为运行时提供了更加方便的接口，除了 Linux 之外，运行时还实现了 BSD、Darwin、Plan9 以及 Windows 等平台上抽象层。</p>
<h2 id="组件">组件</h2>
<p>Go 的内存分配器主要包含以下几个核心组件：</p>
<ul>
<li>heapArena: 保留整个虚拟地址空间</li>
<li>mheap：分配的堆，在页大小为 8KB 的粒度上进行管理</li>
<li>mspan：是 mheap 上管理的一连串的页</li>
<li>mcentral：收集了给定大小等级的所有 span</li>
<li>mcache：为 per-P 的缓存。</li>
</ul>
<p>其中页是向操作系统申请内存的最小单位，目前设计为 8KB。</p>
<p>传统意义上的栈被 Go 的运行时霸占，不开放给用户态代码；而传统意义上的堆内存，又被 Go 运行时划分为了两个部分， 一个是 Go 运行时自身所需的堆内存，即堆外内存；另一部分则用于 Go 用户态代码所使用的堆内存，也叫做 Go 堆。 Go 堆负责了用户态对象的存放以及 goroutine 的执行栈。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123150846.png" alt=""></p>
<p>所有的 Go 语言程序都会在启动时初始化如上图所示的内存布局，每一个处理器都会被分配一个线程缓存 runtime.mcache 用于处理微对象和小对象的分配，它们会持有mspan runtime.mspan。</p>
<p>每个类型的mspan都会管理特定大小的对象，当mspan中不存在空闲对象时，它们会从 runtime.mheap 持有的 134 个中心缓存 runtime.mcentral 中获取新的内存单元，中心缓存属于全局的堆结构体 runtime.mheap，它会从操作系统中申请内存。</p>
<p>在 amd64 的 Linux 操作系统上，runtime.mheap 会持有 4,194,304 runtime.heapArena，每一个 runtime.heapArena 都会管理 64MB 的内存，单个 Go 语言程序的内存上限也就是 256TB。</p>
<h3 id="arena">Arena</h3>
<h4 id="heaparena">heapArena</h4>
<p>Go 堆被视为由多个 arena 组成，每个 arena 在 64 位机器上为 64MB，且起始地址与 arena 的大小对齐， 所有的 arena 覆盖了整个 Go 堆的地址空间。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">pageSize</span>             <span class="p">=</span> <span class="mi">8192</span>                       <span class="c1">// 8KB
</span><span class="c1"></span>	<span class="nx">heapArenaBytes</span>       <span class="p">=</span> <span class="mi">67108864</span>                   <span class="c1">// 64MB
</span><span class="c1"></span>	<span class="nx">heapArenaBitmapBytes</span> <span class="p">=</span> <span class="nx">heapArenaBytes</span> <span class="o">/</span> <span class="mi">32</span>        <span class="c1">// 2097152
</span><span class="c1"></span>	<span class="nx">pagesPerArena</span>        <span class="p">=</span> <span class="nx">heapArenaBytes</span> <span class="o">/</span> <span class="nx">pageSize</span>  <span class="c1">// 8192
</span><span class="c1"></span><span class="p">)</span>

<span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">heapArena</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">bitmap</span>     <span class="p">[</span><span class="nx">heapArenaBitmapBytes</span><span class="p">]</span><span class="kt">byte</span>
	<span class="nx">spans</span>      <span class="p">[</span><span class="nx">pagesPerArena</span><span class="p">]</span><span class="o">*</span><span class="nx">mspan</span>
	<span class="nx">pageInUse</span>  <span class="p">[</span><span class="nx">pagesPerArena</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span><span class="kt">uint8</span>
	<span class="nx">pageMarks</span>  <span class="p">[</span><span class="nx">pagesPerArena</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span><span class="kt">uint8</span>
	<span class="nx">zeroedBase</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="arenahint">arenaHint</h4>
<p>结构比较简单，是 arenaHint 链表的节点结构，保存了 arena 的起始地址、是否为最后一个 arena，以及下一个 arenaHint 指针。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">arenaHint</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">addr</span> <span class="kt">uintptr</span>
	<span class="nx">down</span> <span class="kt">bool</span>
	<span class="nx">next</span> <span class="o">*</span><span class="nx">arenaHint</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="mspan">mspan</h3>
<p>runtime.mspan 是 Go 语言内存管理的基本单元.</p>
<p>管理 arena 如此粒度的内存并不符合实践，相反，所有的堆对象都通过 span 按照预先设定好的 大小等级分别分配，小于 32KB 的小对象则分配在固定大小等级的 span 上，否则直接从 mheap 上进行分配。</p>
<p>mspan 是相同大小等级的 span 的双向链表的一个节点，每个节点还记录了自己的起始地址、 指向的 span 中页的数量。它要么位于</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span><span class="lnt">98
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:notinheap
</span><span class="c1">// 双向链表
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">mspan</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// 链表中的下一个 span，如果为空则为 nil
</span><span class="c1"></span>	<span class="nx">next</span> <span class="o">*</span><span class="nx">mspan</span>     <span class="c1">// next span in list, or nil if none
</span><span class="c1"></span>	<span class="c1">// 链表中的前一个 span，如果为空则为 nil
</span><span class="c1"></span>	<span class="nx">prev</span> <span class="o">*</span><span class="nx">mspan</span>     <span class="c1">// previous span in list, or nil if none
</span><span class="c1"></span>	<span class="nx">list</span> <span class="o">*</span><span class="nx">mSpanList</span> <span class="c1">// For debugging. TODO: Remove.
</span><span class="c1"></span>	<span class="c1">// startAddr 和 npages 确定该结构体管理的多个页所在的内存，每个页的大小都是 8KB；
</span><span class="c1"></span>	<span class="c1">// span 的第一个字节的地址，即 s.base()
</span><span class="c1"></span>	<span class="nx">startAddr</span> <span class="kt">uintptr</span> <span class="c1">// address of first byte of span aka s.base()
</span><span class="c1"></span>	<span class="c1">// 一个 span 中的 page 数量
</span><span class="c1"></span>	<span class="nx">npages</span>    <span class="kt">uintptr</span> <span class="c1">// number of pages in span
</span><span class="c1"></span>	<span class="c1">// mSpanManual span 的释放对象链表
</span><span class="c1"></span>	<span class="nx">manualFreeList</span> <span class="nx">gclinkptr</span> <span class="c1">// list of free objects in mSpanManual spans
</span><span class="c1"></span>
	<span class="c1">// freeindex is the slot index between 0 and nelems at which to begin scanning
</span><span class="c1"></span>	<span class="c1">// for the next free object in this span.
</span><span class="c1"></span>	<span class="c1">// Each allocation scans allocBits starting at freeindex until it encounters a 0
</span><span class="c1"></span>	<span class="c1">// indicating a free object. freeindex is then adjusted so that subsequent scans begin
</span><span class="c1"></span>	<span class="c1">// just past the newly discovered free object.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If freeindex == nelem, this span has no free objects.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// allocBits is a bitmap of objects in this span.
</span><span class="c1"></span>	<span class="c1">// If n &gt;= freeindex and allocBits[n/8] &amp; (1&lt;&lt;(n%8)) is 0
</span><span class="c1"></span>	<span class="c1">// then object n is free;
</span><span class="c1"></span>	<span class="c1">// otherwise, object n is allocated. Bits starting at nelem are
</span><span class="c1"></span>	<span class="c1">// undefined and should never be referenced.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Object n starts at address n*elemsize + (start &lt;&lt; pageShift).
</span><span class="c1"></span>	<span class="c1">//扫描页中空闲对象的初始索引
</span><span class="c1"></span>	<span class="nx">freeindex</span> <span class="kt">uintptr</span>
	<span class="c1">// TODO: Look up nelems from sizeclass and remove this field if it
</span><span class="c1"></span>	<span class="c1">// helps performance.
</span><span class="c1"></span>	<span class="c1">// span 中对象的数量
</span><span class="c1"></span>	<span class="nx">nelems</span> <span class="kt">uintptr</span> <span class="c1">// number of object in the span.
</span><span class="c1"></span>
	<span class="c1">// Cache of the allocBits at freeindex. allocCache is shifted
</span><span class="c1"></span>	<span class="c1">// such that the lowest bit corresponds to the bit freeindex.
</span><span class="c1"></span>	<span class="c1">// allocCache holds the complement of allocBits, thus allowing
</span><span class="c1"></span>	<span class="c1">// ctz (count trailing zero) to use it directly.
</span><span class="c1"></span>	<span class="c1">// allocCache may contain bits beyond s.nelems; the caller must ignore
</span><span class="c1"></span>	<span class="c1">// these.
</span><span class="c1"></span>	<span class="c1">//allocBits 的补码，可以用于快速查找内存中未被使用的内存；
</span><span class="c1"></span>	<span class="nx">allocCache</span> <span class="kt">uint64</span>

	<span class="c1">// allocBits and gcmarkBits hold pointers to a span&#39;s mark and
</span><span class="c1"></span>	<span class="c1">// allocation bits. The pointers are 8 byte aligned.
</span><span class="c1"></span>	<span class="c1">// There are three arenas where this data is held.
</span><span class="c1"></span>	<span class="c1">// free: Dirty arenas that are no longer accessed
</span><span class="c1"></span>	<span class="c1">//       and can be reused.
</span><span class="c1"></span>	<span class="c1">// next: Holds information to be used in the next GC cycle.
</span><span class="c1"></span>	<span class="c1">// current: Information being used during this GC cycle.
</span><span class="c1"></span>	<span class="c1">// previous: Information being used during the last GC cycle.
</span><span class="c1"></span>	<span class="c1">// A new GC cycle starts with the call to finishsweep_m.
</span><span class="c1"></span>	<span class="c1">// finishsweep_m moves the previous arena to the free arena,
</span><span class="c1"></span>	<span class="c1">// the current arena to the previous arena, and
</span><span class="c1"></span>	<span class="c1">// the next arena to the current arena.
</span><span class="c1"></span>	<span class="c1">// The next arena is populated as the spans request
</span><span class="c1"></span>	<span class="c1">// memory to hold gcmarkBits for the next GC cycle as well
</span><span class="c1"></span>	<span class="c1">// as allocBits for newly allocated spans.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The pointer arithmetic is done &#34;by hand&#34; instead of using
</span><span class="c1"></span>	<span class="c1">// arrays to avoid bounds checks along critical performance
</span><span class="c1"></span>	<span class="c1">// paths.
</span><span class="c1"></span>	<span class="c1">// The sweep will free the old allocBits and set allocBits to the
</span><span class="c1"></span>	<span class="c1">// gcmarkBits. The gcmarkBits are replaced with a fresh zeroed
</span><span class="c1"></span>	<span class="c1">// out memory.
</span><span class="c1"></span>	<span class="c1">//分别用于标记内存的占用和回收情况；
</span><span class="c1"></span>	<span class="nx">allocBits</span>  <span class="o">*</span><span class="nx">gcBits</span>
	<span class="nx">gcmarkBits</span> <span class="o">*</span><span class="nx">gcBits</span>

	<span class="c1">// sweep generation:
</span><span class="c1"></span>	<span class="c1">// if sweepgen == h-&gt;sweepgen - 2, the span needs sweeping
</span><span class="c1"></span>	<span class="c1">// if sweepgen == h-&gt;sweepgen - 1, the span is currently being swept
</span><span class="c1"></span>	<span class="c1">// if sweepgen == h-&gt;sweepgen, the span is swept and ready to use
</span><span class="c1"></span>	<span class="c1">// if sweepgen == h-&gt;sweepgen + 1, the span was cached before sweep began and is still cached, and needs sweeping
</span><span class="c1"></span>	<span class="c1">// if sweepgen == h-&gt;sweepgen + 3, the span was swept and then cached and is still cached
</span><span class="c1"></span>	<span class="c1">// h-&gt;sweepgen is incremented by 2 after every GC
</span><span class="c1"></span>
	<span class="nx">sweepgen</span>    <span class="kt">uint32</span>
	<span class="nx">divMul</span>      <span class="kt">uint16</span>        <span class="c1">// for divide by elemsize - divMagic.mul
</span><span class="c1"></span>	<span class="nx">baseMask</span>    <span class="kt">uint16</span>        <span class="c1">// if non-0, elemsize is a power of 2, &amp; this will get object allocation base
</span><span class="c1"></span>	<span class="c1">// 分配对象的数量
</span><span class="c1"></span>	<span class="nx">allocCount</span>  <span class="kt">uint16</span>        <span class="c1">// number of allocated objects
</span><span class="c1"></span>	<span class="c1">// 大小等级与 noscan (uint8)
</span><span class="c1"></span>	<span class="nx">spanclass</span>   <span class="nx">spanClass</span>     <span class="c1">// size class and noscan (uint8)
</span><span class="c1"></span>	<span class="c1">// mspaninuse 等等信息
</span><span class="c1"></span>	<span class="nx">state</span>       <span class="nx">mSpanStateBox</span> <span class="c1">// mSpanInUse etc; accessed atomically (get/set methods)
</span><span class="c1"></span>	<span class="nx">needzero</span>    <span class="kt">uint8</span>         <span class="c1">// needs to be zeroed before allocation
</span><span class="c1"></span>	<span class="nx">divShift</span>    <span class="kt">uint8</span>         <span class="c1">// for divide by elemsize - divMagic.shift
</span><span class="c1"></span>	<span class="nx">divShift2</span>   <span class="kt">uint8</span>         <span class="c1">// for divide by elemsize - divMagic.shift2
</span><span class="c1"></span>	<span class="nx">elemsize</span>    <span class="kt">uintptr</span>       <span class="c1">// computed from sizeclass or from npages
</span><span class="c1"></span>	<span class="nx">limit</span>       <span class="kt">uintptr</span>       <span class="c1">// end of data in span
</span><span class="c1"></span>	<span class="nx">speciallock</span> <span class="nx">mutex</span>         <span class="c1">// guards specials list
</span><span class="c1"></span>	<span class="nx">specials</span>    <span class="o">*</span><span class="nx">special</span>      <span class="c1">// linked list of special records sorted by offset.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>串联后的上述结构体会构成如下双向链表，运行时会使用 runtime.mSpanList 存储双向链表的头结点和尾节点并在线程缓存以及中心缓存中使用。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123151356.png" alt=""></p>
<p>因为相邻的管理单元会互相引用，所以我们可以从任意一个结构体访问双向链表中的其他节点。</p>
<h4 id="页和内存">页和内存</h4>
<p>每个 runtime.mspan 都管理 npages 个大小为 8KB 的页，这里的页不是操作系统中的内存页，它们是操作系统内存页的整数倍，该结构体会使用下面的这些字段来管理内存页的分配和回收：</p>
<ul>
<li>startAddr 和 npages — 确定该结构体管理的多个页所在的内存，每个页的大小都是 8KB；</li>
<li>freeindex — 扫描页中空闲对象的初始索引；</li>
<li>allocBits 和 gcmarkBits — 分别用于标记内存的占用和回收情况；</li>
<li>allocCache — allocBits 的补码，可以用于快速查找内存中未被使用的内存；</li>
</ul>
<p>runtime.mspan 会以两种不同的视角看待管理的内存，当结构体管理的内存不足时，运行时会以页为单位向堆申请内存：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123152539.png" alt=""></p>
<p>当用户程序或者线程向 runtime.mspan 申请内存时，该结构会使用 allocCache 字段以对象为单位在管理的内存中快速查找待分配的空间：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123152923.png" alt=""></p>
<p>如果我们能在内存中找到空闲的内存单元，就会直接返回，当内存中不包含空闲的内存时，上一级的组件 runtime.mcache 会为调用 runtime.mcache.refill 更新mspan以满足为更多对象分配内存的需求。</p>
<h4 id="状态">状态</h4>
<p>运行时会使用 runtime.mSpanStateBox 结构体存储mspan的状态 runtime.mSpanState：</p>
<p>该状态可能处于 mSpanDead、mSpanInUse、mSpanManual 和 mSpanFree 四种情况。当 runtime.mspan 在空闲堆中，它会处于 mSpanFree 状态；当 runtime.mspan 已经被分配时，它会处于 mSpanInUse、mSpanManual 状态，这些状态会在遵循以下规则发生转换：</p>
<ul>
<li>在垃圾回收的任意阶段，可能从 mSpanFree 转换到 mSpanInUse 和 mSpanManual；</li>
<li>在垃圾回收的清除阶段，可能从 mSpanInUse 和 mSpanManual 转换到 mSpanFree；</li>
<li>在垃圾回收的标记阶段，不能从 mSpanInUse 和 mSpanManual 转换到 mSpanFree；</li>
</ul>
<p>设置 runtime.mspan 结构体状态的读写操作必须是原子性的避免垃圾回收造成的线程竞争问题。</p>
<h4 id="跨度类">跨度类</h4>
<p>runtime.spanClass 是 runtime.mspan 结构体的跨度类，它决定了mspan中存储的对象大小和个数：</p>
<p>Go 语言的内存管理模块中一共包含 67 种跨度类，每一个跨度类都会存储特定大小的对象并且包含特定数量的页数以及对象，所有的数据都会被预选计算好并存储在 runtime.class_to_size 和 runtime.class_to_allocnpages 等变量中：</p>
<table>
<thead>
<tr>
<th>class</th>
<th>bytes/obj</th>
<th>bytes/span</th>
<th>objects</th>
<th>tail waste</th>
<th>max waste</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>8</td>
<td>8192</td>
<td>1024</td>
<td>0</td>
<td>87.50%</td>
</tr>
<tr>
<td>2</td>
<td>16</td>
<td>8192</td>
<td>512</td>
<td>0</td>
<td>43.75%</td>
</tr>
<tr>
<td>3</td>
<td>32</td>
<td>8192</td>
<td>256</td>
<td>0</td>
<td>46.88%</td>
</tr>
<tr>
<td>4</td>
<td>48</td>
<td>8192</td>
<td>170</td>
<td>32</td>
<td>31.52%</td>
</tr>
<tr>
<td>5</td>
<td>64</td>
<td>8192</td>
<td>128</td>
<td>0</td>
<td>23.44%</td>
</tr>
<tr>
<td>6</td>
<td>80</td>
<td>8192</td>
<td>102</td>
<td>32</td>
<td>19.07%</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>66</td>
<td>32768</td>
<td>32768</td>
<td>1</td>
<td>0</td>
<td>12.50%</td>
</tr>
</tbody>
</table>
<p>上表展示了对象大小从 8B 到 32KB，总共 66 种跨度类的大小、存储的对象数以及浪费的内存空间，以表中的第四个跨度类为例，跨度类为 4 的 runtime.mspan 中对象的大小上限为 48 字节、管理 1 个页、最多可以存储 170 个对象。因为内存需要按照页进行管理，所以在尾部会浪费 32 字节的内存，当页中存储的对象都是 33 字节时，最多会浪费 31.52% 的资源：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123154041.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123154327.png" alt=""></p>
<p>除了上述 66 个跨度类之外，运行时中还包含 ID 为 0 的特殊跨度类，它能够管理大于 32KB 的特殊对象，我们会在后面详细介绍大对象的分配过程，在这里就不展开说明了。</p>
<p>跨度类中除了存储类别的 ID 之外，它还会存储一个 noscan 标记位，该标记位表示对象是否包含指针，垃圾回收会对包含指针的 runtime.mspan 结构体进行扫描。我们可以通过下面的几个函数和方法了解 ID 和标记位的底层存储方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makeSpanClass</span><span class="p">(</span><span class="nx">sizeclass</span> <span class="kt">uint8</span><span class="p">,</span> <span class="nx">noscan</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">spanClass</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">spanClass</span><span class="p">(</span><span class="nx">sizeclass</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="p">|</span> <span class="nf">spanClass</span><span class="p">(</span><span class="nf">bool2int</span><span class="p">(</span><span class="nx">noscan</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sc</span> <span class="nx">spanClass</span><span class="p">)</span> <span class="nf">sizeclass</span><span class="p">()</span> <span class="kt">int8</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">int8</span><span class="p">(</span><span class="nx">sc</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sc</span> <span class="nx">spanClass</span><span class="p">)</span> <span class="nf">noscan</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">sc</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime.spanClass 是一个 uint8 类型的整数，它的前 7 位存储着跨度类的 ID，最后一位表示是否包含指针，该类型提供的两个方法能够帮我们快速获取对应的字段。</p>
<h3 id="mcache">mcache</h3>
<p>runtime.mcache 是 Go 语言中的线程缓存，它会与线程上的处理器一一绑定，是一个 per-P 的缓存,主要用来缓存用户程序申请的微小对象。每一个线程缓存都持有 67 * 2 个 runtime.mspan，这些mspan都存储在结构体的 alloc 字段中：</p>
<p>mcache 是一个 per-P 的缓存，因此每个线程都只访问自身的 mcache，因此也就不会出现 并发，也就省去了对其进行加锁步骤。</p>
<p>它是一个包含不同大小等级的 span 链表的数组，其中 mcache.alloc 的每一个数组元素 都是某一个特定大小的 mspan 的链表头指针。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123154712.png" alt=""></p>
<p>线程缓存在刚刚被初始化时是不包含 runtime.mspan 的，只有当用户程序申请内存时才会从上一级组件获取新的 runtime.mspan 满足内存分配的需求。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Per-thread (in Go, per-P) cache for small objects.
</span><span class="c1">// No locking needed because it is per-thread (per-P).
</span><span class="c1">//
</span><span class="c1">// mcaches are allocated from non-GC&#39;d memory, so any heap pointers
</span><span class="c1">// must be specially handled.
</span><span class="c1">//
</span><span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">mcache</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// The following members are accessed on every malloc,
</span><span class="c1"></span>	<span class="c1">// so they are grouped here for better caching.
</span><span class="c1"></span>	<span class="c1">// 分配这么多字节后触发堆样本
</span><span class="c1"></span>	<span class="nx">next_sample</span> <span class="kt">uintptr</span> <span class="c1">// trigger heap sample after allocating this many bytes
</span><span class="c1"></span>	<span class="c1">// 分配的可扫描堆的字节数
</span><span class="c1"></span>	<span class="nx">local_scan</span>  <span class="kt">uintptr</span> <span class="c1">// bytes of scannable heap allocated
</span><span class="c1"></span>
	<span class="c1">// Allocator cache for tiny objects w/o pointers.
</span><span class="c1"></span>	<span class="c1">// See &#34;Tiny allocator&#34; comment in malloc.go.
</span><span class="c1"></span>
	<span class="c1">// tiny points to the beginning of the current tiny block, or
</span><span class="c1"></span>	<span class="c1">// nil if there is no current tiny block.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// tiny is a heap pointer. Since mcache is in non-GC&#39;d memory,
</span><span class="c1"></span>	<span class="c1">// we handle it by clearing it in releaseAll during mark
</span><span class="c1"></span>	<span class="c1">// termination.
</span><span class="c1"></span>	<span class="c1">// 没有指针的微小对象的分配器缓存。
</span><span class="c1"></span>	<span class="c1">// tiny 指向当前 tiny 块的起始位置，或当没有 tiny 块时候为 nil
</span><span class="c1"></span>	<span class="c1">// tiny 是一个堆指针。由于 mcache 在非 GC 内存中，我们通过在
</span><span class="c1"></span>	<span class="c1">// mark termination 期间在 releaseAll 中清除它来处理它。
</span><span class="c1"></span>	<span class="nx">tiny</span>             <span class="kt">uintptr</span>
	<span class="c1">// tinyOffset 是下一个空闲内存所在的偏移量
</span><span class="c1"></span>	<span class="nx">tinyoffset</span>       <span class="kt">uintptr</span>
	<span class="c1">// 不计入其他统计的极小分配的数量
</span><span class="c1"></span>	<span class="nx">local_tinyallocs</span> <span class="kt">uintptr</span> <span class="c1">// number of tiny allocs not counted in other stats
</span><span class="c1"></span>
	<span class="c1">// The rest is not accessed on every malloc.
</span><span class="c1"></span>	<span class="c1">// 用来分配的 spans，由 spanClass 索引
</span><span class="c1"></span>	<span class="nx">alloc</span> <span class="p">[</span><span class="nx">numSpanClasses</span><span class="p">]</span><span class="o">*</span><span class="nx">mspan</span> <span class="c1">// spans to allocate from, indexed by spanClass
</span><span class="c1"></span>
	<span class="nx">stackcache</span> <span class="p">[</span><span class="nx">_NumStackOrders</span><span class="p">]</span><span class="nx">stackfreelist</span>
	<span class="c1">// 本地分配器统计，在 GC 期间被刷新
</span><span class="c1"></span>	<span class="c1">// Local allocator stats, flushed during GC.
</span><span class="c1"></span>	<span class="nx">local_largefree</span>  <span class="kt">uintptr</span>                  <span class="c1">// bytes freed for large objects (&gt;maxsmallsize)
</span><span class="c1"></span>	<span class="nx">local_nlargefree</span> <span class="kt">uintptr</span>                  <span class="c1">// number of frees for large objects (&gt;maxsmallsize)
</span><span class="c1"></span>	<span class="nx">local_nsmallfree</span> <span class="p">[</span><span class="nx">_NumSizeClasses</span><span class="p">]</span><span class="kt">uintptr</span> <span class="c1">// number of frees for small objects (&lt;=maxsmallsize)
</span><span class="c1"></span>
	<span class="c1">// flushGen indicates the sweepgen during which this mcache
</span><span class="c1"></span>	<span class="c1">// was last flushed. If flushGen != mheap_.sweepgen, the spans
</span><span class="c1"></span>	<span class="c1">// in this mcache are stale and need to the flushed so they
</span><span class="c1"></span>	<span class="c1">// can be swept. This is done in acquirep.
</span><span class="c1"></span>	<span class="nx">flushGen</span> <span class="kt">uint32</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当 mcache 中 span 的数量不够使用时，会向 mcentral 的 nonempty 列表中获得新的 span。</p>
<h4 id="微分配器">微分配器</h4>
<p>线程缓存中还包含几个用于分配微对象的字段，下面的这三个字段组成了微对象分配器，专门为 16 字节以下的对象申请和管理内存：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">mcache</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">tiny</span>             <span class="kt">uintptr</span>
	<span class="nx">tinyoffset</span>       <span class="kt">uintptr</span>
	<span class="nx">local_tinyallocs</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>微分配器只会用于分配非指针类型的内存，上述三个字段中 tiny 会指向堆中的一片内存，tinyOffset 是下一个空闲内存所在的偏移量，最后的 local_tinyallocs 会记录内存分配器中分配的对象个数。</p>
<h4 id="初始化">初始化</h4>
<p>运行时在初始化处理器时会调用 runtime.allocmcache 初始化线程缓存，该函数会在系统栈中使用 runtime.mheap 中的线程缓存分配器初始化新的 runtime.mcache 结构体：</p>
<p>由于 mheap 是全局的，因此在分配期必须对其进行加锁，而分配通过 fixAlloc 组件完成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 虚拟的MSpan，不包含任何对象。
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">emptymspan</span> <span class="nx">mspan</span>
<span class="kd">func</span> <span class="nf">allocmcache</span><span class="p">()</span> <span class="o">*</span><span class="nx">mcache</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">mcache</span><span class="p">)(</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">cachealloc</span><span class="p">.</span><span class="nf">alloc</span><span class="p">())</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">flushGen</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span> <span class="p">{</span>
		<span class="c1">// 暂时指向虚拟的 mspan 中
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">emptymspan</span>
	<span class="p">}</span>
	<span class="c1">// 返回下一个采样点，是服从泊松过程的随机数
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">next_sample</span> <span class="p">=</span> <span class="nf">nextSample</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>就像我们在上面提到的，初始化后的 runtime.mcache 中的所有 runtime.mspan 都是空的占位符 emptymspan。</p>
<p>由于运行时提供了采样过程堆分析的支持， 由于我们的采样的目标是平均每个 MemProfileRate 字节对分配进行采样， 显然，在整个时间线上的分配情况应该是完全随机分布的，这是一个泊松过程。 因此最佳的采样点应该是服从指数分布 exp(MemProfileRate) 的随机数，其中 MemProfileRate 为均值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">nextSample</span><span class="p">()</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;plan9&#34;</span> <span class="p">{</span>
		<span class="c1">// Plan 9 doesn&#39;t support floating point in note handler.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">g</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">();</span> <span class="nx">g</span> <span class="o">==</span> <span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">gsignal</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nf">nextSampleNoFP</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">fastexprand</span><span class="p">(</span><span class="nx">MemProfileRate</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>MemProfileRate 是一个公共变量，可以在用户态代码进行修改：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">MemProfileRate</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">512</span> <span class="o">*</span> <span class="mi">1024</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="替换">替换</h4>
<p>runtime.mcache.refill 方法会为线程缓存获取一个指定跨度类的mspan，被替换的单元不能包含空闲的内存空间，而获取的单元中需要至少包含一个空闲对象用于分配内存：</p>
<p>可以看到 refill 其实是从 mcentral 调用 cacheSpan 方法来获得 span：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span><span class="p">)</span> <span class="nf">refill</span><span class="p">(</span><span class="nx">spc</span> <span class="nx">spanClass</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>
	<span class="nx">s</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">spc</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">cacheSpan</span><span class="p">()</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如上述代码所示，该函数会从中心缓存中申请新的 runtime.mspan 存储到线程缓存中，这也是向线程缓存中插入mspan的唯一方法。</p>
<h4 id="释放">释放</h4>
<p>由于 mcache 从非 GC 内存上进行分配，因此出现的任何堆指针都必须进行特殊处理。 所以在释放前，需要调用 mcache.releaseAll 将堆指针进行处理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span><span class="p">)</span> <span class="nf">releaseAll</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span> <span class="p">{</span>
		<span class="nx">s</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">emptymspan</span> <span class="p">{</span>
			<span class="c1">// 将 span 归还
</span><span class="c1"></span>			<span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">uncacheSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">emptymspan</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 清空 tinyalloc 池.
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">freemcache</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// 归还 span
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">releaseAll</span><span class="p">()</span>
		<span class="c1">// 释放 stack
</span><span class="c1"></span>		<span class="nf">stackcache_clear</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>

		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="c1">// 记录局部统计
</span><span class="c1"></span>		<span class="nf">purgecachedstats</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
		<span class="c1">// 将 mcache 释放
</span><span class="c1"></span>		<span class="nx">mheap_</span><span class="p">.</span><span class="nx">cachealloc</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="p">})</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="per-p">per-P</h4>
<p>首先，mcache 是一个 per-P 的 mcache，我们很自然的疑问就是，这个 mcache 在 p/m 这两个结构体上都有成员：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">p</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">mcache</span>      <span class="o">*</span><span class="nf">mcache</span>
	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">m</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">mcache</span>      <span class="o">*</span><span class="nf">mcache</span>
	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>那么 mcache 是跟着谁跑的？结合调度器的知识不难发现，m 在执行时需要持有一个 p 才具备执行能力。 有利的证据是，当调用 runtime.procresize 时，初始化新的 P 时，mcache 是直接分配到 p 的； 回收 p 时，mcache 是直接从 p 上获取：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">procresize</span><span class="p">(</span><span class="nx">nprocs</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">p</span> <span class="p">{</span>
	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
	<span class="c1">// 初始化新的 P
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">nprocs</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">pp</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">(</span><span class="o">...</span><span class="p">)</span>
		<span class="c1">// 为 P 分配 cache 对象
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">mcache</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">old</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;missing mcache?&#34;</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nx">pp</span><span class="p">.</span><span class="nx">mcache</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="c1">// 创建 cache
</span><span class="c1"></span>				<span class="nx">pp</span><span class="p">.</span><span class="nx">mcache</span> <span class="p">=</span> <span class="nf">allocmcache</span><span class="p">()</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="p">(</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 释放未使用的 P
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">nprocs</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">old</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">(</span><span class="o">...</span><span class="p">)</span>
		<span class="c1">// 释放当前 P 绑定的 cache
</span><span class="c1"></span>		<span class="nf">freemcache</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">mcache</span><span class="p">)</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">mcache</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">(</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>因而我们可以明确：</p>
<ul>
<li>mcache 会被 P 持有，当 M 和 P 绑定时，M 同样会保留 mcache 的指针</li>
<li>mcache 直接向操作系统申请内存，且常驻运行时</li>
<li>P 通过 make 命令进行分配，会分配在 Go 堆上</li>
</ul>
<h3 id="mcentral">mcentral</h3>
<p>runtime.mcentral 是内存分配器的中心缓存，与线程缓存不同，访问中心缓存中的mspan需要使用互斥锁：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Central list of free objects of a given size.
</span><span class="c1">//
</span><span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">mcentral</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span>      <span class="nx">mutex</span>
	<span class="nx">spanclass</span> <span class="nx">spanClass</span>

	<span class="c1">// For !go115NewMCentralImpl.
</span><span class="c1"></span>	<span class="c1">// 不包含空闲对象的链表
</span><span class="c1"></span>	<span class="nx">nonempty</span> <span class="nx">mSpanList</span> <span class="c1">// list of spans with a free object, ie a nonempty free list
</span><span class="c1"></span>	<span class="c1">// 包含空闲对象的列表
</span><span class="c1"></span>	<span class="nx">empty</span>    <span class="nx">mSpanList</span> <span class="c1">// list of spans with no free objects (or cached in an mcache)
</span><span class="c1"></span>
	<span class="c1">// partial and full contain two mspan sets: one of swept in-use
</span><span class="c1"></span>	<span class="c1">// spans, and one of unswept in-use spans. These two trade
</span><span class="c1"></span>	<span class="c1">// roles on each GC cycle. The unswept set is drained either by
</span><span class="c1"></span>	<span class="c1">// allocation or by the background sweeper in every GC cycle,
</span><span class="c1"></span>	<span class="c1">// so only two roles are necessary.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// sweepgen is increased by 2 on each GC cycle, so the swept
</span><span class="c1"></span>	<span class="c1">// spans are in partial[sweepgen/2%2] and the unswept spans are in
</span><span class="c1"></span>	<span class="c1">// partial[1-sweepgen/2%2]. Sweeping pops spans from the
</span><span class="c1"></span>	<span class="c1">// unswept set and pushes spans that are still in-use on the
</span><span class="c1"></span>	<span class="c1">// swept set. Likewise, allocating an in-use span pushes it
</span><span class="c1"></span>	<span class="c1">// on the swept set.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Some parts of the sweeper can sweep arbitrary spans, and hence
</span><span class="c1"></span>	<span class="c1">// can&#39;t remove them from the unswept set, but will add the span
</span><span class="c1"></span>	<span class="c1">// to the appropriate swept list. As a result, the parts of the
</span><span class="c1"></span>	<span class="c1">// sweeper and mcentral that do consume from the unswept list may
</span><span class="c1"></span>	<span class="c1">// encounter swept spans, and these should be ignored.
</span><span class="c1"></span>	<span class="nx">partial</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="nx">spanSet</span> <span class="c1">// list of spans with a free object
</span><span class="c1"></span>	<span class="nx">full</span>    <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="nx">spanSet</span> <span class="c1">// list of spans with no free objects
</span><span class="c1"></span>
	<span class="c1">// nmalloc is the cumulative count of objects allocated from
</span><span class="c1"></span>	<span class="c1">// this mcentral, assuming all spans in mcaches are
</span><span class="c1"></span>	<span class="c1">// fully-allocated. Written atomically, read under STW.
</span><span class="c1"></span>	<span class="c1">// nmalloc 字段也记录了该结构体中分配的对象个数
</span><span class="c1"></span>	<span class="nx">nmalloc</span> <span class="kt">uint64</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>每一个中心缓存都会管理某个跨度类的mspan，它会同时持有两个 runtime.mSpanList，分别存储包含空闲对象的列表和不包含空闲对象的链表：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123210846.png" alt=""></p>
<p>当 mcentral 中 nonempty 列表中也没有可分配的 span 时，则会向 mheap 提出请求，从而获得 新的 span，并进而交给 mcache。</p>
<p>该结构体在初始化时，两个链表都不包含任何内存，程序运行时会扩容结构体持有的两个链表，nmalloc 字段也记录了该结构体中分配的对象个数。</p>
<h4 id="cachespan">cacheSpan</h4>
<p>线程缓存会通过中心缓存的 runtime.mcentral.cacheSpan 方法获取新的mspan，该方法的实现比较复杂，我们可以将其分成以下几个部分：</p>
<ol>
<li>从有空闲对象的 runtime.mspan 链表中查找可以使用的mspan；</li>
<li>从没有空闲对象的 runtime.mspan 链表中查找可以使用的mspan；</li>
<li>调用 runtime.mcentral.grow 从堆中申请新的mspan；</li>
<li>更新mspan的 allocCache 等字段帮助快速分配内存；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Allocate a span to use in an mcache.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nf">cacheSpan</span><span class="p">()</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">go115NewMCentralImpl</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">oldCacheSpan</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="o">...</span><span class="p">.</span>
<span class="p">}</span>
<span class="c1">// Allocate a span to use in an mcache.
</span><span class="c1">//
</span><span class="c1">// For !go115NewMCentralImpl.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nf">oldCacheSpan</span><span class="p">()</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="c1">// Deduct credit for this span allocation and sweep if necessary.
</span><span class="c1"></span>	<span class="nx">spanBytes</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_allocnpages</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()])</span> <span class="o">*</span> <span class="nx">_PageSize</span>
	<span class="nf">deductSweepCredit</span><span class="p">(</span><span class="nx">spanBytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">traceDone</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCSweepStart</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span>
<span class="nx">retry</span><span class="p">:</span>
	<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
	<span class="c1">//首先我们会在中心缓存的非空链表中查找可用的 runtime.mspan，根据 sweepgen 字段分别进行不同的处理：
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">nonempty</span><span class="p">.</span><span class="nx">first</span><span class="p">;</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">{</span>
		<span class="c1">//1. 当内存单元等待回收时，将其插入 empty 链表、调用 runtime.mspan.sweep 清理该单元并返回；
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="c1">// 等待回收
</span><span class="c1"></span>			<span class="nx">c</span><span class="p">.</span><span class="nx">nonempty</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">sweep</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
			<span class="k">goto</span> <span class="nx">havespan</span>
		<span class="c1">//2. 当内存单元正在被后台回收时，跳过该内存单元；
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span><span class="c1">// 正在回收
</span><span class="c1"></span>			<span class="c1">// the span is being swept by background sweeper, skip
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">//3. 当内存单元已经被回收时，将内存单元插入 empty 链表并返回；
</span><span class="c1"></span>		<span class="c1">// we have a nonempty span that does not require sweeping, allocate from it
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">nonempty</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="c1">// 已经回收
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="nx">havespan</span>
	<span class="p">}</span>
	<span class="c1">//如果中心缓存没有在 nonempty 中找到可用的mspan，就会继续遍历其持有的 empty 链表，我们在这里的处理与包含空闲对象的链表几乎完全相同。当找到需要回收的内存单元时，我们也会触发 runtime.mspan.sweep 进行清理，如果清理后的内存单元仍然不包含空闲对象，就会重新执行相应的代码：
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nx">first</span><span class="p">;</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// we have an empty span that requires sweeping,
</span><span class="c1"></span>			<span class="c1">// sweep it and see if we can free some space in it
</span><span class="c1"></span>			<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="c1">// swept spans are at the end of the list
</span><span class="c1"></span>			<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">sweep</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
			<span class="nx">freeIndex</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">nextFreeIndex</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">freeIndex</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
				<span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="nx">freeIndex</span>
				<span class="k">goto</span> <span class="nx">havespan</span>
			<span class="p">}</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="c1">// the span is still empty after sweep
</span><span class="c1"></span>			<span class="c1">// it is already in the empty list, so just retry
</span><span class="c1"></span>			<span class="k">goto</span> <span class="nx">retry</span><span class="c1">// 不包含空闲对象
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
			<span class="c1">// the span is being swept by background sweeper, skip
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// already swept empty span,
</span><span class="c1"></span>		<span class="c1">// all subsequent ones must also be either swept or in process of sweeping
</span><span class="c1"></span>		<span class="k">break</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCSweepDone</span><span class="p">()</span>
		<span class="nx">traceDone</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">//如果 runtime.mcentral 在两个链表中都没有找到可用的内存单元，它会调用 runtime.mcentral.grow 触发扩容操作从堆中申请新的内存：
</span><span class="c1"></span>	<span class="c1">// Replenish central list if empty.
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">grow</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// At this point s is a non-empty span, queued at the end of the empty list,
</span><span class="c1"></span>	<span class="c1">// c is unlocked.
</span><span class="c1"></span><span class="nx">havespan</span><span class="p">:</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">traceDone</span> <span class="p">{</span>
		<span class="nf">traceGCSweepDone</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="o">||</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;span has no free objects&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// Assume all objects from this span will be allocated in the
</span><span class="c1"></span>	<span class="c1">// mcache. If it gets uncached, we&#39;ll adjust this.
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">nmalloc</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
	<span class="nx">usedBytes</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">*</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">spanBytes</span><span class="p">)</span><span class="o">-</span><span class="nb">int64</span><span class="p">(</span><span class="nx">usedBytes</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="c1">// heap_live changed.
</span><span class="c1"></span>		<span class="nf">traceHeapAlloc</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// heap_live changed.
</span><span class="c1"></span>		<span class="nx">gcController</span><span class="p">.</span><span class="nf">revise</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">freeByteBase</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">whichByte</span> <span class="o">:=</span> <span class="nx">freeByteBase</span> <span class="o">/</span> <span class="mi">8</span>
	<span class="c1">// Init alloc bits cache.
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nf">refillAllocCache</span><span class="p">(</span><span class="nx">whichByte</span><span class="p">)</span>

	<span class="c1">// Adjust the allocCache so that s.freeindex corresponds to the low bit in
</span><span class="c1"></span>	<span class="c1">// s.allocCache.
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">allocCache</span> <span class="o">&gt;&gt;=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">%</span> <span class="mi">64</span>

	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>无论通过哪种方法获取到了内存单元，该方法的最后都会对内存单元的 allocBits 和 allocCache 等字段进行更新，让运行时在分配内存时能够快速找到空闲的对象。</p>
<h4 id="grow">grow</h4>
<p>中心缓存的扩容方法 runtime.mcentral.grow 会根据预先计算的 class_to_allocnpages 和 class_to_size 获取待分配的页数以及跨度类并调用 runtime.mheap.alloc 获取新的 runtime.mspan 结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// grow allocates a new empty span from the heap and initializes it for c&#39;s size class.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nf">grow</span><span class="p">()</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="nx">npages</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_allocnpages</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()])</span>
	<span class="nx">size</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()])</span>

	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="c1">// Use division by multiplication and shifts to quickly compute:
</span><span class="c1"></span>	<span class="c1">// n := (npages &lt;&lt; _PageShift) / size
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">npages</span> <span class="o">&lt;&lt;</span> <span class="nx">_PageShift</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">divShift</span> <span class="o">*</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">divMul</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">divShift2</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">limit</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">size</span><span class="o">*</span><span class="nx">n</span>
	<span class="nf">heapBitsForAddr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()).</span><span class="nf">initSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>获取了 runtime.mspan 之后，我们会在上述方法中初始化 limit 字段并清除该结构在堆上对应的位图。</p>
<h3 id="mheap">mheap</h3>
<p>runtime.mheap 是内存分配的核心结构体，Go 语言程序只会存在一个全局的结构，而堆上初始化的所有对象都由该结构体统一管理，该结构体中包含两组非常重要的字段，其中一个是全局的中心缓存列表 central，另一个是管理堆区内存区域的 arenas 以及相关字段。</p>
<p>页堆中包含一个长度为 134 的 runtime.mcentral 数组，其中 67 个为跨度类需要 scan 的中心缓存，另外的 67 个是 noscan 的中心缓存：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123220227.png" alt=""></p>
<p>我们在设计原理一节中已经介绍过 Go 语言所有的内存空间都由如下所示的二维矩阵 runtime.heapArena 管理的，这个二维矩阵管理的内存可以是不连续的：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123220444.png" alt=""></p>
<p>在除了 Windows 以外的 64 位操作系统中，每一个 runtime.heapArena 都会管理 64MB 的内存空间，如下所示的表格展示了不同平台上 Go 语言程序管理的堆区大小以及 runtime.heapArena 占用的内存空间：</p>
<table>
<thead>
<tr>
<th>平台</th>
<th>地址位数</th>
<th>Arena 大小</th>
<th>一维大小</th>
<th>二维大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>*/64-bit</td>
<td>48</td>
<td>64MB</td>
<td>1</td>
<td>4M (32MB)</td>
</tr>
<tr>
<td>windows/64-bit</td>
<td>48</td>
<td>4MB</td>
<td>64</td>
<td>1M (8MB)</td>
</tr>
<tr>
<td>*/32-bit</td>
<td>32</td>
<td>4MB</td>
<td>1</td>
<td>1024 (4KB)</td>
</tr>
<tr>
<td>*/mips(le)</td>
<td>31</td>
<td>4MB</td>
<td>1</td>
<td>512 (2KB)</td>
</tr>
</tbody>
</table>
<p>本节将介绍页堆的初始化、内存分配以及mspan分配的过程，这些过程能够帮助我们理解全局变量页堆与其他组件的关系以及它管理内存的方式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Main malloc heap.
</span><span class="c1">// The heap itself is the &#34;free&#34; and &#34;scav&#34; treaps,
</span><span class="c1">// but all the other global data is here too.
</span><span class="c1">//
</span><span class="c1">// mheap must not be heap-allocated because it contains mSpanLists,
</span><span class="c1">// which must not be heap-allocated.
</span><span class="c1">//
</span><span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">mheap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// lock must only be acquired on the system stack, otherwise a g
</span><span class="c1"></span>	<span class="c1">// could self-deadlock if its stack grows with the lock held.
</span><span class="c1"></span>	<span class="nx">lock</span>      <span class="nx">mutex</span>
	<span class="nx">pages</span>     <span class="nx">pageAlloc</span> <span class="c1">// page allocation data structure
</span><span class="c1"></span>	<span class="nx">sweepgen</span>  <span class="kt">uint32</span>    <span class="c1">// sweep generation, see comment in mspan; written during STW
</span><span class="c1"></span>	<span class="nx">sweepdone</span> <span class="kt">uint32</span>    <span class="c1">// all spans are swept
</span><span class="c1"></span>	<span class="nx">sweepers</span>  <span class="kt">uint32</span>    <span class="c1">// number of active sweepone calls
</span><span class="c1"></span>
	<span class="c1">// allspans is a slice of all mspans ever created. Each mspan
</span><span class="c1"></span>	<span class="c1">// appears exactly once.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The memory for allspans is manually managed and can be
</span><span class="c1"></span>	<span class="c1">// reallocated and move as the heap grows.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// In general, allspans is protected by mheap_.lock, which
</span><span class="c1"></span>	<span class="c1">// prevents concurrent access as well as freeing the backing
</span><span class="c1"></span>	<span class="c1">// store. Accesses during STW might not hold the lock, but
</span><span class="c1"></span>	<span class="c1">// must ensure that allocation cannot happen around the
</span><span class="c1"></span>	<span class="c1">// access (since that may free the backing store).
</span><span class="c1"></span>	<span class="c1">// 所有 spans 从这里分配出去
</span><span class="c1"></span>	<span class="nx">allspans</span> <span class="p">[]</span><span class="o">*</span><span class="nx">mspan</span> <span class="c1">// all spans out there
</span><span class="c1"></span>
	<span class="c1">// sweepSpans contains two mspan stacks: one of swept in-use
</span><span class="c1"></span>	<span class="c1">// spans, and one of unswept in-use spans. These two trade
</span><span class="c1"></span>	<span class="c1">// roles on each GC cycle. Since the sweepgen increases by 2
</span><span class="c1"></span>	<span class="c1">// on each cycle, this means the swept spans are in
</span><span class="c1"></span>	<span class="c1">// sweepSpans[sweepgen/2%2] and the unswept spans are in
</span><span class="c1"></span>	<span class="c1">// sweepSpans[1-sweepgen/2%2]. Sweeping pops spans from the
</span><span class="c1"></span>	<span class="c1">// unswept stack and pushes spans that are still in-use on the
</span><span class="c1"></span>	<span class="c1">// swept stack. Likewise, allocating an in-use span pushes it
</span><span class="c1"></span>	<span class="c1">// on the swept stack.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For !go115NewMCentralImpl.
</span><span class="c1"></span>	<span class="nx">sweepSpans</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="nx">gcSweepBuf</span>

	<span class="nx">_</span> <span class="kt">uint32</span> <span class="c1">// align uint64 fields on 32-bit for atomics
</span><span class="c1"></span>
	<span class="c1">// Proportional sweep
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// These parameters represent a linear function from heap_live
</span><span class="c1"></span>	<span class="c1">// to page sweep count. The proportional sweep system works to
</span><span class="c1"></span>	<span class="c1">// stay in the black by keeping the current page sweep count
</span><span class="c1"></span>	<span class="c1">// above this line at the current heap_live.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The line has slope sweepPagesPerByte and passes through a
</span><span class="c1"></span>	<span class="c1">// basis point at (sweepHeapLiveBasis, pagesSweptBasis). At
</span><span class="c1"></span>	<span class="c1">// any given time, the system is at (memstats.heap_live,
</span><span class="c1"></span>	<span class="c1">// pagesSwept) in this space.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// It&#39;s important that the line pass through a point we
</span><span class="c1"></span>	<span class="c1">// control rather than simply starting at a (0,0) origin
</span><span class="c1"></span>	<span class="c1">// because that lets us adjust sweep pacing at any time while
</span><span class="c1"></span>	<span class="c1">// accounting for current progress. If we could only adjust
</span><span class="c1"></span>	<span class="c1">// the slope, it would create a discontinuity in debt if any
</span><span class="c1"></span>	<span class="c1">// progress has already been made.
</span><span class="c1"></span>	<span class="nx">pagesInUse</span>         <span class="kt">uint64</span>  <span class="c1">// pages of spans in stats mSpanInUse; updated atomically
</span><span class="c1"></span>	<span class="nx">pagesSwept</span>         <span class="kt">uint64</span>  <span class="c1">// pages swept this cycle; updated atomically
</span><span class="c1"></span>	<span class="nx">pagesSweptBasis</span>    <span class="kt">uint64</span>  <span class="c1">// pagesSwept to use as the origin of the sweep ratio; updated atomically
</span><span class="c1"></span>	<span class="nx">sweepHeapLiveBasis</span> <span class="kt">uint64</span>  <span class="c1">// value of heap_live to use as the origin of sweep ratio; written with lock, read without
</span><span class="c1"></span>	<span class="nx">sweepPagesPerByte</span>  <span class="kt">float64</span> <span class="c1">// proportional sweep ratio; written with lock, read without
</span><span class="c1"></span>	<span class="c1">// TODO(austin): pagesInUse should be a uintptr, but the 386
</span><span class="c1"></span>	<span class="c1">// compiler can&#39;t 8-byte align fields.
</span><span class="c1"></span>
	<span class="c1">// scavengeGoal is the amount of total retained heap memory (measured by
</span><span class="c1"></span>	<span class="c1">// heapRetained) that the runtime will try to maintain by returning memory
</span><span class="c1"></span>	<span class="c1">// to the OS.
</span><span class="c1"></span>	<span class="nx">scavengeGoal</span> <span class="kt">uint64</span>

	<span class="c1">// Page reclaimer state
</span><span class="c1"></span>
	<span class="c1">// reclaimIndex is the page index in allArenas of next page to
</span><span class="c1"></span>	<span class="c1">// reclaim. Specifically, it refers to page (i %
</span><span class="c1"></span>	<span class="c1">// pagesPerArena) of arena allArenas[i / pagesPerArena].
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If this is &gt;= 1&lt;&lt;63, the page reclaimer is done scanning
</span><span class="c1"></span>	<span class="c1">// the page marks.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This is accessed atomically.
</span><span class="c1"></span>	<span class="nx">reclaimIndex</span> <span class="kt">uint64</span>
	<span class="c1">// reclaimCredit is spare credit for extra pages swept. Since
</span><span class="c1"></span>	<span class="c1">// the page reclaimer works in large chunks, it may reclaim
</span><span class="c1"></span>	<span class="c1">// more than requested. Any spare pages released go to this
</span><span class="c1"></span>	<span class="c1">// credit pool.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This is accessed atomically.
</span><span class="c1"></span>	<span class="nx">reclaimCredit</span> <span class="kt">uintptr</span>

	<span class="c1">// Malloc stats.
</span><span class="c1"></span>	<span class="nx">largealloc</span>  <span class="kt">uint64</span>                  <span class="c1">// bytes allocated for large objects
</span><span class="c1"></span>	<span class="nx">nlargealloc</span> <span class="kt">uint64</span>                  <span class="c1">// number of large object allocations
</span><span class="c1"></span>	<span class="nx">largefree</span>   <span class="kt">uint64</span>                  <span class="c1">// bytes freed for large objects (&gt;maxsmallsize)
</span><span class="c1"></span>	<span class="nx">nlargefree</span>  <span class="kt">uint64</span>                  <span class="c1">// number of frees for large objects (&gt;maxsmallsize)
</span><span class="c1"></span>	<span class="nx">nsmallfree</span>  <span class="p">[</span><span class="nx">_NumSizeClasses</span><span class="p">]</span><span class="kt">uint64</span> <span class="c1">// number of frees for small objects (&lt;=maxsmallsize)
</span><span class="c1"></span>
	<span class="c1">// arenas is the heap arena map. It points to the metadata for
</span><span class="c1"></span>	<span class="c1">// the heap for every arena frame of the entire usable virtual
</span><span class="c1"></span>	<span class="c1">// address space.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Use arenaIndex to compute indexes into this array.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For regions of the address space that are not backed by the
</span><span class="c1"></span>	<span class="c1">// Go heap, the arena map contains nil.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Modifications are protected by mheap_.lock. Reads can be
</span><span class="c1"></span>	<span class="c1">// performed without locking; however, a given entry can
</span><span class="c1"></span>	<span class="c1">// transition from nil to non-nil at any time when the lock
</span><span class="c1"></span>	<span class="c1">// isn&#39;t held. (Entries never transitions back to nil.)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// In general, this is a two-level mapping consisting of an L1
</span><span class="c1"></span>	<span class="c1">// map and possibly many L2 maps. This saves space when there
</span><span class="c1"></span>	<span class="c1">// are a huge number of arena frames. However, on many
</span><span class="c1"></span>	<span class="c1">// platforms (even 64-bit), arenaL1Bits is 0, making this
</span><span class="c1"></span>	<span class="c1">// effectively a single-level map. In this case, arenas[0]
</span><span class="c1"></span>	<span class="c1">// will never be nil.
</span><span class="c1"></span>	<span class="nx">arenas</span> <span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">arenaL1Bits</span><span class="p">]</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">arenaL2Bits</span><span class="p">]</span><span class="o">*</span><span class="nx">heapArena</span>

	<span class="c1">// heapArenaAlloc is pre-reserved space for allocating heapArena
</span><span class="c1"></span>	<span class="c1">// objects. This is only used on 32-bit, where we pre-reserve
</span><span class="c1"></span>	<span class="c1">// this space to avoid interleaving it with the heap itself.
</span><span class="c1"></span>	<span class="nx">heapArenaAlloc</span> <span class="nx">linearAlloc</span>

	<span class="c1">// arenaHints is a list of addresses at which to attempt to
</span><span class="c1"></span>	<span class="c1">// add more heap arenas. This is initially populated with a
</span><span class="c1"></span>	<span class="c1">// set of general hint addresses, and grown with the bounds of
</span><span class="c1"></span>	<span class="c1">// actual heap arena ranges.
</span><span class="c1"></span>	<span class="nx">arenaHints</span> <span class="o">*</span><span class="nx">arenaHint</span>

	<span class="c1">// arena is a pre-reserved space for allocating heap arenas
</span><span class="c1"></span>	<span class="c1">// (the actual arenas). This is only used on 32-bit.
</span><span class="c1"></span>	<span class="nx">arena</span> <span class="nx">linearAlloc</span>

	<span class="c1">// allArenas is the arenaIndex of every mapped arena. This can
</span><span class="c1"></span>	<span class="c1">// be used to iterate through the address space.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Access is protected by mheap_.lock. However, since this is
</span><span class="c1"></span>	<span class="c1">// append-only and old backing arrays are never freed, it is
</span><span class="c1"></span>	<span class="c1">// safe to acquire mheap_.lock, copy the slice header, and
</span><span class="c1"></span>	<span class="c1">// then release mheap_.lock.
</span><span class="c1"></span>	<span class="nx">allArenas</span> <span class="p">[]</span><span class="nx">arenaIdx</span>

	<span class="c1">// sweepArenas is a snapshot of allArenas taken at the
</span><span class="c1"></span>	<span class="c1">// beginning of the sweep cycle. This can be read safely by
</span><span class="c1"></span>	<span class="c1">// simply blocking GC (by disabling preemption).
</span><span class="c1"></span>	<span class="nx">sweepArenas</span> <span class="p">[]</span><span class="nx">arenaIdx</span>

	<span class="c1">// markArenas is a snapshot of allArenas taken at the beginning
</span><span class="c1"></span>	<span class="c1">// of the mark cycle. Because allArenas is append-only, neither
</span><span class="c1"></span>	<span class="c1">// this slice nor its contents will change during the mark, so
</span><span class="c1"></span>	<span class="c1">// it can be read safely.
</span><span class="c1"></span>	<span class="nx">markArenas</span> <span class="p">[]</span><span class="nx">arenaIdx</span>

	<span class="c1">// curArena is the arena that the heap is currently growing
</span><span class="c1"></span>	<span class="c1">// into. This should always be physPageSize-aligned.
</span><span class="c1"></span>	<span class="nx">curArena</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">base</span><span class="p">,</span> <span class="nx">end</span> <span class="kt">uintptr</span>
	<span class="p">}</span>

	<span class="c1">// _ uint32 // ensure 64-bit alignment of central
</span><span class="c1"></span>
	<span class="c1">// central free lists for small size classes.
</span><span class="c1"></span>	<span class="c1">// the padding makes sure that the mcentrals are
</span><span class="c1"></span>	<span class="c1">// spaced CacheLinePadSize bytes apart, so that each mcentral.lock
</span><span class="c1"></span>	<span class="c1">// gets its own cache line.
</span><span class="c1"></span>	<span class="c1">// central is indexed by spanClass.
</span><span class="c1"></span>	<span class="nx">central</span> <span class="p">[</span><span class="nx">numSpanClasses</span><span class="p">]</span><span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">mcentral</span> <span class="nx">mcentral</span>
		<span class="nx">pad</span>      <span class="p">[</span><span class="nx">cpu</span><span class="p">.</span><span class="nx">CacheLinePadSize</span> <span class="o">-</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">mcentral</span><span class="p">{})</span><span class="o">%</span><span class="nx">cpu</span><span class="p">.</span><span class="nx">CacheLinePadSize</span><span class="p">]</span><span class="kt">byte</span>
	<span class="p">}</span>
	<span class="c1">// span* 分配器
</span><span class="c1"></span>	<span class="nx">spanalloc</span>             <span class="nx">fixalloc</span> <span class="c1">// allocator for span*
</span><span class="c1"></span>	<span class="c1">// mcache* 分配器
</span><span class="c1"></span>	<span class="nx">cachealloc</span>            <span class="nx">fixalloc</span> <span class="c1">// allocator for mcache*
</span><span class="c1"></span>	<span class="c1">// specialfinalizer* 分配器
</span><span class="c1"></span>	<span class="nx">specialfinalizeralloc</span> <span class="nx">fixalloc</span> <span class="c1">// allocator for specialfinalizer*
</span><span class="c1"></span>	<span class="c1">// specialprofile* 分配器
</span><span class="c1"></span>	<span class="nx">specialprofilealloc</span>   <span class="nx">fixalloc</span> <span class="c1">// allocator for specialprofile*
</span><span class="c1"></span>	<span class="c1">// 特殊记录分配器的锁
</span><span class="c1"></span>	<span class="nx">speciallock</span>           <span class="nx">mutex</span>    <span class="c1">// lock for special record allocators.
</span><span class="c1"></span>	<span class="c1">// arenaHints 分配器
</span><span class="c1"></span>	<span class="nx">arenaHintAlloc</span>        <span class="nx">fixalloc</span> <span class="c1">// allocator for arenaHints
</span><span class="c1"></span>
	<span class="nx">unused</span> <span class="o">*</span><span class="nx">specialfinalizer</span> <span class="c1">// never set, just here to force the specialfinalizer type into DWARF
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="init">init</h4>
<p>堆区的初始化会使用 runtime.mheap.init 方法，我们能看到该方法初始化了非常多的结构体和字段，不过其中初始化的两类变量比较重要：</p>
<ol>
<li>spanalloc、cachealloc 以及 arenaHintAlloc 等 runtime.fixalloc 类型的空闲链表分配器；</li>
<li>central 切片中 runtime.mcentral 类型的中心缓存；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Initialize the heap.
</span><span class="c1">// 堆初始化
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 初始化堆中各个组件的分配器
</span><span class="c1"></span>	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankMheap</span><span class="p">)</span>
	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">spineLock</span><span class="p">,</span> <span class="nx">lockRankSpine</span><span class="p">)</span>
	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">spineLock</span><span class="p">,</span> <span class="nx">lockRankSpine</span><span class="p">)</span>
	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">speciallock</span><span class="p">,</span> <span class="nx">lockRankMheapSpecial</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">.</span><span class="nx">spanalloc</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">mspan</span><span class="p">{}),</span> <span class="nx">recordspan</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">mspan_sys</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">cachealloc</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">mcache</span><span class="p">{}),</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">mcache_sys</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">specialfinalizeralloc</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">specialfinalizer</span><span class="p">{}),</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">other_sys</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">specialprofilealloc</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">specialprofile</span><span class="p">{}),</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">other_sys</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">arenaHintAlloc</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">arenaHint</span><span class="p">{}),</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">other_sys</span><span class="p">)</span>

	<span class="c1">// Don&#39;t zero mspan allocations. Background sweeping can
</span><span class="c1"></span>	<span class="c1">// inspect a span concurrently with allocating it, so it&#39;s
</span><span class="c1"></span>	<span class="c1">// important that the span&#39;s sweepgen survive across freeing
</span><span class="c1"></span>	<span class="c1">// and re-allocating a span to prevent background sweeping
</span><span class="c1"></span>	<span class="c1">// from improperly cas&#39;ing it from 0.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This is safe because mspan contains no heap pointers.
</span><span class="c1"></span>	<span class="c1">// 不对 mspan 的分配清零，后台扫描可以通过分配它来并发的检查一个 span
</span><span class="c1"></span>	<span class="c1">// 因此 span 的 sweepgen 在释放和重新分配时候能存活，从而可以防止后台扫描
</span><span class="c1"></span>	<span class="c1">// 不正确的将其从 0 进行 CAS。
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 因为 mspan 不包含堆指针，因此它是安全的
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">spanalloc</span><span class="p">.</span><span class="nx">zero</span> <span class="p">=</span> <span class="kc">false</span>

	<span class="c1">// h-&gt;mapcache needs no init
</span><span class="c1"></span>	<span class="c1">// h-&gt;mapcache 不需要初始化
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">h</span><span class="p">.</span><span class="nx">central</span> <span class="p">{</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nf">spanClass</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="nx">h</span><span class="p">.</span><span class="nx">pages</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_sys</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>堆中初始化的多个空闲链表分配器与我们在设计原理一节中提到的分配器没有太多区别，当我们调用 runtime.fixalloc.init 初始化分配器时，需要传入待初始化的结构体大小等信息，这会帮助分配器分割待分配的内存，该分配器提供了以下两个用于分配和释放内存的方法：</p>
<ul>
<li>runtime.fixalloc.alloc — 获取下一个空闲的内存空间；</li>
<li>runtime.fixalloc.free — 释放指针指向的内存空间；</li>
</ul>
<p>除了这些空闲链表分配器之外，我们还会在该方法中初始化所有的中心缓存，这些中心缓存会维护全局的mspan，各个线程会通过中心缓存获取新的内存单元。</p>
<h4 id="fixalloc">fixalloc</h4>
<p>fixalloc 是一个基于自由列表的固定大小的分配器。其核心原理是将若干未分配的内存块连接起来， 将未分配的区域的第一个字为指向下一个未分配区域的指针使用。</p>
<p>Go 的主分配堆中 malloc（span、cache、treap、finalizer、profile、arena hint 等） 均 围绕它为实体进行固定分配和回收。</p>
<p>fixalloc 作为抽象，非常简洁，只包含三个基本操作：初始化、分配、回收</p>
<h5 id="结构">结构</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// fixalloc 是一个简单的固定大小对象的自由表内存分配器。
</span><span class="c1">// Malloc 使用围绕 sysAlloc 的 fixalloc 来管理其 MCache 和 MSpan 对象。
</span><span class="c1">//
</span><span class="c1">// fixalloc.alloc 返回的内存默认为零，但调用者可以通过将 zero 标志设置为 false
</span><span class="c1">// 来自行负责将分配归零。如果这部分内存永远不包含堆指针，则这样的操作是安全的。
</span><span class="c1">//
</span><span class="c1">// 调用方负责锁定 fixalloc 调用。调用方可以在对象中保持状态，
</span><span class="c1">// 但当释放和重新分配时第一个字会被破坏。
</span><span class="c1">//
</span><span class="c1">// 考虑使 fixalloc 的类型变为 go:notinheap.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">fixalloc</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">size</span>   <span class="kt">uintptr</span>
	<span class="nx">first</span>  <span class="kd">func</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span> <span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="c1">// 首次调用时返回 p
</span><span class="c1"></span>	<span class="nx">arg</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="nx">list</span>   <span class="o">*</span><span class="nx">mlink</span>
	<span class="nx">chunk</span>  <span class="kt">uintptr</span> <span class="c1">// 使用 uintptr 而非 unsafe.Pointer 来避免 write barrier
</span><span class="c1"></span>	<span class="nx">nchunk</span> <span class="kt">uint32</span>
	<span class="nx">inuse</span>  <span class="kt">uintptr</span> <span class="c1">// 正在使用的字节
</span><span class="c1"></span>	<span class="nx">stat</span>   <span class="o">*</span><span class="kt">uint64</span>
	<span class="nx">zero</span>   <span class="kt">bool</span> <span class="c1">// 归零的分配
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="初始化-1">初始化</h5>
<p>Go 语言对于零值有自己的规定，自然也就体现在内存分配器上。而 fixalloc 作为内存分配器内部组件的来源于 操作系统的内存，自然需要自行初始化，因此，fixalloc 的初始化也就不可避免的需要将自身的各个字段归零：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 初始化 f 来分配给定大小的对象。
</span><span class="c1">// 使用分配器来按 chunk 获取
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">fixalloc</span><span class="p">)</span> <span class="nf">init</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">first</span> <span class="kd">func</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span> <span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">),</span> <span class="nx">arg</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">stat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">size</span> <span class="p">=</span> <span class="nx">size</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">first</span> <span class="p">=</span> <span class="nx">first</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">arg</span> <span class="p">=</span> <span class="nx">arg</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">list</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">chunk</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">nchunk</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">inuse</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">stat</span> <span class="p">=</span> <span class="nx">stat</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">zero</span> <span class="p">=</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="分配">分配</h5>
<p>fixalloc 基于自由表策略进行实现，分为两种情况：</p>
<ol>
<li>存在被释放、可复用的内存</li>
<li>不存在可复用的内存</li>
</ol>
<p>对于第一种情况，也就是在运行时内存被释放，但这部分内存并不会被立即回收给操作系统， 我们直接从自由表中获得即可，但需要注意按需将这部分内存进行清零操作。</p>
<p>对于第二种情况，我们直接向操作系统申请固定大小的内存，然后扣除分配的大小即可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> 	<span class="nx">_FixAllocChunk</span> <span class="p">=</span> <span class="mi">16</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span>               <span class="c1">// FixAlloc 一个 Chunk 的大小
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">fixalloc</span><span class="p">)</span> <span class="nf">alloc</span><span class="p">()</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="c1">// fixalloc 的个字段必须先被 init
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">f</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: use of FixAlloc_Alloc before FixAlloc_Init\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: internal error&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 如果 f.list 不是 nil, 则说明还存在已经释放、可复用的内存，直接将其分配
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">f</span><span class="p">.</span><span class="nx">list</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 取出 f.list
</span><span class="c1"></span>		<span class="nx">v</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">list</span><span class="p">)</span>
		<span class="c1">// 并将其指向下一段区域
</span><span class="c1"></span>		<span class="nx">f</span><span class="p">.</span><span class="nx">list</span> <span class="p">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nx">next</span>
		<span class="c1">// 增加使用的(分配)大小
</span><span class="c1"></span>		<span class="nx">f</span><span class="p">.</span><span class="nx">inuse</span> <span class="o">+=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">size</span>
		<span class="c1">// 如果需要对内存清零，则对取出的内存执行初始化
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">f</span><span class="p">.</span><span class="nx">zero</span> <span class="p">{</span>
			<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">f</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 返回分配的内存
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">v</span>
	<span class="p">}</span>

	<span class="c1">// f.list 中没有可复用的内存
</span><span class="c1"></span>
	<span class="c1">// 如果此时 nchunk 不足以分配一个 size
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">nchunk</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">f</span><span class="p">.</span><span class="nx">size</span> <span class="p">{</span>
		<span class="c1">// 则向操作系统申请内存，大小为 16 &lt;&lt; 10 pow(2,14)
</span><span class="c1"></span>		<span class="nx">f</span><span class="p">.</span><span class="nx">chunk</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">persistentalloc</span><span class="p">(</span><span class="nx">_FixAllocChunk</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">f</span><span class="p">.</span><span class="nx">stat</span><span class="p">))</span>
		<span class="nx">f</span><span class="p">.</span><span class="nx">nchunk</span> <span class="p">=</span> <span class="nx">_FixAllocChunk</span>
	<span class="p">}</span>

	<span class="c1">// 指向申请好的内存
</span><span class="c1"></span>	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">chunk</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">f</span><span class="p">.</span><span class="nx">first</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// first 只有在 fixalloc 作为 spanalloc 时候，才会被设置为 recordspan
</span><span class="c1"></span>		<span class="nx">f</span><span class="p">.</span><span class="nf">first</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">arg</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> <span class="c1">// 用于为 heap.allspans 添加新的 span
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="c1">// 扣除并保留 size 大小的空间
</span><span class="c1"></span>	<span class="nx">f</span><span class="p">.</span><span class="nx">chunk</span> <span class="p">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">chunk</span> <span class="o">+</span> <span class="nx">f</span><span class="p">.</span><span class="nx">size</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">nchunk</span> <span class="o">-=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">inuse</span> <span class="o">+=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">size</span> <span class="c1">// 记录已经使用的大小
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">v</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="回收">回收</h5>
<p>回收就更加简单了，直接将回收的地址指针放回到自由表中即可：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">fixalloc</span><span class="p">)</span> <span class="nf">free</span><span class="p">(</span><span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 减少使用的字节数
</span><span class="c1"></span>	<span class="nx">f</span><span class="p">.</span><span class="nx">inuse</span> <span class="o">-=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">size</span>
	<span class="c1">// 将要释放的内存地址作为 mlink 指针插入到 f.list 内，完成回收
</span><span class="c1"></span>	<span class="nx">v</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">mlink</span><span class="p">)(</span><span class="nx">p</span><span class="p">)</span>
	<span class="nx">v</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">list</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">list</span> <span class="p">=</span> <span class="nx">v</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="alloc">alloc</h4>
<p>runtime.mheap 是内存分配器中的核心组件，运行时会通过它的 runtime.mheap.alloc 方法在系统栈中获取新的 runtime.mspan：</p>
<p>这个方法需要指明要分配的页数、span 的大小等级、是否为大对象、是否清零：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// alloc allocates a new span of npage pages from the GC&#39;d heap.
</span><span class="c1">//
</span><span class="c1">// spanclass indicates the span&#39;s size class and scannability.
</span><span class="c1">//
</span><span class="c1">// If needzero is true, the memory for the returned span will be zeroed.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">spanclass</span> <span class="nx">spanClass</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="c1">// Don&#39;t do any operations that lock the heap on the G stack.
</span><span class="c1"></span>	<span class="c1">// It might trigger stack growth, and the stack growth code needs
</span><span class="c1"></span>	<span class="c1">// to be able to allocate heap.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// To prevent excessive heap growth, before allocating n pages
</span><span class="c1"></span>		<span class="c1">// we need to sweep and reclaim at least n pages.
</span><span class="c1"></span>		<span class="c1">//为了阻止内存的大量占用和堆的增长，我们在分配对应页数的内存前需要先调用 runtime.mheap.reclaim 方法回收一部分内存
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">sweepdone</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nf">reclaim</span><span class="p">(</span><span class="nx">npages</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">//接下来我们将通过 runtime.mheap.allocSpan 分配新的mspan，
</span><span class="c1"></span>		<span class="nx">s</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">allocSpan</span><span class="p">(</span><span class="nx">npages</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">spanclass</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_inuse</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 需要清零时，对分配的 span 进行清零
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">needzero</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()),</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="o">&lt;&lt;</span><span class="nx">_PageShift</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 标记已经清零
</span><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>我们会将mheap.allocSpan的执行过程拆分成两个部分：</p>
<ol>
<li>从堆上分配新的内存页和mspan runtime.mspan；</li>
<li>初始化mspan并将其加入 runtime.mheap 持有内存单元列表；</li>
</ol>
<p>首先我们需要在堆上申请 npages 数量的内存页并初始化 runtime.mspan：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// allocSpan allocates an mspan which owns npages worth of memory.
</span><span class="c1">//
</span><span class="c1">// If manual == false, allocSpan allocates a heap span of class spanclass
</span><span class="c1">// and updates heap accounting. If manual == true, allocSpan allocates a
</span><span class="c1">// manually-managed span (spanclass is ignored), and the caller is
</span><span class="c1">// responsible for any accounting related to its use of the span. Either
</span><span class="c1">// way, allocSpan will atomically add the bytes in the newly allocated
</span><span class="c1">// span to *sysStat.
</span><span class="c1">//
</span><span class="c1">// The returned span is fully initialized.
</span><span class="c1">//
</span><span class="c1">// h must not be locked.
</span><span class="c1">//
</span><span class="c1">// allocSpan must be called on the system stack both because it acquires
</span><span class="c1">// the heap lock and because it must block GC transitions.
</span><span class="c1">//
</span><span class="c1">//go:systemstack
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">allocSpan</span><span class="p">(</span><span class="nx">npages</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">manual</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">spanclass</span> <span class="nx">spanClass</span><span class="p">,</span> <span class="nx">sysStat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Function-global state.
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">base</span><span class="p">,</span> <span class="nx">scav</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

	<span class="c1">// If the allocation is small enough, try the page cache!
</span><span class="c1"></span>	<span class="nx">pp</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">pp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">npages</span> <span class="p">&lt;</span> <span class="nx">pageCachePages</span><span class="o">/</span><span class="mi">4</span> <span class="p">{</span>
		<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">pcache</span>

		<span class="c1">// If the cache is empty, refill it.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="o">*</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">pages</span><span class="p">.</span><span class="nf">allocToCache</span><span class="p">()</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// Try to allocate from the cache.
</span><span class="c1"></span>		<span class="nx">base</span><span class="p">,</span> <span class="nx">scav</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">base</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">s</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">tryAllocMSpan</span><span class="p">()</span>

			<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">gcBlackenEnabled</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">manual</span> <span class="o">||</span> <span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">HaveSpan</span>
			<span class="p">}</span>
			<span class="c1">// We&#39;re either running duing GC, failed to acquire a mspan,
</span><span class="c1"></span>			<span class="c1">// or the allocation is for a large object. This means we
</span><span class="c1"></span>			<span class="c1">// have to lock the heap and do a bunch of extra work,
</span><span class="c1"></span>			<span class="c1">// so go down the HaveBaseLocked path.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// We must do this during GC to avoid skew with heap_scan
</span><span class="c1"></span>			<span class="c1">// since we flush mcache stats whenever we lock.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// TODO(mknyszek): It would be nice to not have to
</span><span class="c1"></span>			<span class="c1">// lock the heap if it&#39;s a large allocation, but
</span><span class="c1"></span>			<span class="c1">// it&#39;s fine for now. The critical section here is
</span><span class="c1"></span>			<span class="c1">// short and large object allocations are relatively
</span><span class="c1"></span>			<span class="c1">// infrequent.
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// For one reason or another, we couldn&#39;t get the
</span><span class="c1"></span>	<span class="c1">// whole job done without the heap lock.
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">base</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Try to acquire a base address.
</span><span class="c1"></span>		<span class="nx">base</span><span class="p">,</span> <span class="nx">scav</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">pages</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">base</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">grow</span><span class="p">(</span><span class="nx">npages</span><span class="p">)</span> <span class="p">{</span>
				<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
				<span class="k">return</span> <span class="kc">nil</span>
			<span class="p">}</span>
			<span class="nx">base</span><span class="p">,</span> <span class="nx">scav</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">pages</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">base</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;grew heap, but no adequate free space found&#34;</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// We failed to get an mspan earlier, so grab
</span><span class="c1"></span>		<span class="c1">// one now that we have the heap lock.
</span><span class="c1"></span>		<span class="nx">s</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">allocMSpanLocked</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">manual</span> <span class="p">{</span>
		<span class="c1">// This is a heap span, so we should do some additional accounting
</span><span class="c1"></span>		<span class="c1">// which may only be done with the heap locked.
</span><span class="c1"></span>
		<span class="c1">// Transfer stats from mcache to global.
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span>
		<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">c</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">mcache</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// This case occurs while bootstrapping.
</span><span class="c1"></span>			<span class="c1">// See the similar code in mallocgc.
</span><span class="c1"></span>			<span class="nx">c</span> <span class="p">=</span> <span class="nx">mcache0</span>
			<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;mheap.allocSpan called with no P&#34;</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_scan</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">local_scan</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">local_scan</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">memstats</span><span class="p">.</span><span class="nx">tinyallocs</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">local_tinyallocs</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">local_tinyallocs</span> <span class="p">=</span> <span class="mi">0</span>

		<span class="c1">// Do some additional accounting if it&#39;s a large allocation.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">mheap_</span><span class="p">.</span><span class="nx">largealloc</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">npages</span> <span class="o">*</span> <span class="nx">pageSize</span><span class="p">)</span>
			<span class="nx">mheap_</span><span class="p">.</span><span class="nx">nlargealloc</span><span class="o">++</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">npages</span><span class="o">*</span><span class="nx">pageSize</span><span class="p">))</span>
		<span class="p">}</span>

		<span class="c1">// Either heap_live or heap_scan could have been updated.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">gcController</span><span class="p">.</span><span class="nf">revise</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

<span class="nx">HaveSpan</span><span class="p">:</span>
	<span class="c1">// At this point, both s != nil and base != 0, and the heap
</span><span class="c1"></span>	<span class="c1">// lock is no longer held. Initialize the span.
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">base</span><span class="p">,</span> <span class="nx">npages</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">allocNeedsZero</span><span class="p">(</span><span class="nx">base</span><span class="p">,</span> <span class="nx">npages</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="nx">nbytes</span> <span class="o">:=</span> <span class="nx">npages</span> <span class="o">*</span> <span class="nx">pageSize</span>
	<span class="k">if</span> <span class="nx">manual</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">manualFreeList</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">limit</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="o">*</span><span class="nx">pageSize</span>
		<span class="c1">// Manually managed memory doesn&#39;t count toward heap_sys.
</span><span class="c1"></span>		<span class="nf">mSysStatDec</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_sys</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="o">*</span><span class="nx">pageSize</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">mSpanManual</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// We must set span properties before the span is published anywhere
</span><span class="c1"></span>		<span class="c1">// since we&#39;re not holding the heap lock.
</span><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nx">spanclass</span> <span class="p">=</span> <span class="nx">spanclass</span>
		<span class="k">if</span> <span class="nx">sizeclass</span> <span class="o">:=</span> <span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">();</span> <span class="nx">sizeclass</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nx">nbytes</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">=</span> <span class="mi">1</span>

			<span class="nx">s</span><span class="p">.</span><span class="nx">divShift</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divMul</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divShift2</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">baseMask</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">sizeclass</span><span class="p">])</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">=</span> <span class="nx">nbytes</span> <span class="o">/</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>

			<span class="nx">m</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">class_to_divmagic</span><span class="p">[</span><span class="nx">sizeclass</span><span class="p">]</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divShift</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">shift</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divMul</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">mul</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divShift2</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">shift2</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">baseMask</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">baseMask</span>
		<span class="p">}</span>

		<span class="c1">// Initialize mark and allocation structures.
</span><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">allocCache</span> <span class="p">=</span> <span class="p">^</span><span class="nb">uint64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// all 1s indicating all free.
</span><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nx">gcmarkBits</span> <span class="p">=</span> <span class="nf">newMarkBits</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">allocBits</span> <span class="p">=</span> <span class="nf">newAllocBits</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span>

		<span class="c1">// It&#39;s safe to access h.sweepgen without the heap lock because it&#39;s
</span><span class="c1"></span>		<span class="c1">// only ever updated with the world stopped and we run on the
</span><span class="c1"></span>		<span class="c1">// systemstack which blocks a STW transition.
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">)</span>

		<span class="c1">// Now that the span is filled in, set its state. This
</span><span class="c1"></span>		<span class="c1">// is a publication barrier for the other fields in
</span><span class="c1"></span>		<span class="c1">// the span. While valid pointers into this span
</span><span class="c1"></span>		<span class="c1">// should never be visible until the span is returned,
</span><span class="c1"></span>		<span class="c1">// if the garbage collector finds an invalid pointer,
</span><span class="c1"></span>		<span class="c1">// access to the span may race with initialization of
</span><span class="c1"></span>		<span class="c1">// the span. We resolve this race by atomically
</span><span class="c1"></span>		<span class="c1">// setting the state after the span is fully
</span><span class="c1"></span>		<span class="c1">// initialized, and atomically checking the state in
</span><span class="c1"></span>		<span class="c1">// any situation where a pointer is suspect.
</span><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">mSpanInUse</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Commit and account for any scavenged memory that the span now owns.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">scav</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// sysUsed all the pages that are actually available
</span><span class="c1"></span>		<span class="c1">// in the span since some of them might be scavenged.
</span><span class="c1"></span>		<span class="nf">sysUsed</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">base</span><span class="p">),</span> <span class="nx">nbytes</span><span class="p">)</span>
		<span class="nf">mSysStatDec</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_released</span><span class="p">,</span> <span class="nx">scav</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// Update stats.
</span><span class="c1"></span>	<span class="nf">mSysStatInc</span><span class="p">(</span><span class="nx">sysStat</span><span class="p">,</span> <span class="nx">nbytes</span><span class="p">)</span>
	<span class="nf">mSysStatDec</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_idle</span><span class="p">,</span> <span class="nx">nbytes</span><span class="p">)</span>

	<span class="c1">// Publish the span in various locations.
</span><span class="c1"></span>
	<span class="c1">// This is safe to call without the lock held because the slots
</span><span class="c1"></span>	<span class="c1">// related to this span will only ever be read or modified by
</span><span class="c1"></span>	<span class="c1">// this thread until pointers into the span are published (and
</span><span class="c1"></span>	<span class="c1">// we execute a publication barrier at the end of this function
</span><span class="c1"></span>	<span class="c1">// before that happens) or pageInUse is updated.
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nf">setSpans</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">(),</span> <span class="nx">npages</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">manual</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">go115NewMCentralImpl</span> <span class="p">{</span>
			<span class="c1">// Add to swept in-use list.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// This publishes the span to root marking.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// h.sweepgen is guaranteed to only change during STW,
</span><span class="c1"></span>			<span class="c1">// and preemption is disabled in the page allocator.
</span><span class="c1"></span>			<span class="nx">h</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="nx">h</span><span class="p">.</span><span class="nx">sweepgen</span><span class="o">/</span><span class="mi">2</span><span class="o">%</span><span class="mi">2</span><span class="p">].</span><span class="nf">push</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// Mark in-use span in arena page bitmap.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// This publishes the span to the page sweeper, so
</span><span class="c1"></span>		<span class="c1">// it&#39;s imperative that the span be completely initialized
</span><span class="c1"></span>		<span class="c1">// prior to this line.
</span><span class="c1"></span>		<span class="nx">arena</span><span class="p">,</span> <span class="nx">pageIdx</span><span class="p">,</span> <span class="nx">pageMask</span> <span class="o">:=</span> <span class="nf">pageIndexOf</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Or8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arena</span><span class="p">.</span><span class="nx">pageInUse</span><span class="p">[</span><span class="nx">pageIdx</span><span class="p">],</span> <span class="nx">pageMask</span><span class="p">)</span>

		<span class="c1">// Update related page sweeper stats.
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">pagesInUse</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">npages</span><span class="p">))</span>

		<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
			<span class="c1">// Trace that a heap alloc occurred.
</span><span class="c1"></span>			<span class="nf">traceHeapAlloc</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Make sure the newly allocated span will be observed
</span><span class="c1"></span>	<span class="c1">// by the GC before pointers into the span are published.
</span><span class="c1"></span>	<span class="nf">publicationBarrier</span><span class="p">()</span>

	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述方法会通过处理器的页缓存 runtime.pageCache 或者全局的页分配器 runtime.pageAlloc 两种途径从堆中申请内存：</p>
<ol>
<li>如果申请的内存比较小，获取申请内存的处理器并尝试调用 runtime.pageCache.alloc 获取内存区域的基地址和大小；</li>
<li>如果申请的内存比较大或者线程的页缓存中内存不足，会通过 runtime.pageAlloc.alloc 在页堆上申请内存；</li>
<li>如果发现页堆上的内存不足，会尝试通过 runtime.mheap.grow 进行扩容并重新调用 runtime.pageAlloc.alloc 申请内存；
<ol>
<li>如果申请到内存，意味着扩容成功；</li>
<li>如果没有申请到内存，意味着扩容失败，宿主机可能不存在空闲内存，运行时会直接中止当前程序；</li>
</ol>
</li>
</ol>
<p>无论通过哪种方式获得内存页，我们都会在该函数中分配新的 runtime.mspan 结构体；该方法的剩余部分会通过页数、内存空间以及跨度类等参数初始化它的多个字段：</p>
<p>在上述代码中，我们通过调用 runtime.mspan.init 方法以及设置参数初始化刚刚分配的 runtime.mspan 结构并通过 runtime.mheaps.setSpans 方法建立页堆与内存单元的联系。</p>
<h4 id="grow-1">grow</h4>
<p>runtime.mheap.grow 方法会向操作系统申请更多的内存空间，传入的页数经过对齐可以得到期望的内存大小，我们可以将该方法的执行过程分成以下几个部分：</p>
<ol>
<li>通过传入的页数从已经保留的arena中获取期望分配的内存空间大小以及内存的基地址；</li>
<li>如果 arena 区域没有足够的空间，调用 runtime.mheap.sysAlloc 从操作系统中申请更多的内存；</li>
<li>扩容 runtime.mheap 持有的 arena 区域并更新页分配器的元信息；</li>
<li>在某些场景下，调用 runtime.pageAlloc.scavenge 回收不再使用的空闲内存页；</li>
</ol>
<p>在页堆扩容的过程中，runtime.mheap.sysAlloc 是页堆用来申请虚拟内存的方法.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// sysAlloc allocates heap arena space for at least n bytes. The
</span><span class="c1">// returned pointer is always heapArenaBytes-aligned and backed by
</span><span class="c1">// h.arenas metadata. The returned size is always a multiple of
</span><span class="c1">// heapArenaBytes. sysAlloc returns nil on failure.
</span><span class="c1">// There is no corresponding free function.
</span><span class="c1">//
</span><span class="c1">// sysAlloc returns a memory region in the Prepared state. This region must
</span><span class="c1">// be transitioned to Ready before use.
</span><span class="c1">//
</span><span class="c1">// h must be locked.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">sysAlloc</span><span class="p">(</span><span class="nx">n</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="p">=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">heapArenaBytes</span><span class="p">)</span>
	<span class="c1">//首先，该方法会尝试在预保留的区域申请内存：
</span><span class="c1"></span>	<span class="c1">// First, try the arena pre-reservation.
</span><span class="c1"></span>	<span class="c1">//调用线性分配器的 runtime.linearAlloc.alloc 方法在预先保留的内存中申请一块可以使用的空间。
</span><span class="c1"></span>	<span class="nx">v</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">arena</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">heapArenaBytes</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_sys</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">v</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">size</span> <span class="p">=</span> <span class="nx">n</span>
		<span class="k">goto</span> <span class="nx">mapped</span>
	<span class="p">}</span>

	<span class="c1">// Try to grow the heap at a hint address.
</span><span class="c1"></span>	<span class="c1">// 如果获取不到，再尝试增长 arena hint
</span><span class="c1"></span>	<span class="c1">//如果没有可用的空间，我们会根据页堆的 arenaHints 在目标地址上尝试扩容：
</span><span class="c1"></span>	<span class="c1">//runtime.sysReserve 和 runtime.sysMap 是代码的核心部分，它们会从操作系统中申请内存并将内存转换至 Prepared 状态。
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">h</span><span class="p">.</span><span class="nx">arenaHints</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">hint</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">arenaHints</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">hint</span><span class="p">.</span><span class="nx">addr</span>
		<span class="k">if</span> <span class="nx">hint</span><span class="p">.</span><span class="nx">down</span> <span class="p">{</span>
			<span class="nx">p</span> <span class="o">-=</span> <span class="nx">n</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">p</span><span class="o">+</span><span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">p</span> <span class="p">{</span><span class="c1">// 溢出
</span><span class="c1"></span>			<span class="c1">// We can&#39;t use this, so don&#39;t ask.
</span><span class="c1"></span>			<span class="nx">v</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nf">arenaIndex</span><span class="p">(</span><span class="nx">p</span><span class="o">+</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">arenaBits</span> <span class="p">{</span><span class="c1">// 溢出
</span><span class="c1"></span>			<span class="c1">// Outside addressable heap. Can&#39;t use.
</span><span class="c1"></span>			<span class="nx">v</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">v</span> <span class="p">=</span> <span class="nf">sysReserve</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="nx">n</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 获取成功，更新 arena hint
</span><span class="c1"></span>			<span class="c1">// Success. Update the hint.
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">hint</span><span class="p">.</span><span class="nx">down</span> <span class="p">{</span>
				<span class="nx">p</span> <span class="o">+=</span> <span class="nx">n</span>
			<span class="p">}</span>
			<span class="nx">hint</span><span class="p">.</span><span class="nx">addr</span> <span class="p">=</span> <span class="nx">p</span>
			<span class="nx">size</span> <span class="p">=</span> <span class="nx">n</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="c1">// Failed. Discard this hint and try the next.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// TODO: This would be cleaner if sysReserve could be
</span><span class="c1"></span>		<span class="c1">// told to only return the requested address. In
</span><span class="c1"></span>		<span class="c1">// particular, this is already how Windows behaves, so
</span><span class="c1"></span>		<span class="c1">// it would simplify things there.
</span><span class="c1"></span>		<span class="c1">// 失败，丢弃并重新尝试
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">v</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">sysFree</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">arenaHints</span> <span class="p">=</span> <span class="nx">hint</span><span class="p">.</span><span class="nx">next</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">arenaHintAlloc</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">hint</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="c1">// The race detector assumes the heap lives in
</span><span class="c1"></span>			<span class="c1">// [0x00c000000000, 0x00e000000000), but we
</span><span class="c1"></span>			<span class="c1">// just ran out of hints in this region. Give
</span><span class="c1"></span>			<span class="c1">// a nice failure.
</span><span class="c1"></span>			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;too many address space collisions for -race mode&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// All of the hints failed, so we&#39;ll take any
</span><span class="c1"></span>		<span class="c1">// (sufficiently aligned) address the kernel will give
</span><span class="c1"></span>		<span class="c1">// us.
</span><span class="c1"></span>		<span class="nx">v</span><span class="p">,</span> <span class="nx">size</span> <span class="p">=</span> <span class="nf">sysReserveAligned</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">heapArenaBytes</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span>
		<span class="p">}</span>

		<span class="c1">// Create new hints for extending this region.
</span><span class="c1"></span>		<span class="c1">// 创建新的 hint 来增长此区域
</span><span class="c1"></span>		<span class="nx">hint</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">arenaHint</span><span class="p">)(</span><span class="nx">h</span><span class="p">.</span><span class="nx">arenaHintAlloc</span><span class="p">.</span><span class="nf">alloc</span><span class="p">())</span>
		<span class="nx">hint</span><span class="p">.</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">hint</span><span class="p">.</span><span class="nx">down</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">),</span> <span class="kc">true</span>
		<span class="nx">hint</span><span class="p">.</span><span class="nx">next</span><span class="p">,</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenaHints</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenaHints</span><span class="p">,</span> <span class="nx">hint</span>
		<span class="nx">hint</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">arenaHint</span><span class="p">)(</span><span class="nx">h</span><span class="p">.</span><span class="nx">arenaHintAlloc</span><span class="p">.</span><span class="nf">alloc</span><span class="p">())</span>
		<span class="nx">hint</span><span class="p">.</span><span class="nx">addr</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="o">+</span> <span class="nx">size</span>
		<span class="nx">hint</span><span class="p">.</span><span class="nx">next</span><span class="p">,</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenaHints</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenaHints</span><span class="p">,</span> <span class="nx">hint</span>
	<span class="p">}</span>

	<span class="c1">// Check for bad pointers or pointers we can&#39;t use.
</span><span class="c1"></span>	<span class="c1">// 检查不能使用的指针
</span><span class="c1"></span>	<span class="p">{</span>
		<span class="kd">var</span> <span class="nx">bad</span> <span class="kt">string</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">p</span><span class="o">+</span><span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">p</span> <span class="p">{</span>
			<span class="nx">bad</span> <span class="p">=</span> <span class="s">&#34;region exceeds uintptr range&#34;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nf">arenaIndex</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">arenaBits</span> <span class="p">{</span>
			<span class="nx">bad</span> <span class="p">=</span> <span class="s">&#34;base outside usable address space&#34;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nf">arenaIndex</span><span class="p">(</span><span class="nx">p</span><span class="o">+</span><span class="nx">size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">arenaBits</span> <span class="p">{</span>
			<span class="nx">bad</span> <span class="p">=</span> <span class="s">&#34;end outside usable address space&#34;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">bad</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="c1">// This should be impossible on most architectures,
</span><span class="c1"></span>			<span class="c1">// but it would be really confusing to debug.
</span><span class="c1"></span>			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: memory allocated by OS [&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="s">&#34;, &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">p</span><span class="o">+</span><span class="nx">size</span><span class="p">),</span> <span class="s">&#34;) not in usable address space: &#34;</span><span class="p">,</span> <span class="nx">bad</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;memory reservation exceeds address space limit&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">heapArenaBytes</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;misrounded allocation in sysAlloc&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Transition from Reserved to Prepared.
</span><span class="c1"></span>	<span class="c1">// 正式开始使用保留的内存
</span><span class="c1"></span>	<span class="nf">sysMap</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_sys</span><span class="p">)</span>

<span class="nx">mapped</span><span class="p">:</span>
	<span class="c1">// Create arena metadata.
</span><span class="c1"></span>	<span class="c1">//runtime.mheap.sysAlloc 方法在最后会初始化一个新的 runtime.heapArena 结构体来管理刚刚申请的内存空间，该结构体会被加入页堆的二维矩阵中。
</span><span class="c1"></span>	<span class="c1">// 创建 arena 的 metadata
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">ri</span> <span class="o">:=</span> <span class="nf">arenaIndex</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">));</span> <span class="nx">ri</span> <span class="o">&lt;=</span> <span class="nf">arenaIndex</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span><span class="o">+</span><span class="nx">size</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="nx">ri</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">l2</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">arenas</span><span class="p">[</span><span class="nx">ri</span><span class="p">.</span><span class="nf">l1</span><span class="p">()]</span>
		<span class="k">if</span> <span class="nx">l2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// Allocate an L2 arena map.
</span><span class="c1"></span>			<span class="c1">// 分配 L2 arena map
</span><span class="c1"></span>			<span class="nx">l2</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">arenaL2Bits</span><span class="p">]</span><span class="o">*</span><span class="nx">heapArena</span><span class="p">)(</span><span class="nf">persistentalloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="o">*</span><span class="nx">l2</span><span class="p">),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">l2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory allocating heap arena map&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">StorepNoWB</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">arenas</span><span class="p">[</span><span class="nx">ri</span><span class="p">.</span><span class="nf">l1</span><span class="p">()]),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">l2</span><span class="p">))</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">l2</span><span class="p">[</span><span class="nx">ri</span><span class="p">.</span><span class="nf">l2</span><span class="p">()]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;arena already initialized&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="kd">var</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">heapArena</span>
		<span class="nx">r</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">heapArena</span><span class="p">)(</span><span class="nx">h</span><span class="p">.</span><span class="nx">heapArenaAlloc</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="o">*</span><span class="nx">r</span><span class="p">),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_sys</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">r</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">r</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">heapArena</span><span class="p">)(</span><span class="nf">persistentalloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="o">*</span><span class="nx">r</span><span class="p">),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_sys</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">r</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory allocating heap arena metadata&#34;</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// Add the arena to the arenas list.
</span><span class="c1"></span>		<span class="c1">// 将 arena 添加到 arena 列表中
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">)</span> <span class="o">==</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">size</span> <span class="o">:=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">))</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
			<span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">size</span> <span class="p">=</span> <span class="nx">physPageSize</span>
			<span class="p">}</span>
			<span class="nx">newArray</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">notInHeap</span><span class="p">)(</span><span class="nf">persistentalloc</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_sys</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">newArray</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory allocating allArenas&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">oldSlice</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span>
			<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">notInHeapSlice</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">))</span> <span class="p">=</span> <span class="nx">notInHeapSlice</span><span class="p">{</span><span class="nx">newArray</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="nx">size</span> <span class="o">/</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)}</span>
			<span class="nb">copy</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">,</span> <span class="nx">oldSlice</span><span class="p">)</span>
			<span class="c1">// Do not free the old backing array because
</span><span class="c1"></span>			<span class="c1">// there may be concurrent readers. Since we
</span><span class="c1"></span>			<span class="c1">// double the array each time, this can lead
</span><span class="c1"></span>			<span class="c1">// to at most 2x waste.
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">ri</span>

		<span class="c1">// Store atomically just in case an object from the
</span><span class="c1"></span>		<span class="c1">// new heap arena becomes visible before the heap lock
</span><span class="c1"></span>		<span class="c1">// is released (which shouldn&#39;t happen, but there&#39;s
</span><span class="c1"></span>		<span class="c1">// little downside to this).
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">StorepNoWB</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l2</span><span class="p">[</span><span class="nx">ri</span><span class="p">.</span><span class="nf">l2</span><span class="p">()]),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">r</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="c1">// Tell the race detector about the new heap memory.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">racemapshadow</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>这个过程略显复杂：</p>
<ol>
<li>首先会通过现有的 arena 中获得已经保留的内存区域，如果能获取到，则直接对 arena 进行初始化；</li>
<li>如果没有，则会通过 sysReserve 为 arena 保留新的内存区域，并通过 sysReserveAligned 对操作系统对齐的区域进行重排，而后使用 sysMap 正式使用所在区块的内存。</li>
<li>在 arena 初始化阶段，本质上是为 arena 创建 metadata，这部分内存属于堆外内存，即不会被 GC 所追踪的内存，因而通过 persistentalloc 进行分配。</li>
</ol>
<p>persistentalloc 是 sysAlloc 之上的一层封装，它分配到的内存用于不能被释放。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Wrapper around sysAlloc that can allocate small chunks.
</span><span class="c1">// There is no associated free operation.
</span><span class="c1">// Intended for things like function/type/debug-related persistent data.
</span><span class="c1">// If align is 0, uses default align (currently 8).
</span><span class="c1">// The returned memory will be zeroed.
</span><span class="c1">//
</span><span class="c1">// Consider marking persistentalloc&#39;d types go:notinheap.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">persistentalloc</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">align</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">sysStat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">p</span> <span class="o">*</span><span class="nx">notInHeap</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nf">persistentalloc1</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">align</span><span class="p">,</span> <span class="nx">sysStat</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Must run on system stack because stack growth can (re)invoke it.
</span><span class="c1">// See issue 9174.
</span><span class="c1">//go:systemstack
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">persistentalloc1</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">align</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">sysStat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="o">*</span><span class="nx">notInHeap</span> <span class="p">{</span>
	<span class="kd">const</span> <span class="p">(</span>
		<span class="nx">maxBlock</span> <span class="p">=</span> <span class="mi">64</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span> <span class="c1">// VM reservation granularity is 64K on windows
</span><span class="c1"></span>	<span class="p">)</span>
	<span class="c1">// 不允许分配大小为 0 的空间
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;persistentalloc: size == 0&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 对齐数必须为 2 的指数、且不大于 PageSize
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">align</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">align</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">align</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;persistentalloc: align is not a power of 2&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">align</span> <span class="p">&gt;</span> <span class="nx">_PageSize</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;persistentalloc: align is too large&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 若未指定则默认为 8
</span><span class="c1"></span>		<span class="nx">align</span> <span class="p">=</span> <span class="mi">8</span>
	<span class="p">}</span>
	<span class="c1">// 分配大内存：分配的大小如果超过最大的 block 大小，则直接调用 sysAlloc 进行分配
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">size</span> <span class="o">&gt;=</span> <span class="nx">maxBlock</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">notInHeap</span><span class="p">)(</span><span class="nf">sysAlloc</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">sysStat</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="c1">// 分配小内存：在 m 上进行
</span><span class="c1"></span>	<span class="c1">// 先获取 m
</span><span class="c1"></span>	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
	<span class="kd">var</span> <span class="nx">persistent</span> <span class="o">*</span><span class="nx">persistentAlloc</span>
	<span class="k">if</span> <span class="nx">mp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 如果能够获取到 m 且同时持有 p，则直接分配到 p 的 palloc 上
</span><span class="c1"></span>		<span class="nx">persistent</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">palloc</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 否则就分配到全局的 globalAlloc.persistentAlloc 上
</span><span class="c1"></span>		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">globalAlloc</span><span class="p">.</span><span class="nx">mutex</span><span class="p">)</span>
		<span class="nx">persistent</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">globalAlloc</span><span class="p">.</span><span class="nx">persistentAlloc</span>
	<span class="p">}</span>
	<span class="c1">// 四舍五入 off 到 align 的倍数
</span><span class="c1"></span>	<span class="nx">persistent</span><span class="p">.</span><span class="nx">off</span> <span class="p">=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">persistent</span><span class="p">.</span><span class="nx">off</span><span class="p">,</span> <span class="nx">align</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">persistent</span><span class="p">.</span><span class="nx">off</span><span class="o">+</span><span class="nx">size</span> <span class="p">&gt;</span> <span class="nx">persistentChunkSize</span> <span class="o">||</span> <span class="nx">persistent</span><span class="p">.</span><span class="nx">base</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">persistent</span><span class="p">.</span><span class="nx">base</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">notInHeap</span><span class="p">)(</span><span class="nf">sysAlloc</span><span class="p">(</span><span class="nx">persistentChunkSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">other_sys</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">persistent</span><span class="p">.</span><span class="nx">base</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">persistent</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">globalAlloc</span><span class="p">.</span><span class="nx">persistentAlloc</span> <span class="p">{</span>
				<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">globalAlloc</span><span class="p">.</span><span class="nx">mutex</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: cannot allocate memory&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// Add the new chunk to the persistentChunks list.
</span><span class="c1"></span>		<span class="k">for</span> <span class="p">{</span>
			<span class="nx">chunks</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">persistentChunks</span><span class="p">))</span>
			<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">persistent</span><span class="p">.</span><span class="nx">base</span><span class="p">))</span> <span class="p">=</span> <span class="nx">chunks</span>
			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Casuintptr</span><span class="p">((</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">persistentChunks</span><span class="p">)),</span> <span class="nx">chunks</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">persistent</span><span class="p">.</span><span class="nx">base</span><span class="p">)))</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">persistent</span><span class="p">.</span><span class="nx">off</span> <span class="p">=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="nx">align</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">persistent</span><span class="p">.</span><span class="nx">base</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">persistent</span><span class="p">.</span><span class="nx">off</span><span class="p">)</span>
	<span class="nx">persistent</span><span class="p">.</span><span class="nx">off</span> <span class="o">+=</span> <span class="nx">size</span>
	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">persistent</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">globalAlloc</span><span class="p">.</span><span class="nx">persistentAlloc</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">globalAlloc</span><span class="p">.</span><span class="nx">mutex</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">sysStat</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">other_sys</span> <span class="p">{</span>
		<span class="nf">mSysStatInc</span><span class="p">(</span><span class="nx">sysStat</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
		<span class="nf">mSysStatDec</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">other_sys</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">p</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，这里申请到的内存会被记录到 globalAlloc 中:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">globalAlloc</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">mutex</span>
	<span class="nx">persistentAlloc</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">persistentAlloc</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">base</span> <span class="o">*</span><span class="nx">notInHeap</span> <span class="c1">// 空结构，内存首地址
</span><span class="c1"></span>	<span class="nx">off</span>  <span class="kt">uintptr</span>    <span class="c1">// 偏移量
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="linearalloc">linearAlloc</h4>
<p>linearAlloc 是一个基于线性分配策略的分配器，但由于它只作为 mheap_.heapArenaAlloc 和 mheap_.arena 在 32 位系统上使用，这里不做详细分析。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// linearAlloc 是一个简单的线性分配器，它预留一块内存区域并按需将其映射到 Ready 状态。
</span><span class="c1">// 调用方有责任对齐进行加锁。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">linearAlloc</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">next</span>   <span class="kt">uintptr</span> <span class="c1">// 下一个可用的字节
</span><span class="c1"></span>	<span class="nx">mapped</span> <span class="kt">uintptr</span> <span class="c1">// 映射空间后的一个字节
</span><span class="c1"></span>	<span class="nx">end</span>    <span class="kt">uintptr</span> <span class="c1">// 保留空间的末尾
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">linearAlloc</span><span class="p">)</span> <span class="nf">init</span><span class="p">(</span><span class="nx">base</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">next</span><span class="p">,</span> <span class="nx">l</span><span class="p">.</span><span class="nx">mapped</span> <span class="p">=</span> <span class="nx">base</span><span class="p">,</span> <span class="nx">base</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">end</span> <span class="p">=</span> <span class="nx">base</span> <span class="o">+</span> <span class="nx">size</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">linearAlloc</span><span class="p">)</span> <span class="nf">alloc</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">align</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">sysStat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nf">round</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">next</span><span class="p">,</span> <span class="nx">align</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">p</span><span class="o">+</span><span class="nx">size</span> <span class="p">&gt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">end</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">p</span> <span class="o">+</span> <span class="nx">size</span>
	<span class="k">if</span> <span class="nx">pEnd</span> <span class="o">:=</span> <span class="nf">round</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">next</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">physPageSize</span><span class="p">);</span> <span class="nx">pEnd</span> <span class="p">&gt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">mapped</span> <span class="p">{</span>
		<span class="c1">// We need to map more of the reserved space.
</span><span class="c1"></span>		<span class="nf">sysMap</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">mapped</span><span class="p">),</span> <span class="nx">pEnd</span><span class="o">-</span><span class="nx">l</span><span class="p">.</span><span class="nx">mapped</span><span class="p">,</span> <span class="nx">sysStat</span><span class="p">)</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">mapped</span> <span class="p">=</span> <span class="nx">pEnd</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="小结">小结</h3>
<p>展示了所有结构的关系。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/mem-struct.png" alt=""></p>
<p>heap 最中间的灰色区域 arena 覆盖了 Go 程序的整个虚拟内存， 每个 arena 包括一段 bitmap 和一段指向连续 span 的指针； 每个 span 由一串连续的页组成；每个 arena 的起始位置通过 arenaHint 进行记录。</p>
<p>分配的顺序从右向左，代价也就越来越大。 小对象和微对象优先从白色区域 per-P 的 mcache 分配 span，这个过程不需要加锁（白色）； 若失败则会从 mheap 持有的 mcentral 加锁获得新的 span，这个过程需要加锁，但只是局部（灰色）； 若仍失败则会从右侧的 free 或 scav 进行分配，这个过程需要对整个 heap 进行加锁，代价最大（黑色）。</p>
<h2 id="内存分配">内存分配</h2>
<p>堆上所有的对象都会通过调用 runtime.newobject 函数分配内存.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// implementation of new builtin
</span><span class="c1">// compiler (both frontend and SSA backend) knows the signature
</span><span class="c1">// of this function
</span><span class="c1">// 创建一个新的对象
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">typ</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nx">typ</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span><span class="c1">// true 内存清零
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中 _type 为 Go 类型的实现，通过其 size 属性能够获得该类型所需要的大小。</p>
<p>该函数会调用 runtime.mallocgc 分配指定大小的内存空间，这也是用户程序向堆上申请内存空间的必经函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Allocate an object of size bytes.
</span><span class="c1">// Small objects are allocated from the per-P cache&#39;s free lists.
</span><span class="c1">// Large objects (&gt; 32 kB) are allocated straight from the heap.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">gcphase</span> <span class="o">==</span> <span class="nx">_GCmarktermination</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;mallocgc called with gcphase == _GCmarktermination&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 创建大小为零的对象，例如空结构体
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zerobase</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">sbrk</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">align</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">typ</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// TODO(austin): This should be just
</span><span class="c1"></span>			<span class="c1">//   align = uintptr(typ.align)
</span><span class="c1"></span>			<span class="c1">// but that&#39;s only 4 on 32-bit platforms,
</span><span class="c1"></span>			<span class="c1">// even if there&#39;s a uint64 field in typ (see #599).
</span><span class="c1"></span>			<span class="c1">// This causes 64-bit atomic accesses to panic.
</span><span class="c1"></span>			<span class="c1">// Hence, we use stricter alignment that matches
</span><span class="c1"></span>			<span class="c1">// the normal allocator better.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">7</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">align</span> <span class="p">=</span> <span class="mi">8</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">align</span> <span class="p">=</span> <span class="mi">4</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">align</span> <span class="p">=</span> <span class="mi">2</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">align</span> <span class="p">=</span> <span class="mi">1</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nf">persistentalloc</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">align</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">other_sys</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// assistG is the G to charge for this allocation, or nil if
</span><span class="c1"></span>	<span class="c1">// GC is not currently active.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">assistG</span> <span class="o">*</span><span class="nx">g</span>
	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Charge the current user G for this allocation.
</span><span class="c1"></span>		<span class="nx">assistG</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">assistG</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">assistG</span> <span class="p">=</span> <span class="nx">assistG</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
		<span class="p">}</span>
		<span class="c1">// Charge the allocation against the G. We&#39;ll account
</span><span class="c1"></span>		<span class="c1">// for internal fragmentation at the end of mallocgc.
</span><span class="c1"></span>		<span class="nx">assistG</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">-=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">assistG</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// This G is in debt. Assist the GC to correct
</span><span class="c1"></span>			<span class="c1">// this before allocating. This must happen
</span><span class="c1"></span>			<span class="c1">// before disabling preemption.
</span><span class="c1"></span>			<span class="nf">gcAssistAlloc</span><span class="p">(</span><span class="nx">assistG</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Set mp.mallocing to keep from being preempted by GC.
</span><span class="c1"></span>	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;malloc deadlock&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span> <span class="o">==</span> <span class="nf">getg</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;malloc during signal&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="p">=</span> <span class="mi">1</span>

	<span class="nx">shouldhelpgc</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="nx">dataSize</span> <span class="o">:=</span> <span class="nx">size</span>
	<span class="kd">var</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span>
	<span class="c1">// 获取当前 g 所在 M 所绑定 P 的 mcache
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">c</span> <span class="p">=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">mcache</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// We will be called without a P while bootstrapping,
</span><span class="c1"></span>		<span class="c1">// in which case we use mcache0, which is set in mallocinit.
</span><span class="c1"></span>		<span class="c1">// mcache0 is cleared when bootstrapping is complete,
</span><span class="c1"></span>		<span class="c1">// by procresize.
</span><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="nx">mcache0</span>
		<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;malloc called with no P&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">span</span> <span class="o">*</span><span class="nx">mspan</span>
	<span class="kd">var</span> <span class="nx">x</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="nx">noscan</span> <span class="o">:=</span> <span class="nx">typ</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span>

	<span class="k">if</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">maxSmallSize</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">noscan</span> <span class="o">&amp;&amp;</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">maxTinySize</span> <span class="p">{</span>
			<span class="c1">// 微对象分配
</span><span class="c1"></span>			<span class="c1">// Tiny allocator.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// Tiny allocator combines several tiny allocation requests
</span><span class="c1"></span>			<span class="c1">// into a single memory block. The resulting memory block
</span><span class="c1"></span>			<span class="c1">// is freed when all subobjects are unreachable. The subobjects
</span><span class="c1"></span>			<span class="c1">// must be noscan (don&#39;t have pointers), this ensures that
</span><span class="c1"></span>			<span class="c1">// the amount of potentially wasted memory is bounded.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// Size of the memory block used for combining (maxTinySize) is tunable.
</span><span class="c1"></span>			<span class="c1">// Current setting is 16 bytes, which relates to 2x worst case memory
</span><span class="c1"></span>			<span class="c1">// wastage (when all but one subobjects are unreachable).
</span><span class="c1"></span>			<span class="c1">// 8 bytes would result in no wastage at all, but provides less
</span><span class="c1"></span>			<span class="c1">// opportunities for combining.
</span><span class="c1"></span>			<span class="c1">// 32 bytes provides more opportunities for combining,
</span><span class="c1"></span>			<span class="c1">// but can lead to 4x worst case wastage.
</span><span class="c1"></span>			<span class="c1">// The best case winning is 8x regardless of block size.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// Objects obtained from tiny allocator must not be freed explicitly.
</span><span class="c1"></span>			<span class="c1">// So when an object will be freed explicitly, we ensure that
</span><span class="c1"></span>			<span class="c1">// its size &gt;= maxTinySize.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// SetFinalizer has a special case for objects potentially coming
</span><span class="c1"></span>			<span class="c1">// from tiny allocator, it such case it allows to set finalizers
</span><span class="c1"></span>			<span class="c1">// for an inner byte of a memory block.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// The main targets of tiny allocator are small strings and
</span><span class="c1"></span>			<span class="c1">// standalone escaping variables. On a json benchmark
</span><span class="c1"></span>			<span class="c1">// the allocator reduces number of allocations by ~12% and
</span><span class="c1"></span>			<span class="c1">// reduces heap size by ~20%.
</span><span class="c1"></span>			<span class="c1">//线程缓存 runtime.mcache 中的 tiny 字段指向了 maxTinySize 大小的块，如果当前块中还包含大小合适的空闲内存，运行时会通过基地址和偏移量获取并返回这块内存：
</span><span class="c1"></span>			<span class="nx">off</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span>
			<span class="c1">// Align tiny pointer for required (conservative) alignment.
</span><span class="c1"></span>			<span class="c1">// 将微型指针对齐以进行所需（保守）对齐。
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">7</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">off</span> <span class="p">=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">off</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">off</span> <span class="p">=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">off</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">off</span> <span class="p">=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">off</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">off</span><span class="o">+</span><span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">maxTinySize</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// 能直接被当前的内存块容纳
</span><span class="c1"></span>				<span class="c1">// The object fits into existing tiny block.
</span><span class="c1"></span>				<span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">+</span> <span class="nx">off</span><span class="p">)</span>
				<span class="c1">// 增加 offset
</span><span class="c1"></span>				<span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="p">=</span> <span class="nx">off</span> <span class="o">+</span> <span class="nx">size</span>
				<span class="c1">// 统计数量
</span><span class="c1"></span>				<span class="nx">c</span><span class="p">.</span><span class="nx">local_tinyallocs</span><span class="o">++</span>
				<span class="c1">// 完成分配，释放 m
</span><span class="c1"></span>				<span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="p">=</span> <span class="mi">0</span>
				<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
				<span class="k">return</span> <span class="nx">x</span>
			<span class="p">}</span>
			<span class="c1">// Allocate a new maxTinySize block.
</span><span class="c1"></span>			<span class="c1">//当内存块中不包含空闲的内存时，下面的这段代码会从先线程缓存找到跨度类对应的mspan runtime.mspan，调用 runtime.nextFreeFast 获取空闲的内存；当不存在空闲内存时，我们会调用 runtime.mcache.nextFree 从中心缓存或者页堆中获取可分配的内存块：
</span><span class="c1"></span>			<span class="c1">// 根据 tinySpan 的大小等级获得对应的 span 链表
</span><span class="c1"></span>			<span class="c1">// 从而用于分配一个新的 maxTinySize 块，与小对象分配的过程一致
</span><span class="c1"></span>			<span class="nx">span</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">tinySpanClass</span><span class="p">]</span>
			<span class="nx">v</span> <span class="o">:=</span> <span class="nf">nextFreeFast</span><span class="p">(</span><span class="nx">span</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">v</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">nextFree</span><span class="p">(</span><span class="nx">tinySpanClass</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">x</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="c1">// See if we need to replace the existing tiny block with the new one
</span><span class="c1"></span>			<span class="c1">// based on amount of remaining free space.
</span><span class="c1"></span>			<span class="c1">// 看看我们是否需要根据剩余可用空间量替换现有的小块
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="o">||</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="p">=</span> <span class="nx">size</span>
			<span class="p">}</span>
			<span class="c1">//获取新的空闲内存块之后，上述代码会清空空闲内存中的数据、更新构成微对象分配器的几个字段 tiny 和 tinyoffset 并返回新的空闲内存。
</span><span class="c1"></span>			<span class="nx">size</span> <span class="p">=</span> <span class="nx">maxTinySize</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 小对象分配
</span><span class="c1"></span>			<span class="c1">//1. 确定分配对象的大小以及跨度类 runtime.spanClass；
</span><span class="c1"></span>			<span class="kd">var</span> <span class="nx">sizeclass</span> <span class="kt">uint8</span>
			<span class="k">if</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">smallSizeMax</span><span class="o">-</span><span class="mi">8</span> <span class="p">{</span>
				<span class="nx">sizeclass</span> <span class="p">=</span> <span class="nx">size_to_class8</span><span class="p">[</span><span class="nf">divRoundUp</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">smallSizeDiv</span><span class="p">)]</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">sizeclass</span> <span class="p">=</span> <span class="nx">size_to_class128</span><span class="p">[</span><span class="nf">divRoundUp</span><span class="p">(</span><span class="nx">size</span><span class="o">-</span><span class="nx">smallSizeMax</span><span class="p">,</span> <span class="nx">largeSizeDiv</span><span class="p">)]</span>
			<span class="p">}</span>
			<span class="c1">//2. 从线程缓存、中心缓存或者堆中获取mspan并从mspan找到空闲的内存空间；
</span><span class="c1"></span>			<span class="nx">size</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">sizeclass</span><span class="p">])</span>
			<span class="nx">spc</span> <span class="o">:=</span> <span class="nf">makeSpanClass</span><span class="p">(</span><span class="nx">sizeclass</span><span class="p">,</span> <span class="nx">noscan</span><span class="p">)</span>
			<span class="nx">span</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>
			<span class="nx">v</span> <span class="o">:=</span> <span class="nf">nextFreeFast</span><span class="p">(</span><span class="nx">span</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">v</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">nextFree</span><span class="p">(</span><span class="nx">spc</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
			<span class="c1">//3. 调用 runtime.memclrNoHeapPointers 清空空闲内存中的所有数据；
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">needzero</span> <span class="o">&amp;&amp;</span> <span class="nx">span</span><span class="p">.</span><span class="nx">needzero</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">),</span> <span class="nx">size</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 大对象分配
</span><span class="c1"></span>		<span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">span</span> <span class="p">=</span> <span class="nf">largeAlloc</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">needzero</span><span class="p">,</span> <span class="nx">noscan</span><span class="p">)</span>
		<span class="p">})</span>
		<span class="nx">span</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="nx">span</span><span class="p">.</span><span class="nx">allocCount</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
		<span class="nx">size</span> <span class="p">=</span> <span class="nx">span</span><span class="p">.</span><span class="nx">elemsize</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">scanSize</span> <span class="kt">uintptr</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">noscan</span> <span class="p">{</span>
		<span class="c1">// If allocating a defer+arg block, now that we&#39;ve picked a malloc size
</span><span class="c1"></span>		<span class="c1">// large enough to hold everything, cut the &#34;asked for&#34; size down to
</span><span class="c1"></span>		<span class="c1">// just the defer header, so that the GC bitmap will record the arg block
</span><span class="c1"></span>		<span class="c1">// as containing nothing at all (as if it were unused space at the end of
</span><span class="c1"></span>		<span class="c1">// a malloc block caused by size rounding).
</span><span class="c1"></span>		<span class="c1">// The defer arg areas are scanned as part of scanstack.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">typ</span> <span class="o">==</span> <span class="nx">deferType</span> <span class="p">{</span>
			<span class="nx">dataSize</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">_defer</span><span class="p">{})</span>
		<span class="p">}</span>
		<span class="nf">heapBitsSetType</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">dataSize</span><span class="p">,</span> <span class="nx">typ</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">dataSize</span> <span class="p">&gt;</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">size</span> <span class="p">{</span>
			<span class="c1">// Array allocation. If there are any
</span><span class="c1"></span>			<span class="c1">// pointers, GC has to scan to the last
</span><span class="c1"></span>			<span class="c1">// element.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">scanSize</span> <span class="p">=</span> <span class="nx">dataSize</span> <span class="o">-</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">size</span> <span class="o">+</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">ptrdata</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">scanSize</span> <span class="p">=</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">ptrdata</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">local_scan</span> <span class="o">+=</span> <span class="nx">scanSize</span>
	<span class="p">}</span>

	<span class="c1">// Ensure that the stores above that initialize x to
</span><span class="c1"></span>	<span class="c1">// type-safe memory and set the heap bits occur before
</span><span class="c1"></span>	<span class="c1">// the caller can make x observable to the garbage
</span><span class="c1"></span>	<span class="c1">// collector. Otherwise, on weakly ordered machines,
</span><span class="c1"></span>	<span class="c1">// the garbage collector could follow a pointer to x,
</span><span class="c1"></span>	<span class="c1">// but see uninitialized memory or stale heap bits.
</span><span class="c1"></span>	<span class="nf">publicationBarrier</span><span class="p">()</span>

	<span class="c1">// Allocate black during GC.
</span><span class="c1"></span>	<span class="c1">// All slots hold nil so no scanning is needed.
</span><span class="c1"></span>	<span class="c1">// This may be racing with GC so do it atomically if there can be
</span><span class="c1"></span>	<span class="c1">// a race marking the bit.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="p">{</span>
		<span class="nf">gcmarknewobject</span><span class="p">(</span><span class="nx">span</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">scanSize</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">racemalloc</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
		<span class="nf">msanmalloc</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">allocfreetrace</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">tracealloc</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">typ</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">rate</span> <span class="o">:=</span> <span class="nx">MemProfileRate</span><span class="p">;</span> <span class="nx">rate</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">rate</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">next_sample</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">next_sample</span> <span class="o">-=</span> <span class="nx">size</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
			<span class="nf">profilealloc</span><span class="p">(</span><span class="nx">mp</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
			<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">assistG</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Account for internal fragmentation in the assist
</span><span class="c1"></span>		<span class="c1">// debt now that we know it.
</span><span class="c1"></span>		<span class="nx">assistG</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">-=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">size</span> <span class="o">-</span> <span class="nx">dataSize</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">shouldhelpgc</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">t</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">gcTrigger</span><span class="p">{</span><span class="nx">kind</span><span class="p">:</span> <span class="nx">gcTriggerHeap</span><span class="p">});</span> <span class="nx">t</span><span class="p">.</span><span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">gcStart</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码使用 runtime.gomcache 获取了线程缓存并通过类型判断类型是否为指针类型。我们从这个代码片段可以看出 runtime.mallocgc 会根据对象的大小执行不同的分配逻辑，在前面的章节也曾经介绍过运行时根据对象大小将它们分成微对象、小对象和大对象，这里会根据大小选择不同的分配逻辑：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123224434.png" alt=""></p>
<ul>
<li>微对象 (0, 16B) — 先使用微型分配器，再依次尝试线程缓存、中心缓存和堆分配内存；</li>
<li>小对象 [16B, 32KB] — 依次尝试使用线程缓存、中心缓存和堆分配内存；</li>
<li>大对象 (32KB, +∞) — 直接在堆上分配内存；</li>
</ul>
<p>在分配过程中，我们会发现需要持有 M 才可进行分配，这是因为分配不仅可能涉及 mcache，还需要将正在分配的 M 标记为 mallocing，用于记录当前 M 的分配状态。</p>
<h3 id="微对象">微对象</h3>
<p>Go 语言运行时将小于 16 字节的对象划分为微对象，它会使用线程缓存上的微分配器提高微对象分配的性能，我们主要使用它来分配较小的字符串以及逃逸的临时变量。微分配器可以将多个较小的内存分配请求合入同一个内存块中，只有当内存块中的所有对象都需要被回收时，整片内存才可能被回收。</p>
<p>微分配器管理的对象不可以是指针类型，管理多个对象的内存块大小 maxTinySize 是可以调整的，在默认情况下，内存块的大小为 16 字节。maxTinySize 的值越大，组合多个对象的可能性就越高，内存浪费也就越严重；maxTinySize 越小，内存浪费就会越少，不过无论如何调整，8 的倍数都是一个很好的选择。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201123224958.png" alt=""></p>
<p>如上图所示，微分配器已经在 16 字节的内存块中分配了 12 字节的对象，如果下一个待分配的对象小于 4 字节，它就会直接使用上述内存块的剩余部分，减少内存碎片，不过该内存块只有在 3 个对象都被标记为垃圾时才会被回收。</p>
<p>寻找 span 的过程其实与小对象分配完全一致，区别在于微对象分配只寻找 tinySpanClass 大小等级的 span。 而且不会对这部分内存进行清零。</p>
<h3 id="小对象">小对象</h3>
<p>小对象是指大小为 16 字节到 32,768 字节的对象以及所有小于 16 字节的指针类型的对象.</p>
<p>当对一个小对象（&lt;32KB）分配内存时，会将该对象所需的内存大小调整到某个能够容纳该对象的大小等级（size class）， 并查看 mcache 中对应等级的 mspan，通过扫描 mspan 的 freeindex 来确定是否能够进行分配。</p>
<p>当没有可分配的 mspan 时，会从 mcentral 中获取一个所需大小空间的新的 mspan，从 mcentral 中分配会对其进行加锁， 但一次性获取整个 span 的过程均摊了对 mcentral 加锁的成本。</p>
<p>如果 mcentral 的 mspan 也为空时，则它也会发生增长，从而从 mheap 中获取一连串的页，作为一个新的 mspan 进行提供。 而如果 mheap 仍然为空，或者没有足够大的对象来进行分配时，则会从操作系统中分配一组新的页（至少 1MB）， 从而均摊与操作系统沟通的成本。</p>
<h3 id="大对象">大对象</h3>
<p>运行时对于大于 32KB 的大对象会单独处理，我们不会从线程缓存或者中心缓存中获取mspan，而是直接在系统的栈中调用 runtime.largeAlloc 函数分配大片的内存：</p>
<p>runtime.largeAlloc 函数会计算分配该对象所需要的页数，它会按照 8KB 的倍数为对象在堆上申请内存：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">largeAlloc</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">noscan</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="c1">// print(&#34;largeAlloc size=&#34;, size, &#34;\n&#34;)
</span><span class="c1"></span>	<span class="c1">// 对象太大，溢出
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">size</span><span class="o">+</span><span class="nx">_PageSize</span> <span class="p">&lt;</span> <span class="nx">size</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 根据分配的大小计算需要分配的页数
</span><span class="c1"></span>	<span class="nx">npages</span> <span class="o">:=</span> <span class="nx">size</span> <span class="o">&gt;&gt;</span> <span class="nx">_PageShift</span>
	<span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="nx">_PageMask</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">npages</span><span class="o">++</span>
	<span class="p">}</span>

	<span class="c1">// Deduct credit for this span allocation and sweep if
</span><span class="c1"></span>	<span class="c1">// necessary. mHeap_Alloc will also sweep npages, so this only
</span><span class="c1"></span>	<span class="c1">// pays the debt down to npage pages.
</span><span class="c1"></span>	<span class="nf">deductSweepCredit</span><span class="p">(</span><span class="nx">npages</span><span class="o">*</span><span class="nx">_PageSize</span><span class="p">,</span> <span class="nx">npages</span><span class="p">)</span>

	<span class="nx">spc</span> <span class="o">:=</span> <span class="nf">makeSpanClass</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">noscan</span><span class="p">)</span>
	<span class="c1">// 从堆上分配
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span><span class="p">,</span> <span class="nx">spc</span><span class="p">,</span> <span class="nx">needzero</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">go115NewMCentralImpl</span> <span class="p">{</span>
		<span class="c1">// Put the large span in the mcentral swept list so that it&#39;s
</span><span class="c1"></span>		<span class="c1">// visible to the background sweeper.
</span><span class="c1"></span>		<span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">spc</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">fullSwept</span><span class="p">(</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">).</span><span class="nf">push</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">limit</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">size</span>
	<span class="nf">heapBitsForAddr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()).</span><span class="nf">initSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>申请内存时会创建一个跨度类为 0 的 runtime.spanClass 并调用 runtime.mheap.alloc 分配一个管理对应内存的管理单元。</p>
<h3 id="nextfreefast">nextFreeFast</h3>
<p>nextFreeFast 不涉及正式的分配过程，只是简单的寻找一个能够容纳当前微型对象的 span</p>
<p>runtime.nextFreeFast 会利用mspan中的 allocCache 字段，快速找到该字段中为 1 的位数，我们在上面介绍过1表示该位对应的内存空间是空闲的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// nextFreeFast returns the next free object if one is quickly available.
</span><span class="c1">// Otherwise it returns 0.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">nextFreeFast</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">)</span> <span class="nx">gclinkptr</span> <span class="p">{</span>
	<span class="nx">theBit</span> <span class="o">:=</span> <span class="nx">sys</span><span class="p">.</span><span class="nf">Ctz64</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCache</span><span class="p">)</span> <span class="c1">// Is there a free object in the allocCache?
</span><span class="c1"></span>	<span class="c1">// 如果小于 64 则说明可以直接使用
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">theBit</span> <span class="p">&lt;</span> <span class="mi">64</span> <span class="p">{</span>
		<span class="nx">result</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">theBit</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">result</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
			<span class="nx">freeidx</span> <span class="o">:=</span> <span class="nx">result</span> <span class="o">+</span> <span class="mi">1</span>
			<span class="k">if</span> <span class="nx">freeidx</span><span class="o">%</span><span class="mi">64</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">freeidx</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
				<span class="k">return</span> <span class="mi">0</span>
			<span class="p">}</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">allocCache</span> <span class="o">&gt;&gt;=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">theBit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="nx">freeidx</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="o">++</span>
			<span class="k">return</span> <span class="nf">gclinkptr</span><span class="p">(</span><span class="nx">result</span><span class="o">*</span><span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>allocCache 字段用于计算 freeindex 上的 allocBits 缓存，allocCache 进行了移位使其最低位对应于 freeindex 位。allocCache 保存 allocBits 的补码，从而尾零计数可以直接使用它。</p>
<p>找到了空闲的对象后，我们就可以更新mspan的 allocCache、freeindex 等字段并返回该片内存了</p>
<h3 id="nextfree">nextFree</h3>
<p>如果我们没有找到空闲的内存，运行时会通过 runtime.mcache.nextFree 找到新的mspan：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// nextFree returns the next free object from the cached span if one is available.
</span><span class="c1">// Otherwise it refills the cache with a span with an available object and
</span><span class="c1">// returns that object along with a flag indicating that this was a heavy
</span><span class="c1">// weight allocation. If it is a heavy weight allocation the caller must
</span><span class="c1">// determine whether a new GC cycle needs to be started or if the GC is active
</span><span class="c1">// whether this goroutine needs to assist the GC.
</span><span class="c1">//
</span><span class="c1">// Must run in a non-preemptible context since otherwise the owner of
</span><span class="c1">// c could change.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span><span class="p">)</span> <span class="nf">nextFree</span><span class="p">(</span><span class="nx">spc</span> <span class="nx">spanClass</span><span class="p">)</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">gclinkptr</span><span class="p">,</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">,</span> <span class="nx">shouldhelpgc</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>
	<span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="c1">// 获得 s.freeindex 中或之后 s 中下一个空闲对象的索引
</span><span class="c1"></span>	<span class="nx">freeIndex</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">nextFreeIndex</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">freeIndex</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="c1">// span 已满，进行填充
</span><span class="c1"></span>		<span class="c1">// The span is full.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
			<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: s.allocCount=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">,</span> <span class="s">&#34;s.nelems=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;s.allocCount != s.nelems &amp;&amp; freeIndex == s.nelems&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">refill</span><span class="p">(</span><span class="nx">spc</span><span class="p">)</span>
		<span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>

		<span class="nx">freeIndex</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">nextFreeIndex</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">freeIndex</span> <span class="o">&gt;=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;freeIndex is not valid&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 这部分内容需要被 gc 接管，因此需要计算位置
</span><span class="c1"></span>	<span class="nx">v</span> <span class="p">=</span> <span class="nf">gclinkptr</span><span class="p">(</span><span class="nx">freeIndex</span><span class="o">*</span><span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="o">++</span><span class="c1">// 分配计数
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="s">&#34;s.allocCount=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">,</span> <span class="s">&#34;s.nelems=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;s.allocCount &gt; s.nelems&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在上述方法中，如果我们在线程缓存中没有找到可用的mspan，会通过前面介绍的 runtime.mcache.refill 使用中心缓存中的mspan替换已经不存在可用对象的结构体，该方法会调用新结构体的 runtime.mspan.nextFreeIndex 获取空闲的内存并返回。</p>
<h3 id="memclrnoheappointers">memclrNoHeapPointers</h3>
<p>memclrNoHeapPointers 用于清理不包含堆指针的内存区块：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// memclrNoHeapPointers 清除从 ptr 开始的 n 个字节
</span><span class="c1">// 通常情况下你应该使用 typedmemclr，而 memclrNoHeapPointers 应该仅在调用方知道 *ptr
</span><span class="c1">// 不包含堆指针的情况下使用，因为 *ptr 只能是下面两种情况：
</span><span class="c1">// 1. *ptr 是初始化过的内存，且其类型不是指针。
</span><span class="c1">// 2. *ptr 是未初始化的内存（例如刚被新分配时使用的内存），则指包含 &#34;junk&#34; 垃圾内存
</span><span class="c1">// 见 memclr_*.s
</span><span class="c1">//
</span><span class="c1">//go:noescape
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">ptr</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">uintptr</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>清理过程是汇编实现的，就是一些内存的归零工作，简单浏览一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-s" data-lang="s"><span class="n">TEXT</span> <span class="n">runtime</span>·<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">NOSPLIT</span><span class="p">,</span> <span class="o">$</span><span class="m">0-8</span>
	<span class="n">MOVL</span>	<span class="n">ptr</span><span class="m">+0</span><span class="p">(</span><span class="n">FP</span><span class="p">),</span> <span class="n">DI</span>
	<span class="n">MOVL</span>	<span class="n">n</span><span class="m">+4</span><span class="p">(</span><span class="n">FP</span><span class="p">),</span> <span class="n">BX</span>
	<span class="n">XORL</span>	<span class="n">AX</span><span class="p">,</span> <span class="n">AX</span>

	<span class="o">//</span> <span class="n">MOVOU</span> 好像总是比 <span class="n">REP</span> <span class="n">STOSL</span> 快
<span class="n">tail</span><span class="o">:</span>
	<span class="p">(</span><span class="kc">...</span><span class="p">)</span>

<span class="n">loop</span><span class="o">:</span>
	<span class="n">MOVOU</span>	<span class="n">X0</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="n">DI</span><span class="p">)</span>
	<span class="n">MOVOU</span>	<span class="n">X0</span><span class="p">,</span> <span class="m">16</span><span class="p">(</span><span class="n">DI</span><span class="p">)</span>
	<span class="n">MOVOU</span>	<span class="n">X0</span><span class="p">,</span> <span class="m">32</span><span class="p">(</span><span class="n">DI</span><span class="p">)</span>
	<span class="n">MOVOU</span>	<span class="n">X0</span><span class="p">,</span> <span class="m">48</span><span class="p">(</span><span class="n">DI</span><span class="p">)</span>
	<span class="n">MOVOU</span>	<span class="n">X0</span><span class="p">,</span> <span class="m">64</span><span class="p">(</span><span class="n">DI</span><span class="p">)</span>
	<span class="n">MOVOU</span>	<span class="n">X0</span><span class="p">,</span> <span class="m">80</span><span class="p">(</span><span class="n">DI</span><span class="p">)</span>
	<span class="n">MOVOU</span>	<span class="n">X0</span><span class="p">,</span> <span class="m">96</span><span class="p">(</span><span class="n">DI</span><span class="p">)</span>
	<span class="p">(</span><span class="kc">...</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="程序初始化">程序初始化</h2>
<p>除去执行栈外，内存分配器是最先完成初始化的，我们先来看这个初始化的过程。 内存分配器的初始化除去一些例行的检查之外，就是对堆的初始化了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mallocinit</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 一些涉及内存分配器的常量的检查，包括
</span><span class="c1"></span>	<span class="c1">// heapArenaBitmapBytes, physPageSize 等等
</span><span class="c1"></span>	<span class="o">...</span>

	<span class="c1">// 初始化堆
</span><span class="c1"></span>	<span class="nx">mheap_</span><span class="p">.</span><span class="nf">init</span><span class="p">()</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span> <span class="p">=</span> <span class="nf">allocmcache</span><span class="p">()</span>

	<span class="c1">// 创建初始的 arena 增长 hint
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">==</span> <span class="mi">8</span> <span class="o">&amp;&amp;</span> <span class="nx">GOARCH</span> <span class="o">!=</span> <span class="s">&#34;wasm&#34;</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mh">0x7f</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="nx">p</span> <span class="kt">uintptr</span>
			<span class="k">switch</span> <span class="p">{</span>
			<span class="k">case</span> <span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;arm64&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;darwin&#34;</span><span class="p">:</span>
				<span class="nx">p</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">40</span> <span class="p">|</span> <span class="nx">uintptrMask</span><span class="o">&amp;</span><span class="p">(</span><span class="mh">0x0013</span><span class="o">&lt;&lt;</span><span class="mi">28</span><span class="p">)</span>
			<span class="p">(</span><span class="o">...</span><span class="p">)</span>
			<span class="k">default</span><span class="p">:</span>
				<span class="nx">p</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">40</span> <span class="p">|</span> <span class="nx">uintptrMask</span><span class="o">&amp;</span><span class="p">(</span><span class="mh">0x00c0</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">hint</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">arenaHint</span><span class="p">)(</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenaHintAlloc</span><span class="p">.</span><span class="nf">alloc</span><span class="p">())</span>
			<span class="nx">hint</span><span class="p">.</span><span class="nx">addr</span> <span class="p">=</span> <span class="nx">p</span>
			<span class="nx">hint</span><span class="p">.</span><span class="nx">next</span><span class="p">,</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenaHints</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenaHints</span><span class="p">,</span> <span class="nx">hint</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 32 位机器，不关心
</span><span class="c1"></span>		<span class="p">(</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这个过程中还包含对 mcache 初始化 allocmcache()，这个 mcache 会在 procresize 中将 mcache 转移到 P 的门下，而并非属于 M.</p>
<h2 id="小结-1">小结</h2>
<p>内存分配是 Go 语言运行时内存管理的核心逻辑，运行时的内存分配器使用类似 TCMalloc 的分配策略将对象根据大小分类，并设计多层级的组件提高内存分配器的性能。本节不仅介绍了 Go 语言内存分配器的设计与实现原理，同时也介绍了内存分配器的常见设计，帮助我们理解不同编程语言在设计内存分配器时做出的不同选择。</p>
<p>内存分配器虽然非常重要，但是它只解决了如何分配内存的问题，我们在本节中省略了很多与垃圾回收相关的代码，没有分析运行时垃圾回收的实现原理，在下一节中我们将详细分析 Go 语言垃圾回收的设计与实现原理。</p>
<p>参考:
<a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/">7.1 内存分配器</a><br>
<a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch07alloc/basic/">7.1 设计原则</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-11-23
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go%E6%BA%90%E7%A0%81/">Go源码</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go调度器的信号处理源码剖析</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E6%B2%BB%E7%90%86/">
            <span class="next-text nav-default">微服务概览与治理</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Forz</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
