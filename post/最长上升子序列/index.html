<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>最长上升子序列 | Forz Blog</title>
<meta name="keywords" content="Greedy, Hash, DP" />
<meta name="description" content="LeetCode 300. Longest Increasing Subsequence Given an unsorted array of integers, find the length of longest increasing subsequence. For example, Given [10, 9, 2, 5, 3, 7, 101, 18], The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity.">
<meta name="author" content="">
<link rel="canonical" href="/post/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="最长上升子序列" />
<meta property="og:description" content="LeetCode 300. Longest Increasing Subsequence Given an unsorted array of integers, find the length of longest increasing subsequence. For example, Given [10, 9, 2, 5, 3, 7, 101, 18], The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-24T20:26:24&#43;00:00" />
<meta property="article:modified_time" content="2017-06-24T20:26:24&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="最长上升子序列"/>
<meta name="twitter:description" content="LeetCode 300. Longest Increasing Subsequence Given an unsorted array of integers, find the length of longest increasing subsequence. For example, Given [10, 9, 2, 5, 3, 7, 101, 18], The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "最长上升子序列",
      "item": "/post/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "最长上升子序列",
  "name": "最长上升子序列",
  "description": "LeetCode 300. Longest Increasing Subsequence Given an unsorted array of integers, find the length of longest increasing subsequence. For example, Given [10, 9, 2, 5, 3, 7, 101, 18], The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity.",
  "keywords": [
    "Greedy", "Hash", "DP"
  ],
  "articleBody": "LeetCode 300. Longest Increasing Subsequence Given an unsorted array of integers, find the length of longest increasing subsequence.\nFor example,\nGiven [10, 9, 2, 5, 3, 7, 101, 18],\nThe longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.\nYour algorithm should run in O(n2) complexity.\nFollow up: Could you improve it to O(n log n) time complexity?\n解析：\n贪心+二分查找可以将LIS问题的时间复杂度缩短到（nlogn）\n维护一个单调递增子序列，它的关键原理在于，如果当前值小于单调递增子序列中的某个元素，则替换之，因为单调递增子序列能否增长，值取决于最后一个元素，替换内部的元素并不影响。\n在1,3,5,2,8,4,6这个例子中，当到6时，一共可以有四种不同长度，且保证该升序序列在同长度升序序列中末尾最小的升序序列。\n(1) 1,(2) 1,3,(4) 1,3,5,(6)  注：每个序列的末尾数字加括号。\n这些序列都是有可能成为最长递增子序列的候选者。\ntail[i]表示长度为i的递增序列末尾的数字（如上1,2,4,6存在tail中）。\ntail[]数组性质：tail[0] 每次读入一个新元素时，可按照以下规则更新这些序列：\n  nums[i]比所有递增序列的末尾都小,则长度为1的序列更新为这个更小的末尾。\n如果读入数字0，则更新序列为：\n (0) 1,(2) 1,3,(4) 1,3,5,(6)    nums[i]比所有序列的末尾都大,则直接将nums[i]加到当前最长序列的后面。\n如果读入数字9，更新序列为：\n (1) 1,(2) 1,3,(4) 1,3,5,(6) 1,3,5,6,(9)    在中间，则更新那个末尾数字刚好大于等于nums[i]的那个序列，nums[i]替换其末尾数字。该情况下，利用二分搜索寻找。\n如果读入数字3，更新序列为：\n (1) 1,(2) 1,3,(3) 1,3,5,(6)    可以利用lower_bound函数来优化代码，该函数返回第一个大于等于比较值的元素的迭代器，正好和情况1，3所需要的功能相对应。\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public: int lengthOfLIS(vectorint\u0026 nums) { vectorint res; for(int i=0; inums.size(); i++) { auto it = lower_bound(res.begin(), res.end(), nums[i]); if(it==res.end()) res.push_back(nums[i]); else *it = nums[i]; } return res.size(); } };   补充：普通DP方法\n设数组dp[i]表示数组前面i个数中最大增长子数组的长度,枚举倒数第二个数\ndp(j) = max { dp(i) + 1 : if nums[i] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public: int dpOfLIS(vectorint\u0026 nums) { if(nums.size()==0) return 0; vectorint dp(nums.size(),1); //初始化设置dp[i]=1  int ret=1;//保存最终结果  for(int i=0;inums.size();i++)//枚举倒数第二个数  for(int j=i+1;jnums.size();j++) if(nums[i]nums[j]){//可以更新dp值  dp[j]=max(dp[j],dp[i]+1); if(dp[j]ret) ret=dp[j]; } return ret; } };   补充:\n根据dp数组生成最长递增子序列。\n解析:\n接下来解释如何根据求出的dp数组得到最长递增子序列。\n设:arr=[2，l，5,3,6,4,8,9,7],求出的数组 dp=[1，1，2,2,3,3,4,5,4]。\n  遍历dp数组，找到最大值以及位置。在本例中最大值为5,位置为7,说明最终的最长递增子序列的长度为5,并且应该以arr[7]这个数(arr[7]=9)结尾。\n  从arr数组的位置7开始从右向左遍历。如果对某一个位置i,既有arr[i] 从arr数组的位置6开始继续向左遍历，按照同样的过程找到倒数第三个数。在本例中，位置5满足arr[5] 重复这样的过程，直到所有的数都找出来。\n  dp数组包含每一步决策的信息，其实根据dp数组找出最长递增子序列的过程就是从某个位置开始逆序还原出决策路径的过程。具体过程请参看如下代码中的generateLIS方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public static int[] generateLIS(int[] arr, int[] dp) { int len = 0; int index = 0; for (int i = 0; i  dp.length; i++) { if (dp[i]  len) { len = dp[i]; index = i; } } int[] lis = new int[len]; lis[--len] = arr[index]; for (int i = index; i = 0; i--) { if (arr[i]  arr[index] \u0026\u0026 dp[i] == dp[index] - 1) { lis[--len] = arr[i]; index = i; } } return lis; }   LeetCode 334. Increasing Triplet Subsequence Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.\nFormally the function should:\nReturn true if there exists i, j, k\nsuch that arr[i] Your algorithm should run in O(n) time complexity and O(1) space complexity.\nExamples:\nGiven [1, 2, 3, 4, 5],\nreturn true.\nGiven [5, 4, 3, 2, 1],\nreturn false.\n解析：\n最长上升子序列的简化版，给定子序列长度，直接用最小值，次小值记录即可。\n遍历更新最小的数和次小的数，如果某个数大于这两个数，则有三个数递增，返回true.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution { public: bool increasingTriplet(vectorint\u0026 nums) { if (nums.size()  3) return false; int firstMin = INT_MAX; int secondMin = INT_MAX; for (int i = 0; i  nums.size(); i++){ if (nums[i]  firstMin){ firstMin = nums[i]; } else if (nums[i]  secondMin){ secondMin = nums[i]; } else{ return true; } } return false; } };   LeetCode 354. Russian Doll Envelopes You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.\nWhat is the maximum number of envelopes can you Russian doll? (put one inside other)\nExample:\nGiven envelopes = [[5,4],[6,4],[6,7],[2,3]], the maximum number of envelopes you can Russian doll is 3 ([2,3] = [5,4] = [6,7]).\n解析：\n一个最长升序子串的变形，思路完全一样。\npair排序默认按照第一元素优先递增，第一元素相等则第二元素递增\n如果按照默认的递增顺序排序，在width相同时，height是递增的，这样在二分查找时会将width相同的元素也认定为递增可以嵌套，不符合题目要求。如果width按递增顺序排列，而height在width相同时按递减顺序排列，这样在所有元素的height中找LIS即是最大嵌套层数。因为width相同的元素height是递减的，不会认定为递增序列，这就保证了width相同的元素至多有一个在LIS中\n这道题因为可以任意变换信封的位置，而且之前已经进行过排序，所以不能使用单调栈\n举例：原序列为1，5，8，3，6，7.\n开始1，5，8相继入栈，此时读到3，用3替换5，得到1，3，8； 再读6，用6替换8，得到1，3，6； 再读7，得到最终栈为1，3，6，7。最长递增子序列为长度4。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution { public: int maxEnvelopes(vectorpairint, int\u0026 envelopes) { int size = envelopes.size(); sort(envelopes.begin(), envelopes.end(), [](pairint, int a, pairint, intb){ return a.firstb.first || (a.first==b.first \u0026\u0026 a.secondb.second);//必须是一行语句  }); vectorint collector;//之前已经利用排序使宽度严格递增，此处用vector保存高度即可  for(auto\u0026 pair: envelopes) { auto iter = lower_bound(collector.begin(), collector.end(), pair.second);//二分法求高度大于pair的元素迭代器  if(iter == collector.end()) collector.push_back(pair.second);//如果当前元素的高度最大，入栈  else if(*iter  pair.second) *iter = pair.second;//如果不是最大的，进行替换，可以让序列变长的潜力增大  } return collector.size(); } };   补充:普通DP\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  int maxenvelopes(vectorpairint, int\u0026 envelopes) { int size = envelopes.size(); if(!size) return 0; sort(envelopes.begin(), envelopes.end());//默认递增排序 int maxrolls[size]{0}, maxroll = 1; maxrolls[0] = 1; for(int i = 1; i  size; ++i) { maxrolls[i] = 1; for(int j = i-1; j = 0; --j) if(envelopes[i].firstenvelopes[j].first \u0026\u0026 envelopes[i].secondenvelopes[j].second) maxrolls[i] = max(maxrolls[i], maxrolls[j]+1); maxroll = max(maxroll, maxrolls[i]); } return maxroll; }   LeetCode 368. Largest Divisible Subset Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.\nIf there are multiple solutions, return any subset is fine.\nExample 1:\nnums: [1,2,3] Result: [1,2] (of course, [1,3] will also be ok)  Example 2:\nnums: [1,2,4,8] Result: [1,2,4,8]  解析：\n将这些数按从小到大的顺序排列，问题转换为了类似于最长不下降子序列的DP。\n为了找出最大结果, 所以我们还需要记录一下路径, 每一个数字, 我们记录第一个能够使其到达最大长度的父结点, 最后回溯一下即可.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class Solution { public: vectorint largestDivisibleSubset(vectorint\u0026 nums) { sort(nums.begin(),nums.end()); int len = nums.size(); int ans = 0, ansi; int *dp=new int[len]; int *pre=new int[len];//用于保存最长可整除序列的路径（利用前驱节点）  for (int i=0;ilen;i++){//扫描数组  dp[i] = 1;//dp[i]表示扫描到位置i的最优解  pre[i] = -1; for (int j=0;ji;j++){ if (nums[i]%nums[j] == 0 \u0026\u0026 dp[j]+1dp[i]){//查找前面的符合元素  dp[i] = dp[j]+1; pre[i] = j;//维护前驱节点  } } if (dp[i]  ans){//更新结果和终点  ans = dp[i]; ansi = i; } } vectorint res; for (int i=1;ians;i++){ res.push_back(nums[ansi]); ansi = pre[ansi]; } //利用pre数组找到最长可整除子序列  reverse(res.begin(),res.end()); return res; } };   LeetCode 376. Wiggle Subsequence A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.\nFor example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.\nGiven a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.\nExamples: Input: [1,7,4,9,2,5].\nOutput: 6.\nThe entire sequence is a wiggle sequence.\nInput: [1,17,5,10,13,15,10,5,16,8].\nOutput: 7.\nThere are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].\nInput: [1,2,3,4,5,6,7,8,9].\nOutput: 2.\nFollow up: Can you do it in O(n) time?\n解析：\n给定了一个数组，需要我们来获得这个数组序列能够构成wiggle sequence最长子序列的长度。 所谓wiggle sequence：需要满足： 两个相邻元素后一项与前一项的差值是正负交替的； 0不算，即两个相邻元素相同是不算的；\n为了能够在O(n)时间内解决可以考虑使用贪心法. 举个例子: [1,17,5,10,13,15,10,5,16,8],\n可以看到前两个[1, 17]确定了一个递增的序列, 而[17, 5]构成了一个递减序列, 所以到目前位置都正常.\n到了[10, 13, 15]这里就有问题了, 他们和之前的5构成了一个递增序列, 而出于贪心的考虑, 必然是选择15是最优解, 因为这样给后面序列最大的选择空间. 对于接下来的[10, 5]都与之前的15构成递减区间, 同样道理我们选择5来构造这个序列. 所以一个基于贪心的算法大概就是这样了. 其时间复杂度为(n), 空间复杂度为O(1).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { public: int wiggleMaxLength(vectorint\u0026 nums) { if(nums.size()  2) return nums.size(); int len = nums.size(), ans = len, flag = 0; //ans初始值为len，然后根据贪心删除其中元素  for(int i = 1; i  len; i++) { if(nums[i]-nums[i-1] == 0) ans--; else if(nums[i]-nums[i-1]0) flag==1?ans--:flag=1; else if(nums[i]-nums[i-1]0) flag==-1?ans--:flag=-1; } return ans; } };   ",
  "wordCount" : "3665",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-24T20:26:24Z",
  "dateModified": "2017-06-24T20:26:24Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      最长上升子序列
    </h1>
    <div class="post-meta">June 24, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="leetcode-300-longest-increasing-subsequence">LeetCode 300. Longest Increasing Subsequence<a hidden class="anchor" aria-hidden="true" href="#leetcode-300-longest-increasing-subsequence">#</a></h1>
<p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p>For example,</p>
<p>Given [10, 9, 2, 5, 3, 7, 101, 18],</p>
<p>The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.</p>
<p>Your algorithm should run in O(n2) complexity.</p>
<p>Follow up: Could you improve it to O(n log n) time complexity?</p>
<p>解析：</p>
<p>贪心+二分查找可以将LIS问题的时间复杂度缩短到（nlogn）</p>
<p>维护一个单调递增子序列，它的关键原理在于，如果当前值小于单调递增子序列中的某个元素，则替换之，因为单调递增子序列能否增长，值取决于最后一个元素，替换内部的元素并不影响。</p>
<p>在1,3,5,2,8,4,6这个例子中，当到6时，一共可以有四种不同长度，且保证该升序序列在同长度升序序列中末尾最小的升序序列。</p>
<pre><code>(1)
1,(2)
1,3,(4)
1,3,5,(6)
</code></pre>
<p>注：每个序列的末尾数字加括号。</p>
<p>这些序列都是有可能成为最长递增子序列的候选者。</p>
<p>tail[i]表示长度为i的递增序列末尾的数字（如上1,2,4,6存在tail中）。</p>
<p>tail[]数组性质：tail[0] &lt; tail[1] &lt; … &lt; tail[n]</p>
<p>每次读入一个新元素时，可按照以下规则更新这些序列：</p>
<ol>
<li>
<p>nums[i]比所有递增序列的末尾都小,则长度为1的序列更新为这个更小的末尾。</p>
<p>如果读入数字0，则更新序列为：</p>
<pre><code> (0)
 1,(2)
 1,3,(4)
 1,3,5,(6)
</code></pre>
</li>
<li>
<p>nums[i]比所有序列的末尾都大,则直接将nums[i]加到当前最长序列的后面。</p>
<p>如果读入数字9，更新序列为：</p>
<pre><code> (1)
 1,(2)
 1,3,(4)
 1,3,5,(6)
 1,3,5,6,(9)
</code></pre>
</li>
<li>
<p>在中间，则更新那个末尾数字刚好大于等于nums[i]的那个序列，nums[i]替换其末尾数字。该情况下，利用二分搜索寻找。</p>
<p>如果读入数字3，更新序列为：</p>
<pre><code> (1)
 1,(2)
 1,3,(3)
 1,3,5,(6)
</code></pre>
</li>
</ol>
<p>可以利用lower_bound函数来优化代码，该函数返回第一个大于等于比较值的元素的迭代器，正好和情况1，3所需要的功能相对应。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">lengthOfLIS</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">res</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">it</span><span class="o">==</span><span class="n">res</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="k">else</span> <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">res</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>补充：普通DP方法</p>
<p>设数组dp[i]表示数组前面i个数中最大增长子数组的长度,枚举倒数第二个数</p>
<p>dp(j) = max { dp(i) + 1 : if nums[i] &lt; nums[j] , dp[j] }</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">dpOfLIS</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">//初始化设置dp[i]=1
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">ret</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="c1">//保存最终结果
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//枚举倒数第二个数
</span><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span><span class="c1">//可以更新dp值
</span><span class="c1"></span>                <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="n">ret</span><span class="p">)</span>
                    <span class="n">ret</span><span class="o">=</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>补充:</p>
<p>根据dp数组生成最长递增子序列。</p>
<p>解析:</p>
<p>接下来解释如何根据求出的dp数组得到最长递增子序列。</p>
<p>设:arr=[2，l，5,3,6,4,8,9,7],求出的数组 dp=[1，1，2,2,3,3,4,5,4]。</p>
<ol>
<li>
<p>遍历dp数组，找到最大值以及位置。在本例中最大值为5,位置为7,说明最终的最长递增子序列的长度为5,并且应该以arr[7]这个数(arr[7]=9)结尾。</p>
</li>
<li>
<p>从arr数组的位置7开始从右向左遍历。如果对某一个位置i,既有arr[i]&lt;arr[7],又有dp[i]==dp[7]-1,说明arr[i]可以作为最长递增子序列的倒数第二个数。在本例中，arr[6]&lt;arr[7],并且dp[6]=dp[7]-1,所以8应该作为最长递增子序列的倒数第二个数。</p>
</li>
<li>
<p>从arr数组的位置6开始继续向左遍历，按照同样的过程找到倒数第三个数。在本例中，位置5满足arr[5]&lt;arr[6],并且dp[5]=dp[6]-1,同时位置4也满足。选arr[5]或者arr[4]作为倒数第三个数都可以。</p>
</li>
<li>
<p>重复这样的过程，直到所有的数都找出来。</p>
</li>
</ol>
<p>dp数组包含每一步决策的信息，其实根据dp数组找出最长递增子序列的过程就是从某个位置开始逆序还原出决策路径的过程。具体过程请参看如下代码中的generateLIS方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">generateLIS</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dp</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">len</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
				<span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="kt">int</span><span class="o">[]</span> <span class="n">lis</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">len</span><span class="o">];</span>
		<span class="n">lis</span><span class="o">[--</span><span class="n">len</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">dp</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">lis</span><span class="o">[--</span><span class="n">len</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
				<span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">lis</span><span class="o">;</span>
	<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-334-increasing-triplet-subsequence">LeetCode 334. Increasing Triplet Subsequence<a hidden class="anchor" aria-hidden="true" href="#leetcode-334-increasing-triplet-subsequence">#</a></h1>
<p>Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.</p>
<p>Formally the function should:</p>
<p>Return true if there exists i, j, k</p>
<p>such that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.</p>
<p>Your algorithm should run in O(n) time complexity and O(1) space complexity.</p>
<p>Examples:</p>
<p>Given [1, 2, 3, 4, 5],</p>
<p>return true.</p>
<p>Given [5, 4, 3, 2, 1],</p>
<p>return false.</p>
<p>解析：</p>
<p>最长上升子序列的简化版，给定子序列长度，直接用最小值，次小值记录即可。</p>
<p>遍历更新最小的数和次小的数，如果某个数大于这两个数，则有三个数递增，返回true.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">bool</span> <span class="n">increasingTriplet</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">firstMin</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">secondMin</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">firstMin</span><span class="p">){</span>
            <span class="n">firstMin</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">secondMin</span><span class="p">){</span>
            <span class="n">secondMin</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-354-russian-doll-envelopes">LeetCode 354. Russian Doll Envelopes<a hidden class="anchor" aria-hidden="true" href="#leetcode-354-russian-doll-envelopes">#</a></h1>
<p>You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.</p>
<p>What is the maximum number of envelopes can you Russian doll? (put one inside other)</p>
<p>Example:</p>
<p>Given envelopes = [[5,4],[6,4],[6,7],[2,3]], the maximum number of envelopes you can Russian doll is 3 ([2,3] =&gt; [5,4] =&gt; [6,7]).</p>
<p>解析：</p>
<p>一个最长升序子串的变形，思路完全一样。</p>
<p>pair排序默认按照第一元素优先递增，第一元素相等则第二元素递增</p>
<p>如果按照默认的递增顺序排序，在width相同时，height是递增的，这样在二分查找时会将width相同的元素也认定为递增可以嵌套，不符合题目要求。如果width按递增顺序排列，而height在width相同时按递减顺序排列，这样在所有元素的height中找LIS即是最大嵌套层数。因为width相同的元素height是递减的，不会认定为递增序列，这就保证了width相同的元素至多有一个在LIS中</p>
<p>这道题因为可以任意变换信封的位置，而且之前已经进行过排序，所以不能使用单调栈</p>
<p>举例：原序列为1，5，8，3，6，7.<br>
开始1，5，8相继入栈，此时读到3，用3替换5，得到1，3，8；  <br>
再读6，用6替换8，得到1，3，6； <br>
再读7，得到最终栈为1，3，6，7。最长递增子序列为长度4。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">maxEnvelopes</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">envelopes</span><span class="p">)</span> 
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">envelopes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">envelopes</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">envelopes</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="n">b</span><span class="p">){</span>
                <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">first</span><span class="o">&lt;</span><span class="n">b</span><span class="p">.</span><span class="n">first</span> <span class="o">||</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">first</span><span class="o">==</span><span class="n">b</span><span class="p">.</span><span class="n">first</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">.</span><span class="n">second</span><span class="o">&gt;</span><span class="n">b</span><span class="p">.</span><span class="n">second</span><span class="p">);</span><span class="c1">//必须是一行语句
</span><span class="c1"></span>                <span class="p">});</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">collector</span><span class="p">;</span><span class="c1">//之前已经利用排序使宽度严格递增，此处用vector保存高度即可
</span><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">pair</span><span class="p">:</span> <span class="n">envelopes</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">collector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">collector</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">);</span><span class="c1">//二分法求高度大于pair的元素迭代器
</span><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="n">collector</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="n">collector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">);</span><span class="c1">//如果当前元素的高度最大，入栈
</span><span class="c1"></span>            <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span> <span class="o">&gt;</span> <span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">;</span><span class="c1">//如果不是最大的，进行替换，可以让序列变长的潜力增大
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="k">return</span> <span class="n">collector</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>补充:普通DP</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">maxenvelopes</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">envelopes</span><span class="p">)</span> 
<span class="p">{</span>
<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">envelopes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">sort</span><span class="p">(</span><span class="n">envelopes</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">envelopes</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="c1">//默认递增排序
</span><span class="c1"></span><span class="kt">int</span> <span class="n">maxrolls</span><span class="p">[</span><span class="n">size</span><span class="p">]{</span><span class="mi">0</span><span class="p">},</span> <span class="n">maxroll</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">maxrolls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">maxrolls</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">envelopes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="o">&gt;</span><span class="n">envelopes</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">first</span> <span class="o">&amp;&amp;</span> <span class="n">envelopes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="o">&gt;</span><span class="n">envelopes</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">second</span><span class="p">)</span>
            <span class="n">maxrolls</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxrolls</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">maxrolls</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">maxroll</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxroll</span><span class="p">,</span> <span class="n">maxrolls</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">maxroll</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-368-largest-divisible-subset">LeetCode 368. Largest Divisible Subset<a hidden class="anchor" aria-hidden="true" href="#leetcode-368-largest-divisible-subset">#</a></h1>
<p>Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.</p>
<p>If there are multiple solutions, return any subset is fine.</p>
<p>Example 1:</p>
<pre><code>nums: [1,2,3]

Result: [1,2] (of course, [1,3] will also be ok)
</code></pre>
<p>Example 2:</p>
<pre><code>nums: [1,2,4,8]

Result: [1,2,4,8]
</code></pre>
<p>解析：</p>
<p>将这些数按从小到大的顺序排列，问题转换为了类似于最长不下降子序列的DP。</p>
<p>为了找出最大结果, 所以我们还需要记录一下路径, 每一个数字, 我们记录第一个能够使其到达最大长度的父结点, 最后回溯一下即可.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">largestDivisibleSubset</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ansi</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">dp</span><span class="o">=</span><span class="n">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">len</span><span class="p">];</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">pre</span><span class="o">=</span><span class="n">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">len</span><span class="p">];</span><span class="c1">//用于保存最长可整除序列的路径（利用前驱节点）
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="c1">//扫描数组
</span><span class="c1"></span>        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//dp[i]表示扫描到位置i的最优解
</span><span class="c1"></span>        <span class="n">pre</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">%</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">&gt;</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span><span class="c1">//查找前面的符合元素
</span><span class="c1"></span>                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
                <span class="n">pre</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span><span class="c1">//维护前驱节点
</span><span class="c1"></span>            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ans</span><span class="p">){</span><span class="c1">//更新结果和终点
</span><span class="c1"></span>            <span class="n">ans</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">ansi</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">ans</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">ansi</span><span class="p">]);</span> <span class="n">ansi</span> <span class="o">=</span> <span class="n">pre</span><span class="p">[</span><span class="n">ansi</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="c1">//利用pre数组找到最长可整除子序列
</span><span class="c1"></span>    <span class="n">reverse</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">res</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-376-wiggle-subsequence">LeetCode 376. Wiggle Subsequence<a hidden class="anchor" aria-hidden="true" href="#leetcode-376-wiggle-subsequence">#</a></h1>
<p>A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.</p>
<p>For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.</p>
<p>Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.</p>
<p>Examples: <br>
Input: [1,7,4,9,2,5].<br>
Output: 6.<br>
The entire sequence is a wiggle sequence.</p>
<p>Input: [1,17,5,10,13,15,10,5,16,8].<br>
Output: 7.<br>
There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].</p>
<p>Input: [1,2,3,4,5,6,7,8,9].<br>
Output: 2.<br>
Follow up: <br>
Can you do it in O(n) time?</p>
<p>解析：</p>
<p>给定了一个数组，需要我们来获得这个数组序列能够构成wiggle   sequence最长子序列的长度。
所谓wiggle sequence：需要满足： <br>
两个相邻元素后一项与前一项的差值是正负交替的； <br>
0不算，即两个相邻元素相同是不算的；</p>
<p>为了能够在O(n)时间内解决可以考虑使用贪心法. 举个例子: [1,17,5,10,13,15,10,5,16,8],<br>
可以看到前两个[1, 17]确定了一个递增的序列, 而[17, 5]构成了一个递减序列, 所以到目前位置都正常.</p>
<p>到了[10, 13, 15]这里就有问题了, 他们和之前的5构成了一个递增序列, 而出于贪心的考虑, 必然是选择15是最优解, 因为这样给后面序列最大的选择空间. 对于接下来的[10, 5]都与之前的15构成递减区间, 同样道理我们选择5来构造这个序列. 所以一个基于贪心的算法大概就是这样了. 其时间复杂度为(n), 空间复杂度为O(1).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>  
<span class="nl">public</span><span class="p">:</span>  
<span class="kt">int</span> <span class="n">wiggleMaxLength</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>  
    <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>  
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">len</span><span class="p">,</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">//ans初始值为len，然后根据贪心删除其中元素
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">ans</span><span class="o">--</span><span class="p">;</span>  
        <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">flag</span><span class="o">==</span><span class="mi">1</span><span class="o">?</span><span class="n">ans</span><span class="o">--:</span><span class="n">flag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>  
        <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">flag</span><span class="o">==-</span><span class="mi">1</span><span class="o">?</span><span class="n">ans</span><span class="o">--:</span><span class="n">flag</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>  
    <span class="p">}</span>  
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>  
<span class="p">}</span>  
<span class="p">};</span>  
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/greedy/">Greedy</a></li>
      <li><a href="/tags/hash/">Hash</a></li>
      <li><a href="/tags/dp/">DP</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
