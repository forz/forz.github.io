<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go协程池ants介绍 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author"
  content="Forz" /><meta name="description" content="简介 处理大量并发是 Go 语言的一大优势。语言内置了方便的并发语法，可以非常方便的创建很多个轻量级的 goroutine 并发处理任务。相比于创建多个线程，gorou" /><meta name="keywords"
  content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.84.4 with theme even" />


<link rel="canonical" href="/post/go%E5%8D%8F%E7%A8%8B%E6%B1%A0ants%E4%BB%8B%E7%BB%8D/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link rel="stylesheet" href="/css/search.css" />


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go协程池ants介绍" />
<meta property="og:description" content="简介 处理大量并发是 Go 语言的一大优势。语言内置了方便的并发语法，可以非常方便的创建很多个轻量级的 goroutine 并发处理任务。相比于创建多个线程，gorou" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E5%8D%8F%E7%A8%8B%E6%B1%A0ants%E4%BB%8B%E7%BB%8D/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-07-08T15:05:53+00:00" />
<meta property="article:modified_time" content="2021-07-08T15:05:53+00:00" />

<meta itemprop="name" content="Go协程池ants介绍">
<meta itemprop="description" content="简介 处理大量并发是 Go 语言的一大优势。语言内置了方便的并发语法，可以非常方便的创建很多个轻量级的 goroutine 并发处理任务。相比于创建多个线程，gorou"><meta itemprop="datePublished" content="2021-07-08T15:05:53+00:00" />
<meta itemprop="dateModified" content="2021-07-08T15:05:53+00:00" />
<meta itemprop="wordCount" content="4985">
<meta itemprop="keywords" content="Go," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go协程池ants介绍"/>
<meta name="twitter:description" content="简介 处理大量并发是 Go 语言的一大优势。语言内置了方便的并发语法，可以非常方便的创建很多个轻量级的 goroutine 并发处理任务。相比于创建多个线程，gorou"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="clearfix">
  <div class="logo-wrapper">
    <a href="/" class="logo">Forz Blog</a>
  </div>

  <nav class="site-navbar">
    <ul id="menu" class="menu">
      <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
    </ul>
  </nav>
</div>


<div class="search-container">
  <div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="Search for titles or URIs..."
        name="search" autocomplete="off" />
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path
            d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js"></script>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js"></script>
<script>
    var client = algoliasearch("IAR2EF5L65", "b4b9da2eba53aa6dabe4b8ac9e8676e1");
    var index = client.initIndex('forz.forzvina.com');
    autocomplete('#aa-search-input',
        { hint: false }, {
        source: autocomplete.sources.hits(index, { hitsPerPage: 8 }),
        displayKey: 'name',
        templates: {
            suggestion: function (suggestion) {
                var reg = /([A-Z]+)/ig
                var title = suggestion.uri.replace(reg, function (m) {
                    return m.toLowerCase()
                })
                return '<span class="search-item">' + '<a href="\/' + title + '">' +
                    suggestion._highlightResult.title.value + '</a></span>';
            }
        }
    });
</script>
</div>


    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go协程池ants介绍</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-07-08 </span>
        <div class="post-category">
            <a href="/categories/go/"> Go </a>
            </div>
          <span class="more-meta"> 约 4985 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#简介">简介</a></li>
    <li><a href="#快速使用">快速使用</a></li>
    <li><a href="#函数作为任务">函数作为任务</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="简介">简介</h2>
<p>处理大量并发是 Go 语言的一大优势。语言内置了方便的并发语法，可以非常方便的创建很多个轻量级的 goroutine 并发处理任务。相比于创建多个线程，goroutine 更轻量、资源占用更少、切换速度更快、无线程上下文切换开销更少。但是受限于资源总量，系统中能够创建的 goroutine 数量也是受限的。默认每个 goroutine 占用 8KB 内存，一台 8GB 内存的机器满打满算也只能创建 8GB/8KB = 1000000 个 goroutine，更何况系统还需要保留一部分内存运行日常管理任务，go 运行时需要内存运行 gc、处理 goroutine 切换等。使用的内存超过机器内存容量，系统会使用交换区（swap），导致性能急速下降。我们可以简单验证一下创建过多 goroutine 会发生什么：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
  <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">10000000</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10000000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span><span class="p">)</span>
    <span class="p">}()</span>
  <span class="p">}</span>
  <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在我的机器上（8G内存）运行上面的程序会报<code>errno 1455</code>，即<code>Out of Memory</code>错误，这很好理解。谨慎运行。</p>
<p>另一方面，goroutine 的管理也是一个问题。goroutine 只能自己运行结束，外部没有任何手段可以强制j结束一个 goroutine。如果一个 goroutine 因为某种原因没有自行结束，就会出现 goroutine 泄露。此外，频繁创建 goroutine 也是一个开销。</p>
<p>鉴于上述原因，自然出现了与线程池一样的需求，即 goroutine 池。一般的 goroutine 池自动管理 goroutine 的生命周期，可以按需创建，动态缩容。向 goroutine 池提交一个任务，goroutine 池会自动安排某个 goroutine 来处理。</p>
<p>ants就是其中一个实现 goroutine 池的库。</p>
<h2 id="快速使用">快速使用</h2>
<p>本文代码使用 Go Modules。</p>
<p>创建目录并初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-s" data-lang="s"><span class="n">mkdir</span> <span class="n">ants</span> <span class="o">&amp;&amp;</span> <span class="n">cd</span> <span class="n">ants</span>
<span class="n">go</span> <span class="n">mod</span> <span class="n">init</span> <span class="n">github.com</span><span class="o">/</span><span class="n">darjun</span><span class="o">/</span><span class="n">go</span><span class="o">-</span><span class="n">daily</span><span class="o">-</span><span class="n">lib</span><span class="o">/</span><span class="n">ants</span>
</code></pre></td></tr></table>
</div>
</div><p>安装ants库，使用v2版本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-s" data-lang="s"><span class="n">go</span> <span class="n">get</span> <span class="o">-</span><span class="n">u</span> <span class="n">github.com</span><span class="o">/</span><span class="n">panjf2000</span><span class="o">/</span><span class="n">ants</span><span class="o">/</span><span class="n">v2</span>
</code></pre></td></tr></table>
</div>
</div><p>我们接下来要实现一个计算大量整数和的程序。首先创建基础的任务结构，并实现其执行任务方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Task</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">index</span> <span class="kt">int</span>
  <span class="nx">nums</span>  <span class="p">[]</span><span class="kt">int</span>
  <span class="nx">sum</span>   <span class="kt">int</span>
  <span class="nx">wg</span>    <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Task</span><span class="p">)</span> <span class="nf">Do</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">num</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">t</span><span class="p">.</span><span class="nx">nums</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">sum</span> <span class="o">+=</span> <span class="nx">num</span>
  <span class="p">}</span>

  <span class="nx">t</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>很简单，就是将一个切片中的所有整数相加。</p>
<p>然后我们创建 goroutine 池，注意池使用完后需要手动关闭，这里使用defer关闭：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">p</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ants</span><span class="p">.</span><span class="nf">NewPoolWithFunc</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nx">taskFunc</span><span class="p">)</span>
<span class="k">defer</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Release</span><span class="p">()</span>

<span class="kd">func</span> <span class="nf">taskFunc</span><span class="p">(</span><span class="nx">data</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
  <span class="nx">task</span> <span class="o">:=</span> <span class="nx">data</span><span class="p">.(</span><span class="o">*</span><span class="nx">Task</span><span class="p">)</span>
  <span class="nx">task</span><span class="p">.</span><span class="nf">Do</span><span class="p">()</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;task:%d sum:%d\n&#34;</span><span class="p">,</span> <span class="nx">task</span><span class="p">.</span><span class="nx">index</span><span class="p">,</span> <span class="nx">task</span><span class="p">.</span><span class="nx">sum</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面调用了<code>ants.NewPoolWithFunc()</code>创建了一个 goroutine 池。第一个参数是池容量，即池中最多有 10 个 goroutine。第二个参数为每次执行任务的函数。当我们调用<code>p.Invoke(data)</code>的时候，ants池会在其管理的 goroutine 中找出一个空闲的，让它执行函数taskFunc，并将data作为参数。</p>
<p>接着，我们模拟数据，做数据切分，生成任务，交给 ants 处理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
  <span class="nx">DataSize</span>    <span class="p">=</span> <span class="mi">10000</span>
  <span class="nx">DataPerTask</span> <span class="p">=</span> <span class="mi">100</span>
<span class="p">)</span>

<span class="nx">nums</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">DataSize</span><span class="p">,</span> <span class="nx">DataSize</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span> <span class="p">{</span>
  <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">DataSize</span> <span class="o">/</span> <span class="nx">DataPerTask</span><span class="p">)</span>
<span class="nx">tasks</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">Task</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">DataSize</span><span class="o">/</span><span class="nx">DataPerTask</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">DataSize</span><span class="o">/</span><span class="nx">DataPerTask</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">task</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Task</span><span class="p">{</span>
    <span class="nx">index</span><span class="p">:</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nx">nums</span><span class="p">:</span>  <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">*</span><span class="nx">DataPerTask</span> <span class="p">:</span> <span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nx">DataPerTask</span><span class="p">],</span>
    <span class="nx">wg</span><span class="p">:</span>    <span class="o">&amp;</span><span class="nx">wg</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="nx">tasks</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">tasks</span><span class="p">,</span> <span class="nx">task</span><span class="p">)</span>
  <span class="nx">p</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(</span><span class="nx">task</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;running goroutines: %d\n&#34;</span><span class="p">,</span> <span class="nx">ants</span><span class="p">.</span><span class="nf">Running</span><span class="p">())</span>
</code></pre></td></tr></table>
</div>
</div><p>随机生成 10000 个整数，将这些整数分为 100 份，每份 100 个，生成Task结构，调用<code>p.Invoke(task)</code>处理。<code>wg.Wait()</code>等待处理完成，然后输出ants正在运行的 goroutine 数量，这时应该是 0。</p>
<p>最后我们将结果汇总，并验证一下结果，与直接相加得到的结果做一个比较：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">sum</span> <span class="kt">int</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">task</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tasks</span> <span class="p">{</span>
  <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">task</span><span class="p">.</span><span class="nx">sum</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">expect</span> <span class="kt">int</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">num</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span> <span class="p">{</span>
  <span class="nx">expect</span> <span class="o">+=</span> <span class="nx">num</span>
<span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;finish all tasks, result is %d expect:%d\n&#34;</span><span class="p">,</span> <span class="nx">sum</span><span class="p">,</span> <span class="nx">expect</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>运行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">run</span> <span class="n">main.go</span>
<span class="kc">...</span>
<span class="n">task</span><span class="o">:</span><span class="m">96</span> <span class="n">sum</span><span class="o">:</span><span class="m">53275</span>
<span class="n">task</span><span class="o">:</span><span class="m">88</span> <span class="n">sum</span><span class="o">:</span><span class="m">50090</span>
<span class="n">task</span><span class="o">:</span><span class="m">62</span> <span class="n">sum</span><span class="o">:</span><span class="m">57114</span>
<span class="n">task</span><span class="o">:</span><span class="m">45</span> <span class="n">sum</span><span class="o">:</span><span class="m">48041</span>
<span class="n">task</span><span class="o">:</span><span class="m">82</span> <span class="n">sum</span><span class="o">:</span><span class="m">45269</span>
<span class="n">running</span> <span class="n">goroutines</span><span class="o">:</span> <span class="m">0</span>
<span class="n">finish</span> <span class="n">all</span> <span class="n">tasks</span><span class="p">,</span> <span class="n">result</span> <span class="n">is</span> <span class="m">5010172</span> <span class="n">expect</span><span class="o">:</span><span class="m">5010172</span>
</code></pre></td></tr></table>
</div>
</div><p>确实，任务完成之后，正在运行的 goroutine 数量变为 0。而且我们验证了，结果没有偏差。另外需要注意，goroutine 池中任务的执行顺序是随机的，与提交任务的先后没有关系。由上面运行打印的任务标识我们也能发现这一点。
k8s-jiaoxuegongju-inner</p>
<h2 id="函数作为任务">函数作为任务</h2>
<p>ants支持将一个不接受任何参数的函数作为任务提交给 goroutine 运行。由于不接受参数，我们提交的函数要么不需要外部数据，只需要处理自身逻辑，否则就必须用某种方式将需要的数据传递进去，例如闭包。</p>
<p>提交函数作为任务的 goroutine 池使用<code>ants.NewPool()</code>创建，它只接受一个参数表示池子的容量。调用池子对象的<code>Submit()</code>方法来提交任务，将一个不接受任何参数的函数传入。</p>
<p>最开始的例子可以改写一下。增加一个任务包装函数，将任务需要的参数作为包装函数的参数。包装函数返回实际的任务函数，该任务函数就可以通过闭包访问它需要的数据了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">taskFunc</span> <span class="kd">func</span><span class="p">()</span>

<span class="kd">func</span> <span class="nf">taskFuncWrapper</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">sum</span> <span class="o">*</span><span class="kt">int</span><span class="p">,</span> <span class="nx">wg</span><span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nx">taskFunc</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">num</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">*</span><span class="nx">DataPerTask</span> <span class="p">:</span> <span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nx">DataPerTask</span><span class="p">]</span> <span class="p">{</span>
      <span class="o">*</span><span class="nx">sum</span> <span class="o">+=</span> <span class="nx">num</span>
    <span class="p">}</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;task:%d sum:%d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="nx">sum</span><span class="p">)</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>调用<code>ants.NewPool(10)</code>创建 goroutine 池，同样池子用完需要释放，这里使用defer：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">p</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ants</span><span class="p">.</span><span class="nf">NewPool</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="k">defer</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Release</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>生成模拟数据，切分任务。提交任务给ants池执行，这里使用<code>taskFuncWrapper()</code>包装函数生成具体的任务，然后调用p.Submit()提交：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">nums</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">DataSize</span><span class="p">,</span> <span class="nx">DataSize</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span> <span class="p">{</span>
  <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">DataSize</span> <span class="o">/</span> <span class="nx">DataPerTask</span><span class="p">)</span>
<span class="nx">partSums</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">DataSize</span><span class="o">/</span><span class="nx">DataPerTask</span><span class="p">,</span> <span class="nx">DataSize</span><span class="o">/</span><span class="nx">DataPerTask</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">DataSize</span><span class="o">/</span><span class="nx">DataPerTask</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">p</span><span class="p">.</span><span class="nf">Submit</span><span class="p">(</span><span class="nf">taskFuncWrapper</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">partSums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">))</span>
<span class="p">}</span>
<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>汇总结果，验证：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">sum</span> <span class="kt">int</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">partSum</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">partSums</span> <span class="p">{</span>
  <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">partSum</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">expect</span> <span class="kt">int</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">num</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span> <span class="p">{</span>
  <span class="nx">expect</span> <span class="o">+=</span> <span class="nx">num</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;running goroutines: %d\n&#34;</span><span class="p">,</span> <span class="nx">ants</span><span class="p">.</span><span class="nf">Running</span><span class="p">())</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;finish all tasks, result is %d expect is %d\n&#34;</span><span class="p">,</span> <span class="nx">sum</span><span class="p">,</span> <span class="nx">expect</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这个程序的功能与最开始的完全相同。</p>
<p>执行流程
GitHub 仓库中有个执行流程图，我重新绘制了一下：</p>
<p>图片
执行流程如下：</p>
<p>初始化 goroutine 池；
提交任务给 goroutine 池，检查是否有空闲的 goroutine：
已到上限，检查 goroutine 池是否是非阻塞的：
未到上限，创建一个新的 goroutine 处理任务
非阻塞，直接返回nil表示执行失败
阻塞，等待 goroutine 空闲
有，获取空闲 goroutine
无，检查池中的 goroutine 数量是否已到池容量上限：
任务处理完成，将 goroutine 交还给池，以待处理下一个任务
选项
ants提供了一些选项可以定制 goroutine 池的行为。选项使用Options结构定义：</p>
<p>// src/github.com/panjf2000/ants/options.go
type Options struct {
ExpiryDuration time.Duration
PreAlloc bool
MaxBlockingTasks int
Nonblocking bool
PanicHandler func(interface{})
Logger Logger
}
各个选项含义如下：</p>
<p>ExpiryDuration：过期时间。表示 goroutine 空闲多长时间之后会被ants池回收
PreAlloc：预分配。调用NewPool()/NewPoolWithFunc()之后预分配worker（管理一个工作 goroutine 的结构体）切片。而且使用预分配与否会直接影响池中管理worker的结构。见下面源码
MaxBlockingTasks：最大阻塞任务数量。即池中 goroutine 数量已到池容量，且所有 goroutine 都处理繁忙状态，这时到来的任务会在阻塞列表等待。这个选项设置的是列表的最大长度。阻塞的任务数量达到这个值后，后续任务提交直接返回失败
Nonblocking：池是否阻塞，默认阻塞。提交任务时，如果ants池中 goroutine 已到上限且全部繁忙，阻塞的池会将任务添加的阻塞列表等待（当然受限于阻塞列表长度，见上一个选项）。非阻塞的池直接返回失败
PanicHandler：panic 处理。遇到 panic 会调用这里设置的处理函数
Logger：指定日志记录器
NewPool()部分源码：</p>
<p>if p.options.PreAlloc {
if size == -1 {
return nil, ErrInvalidPreAllocSize
}
p.workers = newWorkerArray(loopQueueType, size)
} else {
p.workers = newWorkerArray(stackType, 0)
}
使用预分配时，创建loopQueueType类型的结构，反之创建stackType类型。这是ants定义的两种管理worker的数据结构。</p>
<p>ants定义了一些With*函数来设置这些选项：</p>
<p>func WithOptions(options Options) Option {
return func(opts *Options) {
*opts = options
}
}</p>
<p>func WithExpiryDuration(expiryDuration time.Duration) Option {
return func(opts *Options) {
opts.ExpiryDuration = expiryDuration
}
}</p>
<p>func WithPreAlloc(preAlloc bool) Option {
return func(opts *Options) {
opts.PreAlloc = preAlloc
}
}</p>
<p>func WithMaxBlockingTasks(maxBlockingTasks int) Option {
return func(opts *Options) {
opts.MaxBlockingTasks = maxBlockingTasks
}
}</p>
<p>func WithNonblocking(nonblocking bool) Option {
return func(opts *Options) {
opts.Nonblocking = nonblocking
}
}</p>
<p>func WithPanicHandler(panicHandler func(interface{})) Option {
return func(opts *Options) {
opts.PanicHandler = panicHandler
}
}</p>
<p>func WithLogger(logger Logger) Option {
return func(opts *Options) {
opts.Logger = logger
}
}
这里使用了 Go 语言中非常常见的一种模式，我称之为选项模式，非常方便地构造有大量参数，且大部分有默认值或一般不需要显式设置的对象。</p>
<p>我们来验证几个选项。</p>
<p>最大等待队列长度
ants池设置容量之后，如果所有的 goroutine 都在处理任务。这时提交的任务默认会进入等待队列，WithMaxBlockingTasks(maxBlockingTasks int)可以设置等待队列的最大长度。超过这个长度，提交任务直接返回错误：</p>
<p>func wrapper(i int, wg <em>sync.WaitGroup) func() {
return func() {
fmt.Printf(&ldquo;hello from task:%d\n&rdquo;, i)
time.Sleep(1</em> time.Second)
wg.Done()
}
}</p>
<p>func main() {
p, _ := ants.NewPool(4, ants.WithMaxBlockingTasks(2))
defer p.Release()</p>
<p>var wg sync.WaitGroup
wg.Add(8)
for i := 1; i &lt;= 8; i++ {
go func(i int) {
err := p.Submit(wrapper(i, &amp;wg))
if err != nil {
fmt.Printf(&ldquo;task:%d err:%v\n&rdquo;, i, err)
wg.Done()
}
}(i)
}</p>
<p>wg.Wait()
}
上面代码中，我们设置 goroutine 池的容量为 4，最大阻塞队列长度为 2。然后一个 for 提交 8 个任务，期望结果是：4 个任务在执行，2 个任务在等待，2 个任务提交失败。运行结果：</p>
<p>hello from task:8
hello from task:5
hello from task:4
hello from task:6
task:7 err:too many goroutines blocked on submit or Nonblocking is set
task:3 err:too many goroutines blocked on submit or Nonblocking is set
hello from task:1
hello from task:2
我们看到提交任务失败，打印too many goroutines blocked &hellip;。</p>
<p>代码中有 4 点需要注意：</p>
<p>提交任务必须并行进行。如果是串行提交，第 5 个任务提交时由于池中没有空闲的 goroutine 处理该任务，Submit()方法会被阻塞，后续任务就都不能提交了。也就达不到验证的目的了
由于任务可能提交失败，失败的任务不会实际执行，所以实际上wg.Done()次数会小于 8。因而在err != nil分支中我们需要调用一次wg.Done()。否则wg.Wait()会永远阻塞
为了避免任务执行过快，空出了 goroutine，观察不到现象，每个任务中我使用time.Sleep(1 * time.Second)休眠 1s
由于 goroutine 之间的执行顺序未显式同步，故每次执行的顺序不确定
由于简单起见，前面的例子中Submit()方法的返回值都被我们忽略了。实际开发中一定不要忽略。</p>
<p>非阻塞
ants池默认是阻塞的，我们可以使用WithNonblocking(nonblocking bool)设置其为非阻塞。非阻塞的ants池中，在所有 goroutine 都在处理任务时，提交新任务会直接返回错误：</p>
<p>func main() {
p, _ := ants.NewPool(2, ants.WithNonblocking(true))
defer p.Release()</p>
<p>var wg sync.WaitGroup
wg.Add(3)
for i := 1; i &lt;= 3; i++ {
err := p.Submit(wrapper(i, &amp;wg))
if err != nil {
fmt.Printf(&ldquo;task:%d err:%v\n&rdquo;, i, err)
wg.Done()
}
}</p>
<p>wg.Wait()
}
使用上个例子中的wrapper()函数，ants池容量设置为 2。连续提交 3 个任务，期望结果前两个任务正常执行，第 3 个任务提交时返回错误：</p>
<p>hello from task:2
task:3 err:too many goroutines blocked on submit or Nonblocking is set
hello from task:1
panic 处理器
一个鲁棒性强的库一定不会忽视错误的处理，特别是宕机相关的错误。在 Go 语言中就是 panic，也被称为运行时恐慌，在程序运行的过程中产生的严重性错误，例如索引越界，空指针解引用等，都会触发 panic。如果不处理 panic，程序会直接意外退出，可能造成数据丢失的严重后果。</p>
<p>ants中如果 goroutine 在执行任务时发生panic，会终止当前任务的执行，将发生错误的堆栈输出到os.Stderr。注意，该 goroutine 还是会被放回池中，下次可以取出执行新的任务。</p>
<p>func wrapper(i int, wg *sync.WaitGroup) func() {
return func() {
fmt.Printf(&ldquo;hello from task:%d\n&rdquo;, i)
if i%2 == 0 {
panic(fmt.Sprintf(&ldquo;panic from task:%d&rdquo;, i))
}
wg.Done()
}
}</p>
<p>func main() {
p, _ := ants.NewPool(2)
defer p.Release()</p>
<p>var wg sync.WaitGroup
wg.Add(3)
for i := 1; i &lt;= 2; i++ {
p.Submit(wrapper(i, &amp;wg))
}</p>
<p>time.Sleep(1 * time.Second)
p.Submit(wrapper(3, &amp;wg))
p.Submit(wrapper(5, &amp;wg))
wg.Wait()
}
我们让偶数个任务触发panic。提交两个任务，第二个任务一定会触发panic。触发panic之后，我们还可以继续提交任务 3、5。注意这里没有 4，提交任务 4 还是会触发panic。</p>
<p>上面的程序需要注意 2 点：</p>
<p>任务函数中wg.Done()是在panic方法之后，如果触发了panic，函数中的其他正常逻辑就不会再继续执行了。所以我们虽然wg.Add(3)，但是一共提交了 4 个任务，其中一个任务触发了panic，wg.Done()没有正确执行。实际开发中，我们一般使用defer语句来确保wg.Done()一定会执行
在 for 循环之后，我添加了一行代码time.Sleep(1 * time.Second)。如果没有这一行，后续的两条Submit()方法可以直接执行，可能会导致任务很快就完成了，wg.Wait()直接返回了，这时panic的堆栈还没有输出。你可以尝试注释掉这行代码运行看看结果
除了ants提供的默认 panic 处理器，我们还可以使用WithPanicHandler(paincHandler func(interface{}))指定我们自己编写的 panic 处理器。处理器的参数就是传给panic的值：</p>
<p>func panicHandler(err interface{}) {
fmt.Fprintln(os.Stderr, err)
}</p>
<p>p, _ := ants.NewPool(2, ants.WithPanicHandler(panicHandler))
defer p.Release()
其余代码与上面的完全相同，指定了panicHandler后触发panic就会执行它。运行：</p>
<p>hello from task:2
panic from task:2
hello from task:1
hello from task:5
hello from task:3
看到输出了传给panic函数的字符串（第二行输出）。</p>
<p>默认池
为了方便使用，很多 Go 库都喜欢提供其核心功能类型的一个默认实现。可以直接通过库提供的接口调用。例如net/http，例如ants。ants库中定义了一个默认的池，默认容量为MaxInt32。goroutine 池的各个方法都可以直接通过ants包直接访问：</p>
<p>// src/github.com/panjf2000/ants/ants.go
defaultAntsPool, _ = NewPool(DefaultAntsPoolSize)</p>
<p>func Submit(task func()) error {
return defaultAntsPool.Submit(task)
}</p>
<p>func Running() int {
return defaultAntsPool.Running()
}</p>
<p>func Cap() int {
return defaultAntsPool.Cap()
}</p>
<p>func Free() int {
return defaultAntsPool.Free()
}</p>
<p>func Release() {
defaultAntsPool.Release()
}</p>
<p>func Reboot() {
defaultAntsPool.Reboot()
}
直接使用：</p>
<p>func main() {
defer ants.Release()</p>
<p>var wg sync.WaitGroup
wg.Add(2)
for i := 1; i &lt;= 2; i++ {
ants.Submit(wrapper(i, &amp;wg))
}
wg.Wait()
}
默认池也需要Release()。</p>
<p>总结
本文介绍了 goroutine 池的由来，并借由ants库介绍了基本的使用方法，和一些细节。ants源码不多，去掉测试的核心代码只有 1k 行左右，建议有时间、感兴趣的童鞋深入阅读。</p>
<p>大家如果发现好玩、好用的 Go 语言库，欢迎到 Go 每日一库 GitHub 上提交 issue😄</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-07-08
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go/">Go</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go的函数式编程</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84map%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
            <span class="next-text nav-default">基本数据结构map源码剖析</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Forz</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
