<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go中的内置类型转换 | Forz Blog</title>
<meta name="keywords" content="Go" />
<meta name="description" content="隐型转换 转换是T（x）形式的表达式，其中T是类型，x是可以转换为类型T的表达式。 1 Conversion = Type &#34;(&#34; Expression [ &#34;,&#34; ] &#34;)&#34; . 如果类型以operator *或&lt;">
<meta name="author" content="">
<link rel="canonical" href="/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Go中的内置类型转换" />
<meta property="og:description" content="隐型转换 转换是T（x）形式的表达式，其中T是类型，x是可以转换为类型T的表达式。 1 Conversion = Type &#34;(&#34; Expression [ &#34;,&#34; ] &#34;)&#34; . 如果类型以operator *或&lt;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-01-26T21:22:18&#43;00:00" />
<meta property="article:modified_time" content="2019-01-26T21:22:18&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go中的内置类型转换"/>
<meta name="twitter:description" content="隐型转换 转换是T（x）形式的表达式，其中T是类型，x是可以转换为类型T的表达式。 1 Conversion = Type &#34;(&#34; Expression [ &#34;,&#34; ] &#34;)&#34; . 如果类型以operator *或&lt;"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Go中的内置类型转换",
      "item": "/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go中的内置类型转换",
  "name": "Go中的内置类型转换",
  "description": "隐型转换 转换是T（x）形式的表达式，其中T是类型，x是可以转换为类型T的表达式。 1 Conversion = Type \u0026#34;(\u0026#34; Expression [ \u0026#34;,\u0026#34; ] \u0026#34;)\u0026#34; . 如果类型以operator *或\u0026lt;",
  "keywords": [
    "Go"
  ],
  "articleBody": "隐型转换 转换是T（x）形式的表达式，其中T是类型，x是可以转换为类型T的表达式。\n1  Conversion = Type \"(\" Expression [ \",\" ] \")\" .   如果类型以operator *或1 2 3 4 5 6 7 8  *Point(p) // same as *(Point(p)) (*Point)(p) // p is converted to *Point chan int(c) // same as (chan int)(c) // c is converted to func()(x) // function signature func() x (func())(x) // x is converted to func() (func() int)(x) // x is converted to func() int func() int(x) // x is converted to func() int (unambiguous)   如果x可由T表示，则常数值x可以转换为类型T.作为特殊情况，可以使用与非常数x相同的规则将整数常量x转换为字符串类型。\n转换常量会产生类型常量作为结果。\n1 2 3 4 5 6 7 8 9 10 11 12  uint(iota) // iota value of type uint float32(2.718281828) // 2.718281828 of type float32 complex128(1) // 1.0 + 0.0i of type complex128 float32(0.49999999) // 0.5 of type float32 float64(-1e-1000) // 0.0 of type float64 string('x') // \"x\" of type string string(0x266c) // \"♬\" of type string MyString(\"foo\" + \"bar\") // \"foobar\" of type MyString string([]byte{'a'}) // not a constant: []byte{'a'} is not a constant (*int)(nil) // not a constant: nil is not a constant, *int is not a boolean, numeric, or string type int(1.2) // illegal: 1.2 cannot be represented as an int string(65.0) // illegal: 65.0 is not an integer constant   对于一个常量值x, 如果能转换成T类型的值，它需要满足下面的条件之一:\n x可赋予T. 忽略struct标签（见下文），x的类型和T具有相同的底层类型。 忽略struct标签（见下文），x类型和T都是未命名的指针类型，它们的指针指向的对象类型一致 x的类型和T都是整数或浮点类型。 x的类型和T都是复杂类型。 x是整数或slice of byte、slice of rune，T是字符串类型。 x是字符串，T是slice of byte、slice of rune  为了转换的目的，在比较结构类型的标识时，会忽略结构标记：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  type Person struct { Name string Address *struct { Street string City string } } var data *struct { Name string `json:\"name\"` Address *struct { Street string `json:\"street\"` City string `json:\"city\"` } `json:\"address\"` } var person = (*Person)(data) // ignoring tags, the underlying types are identical   特定规则适用于数字类型之间或字符串类型之间的（非常量）转换。这些转换可能会更改x的表示形式并产生运行时成本。所有其他转换仅更改类型，但不更改x的表示。\n没有语言机制来在指针和整数之间进行转换。软件包unsafe在受限情况下实现此功能。\n数值类型之间的转换 非常量的数值之间的转换遵循下面三条原则:\n  整数之间的转换时，如果值是有符号的整数，它的符号位会扩展无限大，否则零扩展，然后它会被删减以适合结果类型。对于无符号数v: v := uint16(0x10F0),如果进行转换uint32(int8(v)),可以看到它的结果是0xFFFFFFF0，不会有溢出指示或者错误。\n1 2 3 4 5 6 7 8  v1 := uint16(0x10F0) fmt.Printf(\"%d=%b\\n\", v1, v1) //4336=1000011110000 v2 := int8(v1) fmt.Printf(\"%d=%b\\n\", v2, v2) //-16=-10000 v3 := uint16(v2) fmt.Printf(\"%d=%b\\n\", v3, v3) //65520=1111111111110000 v4 := int16(v2) fmt.Printf(\"%d=%b\\n\", v4, v4) //-16=-10000   介绍一下。 对于v1,它是一个无符号的整数， 要把它转为有符号的int8，那么我们只看v1的后8位:\n1  1111 0000   不幸的是，这个8位的最高位是1,我们会把它作为符号位，所以v2是个负数，那么11110000就是这个负数的补码，\n那么它的原码是多少呢，计算补码的补码就是负数的原码:1001 0000,所以它是-16。如果最高位是0，简单了，本身就是它的原码。\n再看v2转v3， 也就是有符号整数转无符号整数。v2是负数，内部表示为11110000,因为要扩展为16位，将符号位1扩展到最高位1111 1111 1111 0000,因为它是无符号整数，所 以这个值整数的值65520。\n你可以把v1值的值改为0xff60看看输出是什么？此时转换不会符号位为负数的情况。\n1 2 3 4  补码（two's complement) 指的是正数=原码，负数=反码加一 反码（ones' complement) 指的就是通常所指的反码。 对一个整数的补码再求补码，等于该整数自身。 补码的正零与负零表示方法相同。     浮点数转换成整数时，小数部分被丢弃,也就是朝0方向舍入。\n1 2 3 4  var v1 float32 = 0.999999 fmt.Println(int(v1)) v1 = -0.999999 fmt.Println(int(v1))     转换整数或者浮点数到浮点数的时候，或者一个复数到另一个复数， 结果值会被舍入到目标类型的精度。例如类型为float32的变量x可以通过附加的精度超过标准的IEEE-754 32-bit数， 但是float32(x)代表x的值舍入到 IEEE-754 32 bit的精度。类似地， x + 0.1 可以使用超过32 bit的精度，但是float32(x + 0.1) 肯定是32 bit的精度。\n关于浮点数格式IEEE-754, 它由三个域组成，float32中分别占1位、8位、和 23位.\n  在涉及浮点值或复数值的所有非常量转换中，如果结果类型无法表示转换成功的值，但结果值与实现有关。\n字符串变量的转换 字符串代表一串字节流，所以很容易的和slice of byte, slice of rune进行转换。\n 将有符号或无符号整数值转换为字符串类型会生成包含整数的UTF-8表示形式的字符串。超出有效Unicode代码点范围的值将转换为“\\uFFFD”。  字符'�'的 Unicode 代码点是U+FFFD。它是 Unicode 标准中定义的 Replacement Character，专用于替换那些未知的、不被认可的以及无法展示的字符。\n```go string('a') // \"a\" string(-1) // \"\\ufffd\" == \"\\xef\\xbf\\xbd\" string(0xf8) // \"\\u00f8\" == \"ø\" == \"\\xc3\\xb8\" type MyString string MyString(0x65e5) // \"\\u65e5\" == \"日\" == \"\\xe6\\x97\\xa5\" ```   将一个byte切片转换为字符串类型会产生一个字符串，根据UTF-8编码产生字符串,其连续字节是切片的元素。\n1 2 3 4 5 6  string([]byte{'h', 'e', 'l', 'l', '\\xc3', '\\xb8'}) // \"hellø\" string([]byte{}) // \"\" string([]byte(nil)) // \"\"  type MyBytes []byte string(MyBytes{'h', 'e', 'l', 'l', '\\xc3', '\\xb8'}) // \"hellø\"     将一个rune切片转换为字符串类型会产生一个字符串，该字符串是转换为字符串的各个rune值的串联。\n1 2 3 4 5 6  string([]rune{0x767d, 0x9d6c, 0x7fd4}) // \"\\u767d\\u9d6c\\u7fd4\" == \"白鵬翔\" string([]rune{}) // \"\" string([]rune(nil)) // \"\"  type MyRunes []rune string(MyRunes{0x767d, 0x9d6c, 0x7fd4}) // \"\\u767d\\u9d6c\\u7fd4\" == \"白鵬翔\"     将字符串类型的值转换为byte切片类型会生成一个切片，其连续元素是字符串的字节。\n1 2 3 4  []byte(\"hellø\") // []byte{'h', 'e', 'l', 'l', '\\xc3', '\\xb8'} []byte(\"\") // []byte{}  MyBytes(\"hellø\") // []byte{'h', 'e', 'l', 'l', '\\xc3', '\\xb8'}     将字符串类型的值转换为rune类型切片会生成包含字符串的各个Unicode代码点的切片。\n1 2 3 4  []rune(MyString(\"白鵬翔\")) // []rune{0x767d, 0x9d6c, 0x7fd4} []rune(\"\") // []rune{}  MyRunes(\"白鵬翔\") // []rune{0x767d, 0x9d6c, 0x7fd4}     stirng与int,float,bool的转换 int与string int转string 1  s := strconv.Itoa(i)   等价于\n1  s := strconv.FormatInt(int64(i), 10)   string转int 1  i, err := strconv.Atoi(s)   int64与string int64转string 1 2  i := int64(123) s := strconv.FormatInt(i, 10)   第二个参数为基数，可选2~36\n注：对于无符号整形，可以使用FormatUint(i uint64, base int)\nstring转int64 1  err := strconv.ParseInt(s, 10, 64)   第二个参数为基数（2~36），第三个参数位大小表示期望转换的结果类型，其值可以为0, 8, 16, 32和64，分别对应 int, int8, int16, int32和int64\nfloat与string float转string sprintf 1 2 3 4 5 6 7 8 9 10 11 12 13 14  // Desired output: // \"1.9\" // \"10.9\" // \"100.9\"  fmt.Println(\"2g:\") fmt.Println(fmt.Sprintf(\"%.2g\", 1.900)) // outputs \"1.9\" fmt.Println(fmt.Sprintf(\"%.2g\", 10.900)) // outputs \"11\" fmt.Println(fmt.Sprintf(\"%.2g\", 100.900)) // outputs \"1e+02\"  fmt.Println(\"\\n2f:\") fmt.Println(fmt.Sprintf(\"%.2f\", 1.900)) // outputs \"1.90\" fmt.Println(fmt.Sprintf(\"%.2f\", 10.900)) // outputs \"10.90\" fmt.Println(fmt.Sprintf(\"%.2f\", 100.900)) // outputs \"100.90\"   使用2g格式化的问题是,当整数增加数量级时,它会开始舍入.此外,它有时会显示带有e的数字.\n使用2f格式化会出现显示尾随零的问题.\n如何将将float格式化为n个小数位并且没有尾随零呢？我们需要FormatFloat\nFormatFloat 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // FormatFloat 将浮点数 f 转换为字符串形式 // f：要转换的浮点数 // fmt：格式标记（b、e、E、f、g、G） // prec：精度（数字部分的长度，不包括指数部分） // bitSize：指定浮点类型（32:float32、64:float64），结果会据此进行舍入。 // // 格式标记： // 'b' (-ddddp±ddd，二进制指数) // 'e' (-d.dddde±dd，十进制指数) // 'E' (-d.ddddE±dd，十进制指数) // 'f' (-ddd.dddd，没有指数) // 'g' ('e':大指数，'f':其它情况) // 'G' ('E':大指数，'f':其它情况) // // 如果格式标记为 'e'，'E'和'f'，则 prec 表示小数点后的数字位数 // 如果格式标记为 'g'，'G'，则 prec 表示总的数字位数（整数部分+小数部分） // -1 代表输出的精度小数点后的位数，如果是// 参考格式化输入输出中的旗标和精度说明 func FormatFloat(f float64, fmt byte, prec, bitSize int) string   1  strconv.FormatFloat(10.900,’f’, – 1,64)   这将导致10.9.\n-1作为第三个参数告诉函数打印准确表示浮点数所需的最少数字.\n转化效率对比 需求 浮点数取2位精度输出\n实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  package main import ( \"time\" \"log\" \"strconv\" \"fmt\" ) func main() { threadCount := 100000 fa := 3.233667 time1 := TestFn(threadCount,fa,func(fa float64) string{ return strconv.FormatFloat(fa,'f',2,64) }) log.Printf(\"FormatFloat 耗时:%.4f ms\",time1) time2 := TestFn(threadCount,fa,func(fa float64) string{ return fmt.Sprintf(\"%.2f\",fa) }) log.Printf(\"Sprintf 耗时:%.4f ms\",time2) } func TestFn(count int,fa float64,fn func(fa float64) string) float64{ t1 := time.Now() for i := 0; i  count; i++ { fn(fa) } t2 := time.Now() return t2.Sub(t1).Seconds()*1000 }   效率对比 测试 100次 (即threadCount赋值100，下面同理)\n2017/06/15 18:50:17 FormatFloat 耗时:0.0452 ms 2017/06/15 18:50:17 Sprintf 耗时:0.0512 ms 测试 1000次\n2017/06/15 18:50:43 FormatFloat 耗时:0.3861 ms 2017/06/15 18:50:43 Sprintf 耗时:0.4903 ms\n测试 10000次\n2017/06/15 18:50:58 FormatFloat 耗时:3.9688 ms 2017/06/15 18:50:58 Sprintf 耗时:5.2045 ms\n测试 100000次　2017/06/15 18:51:20 FormatFloat 耗时:41.9253 ms 2017/06/15 18:51:20 Sprintf 耗时:51.8639 ms\n测试 10000000次\n2017/06/15 18:51:49 FormatFloat 耗时:3917.7585 ms 2017/06/15 18:51:54 Sprintf 耗时:5131.5497 ms\n结论 strconv 包的函数不需要格式化，比 fmt 包的函数更加高效。\nstrconv下的FormatFloat明显快一些。fmt.Sprintf用到反射，效率不高，建议少用。　string转float 1  func ParseFloat(s string, bitSize int) (f float64, err error)   解析一个表示浮点数的字符串并返回其值。\n如果s合乎语法规则，函数会返回最为接近s表示值的一个浮点数（使用IEEE754规范舍入）。bitSize指定了期望的接收类型，32是float32（返回值可以不改变精确值的赋值给float32），64是float64；返回值err是*NumErr类型的，语法有误的，err.Error=ErrSyntax；结果超出表示范围的，返回值f为±Inf，err.Error= ErrRange。\nstring转float64 这里有两种方法，都支持指定精度。 注意：所有数字要在表现层显示最好转换为字符串传送给表现层，如果用于后端计算则转换为数字即可。比如：数字2.10 如果用保持5位数字精度显示： 那么 数字2.10 显示为：2.1, 而将2.10转换为字符串同时保持5位精度，则显示为: 2.10000。但是它们都是转换为了5位精度的，只是显示的时候，数字2.10000 直接显示为2.1了， 所以要显示精度则转换为字符串，要用于计算则转换为数字。\n方法1： 只支持指定精度\n1 2 3 4 5 6 7  func strToFloat64(str string, len int) float64 { lenstr := \"%.\" + strconv.Itoa(len) + \"f\" value,_ := strconv.ParseFloat(str,64) nstr := fmt.Sprintf(lenstr,value) val,_ := strconv.ParseFloat(nstr,64) return val }   方法2：支持指定精度，支持是否四舍五入\n1 2 3 4 5 6 7 8 9 10 11 12  func strToFloat64Round(str string, prec int, round bool) float64 { f,_ := strconv.ParseFloat(str,64) return Precision(f,prec,round) } func Precision(f float64, prec int, round bool) float64 { pow10_n := math.Pow10(prec) if round { return math.Trunc(f + 0.5/pow10_n)*pow10_n) / pow10_n\t} return math.Trunc((f)*pow10_n) / pow10_n }   bool与string bool转string 1 2 3 4 5 6  func FormatBool(b bool) string // 将字符串转换为布尔值 // 它接受真值：1, t, T, TRUE, true, True // 它接受假值：0, f, F, FALSE, false, False // 其它任何值都返回一个错误。   string转bool 1  func ParseBool(str string) (bool, error)   bytes与float64 bytes转float64 1 2 3 4  func bytesToFloat64(bytes []byte) float64 { bits := binary.LittleEndian.Uint64(bytes) return math.Float64frombits(bits) }   float64转bytes 1 2 3 4 5 6  func float64ToBytes(input float64) []byte { bits := math.Float64bits(input) bytes := make([]byte,8) //这里表示[]uint8, 所以用了 8 \tbinary.LittleEndian.PutUint64(bytes,bits) return bytes }   结构体互相转换 基本上只有两个完全一样的struct(就是结构体的名字不同，成员定义、顺序、包括tag都得一样)才可以直接转换，转换直接t2 := Test2(t1)这样就可以(t1是Test1类型)\n前提是Test1, Test2符合转换条件，哪怕tag定义不一样都不行的，比如下面这样都不能转换的，编译会报错。\n1 2 3 4 5 6 7 8  type Test1 struct { Age int `json:\"age\"` Name string } type Test1 struct { Age int Name string }   数组与切片的转换 数组转切片 利用索引运算\n1 2  a[low:high] a[low:high:max]   切片转数组 slice的底层实现是数组，所以有一个\"hack\"方法，将slice的底层数组返回:\n1 2 3 4 5 6 7 8 9 10 11 12  import ( \"reflect\" \"unsafe\" ) const SIZEOF_INT32 = 4 // bytes // Get the slice header header := *(*reflect.SliceHeader)(unsafe.Pointer(\u0026raw)) // The length and capacity of the slice are different. header.Len /= SIZEOF_INT32 header.Cap /= SIZEOF_INT32 // Convert slice header to an []int32 data := *(*[]int32)(unsafe.Pointer(\u0026header))   安全的方式是生成数组然后依次赋值，注意copy是不行的，因为copy的参数必须都是slice:\n1 2 3 4 5 6 7  import \"encoding/binary\" const SIZEOF_INT32 = 4 // bytes data := make([]int32, len(raw)/SIZEOF_INT32) for i := range data { // assuming little endian  data[i] = int32(binary.LittleEndian.Uint32(raw[i*SIZEOF_INT32:(i+1)*SIZEOF_INT32])) }   struct和字符串之间的转换 struct类型的值和字符串之间的转换我们称之为marshal和unmarshal。\n有非常多的库可以做这个事情，比如gob, encoding/json等。\nJava字符串和Go字符串之间的转换 Java字符串在内部是以UTF-16编码方式存在的，每个字符包含两个字节。而Go字符串在内部是以UTF-8格式存在的，每个字符串占用的字节数可能不同。\n可以使用unicode包进行转换，或者使用unicode/utf16\n字节slice和整数之间的转换 包 encoding/binary实现了数值和字节序列之间的转换，包含变长int的各种编解码。\nGo中的数值类型都是固定长度的位数(int8, uint8, int16, float32, complex64)，所以组成这些数组的bit可以转换成各种字节slice。\n变长int (varint)经常用于节省空间，比如一个， Go实现的varint规范可以参考proto-buff的实现。很多编解码库中都使用了变长的int，这样对于大量的小数字我们可以用更少的字节来表示，对于网络传输来说很有好处。\n这个包经常用在网络传输的序列化和反序列中。\n另外一个值得注意的是数值是由多个字节组成的，这就涉及到字节序的问题，你必须指定使用小端序或大端序。\n首先看一下定长的数值的转换，主要是Read和Write两个方法，底层还是通过移位操作实现的。\n1 2  func Read(r io.Reader, order ByteOrder, data interface{}) error func Write(w io.Writer, order ByteOrder, data interface{}) error   例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  package main import ( \"bytes\" \"encoding/binary\" \"fmt\" ) func main() { b := write() read(b) } func write() []byte { buf := new(bytes.Buffer) var data = []interface{}{ uint16(61374), //efbe \tint8(-54), //-36 \tuint8(254), //fe \t} for _, v := range data { err := binary.Write(buf, binary.BigEndian, v) if err != nil { fmt.Println(\"binary.Write failed:\", err) } } fmt.Printf(\"%x\\n\", buf.Bytes()) //efbecafe \treturn buf.Bytes() } func read(b []byte) { var i1 uint16 var i2 int8 var i3 uint8 buf := bytes.NewReader(b) err := binary.Read(buf, binary.BigEndian, \u0026i1) if err != nil { fmt.Println(\"binary.Read failed:\", err) } err = binary.Read(buf, binary.BigEndian, \u0026i2) if err != nil { fmt.Println(\"binary.Read failed:\", err) } err = binary.Read(buf, binary.BigEndian, \u0026i3) if err != nil { fmt.Println(\"binary.Read failed:\", err) } fmt.Println(i1, i2, i3) //61374 -54 254 }   一种不通用的适合特定类型的转换也可以使用下面的方法：\n1 2 3 4 5 6 7 8  func readInt32(b []byte) int32 { // equivalnt of return int32(binary.LittleEndian.Uint32(b))  return int32(uint32(b[0]) | uint32(b[1])8 | uint32(b[2])16 | uint32(b[3])24) } //或者 func ReadInt32Unsafe(b []byte) int32 { return *(*int32)(unsafe.Pointer(\u0026b[0])) }   变长int的操作函数:\n1 2 3 4 5 6  func PutUvarint(buf []byte, x uint64) int func PutVarint(buf []byte, x int64) int func Uvarint(buf []byte) (uint64, int) func Varint(buf []byte) (int64, int) func ReadUvarint(r io.ByteReader) (uint64, error) func ReadVarint(r io.ByteReader) (int64, error)   以及一个对象被转换成多少字节的方法:\n1  func Size(v interface{}) int   参考:https://colobu.com/2016/06/21/dive-into-go-6/#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2\n",
  "wordCount" : "5972",
  "inLanguage": "zh-cn",
  "datePublished": "2019-01-26T21:22:18Z",
  "dateModified": "2019-01-26T21:22:18Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Go中的内置类型转换
    </h1>
    <div class="post-meta">January 26, 2019
</div>
  </header> 
  <div class="post-content"><h1 id="隐型转换">隐型转换<a hidden class="anchor" aria-hidden="true" href="#隐型转换">#</a></h1>
<p>转换是T（x）形式的表达式，其中T是类型，x是可以转换为类型T的表达式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">Conversion</span> <span class="p">=</span> <span class="nx">Type</span> <span class="s">&#34;(&#34;</span> <span class="nx">Expression</span> <span class="p">[</span> <span class="s">&#34;,&#34;</span> <span class="p">]</span> <span class="s">&#34;)&#34;</span> <span class="p">.</span>
</code></pre></td></tr></table>
</div>
</div><p>如果类型以operator *或&lt;- 开头，或者类型以关键字func开头并且没有结果列表，则必须在必要时将其括起来以避免歧义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="o">*</span><span class="nf">Point</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>        <span class="c1">// same as *(Point(p))
</span><span class="c1"></span><span class="p">(</span><span class="o">*</span><span class="nx">Point</span><span class="p">)(</span><span class="nx">p</span><span class="p">)</span>      <span class="c1">// p is converted to *Point
</span><span class="c1"></span><span class="o">&lt;-</span><span class="kd">chan</span> <span class="nb">int</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>    <span class="c1">// same as &lt;-(chan int(c))
</span><span class="c1"></span><span class="p">(</span><span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)(</span><span class="nx">c</span><span class="p">)</span>  <span class="c1">// c is converted to &lt;-chan int
</span><span class="c1"></span><span class="kd">func</span><span class="p">()(</span><span class="nx">x</span><span class="p">)</span>        <span class="c1">// function signature func() x
</span><span class="c1"></span><span class="p">(</span><span class="kd">func</span><span class="p">())(</span><span class="nx">x</span><span class="p">)</span>      <span class="c1">// x is converted to func()
</span><span class="c1"></span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="kt">int</span><span class="p">)(</span><span class="nx">x</span><span class="p">)</span>  <span class="c1">// x is converted to func() int
</span><span class="c1"></span><span class="kd">func</span><span class="p">()</span> <span class="nb">int</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>    <span class="c1">// x is converted to func() int (unambiguous)
</span></code></pre></td></tr></table>
</div>
</div><p>如果x可由T表示，则常数值x可以转换为类型T.作为特殊情况，可以使用与非常数x相同的规则将整数常量x转换为字符串类型。</p>
<p>转换常量会产生类型常量作为结果。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nb">uint</span><span class="p">(</span><span class="kc">iota</span><span class="p">)</span>               <span class="c1">// iota value of type uint
</span><span class="c1"></span><span class="nb">float32</span><span class="p">(</span><span class="mf">2.718281828</span><span class="p">)</span>     <span class="c1">// 2.718281828 of type float32
</span><span class="c1"></span><span class="nb">complex128</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>            <span class="c1">// 1.0 + 0.0i of type complex128
</span><span class="c1"></span><span class="nb">float32</span><span class="p">(</span><span class="mf">0.49999999</span><span class="p">)</span>      <span class="c1">// 0.5 of type float32
</span><span class="c1"></span><span class="nb">float64</span><span class="p">(</span><span class="o">-</span><span class="mf">1e-1000</span><span class="p">)</span>        <span class="c1">// 0.0 of type float64
</span><span class="c1"></span><span class="nb">string</span><span class="p">(</span><span class="sc">&#39;x&#39;</span><span class="p">)</span>              <span class="c1">// &#34;x&#34; of type string
</span><span class="c1"></span><span class="nb">string</span><span class="p">(</span><span class="mh">0x266c</span><span class="p">)</span>           <span class="c1">// &#34;♬&#34; of type string
</span><span class="c1"></span><span class="nf">MyString</span><span class="p">(</span><span class="s">&#34;foo&#34;</span> <span class="o">+</span> <span class="s">&#34;bar&#34;</span><span class="p">)</span>  <span class="c1">// &#34;foobar&#34; of type MyString
</span><span class="c1"></span><span class="nb">string</span><span class="p">([]</span><span class="kt">byte</span><span class="p">{</span><span class="sc">&#39;a&#39;</span><span class="p">})</span>      <span class="c1">// not a constant: []byte{&#39;a&#39;} is not a constant
</span><span class="c1"></span><span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="kc">nil</span><span class="p">)</span>              <span class="c1">// not a constant: nil is not a constant, *int is not a boolean, numeric, or string type
</span><span class="c1"></span><span class="nb">int</span><span class="p">(</span><span class="mf">1.2</span><span class="p">)</span>                 <span class="c1">// illegal: 1.2 cannot be represented as an int
</span><span class="c1"></span><span class="nb">string</span><span class="p">(</span><span class="mf">65.0</span><span class="p">)</span>             <span class="c1">// illegal: 65.0 is not an integer constant
</span></code></pre></td></tr></table>
</div>
</div><p>对于一个常量值x, 如果能转换成T类型的值，它需要满足下面的条件之一:</p>
<ul>
<li>x可赋予T.</li>
<li>忽略struct标签（见下文），x的类型和T具有相同的底层类型。</li>
<li>忽略struct标签（见下文），x类型和T都是未命名的指针类型，它们的指针指向的对象类型一致</li>
<li>x的类型和T都是整数或浮点类型。</li>
<li>x的类型和T都是复杂类型。</li>
<li>x是整数或slice of byte、slice of rune，T是字符串类型。</li>
<li>x是字符串，T是slice of byte、slice of rune</li>
</ul>
<p>为了转换的目的，在比较结构类型的标识时，会忽略结构标记：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span>    <span class="kt">string</span>
	<span class="nx">Address</span> <span class="o">*</span><span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">Street</span> <span class="kt">string</span>
		<span class="nx">City</span>   <span class="kt">string</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">data</span> <span class="o">*</span><span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span>    <span class="kt">string</span> <span class="s">`json:&#34;name&#34;`</span>
	<span class="nx">Address</span> <span class="o">*</span><span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">Street</span> <span class="kt">string</span> <span class="s">`json:&#34;street&#34;`</span>
		<span class="nx">City</span>   <span class="kt">string</span> <span class="s">`json:&#34;city&#34;`</span>
	<span class="p">}</span> <span class="s">`json:&#34;address&#34;`</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">person</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">Person</span><span class="p">)(</span><span class="nx">data</span><span class="p">)</span>  <span class="c1">// ignoring tags, the underlying types are identical
</span></code></pre></td></tr></table>
</div>
</div><p>特定规则适用于数字类型之间或字符串类型之间的（非常量）转换。这些转换可能会更改x的表示形式并产生运行时成本。所有其他转换仅更改类型，但不更改x的表示。</p>
<p>没有语言机制来在指针和整数之间进行转换。软件包unsafe在受限情况下实现此功能。</p>
<h2 id="数值类型之间的转换">数值类型之间的转换<a hidden class="anchor" aria-hidden="true" href="#数值类型之间的转换">#</a></h2>
<p>非常量的数值之间的转换遵循下面三条原则:</p>
<ol>
<li>
<p>整数之间的转换时，如果值是有符号的整数，它的符号位会扩展无限大，否则零扩展，然后它会被删减以适合结果类型。对于无符号数v: v := uint16(0x10F0),如果进行转换uint32(int8(v)),可以看到它的结果是0xFFFFFFF0，不会有溢出指示或者错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">v1</span> <span class="o">:=</span> <span class="nb">uint16</span><span class="p">(</span><span class="mh">0x10F0</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d=%b\n&#34;</span><span class="p">,</span> <span class="nx">v1</span><span class="p">,</span> <span class="nx">v1</span><span class="p">)</span> <span class="c1">//4336=1000011110000
</span><span class="c1"></span><span class="nx">v2</span> <span class="o">:=</span> <span class="nb">int8</span><span class="p">(</span><span class="nx">v1</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d=%b\n&#34;</span><span class="p">,</span> <span class="nx">v2</span><span class="p">,</span> <span class="nx">v2</span><span class="p">)</span> <span class="c1">//-16=-10000
</span><span class="c1"></span><span class="nx">v3</span> <span class="o">:=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">v2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d=%b\n&#34;</span><span class="p">,</span> <span class="nx">v3</span><span class="p">,</span> <span class="nx">v3</span><span class="p">)</span> <span class="c1">//65520=1111111111110000
</span><span class="c1"></span><span class="nx">v4</span> <span class="o">:=</span> <span class="nb">int16</span><span class="p">(</span><span class="nx">v2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d=%b\n&#34;</span><span class="p">,</span> <span class="nx">v4</span><span class="p">,</span> <span class="nx">v4</span><span class="p">)</span> <span class="c1">//-16=-10000
</span></code></pre></td></tr></table>
</div>
</div><p>介绍一下。 对于v1,它是一个无符号的整数， 要把它转为有符号的int8，那么我们只看v1的后8位:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">1111 0000
</code></pre></td></tr></table>
</div>
</div><p>不幸的是，这个8位的最高位是1,我们会把它作为符号位，所以v2是个负数，那么11110000就是这个负数的补码，</p>
<p>那么它的原码是多少呢，计算补码的补码就是负数的原码:1001 0000,所以它是-16。如果最高位是0，简单了，本身就是它的原码。</p>
<p>再看v2转v3， 也就是有符号整数转无符号整数。v2是负数，内部表示为11110000,因为要扩展为16位，将符号位1扩展到最高位1111 1111 1111 0000,因为它是无符号整数，所   以这个值整数的值65520。</p>
<p>你可以把v1值的值改为0xff60看看输出是什么？此时转换不会符号位为负数的情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">补码（two&#39;s complement) 指的是正数=原码，负数=反码加一
反码（ones&#39; complement) 指的就是通常所指的反码。
对一个整数的补码再求补码，等于该整数自身。
补码的正零与负零表示方法相同。
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>浮点数转换成整数时，小数部分被丢弃,也就是朝0方向舍入。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">v1</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mf">0.999999</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">v1</span><span class="p">))</span>
<span class="nx">v1</span> <span class="p">=</span> <span class="o">-</span><span class="mf">0.999999</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">v1</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>转换整数或者浮点数到浮点数的时候，或者一个复数到另一个复数， 结果值会被舍入到目标类型的精度。例如类型为float32的变量x可以通过附加的精度超过标准的IEEE-754 32-bit数， 但是float32(x)代表x的值舍入到 IEEE-754 32 bit的精度。类似地， x + 0.1 可以使用超过32 bit的精度，但是float32(x + 0.1) 肯定是32 bit的精度。</p>
<p>关于浮点数格式IEEE-754, 它由三个域组成，float32中分别占1位、8位、和 23位.</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20190128170732.png" alt=""  />
</p>
</li>
</ol>
<p>在涉及浮点值或复数值的所有非常量转换中，如果结果类型无法表示转换成功的值，但结果值与实现有关。</p>
<h2 id="字符串变量的转换">字符串变量的转换<a hidden class="anchor" aria-hidden="true" href="#字符串变量的转换">#</a></h2>
<p>字符串代表一串字节流，所以很容易的和slice of byte, slice of rune进行转换。</p>
<ol>
<li>将有符号或无符号整数值转换为字符串类型会生成包含整数的UTF-8表示形式的字符串。超出有效Unicode代码点范围的值将转换为“\uFFFD”。</li>
</ol>
<p>字符'�'的 Unicode 代码点是U+FFFD。它是 Unicode 标准中定义的 Replacement Character，专用于替换那些未知的、不被认可的以及无法展示的字符。</p>
<pre><code>```go
string('a')       // &quot;a&quot;
string(-1)        // &quot;\ufffd&quot; == &quot;\xef\xbf\xbd&quot;
string(0xf8)      // &quot;\u00f8&quot; == &quot;ø&quot; == &quot;\xc3\xb8&quot;
type MyString string
MyString(0x65e5)  // &quot;\u65e5&quot; == &quot;日&quot; == &quot;\xe6\x97\xa5&quot;
```
</code></pre>
<ol start="2">
<li>
<p>将一个byte切片转换为字符串类型会产生一个字符串，根据UTF-8编码产生字符串,其连续字节是切片的元素。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nb">string</span><span class="p">([]</span><span class="kt">byte</span><span class="p">{</span><span class="sc">&#39;h&#39;</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="sc">&#39;\xc3&#39;</span><span class="p">,</span> <span class="sc">&#39;\xb8&#39;</span><span class="p">})</span>   <span class="c1">// &#34;hellø&#34;
</span><span class="c1"></span><span class="nb">string</span><span class="p">([]</span><span class="kt">byte</span><span class="p">{})</span>                                     <span class="c1">// &#34;&#34;
</span><span class="c1"></span><span class="nb">string</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="kc">nil</span><span class="p">))</span>                                  <span class="c1">// &#34;&#34;
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">MyBytes</span> <span class="p">[]</span><span class="kt">byte</span>
<span class="nb">string</span><span class="p">(</span><span class="nx">MyBytes</span><span class="p">{</span><span class="sc">&#39;h&#39;</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="sc">&#39;\xc3&#39;</span><span class="p">,</span> <span class="sc">&#39;\xb8&#39;</span><span class="p">})</span>  <span class="c1">// &#34;hellø&#34;
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>将一个rune切片转换为字符串类型会产生一个字符串，该字符串是转换为字符串的各个rune值的串联。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nb">string</span><span class="p">([]</span><span class="kt">rune</span><span class="p">{</span><span class="mh">0x767d</span><span class="p">,</span> <span class="mh">0x9d6c</span><span class="p">,</span> <span class="mh">0x7fd4</span><span class="p">})</span>   <span class="c1">// &#34;\u767d\u9d6c\u7fd4&#34; == &#34;白鵬翔&#34;
</span><span class="c1"></span><span class="nb">string</span><span class="p">([]</span><span class="kt">rune</span><span class="p">{})</span>                         <span class="c1">// &#34;&#34;
</span><span class="c1"></span><span class="nb">string</span><span class="p">([]</span><span class="nb">rune</span><span class="p">(</span><span class="kc">nil</span><span class="p">))</span>                      <span class="c1">// &#34;&#34;
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">MyRunes</span> <span class="p">[]</span><span class="kt">rune</span>
<span class="nb">string</span><span class="p">(</span><span class="nx">MyRunes</span><span class="p">{</span><span class="mh">0x767d</span><span class="p">,</span> <span class="mh">0x9d6c</span><span class="p">,</span> <span class="mh">0x7fd4</span><span class="p">})</span>  <span class="c1">// &#34;\u767d\u9d6c\u7fd4&#34; == &#34;白鵬翔&#34;
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>将字符串类型的值转换为byte切片类型会生成一个切片，其连续元素是字符串的字节。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;hellø&#34;</span><span class="p">)</span>   <span class="c1">// []byte{&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;\xc3&#39;, &#39;\xb8&#39;}
</span><span class="c1"></span><span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>        <span class="c1">// []byte{}
</span><span class="c1"></span>
<span class="nf">MyBytes</span><span class="p">(</span><span class="s">&#34;hellø&#34;</span><span class="p">)</span>  <span class="c1">// []byte{&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;\xc3&#39;, &#39;\xb8&#39;}
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>将字符串类型的值转换为rune类型切片会生成包含字符串的各个Unicode代码点的切片。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="p">[]</span><span class="nb">rune</span><span class="p">(</span><span class="nf">MyString</span><span class="p">(</span><span class="s">&#34;白鵬翔&#34;</span><span class="p">))</span>  <span class="c1">// []rune{0x767d, 0x9d6c, 0x7fd4}
</span><span class="c1"></span><span class="p">[]</span><span class="nb">rune</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>                 <span class="c1">// []rune{}
</span><span class="c1"></span>
<span class="nf">MyRunes</span><span class="p">(</span><span class="s">&#34;白鵬翔&#34;</span><span class="p">)</span>           <span class="c1">// []rune{0x767d, 0x9d6c, 0x7fd4}
</span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h1 id="stirng与intfloatbool的转换">stirng与int,float,bool的转换<a hidden class="anchor" aria-hidden="true" href="#stirng与intfloatbool的转换">#</a></h1>
<h2 id="int与string">int与string<a hidden class="anchor" aria-hidden="true" href="#int与string">#</a></h2>
<h3 id="int转string">int转string<a hidden class="anchor" aria-hidden="true" href="#int转string">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>等价于</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">FormatInt</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="nx">i</span><span class="p">),</span> <span class="mi">10</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="string转int">string转int<a hidden class="anchor" aria-hidden="true" href="#string转int">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">i</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="int64与string">int64与string<a hidden class="anchor" aria-hidden="true" href="#int64与string">#</a></h2>
<h3 id="int64转string">int64转string<a hidden class="anchor" aria-hidden="true" href="#int64转string">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">i</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="nx">s</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">FormatInt</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>第二个参数为基数，可选2~36</p>
<p>注：对于无符号整形，可以使用FormatUint(i uint64, base int)</p>
<h3 id="string转int64">string转int64<a hidden class="anchor" aria-hidden="true" href="#string转int64">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>第二个参数为基数（2~36），第三个参数位大小表示期望转换的结果类型，其值可以为0, 8, 16, 32和64，分别对应 int, int8, int16, int32和int64</p>
<h2 id="float与string">float与string<a hidden class="anchor" aria-hidden="true" href="#float与string">#</a></h2>
<h3 id="float转string">float转string<a hidden class="anchor" aria-hidden="true" href="#float转string">#</a></h3>
<h4 id="sprintf">sprintf<a hidden class="anchor" aria-hidden="true" href="#sprintf">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Desired output: 
</span><span class="c1">// &#34;1.9&#34;
</span><span class="c1">// &#34;10.9&#34;
</span><span class="c1">// &#34;100.9&#34;
</span><span class="c1"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;2g:&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%.2g&#34;</span><span class="p">,</span> <span class="mf">1.900</span><span class="p">))</span> <span class="c1">// outputs &#34;1.9&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%.2g&#34;</span><span class="p">,</span> <span class="mf">10.900</span><span class="p">))</span> <span class="c1">// outputs &#34;11&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%.2g&#34;</span><span class="p">,</span> <span class="mf">100.900</span><span class="p">))</span> <span class="c1">// outputs &#34;1e+02&#34;
</span><span class="c1"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\n2f:&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%.2f&#34;</span><span class="p">,</span> <span class="mf">1.900</span><span class="p">))</span> <span class="c1">// outputs &#34;1.90&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%.2f&#34;</span><span class="p">,</span> <span class="mf">10.900</span><span class="p">))</span> <span class="c1">// outputs &#34;10.90&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%.2f&#34;</span><span class="p">,</span> <span class="mf">100.900</span><span class="p">))</span> <span class="c1">// outputs &#34;100.90&#34;
</span></code></pre></td></tr></table>
</div>
</div><p>使用2g格式化的问题是,当整数增加数量级时,它会开始舍入.此外,它有时会显示带有e的数字.</p>
<p>使用2f格式化会出现显示尾随零的问题.</p>
<p>如何将将float格式化为n个小数位并且没有尾随零呢？我们需要FormatFloat</p>
<h4 id="formatfloat">FormatFloat<a hidden class="anchor" aria-hidden="true" href="#formatfloat">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// FormatFloat 将浮点数 f 转换为字符串形式
</span><span class="c1">// f：要转换的浮点数
</span><span class="c1">// fmt：格式标记（b、e、E、f、g、G）
</span><span class="c1">// prec：精度（数字部分的长度，不包括指数部分）
</span><span class="c1">// bitSize：指定浮点类型（32:float32、64:float64），结果会据此进行舍入。
</span><span class="c1">//
</span><span class="c1">// 格式标记：
</span><span class="c1">// &#39;b&#39; (-ddddp±ddd，二进制指数)
</span><span class="c1">// &#39;e&#39; (-d.dddde±dd，十进制指数)
</span><span class="c1">// &#39;E&#39; (-d.ddddE±dd，十进制指数)
</span><span class="c1">// &#39;f&#39; (-ddd.dddd，没有指数)
</span><span class="c1">// &#39;g&#39; (&#39;e&#39;:大指数，&#39;f&#39;:其它情况)
</span><span class="c1">// &#39;G&#39; (&#39;E&#39;:大指数，&#39;f&#39;:其它情况)
</span><span class="c1">//
</span><span class="c1">// 如果格式标记为 &#39;e&#39;，&#39;E&#39;和&#39;f&#39;，则 prec 表示小数点后的数字位数
</span><span class="c1">// 如果格式标记为 &#39;g&#39;，&#39;G&#39;，则 prec 表示总的数字位数（整数部分+小数部分）
</span><span class="c1">// -1 代表输出的精度小数点后的位数，如果是&lt;0的值，则返回最少的位数来表示该数，如果是大于0的则返回对应位数的值  
</span><span class="c1">// 参考格式化输入输出中的旗标和精度说明
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">FormatFloat</span><span class="p">(</span><span class="nx">f</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">fmt</span> <span class="kt">byte</span><span class="p">,</span> <span class="nx">prec</span><span class="p">,</span> <span class="nx">bitSize</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">strconv</span><span class="p">.</span><span class="nf">FormatFloat</span><span class="p">(</span><span class="mf">10.900</span><span class="p">,</span><span class="err">’</span><span class="nx">f</span><span class="err">’</span><span class="p">,</span> <span class="err">–</span> <span class="mi">1</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这将导致10.9.</p>
<p>-1作为第三个参数告诉函数打印准确表示浮点数所需的最少数字.</p>
<h4 id="转化效率对比">转化效率对比<a hidden class="anchor" aria-hidden="true" href="#转化效率对比">#</a></h4>
<h5 id="需求">需求<a hidden class="anchor" aria-hidden="true" href="#需求">#</a></h5>
<p>浮点数取2位精度输出</p>
<h5 id="实现">实现<a hidden class="anchor" aria-hidden="true" href="#实现">#</a></h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;time&#34;</span>
    <span class="s">&#34;log&#34;</span>
    <span class="s">&#34;strconv&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">threadCount</span> <span class="o">:=</span> <span class="mi">100000</span>
    <span class="nx">fa</span> <span class="o">:=</span> <span class="mf">3.233667</span>


    <span class="nx">time1</span> <span class="o">:=</span> <span class="nf">TestFn</span><span class="p">(</span><span class="nx">threadCount</span><span class="p">,</span><span class="nx">fa</span><span class="p">,</span><span class="kd">func</span><span class="p">(</span><span class="nx">fa</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">string</span><span class="p">{</span>
        <span class="k">return</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">FormatFloat</span><span class="p">(</span><span class="nx">fa</span><span class="p">,</span><span class="sc">&#39;f&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;FormatFloat 耗时:%.4f ms&#34;</span><span class="p">,</span><span class="nx">time1</span><span class="p">)</span>

    <span class="nx">time2</span> <span class="o">:=</span> <span class="nf">TestFn</span><span class="p">(</span><span class="nx">threadCount</span><span class="p">,</span><span class="nx">fa</span><span class="p">,</span><span class="kd">func</span><span class="p">(</span><span class="nx">fa</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">string</span><span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%.2f&#34;</span><span class="p">,</span><span class="nx">fa</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Sprintf 耗时:%.4f ms&#34;</span><span class="p">,</span><span class="nx">time2</span><span class="p">)</span>

<span class="p">}</span>

<span class="kd">func</span> <span class="nf">TestFn</span><span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">,</span><span class="nx">fa</span> <span class="kt">float64</span><span class="p">,</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">(</span><span class="nx">fa</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">float64</span><span class="p">{</span>
    <span class="nx">t1</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>

    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nf">fn</span><span class="p">(</span><span class="nx">fa</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">t2</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">t2</span><span class="p">.</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">t1</span><span class="p">).</span><span class="nf">Seconds</span><span class="p">()</span><span class="o">*</span><span class="mi">1000</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="效率对比">效率对比<a hidden class="anchor" aria-hidden="true" href="#效率对比">#</a></h4>
<p>测试 100次 (即threadCount赋值100，下面同理)</p>
<p>2017/06/15 18:50:17 FormatFloat 耗时:0.0452 ms
2017/06/15 18:50:17 Sprintf 耗时:0.0512 ms
　　
测试 1000次</p>
<p>2017/06/15 18:50:43 FormatFloat 耗时:0.3861 ms
2017/06/15 18:50:43 Sprintf 耗时:0.4903 ms</p>
<p>测试 10000次</p>
<p>2017/06/15 18:50:58 FormatFloat 耗时:3.9688 ms
2017/06/15 18:50:58 Sprintf 耗时:5.2045 ms</p>
<p>测试  100000次　　　　</p>
<p>2017/06/15 18:51:20 FormatFloat 耗时:41.9253 ms
2017/06/15 18:51:20 Sprintf 耗时:51.8639 ms</p>
<p>测试  10000000次</p>
<p>2017/06/15 18:51:49 FormatFloat 耗时:3917.7585 ms
2017/06/15 18:51:54 Sprintf 耗时:5131.5497 ms</p>
<h4 id="结论">结论<a hidden class="anchor" aria-hidden="true" href="#结论">#</a></h4>
<p>strconv 包的函数不需要格式化，比 fmt 包的函数更加高效。</p>
<p>strconv下的FormatFloat明显快一些。fmt.Sprintf用到反射，效率不高，建议少用。　　　
　</p>
<h3 id="string转float">string转float<a hidden class="anchor" aria-hidden="true" href="#string转float">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ParseFloat</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">bitSize</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">f</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>解析一个表示浮点数的字符串并返回其值。</p>
<p>如果s合乎语法规则，函数会返回最为接近s表示值的一个浮点数（使用IEEE754规范舍入）。bitSize指定了期望的接收类型，32是float32（返回值可以不改变精确值的赋值给float32），64是float64；返回值err是*NumErr类型的，语法有误的，err.Error=ErrSyntax；结果超出表示范围的，返回值f为±Inf，err.Error= ErrRange。</p>
<p>string转float64 这里有两种方法，都支持指定精度。 注意：所有数字要在表现层显示最好转换为字符串传送给表现层，如果用于后端计算则转换为数字即可。比如：数字2.10 如果用保持5位数字精度显示： 那么 数字2.10 显示为：2.1, 而将2.10转换为字符串同时保持5位精度，则显示为: 2.10000。但是它们都是转换为了5位精度的，只是显示的时候，数字2.10000 直接显示为2.1了， 所以要显示精度则转换为字符串，要用于计算则转换为数字。</p>
<p>方法1： 只支持指定精度</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">strToFloat64</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">len</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="nx">lenstr</span> <span class="o">:=</span> <span class="s">&#34;%.&#34;</span> <span class="o">+</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">len</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;f&#34;</span>
	<span class="nx">value</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseFloat</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span>
	<span class="nx">nstr</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="nx">lenstr</span><span class="p">,</span><span class="nx">value</span><span class="p">)</span>
	<span class="nx">val</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseFloat</span><span class="p">(</span><span class="nx">nstr</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">val</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>方法2：支持指定精度，支持是否四舍五入</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">strToFloat64Round</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">prec</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">round</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="nx">f</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseFloat</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span>
	<span class="k">return</span> <span class="nf">Precision</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span><span class="nx">prec</span><span class="p">,</span><span class="nx">round</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Precision</span><span class="p">(</span><span class="nx">f</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">prec</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">round</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="nx">pow10_n</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Pow10</span><span class="p">(</span><span class="nx">prec</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">round</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Trunc</span><span class="p">(</span><span class="nx">f</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">/</span><span class="nx">pow10_n</span><span class="p">)</span><span class="o">*</span><span class="nx">pow10_n</span><span class="p">)</span> <span class="o">/</span> <span class="nx">pow10_n</span>	
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Trunc</span><span class="p">((</span><span class="nx">f</span><span class="p">)</span><span class="o">*</span><span class="nx">pow10_n</span><span class="p">)</span> <span class="o">/</span> <span class="nx">pow10_n</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="bool与string">bool与string<a hidden class="anchor" aria-hidden="true" href="#bool与string">#</a></h2>
<h3 id="bool转string">bool转string<a hidden class="anchor" aria-hidden="true" href="#bool转string">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">FormatBool</span><span class="p">(</span><span class="nx">b</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">string</span>

<span class="c1">// 将字符串转换为布尔值
</span><span class="c1">// 它接受真值：1, t, T, TRUE, true, True
</span><span class="c1">// 它接受假值：0, f, F, FALSE, false, False
</span><span class="c1">// 其它任何值都返回一个错误。
</span></code></pre></td></tr></table>
</div>
</div><h3 id="string转bool">string转bool<a hidden class="anchor" aria-hidden="true" href="#string转bool">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ParseBool</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="bytes与float64">bytes与float64<a hidden class="anchor" aria-hidden="true" href="#bytes与float64">#</a></h1>
<h2 id="bytes转float64">bytes转float64<a hidden class="anchor" aria-hidden="true" href="#bytes转float64">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">bytesToFloat64</span><span class="p">(</span><span class="nx">bytes</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="nx">bits</span> <span class="o">:=</span> <span class="nx">binary</span><span class="p">.</span><span class="nx">LittleEndian</span><span class="p">.</span><span class="nf">Uint64</span><span class="p">(</span><span class="nx">bytes</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Float64frombits</span><span class="p">(</span><span class="nx">bits</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="float64转bytes">float64转bytes<a hidden class="anchor" aria-hidden="true" href="#float64转bytes">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">float64ToBytes</span><span class="p">(</span><span class="nx">input</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">bits</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Float64bits</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span>
	<span class="nx">bytes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span> <span class="c1">//这里表示[]uint8, 所以用了 8
</span><span class="c1"></span>	<span class="nx">binary</span><span class="p">.</span><span class="nx">LittleEndian</span><span class="p">.</span><span class="nf">PutUint64</span><span class="p">(</span><span class="nx">bytes</span><span class="p">,</span><span class="nx">bits</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">bytes</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="结构体互相转换">结构体互相转换<a hidden class="anchor" aria-hidden="true" href="#结构体互相转换">#</a></h1>
<p>基本上只有两个完全一样的struct(就是结构体的名字不同，成员定义、顺序、包括tag都得一样)才可以直接转换，转换直接t2 := Test2(t1)这样就可以(t1是Test1类型)</p>
<p>前提是Test1, Test2符合转换条件，哪怕tag定义不一样都不行的，比如下面这样都不能转换的，编译会报错。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Test1</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Age</span> <span class="kt">int</span>      <span class="s">`json:&#34;age&#34;`</span>
    <span class="nx">Name</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">Test1</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Age</span> <span class="kt">int</span>
    <span class="nx">Name</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="数组与切片的转换">数组与切片的转换<a hidden class="anchor" aria-hidden="true" href="#数组与切片的转换">#</a></h1>
<h2 id="数组转切片">数组转切片<a hidden class="anchor" aria-hidden="true" href="#数组转切片">#</a></h2>
<p>利用索引运算</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">a</span><span class="p">[</span><span class="nx">low</span><span class="p">:</span><span class="nx">high</span><span class="p">]</span>
<span class="nx">a</span><span class="p">[</span><span class="nx">low</span><span class="p">:</span><span class="nx">high</span><span class="p">:</span><span class="nx">max</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="切片转数组">切片转数组<a hidden class="anchor" aria-hidden="true" href="#切片转数组">#</a></h2>
<p>slice的底层实现是数组，所以有一个&quot;hack&quot;方法，将slice的底层数组返回:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;reflect&#34;</span>
    <span class="s">&#34;unsafe&#34;</span>
<span class="p">)</span>
<span class="kd">const</span> <span class="nx">SIZEOF_INT32</span> <span class="p">=</span> <span class="mi">4</span> <span class="c1">// bytes
</span><span class="c1">// Get the slice header
</span><span class="c1"></span><span class="nx">header</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">SliceHeader</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">raw</span><span class="p">))</span>
<span class="c1">// The length and capacity of the slice are different.
</span><span class="c1"></span><span class="nx">header</span><span class="p">.</span><span class="nx">Len</span> <span class="o">/=</span> <span class="nx">SIZEOF_INT32</span>
<span class="nx">header</span><span class="p">.</span><span class="nx">Cap</span> <span class="o">/=</span> <span class="nx">SIZEOF_INT32</span>
<span class="c1">// Convert slice header to an []int32
</span><span class="c1"></span><span class="nx">data</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">[]</span><span class="kt">int32</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">header</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>安全的方式是生成数组然后依次赋值，注意copy是不行的，因为copy的参数必须都是slice:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;encoding/binary&#34;</span>
<span class="kd">const</span> <span class="nx">SIZEOF_INT32</span> <span class="p">=</span> <span class="mi">4</span> <span class="c1">// bytes
</span><span class="c1"></span><span class="nx">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int32</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">raw</span><span class="p">)</span><span class="o">/</span><span class="nx">SIZEOF_INT32</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">data</span> <span class="p">{</span>
    <span class="c1">// assuming little endian
</span><span class="c1"></span>    <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">binary</span><span class="p">.</span><span class="nx">LittleEndian</span><span class="p">.</span><span class="nf">Uint32</span><span class="p">(</span><span class="nx">raw</span><span class="p">[</span><span class="nx">i</span><span class="o">*</span><span class="nx">SIZEOF_INT32</span><span class="p">:(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nx">SIZEOF_INT32</span><span class="p">]))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="struct和字符串之间的转换">struct和字符串之间的转换<a hidden class="anchor" aria-hidden="true" href="#struct和字符串之间的转换">#</a></h1>
<p>struct类型的值和字符串之间的转换我们称之为marshal和unmarshal。</p>
<p>有非常多的库可以做这个事情，比如gob, encoding/json等。</p>
<h1 id="java字符串和go字符串之间的转换">Java字符串和Go字符串之间的转换<a hidden class="anchor" aria-hidden="true" href="#java字符串和go字符串之间的转换">#</a></h1>
<p>Java字符串在内部是以UTF-16编码方式存在的，每个字符包含两个字节。而Go字符串在内部是以UTF-8格式存在的，每个字符串占用的字节数可能不同。</p>
<p>可以使用unicode包进行转换，或者使用unicode/utf16</p>
<h1 id="字节slice和整数之间的转换">字节slice和整数之间的转换<a hidden class="anchor" aria-hidden="true" href="#字节slice和整数之间的转换">#</a></h1>
<p>包 encoding/binary实现了数值和字节序列之间的转换，包含变长int的各种编解码。</p>
<p>Go中的数值类型都是固定长度的位数(int8, uint8, int16, float32, complex64)，所以组成这些数组的bit可以转换成各种字节slice。</p>
<p>变长int (varint)经常用于节省空间，比如一个， Go实现的varint规范可以参考proto-buff的实现。很多编解码库中都使用了变长的int，这样对于大量的小数字我们可以用更少的字节来表示，对于网络传输来说很有好处。</p>
<p>这个包经常用在网络传输的序列化和反序列中。</p>
<p>另外一个值得注意的是数值是由多个字节组成的，这就涉及到字节序的问题，你必须指定使用小端序或大端序。</p>
<p>首先看一下定长的数值的转换，主要是Read和Write两个方法，底层还是通过移位操作实现的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">,</span> <span class="nx">order</span> <span class="nx">ByteOrder</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
<span class="kd">func</span> <span class="nf">Write</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">order</span> <span class="nx">ByteOrder</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;bytes&#34;</span>
	<span class="s">&#34;encoding/binary&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="nf">write</span><span class="p">()</span>
	<span class="nf">read</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">write</span><span class="p">()</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">data</span> <span class="p">=</span> <span class="p">[]</span><span class="kd">interface</span><span class="p">{}{</span>
		<span class="nb">uint16</span><span class="p">(</span><span class="mi">61374</span><span class="p">),</span> <span class="c1">//efbe
</span><span class="c1"></span>		<span class="nb">int8</span><span class="p">(</span><span class="o">-</span><span class="mi">54</span><span class="p">),</span>     <span class="c1">//-36
</span><span class="c1"></span>		<span class="nb">uint8</span><span class="p">(</span><span class="mi">254</span><span class="p">),</span>    <span class="c1">//fe
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">data</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="o">:=</span> <span class="nx">binary</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">binary</span><span class="p">.</span><span class="nx">BigEndian</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;binary.Write failed:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%x\n&#34;</span><span class="p">,</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">())</span> <span class="c1">//efbecafe
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">read</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">i1</span> <span class="kt">uint16</span>
	<span class="kd">var</span> <span class="nx">i2</span> <span class="kt">int8</span>
	<span class="kd">var</span> <span class="nx">i3</span> <span class="kt">uint8</span>
	<span class="nx">buf</span> <span class="o">:=</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">binary</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">binary</span><span class="p">.</span><span class="nx">BigEndian</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">i1</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;binary.Read failed:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">binary</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">binary</span><span class="p">.</span><span class="nx">BigEndian</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">i2</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;binary.Read failed:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">binary</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">binary</span><span class="p">.</span><span class="nx">BigEndian</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">i3</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;binary.Read failed:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i1</span><span class="p">,</span> <span class="nx">i2</span><span class="p">,</span> <span class="nx">i3</span><span class="p">)</span> <span class="c1">//61374 -54 254
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>一种不通用的适合特定类型的转换也可以使用下面的方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">readInt32</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">int32</span> <span class="p">{</span>
    <span class="c1">// equivalnt of return int32(binary.LittleEndian.Uint32(b))
</span><span class="c1"></span>    <span class="k">return</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">|</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">&lt;&lt;</span><span class="mi">8</span> <span class="p">|</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">&lt;&lt;</span><span class="mi">16</span> <span class="p">|</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">&lt;&lt;</span><span class="mi">24</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">//或者
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">ReadInt32Unsafe</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">int32</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">int32</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>变长int的操作函数:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">PutUvarint</span><span class="p">(</span><span class="nx">buf</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">x</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">int</span>
<span class="kd">func</span> <span class="nf">PutVarint</span><span class="p">(</span><span class="nx">buf</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">x</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">int</span>
<span class="kd">func</span> <span class="nf">Uvarint</span><span class="p">(</span><span class="nx">buf</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span>
<span class="kd">func</span> <span class="nf">Varint</span><span class="p">(</span><span class="nx">buf</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span>
<span class="kd">func</span> <span class="nf">ReadUvarint</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">ByteReader</span><span class="p">)</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="kd">func</span> <span class="nf">ReadVarint</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">ByteReader</span><span class="p">)</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>以及一个对象被转换成多少字节的方法:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Size</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">int</span>
</code></pre></td></tr></table>
</div>
</div><p>参考:<a href="https://colobu.com/2016/06/21/dive-into-go-6/#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2">https://colobu.com/2016/06/21/dive-into-go-6/#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go/">Go</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
