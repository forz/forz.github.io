<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>libevent源码剖析(七) | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="现在我们已经初步了解了libevent的Reactor组件——event_base和事件管理框架，接下来就是libevent事件处理的中心部">
<meta name="author" content="">
<link rel="canonical" href="/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%83/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="libevent源码剖析(七)" />
<meta property="og:description" content="现在我们已经初步了解了libevent的Reactor组件——event_base和事件管理框架，接下来就是libevent事件处理的中心部" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%83/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-25T17:01:35&#43;00:00" />
<meta property="article:modified_time" content="2017-06-25T17:01:35&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="libevent源码剖析(七)"/>
<meta name="twitter:description" content="现在我们已经初步了解了libevent的Reactor组件——event_base和事件管理框架，接下来就是libevent事件处理的中心部"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "libevent源码剖析(七)",
      "item": "/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%83/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "libevent源码剖析(七)",
  "name": "libevent源码剖析(七)",
  "description": "现在我们已经初步了解了libevent的Reactor组件——event_base和事件管理框架，接下来就是libevent事件处理的中心部",
  "keywords": [
    
  ],
  "articleBody": "现在我们已经初步了解了libevent的Reactor组件——event_base和事件管理框架，接下来就是libevent事件处理的中心部分——事件主循环，根据系统提供的事件多路分发机制执行事件循环，对已注册的就绪事件，调用注册事件的回调函数来处理事件。\n1 阶段性的胜利 Libevent将I/O事件、定时器和信号事件处理很好的结合到了一起，本节也会介绍libevent是如何做到这一点的。\n在看完本节的内容后，读者应该会对Libevent的基本框架：事件管理和主循环有比较清晰的认识了，并能够把libevent的事件控制流程清晰的串通起来，剩下的就是一些细节的内容了。\n2 事件处理主循环 Libevent的事件主循环主要是通过event_base_loop ()函数完成的，其主要操作如下面的流程图所示，event_base_loop所作的就是持续执行下面的循环。\n清楚了event_base_loop所作的主要操作，就可以对比源代码看个究竟了，代码结构还是相当清晰的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  int event_base_loop(struct event_base *base, int flags) { const struct eventop *evsel = base-evsel; void *evbase = base-evbase; struct timeval tv; struct timeval *tv_p; int res, done; // 清空时间缓存  base-tv_cache.tv_sec = 0; // evsignal_base是全局变量，在处理signal时，用于指名signal所属的event_base实例  if (base-sig.ev_signal_added) evsignal_base = base; done = 0; while (!done) { // 事件主循环 // 查看是否需要跳出循环，程序可以调用event_loopexit_cb()设置event_gotterm标记 // 调用event_base_loopbreak()设置event_break标记 if (base-event_gotterm) { base-event_gotterm = 0; break; } if (base-event_break) { base-event_break = 0; break; } // 校正系统时间，如果系统使用的是非MONOTONIC时间，用户可能会向后调整了系统时间 // 在timeout_correct函数里，比较last wait time和当前时间，如果当前时间// 表明时间有问题，这时需要更新timer_heap中所有定时事件的超时时间。 timeout_correct(base, \u0026tv); // 根据timer heap中事件的最小超时时间，计算系统I/O demultiplexer的最大等待时间 tv_p = \u0026tv; if (!base-event_count_active \u0026\u0026 !(flags \u0026 EVLOOP_NONBLOCK)) { timeout_next(base, \u0026tv_p); } else { // 依然有未处理的就绪事件，就让I/O demultiplexer立即返回，不必等待 // 下面会提到，在libevent中，低优先级的就绪事件可能不能立即被处理 evutil_timerclear(\u0026tv); } // 如果当前没有注册事件，就退出 if (!event_haveevents(base)) { event_debug((\"%s: no events registered.\", __func__)); return (1); } // 更新last wait time，并清空time cache gettime(base, \u0026base-event_tv); base-tv_cache.tv_sec = 0; // 调用系统I/O demultiplexer等待就绪I/O events，可能是epoll_wait，或者select等； // 在evsel-dispatch()中，会把就绪signal event、I/O event插入到激活链表中 res = evsel-dispatch(base, evbase, tv_p); if (res == -1) return (-1); // 将time cache赋值为当前系统时间 gettime(base, \u0026base-tv_cache); // 检查heap中的timer events，将就绪的timer event从heap上删除，并插入到激活链表中 timeout_process(base); // 调用event_process_active()处理激活链表中的就绪event，调用其回调函数执行事件处理 // 该函数会寻找最高优先级（priority值越小优先级越高）的激活事件链表， // 然后处理链表中的所有就绪事件； // 因此低优先级的就绪事件可能得不到及时处理； if (base-event_count_active) { event_process_active(base); if (!base-event_count_active \u0026\u0026 (flags \u0026 EVLOOP_ONCE)) done = 1; } else if (flags \u0026 EVLOOP_NONBLOCK) done = 1; } // 循环结束，清空时间缓存 base-tv_cache.tv_sec = 0; event_debug((\"%s: asked to terminate loop.\", __func__)); return (0); }   3 I/O和Timer事件的统一 Libevent将Timer和Signal事件都统一到了系统的I/O 的demultiplex机制中了，相信读者从上面的流程和代码中也能窥出一斑了，下面就再啰嗦一次了。\n首先将Timer事件融合到系统I/O多路复用机制中，还是相当清晰的，因为系统的I/O机制像select()和epoll_wait()都允许程序制定一个最大等待时间（也称为最大超时时间）timeout，即使没有I/O事件发生，它们也保证能在timeout时间内返回。\n那么根据所有Timer事件的最小超时时间来设置系统I/O的timeout时间；当系统I/O返回时，再激活所有就绪的Timer事件就可以了，这样就能将Timer事件完美的融合到系统的I/O机制中了。\n这是在Reactor和Proactor模式（主动器模式，比如Windows上的IOCP）中处理Timer事件的经典方法了，ACE采用的也是这种方法，大家可以参考POSA vol2书中的Reactor模式一节。\n堆是一种经典的数据结构，向堆中插入、删除元素时间复杂度都是O(lgN)，N为堆中元素的个数，而获取最小key值（小根堆）的复杂度为O(1)；因此变成了管理Timer事件的绝佳人选（当然是非唯一的），libevent就是采用的堆结构。\n4 I/O和Signal事件的统一 Signal是异步事件的经典事例，将Signal事件统一到系统的I/O多路复用中就不像Timer事件那么自然了，Signal事件的出现对于进程来讲是完全随机的，进程不能只是测试一个变量来判别是否发生了一个信号，而是必须告诉内核“在此信号发生时，请执行如下的操作”。\n如果当Signal发生时，并不立即调用event的callback函数处理信号，而是设法通知系统的I/O机制，让其返回，然后再统一和I/O事件以及Timer一起处理，不就可以了嘛。是的，这也是libevent中使用的方法。\n问题的核心在于，当Signal发生时，如何通知系统的I/O多路复用机制，这里先卖个小关子，放到信号处理一节再详细说明，我想读者肯定也能想出通知的方法，比如使用pipe。\n5 小结 介绍了libevent的事件主循环，描述了libevent是如何处理就绪的I/O事件、定时器和信号事件，以及如何将它们无缝的融合到一起。\n转载：http://blog.csdn.net/sparkliang/article/details/4987751\n",
  "wordCount" : "2447",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-25T17:01:35Z",
  "dateModified": "2017-06-25T17:01:35Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%83/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      libevent源码剖析(七)
    </h1>
    <div class="post-meta">June 25, 2017
</div>
  </header> 
  <div class="post-content"><p>现在我们已经初步了解了libevent的Reactor组件——event_base和事件管理框架，接下来就是libevent事件处理的中心部分——事件主循环，根据系统提供的事件多路分发机制执行事件循环，对已注册的就绪事件，调用注册事件的回调函数来处理事件。</p>
<h1 id="1-阶段性的胜利">1 阶段性的胜利<a hidden class="anchor" aria-hidden="true" href="#1-阶段性的胜利">#</a></h1>
<p>Libevent将I/O事件、定时器和信号事件处理很好的结合到了一起，本节也会介绍libevent是如何做到这一点的。</p>
<p>在看完本节的内容后，读者应该会对Libevent的基本框架：事件管理和主循环有比较清晰的认识了，并能够把libevent的事件控制流程清晰的串通起来，剩下的就是一些细节的内容了。</p>
<h1 id="2-事件处理主循环">2 事件处理主循环<a hidden class="anchor" aria-hidden="true" href="#2-事件处理主循环">#</a></h1>
<p>Libevent的事件主循环主要是通过event_base_loop ()函数完成的，其主要操作如下面的流程图所示，event_base_loop所作的就是持续执行下面的循环。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/main-loop.JPG" alt=""  />
</p>
<p>清楚了event_base_loop所作的主要操作，就可以对比源代码看个究竟了，代码结构还是相当清晰的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">event_base_loop</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="k">const</span> <span class="k">struct</span> <span class="n">eventop</span> <span class="o">*</span><span class="n">evsel</span> <span class="o">=</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">evsel</span><span class="p">;</span>  
    <span class="kt">void</span> <span class="o">*</span><span class="n">evbase</span> <span class="o">=</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">evbase</span><span class="p">;</span>  
    <span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>  
    <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">tv_p</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">res</span><span class="p">,</span> <span class="n">done</span><span class="p">;</span>  
    <span class="c1">// 清空时间缓存  
</span><span class="c1"></span>    <span class="n">base</span><span class="o">-&gt;</span><span class="n">tv_cache</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
    <span class="c1">// evsignal_base是全局变量，在处理signal时，用于指名signal所属的event_base实例  
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">.</span><span class="n">ev_signal_added</span><span class="p">)</span>  
        <span class="n">evsignal_base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>  
    <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 事件主循环  
</span><span class="c1">// 查看是否需要跳出循环，程序可以调用event_loopexit_cb()设置event_gotterm标记  
</span><span class="c1">// 调用event_base_loopbreak()设置event_break标记  
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">event_gotterm</span><span class="p">)</span> <span class="p">{</span>  
<span class="n">base</span><span class="o">-&gt;</span><span class="n">event_gotterm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
<span class="k">break</span><span class="p">;</span>  
<span class="p">}</span>  
<span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">event_break</span><span class="p">)</span> <span class="p">{</span>  
<span class="n">base</span><span class="o">-&gt;</span><span class="n">event_break</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
<span class="k">break</span><span class="p">;</span>  
<span class="p">}</span>  
<span class="c1">// 校正系统时间，如果系统使用的是非MONOTONIC时间，用户可能会向后调整了系统时间  
</span><span class="c1">// 在timeout_correct函数里，比较last wait time和当前时间，如果当前时间&lt; last wait time  
</span><span class="c1">// 表明时间有问题，这时需要更新timer_heap中所有定时事件的超时时间。  
</span><span class="c1"></span><span class="n">timeout_correct</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span>  

<span class="c1">// 根据timer heap中事件的最小超时时间，计算系统I/O demultiplexer的最大等待时间  
</span><span class="c1"></span><span class="n">tv_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tv</span><span class="p">;</span>  
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">event_count_active</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EVLOOP_NONBLOCK</span><span class="p">))</span> <span class="p">{</span>  
<span class="n">timeout_next</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tv_p</span><span class="p">);</span>  
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  
<span class="c1">// 依然有未处理的就绪事件，就让I/O demultiplexer立即返回，不必等待  
</span><span class="c1">// 下面会提到，在libevent中，低优先级的就绪事件可能不能立即被处理  
</span><span class="c1"></span><span class="n">evutil_timerclear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span>  
<span class="p">}</span>  
<span class="c1">// 如果当前没有注册事件，就退出  
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event_haveevents</span><span class="p">(</span><span class="n">base</span><span class="p">))</span> <span class="p">{</span>  
<span class="n">event_debug</span><span class="p">((</span><span class="s">&#34;%s: no events registered.&#34;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">));</span>  
<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>  
<span class="p">}</span>  
<span class="c1">// 更新last wait time，并清空time cache  
</span><span class="c1"></span><span class="n">gettime</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">event_tv</span><span class="p">);</span>  
<span class="n">base</span><span class="o">-&gt;</span><span class="n">tv_cache</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
<span class="c1">// 调用系统I/O demultiplexer等待就绪I/O events，可能是epoll_wait，或者select等；  
</span><span class="c1">// 在evsel-&gt;dispatch()中，会把就绪signal event、I/O event插入到激活链表中  
</span><span class="c1"></span><span class="n">res</span> <span class="o">=</span> <span class="n">evsel</span><span class="o">-&gt;</span><span class="n">dispatch</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">evbase</span><span class="p">,</span> <span class="n">tv_p</span><span class="p">);</span>  
<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>  
<span class="c1">// 将time cache赋值为当前系统时间  
</span><span class="c1"></span><span class="n">gettime</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">tv_cache</span><span class="p">);</span>  
<span class="c1">// 检查heap中的timer events，将就绪的timer event从heap上删除，并插入到激活链表中  
</span><span class="c1"></span><span class="n">timeout_process</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>  
<span class="c1">// 调用event_process_active()处理激活链表中的就绪event，调用其回调函数执行事件处理  
</span><span class="c1">// 该函数会寻找最高优先级（priority值越小优先级越高）的激活事件链表，  
</span><span class="c1">// 然后处理链表中的所有就绪事件；  
</span><span class="c1">// 因此低优先级的就绪事件可能得不到及时处理；  
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">event_count_active</span><span class="p">)</span> <span class="p">{</span>  
<span class="n">event_process_active</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>  
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">event_count_active</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EVLOOP_ONCE</span><span class="p">))</span>  
<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EVLOOP_NONBLOCK</span><span class="p">)</span>  
<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  
<span class="p">}</span>  
<span class="c1">// 循环结束，清空时间缓存  
</span><span class="c1"></span><span class="n">base</span><span class="o">-&gt;</span><span class="n">tv_cache</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
<span class="n">event_debug</span><span class="p">((</span><span class="s">&#34;%s: asked to terminate loop.&#34;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">));</span>  
<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>  
<span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><h1 id="3-io和timer事件的统一">3 I/O和Timer事件的统一<a hidden class="anchor" aria-hidden="true" href="#3-io和timer事件的统一">#</a></h1>
<p>Libevent将Timer和Signal事件都统一到了系统的I/O 的demultiplex机制中了，相信读者从上面的流程和代码中也能窥出一斑了，下面就再啰嗦一次了。</p>
<p>首先将Timer事件融合到系统I/O多路复用机制中，还是相当清晰的，因为系统的I/O机制像select()和epoll_wait()都允许程序制定一个最大等待时间（也称为最大超时时间）timeout，即使没有I/O事件发生，它们也保证能在timeout时间内返回。</p>
<p>那么根据所有Timer事件的最小超时时间来设置系统I/O的timeout时间；当系统I/O返回时，再激活所有就绪的Timer事件就可以了，这样就能将Timer事件完美的融合到系统的I/O机制中了。</p>
<p>这是在Reactor和Proactor模式（主动器模式，比如Windows上的IOCP）中处理Timer事件的经典方法了，ACE采用的也是这种方法，大家可以参考POSA vol2书中的Reactor模式一节。</p>
<p>堆是一种经典的数据结构，向堆中插入、删除元素时间复杂度都是O(lgN)，N为堆中元素的个数，而获取最小key值（小根堆）的复杂度为O(1)；因此变成了管理Timer事件的绝佳人选（当然是非唯一的），libevent就是采用的堆结构。</p>
<h1 id="4-io和signal事件的统一">4 I/O和Signal事件的统一<a hidden class="anchor" aria-hidden="true" href="#4-io和signal事件的统一">#</a></h1>
<p>Signal是异步事件的经典事例，将Signal事件统一到系统的I/O多路复用中就不像Timer事件那么自然了，Signal事件的出现对于进程来讲是完全随机的，进程不能只是测试一个变量来判别是否发生了一个信号，而是必须告诉内核“在此信号发生时，请执行如下的操作”。</p>
<p>如果当Signal发生时，并不立即调用event的callback函数处理信号，而是设法通知系统的I/O机制，让其返回，然后再统一和I/O事件以及Timer一起处理，不就可以了嘛。是的，这也是libevent中使用的方法。</p>
<p>问题的核心在于，当Signal发生时，如何通知系统的I/O多路复用机制，这里先卖个小关子，放到信号处理一节再详细说明，我想读者肯定也能想出通知的方法，比如使用pipe。</p>
<h1 id="5-小结">5 小结<a hidden class="anchor" aria-hidden="true" href="#5-小结">#</a></h1>
<p>介绍了libevent的事件主循环，描述了libevent是如何处理就绪的I/O事件、定时器和信号事件，以及如何将它们无缝的融合到一起。</p>
<p>转载：<a href="">http://blog.csdn.net/sparkliang/article/details/4987751</a></p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
