<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>路径问题 | Forz Blog</title>
<meta name="keywords" content="Graph, DP" />
<meta name="description" content="LeetCode 62. Unique Paths A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How">
<meta name="author" content="">
<link rel="canonical" href="/post/%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="路径问题" />
<meta property="og:description" content="LeetCode 62. Unique Paths A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-24T22:08:03&#43;00:00" />
<meta property="article:modified_time" content="2017-06-24T22:08:03&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="路径问题"/>
<meta name="twitter:description" content="LeetCode 62. Unique Paths A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "路径问题",
      "item": "/post/%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "路径问题",
  "name": "路径问题",
  "description": "LeetCode 62. Unique Paths A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How",
  "keywords": [
    "Graph", "DP"
  ],
  "articleBody": "LeetCode 62. Unique Paths A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).\nHow many possible unique paths are there?\n解析：\n对于格点(i,j)。由于只能从上格点(i-1,j)或左格点(i,j-1)到达，并且两者路径是不重复的\n因此path[i][j] = path[i-1][j]+path[i][j-1]\n因为递推公式只与i-1和j-1有关，可以用滚动数组优化来降维，只保存一行的DP值，按行扫描。\n1 2 3 4 5 6 7 8 9 10  class Solution { public: //组合方法会超int值，不能使用 int uniquePaths(int m, int n) { vectorint v(n, 1); //初始化dp值，第一行所有的格子只有一种走法  for(int i=1; im; ++i)//滚动数组，从第二行开始滚  for(int j=1; jn; ++j)//从第二列开始，第一列总为1，不需要访问。  v[j]+=v[j-1]; return v[n-1]; } };   LeetCode 63. Unique Paths II Follow up for “Unique Paths”:\nNow consider if some obstacles are added to the grids. How many unique paths would there be?\nAn obstacle and empty space is marked as 1 and 0 respectively in the grid.\nFor example,\nThere is one obstacle in the middle of a 3x3 grid as illustrated below.\n[ [0,0,0], [0,1,0], [0,0,0] ]  The total number of unique paths is 2.\nNote: m and n will be at most 100.\n解析：这道题只是在前面62题的基础上加了路障，也很简单，就是在路障这个地方就把它的路径的个数直接设为0。DP初始值不能全设为1，要进行判断，第一列和第一行都要判断是否为路障。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { public: int uniquePathsWithObstacles(vectorvectorint  \u0026obstacleGrid) { const int m = obstacleGrid.size();//m行  const int n = obstacleGrid[0].size();//n列  if (obstacleGrid[0][0] || obstacleGrid[m-1][n-1]) return 0;//没有结果  vectorint f(n, 0);//初始化dp值，全为0，之后要判断该格子是否为障碍  f[0] = 1; for (int i = 0; i  m; i++)//按行求dp，不需要增加行这一维，从第1行开始dp  for (int j = 0; j  n; j++)//从第一列开始dp，如果第一列任何一个格子为障碍，那么就不是1，而是0  f[j] = obstacleGrid[i][j] ? 0 : (j == 0 ? 0 : f[j - 1]) + f[j];//扫描第一列的时候要特判来防止越界  return f[n - 1]; } };   LeetCode 64. Minimum Path Sum Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\n解析：\n状态A[i][j]可以表示左上点到grid[i][j]作为右下角的路径的最小和，状态转移方程是：\nA[i][j]=min{A[i-1][j],A[i][j-1]}+grid[i][j]\n因为grid[i][j]表示从(0,0)到（i，j）的最小距离，只依赖于grid[i-1][j]和grid[i][j-1]，所以可以使用滚动数组来优化，只保存一列的DP值，按列扫描。\n对第一列和第一行的DP值进行单独初始化，\n第一列的每一行都是从上一行向下走得到。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution { public: int minPathSum(vectorvectorint\u0026 grid) { int m = grid.size(); //矩阵行数  int n = grid[0].size();//矩阵列数  vectorint cur(m, grid[0][0]);//只建一列  for (int i = 1; i  m; i++)//初始化dp值（第一列）  cur[i] = cur[i - 1] + grid[i][0]; for (int j = 1; j  n; j++) {//从第二列开始扫描 //进行dp，每一次dp时cur数组保存的是上一列的数值(保存向右走的数据)。  cur[0] += grid[0][j]; //每一列的第一行单独初始化（路径单一且防止越界）  for (int i = 1; i  m; i++)//从第二行开始扫描  cur[i] = min(cur[i - 1], cur[i]) + grid[i][j];//比较向下走还是向右走  } return cur[m - 1]; } };   补充： 常规解法\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public: int minPathSum(vectorvectorint\u0026 grid) { auto m = grid.size(), n = grid[0].size(); for (int i = 1; i  m; ++i) grid[i][0] += grid[i - 1][0];//第一列 for (int j = 1; j  n; ++j) grid[0][j] += grid[0][j - 1];//第一行 for (int i = 1; i  m; ++i) for (int j = 1; j  n; ++j) grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]); return grid[m - 1][n - 1]; } };   174. Dungeon Game The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\nSome of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers).\nIn order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.\nWrite a function to determine the knight’s minimum initial health so that he is able to rescue the princess. For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT- RIGHT - DOWN - DOWN.\nNotes:\nThe knight’s health has no upper bound.\nAny room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.\n解析： 由于最终目标是骑士到达公主位置，因此在右下角必须满足HP剩余1.\n大多数动态规划题要求某单一特征取最值，比如求左上角到右下角的最大／最小步数等。 但是这道题目不止要求取最值，还要求中间步骤满足一定的要求，因此常规解法并不能满足要求。\n因为要满足重叠子，每一个dp值都代表到达结果的方案，而如果从左上往右下推（每个dp值表示从左上角到该位置的最少HP），因为DP值保存最小HP，很多位置以当前的dp值开始走，满足不了过程中HP大于0的要求，根本无法到达右下角。\n从右下角位置开始倒推，每个位置需要同时满足两个条件：（1）该位置HP为1(保证不死)，（2）该位置的HP足够到达公主(使用动态规划)\n动态规划题目很多都是可逆的，即左上角－右下角或者右下角－左上角会产生相同的结果，但是中间有要求的题目就变成了单向解决（每个子问题都要保证能到达结果）。\n这道题目假如使用左上角出发就不能用DP解，因为我们既要求初始化生命值最少，又要求当前生命值尽可能多，无法判断出最优子结构。\n状态: d[i][j]，表示从（i，j）位置到右下角开始需要最少的hp值\n状态转移：d[i][j]=min(d[i+1][j],d[i][j+1])-dungeon[i][j]\ni与i和i+1有关，，j与j和j+1有关，可以逆序枚举i和j来优化\nd[i][j] 但是要注意任何时候hp值不能小于等于0，这个时候d[i][j]应该设置为1，来表示不需要额外的hp值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution {//从右下往左上dp public: int calculateMinimumHP(vectorvectorint\u0026 dungeon) { int n=dungeon.size(),m=dungeon[0].size(); vectorint dp(n+1,INT_MAX);//dp初始全为MAX  dp[n-1]=1; for(int j=m-1;j=0;j--){ for(int i=n-1;i=0;i--){ dp[i]=min(dp[i],dp[i+1])-dungeon[i][j]; dp[i]=max(1,dp[i]); } } return dp[0]; } };   120. Triangle Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.\nFor example, given the following triangle\n[ [2], [3,4], [6,5,7], [4,1,8,3] ]  The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).\nNote:\nBonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.\n解析：\n这是一道动态规划的题目，求一个三角形二维数组从顶到低端的最小路径和。\n可以观察出来，顶端只有一个点，若是自下而上DP，那么S[0][0]就是要求解的答案。若是自上而下DP，还需要扫描一遍底端节点，很麻烦。\n我们从底端向顶端计算。设状态为 S[i][j]表示从从位置 ( i, j ) 出发，到最低端路径的最小和\n状态转移方程：\nS[i][j] = min(S[i+1][j] + S[i+1][j+1]) +S[i][j]\n1 2 3 4 5 6 7 8 9 10  class Solution { public: int minimumTotal(vectorvectorint  \u0026triangle) {//自下向上DP，好找规律  for (int i = triangle.size() - 2; i = 0; --i)//从倒数第二层开始DP  for (int j = 0; j  i; ++j){ triangle[i][j] +=min(triangle[i+1][j+1],triangle[i+1][j]); } return triangle[0][0]; } };   329. Longest Increasing Path in a Matrix Given an integer matrix, find the length of the longest increasing path.\nFrom each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).\nExample 1:\nnums = [ [9,9,4], [6,6,8], [2,1,1] ]  Return 4\nThe longest increasing path is [1, 2, 6, 9].\nExample 2:\nnums = [ [3,4,5], [3,2,6], [2,2,1] ]  Return 4\nThe longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.\n解析：\n直接暴力搜索会TLE，因为本题只需要求最长路径，可以用记忆化搜索。\n枚举起点，从每一个单元格出发，递归寻找其最长递增路径。\n利用辅助数组dp记录已经搜索过的单元格，dp[x][y]存储从单元格(x, y)出发的最长递增路径长度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class Solution { private: int dfs(vectorvectorint\u0026 matrix, vectorvectorint\u0026 record, int x, int y, int lastVal) {//dfs需要保存前驱节点的值  if (x  0 || y  0 || x = matrix.size() || y = matrix[0].size()) return 0;//越界终止递归  if (matrix[x][y]  lastVal)//  { if (record[x][y] != 0) return record[x][y]; // 路线已算出，直接返回结果  int left = dfs(matrix, record, x + 1, y, matrix[x][y]) + 1; int right = dfs(matrix, record, x - 1, y, matrix[x][y]) + 1; int top = dfs(matrix, record, x, y + 1, matrix[x][y]) + 1; int bottom = dfs(matrix, record, x, y - 1, matrix[x][y]) + 1; record[x][y] = max(left, max(right, max(top, bottom))); return record[x][y]; } return 0; } public: int longestIncreasingPath(vectorvectorint\u0026 matrix) { if (matrix.size() == 0) return 0; vectorint temp(matrix[0].size(), 0); vectorvectorint record(matrix.size(), temp);//构建dp二维数组  int longest = 0; for (int i = 0; i  matrix.size(); ++i)//枚举每个起点  for (int j = 0; j  matrix[0].size(); ++j) longest = max(longest, dfs(matrix, record, i, j, -1)); return longest; } };   ",
  "wordCount" : "3102",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-24T22:08:03Z",
  "dateModified": "2017-06-24T22:08:03Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      路径问题
    </h1>
    <div class="post-meta">June 24, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="leetcode-62-unique-paths">LeetCode 62. Unique Paths<a hidden class="anchor" aria-hidden="true" href="#leetcode-62-unique-paths">#</a></h1>
<p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/robot_maze.png" alt=""  />
</p>
<p>解析：</p>
<p>对于格点(i,j)。由于只能从上格点(i-1,j)或左格点(i,j-1)到达，并且两者路径是不重复的</p>
<p>因此path[i][j] = path[i-1][j]+path[i][j-1]</p>
<p>因为递推公式只与i-1和j-1有关，可以用滚动数组优化来降维，只保存一行的DP值，按行扫描。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>  
<span class="nl">public</span><span class="p">:</span>  <span class="c1">//组合方法会超int值，不能使用
</span><span class="c1"></span><span class="kt">int</span> <span class="n">uniquePaths</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>  
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">//初始化dp值，第一行所有的格子只有一种走法
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="c1">//滚动数组，从第二行开始滚
</span><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="c1">//从第二列开始，第一列总为1，不需要访问。
</span><span class="c1"></span>            <span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+=</span><span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>  
    <span class="k">return</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>  
<span class="p">}</span>  
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-63-unique-paths-ii">LeetCode 63. Unique Paths II<a hidden class="anchor" aria-hidden="true" href="#leetcode-63-unique-paths-ii">#</a></h1>
<p>Follow up for “Unique Paths”:</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p>An obstacle and empty space is marked as 1 and 0 respectively in the grid.</p>
<p>For example,</p>
<p>There is one obstacle in the middle of a 3x3 grid as illustrated below.</p>
<pre><code>[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
</code></pre>
<p>The total number of unique paths is 2.</p>
<p>Note: m and n will be at most 100.</p>
<p>解析：这道题只是在前面62题的基础上加了路障，也很简单，就是在路障这个地方就把它的路径的个数直接设为0。DP初始值不能全设为1，要进行判断，第一列和第一行都要判断是否为路障。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">uniquePathsWithObstacles</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">obstacleGrid</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">obstacleGrid</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="c1">//m行
</span><span class="c1"></span>    <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="c1">//n列
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="n">obstacleGrid</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//没有结果
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span><span class="c1">//初始化dp值，全为0，之后要判断该格子是否为障碍
</span><span class="c1"></span>    <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//按行求dp，不需要增加行这一维，从第1行开始dp
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="c1">//从第一列开始dp，如果第一列任何一个格子为障碍，那么就不是1，而是0
</span><span class="c1"></span>            <span class="n">f</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">obstacleGrid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">f</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="c1">//扫描第一列的时候要特判来防止越界
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-64-minimum-path-sum">LeetCode 64. Minimum Path Sum<a hidden class="anchor" aria-hidden="true" href="#leetcode-64-minimum-path-sum">#</a></h1>
<p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</p>
<p>Note: You can only move either down or right at any point in time.</p>
<p>解析：</p>
<p>状态A[i][j]可以表示左上点到grid[i][j]作为右下角的路径的最小和，状态转移方程是：</p>
<p>A[i][j]=min{A[i-1][j],A[i][j-1]}+grid[i][j]</p>
<p>因为grid[i][j]表示从(0,0)到（i，j）的最小距离，只依赖于grid[i-1][j]和grid[i][j-1]，所以可以使用滚动数组来优化，只保存一列的DP值，按列扫描。</p>
<p>对第一列和第一行的DP值进行单独初始化，</p>
<p>第一列的每一行都是从上一行向下走得到。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">minPathSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">)</span> <span class="p">{</span>

    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>     <span class="c1">//矩阵行数
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="c1">//矩阵列数
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">cur</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span><span class="c1">//只建一列
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//初始化dp值（第一列）
</span><span class="c1"></span>        <span class="n">cur</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span> 
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="c1">//从第二列开始扫描
</span><span class="c1">//进行dp，每一次dp时cur数组保存的是上一列的数值(保存向右走的数据)。
</span><span class="c1"></span>        <span class="n">cur</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">];</span> <span class="c1">//每一列的第一行单独初始化（路径单一且防止越界）
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//从第二行开始扫描
</span><span class="c1"></span>            <span class="n">cur</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">cur</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">cur</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span><span class="c1">//比较向下走还是向右走
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="n">cur</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>补充： 常规解法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">minPathSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">)</span> <span class="p">{</span>
<span class="k">auto</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span><span class="c1">//第一列
</span><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span><span class="c1">//第一行
</span><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">min</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
<span class="k">return</span> <span class="n">grid</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="174-dungeon-game">174. Dungeon Game<a hidden class="anchor" aria-hidden="true" href="#174-dungeon-game">#</a></h1>
<p>The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.</p>
<p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.</p>
<p>Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers).</p>
<p>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.</p>
<p>Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess.
For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN.</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20170415162733.png" alt=""  />
</p>
<p>Notes:</p>
<p>The knight’s health has no upper bound.</p>
<p>Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</p>
<p>解析：
由于最终目标是骑士到达公主位置，因此在右下角必须满足HP剩余1.</p>
<p>大多数动态规划题要求某单一特征取最值，比如求左上角到右下角的最大／最小步数等。
但是这道题目不止要求取最值，还要求中间步骤满足一定的要求，因此常规解法并不能满足要求。</p>
<p>因为要满足重叠子，每一个dp值都代表到达结果的方案，而如果从左上往右下推（每个dp值表示从左上角到该位置的最少HP），因为DP值保存最小HP，很多位置以当前的dp值开始走，满足不了过程中HP大于0的要求，根本无法到达右下角。</p>
<p>从右下角位置开始倒推，每个位置需要同时满足两个条件：（1）该位置HP为1(保证不死)，（2）该位置的HP足够到达公主(使用动态规划)</p>
<p>动态规划题目很多都是可逆的，即左上角－右下角或者右下角－左上角会产生相同的结果，但是中间有要求的题目就变成了单向解决（每个子问题都要保证能到达结果）。</p>
<p>这道题目假如使用左上角出发就不能用DP解，因为我们既要求初始化生命值最少，又要求当前生命值尽可能多，无法判断出最优子结构。</p>
<p>状态: d[i][j]，表示从（i，j）位置到右下角开始需要最少的hp值</p>
<p>状态转移：d[i][j]=min(d[i+1][j],d[i][j+1])-dungeon[i][j]</p>
<p>i与i和i+1有关，，j与j和j+1有关，可以逆序枚举i和j来优化</p>
<p>d[i][j] &lt;= 0是无意义的，当d[i][j]&lt;=0时实际上表示的是在该位置，不需要额外的hp值，就可以到达右下角</p>
<p>但是要注意任何时候hp值不能小于等于0，这个时候d[i][j]应该设置为1，来表示不需要额外的hp值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span><span class="c1">//从右下往左上dp
</span><span class="c1"></span><span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">calculateMinimumHP</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">dungeon</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">dungeon</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="n">m</span><span class="o">=</span><span class="n">dungeon</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">INT_MAX</span><span class="p">);</span><span class="c1">//dp初始全为MAX
</span><span class="c1"></span>        <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="n">dungeon</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="120-triangle">120. Triangle<a hidden class="anchor" aria-hidden="true" href="#120-triangle">#</a></h1>
<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p>For example, given the following triangle</p>
<pre><code>[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
</code></pre>
<p>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p>
<p>Note:</p>
<p>Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p>
<p>解析：</p>
<p>这是一道动态规划的题目，求一个三角形二维数组从顶到低端的最小路径和。</p>
<p>可以观察出来，顶端只有一个点，若是自下而上DP，那么S[0][0]就是要求解的答案。若是自上而下DP，还需要扫描一遍底端节点，很麻烦。</p>
<p>我们从底端向顶端计算。设状态为 S[i][j]表示从从位置 ( i, j ) 出发，到最低端路径的最小和</p>
<p>状态转移方程：</p>
<p>S[i][j] = min(S[i+1][j] + S[i+1][j+1]) +S[i][j]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">minimumTotal</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">triangle</span><span class="p">)</span> <span class="p">{</span><span class="c1">//自下向上DP，好找规律
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span><span class="c1">//从倒数第二层开始DP
</span><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
                <span class="n">triangle</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span><span class="n">min</span><span class="p">(</span><span class="n">triangle</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">triangle</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="k">return</span> <span class="n">triangle</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="329-longest-increasing-path-in-a-matrix">329. Longest Increasing Path in a Matrix<a hidden class="anchor" aria-hidden="true" href="#329-longest-increasing-path-in-a-matrix">#</a></h1>
<p>Given an integer matrix, find the length of the longest increasing path.</p>
<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>
<p>Example 1:</p>
<pre><code>nums = [
  [9,9,4],
  [6,6,8],
  [2,1,1]
]
</code></pre>
<p>Return 4</p>
<p>The longest increasing path is [1, 2, 6, 9].</p>
<p>Example 2:</p>
<pre><code>nums = [
  [3,4,5],
  [3,2,6],
  [2,2,1]
]
</code></pre>
<p>Return 4</p>
<p>The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</p>
<p>解析：</p>
<p>直接暴力搜索会TLE，因为本题只需要求最长路径，可以用记忆化搜索。</p>
<p>枚举起点，从每一个单元格出发，递归寻找其最长递增路径。</p>
<p>利用辅助数组dp记录已经搜索过的单元格，dp[x][y]存储从单元格(x, y)出发的最长递增路径长度。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">private</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">dfs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">record</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lastVal</span><span class="p">)</span>
<span class="p">{</span><span class="c1">//dfs需要保存前驱节点的值
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">())</span> 
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//越界终止递归
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lastVal</span><span class="p">)</span><span class="c1">//
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">record</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">];</span> <span class="c1">// 路线已算出，直接返回结果
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">record</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">matrix</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">record</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">matrix</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">record</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">matrix</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">bottom</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">record</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">matrix</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">record</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">bottom</span><span class="p">)));</span>
        <span class="k">return</span> <span class="n">record</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">longestIncreasingPath</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">matrix</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">temp</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">record</span><span class="p">(</span><span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">temp</span><span class="p">);</span><span class="c1">//构建dp二维数组
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">longest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="c1">//枚举每个起点
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="n">longest</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">longest</span><span class="p">,</span> <span class="n">dfs</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">record</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">longest</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/graph/"> Graph</a></li>
      <li><a href="/tags/dp/">DP</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
