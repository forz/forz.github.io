<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go的调度器源码剖析 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author"
  content="Forz" /><meta name="description" content="设计原理 协程 进程时代 最初的计算机上面没有操作系统，更别提进程、线程和协程了。 后来，现代化的计算机有了操作系统，每个程序都是一个进程，但是操作" /><meta name="keywords"
  content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.84.4 with theme even" />


<link rel="canonical" href="/post/go%E7%9A%84%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link rel="stylesheet" href="/css/search.css" />


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go的调度器源码剖析" />
<meta property="og:description" content="设计原理 协程 进程时代 最初的计算机上面没有操作系统，更别提进程、线程和协程了。 后来，现代化的计算机有了操作系统，每个程序都是一个进程，但是操作" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E7%9A%84%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-07-12T13:29:52+00:00" />
<meta property="article:modified_time" content="2019-07-12T13:29:52+00:00" />

<meta itemprop="name" content="Go的调度器源码剖析">
<meta itemprop="description" content="设计原理 协程 进程时代 最初的计算机上面没有操作系统，更别提进程、线程和协程了。 后来，现代化的计算机有了操作系统，每个程序都是一个进程，但是操作"><meta itemprop="datePublished" content="2019-07-12T13:29:52+00:00" />
<meta itemprop="dateModified" content="2019-07-12T13:29:52+00:00" />
<meta itemprop="wordCount" content="74979">
<meta itemprop="keywords" content="Go源码," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go的调度器源码剖析"/>
<meta name="twitter:description" content="设计原理 协程 进程时代 最初的计算机上面没有操作系统，更别提进程、线程和协程了。 后来，现代化的计算机有了操作系统，每个程序都是一个进程，但是操作"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="clearfix">
  <div class="logo-wrapper">
    <a href="/" class="logo">Forz Blog</a>
  </div>

  <nav class="site-navbar">
    <ul id="menu" class="menu">
      <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
    </ul>
  </nav>
</div>


<div class="search-container">
  <div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="Search for titles or URIs..."
        name="search" autocomplete="off" />
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path
            d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js"></script>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js"></script>
<script>
    var client = algoliasearch("IAR2EF5L65", "b4b9da2eba53aa6dabe4b8ac9e8676e1");
    var index = client.initIndex('forz.forzvina.com');
    autocomplete('#aa-search-input',
        { hint: false }, {
        source: autocomplete.sources.hits(index, { hitsPerPage: 8 }),
        displayKey: 'name',
        templates: {
            suggestion: function (suggestion) {
                var reg = /([A-Z]+)/ig
                var title = suggestion.uri.replace(reg, function (m) {
                    return m.toLowerCase()
                })
                return '<span class="search-item">' + '<a href="\/' + title + '">' +
                    suggestion._highlightResult.title.value + '</a></span>';
            }
        }
    });
</script>
</div>


    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go的调度器源码剖析</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-07-12 </span>
        <div class="post-category">
            <a href="/categories/go%E6%BA%90%E7%A0%81/"> Go源码 </a>
            </div>
          <span class="more-meta"> 约 74979 字 </span>
          <span class="more-meta"> 预计阅读 150 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#设计原理">设计原理</a>
      <ul>
        <li><a href="#协程">协程</a></li>
        <li><a href="#goroutine">Goroutine</a></li>
        <li><a href="#g-p-m模型">G-P-M模型</a></li>
        <li><a href="#调度思想">调度思想</a></li>
        <li><a href="#go-func-调度流程">go func() 调度流程</a></li>
        <li><a href="#调度器的生命周期">调度器的生命周期</a></li>
        <li><a href="#调度器的基本原理">调度器的基本原理</a></li>
        <li><a href="#调度触发时机">调度触发时机</a></li>
      </ul>
    </li>
    <li><a href="#源码分析">源码分析</a>
      <ul>
        <li><a href="#g-p-m模型结构体">G-P-M模型结构体</a></li>
        <li><a href="#调度流程">调度流程</a></li>
        <li><a href="#调度器初始化">调度器初始化</a></li>
        <li><a href="#调整p列表">调整P列表</a></li>
        <li><a href="#创建g">创建G</a></li>
        <li><a href="#g存入可运行队列">G存入可运行队列</a></li>
        <li><a href="#唤醒m">唤醒M</a></li>
        <li><a href="#m开始执行">M开始执行</a></li>
        <li><a href="#m寻找g">M寻找G</a></li>
        <li><a href="#g的运行与退出">G的运行与退出</a></li>
        <li><a href="#m的休眠">M的休眠</a></li>
        <li><a href="#mg的解绑">M/G的解绑</a></li>
        <li><a href="#m的死亡">M的死亡</a></li>
        <li><a href="#触发调度">触发调度</a></li>
        <li><a href="#gomaxprocs">GOMAXPROCS</a></li>
        <li><a href="#模板线程">模板线程</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="设计原理">设计原理</h2>
<h3 id="协程">协程</h3>
<h4 id="进程时代">进程时代</h4>
<p>最初的计算机上面没有操作系统，更别提进程、线程和协程了。</p>
<p>后来，现代化的计算机有了操作系统，每个程序都是一个进程，但是操作系统在一段时间只能运行一个进程，直到这个进程运行完，才能运行下一个进程，这个时期可以成为单进程时代——串行时代。</p>
<p>后来操作系统就具有了最早的并发能力：多进程并发，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。</p>
<h4 id="线程时代">线程时代</h4>
<p>有了对进程的调度能力之后，发现进程拥有太多资源，在创建、切换和销毁的时候，都会占用很长的时间，CPU虽然利用起来了，但CPU有很大的一部分都被用来进行进程调度了，怎么才能提高CPU的利用率呢？</p>
<p>大家希望能有一种轻量级的进程，调度不怎么花时间，这样CPU就有更多的时间用在执行任务上。</p>
<p>后来，操作系统支持了线程，线程在进程里面，线程运行所需要资源比进程少多了，跟进程比起来，切换简直是“不算事”。</p>
<p>一个进程可以有多个线程，CPU在执行调度的时候切换的是线程，如果下一个线程也是当前进程的，就只有线程切换，“很快”就能完成，如果下一个线程不是当前的进程，就需要切换进程，这就得费点时间了。</p>
<p>传统的编程语言比如C、C++等的并发实现实际上就是基于操作系统调度的，即程序负责创建线程(一般通过pthread等lib调用实现)，操作系统负责调度。这种传统支持并发的方式有诸多不足：</p>
<p>复杂:</p>
<ul>
<li>创建容易，退出难：做过C/C++ Programming的童鞋都知道，创建一个thread(比如利用pthread)虽然参数也不少，但好歹可以接受。但一旦涉及到thread的退出，就要考虑thread是detached，还是需要parent thread去join？是否需要在thread中设置cancel point，以保证join时能顺利退出？</li>
<li>并发单元间通信困难，易错：多个thread之间的通信虽然有多种机制可选，但用起来是相当复杂；并且一旦涉及到shared memory，就会用到各种lock，死锁便成为家常便饭；</li>
<li>thread stack size的设定：是使用默认的，还是设置的大一些，或者小一些呢？</li>
</ul>
<p>难于scaling:</p>
<ul>
<li>一个thread的代价已经比进程小了很多了，但我们依然不能大量创建thread，因为除了每个thread占用的资源不小之外，操作系统调度切换thread的代价也不小；</li>
<li>对于很多网络服务程序，由于不能大量创建thread，就要在少量thread里做网络多路复用，即：使用epoll/kqueue/IoCompletionPort这套机制，即便有libevent/libev这样的第三方库帮忙，写起这样的程序也是很不易的，存在大量callback，给程序员带来不小的心智负担。</li>
</ul>
<h4 id="协程时代">协程时代</h4>
<p>多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存（每个线程的内存占用级别为MB），线程多了之后调度也会消耗大量的CPU。如何才能充分利用CPU、内存等资源的情况下，实现更高的并发？</p>
<p>既然线程的资源占用、调度在高并发的情况下，依然是比较大的，是否有一种东西，更加轻量？</p>
<p>你可能知道：线程分为内核态线程和用户态线程，用户态线程需要绑定内核态线程，CPU并不能感知用户态线程的存在，它只知道它在运行1个线程，这个线程实际是内核态线程。</p>
<p>用户态线程实际有个名字叫协程（co-routine），为了容易区分，我们使用协程指用户态线程，使用线程指内核态线程。</p>
<p>User-level threads, Application-level threads, Green threads都指一样的东西，就是不受OS感知的线程，如果你Google coroutine相关的资料，会看到它指的就是用户态线程，在Green threads的维基百科里，看Green threads的实现列表，你会看到好很多coroutine实现，比如Java、Lua、Go、Erlang、Common Lisp、Haskell、Rust、PHP、Stackless Python，所以，我认为用户态线程就是协程。</p>
<p>协程跟线程是有区别的，线程由CPU调度是抢占式的，协程由用户态调度是协作式的，一个协程让出CPU后，才执行下一个协程。</p>
<p>协程和线程有3种映射关系：</p>
<p>N:1模型:N个协程在1个内核空间线程上运行。优势是上下文切换非常快但是无法利用多核系统的优点。</p>
<p>1:1模型:1个线程运行一个协程。这种充分利用了多核系统的优势但是上下文切换非常慢，因为每一次调度都会在用户态和内核态之间切换。（POSIX线程模型(pthread)，Java）</p>
<p>M:N模型:每个协程对应多个线程，同时也可以一个线程对应多个协程。Go打算采用这种模型，使用任意个内核模型管理任意个goroutine。这样结合了以上两种模型的优点，但缺点就是调度的复杂性。</p>
<h3 id="goroutine">Goroutine</h3>
<p>Go采用了用户层轻量级thread或者说是类coroutine的概念来解决这些问题，Go将之称为”goroutine“。goroutine占用的资源非常小(Go 1.4将每个goroutine stack的size默认设置为2k)，goroutine调度的切换也不用陷入(trap)操作系统内核层完成，代价很低。因此，一个Go程序中可以创建成千上万个并发的goroutine。所有的Go代码都在goroutine中执行，哪怕是go的runtime也不例外。将这些goroutines按照一定算法放到“CPU”上执行的程序就称为goroutine调度器或goroutine scheduler。</p>
<p>不过，一个Go程序对于操作系统来说只是一个用户层程序，对于操作系统而言，它的眼中只有thread，它甚至不知道有什么叫Goroutine的东西的存在。goroutine的调度全要靠Go自己完成，实现Go程序内goroutine之间“公平”的竞争“CPU”资源，这个任务就落到了Go runtime头上，要知道在一个Go程序中，除了用户代码，剩下的就是go runtime了。</p>
<p>于是Goroutine的调度问题就演变为go runtime如何将程序内的众多goroutine按照一定算法调度到“CPU”资源上运行了。在操作系统层面，Thread竞争的“CPU”资源是真实的物理CPU，但在Go程序层面，各个Goroutine要竞争的”CPU”资源是什么呢？Go程序是用户层程序，它本身整体是运行在一个或多个操作系统线程上的，因此goroutine们要竞争的所谓“CPU”资源就是操作系统线程。这样Go scheduler的任务就明确了：将goroutines按照一定算法放到不同的操作系统线程中去执行。这种在语言层面自带调度器的，我们称之为原生支持并发。</p>
<h4 id="goroutine和线程的区别">goroutine和线程的区别</h4>
<p>我们可以从三个角度区别：内存消耗、创建与销毀、切换。</p>
<h5 id="内存占用">内存占用</h5>
<p>创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。创建一个 thread 则需要消耗 1 MB 栈内存，而且还需要一个被称为 “a guard page” 的区域用于和其他 thread 的栈空间进行隔离。</p>
<p>对于一个用 Go 构建的 HTTP Server 而言，对到来的每个请求，创建一个 goroutine 用来处理是非常轻松的一件事。而如果用一个使用线程作为并发原语的语言构建的服务，例如 Java 来说，每个请求对应一个线程则太浪费资源了，很快就会出 OOM 错误（OutOfMermoryError）。</p>
<h5 id="创建和销毀">创建和销毀</h5>
<p>Thread 创建和销毀都会有巨大的消耗，因为要和操作系统打交道，是内核级的，通常解决的办法就是线程池。而 goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。</p>
<h5 id="切换">切换</h5>
<p>当 threads 切换时，需要保存各种寄存器，以便将来恢复：</p>
<p>16 general purpose registers, PC (Program Counter), SP (Stack Pointer), segment registers, 16 XMM registers, FP coprocessor state, 16 AVX registers, all MSRs etc.</p>
<p>而 goroutines 切换只需保存三个寄存器：Program Counter, Stack Pointer and BP。</p>
<p>一般而言，线程切换会消耗 1000-1500 纳秒，一个纳秒平均可以执行 12-18 条指令。所以由于线程切换，执行指令的条数会减少 12000-18000。</p>
<p>Goroutine 的切换约为 200 ns，相当于 2400-3600 条指令。</p>
<p>因此，goroutines 切换成本比 threads 要小得多。</p>
<h3 id="g-p-m模型">G-P-M模型</h3>
<ul>
<li>
<p>G: 表示goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等；另外G对象是可以重用的。</p>
</li>
<li>
<p>P: 表示逻辑processor，P的数量决定了系统内最大可并行的G的数量（前提：系统的物理cpu核数&gt;=P的数量）；P的最大作用还是其拥有的各种G对象队列、链表、一些cache和状态。</p>
</li>
<li>
<p>M: M代表着真正的执行计算资源。在绑定有效的p后，进入schedule循环；而schedule循环的机制大致是从各种队列、p的本地队列中获取G，切换到G的执行栈上并执行G的函数，调用goexit做清理工作并回到m，如此反复。M并不保留G状态，这是G可以跨M调度的基础。</p>
</li>
</ul>
<p>P是一个“逻辑Proccessor”，每个G要想真正运行起来，首先需要被分配一个P（进入到P的local runq中，这里暂忽略global runq那个环节）。对于G来说，P就是运行它的“CPU”，可以说：G的眼里只有P。但从Go scheduler视角来看，真正的“CPU”是M，只有将P和M绑定才能让P的runq中G得以真实运行起来。这样的P与M的关系，就好比Linux操作系统调度层面用户线程(user thread)与核心线程(kernel thread)的对应关系那样(N x M)。</p>
<p>P必须和M组合起来执行G，但是两者也并不是完全1:1对应，通常情况下P的数量固定和CPU的核数一样(GOMAXPROCS参数)，M则是按需创建，比如当M因为陷入系统调用而长时间阻塞的时候，P就会被监控线程抢回，去新建或者唤醒另一个M去执行，因此M的数量会增加，系统中可能存在一些阻塞的M。</p>
<p>Goroutine调度器和系统调度器是通过M结合起来的，每个M都代表了1个内核线程，系统调度器负责把内核线程分配到CPU的核上执行。</p>
<p>这幅图，展示了goroutine调度器和系统调度器的关系，而不是把二者割裂开来，并且从宏观的角度展示了调度器的重要组成。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201115152546.png" alt=""></p>
<p>自顶向下是调度器的4个部分：</p>
<ol>
<li>全局队列（Global Queue）：存放等待运行的G。</li>
<li>P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。</li>
<li>P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS个。</li>
<li>M线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</li>
</ol>
<h4 id="g">G</h4>
<p>Goroutine 就是 Go 语言调度器中待执行的任务，它在运行时调度器中的地位与线程在操作系统中差不多，但是它占用了更小的内存空间，也降低了上下文切换的开销。</p>
<p>Goroutine 只存在于 Go 语言的运行时，它是 Go 语言在用户态提供的线程，作为一种粒度更细的资源调度单元，如果使用得当能够在高并发的场景下更高效地利用机器的 CPU。</p>
<p>当 goroutine 被调离 CPU 时，调度器负责把 CPU 寄存器的值保存在 g 对象的成员变量之中。</p>
<p>当 goroutine 被调度起来运行时，调度器又负责把 g 对象的成员变量所保存的寄存器值恢复到 CPU 的寄存器。</p>
<p>Goroutine 在 Go 语言运行时使用私有结构体 runtime.g 表示。这个私有结构体非常复杂，总共包含 40 多个用于表示各种状态的成员变量，我们在这里也不会介绍全部字段，而是会挑选其中的一部分进行介绍，首先是与栈相关的两个字段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">stack</span>       <span class="nx">stack</span>
	<span class="nx">stackguard0</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中 stack 字段描述了当前 Goroutine 的栈内存范围 [stack.lo, stack.hi)，另一个字段 stackguard0 可以用于调度器抢占式调度。除了 stackguard0 之外，Goroutine 中还包含另外三个与抢占密切相关的字段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">preempt</span>       <span class="kt">bool</span> <span class="c1">// 抢占信号
</span><span class="c1"></span>	<span class="nx">preemptStop</span>   <span class="kt">bool</span> <span class="c1">// 抢占时将状态修改成 `_Gpreempted`
</span><span class="c1"></span>	<span class="nx">preemptShrink</span> <span class="kt">bool</span> <span class="c1">// 在同步安全点收缩栈
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Goroutine 与我们在前面章节提到的 defer 和 panic 也有千丝万缕的联系，每一个 Goroutine 上都持有两个分别存储 defer 和 panic 对应结构体的链表：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">_panic</span>       <span class="o">*</span><span class="nx">_panic</span> <span class="c1">// 最内侧的 panic 结构体
</span><span class="c1"></span>	<span class="nx">_defer</span>       <span class="o">*</span><span class="nx">_defer</span> <span class="c1">// 最内侧的延迟函数结构体
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>最后，我们再节选一些作者认为比较有趣或者重要的字段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">m</span>              <span class="o">*</span><span class="nx">m</span>
	<span class="nx">sched</span>          <span class="nx">gobuf</span>
	<span class="nx">atomicstatus</span>   <span class="kt">uint32</span>
	<span class="nx">goid</span>           <span class="kt">int64</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>m — 当前 Goroutine 占用的线程，可能为空；</li>
<li>atomicstatus — Goroutine 的状态；</li>
<li>sched — 存储 Goroutine 的调度相关的数据；</li>
<li>goid — Goroutine 的 ID，该字段对开发者不可见，Go 团队认为引入 ID 会让部分 Goroutine 变得更特殊，从而限制语言的并发能力10；</li>
</ul>
<p>上述四个字段中，我们需要展开介绍 sched 字段的 runtime.gobuf 结构体中包含哪些内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">gobuf</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">sp</span>   <span class="kt">uintptr</span>
	<span class="nx">pc</span>   <span class="kt">uintptr</span>
	<span class="nx">g</span>    <span class="nx">guintptr</span>
	<span class="nx">ret</span>  <span class="nx">sys</span><span class="p">.</span><span class="nx">Uintreg</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>sp — 栈指针（Stack Pointer）；</li>
<li>pc — 程序计数器（Program Counter）；</li>
<li>g — 持有 runtime.gobuf 的 Goroutine；</li>
<li>ret — 系统调用的返回值；</li>
</ul>
<p>这些内容会在调度器保存或者恢复上下文的时候用到，其中的栈指针和程序计数器会用来存储或者恢复寄存器中的值，改变程序即将执行的代码。</p>
<p>结构体 runtime.g 的 atomicstatus 字段就存储了当前 Goroutine 的状态。除了几个已经不被使用的以及与 GC 相关的状态之外，Goroutine 可能处于以下 9 个状态：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>_Gidle</td>
<td>刚刚被分配并且还没有被初始化</td>
</tr>
<tr>
<td>_Grunnable</td>
<td>没有执行代码，没有栈的所有权，存储在运行队列中</td>
</tr>
<tr>
<td>_Grunning</td>
<td>可以执行代码，拥有栈的所有权，被赋予了内核线程 M 和处理器 P</td>
</tr>
<tr>
<td>_Gsyscall</td>
<td>正在执行系统调用，拥有栈的所有权，没有执行用户代码，被赋予了内核线程 M 但是不在运行队列上</td>
</tr>
<tr>
<td>_Gwaiting</td>
<td>由于运行时而被阻塞，没有执行用户代码并且不在运行队列上，但是可能存在于 Channel 的等待队列上</td>
</tr>
<tr>
<td>_Gdead</td>
<td>没有被使用，没有执行代码，可能有分配的栈</td>
</tr>
<tr>
<td>_Gcopystack</td>
<td>栈正在被拷贝，没有执行代码，不在运行队列上</td>
</tr>
<tr>
<td>_Gpreempted</td>
<td>由于抢占而被阻塞，没有执行用户代码并且不在运行队列上，等待唤醒</td>
</tr>
<tr>
<td>_Gscan</td>
<td>GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在</td>
</tr>
</tbody>
</table>
<p>上述状态中比较常见是_Grunnable、_Grunning、_Gsyscall、_Gwaiting 和_Gpreempted 五个状态，我们会重点介绍这几个状态，Goroutine 的状态迁移是一个复杂的过程，触发 Goroutine 状态迁移的方法也很多，在这里我们也没有办法介绍全部的迁移线路，我们会从中选择一些进行介绍。</p>
<p>虽然 Goroutine 在运行时中定义的状态非常多而且复杂，但是我们可以将这些不同的状态聚合成最终的三种：等待中、可运行、运行中，在运行期间我们会在这三种不同的状态来回切换：</p>
<ul>
<li>等待中：Goroutine 正在等待某些条件满足，例如：系统调用结束等，包括 _Gwaiting、_Gsyscall 和 _Gpreempted 几个状态；</li>
<li>可运行：Goroutine 已经准备就绪，可以在线程运行，如果当前程序中有非常多的 Goroutine，每个 Goroutine 就可能会等待更多的时间，即_Grunnable；</li>
<li>运行中：Goroutine 正在某个线程上运行，即 _Grunning；
golang-goroutine-state-transition</li>
</ul>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201114234900.png" alt=""></p>
<p>上图展示了 Goroutine 状态迁移的常见路径，其中包括创建 Goroutine 到 Goroutine 被执行、触发系统调用或者抢占式调度器的状态迁移过程。</p>
<p>一个G在创建之初是Gidle状态。只有被初始化之后，其状态才变成Grunnable。一个G真正开始被使用是在其状态设置为Grunnabel之后。</p>
<p>一个G在运行过程中是否会等待某个事件以及等待什么事件，完全由其封装的go函数决定。涉及通道操作，网络I/O以及操纵定时器和调用time.sleep函数会使G进入Gwaiting状态。</p>
<p>事件到来之后，等待的G会被唤醒，并置于Grunnable状态，等待运行。</p>
<p>G在退出系统调用时，运行时系统会首先尝试直接运行这个G。仅当无法直接运行时，才会把它转换为Grunnable状态并放入调度器的可运行G队列。那么为什么不是放入本地P的可运行G队列呢？因为在G进入系统调用之后，本地P就与当前M分离开了。当G退出系统调用时，本地P已经不在了，也就是说这个G没有本地P，所以只能让调度器去接纳它了。</p>
<p>进入死亡状态（Gdead）的G会被放入本地P或调度器的自由G列表，可以在需要的时候重新初始化并使用。相比之下，P在进入死亡状态（Pdead）之后，只能面临销毁的结局。</p>
<h4 id="m">M</h4>
<p>Go 语言并发模型中的 M 是操作系统线程。调度器最多可以创建 10000 个线程，但是其中大多数的线程都不会执行用户代码（可能陷入系统调用），最多只会有 GOMAXPROCS 个活跃线程能够正常运行。</p>
<p>在默认情况下，运行时会将 GOMAXPROCS 设置成当前机器的核数，我们也可以使用 runtime.GOMAXPROCS 来改变程序中最大的线程数。</p>
<p>在默认情况下，一个四核机器上会创建四个活跃的操作系统线程，每一个线程都对应一个运行时中的 runtime.m 结构体。</p>
<p>在大多数情况下，我们都会使用 Go 的默认设置，也就是线程数等于 CPU 个数，在这种情况下不会触发操作系统的线程调度和上下文切换，所有的调度都会发生在用户态，由 Go 语言调度器触发，能够减少非常多的额外开销。</p>
<p>操作系统线程在 Go 语言中会使用私有结构体 runtime.m 来表示，这个结构体中也包含了几十个私有的字段，我们依然对其进行了删减，先来了解几个与 Goroutine 直接相关的字段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">m</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">g0</span>   <span class="o">*</span><span class="nx">g</span>
  <span class="nx">curg</span> <span class="o">*</span><span class="nx">g</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中 g0 是持有调度栈的 Goroutine，curg 是在当前线程上运行的用户 Goroutine，这也是操作系统线程唯一关心的两个 Goroutine。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201111114631.png" alt=""></p>
<p>g0 是一个运行时中比较特殊的 Goroutine，它会深度参与运行时的调度过程，包括 Goroutine 的创建、大内存分配和 CGO 函数的执行。在后面的小节中，我们会经常看到 g0 的身影。runtime.m 结构体中还存在着三个处理器字段，它们分别表示正在运行代码的处理器 p、暂存的处理器 nextp 和执行系统调用之前的使用线程的处理器 oldp：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">m</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">p</span>             <span class="nx">puintptr</span>
	<span class="nx">nextp</span>         <span class="nx">puintptr</span>
	<span class="nx">oldp</span>          <span class="nx">puintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>除了在上面介绍的字段之外，runtime.m 中还包含大量与线程状态、锁、调度、系统调用有关的字段，我们会在分析调度过程时详细介绍。</p>
<h4 id="p">P</h4>
<p>调度器中的处理器 P 是线程和 Goroutine 的中间层，它能提供线程需要的上下文环境，也会负责调度线程上的等待队列，通过处理器 P 的调度，每一个内核线程都能够执行多个 Goroutine，它能在 Goroutine 进行一些 I/O 操作时及时切换，提高线程的利用率。</p>
<p>因为调度器在启动时就会创建 GOMAXPROCS 个处理器，所以 Go 语言程序的处理器数量一定会等于 GOMAXPROCS，这些处理器会绑定到不同的内核线程上并利用线程的计算资源运行 Goroutine。</p>
<p>runtime.p 是处理器的运行时表示，作为调度器的内部实现，它包含的字段也非常多，其中包括与性能追踪、垃圾回收和计时器相关的字段，这些字段也非常重要，但是在这里就不一一展示了，我们主要关注处理器中的线程和运行队列：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">p</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">m</span>           <span class="nx">muintptr</span>

	<span class="nx">runqhead</span> <span class="kt">uint32</span>
	<span class="nx">runqtail</span> <span class="kt">uint32</span>
	<span class="nx">runq</span>     <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="nx">guintptr</span>
	<span class="nx">runnext</span> <span class="nx">guintptr</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>反向存储的线程维护着线程与处理器之间的关系，而 runhead、runqtail 和 runq 三个字段表示处理器持有的运行队列，其中存储着待执行的 Goroutine 列表，runnext 中是线程下一个需要执行的 Goroutine。</p>
<p>runtime.p 结构体中的状态 status 字段会是以下五种中的一种：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>_Pidle</td>
<td>处理器没有运行用户代码或者调度器，被空闲队列或者改变其状态的结构持有，运行队列为空</td>
</tr>
<tr>
<td>_Prunning</td>
<td>被线程 M 持有，并且正在执行用户代码或者调度器</td>
</tr>
<tr>
<td>_Psyscall</td>
<td>没有执行用户代码，当前线程陷入系统调用</td>
</tr>
<tr>
<td>_Pgcstop</td>
<td>被线程 M 持有，当前处理器由于垃圾回收被停止</td>
</tr>
<tr>
<td>_Pdead</td>
<td>当前处理器已经不被使用</td>
</tr>
</tbody>
</table>
<p>通过分析处理器 P 的状态，我们能够对处理器的工作过程有一些简单理解，例如处理器在执行用户代码时会处于 _Prunning 状态，在当前线程执行 I/O 操作时会陷入_Psyscall 状态。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201114234757.png" alt=""></p>
<p>P在创建之初的状态是Pgcstop，但这并不意味着运行时系统要进行垃圾回收。P出于这一状态的时间会非常短暂，在紧接着的初始化后，运行时系统会将其状态设置为Pidle并放入调度器的空闲P列表。</p>
<p>非Pdead状态的P在运行时系统停止调度时都会被置于Pgcstop状态。重启调度时（如垃圾回收结束后），所有P都会被置于Pidle状态，而不是他们原来的状态。</p>
<p>非Pgcstop状态的P都会因最大P数量的减小而被认为是多余的，并被置于Pdead状态。当P进入Pdead状态之前，该P的可运行G队列会被转移到调度器的可运行G队列，它的自由G列表会被转移到调度器的自由G列表。</p>
<p>每个P中有一个可运行的G队列，以及一个自由G列表。自由G列表中包含了已运行完成的G。随着已运行完成的G越来越多，该列表会不断增长。如果它增长到一定程度，运行时系统会把其中部分G转移到调度器的自由G列表。同样，当调度器发现其中的自由G太少时，会预先尝试从调度器的自由G列表中转移一些G过来。</p>
<p>当使用go语句启用一个G时，运行时系统会先从相应P的自由G列表中获取一个G来封装这个go语句的函数。仅当获取不到的时候，也就是调度器的自由G列表也空了，才会创建一个新的G。</p>
<h3 id="调度思想">调度思想</h3>
<h4 id="复用线程">复用线程</h4>
<p>协程本身就是运行在一组线程之上，不需要频繁的创建、销毁线程，而是对线程的复用。</p>
<p>在调度器中复用线程还有2个体现：</p>
<ol>
<li>work stealing，当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。</li>
<li>hand off，当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。</li>
</ol>
<h4 id="利用并行">利用并行</h4>
<p>GOMAXPROCS设置P的数量，当GOMAXPROCS大于1时，就最多有GOMAXPROCS个线程处于运行状态，这些线程可能分布在多个CPU核上同时运行，使得并发利用并行。</p>
<p>另外，GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS = 核数/2，则最多利用了一半的CPU核进行并行。</p>
<p>上面提到并行了，关于并发和并行再说一下：Go创始人Rob Pike一直在强调go是并发，不是并行，因为Go做的是在一段时间内完成几十万、甚至几百万的工作，而不是同一时间同时在做大量的工作。并发可以利用并行提高效率，调度器是有并行设计的。</p>
<p>并行依赖多核技术，每个核上在某个时间只能执行一个线程，当我们的CPU有8个核时，我们能同时执行8个线程，这就是并行。</p>
<h4 id="抢占">抢占</h4>
<h5 id="基于协作的抢占式调度12">基于协作的抢占式调度(1.2)</h5>
<p>我们可以在 pkg/runtime/proc.c 文件中找到引入基于协作的抢占式调度后的调度器。Go 语言会在分段栈的机制上实现抢占调度，利用编译器在分段栈上插入的函数，所有 Goroutine 在函数调用时都有机会进入运行时检查是否需要执行抢占。Go 团队通过以下的多个提交实现该特性：</p>
<ul>
<li>runtime: add stackguard0 to G
<ul>
<li>为 Goroutine 引入 stackguard0 字段，该字段被设置成 StackPreempt 意味着当前 Goroutine 发出了抢占请求；</li>
</ul>
</li>
<li>runtime: introduce preemption function (not used for now)
<ul>
<li>引入抢占函数 runtime.preemptone 和 runtime.preemptall，这两个函数会改变 Goroutine 的 stackguard0 字段发出抢占请求；</li>
<li>定义抢占请求 StackPreempt；</li>
</ul>
</li>
<li>runtime: preempt goroutines for GC
<ul>
<li>在 runtime.stoptheworld 中调用 runtime.preemptall 设置所有处理器上正在运行的 Goroutine 的 stackguard0 为 StackPreempt；</li>
<li>在 runtime.newstack 函数中增加抢占的代码，当 stackguard0 等于 StackPreempt 时触发调度器抢占让出线程；</li>
</ul>
</li>
<li>runtime: preempt long-running goroutines
<ul>
<li>在系统监控中，如果一个 Goroutine 的运行时间超过 10ms，就会调用 runtime.retake 和 runtime.preemptone；</li>
</ul>
</li>
<li>runtime: more reliable preemption
<ul>
<li>修复 Goroutine 因为周期性执行非阻塞的 CGO 或者系统调用不会被抢占的问题；</li>
</ul>
</li>
</ul>
<p>上面的多个提交实现了抢占式调度，但是还缺少最关键的一个环节 — 编译器如何在函数调用前插入函数，我们能在非常古老的提交 runtime: stack growth adjustments, cleanup 中找到编译器插入函数的出行，最新版本的 Go 语言会通过 cmd/internal/obj/x86.stacksplit 插入 runtime.morestack 函数，该函数可能会调用 runtime.newstack 触发抢占。从上面的多个提交中，我们能归纳出基于协作的抢占式调度的工作原理：</p>
<ol>
<li>编译器会在调用函数前插入 runtime.morestack；</li>
<li>Go 语言运行时会在垃圾回收暂停程序、系统监控发现 Goroutine 运行超过 10ms 时发出抢占请求 StackPreempt；</li>
<li>当发生函数调用时，可能会执行编译器插入的 runtime.morestack 函数，它调用的 runtime.newstack 会检查 Goroutine 的 stackguard0 字段是否为 StackPreempt；</li>
<li>如果 stackguard0 是 StackPreempt，就会触发抢占让出当前线程；</li>
</ol>
<p>这种实现方式虽然增加了运行时的复杂度，但是实现相对简单，也没有带来过多的额外开销，总体来看还是比较成功的实现，也在 Go 语言中使用了 10 几个版本。因为这里的抢占是通过编译器插入函数实现的，还是需要函数调用作为入口才能触发抢占，所以这是一种协作式的抢占式调度。</p>
<h5 id="基于信号的抢占式调度114">基于信号的抢占式调度(1.14)</h5>
<p>基于协作的抢占式调度虽然实现巧妙，但是并不完备，我们能在 runtime: non-cooperative goroutine preemption 中找到一些遗留问题：</p>
<ul>
<li>runtime: tight loops should be preemptible #10958</li>
<li>An empty for{} will block large slice allocation in another goroutine, even with GOMAXPROCS &gt; 1 ? #17174</li>
<li>runtime: tight loop hangs process completely after some time #15442</li>
<li>…</li>
</ul>
<p>Go 语言在 1.14 版本中实现了非协作的抢占式调度，在实现的过程中我们重构已有的逻辑并为 Goroutine 增加新的状态和字段来支持抢占。Go 团队通过下面的一系列提交实现了这一功能，我们可以按时间顺序分析相关提交理解它的工作原理：</p>
<ul>
<li>runtime: add general suspendG/resumeG
<ul>
<li>挂起 Goroutine 的过程是在垃圾回收的栈扫描时完成的，我们通过 runtime.suspendG 和 runtime.resumeG 两个函数重构栈扫描这一过程；</li>
<li>调用 runtime.suspendG 函数时会将处于运行状态的 Goroutine 的 preemptStop 标记成 true；</li>
<li>调用 runtime.preemptPark 函数可以挂起当前 Goroutine、将其状态更新成 _Gpreempted 并触发调度器的重新调度，该函数能够交出线程控制权；</li>
</ul>
</li>
<li>runtime: asynchronous preemption function for x86
<ul>
<li>在 x86 架构上增加异步抢占的函数 runtime.asyncPreempt 和 runtime.asyncPreempt2；</li>
</ul>
</li>
<li>runtime: use signals to preempt Gs for suspendG
<ul>
<li>支持通过向线程发送信号的方式暂停运行的 Goroutine；</li>
<li>在 runtime.sighandler 函数中注册 SIGURG 信号的处理函数 runtime.doSigPreempt；</li>
<li>实现 runtime.preemptM 函数，它可以通过 SIGURG 信号向线程发送抢占请求；</li>
</ul>
</li>
<li>runtime: implement async scheduler preemption
<ul>
<li>修改 runtime.preemptone 函数的实现，加入异步抢占的逻辑；</li>
</ul>
</li>
</ul>
<p>目前的抢占式调度也只会在垃圾回收扫描任务时触发，我们可以梳理一下上述代码实现的抢占式调度过程：</p>
<ol>
<li>程序启动时，在 runtime.sighandler 函数中注册 SIGURG 信号的处理函数 runtime.doSigPreempt；</li>
<li>在触发垃圾回收的栈扫描时会调用 runtime.suspendG 挂起 Goroutine，该函数会执行下面的逻辑：
<ol>
<li>将 _Grunning 状态的 Goroutine 标记成可以被抢占，即将 preemptStop 设置成 true；</li>
<li>调用 runtime.preemptM 触发抢占；</li>
</ol>
</li>
<li>runtime.preemptM 会调用 runtime.signalM 向线程发送信号 SIGURG；</li>
<li>操作系统会中断正在运行的线程并执行预先注册的信号处理函数 runtime.doSigPreempt；</li>
<li>runtime.doSigPreempt 函数会处理抢占信号，获取当前的 SP 和 PC 寄存器并调用 runtime.sigctxt.pushCall；</li>
<li>runtime.sigctxt.pushCall 会修改寄存器并在程序回到用户态时执行 runtime.asyncPreempt；</li>
<li>汇编指令 runtime.asyncPreempt 会调用运行时函数 runtime.asyncPreempt2；</li>
<li>runtime.asyncPreempt2 会调用 runtime.preemptPark；</li>
<li>runtime.preemptPark 会修改当前 Goroutine 的状态到_Gpreempted 并调用 runtime.schedule 让当前函数陷入休眠并让出线程，调度器会选择其它的 Goroutine 继续执行；</li>
</ol>
<p>上述 9 个步骤展示了基于信号的抢占式调度的执行过程。除了分析抢占的过程之外，我们还需要讨论一下抢占信号的选择，提案根据以下的四个原因选择 SIGURG 作为触发异步抢占的信号；</p>
<ol>
<li>该信号需要被调试器透传；</li>
<li>该信号不会被内部的 libc 库使用并拦截；</li>
<li>该信号可以随意出现并且不触发任何后果；</li>
<li>我们需要处理多个平台上的不同信号；</li>
</ol>
<p>STW 和栈扫描是一个可以抢占的安全点（Safe-points），所以 Go 语言会在这里先加入抢占功能。基于信号的抢占式调度只解决了垃圾回收和栈扫描时存在的问题，它到目前为止没有解决全部问题，但是这种真抢占式调度时调度器走向完备的开始，相信在未来我们可以会更多的地方触发抢占。</p>
<h4 id="全局g队列">全局G队列</h4>
<p>在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。</p>
<h4 id="poller">Poller</h4>
<p>Go runtime已经实现了netpoller，这使得即便G发起网络I/O操作也不会导致M被阻塞（仅阻塞G），从而不会导致大量M被创建出来。但是对于regular file的I/O操作一旦阻塞，那么M将进入sleep状态，等待I/O返回后被唤醒；这种情况下P将与sleep的M分离，再选择一个idle的M。如果此时没有idle的M，则会新创建一个M，这就是为何大量I/O操作导致大量Thread被创建的原因。</p>
<p>Ian Lance Taylor在Go 1.9 dev周期中增加了一个Poller for os package的功能，这个功能可以像netpoller那样，在G操作支持pollable的fd时，仅阻塞G，而不阻塞M。不过该功能依然不能对regular file有效，regular file不是pollable的。不过，对于scheduler而言，这也算是一个进步了。</p>
<h3 id="go-func-调度流程">go func() 调度流程</h3>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201115153416.png" alt=""></p>
<p>从上图我们可以分析出几个结论：</p>
<ol>
<li>
<p>我们通过 go func () 来创建一个 goroutine；</p>
</li>
<li>
<p>有两个存储 G 的队列，一个是局部调度器 P 的本地队列、一个是全局 G 队列。新创建的 G 会先保存在 P 的本地队列中，如果 P 的本地队列已经满了就会保存在全局的队列中；</p>
</li>
<li>
<p>G 只能运行在 M 中，一个 M 必须持有一个 P，M 与 P 是 1：1 的关系。M 会从 P 的本地队列弹出一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会想其他的 MP 组合偷取一个可执行的 G 来执行；</p>
</li>
<li>
<p>一个 M 调度 G 执行的过程是一个循环机制；</p>
</li>
<li>
<p>当 M 执行某一个 G 时候如果发生了 syscall 或则其余阻塞操作，M 会阻塞，如果当前有一些 G 在执行，runtime 会把这个线程 M 从 P 中摘除 (detach)，然后再创建一个新的操作系统的线程 (如果有空闲的线程可用就复用空闲线程) 来服务于这个 P；</p>
</li>
<li>
<p>当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中。</p>
</li>
</ol>
<h3 id="调度器的生命周期">调度器的生命周期</h3>
<p>接下来我们从另外一个宏观角度——生命周期，认识调度器。</p>
<p>所有的Go程序运行都会经过一个完整的调度器生命周期：从创建到结束。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20190706204142.png" alt=""></p>
<p>即使下面这段简单的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="c1">// main.main
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello scheduler&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>也会经历如上图所示的过程：</p>
<ol>
<li>runtime创建最初的线程m0和goroutine g0，并把2者关联。</li>
<li>调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。</li>
<li>示例代码中的main函数是main.main，runtime中也有1个main函数——runtime.main，代码经过编译后，runtime.main会调用main.main，程序启动时会为runtime.main创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。</li>
<li>启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。</li>
<li>G拥有栈，M根据G中的栈信息和调度信息设置运行环境</li>
<li>M运行G</li>
<li>G退出，再次回到M获取可运行的G，这样重复下去，直到main.main退出，runtime.main执行Defer和Panic处理，或调用runtime.exit退出程序。</li>
</ol>
<p>调度器的生命周期几乎占满了一个Go程序的一生，runtime.main的goroutine执行之前都是为调度器做准备工作，runtime.main的goroutine运行，才是调度器的真正开始，直到runtime.main结束而结束。</p>
<h4 id="m0和g0">M0和G0</h4>
<p>M0 是启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了。</p>
<p>G0 是每次启动一个 M 都会第一个创建的 gourtine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0。</p>
<h3 id="调度器的基本原理">调度器的基本原理</h3>
<p>关于调度器的基本原理,本文总结了12个主要的场景，覆盖了以下内容：</p>
<ul>
<li>G的创建和分配</li>
<li>M如何从G1切换到G2</li>
<li>P的本地队列和全局队列的负载均衡</li>
<li>M如何寻找G</li>
<li>work stealing，M如何去偷G</li>
<li>为何需要自旋线程</li>
<li>G进行系统调用，如何保证P的其他G可以被执行，而不是饿死</li>
<li>Go调度器的抢占</li>
</ul>
<p>下面根据上述情景进行分析,阐述goroutine的调度原理.</p>
<p>图中三角形、正方形、圆形分别代表了M、P、G，正方形连接的绿色长方形代表了P的本地队列。蓝色长方形代表全局队列。</p>
<h5 id="g的创建和分配">G的创建和分配</h5>
<p>p1拥有g1，m1获取p1后开始运行g1，g1使用go func()创建了g2，为了局部性g2优先加入到p1的本地队列。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201115152412.png" alt=""></p>
<h5 id="m如何从g1切换到g2">M如何从G1切换到G2</h5>
<p>g1运行完成后(函数：goexit)，m上运行的goroutine切换为g0，g0负责调度时协程的切换（函数：schedule）。从p1的本地队列取g2，从g0切换到g2，并开始运行g2(函数：execute)。实现了线程m1的复用。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201115153758.png" alt=""></p>
<p>假设每个p的本地队列只能存4个g。g2要创建了6个g，前4个g（g3, g4, g5, g6）已经加入p1的本地队列，p1本地队列满了。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201115154306.png" alt=""></p>
<h5 id="p的本地队列和全局队列的负载均衡">P的本地队列和全局队列的负载均衡</h5>
<p>g2在创建g7的时候，发现p1的本地队列已满，需要执行负载均衡，把p1中本地队列中前一半的g，还有新创建的g转移到全局队列（实现中并不一定是新的g，如果g是g2之后就执行的，会被保存在本地队列，利用某个老的g替换新g加入全局队列），这些g被转移到全局队列时，会被打乱顺序。所以g3,g4,g7被转移到全局队列。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201115154325.png" alt=""></p>
<p>g2创建g8时，p1的本地队列未满，所以g8会被加入到p1的本地队列。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201115154345.png" alt=""></p>
<h4 id="m如何寻找g">M如何寻找G</h4>
<p>在创建g时，运行的g会尝试唤醒其他空闲的p和m执行。假定g2唤醒了m2，m2绑定了p2，并运行g0，但p2本地队列没有g，m2此时为自旋线程（没有G但为运行状态的线程，不断寻找g，后续场景会有介绍）。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201115155002.png" alt=""></p>
<p>m2尝试从全局队列(GQ)取一批g放到p2的本地队列（函数：findrunnable）。m2从全局队列取的g数量符合下面的公式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">n</span> <span class="p">=</span> <span class="nf">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">GQ</span><span class="p">)</span><span class="o">/</span><span class="nx">GOMAXPROCS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">GQ</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>公式的含义是，至少从全局队列取1个g，但每次不要从全局队列移动太多的g到p本地队列，给其他p留点。这是从全局队列到P本地队列的负载均衡。</p>
<p>假定我们场景中一共有4个P，所以m2只从能从全局队列取1个g（即g3）移动p2本地队列，然后完成从g0到g3的切换，运行g3。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201115155110.png" alt=""></p>
<h5 id="work-stealingm如何去偷g">work stealing，M如何去偷G</h5>
<p>假设g2一直在m1上运行，经过2轮后，m2已经把g7、g4也挪到了p2的本地队列并完成运行，全局队列和p2的本地队列都空了，如图左边。</p>
<p>全局队列已经没有g，那m就要执行work stealing：从其他有g的p哪里偷取一半g过来，放到自己的P本地队列。p2从p1的本地队列尾部取一半的g，本例中一半则只有1个g8，放到p2的本地队列，情况如图右边。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201115155131.png" alt=""></p>
<h5 id="自旋线程">自旋线程</h5>
<p>p1本地队列g5、g6已经被其他m偷走并运行完成，当前m1和m2分别在运行g2和g8，m3和m4没有goroutine可以运行，m3和m4处于自旋状态，它们不断寻找goroutine。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201115155221.png" alt=""></p>
<p>为什么要让m3和m4自旋，自旋本质是在运行，线程在运行却没有执行g，就变成了浪费CPU？销毁线程不是更好吗？可以节约CPU资源。创建和销毁CPU都是浪费时间的，我们希望当有新goroutine创建时，立刻能有m运行它，如果销毁再新建就增加了时延，降低了效率。</p>
<p>当然也考虑了过多的自旋线程是浪费CPU，所以系统中最多有GOMAXPROCS个自旋的线程，多余的没事做线程会让他们休眠（见函数：notesleep()）。</p>
<h5 id="场景融合">场景融合</h5>
<p>如果把上面所有的场景都融合起来，就能构成下面这幅图了，它从整体的角度描述了Go调度器各部分的关系。图的上半部分是G的创建、负载均衡和work stealing，下半部分是M不停寻找和执行G的迭代过程。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20190706221840.png" alt=""></p>
<h3 id="调度触发时机">调度触发时机</h3>
<h4 id="系统态的阻塞唤醒">系统态的阻塞/唤醒</h4>
<p>如果G被阻塞在某个system call或cgo操作上，那么不光G会阻塞，执行该G的M也会解绑P，与G一起进入sleep状态。如果此时有idle的M，则P与其绑定继续执行其他G；如果没有idle M，但仍然有其他G要去执行，那么就会创建一个新M。</p>
<p>当阻塞在syscall上的G完成syscall调用后，G会去尝试获取一个可用的P，如果没有可用的P，那么G会被标记为runnable，之前的那个sleep的M将再次进入sleep。</p>
<h4 id="用户态的阻塞唤醒">用户态的阻塞/唤醒</h4>
<p>如果G被阻塞在某个channel操作时，G会被放置到某个wait队列中，而M会尝试运行下一个runnable的G；如果此时没有runnable的G供m运行，那么m将解绑P，并进入sleep状态。当I/O available或channel操作完成，在wait队列中的G会被唤醒，标记为runnable，放入到某P的队列中，绑定一个M继续执行。</p>
<h4 id="netpoller">NetPoller</h4>
<p>Go 将 epoll 进行了包装(使用了垂直触发)，会单独创建一个名为 NetPoller 的 M 异步处理网络IO，它不需要和 P 进行绑定。</p>
<p>当 G 执行网络 IO 的时候，G 会将当前 M 和 P 解绑，进入到 NetPoller 的 M 中，等待网络 IO 完成，这样即使执行网络 IO 的系统调用，也不会产生阻塞的 M.</p>
<p>当网络 IO 完成后，M 的 Schedule 函数，会通过 findrunable函数 取到这个 G，继续运行它。</p>
<h4 id="抢占式调度">抢占式调度</h4>
<p>当 G 执行的时间超过 10ms 时，一个名为 sysmon 的 M 就会向其发起抢占式调度。由于 Go 是用户态的代码，并没有时间片和硬中断的概念，所以 Go 抢占式调度的方式是运行方主动将自己挂起。</p>
<p>sysmon 如果要抢占某个 G 的执行权，那么就会设置它的抢占标记(g.stackguard0)。G 在执行函数的时候(具体来说是 newstack函数)，会检查抢占标记，如果这个标记已经被设置了，那么它就会通过 Gosched 的方式将自己放到 GRQ 中，重新等待执行。</p>
<p>参考:</p>
<h2 id="源码分析">源码分析</h2>
<p>根据源码实现,调度器有如下细节优化:</p>
<ol>
<li>G对象和M对象默认会复用.除P本地的复用链表外,还有全局链表在多个P之间共享.</li>
<li>P分为本地队列和全局队列,本地P队列只有当前M可用,可以使用无锁编程.</li>
</ol>
<p>以下源码截取自go1.15版本.</p>
<h3 id="g-p-m模型结构体">G-P-M模型结构体</h3>
<h4 id="g-1">G</h4>
<p>G 既然是 Goroutine，必然需要定义自身的执行栈：</p>
<p>除了执行栈之外，还有很多与调试和 profiling 相关的字段。 一个 G 没有什么黑魔法，无非是将需要执行的函数参数进行了拷贝，保存了要执行的函数体的入口地址，用于执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Stack parameters.
</span><span class="c1"></span>	<span class="c1">// stack describes the actual stack memory: [stack.lo, stack.hi).
</span><span class="c1"></span>	<span class="c1">// stackguard0 is the stack pointer compared in the Go stack growth prologue.
</span><span class="c1"></span>	<span class="c1">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
</span><span class="c1"></span>	<span class="c1">// stackguard1 is the stack pointer compared in the C stack growth prologue.
</span><span class="c1"></span>	<span class="c1">// It is stack.lo+StackGuard on g0 and gsignal stacks.
</span><span class="c1"></span>	<span class="c1">// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
</span><span class="c1"></span>	<span class="c1">// goroutine 使用的栈
</span><span class="c1"></span>	<span class="nx">stack</span>       <span class="nx">stack</span>   <span class="c1">// offset known to runtime/cgo //执行栈
</span><span class="c1"></span>	<span class="c1">// 用于栈的扩张和收缩检查，抢占标志
</span><span class="c1"></span>	<span class="nx">stackguard0</span> <span class="kt">uintptr</span> <span class="c1">// offset known to liblink
</span><span class="c1"></span>	<span class="nx">stackguard1</span> <span class="kt">uintptr</span> <span class="c1">// offset known to liblink
</span><span class="c1"></span>
	<span class="nx">_panic</span>         <span class="o">*</span><span class="nx">_panic</span> <span class="c1">// innermost panic - offset known to liblink
</span><span class="c1"></span>	<span class="nx">_defer</span>         <span class="o">*</span><span class="nx">_defer</span> <span class="c1">// innermost defer
</span><span class="c1"></span>	<span class="c1">// 当前与 g 绑定的 m
</span><span class="c1"></span>	<span class="nx">m</span>              <span class="o">*</span><span class="nx">m</span>      <span class="c1">// current m; offset known to arm liblink
</span><span class="c1"></span>	<span class="nx">sched</span>          <span class="nx">gobuf</span>    <span class="c1">//用于保存执行现场
</span><span class="c1"></span>	<span class="nx">syscallsp</span>      <span class="kt">uintptr</span>        <span class="c1">// if status==Gsyscall, syscallsp = sched.sp to use during gc
</span><span class="c1"></span>	<span class="nx">syscallpc</span>      <span class="kt">uintptr</span>        <span class="c1">// if status==Gsyscall, syscallpc = sched.pc to use during gc
</span><span class="c1"></span>	<span class="c1">// 期望 sp 位于栈顶，用于回溯检查
</span><span class="c1"></span>	<span class="nx">stktopsp</span>       <span class="kt">uintptr</span>        <span class="c1">// expected sp at top of stack, to check in traceback
</span><span class="c1"></span>	<span class="c1">// wakeup 唤醒时候传递的参数
</span><span class="c1"></span>	<span class="nx">param</span>          <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// passed parameter on wakeup
</span><span class="c1"></span>	<span class="nx">atomicstatus</span>   <span class="kt">uint32</span>
	<span class="nx">stackLock</span>      <span class="kt">uint32</span> <span class="c1">// sigprof/scang lock; TODO: fold in to atomicstatus
</span><span class="c1"></span>	<span class="nx">goid</span>           <span class="kt">int64</span>    <span class="c1">//唯一序号
</span><span class="c1"></span>	<span class="c1">// 指向全局队列里下一个 g
</span><span class="c1"></span>	<span class="nx">schedlink</span>      <span class="nx">guintptr</span> <span class="c1">//链表
</span><span class="c1"></span>	<span class="c1">// g 被阻塞之后的近似时间
</span><span class="c1"></span>	<span class="nx">waitsince</span>      <span class="kt">int64</span>      <span class="c1">// approx time when the g become blocked
</span><span class="c1"></span>	<span class="c1">// g 被阻塞的原因
</span><span class="c1"></span>	<span class="nx">waitreason</span>     <span class="nx">waitReason</span> <span class="c1">// if status==Gwaiting
</span><span class="c1"></span>	<span class="c1">// 抢占调度标志。这个为 true 时，stackguard0 等于 stackpreempt
</span><span class="c1"></span>	<span class="c1">// 抢占信号，stackguard0 = stackpreempt 的副本
</span><span class="c1"></span>	<span class="nx">preempt</span>        <span class="kt">bool</span>       <span class="c1">// preemption signal, duplicates stackguard0 = stackpreempt
</span><span class="c1"></span>	<span class="nx">paniconfault</span>   <span class="kt">bool</span>       <span class="c1">// panic (instead of crash) on unexpected fault address
</span><span class="c1"></span>	<span class="nx">preemptscan</span>    <span class="kt">bool</span>       <span class="c1">// preempted g does scan for gc
</span><span class="c1"></span>	<span class="nx">gcscandone</span>     <span class="kt">bool</span>       <span class="c1">// g has scanned stack; protected by _Gscan bit in status
</span><span class="c1"></span>	<span class="nx">gcscanvalid</span>    <span class="kt">bool</span>       <span class="c1">// false at start of gc cycle, true if G has not run since last scan; TODO: remove?
</span><span class="c1"></span>	<span class="nx">throwsplit</span>     <span class="kt">bool</span>       <span class="c1">// must not split stack
</span><span class="c1"></span>	<span class="nx">raceignore</span>     <span class="kt">int8</span>       <span class="c1">// ignore race detection events
</span><span class="c1"></span>	<span class="nx">sysblocktraced</span> <span class="kt">bool</span>       <span class="c1">// StartTrace has emitted EvGoInSyscall about this goroutine
</span><span class="c1"></span>	<span class="c1">// syscall 返回之后的 cputicks，用来做 tracing
</span><span class="c1"></span>	<span class="nx">sysexitticks</span>   <span class="kt">int64</span>      <span class="c1">// cputicks when syscall has returned (for tracing)
</span><span class="c1"></span>	<span class="nx">traceseq</span>       <span class="kt">uint64</span>     <span class="c1">// trace event sequencer
</span><span class="c1"></span>	<span class="nx">tracelastp</span>     <span class="nx">puintptr</span>   <span class="c1">// last P emitted an event for this goroutine
</span><span class="c1"></span>	<span class="c1">// 如果调用了 LockOsThread，那么这个 g 会绑定到某个 m 上
</span><span class="c1"></span>	<span class="nx">lockedm</span>        <span class="nx">muintptr</span>
	<span class="nx">sig</span>            <span class="kt">uint32</span>
	<span class="nx">writebuf</span>       <span class="p">[]</span><span class="kt">byte</span>
	<span class="nx">sigcode0</span>       <span class="kt">uintptr</span>
	<span class="nx">sigcode1</span>       <span class="kt">uintptr</span>
	<span class="nx">sigpc</span>          <span class="kt">uintptr</span>
	<span class="c1">// 创建该 goroutine 的语句的指令地址
</span><span class="c1"></span>	<span class="nx">gopc</span>           <span class="kt">uintptr</span>         <span class="c1">// pc of go statement that created this goroutine    //调用者PC/IP
</span><span class="c1"></span>	<span class="nx">ancestors</span>      <span class="o">*</span><span class="p">[]</span><span class="nx">ancestorInfo</span> <span class="c1">// ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)
</span><span class="c1"></span>	<span class="c1">// goroutine 函数的指令地址
</span><span class="c1"></span>	<span class="nx">startpc</span>        <span class="kt">uintptr</span>         <span class="c1">// pc of goroutine function  //任务函数
</span><span class="c1"></span>	<span class="nx">racectx</span>        <span class="kt">uintptr</span>
	<span class="nx">waiting</span>        <span class="o">*</span><span class="nx">sudog</span>         <span class="c1">// sudog structures this g is waiting on (that have a valid elem ptr); in lock order
</span><span class="c1"></span>	<span class="nx">cgoCtxt</span>        <span class="p">[]</span><span class="kt">uintptr</span>      <span class="c1">// cgo traceback context
</span><span class="c1"></span>	<span class="nx">labels</span>         <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// profiler labels
</span><span class="c1"></span>	<span class="c1">// time.Sleep 缓存的定时器
</span><span class="c1"></span>	<span class="nx">timer</span>          <span class="o">*</span><span class="nx">timer</span>         <span class="c1">// cached timer for time.Sleep
</span><span class="c1"></span>	<span class="nx">selectDone</span>     <span class="kt">uint32</span>         <span class="c1">// are we participating in a select and did someone win the race?
</span><span class="c1"></span>
	<span class="c1">// Per-G GC state
</span><span class="c1"></span>
	<span class="c1">// gcAssistBytes is this G&#39;s GC assist credit in terms of
</span><span class="c1"></span>	<span class="c1">// bytes allocated. If this is positive, then the G has credit
</span><span class="c1"></span>	<span class="c1">// to allocate gcAssistBytes bytes without assisting. If this
</span><span class="c1"></span>	<span class="c1">// is negative, then the G must correct this by performing
</span><span class="c1"></span>	<span class="c1">// scan work. We track this in bytes to make it fast to update
</span><span class="c1"></span>	<span class="c1">// and check for debt in the malloc hot path. The assist ratio
</span><span class="c1"></span>	<span class="c1">// determines how this corresponds to scan work debt.
</span><span class="c1"></span>	<span class="nx">gcAssistBytes</span> <span class="kt">int64</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>g 结构体关联了两个比较简单的结构体，stack 表示 goroutine 运行时的栈：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 描述栈的数据结构，栈的范围：[lo, hi)
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">stack</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 栈顶，低地址
</span><span class="c1"></span>    <span class="nx">lo</span> <span class="kt">uintptr</span>
    <span class="c1">// 栈低，高地址
</span><span class="c1"></span>    <span class="nx">hi</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Goroutine 运行时，光有栈还不行，至少还得包括 PC，SP 等寄存器，gobuf 就保存了这些值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">gobuf</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 存储 rsp 寄存器的值
</span><span class="c1"></span>    <span class="nx">sp</span>   <span class="kt">uintptr</span>
    <span class="c1">// 存储 rip 寄存器的值
</span><span class="c1"></span>    <span class="nx">pc</span>   <span class="kt">uintptr</span>
    <span class="c1">// 指向 goroutine
</span><span class="c1"></span>    <span class="nx">g</span>    <span class="nx">guintptr</span>
    <span class="nx">ctxt</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// this has to be a pointer so that gc scans it
</span><span class="c1"></span>    <span class="c1">// 保存系统调用的返回值
</span><span class="c1"></span>    <span class="nx">ret</span>  <span class="nx">sys</span><span class="p">.</span><span class="nx">Uintreg</span>
    <span class="nx">lr</span>   <span class="kt">uintptr</span>
    <span class="nx">bp</span>   <span class="kt">uintptr</span> <span class="c1">// for GOEXPERIMENT=framepointer
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果你知道程序时如何在计算机中执行的话（取指、译码、执行），那你就不会对这个结构体感到陌生。由于go的两级线程模型，所以G既要包含代码，又要包含用于执行该代码的栈以以及sp和pc。SP指向的是保存程序数据的栈的栈顶，PC指向的是正在取指的指令。而gogo函数的作用就是从sched结构中恢复出上次G被调度器暂停时的寄存器现场（SP、PC等），这样G就可以从上次暂停的地方继续执行了。</p>
<p>G 的状态流转：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201126172549.png" alt=""></p>
<p>说明一下，上图省略了一些垃圾回收的状态。</p>
<h4 id="m-1">M</h4>
<p>M 是 OS 线程的实体。我们介绍几个比较重要的字段，包括：</p>
<ul>
<li>持有用于执行调度器的 g0</li>
<li>持有用于信号处理的 gsignal</li>
<li>持有线程本地存储 tls</li>
<li>持有当前正在运行的 curg</li>
<li>持有运行 Goroutine 时需要的本地资源 p</li>
<li>表示自身的自旋和非自旋状态 spining</li>
<li>管理在它身上执行的 cgo 调用</li>
<li>将自己与其他的 M 进行串联</li>
<li>持有当前线程上进行内存分配的本地缓存 mcache</li>
</ul>
<p>等等其他五十多个字段，包括关于 M 的一些调度统计、调试信息等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">m</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// 记录工作线程（也就是内核线程）使用的栈信息。在执行调度代码时需要使用
</span><span class="c1"></span>    <span class="c1">// 执行用户 goroutine 代码时，使用用户 goroutine 自己的栈，因此调度时会发生栈的切换
</span><span class="c1"></span>	<span class="nx">g0</span>      <span class="o">*</span><span class="nx">g</span>     <span class="c1">// goroutine with scheduling stack	//提供系统栈空间
</span><span class="c1"></span>	<span class="nx">morebuf</span> <span class="nx">gobuf</span>  <span class="c1">// gobuf arg to morestack
</span><span class="c1"></span>	<span class="nx">divmod</span>  <span class="kt">uint32</span> <span class="c1">// div/mod denominator for arm - known to liblink
</span><span class="c1"></span>
	<span class="c1">// Fields not known to debuggers.
</span><span class="c1"></span>	<span class="nx">procid</span>        <span class="kt">uint64</span>       <span class="c1">// for debuggers, but offset not hard-coded
</span><span class="c1"></span>	<span class="c1">// 处理 signal 的 g
</span><span class="c1"></span>	<span class="nx">gsignal</span>       <span class="o">*</span><span class="nx">g</span>           <span class="c1">// signal-handling g
</span><span class="c1"></span>	<span class="nx">goSigStack</span>    <span class="nx">gsignalStack</span> <span class="c1">// Go-allocated signal handling stack
</span><span class="c1"></span>	<span class="nx">sigmask</span>       <span class="nx">sigset</span>       <span class="c1">// storage for saved signal mask
</span><span class="c1"></span>	<span class="c1">// 通过 tls 结构体实现 m 与工作线程的绑定
</span><span class="c1"></span>    <span class="c1">// 线程本地存储
</span><span class="c1"></span>	<span class="nx">tls</span>           <span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="kt">uintptr</span>   <span class="c1">// thread-local storage (for x86 extern register)
</span><span class="c1"></span>	<span class="c1">//在新的M上启动某个特殊任务的函数，可能系统监控，GC辅助或M自旋。
</span><span class="c1"></span>	<span class="nx">mstartfn</span>      <span class="kd">func</span><span class="p">()</span>	<span class="c1">//启动函数
</span><span class="c1"></span>	<span class="c1">//当前M正在运行的那个G（goroutine）的指针。
</span><span class="c1"></span>	<span class="nx">curg</span>          <span class="o">*</span><span class="nx">g</span>       <span class="c1">// current running goroutine	//当前运行G
</span><span class="c1"></span>	<span class="nx">caughtsig</span>     <span class="nx">guintptr</span> <span class="c1">// goroutine running during fatal signal
</span><span class="c1"></span>	<span class="c1">// 执行 go 代码时持有的 p (如果没有执行则为 nil)
</span><span class="c1"></span>	<span class="nx">p</span>             <span class="nx">puintptr</span> <span class="c1">// attached p for executing go code (nil if not executing go code)	//绑定P
</span><span class="c1"></span>	<span class="c1">//暂存与当前M有潜在关联的P，将P赋给M的nextp字段称为M和P的预联。
</span><span class="c1"></span>	<span class="nx">nextp</span>         <span class="nx">puintptr</span>	<span class="c1">//临时存放P
</span><span class="c1"></span>	<span class="nx">oldp</span>          <span class="nx">puintptr</span> <span class="c1">// the p that was attached before executing a syscall
</span><span class="c1"></span>	<span class="nx">id</span>            <span class="kt">int64</span>
	<span class="nx">mallocing</span>     <span class="kt">int32</span>
	<span class="nx">throwing</span>      <span class="kt">int32</span>
	<span class="c1">// 该字段不等于空字符串的话，要保持 curg 始终在这个 m 上运行
</span><span class="c1"></span>	<span class="nx">preemptoff</span>    <span class="kt">string</span> <span class="c1">// if != &#34;&#34;, keep curg running on this m
</span><span class="c1"></span>	<span class="nx">locks</span>         <span class="kt">int32</span>
	<span class="nx">dying</span>         <span class="kt">int32</span>
	<span class="nx">profilehz</span>     <span class="kt">int32</span>
	<span class="c1">// 为 true 时表示当前 m 处于自旋状态，正在从其他线程偷工作
</span><span class="c1"></span>	<span class="nx">spinning</span>      <span class="kt">bool</span> <span class="c1">// m is out of work and is actively looking for work	//自旋状态
</span><span class="c1"></span>	<span class="c1">// m 正阻塞在 note 上
</span><span class="c1"></span>	<span class="nx">blocked</span>       <span class="kt">bool</span> <span class="c1">// m is blocked on a note
</span><span class="c1"></span>	<span class="c1">// m 正在执行 write barrier
</span><span class="c1"></span>	<span class="nx">inwb</span>          <span class="kt">bool</span> <span class="c1">// m is executing a write barrier
</span><span class="c1"></span>	<span class="nx">newSigstack</span>   <span class="kt">bool</span> <span class="c1">// minit on C thread called sigaltstack
</span><span class="c1"></span>	<span class="nx">printlock</span>     <span class="kt">int8</span>
	<span class="c1">// 正在执行 cgo 调用
</span><span class="c1"></span>	<span class="nx">incgo</span>         <span class="kt">bool</span>   <span class="c1">// m is executing a cgo call
</span><span class="c1"></span>	<span class="nx">freeWait</span>      <span class="kt">uint32</span> <span class="c1">// if == 0, safe to free g0 and delete m (atomic)
</span><span class="c1"></span>	<span class="nx">fastrand</span>      <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">uint32</span>
	<span class="nx">needextram</span>    <span class="kt">bool</span>
	<span class="nx">traceback</span>     <span class="kt">uint8</span>
	<span class="c1">// cgo 调用总计数
</span><span class="c1"></span>	<span class="nx">ncgocall</span>      <span class="kt">uint64</span>      <span class="c1">// number of cgo calls in total
</span><span class="c1"></span>	<span class="nx">ncgo</span>          <span class="kt">int32</span>       <span class="c1">// number of cgo calls currently in progress
</span><span class="c1"></span>	<span class="nx">cgoCallersUse</span> <span class="kt">uint32</span>      <span class="c1">// if non-zero, cgoCallers in use temporarily
</span><span class="c1"></span>	<span class="c1">// cgo 调用崩溃的 cgo 回溯
</span><span class="c1"></span>	<span class="nx">cgoCallers</span>    <span class="o">*</span><span class="nx">cgoCallers</span> <span class="c1">// cgo traceback if crashing in cgo call
</span><span class="c1"></span>	<span class="c1">// 没有 goroutine 需要运行时，工作线程睡眠在这个 park 成员上，
</span><span class="c1"></span>    <span class="c1">// 其它线程通过这个 park 唤醒该工作线程
</span><span class="c1"></span>	<span class="nx">park</span>          <span class="nx">note</span>	<span class="c1">//休眠锁
</span><span class="c1"></span>	<span class="c1">// 记录所有工作线程的链表
</span><span class="c1"></span>	<span class="nx">alllink</span>       <span class="o">*</span><span class="nx">m</span> <span class="c1">// on allm
</span><span class="c1"></span>	<span class="nx">schedlink</span>     <span class="nx">muintptr</span>	<span class="c1">//链表
</span><span class="c1"></span>	<span class="nx">mcache</span>        <span class="o">*</span><span class="nx">mcache</span>
	<span class="c1">//与当前M锁定的G。一旦锁定，这个M只能运行这个G，这个G也只能由该M运行。
</span><span class="c1"></span>	<span class="nx">lockedg</span>       <span class="nx">guintptr</span>
	<span class="nx">createstack</span>   <span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="kt">uintptr</span>    <span class="c1">// stack that created this thread.
</span><span class="c1"></span>	<span class="nx">lockedExt</span>     <span class="kt">uint32</span>         <span class="c1">// tracking for external LockOSThread
</span><span class="c1"></span>	<span class="nx">lockedInt</span>     <span class="kt">uint32</span>         <span class="c1">// tracking for internal lockOSThread
</span><span class="c1"></span>	<span class="c1">// 正在等待锁的下一个 m
</span><span class="c1"></span>	<span class="nx">nextwaitm</span>     <span class="nx">muintptr</span>       <span class="c1">// next m waiting for lock
</span><span class="c1"></span>	<span class="nx">waitunlockf</span>   <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// todo go func(*g, unsafe.pointer) bool
</span><span class="c1"></span>	<span class="nx">waitlock</span>      <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="nx">waittraceev</span>   <span class="kt">byte</span>
	<span class="nx">waittraceskip</span> <span class="kt">int</span>
	<span class="nx">startingtrace</span> <span class="kt">bool</span>
	<span class="nx">syscalltick</span>   <span class="kt">uint32</span>
	<span class="c1">//线程句柄。真正用来执行go代码的系统线程。
</span><span class="c1"></span>	<span class="c1">// 工作线程 id
</span><span class="c1"></span>	<span class="nx">thread</span>        <span class="kt">uintptr</span> <span class="c1">// thread handle
</span><span class="c1"></span>	<span class="nx">freelink</span>      <span class="o">*</span><span class="nx">m</span>      <span class="c1">// on sched.freem
</span><span class="c1"></span>
	<span class="c1">// these are here because they are too large to be on the stack
</span><span class="c1"></span>	<span class="c1">// of low-level NOSPLIT functions.
</span><span class="c1"></span>	<span class="nx">libcall</span>   <span class="nx">libcall</span>
	<span class="nx">libcallpc</span> <span class="kt">uintptr</span> <span class="c1">// for cpu profiler
</span><span class="c1"></span>	<span class="nx">libcallsp</span> <span class="kt">uintptr</span>
	<span class="nx">libcallg</span>  <span class="nx">guintptr</span>
	<span class="nx">syscall</span>   <span class="nx">libcall</span> <span class="c1">// stores syscall parameters on windows
</span><span class="c1"></span>
	<span class="nx">vdsoSP</span> <span class="kt">uintptr</span> <span class="c1">// SP for traceback while in VDSO call (0 if not in call)
</span><span class="c1"></span>	<span class="nx">vdsoPC</span> <span class="kt">uintptr</span> <span class="c1">// PC for traceback while in VDSO call
</span><span class="c1"></span>
	<span class="nx">mOS</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>M 的状态变化：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201116140605.png" alt=""></p>
<p>M 只有自旋和非自旋两种状态。自旋的时候，会努力找工作；找不到的时候会进入非自旋状态，之后会休眠，直到有工作需要处理时，被其他工作线程唤醒，又进入自旋状态。</p>
<h4 id="p-1">P</h4>
<p>P 只是处理器的抽象，而非处理器本身，它存在的意义在于实现工作窃取（work stealing）算法。 简单来说，每个 P 持有一个 G 的本地队列。</p>
<p>在没有 P 的情况下，所有的 G 只能放在一个全局的队列中。 当 M 执行完 G 而没有 G 可执行时，必须将队列锁住从而取值。</p>
<p>当引入了 P 之后，P 持有 G 的本地队列，而持有 P 的 M 执行完 G 后在 P 本地队列中没有 发现其他 G 可以执行时，虽然仍然会先检查全局队列、网络，但这时增加了一个从其他 P 的 队列偷取（steal）一个 G 来执行的过程。优先级为本地 &gt; 全局 &gt; 网络 &gt; 偷取。</p>
<p>所以整个结构除去 P 的本地 G 队列外，就是一些统计、调试、GC 辅助的字段了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">p</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span> <span class="nx">mutex</span>
	<span class="c1">// 在 allp 中的索引
</span><span class="c1"></span>	<span class="nx">id</span>          <span class="kt">int32</span>
	<span class="c1">//P的状态
</span><span class="c1"></span>	<span class="nx">status</span>      <span class="kt">uint32</span> <span class="c1">// one of pidle/prunning/...
</span><span class="c1"></span>	<span class="nx">link</span>        <span class="nx">puintptr</span>
	<span class="c1">// 调度计数 每次调用 schedule 时会加一
</span><span class="c1"></span>	<span class="nx">schedtick</span>   <span class="kt">uint32</span>     <span class="c1">// incremented on every scheduler call
</span><span class="c1"></span>	<span class="c1">// 系统调用计数  每次系统调用时加一
</span><span class="c1"></span>	<span class="nx">syscalltick</span> <span class="kt">uint32</span>     <span class="c1">// incremented on every system call
</span><span class="c1"></span>	<span class="c1">// sysmon持有的调用计数备份,用于 sysmon 线程记录被监控 p 的系统调用时间和运行时间
</span><span class="c1"></span>	<span class="nx">sysmontick</span>  <span class="nx">sysmontick</span> <span class="c1">// last tick observed by sysmon
</span><span class="c1"></span>	<span class="c1">// 反向链接到关联的 m （nil 则表示 idle）
</span><span class="c1"></span>	<span class="nx">m</span>           <span class="nx">muintptr</span>   <span class="c1">// back-link to associated m (nil if idle)
</span><span class="c1"></span>	<span class="nx">mcache</span>      <span class="o">*</span><span class="nx">mcache</span>
	<span class="nx">racectx</span>     <span class="kt">uintptr</span>
	<span class="c1">// 不同大小的可用的 defer 结构池
</span><span class="c1"></span>	<span class="nx">deferpool</span>    <span class="p">[</span><span class="mi">5</span><span class="p">][]</span><span class="o">*</span><span class="nx">_defer</span> <span class="c1">// pool of available defer structs of different sizes (see panic.go)
</span><span class="c1"></span>	<span class="nx">deferpoolbuf</span> <span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">32</span><span class="p">]</span><span class="o">*</span><span class="nx">_defer</span>

	<span class="c1">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.
</span><span class="c1"></span>	<span class="nx">goidcache</span>    <span class="kt">uint64</span>
	<span class="nx">goidcacheend</span> <span class="kt">uint64</span>

	<span class="c1">// Queue of runnable goroutines. Accessed without lock.
</span><span class="c1"></span>	<span class="c1">//可运行G队列的队头
</span><span class="c1"></span>	<span class="nx">runqhead</span> <span class="kt">uint32</span>
	<span class="c1">//可运行G队列的队尾
</span><span class="c1"></span>	<span class="nx">runqtail</span> <span class="kt">uint32</span>
	<span class="c1">//可运行G队列，固定长度为256
</span><span class="c1"></span>	<span class="nx">runq</span>     <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="nx">guintptr</span> <span class="c1">//本地队列,访问时无须加锁
</span><span class="c1"></span>	<span class="c1">// runnext, if non-nil, is a runnable G that was ready&#39;d by
</span><span class="c1"></span>	<span class="c1">// the current G and should be run next instead of what&#39;s in
</span><span class="c1"></span>	<span class="c1">// runq if there&#39;s time remaining in the running G&#39;s time
</span><span class="c1"></span>	<span class="c1">// slice. It will inherit the time left in the current time
</span><span class="c1"></span>	<span class="c1">// slice. If a set of goroutines is locked in a
</span><span class="c1"></span>	<span class="c1">// communicate-and-wait pattern, this schedules that set as a
</span><span class="c1"></span>	<span class="c1">// unit and eliminates the (potentially large) scheduling
</span><span class="c1"></span>	<span class="c1">// latency that otherwise arises from adding the ready&#39;d
</span><span class="c1"></span>	<span class="c1">// goroutines to the end of the run queue.
</span><span class="c1"></span>	<span class="c1">// runnext 非空时，代表的是一个 runnable 状态的 G，
</span><span class="c1"></span>    <span class="c1">// 这个 G 被 当前 G 修改为 ready 状态，相比 runq 中的 G 有更高的优先级。
</span><span class="c1"></span>    <span class="c1">// 如果当前 G 还有剩余的可用时间，那么就应该运行这个 G
</span><span class="c1"></span>    <span class="c1">// 运行之后，该 G 会继承当前 G 的剩余时间
</span><span class="c1"></span>	<span class="nx">runnext</span> <span class="nx">guintptr</span>    <span class="c1">//优先执行
</span><span class="c1"></span>
	<span class="c1">// Available G&#39;s (status == Gdead)
</span><span class="c1"></span>	<span class="c1">//自由G队列
</span><span class="c1"></span>	<span class="nx">gFree</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">gList</span>
		<span class="nx">n</span> <span class="kt">int32</span>
	<span class="p">}</span>

	<span class="nx">sudogcache</span> <span class="p">[]</span><span class="o">*</span><span class="nx">sudog</span>
	<span class="nx">sudogbuf</span>   <span class="p">[</span><span class="mi">128</span><span class="p">]</span><span class="o">*</span><span class="nx">sudog</span>

	<span class="nx">tracebuf</span> <span class="nx">traceBufPtr</span>

	<span class="c1">// traceSweep indicates the sweep events should be traced.
</span><span class="c1"></span>	<span class="c1">// This is used to defer the sweep start event until a span
</span><span class="c1"></span>	<span class="c1">// has actually been swept.
</span><span class="c1"></span>	<span class="nx">traceSweep</span> <span class="kt">bool</span>
	<span class="c1">// traceSwept and traceReclaimed track the number of bytes
</span><span class="c1"></span>	<span class="c1">// swept and reclaimed by sweeping in the current sweep loop.
</span><span class="c1"></span>	<span class="nx">traceSwept</span><span class="p">,</span> <span class="nx">traceReclaimed</span> <span class="kt">uintptr</span>

	<span class="nx">palloc</span> <span class="nx">persistentAlloc</span> <span class="c1">// per-P to avoid mutex
</span><span class="c1"></span>
	<span class="c1">// Per-P GC state
</span><span class="c1"></span>	<span class="nx">gcAssistTime</span>         <span class="kt">int64</span> <span class="c1">// Nanoseconds in assistAlloc
</span><span class="c1"></span>	<span class="nx">gcFractionalMarkTime</span> <span class="kt">int64</span> <span class="c1">// Nanoseconds in fractional mark worker
</span><span class="c1"></span>	<span class="nx">gcBgMarkWorker</span>       <span class="nx">guintptr</span>
	<span class="nx">gcMarkWorkerMode</span>     <span class="nx">gcMarkWorkerMode</span>

	<span class="c1">// gcMarkWorkerStartTime is the nanotime() at which this mark
</span><span class="c1"></span>	<span class="c1">// worker started.
</span><span class="c1"></span>	<span class="nx">gcMarkWorkerStartTime</span> <span class="kt">int64</span>

	<span class="c1">// gcw is this P&#39;s GC work buffer cache. The work buffer is
</span><span class="c1"></span>	<span class="c1">// filled by write barriers, drained by mutator assists, and
</span><span class="c1"></span>	<span class="c1">// disposed on certain GC state transitions.
</span><span class="c1"></span>	<span class="nx">gcw</span> <span class="nx">gcWork</span>

	<span class="c1">// wbBuf is this P&#39;s GC write barrier buffer.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// TODO: Consider caching this in the running G.
</span><span class="c1"></span>	<span class="nx">wbBuf</span> <span class="nx">wbBuf</span>

	<span class="nx">runSafePointFn</span> <span class="kt">uint32</span> <span class="c1">// if 1, run sched.safePointFn at next safe point
</span><span class="c1"></span>
	<span class="nx">pad</span> <span class="nx">cpu</span><span class="p">.</span><span class="nx">CacheLinePad</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>P 的状态流转：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201125224431.png" alt=""></p>
<p>通常情况下（在程序运行时不调整 P 的个数），P 只会在上图中的四种状态下进行切换。 当程序刚开始运行进行初始化时，所有的 P 都处于 _Pgcstop 状态， 随着 P 的初始化（runtime.procresize），会被置于_Pidle。</p>
<p>当 M 需要运行时，会 runtime.acquirep 来使 P 变成 Prunning 状态，并通过 runtime.releasep 来释放。</p>
<p>当 G 执行时需要进入系统调用，P 会被设置为 _Psyscall， 如果这个时候被系统监控抢夺（runtime.retake），则 P 会被重新修改为_Pidle。</p>
<p>如果在程序运行中发生 GC，则 P 会被设置为 _Pgcstop， 并在 runtime.startTheWorld 时重新调整为_Pidle 或者 _Prunning。</p>
<h4 id="schedt">schedt</h4>
<p>调度器，所有 Goroutine 被调度的核心，存放了调度器持有的全局资源，访问这些资源需要持有锁：</p>
<ul>
<li>管理了能够将 G 和 M 进行绑定的 M 队列</li>
<li>管理了空闲的 P 链表（队列）</li>
<li>管理了 G 的全局队列</li>
<li>管理了可被复用的 G 的全局缓存</li>
<li>管理了 defer 池</li>
</ul>
<p>调度器的数据结构是一个结构体，但是不能单纯的说调度器就是一个结构体。结构体只是为了辅助调度，真正的调度行为还的靠调度函数来完成。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">schedt</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// accessed atomically. keep at top to ensure alignment on 32-bit systems.
</span><span class="c1"></span>    <span class="c1">// 需以原子访问访问。
</span><span class="c1"></span>    <span class="c1">// 保持在 struct 顶部，以使其在 32 位系统上可以对齐
</span><span class="c1"></span>	<span class="nx">goidgen</span>  <span class="kt">uint64</span>
	<span class="nx">lastpoll</span> <span class="kt">uint64</span>

	<span class="nx">lock</span> <span class="nx">mutex</span>

	<span class="c1">// When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be
</span><span class="c1"></span>	<span class="c1">// sure to call checkdead().
</span><span class="c1"></span>	<span class="c1">//闲置M链表 由空闲的工作线程组成的链表
</span><span class="c1"></span>	<span class="nx">midle</span>        <span class="nx">muintptr</span> <span class="c1">// idle m&#39;s waiting for work
</span><span class="c1"></span>	<span class="c1">//闲置的M数量 空闲的工作线程数量
</span><span class="c1"></span>	<span class="nx">nmidle</span>       <span class="kt">int32</span>    <span class="c1">// number of idle m&#39;s waiting for work
</span><span class="c1"></span>	<span class="c1">//因锁定而停止的M的数量 空闲的且被 lock 的 m 计数
</span><span class="c1"></span>	<span class="nx">nmidlelocked</span> <span class="kt">int32</span>    <span class="c1">// number of locked m&#39;s waiting for work
</span><span class="c1"></span>	<span class="c1">//已创建的M的数量，也是下一个M的ID号
</span><span class="c1"></span>	<span class="nx">mnext</span>        <span class="kt">int64</span>    <span class="c1">// number of m&#39;s that have been created and next M ID
</span><span class="c1"></span>	<span class="c1">// 表示最多所能创建的工作线程数量
</span><span class="c1"></span>	<span class="nx">maxmcount</span>    <span class="kt">int32</span>    <span class="c1">// maximum number of m&#39;s allowed (or die)	//M最大闲置数
</span><span class="c1"></span>	<span class="c1">//执行系统监测任务的M的数量
</span><span class="c1"></span>	<span class="nx">nmsys</span>        <span class="kt">int32</span>    <span class="c1">// number of system m&#39;s not counted for deadlock
</span><span class="c1"></span>	<span class="c1">//已被释放的M的数量
</span><span class="c1"></span>	<span class="nx">nmfreed</span>      <span class="kt">int64</span>    <span class="c1">// cumulative number of freed m&#39;s
</span><span class="c1"></span>	<span class="c1">// goroutine 的数量，自动更新
</span><span class="c1"></span>	<span class="nx">ngsys</span> <span class="kt">uint32</span> <span class="c1">// number of system goroutines; updated atomically
</span><span class="c1"></span>	<span class="c1">// 由空闲的 p 结构体对象组成的链表
</span><span class="c1"></span>	<span class="nx">pidle</span>      <span class="nx">puintptr</span> <span class="c1">// idle p&#39;s
</span><span class="c1"></span>	<span class="c1">// 空闲的 p 结构体对象的数量
</span><span class="c1"></span>	<span class="nx">npidle</span>     <span class="kt">uint32</span>
	<span class="c1">// 自旋状态的 M 的数量
</span><span class="c1"></span>	<span class="nx">nmspinning</span> <span class="kt">uint32</span> <span class="c1">// See &#34;Worker thread parking/unparking&#34; comment in proc.go.
</span><span class="c1"></span>
	<span class="c1">// Global runnable queue.
</span><span class="c1"></span>	<span class="c1">// 全局 runnable G 队列
</span><span class="c1"></span>	<span class="nx">runq</span>     <span class="nx">gQueue</span>
	<span class="c1">// 元素数量
</span><span class="c1"></span>	<span class="nx">runqsize</span> <span class="kt">int32</span>

	<span class="c1">// disable controls selective disabling of the scheduler.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Use schedEnableUser to control this.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// disable is protected by sched.lock.
</span><span class="c1"></span>	<span class="nx">disable</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="c1">// user disables scheduling of user goroutines.
</span><span class="c1"></span>		<span class="nx">user</span>     <span class="kt">bool</span>
		<span class="nx">runnable</span> <span class="nx">gQueue</span> <span class="c1">// pending runnable Gs
</span><span class="c1"></span>		<span class="nx">n</span>        <span class="kt">int32</span>  <span class="c1">// length of runnable
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="c1">// Global cache of dead G&#39;s.
</span><span class="c1"></span>	<span class="c1">// dead G 的全局缓存
</span><span class="c1"></span>    <span class="c1">// 已退出的 goroutine 对象，缓存下来
</span><span class="c1"></span>    <span class="c1">// 避免每次创建 goroutine 时都重新分配内存
</span><span class="c1"></span>	<span class="nx">gFree</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">lock</span>    <span class="nx">mutex</span>
		<span class="c1">// 包含栈的 Gs
</span><span class="c1"></span>		<span class="nx">stack</span>   <span class="nx">gList</span> <span class="c1">// Gs with stacks
</span><span class="c1"></span>		<span class="c1">// 没有栈的 Gs
</span><span class="c1"></span>		<span class="nx">noStack</span> <span class="nx">gList</span> <span class="c1">// Gs without stacks
</span><span class="c1"></span>		<span class="c1">// 空闲 g 的数量
</span><span class="c1"></span>		<span class="nx">n</span>       <span class="kt">int32</span>
	<span class="p">}</span>

	<span class="c1">// Central cache of sudog structs.
</span><span class="c1"></span>	<span class="c1">// sudog 结构的集中缓存
</span><span class="c1"></span>	<span class="nx">sudoglock</span>  <span class="nx">mutex</span>
	<span class="nx">sudogcache</span> <span class="o">*</span><span class="nx">sudog</span>

	<span class="c1">// Central pool of available defer structs of different sizes.
</span><span class="c1"></span>	<span class="c1">// 不同大小的可用的 defer struct 的集中缓存池
</span><span class="c1"></span>	<span class="nx">deferlock</span> <span class="nx">mutex</span>
	<span class="nx">deferpool</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="nx">_defer</span>

	<span class="c1">// freem is the list of m&#39;s waiting to be freed when their
</span><span class="c1"></span>	<span class="c1">// m.exited is set. Linked through m.freelink.
</span><span class="c1"></span>	<span class="nx">freem</span> <span class="o">*</span><span class="nx">m</span>

	<span class="nx">gcwaiting</span>  <span class="kt">uint32</span> <span class="c1">// gc is waiting to run  //是否需要因一些任务而停止调度
</span><span class="c1"></span>	<span class="nx">stopwait</span>   <span class="kt">int32</span><span class="c1">//需要停止但仍未停止的P的数量
</span><span class="c1"></span>	<span class="nx">stopnote</span>   <span class="nx">note</span><span class="c1">//实现与stopwait相关的事件通知机制
</span><span class="c1"></span>	<span class="nx">sysmonwait</span> <span class="kt">uint32</span><span class="c1">//停止调度期间，系统监控任务是否在等待
</span><span class="c1"></span>	<span class="nx">sysmonnote</span> <span class="nx">note</span><span class="c1">//实现与sysmonwait相关的事件通知机制
</span><span class="c1"></span>
	<span class="c1">// safepointFn should be called on each P at the next GC
</span><span class="c1"></span>	<span class="c1">// safepoint if p.runSafePointFn is set.
</span><span class="c1"></span>	<span class="nx">safePointFn</span>   <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span>
	<span class="nx">safePointWait</span> <span class="kt">int32</span>
	<span class="nx">safePointNote</span> <span class="nx">note</span>

	<span class="nx">profilehz</span> <span class="kt">int32</span> <span class="c1">// cpu profiling rate
</span><span class="c1"></span>	<span class="c1">// 上次修改 gomaxprocs 的纳秒时间
</span><span class="c1"></span>	<span class="nx">procresizetime</span> <span class="kt">int64</span> <span class="c1">// nanotime() of last change to gomaxprocs
</span><span class="c1"></span>	<span class="nx">totaltime</span>      <span class="kt">int64</span> <span class="c1">// ∫gomaxprocs dt up to procresizetime
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在程序运行过程中，schedt 对象只有一份实体，它维护了调度器的所有信息。</p>
<p>在go运行时系统中，一些任务执行前需要停止调度。例如垃圾回收任务中的某些子任务，发起运行时恐慌的任务。下面我们将这类任务统称为串行运行时任务。上面的字段都是和串行运行时任务相关的。并且它们也是并发安全的。</p>
<p>暂停调度任务：主要与gcwaiting、stopwait、stopnote字段有关。</p>
<ol>
<li>gcwaiting字段表示是否需要停止调度。在停止调度前，该值被设置为1；恢复调度前，该值被设置为0。</li>
<li>一些调度任务在执行时，一旦发现gcwaiting的值为1，就会把当前P的状态设置为Pgcstop，然后自减stopwait字段的值。</li>
<li>当自减后发现stopwait的值为0，说明所有P都进入了Pgcstop状态。然后就利用stopnote字段唤醒因等待调度停止而暂停的串行运行时任务。</li>
</ol>
<p>暂停系统检测任务：主要与sysmonwait和sysmonnote字段相关。</p>
<ol>
<li>串行运行时任务执行前，系统检测任务也要暂停。</li>
<li>sysmonwait字段表示是否已暂停。0表示未暂停，1表示已暂停。</li>
<li>系统监测任务是一直执行的，它处于无限循环中。在每个循环的开始，系统监测程序都会检查调度情况。</li>
<li>一旦发现调度停止（gcwaiting的值不为0或所有P都已闲置），就会把sysmonwait字段的值设置为1，并利用sysmonnote字段暂停自身。</li>
<li>恢复调度之前，调度器若发现sysmonwait的值不为0，就把它置为0，并利用sysmonnote字段恢复系统监测任务的执行。</li>
</ol>
<h3 id="调度流程">调度流程</h3>
<p>下面流程图，画出了主要的调度流程,现在我们根据流程图分析相关源码</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20190706222545.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201126205229.png" alt=""></p>
<h3 id="调度器初始化">调度器初始化</h3>
<h4 id="schedinit">schedinit</h4>
<p>运行时通过 runtime.schedinit 函数初始化调度器：</p>
<p>在调度器初始函数执行的过程中会将 maxmcount 设置成 10000，这也就是一个 Go 语言程序能够创建的最大线程数，虽然最多可以创建 10000 个线程，但是可以同时运行的线程还是由 GOMAXPROCS 变量控制。</p>
<p>同时runtime/debug包的SetMaxThreads函数可以用来修改这一限制。该函数会返回旧的M数量的最大值。需要注意的是，如果你给定的新值比当时已有的M的数量小，运行时系统会立即引发一个运行时恐慌。所以调用这个函数一定要慎重，而且如果真的有必要，那么越早调用越好。因为调整的过程中会损耗部分性能。</p>
<p>我们从环境变量 GOMAXPROCS 获取了程序能够同时运行的最大处理器数之后就会调用 runtime.procresize 更新程序中处理器的数量，在这时整个程序不会执行任何用户 Goroutine，调度器也会进入锁定状态.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// The bootstrap sequence is:
</span><span class="c1">//
</span><span class="c1">//	call osinit 初始化系统核心数。
</span><span class="c1">//	call schedinit	初始化调度器。
</span><span class="c1">//	make &amp; queue new G	创建新的 goroutine。
</span><span class="c1">//	call runtime·mstart	调用 mstart，启动调度。
</span><span class="c1">//
</span><span class="c1">// The new G calls runtime·main.	在新的 goroutine 上运行 runtime.main 函数。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">schedinit</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// raceinit must be the first call to race detector.
</span><span class="c1"></span>	<span class="c1">// In particular, it must be done before mallocinit below calls racemapshadow.
</span><span class="c1"></span>	<span class="c1">// getg 由编译器实现
</span><span class="c1"></span>    <span class="c1">// get_tls(CX)
</span><span class="c1"></span>    <span class="c1">// MOVQ g(CX), BX; BX存器里面现在放的是当前g结构体对象的地址
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">racectx</span><span class="p">,</span> <span class="nx">raceprocctx0</span> <span class="p">=</span> <span class="nf">raceinit</span><span class="p">()</span>
	<span class="p">}</span>
    <span class="c1">//设置最大M数量
</span><span class="c1"></span>	<span class="nx">sched</span><span class="p">.</span><span class="nx">maxmcount</span> <span class="p">=</span> <span class="mi">10000</span>

	<span class="nf">tracebackinit</span><span class="p">()</span>
    <span class="nf">moduledataverify</span><span class="p">()</span>
    <span class="c1">//初始化栈空间复用管理链表
</span><span class="c1"></span>	<span class="nf">stackinit</span><span class="p">()</span>
    <span class="nf">mallocinit</span><span class="p">()</span>
    <span class="c1">// 初始化 m0
</span><span class="c1"></span>	<span class="nf">mcommoninit</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>
	<span class="nf">cpuinit</span><span class="p">()</span>       <span class="c1">// must run before alginit
</span><span class="c1"></span>	<span class="nf">alginit</span><span class="p">()</span>       <span class="c1">// maps must not be used before this call
</span><span class="c1"></span>	<span class="nf">modulesinit</span><span class="p">()</span>   <span class="c1">// provides activeModules
</span><span class="c1"></span>	<span class="nf">typelinksinit</span><span class="p">()</span> <span class="c1">// uses maps, activeModules
</span><span class="c1"></span>	<span class="nf">itabsinit</span><span class="p">()</span>     <span class="c1">// uses activeModules
</span><span class="c1"></span>
	<span class="nf">msigsave</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>
	<span class="nx">initSigmask</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">sigmask</span>

	<span class="nf">goargs</span><span class="p">()</span>
	<span class="nf">goenvs</span><span class="p">()</span>
	<span class="nf">parsedebugvars</span><span class="p">()</span>
	<span class="nf">gcinit</span><span class="p">()</span>

    <span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nf">nanotime</span><span class="p">())</span>
    <span class="c1">// 初始化 P 的个数
</span><span class="c1"></span>    <span class="c1">// 系统中有多少核，就创建和初始化多少个 p 结构体对象
</span><span class="c1"></span>	<span class="nx">procs</span> <span class="o">:=</span> <span class="nx">ncpu</span>
	<span class="k">if</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">atoi32</span><span class="p">(</span><span class="nf">gogetenv</span><span class="p">(</span><span class="s">&#34;GOMAXPROCS&#34;</span><span class="p">));</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">procs</span> <span class="p">=</span> <span class="nx">n</span>
    <span class="p">}</span>
    <span class="c1">//调整P数量
</span><span class="c1"></span>    <span class="c1">//注意:此刻所有P都是新建的,所以不可能返回有本地任务的P
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">procresize</span><span class="p">(</span><span class="nx">procs</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unknown runnable goroutine during bootstrap&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// For cgocheck &gt; 1, we turn on the write barrier at all times
</span><span class="c1"></span>	<span class="c1">// and check all pointer writes. We can&#39;t do this until after
</span><span class="c1"></span>	<span class="c1">// procresize because the write barrier needs a P.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">cgocheck</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">cgo</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">wbBuf</span><span class="p">.</span><span class="nf">reset</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">buildVersion</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="c1">// Condition should never trigger. This code just serves
</span><span class="c1"></span>		<span class="c1">// to ensure runtime·buildVersion is kept in the resulting binary.
</span><span class="c1"></span>		<span class="nx">buildVersion</span> <span class="p">=</span> <span class="s">&#34;unknown&#34;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>mcommoninit函数初始化m0.</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201116180803.png" alt=""></p>
<p>上图中，将 m0 挂在 allm 上。之后，若新创建 m，则 m1 会和 m0 相连。</p>
<p>M 其实就是 OS 线程，它只有两个状态：自旋、非自旋。 在调度器初始化阶段，只有一个 M，那就是主 OS 线程，因此这里的 commoninit 仅仅只是对 M 进行一个初步的初始化， 该初始化包含对 M 及用于处理 M 信号的 G 的相关运算操作，未涉及工作线程的暂止和复始。</p>
<h5 id="getg">getg</h5>
<p>函数首先调用 getg() 函数获取当前正在运行的 g，getg() 在 src/runtime/stubs.go 中声明，真正的代码由编译器生成。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// getg returns the pointer to the current g.
</span><span class="c1">// The compiler rewrites calls to this function into instructions
</span><span class="c1">// that fetch the g directly (from TLS or from the dedicated register).
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getg</span><span class="p">()</span> <span class="o">*</span><span class="nx">g</span>
</code></pre></td></tr></table>
</div>
</div><p>getg 返回当前正在运行的 goroutine 的指针，它会从 tls 里取出 tls[0]，也就是当前运行的 goroutine 的地址。编译器插入类似下面的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nf">get_tls</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
<span class="nx">MOVQ</span> <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">BX</span><span class="p">;</span> <span class="c1">// BX存器里面现在放的是当前g结构体对象的地址
</span></code></pre></td></tr></table>
</div>
</div><h3 id="调整p列表">调整P列表</h3>
<h4 id="procresize">procresize</h4>
<p>默认只有schedinit和startTheWorldWithSema会调用procresize函数.</p>
<ul>
<li>在schedinit阶段,所有P对象都是新建的.除分配给当前主线程的外,其他都被放入空闲链表.</li>
<li>而startTheWorldWithSema会激活全部有本地任务的P对象</li>
</ul>
<p>runtime.procresize 的执行过程如下：</p>
<ol>
<li>调用时已经 STW，记录调整 P 的时间；</li>
<li>如果全局变量 allp 切片中的处理器数量少于期望数量，就会对切片进行扩容；</li>
<li>使用 new 创建新的处理器结构体并调用 runtime.p.init 方法初始化刚刚扩容的处理器；</li>
<li>如果当前的 P 还可以继续使用（没有被移除），则将 P 设置为 _Prunning；</li>
<li>否则将第一个 P 抢过来给当前 G 的 M 进行绑定,通过指针将线程 m0 和处理器 allp[0] 绑定到一起；</li>
<li>调用 runtime.p.destroy 方法释放不再使用的处理器结构；</li>
<li>通过截断改变全局变量 allp 的长度保证与期望处理器数量相等；</li>
<li>将除 allp[0] 之外的处理器 P 全部设置成 _Pidle 并加入到全局的空闲队列中；</li>
</ol>
<p>调用 runtime.procresize 就是调度器启动的最后一步，在这一步过后调度器会完成相应数量处理器的启动，等待用户创建运行新的 Goroutine 并为 Goroutine 调度处理器资源。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Change number of processors. The world is stopped, sched is locked.
</span><span class="c1">// gcworkbufs are not being modified by either the GC or
</span><span class="c1">// the write barrier code.
</span><span class="c1">// Returns list of Ps with local work, they need to be scheduled by the caller.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">procresize</span><span class="p">(</span><span class="nx">nprocs</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">p</span> <span class="p">{</span>
    <span class="c1">//p的数量
</span><span class="c1"></span>	<span class="nx">old</span> <span class="o">:=</span> <span class="nx">gomaxprocs</span>
	<span class="c1">//首先再检查一遍新值和旧值，如果不合法就引发一个运行时恐慌，并终止该流程。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">old</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">nprocs</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;procresize: invalid arg&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGomaxprocs</span><span class="p">(</span><span class="nx">nprocs</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// update statistics
</span><span class="c1"></span>	<span class="c1">// 更新统计信息，记录此次修改 gomaxprocs 的时间
</span><span class="c1"></span>	<span class="nx">now</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">procresizetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">sched</span><span class="p">.</span><span class="nx">totaltime</span> <span class="o">+=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">old</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">now</span> <span class="o">-</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">procresizetime</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">procresizetime</span> <span class="p">=</span> <span class="nx">now</span>

    <span class="c1">// Grow allp if necessary.
</span><span class="c1"></span>	<span class="c1">//如果allp的长度不够,allp上锁,调整allp的长度,去余补缺即可
</span><span class="c1"></span>	<span class="c1">//如果新值比全局P列表的长度大，则增长全局P列表切片（allp）。如果容量够就扩容，如果容量不够就新建一个新的切片，并把全局P列表中的P都拷贝到新切片中。
</span><span class="c1"></span>	<span class="c1">// 必要时增加 allp
</span><span class="c1"></span>	<span class="c1">// 这个时候本质上是在检查用户代码是否有调用过 runtime.MAXGOPROCS 调整 p 的数量
</span><span class="c1"></span>	<span class="c1">// 此处多一步检查是为了避免内部的锁，如果 nprocs 明显小于 allp 的可见数量（因为 len）
</span><span class="c1"></span>	<span class="c1">// 则不需要进行加锁
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">nprocs</span> <span class="p">&gt;</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">allp</span><span class="p">))</span> <span class="p">{</span>
		<span class="c1">// Synchronize with retake, which could be running
</span><span class="c1"></span>		<span class="c1">// concurrently since it doesn&#39;t run on a P.
</span><span class="c1"></span>		<span class="c1">// 此处与 retake 同步，它可以同时运行，因为它不会在 P 上运行。
</span><span class="c1"></span>		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">nprocs</span> <span class="o">&lt;=</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">allp</span><span class="p">))</span> <span class="p">{</span>
			<span class="c1">// 如果 nprocs 被调小了，扔掉多余的 p
</span><span class="c1"></span>			<span class="nx">allp</span> <span class="p">=</span> <span class="nx">allp</span><span class="p">[:</span><span class="nx">nprocs</span><span class="p">]</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 否则（调大了）创建更多的 p
</span><span class="c1"></span>			<span class="nx">nallp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">nprocs</span><span class="p">)</span>
			<span class="c1">// Copy everything up to allp&#39;s cap so we
</span><span class="c1"></span>			<span class="c1">// never lose old allocated Ps.
</span><span class="c1"></span>			<span class="c1">// 将原有的 p 复制到新创建的 new all p 中，不浪费旧的 p
</span><span class="c1"></span>			<span class="nb">copy</span><span class="p">(</span><span class="nx">nallp</span><span class="p">,</span> <span class="nx">allp</span><span class="p">[:</span><span class="nb">cap</span><span class="p">(</span><span class="nx">allp</span><span class="p">)])</span>
			<span class="nx">allp</span> <span class="p">=</span> <span class="nx">nallp</span>
		<span class="p">}</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// initialize new P&#39;s
</span><span class="c1"></span>	<span class="c1">// 初始化新的 P
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">old</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">nprocs</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">pp</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="c1">//申请新P对象
</span><span class="c1"></span>		<span class="c1">// 如果 p 是新创建的(新创建的 p 在数组中为 nil)，则申请新的 P 对象
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">pp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">pp</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">pp</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
		<span class="nf">atomicstorep</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">pp</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="c1">//经过一番清理之后，执行procresize函数的M的P也可能已经被清理掉了，所以如果侥幸这个P没有被清理掉就把P还给当前M，如果不幸已经被清理了就把全局P列表（allp）中的第一个P给它。
</span><span class="c1"></span>	<span class="c1">// 获取当前正在运行的 g 指针，初始化时 _g_ = g0
</span><span class="c1"></span>    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
    <span class="c1">//如果当前正在用的P属于被释放的那拨,那就换成allp[0]
</span><span class="c1"></span>    <span class="c1">//调度器初始化阶段,根本没有P,那就绑定allp[0]
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">id</span> <span class="p">&lt;</span> <span class="nx">nprocs</span> <span class="p">{</span>
        <span class="c1">// continue to use the current P
</span><span class="c1"></span>        <span class="c1">//继续使用当前P
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Prunning</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">mcache</span><span class="p">.</span><span class="nf">prepareForSweep</span><span class="p">()</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 初始化时执行这个分支
</span><span class="c1"></span>        <span class="c1">// release the current P and acquire allp[0]
</span><span class="c1"></span>        <span class="c1">//释放当前P,因为它已经失效
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span> <span class="p">=</span> <span class="kc">nil</span>
        <span class="c1">//换成allp[0]
</span><span class="c1"></span>		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pidle</span>
		<span class="c1">// 如果是调度器初始化阶段,将 p0 和 m0 关联起来
</span><span class="c1"></span>		<span class="nf">acquirep</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
			<span class="nf">traceGoStart</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// free unused P&#39;s
</span><span class="c1"></span>	<span class="c1">// 释放多余的 P。由于减少了旧的 procs 的数量，因此需要释放
</span><span class="c1"></span>	<span class="c1">// 假设旧值为J，程序还会对全局P列表中第I+1到第J个P（如果有的话）进行清理。
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">nprocs</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">old</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">p</span><span class="p">.</span><span class="nf">destroy</span><span class="p">()</span>
		<span class="c1">// can&#39;t free P itself because it can be referenced by an M in syscall
</span><span class="c1"></span>		<span class="c1">// 不能释放 p 本身，因为他可能在 m 进入系统调用时被引用
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="c1">// Trim allp.
</span><span class="c1"></span>	<span class="c1">// 清理完毕后，修剪 allp, nprocs 个数之外的所有 P
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">allp</span><span class="p">))</span> <span class="o">!=</span> <span class="nx">nprocs</span> <span class="p">{</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
		<span class="nx">allp</span> <span class="p">=</span> <span class="nx">allp</span><span class="p">[:</span><span class="nx">nprocs</span><span class="p">]</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="c1">//将没有本地任务的P放到空闲链表
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">runnablePs</span> <span class="o">*</span><span class="nx">p</span>
	<span class="c1">//最后，程序再次遍历前I个P，也就是新的全局P列表中的所有P，但是会跳过当前执行procresize函数的M的P。
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">nprocs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
        <span class="nx">p</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="c1">//确保不是当前正在用的P
</span><span class="c1"></span>		<span class="c1">// allp[0] 跟 m0 关联了，不会进行之后的“放入空闲链表”
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">==</span> <span class="nx">p</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// 状态转为 idle
</span><span class="c1"></span>		<span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pidle</span>
		<span class="c1">//如果它的可运行G队列为空，就把它加入调度器的空闲P列表。
</span><span class="c1"></span>		<span class="k">if</span> <span class="nf">runqempty</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//放入空闲链表
</span><span class="c1"></span>			<span class="nf">pidleput</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">//否则尝试拿一个M来与这个P关联，成不成功不管，然后把它放入本地的可运行P列表。
</span><span class="c1"></span>            <span class="c1">//有本地任务,构建链表
</span><span class="c1"></span>			<span class="nx">p</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nf">mget</span><span class="p">())</span>
			<span class="c1">// 第一个循环为 nil，后续则为上一个 p
</span><span class="c1"></span>			<span class="c1">// 此处即为构建可运行的 p 链表
</span><span class="c1"></span>			<span class="nx">p</span><span class="p">.</span><span class="nx">link</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">runnablePs</span><span class="p">)</span>
			<span class="nx">runnablePs</span> <span class="p">=</span> <span class="nx">p</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//函数的最后，初始化了一个“随机分配器”,将来有些 m 去偷工作的时候，会遍历所有的 P，这时为了偷地随机一些，就会用到 stealOrder 来返回一个随机选择的 P
</span><span class="c1"></span>	<span class="nx">stealOrder</span><span class="p">.</span><span class="nf">reset</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">nprocs</span><span class="p">))</span>
	<span class="kd">var</span> <span class="nx">int32p</span> <span class="o">*</span><span class="kt">int32</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">gomaxprocs</span> <span class="c1">// make compiler check that gomaxprocs is an int32
</span><span class="c1"></span>    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">((</span><span class="o">*</span><span class="kt">uint32</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">int32p</span><span class="p">)),</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">nprocs</span><span class="p">))</span>
	<span class="c1">//函数最后会将这个拥有可运行G的P列表作为结果返回给调用者。
</span><span class="c1"></span>	<span class="c1">//返回有本地任务的P(链表)
</span><span class="c1"></span>	<span class="c1">//负责重启调度工作的程序会检查这个列表中的P，以保证它们一定能与一个M产生关联。随后程序会让与这些P关联的M都运行起来。
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">runnablePs</span>
<span class="p">}</span>

<span class="c1">// init initializes pp, which may be a freshly allocated p or a
</span><span class="c1">// previously destroyed p, and transitions it to status _Pgcstop.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">pp</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="nf">init</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// p 的 id 就是它在 allp 中的索引
</span><span class="c1"></span>	<span class="nx">pp</span><span class="p">.</span><span class="nx">id</span> <span class="p">=</span> <span class="nx">id</span>
	<span class="c1">// 新创建的 p 处于 _Pgcstop 状态
</span><span class="c1"></span>	<span class="nx">pp</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pgcstop</span>
	<span class="nx">pp</span><span class="p">.</span><span class="nx">sudogcache</span> <span class="p">=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">sudogbuf</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span> <span class="p">{</span>
		<span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpoolbuf</span><span class="p">[</span><span class="nx">i</span><span class="p">][:</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nx">pp</span><span class="p">.</span><span class="nx">wbBuf</span><span class="p">.</span><span class="nf">reset</span><span class="p">()</span>
	<span class="c1">//为P分配cache对象
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">mcache</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 如果 old == 0 且 i == 0 说明这是引导阶段初始化第一个 p
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">id</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">mcache0</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;missing mcache?&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// Use the bootstrap mcache0. Only one P will get
</span><span class="c1"></span>			<span class="c1">// mcache0: the one with ID 0.
</span><span class="c1"></span>			<span class="nx">pp</span><span class="p">.</span><span class="nx">mcache</span> <span class="p">=</span> <span class="nx">mcache0</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">//创建cache
</span><span class="c1"></span>			<span class="nx">pp</span><span class="p">.</span><span class="nx">mcache</span> <span class="p">=</span> <span class="nf">allocmcache</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">raceprocctx</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">id</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">pp</span><span class="p">.</span><span class="nx">raceprocctx</span> <span class="p">=</span> <span class="nx">raceprocctx0</span>
			<span class="nx">raceprocctx0</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// bootstrap
</span><span class="c1"></span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">pp</span><span class="p">.</span><span class="nx">raceprocctx</span> <span class="p">=</span> <span class="nf">raceproccreate</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timersLock</span><span class="p">,</span> <span class="nx">lockRankTimers</span><span class="p">)</span>
<span class="p">}</span>


<span class="c1">// destroy releases all of the resources associated with pp and
</span><span class="c1">// transitions it to status _Pdead.
</span><span class="c1">//
</span><span class="c1">// sched.lock must be held and the world must be stopped.
</span><span class="c1">// 释放未使用的 P，一般情况下不会执行这段代码
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">pp</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="nf">destroy</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Move all runnable goroutines to the global queue
</span><span class="c1"></span>	<span class="c1">// 将本地任务转移到全局队列
</span><span class="c1"></span>	<span class="c1">// 将所有 runnable Goroutine 移动至全局队列
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">runqhead</span> <span class="o">!=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">runqtail</span> <span class="p">{</span>
		<span class="c1">// Pop from tail of local queue
</span><span class="c1"></span>		<span class="c1">// 从本地队列中 pop
</span><span class="c1"></span>		<span class="nx">pp</span><span class="p">.</span><span class="nx">runqtail</span><span class="o">--</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">runq</span><span class="p">[</span><span class="nx">pp</span><span class="p">.</span><span class="nx">runqtail</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">ptr</span><span class="p">()</span>
		<span class="c1">// Push onto head of global queue
</span><span class="c1"></span>		<span class="c1">//首先要把P的可运行G队列中的G放入调度器可运行G队列的头部。
</span><span class="c1"></span>		<span class="nf">globrunqputhead</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">//其次将P的runnaex字段中的G（如果有的话）放入调度器的可运行G队列的头部。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">runnext</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">//将gp加入调度器可运行G队列头部
</span><span class="c1"></span>		<span class="nf">globrunqputhead</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">runnext</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
		<span class="nx">pp</span><span class="p">.</span><span class="nx">runnext</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">plocal</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
		<span class="c1">// The world is stopped, but we acquire timersLock to
</span><span class="c1"></span>		<span class="c1">// protect against sysmon calling timeSleepUntil.
</span><span class="c1"></span>		<span class="c1">// This is the only case where we hold the timersLock of
</span><span class="c1"></span>		<span class="c1">// more than one P, so there are no deadlock concerns.
</span><span class="c1"></span>		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">plocal</span><span class="p">.</span><span class="nx">timersLock</span><span class="p">)</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timersLock</span><span class="p">)</span>
		<span class="nf">moveTimers</span><span class="p">(</span><span class="nx">plocal</span><span class="p">,</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">)</span>
		<span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">pp</span><span class="p">.</span><span class="nx">numTimers</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">pp</span><span class="p">.</span><span class="nx">adjustTimers</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">pp</span><span class="p">.</span><span class="nx">deletedTimers</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timer0When</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timersLock</span><span class="p">)</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">plocal</span><span class="p">.</span><span class="nx">timersLock</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// If there&#39;s a background worker, make it runnable and put
</span><span class="c1"></span>	<span class="c1">// it on the global queue so it can clean itself up.
</span><span class="c1"></span>	<span class="c1">//然后是将P持有的GC标记专用G从Gwaiting状态转到Grunnable状态并放入调度器的可运行G队列末尾。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">ptr</span><span class="p">();</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
			<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">//将gp加入调度器可运行G队列尾部
</span><span class="c1"></span>		<span class="nf">globrunqput</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
		<span class="c1">// This assignment doesn&#39;t race because the
</span><span class="c1"></span>		<span class="c1">// world is stopped.
</span><span class="c1"></span>		<span class="nx">pp</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// Flush p&#39;s write barrier buffer.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="p">{</span>
		<span class="nf">wbBufFlush1</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
		<span class="nx">pp</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">dispose</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">sudogbuf</span> <span class="p">{</span>
		<span class="nx">pp</span><span class="p">.</span><span class="nx">sudogbuf</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">pp</span><span class="p">.</span><span class="nx">sudogcache</span> <span class="p">=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">sudogbuf</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpoolbuf</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">pp</span><span class="p">.</span><span class="nx">deferpoolbuf</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpoolbuf</span><span class="p">[</span><span class="nx">i</span><span class="p">][:</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">mspancache</span><span class="p">.</span><span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// Safe to call since the world is stopped.
</span><span class="c1"></span>			<span class="nx">mheap_</span><span class="p">.</span><span class="nx">spanalloc</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">mspancache</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span>
		<span class="p">}</span>
		<span class="nx">pp</span><span class="p">.</span><span class="nx">mspancache</span><span class="p">.</span><span class="nx">len</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">pp</span><span class="p">.</span><span class="nx">pcache</span><span class="p">.</span><span class="nf">flush</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">pages</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="c1">//释放当前P绑定的cache
</span><span class="c1"></span>	<span class="nf">freemcache</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">mcache</span><span class="p">)</span>
	<span class="nx">pp</span><span class="p">.</span><span class="nx">mcache</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="c1">//将当前P的G复用链转移到全局
</span><span class="c1"></span>	<span class="c1">//还需要调用gfpurge函数将P的自由G列表的所有G都转移到调度器的自由G列表中。
</span><span class="c1"></span>	<span class="c1">//将P的自由G列表的所有G都转移到调度器的自由G列表
</span><span class="c1"></span>	<span class="nf">gfpurge</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
	<span class="nf">traceProcFree</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">timerRaceCtx</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// The race detector code uses a callback to fetch
</span><span class="c1"></span>			<span class="c1">// the proc context, so arrange for that callback
</span><span class="c1"></span>			<span class="c1">// to see the right thing.
</span><span class="c1"></span>			<span class="c1">// This hack only works because we are the only
</span><span class="c1"></span>			<span class="c1">// thread running.
</span><span class="c1"></span>			<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span>
			<span class="nx">phold</span> <span class="o">:=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
			<span class="nx">mp</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>

			<span class="nf">racectxend</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timerRaceCtx</span><span class="p">)</span>
			<span class="nx">pp</span><span class="p">.</span><span class="nx">timerRaceCtx</span> <span class="p">=</span> <span class="mi">0</span>

			<span class="nx">mp</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">phold</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">raceprocdestroy</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">raceprocctx</span><span class="p">)</span>
		<span class="nx">pp</span><span class="p">.</span><span class="nx">raceprocctx</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">pp</span><span class="p">.</span><span class="nx">gcAssistTime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">//最后将P设置为Pdead状态，以便之后进行销毁。之所以不能在这里立即销毁，是因为它们可能被正在进行系统调用的M引用，如果现在就销毁，就会在那些M完成系统调用时造成错误。
</span><span class="c1"></span>	<span class="nx">pp</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pdead</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>这样，整个 procresize 函数就讲完了，这也意味着，调度器的初始化工作已经完成了。</p>
<ol>
<li>使用 make([]p, nprocs) 初始化全局变量 allp，即 allp = make([]p, nprocs)</li>
<li>循环创建并初始化 nprocs 个 p 结构体对象并依次保存在 allp 切片之中</li>
<li>把 m0 和 allp[0] 绑定在一起，即 m0.p = allp[0]，allp[0].m = m0</li>
<li>把除了 allp[0] 之外的所有 p 放入到全局变量 sched 的 pidle 空闲队列之中</li>
</ol>
<p>说明一下，最后一步，代码里是将所有空闲的 P 放入到调度器的全局空闲队列；对于非空闲的 P（本地队列里有 G 待执行），则是生成一个 P 链表，返回给 procresize 函数的调用者。</p>
<p>最后我们将 allp 和 allm 都添加到图上：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201116192844.png" alt=""></p>
<h4 id="acquirep">acquirep</h4>
<p>用 acquirep(<em>p</em>) 绑定获取到的 p 和 m，主要的动作就是设置 p 的 m 字段，更改 p 的工作状态为 _Prunning，并且设置 m 的 p 字段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Associate p and the current m.
</span><span class="c1">//
</span><span class="c1">// This function is allowed to have write barriers even if the caller
</span><span class="c1">// isn&#39;t because it immediately acquires _p_.
</span><span class="c1">//
</span><span class="c1">//go:yeswritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Do the part that isn&#39;t allowed to have write barriers.
</span><span class="c1"></span>	<span class="nf">wirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>

	<span class="c1">// Have p; write barriers now allowed.
</span><span class="c1"></span>
	<span class="c1">// Perform deferred mcache flush before this P can allocate
</span><span class="c1"></span>	<span class="c1">// from a potentially stale mcache.
</span><span class="c1"></span>	<span class="nx">_p_</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nf">prepareForSweep</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceProcStart</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>先调用 wirep 函数真正地进行关联，之后，将 p0 的 mcache 资源赋给 m0。再来看 wirep:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// wirep is the first step of acquirep, which actually associates the
</span><span class="c1">// current M to _p_. This is broken out so we can disallow write
</span><span class="c1">// barriers for this part, since we don&#39;t yet have a P.
</span><span class="c1">//
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">wirep</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;wirep: already in go&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Pidle</span> <span class="p">{</span>
		<span class="nx">id</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">id</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">id</span>
		<span class="p">}</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;wirep: p-&gt;m=&#34;</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="s">&#34;(&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="s">&#34;) p-&gt;status=&#34;</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;wirep: invalid p state&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Prunning</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>可以看到就是一些字段相互设置，执行完成后：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">g0</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="p">=</span> <span class="nx">p0</span>
<span class="nx">p0</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nx">m0</span>
</code></pre></td></tr></table>
</div>
</div><p>并且，p0 的状态变成了 _Prunning。</p>
<h4 id="runqempty">runqempty</h4>
<p>函数 runqempty 用来判断一个 P 是否是空闲，依据是 P 的本地 run queue 队列里有没有 runnable 的 G，如果没有，那 P 就是空闲的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// runqempty reports whether _p_ has no Gs on its local run queue.
</span><span class="c1">// It never returns true spuriously.
</span><span class="c1">// 如果 _p_ 的本地队列里没有待运行的 G，则返回 true
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// Defend against a race where 1) _p_ has G1 in runqnext but runqhead == runqtail,
</span><span class="c1"></span>	<span class="c1">// 2) runqput on _p_ kicks G1 to the runq, 3) runqget on _p_ empties runqnext.
</span><span class="c1"></span>	<span class="c1">// Simply observing that runqhead == runqtail and then observing that runqnext == nil
</span><span class="c1"></span>	<span class="c1">// does not mean the queue is empty.
</span><span class="c1"></span>	<span class="c1">// 这里涉及到一些数据竞争，并不是简单地判断 runqhead == runqtail 并且 runqnext == nil 就可以
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">head</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span>
		<span class="nx">tail</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">)</span>
		<span class="nx">runnext</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Loaduintptr</span><span class="p">((</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">)))</span>
		<span class="k">if</span> <span class="nx">tail</span> <span class="o">==</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">head</span> <span class="o">==</span> <span class="nx">tail</span> <span class="o">&amp;&amp;</span> <span class="nx">runnext</span> <span class="o">==</span> <span class="mi">0</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>并不是简单地判断 head == tail 并且 runnext == nil 为真，就可以说明 runq 是空的。因为涉及到一些数据竞争，例如在比较 head == tail 时为真，但此时 runnext 上其实有一个 G，之后再去比较 runnext == nil 的时候，这个 G 又通过 runqput跑到了 runq 里去了或者通过 runqget 拿走了，runnext 也为真，于是函数就判断这个 P 是空闲的，这就会形成误判。</p>
<p>因此 runqempty 函数先是通过原子操作取出了 head，tail，runnext，然后再次确认 tail 没有发生变化，最后再比较 head == tail 以及 runnext == nil，保证了在观察三者都是在“同时”观察到的，因此，返回的结果就是正确的。</p>
<p>说明一下，runnext 上有时会绑定一个 G，这个 G 是被当前 G 唤醒的，相比其他 G 有更高的执行优先级，因此把它单独拿出来。</p>
<h4 id="pidleput">pidleput</h4>
<p>将P放入全局空闲 P 列表：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Put p to on _Pidle list.
</span><span class="c1">// Sched must be locked.
</span><span class="c1">// May run during STW, so write barriers are not allowed.
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1">// 将 p 放到 _Pidle 列表里
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">pidleput</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;pidleput: P has non-empty run queue&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">pidle</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">pidle</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="c1">// 增加全局空闲 P 的数量
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// TODO: fast atomic
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>构造链表的过程其实比较简单，先将 p.link 指向原来的 sched.pidle 所指向的 p，也就是原空闲链表的最后一个 P，最后，再更新 sched.pidle，使其指向当前 p，这样，新的链表就构造完成。</p>
<h4 id="pidleget">pidleget</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Try get a p from _Pidle list.
</span><span class="c1">// Sched must be locked.
</span><span class="c1">// May run during STW, so write barriers are not allowed.
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1">// 试图从 _Pidle 列表里获取 p
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">pidleget</span><span class="p">()</span> <span class="o">*</span><span class="nx">p</span> <span class="p">{</span>
	<span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">pidle</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">sched</span><span class="p">.</span><span class="nx">pidle</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">link</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// TODO: fast atomic
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">_p_</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>比较简单，获取链表最后一个，再更新 sched.pidle，使其指向前一个 P。</p>
<h4 id="releasep">releasep</h4>
<p>解除当前工作线程和当前 P 的绑定关系：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Disassociate p and the current m.
</span><span class="c1">// 解除 p 与 m 的关联
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">releasep</span><span class="p">()</span> <span class="o">*</span><span class="nx">p</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;releasep: invalid arg&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="o">||</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Prunning</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;releasep: m=&#34;</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="s">&#34; m-&gt;p=&#34;</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="s">&#34; p-&gt;m=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">),</span> <span class="s">&#34; p-&gt;status=&#34;</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;releasep: invalid p state&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceProcStop</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pidle</span>
	<span class="k">return</span> <span class="nx">_p_</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>主要的工作就是将 p 的 m 字段清空，并将 p 的状态修改为 _Pidle。</p>
<h4 id="handoffp">handoffp</h4>
<p>handoffp函数实现抢占p的功能.</p>
<p>当 p 的本地运行队列或全局运行队列里面有待运行的 goroutine，说明还有很多工作要做，调用 startm(<em>p</em>, false) 启动一个 m 来结合 p，继续工作。</p>
<p>当除了当前的 p 外，其他所有的 p 都在运行 goroutine，说明天下太平，每个人都有自己的事做，唯独自己没有。为了全局更快地完成工作，需要启动一个 m，且要使得 m 处于自旋状态，和 p 结合之后，尽快找到工作。</p>
<p>最后，如果实在没有工作要处理，就将 p 放入全局空闲队列里。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Hands off P from syscall or locked M.
</span><span class="c1">// Always runs without a P, so write barriers are not allowed.
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">handoffp</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// handoffp must start an M in any situation where
</span><span class="c1"></span>	<span class="c1">// findrunnable would return a G to run on _p_.
</span><span class="c1"></span>
	<span class="c1">// if it has local work, start it straight away
</span><span class="c1"></span>	<span class="c1">//如果P本地或全局有任务,直接唤醒某个M开始工作
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="o">||</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">startm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// if it has GC work, start it straight away
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">startm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// no local work, check that there are no spinning/idle M&#39;s,
</span><span class="c1"></span>	<span class="c1">// otherwise our help is not required
</span><span class="c1"></span>	<span class="c1">// 所有其它 p 都在运行 goroutine，说明系统比较忙，需要启动 m
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span><span class="o">+</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// TODO: fast atomic
</span><span class="c1"></span>		<span class="nf">startm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pgcstop</span>
		<span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span><span class="o">--</span>
		<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">stopnote</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runSafePointFn</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runSafePointFn</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">sched</span><span class="p">.</span><span class="nf">safePointFn</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
		<span class="nx">sched</span><span class="p">.</span><span class="nx">safePointWait</span><span class="o">--</span>
		<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">safePointWait</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">safePointNote</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 全局队列有工作
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nf">startm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// If this is the last running P and nobody is polling network,
</span><span class="c1"></span>	<span class="c1">// need to wakeup another M to poll network.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span> <span class="o">==</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nf">startm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 没有工作要处理，把 p 放入全局空闲队列
</span><span class="c1"></span>	<span class="nf">pidleput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="创建g">创建G</h3>
<p>创建 G 的过程也是相对比较复杂的，我们来总结一下这个过程：</p>
<ol>
<li>首先尝试从 P 本地 gfree 链表或全局 gfree 队列获取已经执行过的 g</li>
<li>初始化过程中程序无论是本地队列还是全局队列都不可能获取到 g，因此创建一个新的 g，并为其分配运行线程（执行栈），这时 g 处于 _Gidle 状态</li>
<li>创建完成后，g 被更改为 _Gdead 状态，并根据要执行函数的入口地址和参数，初始化执行栈的 SP 和参数的入栈位置，并将需要的参数拷贝一份存入执行栈中</li>
<li>根据 SP、参数，在 g.sched 中保存 SP 和 PC 指针来初始化 g 的运行现场</li>
<li>将调用方、要执行的函数的入口 PC 进行保存，并将 g 的状态更改为 _Grunnable</li>
<li>给 Goroutine 分配 id，并将其放入 P 本地队列的队头或全局队列（初始化阶段队列肯定不是满的，因此不可能放入全局队列）</li>
<li>检查空闲的 P，将其唤醒，准备执行 G，但我们目前处于初始化阶段，主 Goroutine 尚未开始执行，因此这里不会唤醒 P。</li>
</ol>
<p>值得一提的是，newproc 是由 go:nosplit 修饰的函数， 因此这个函数在执行过程中不会发生扩张和抢占，这个函数中的每一行代码都是深思熟虑过、确保能够在有限的栈空间内 完成执行。</p>
<h4 id="newproc">newproc</h4>
<p>编译器会将所有的 go 关键字被转换成 runtime.newproc 函数，该函数会接收大小和表示函数的指针 funcval。在这个函数中我们还会获取 Goroutine 以及调用方的程序计数器，然后调用 runtime.newproc1 函数</p>
<p>newproc 函数需要两个参数：一个是新创建的 goroutine 需要执行的任务，也就是 fn，它代表一个函数 func；还有一个是 fn 的参数大小。</p>
<p>可能会感到奇怪，为什么要给 newproc 传一个表示 fn 的参数大小的参数呢？</p>
<p>我们知道，goroutine 和线程一样，都有自己的栈，不同的是 goroutine 的初始栈比较小，只有 2K，而且是可伸缩的，这也是创建 goroutine 的代价比创建线程代价小的原因。</p>
<p>换句话说，每个 goroutine 都有自己的栈空间，newproc 函数会新创建一个新的 goroutine 来执行 fn 函数，在新 goroutine 上执行指令，就要用新 goroutine 的栈。而执行函数需要参数，这个参数又是在老的 goroutine 上，所以需要将其拷贝到新 goroutine 的栈上。拷贝的起始位置就是栈顶，这好办，那拷贝多少数据呢？由 siz 来确定。</p>
<p>继续看代码，newproc 函数的第二个参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">funcval</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">fn</span> <span class="kt">uintptr</span>
	<span class="c1">// variable-size, fn-specific data here
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>有一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">hello</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">println</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nf">hello</span><span class="p">(</span><span class="s">&#34;hello world&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>栈布局是这样的：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201116220554.png" alt=""></p>
<p>栈顶是 siz，再往上是函数的地址，再往上就是传给 hello 函数的参数，string 在这里是一个地址。因此前面代码里先 push 参数的地址，再 push 参数大小。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Create a new g running fn with siz bytes of arguments.
</span><span class="c1">// Put it on the queue of g&#39;s waiting to run.
</span><span class="c1">// The compiler turns a go statement into a call to this.
</span><span class="c1">// Cannot split the stack because it assumes that the arguments
</span><span class="c1">// are available sequentially after &amp;fn; they would not be
</span><span class="c1">// copied if a stack split occurred.
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newproc</span><span class="p">(</span><span class="nx">siz</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//获取第一参数地址
</span><span class="c1"></span>	<span class="c1">//argp 跳过 fn，向上跳一个指针的长度，拿到 fn 参数的地址。
</span><span class="c1"></span>	<span class="nx">argp</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fn</span><span class="p">),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
    <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="c1">// 获取调用者的指令地址，也就是调用 newproc 时由 call 指令压栈的函数返回地址
</span><span class="c1"></span>	<span class="c1">//通过 getcallerpc 获取调用者的指令地址，也就是调用 newproc 时由 call 指令压栈的函数返回地址，也就是 runtime·rt0_go 函数里 CALL runtime·newproc(SB) 指令后面的 POPQ AX 这条指令的地址。
</span><span class="c1"></span>    <span class="nx">pc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
    <span class="c1">// systemstack 的作用是切换到 g0 栈执行作为参数的函数
</span><span class="c1"></span>    <span class="c1">// 用 g0 系统栈创建 goroutine 对象
</span><span class="c1"></span>	<span class="c1">// 传递的参数包括 fn 函数入口地址，argp 参数起始地址，siz 参数长度，调用方 pc（goroutine)
</span><span class="c1"></span>	<span class="c1">//调用 systemstack 函数在 g0 栈执行 fn 函数。如果是初始化过程中，由 runtime·rt0_go 函数调用，本身是在 g0 栈执行，因此会直接执行 fn 函数。而如果是我们在程序中写的 go xxx 代码，在执行时，就会先切换到 g0 栈执行，然后再切回来。
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">newproc1</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="kt">uint8</span><span class="p">)(</span><span class="nx">argp</span><span class="p">),</span> <span class="nx">siz</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
	<span class="p">})</span>
<span class="p">}</span>

<span class="c1">// Should be a built-in for unsafe.Pointer?
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">x</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="o">+</span> <span class="nx">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// getg returns the pointer to the current g.
</span><span class="c1">// The compiler rewrites calls to this function into instructions
</span><span class="c1">// that fetch the g directly (from TLS or from the dedicated register).
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getg</span><span class="p">()</span> <span class="o">*</span><span class="nx">g</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime.newproc1 会根据传入参数初始化一个 g 结构体，我们可以将该函数分成以下几个部分介绍它的实现：</p>
<ol>
<li>获取或者创建新的 Goroutine 结构体；</li>
<li>将传入的参数移到 Goroutine 的栈上；</li>
<li>更新 Goroutine 调度相关的属性；</li>
<li>将 Goroutine 加入处理器的运行队列；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// mainStarted indicates that the main M has started.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">mainStarted</span> <span class="kt">bool</span>
<span class="c1">// Create a new g running fn with narg bytes of arguments starting
</span><span class="c1">// at argp. callerpc is the address of the go statement that created
</span><span class="c1">// this. The new g is put on the queue of g&#39;s waiting to run.
</span><span class="c1">// 创建一个运行 fn 的新 g，具有 narg 字节大小的参数，从 argp 开始。
</span><span class="c1">// callerps 是 go 语句的起始地址。新创建的 g 会被放入 g 的队列中等待运行。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newproc1</span><span class="p">(</span><span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">,</span> <span class="nx">argp</span> <span class="o">*</span><span class="kt">uint8</span><span class="p">,</span> <span class="nx">narg</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">callergp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/*
</span><span class="cm">	首先是 Goroutine 结构体的创建过程
</span><span class="cm">	*/</span>
	<span class="c1">// 当前 goroutine 的指针
</span><span class="c1"></span>    <span class="c1">// 因为已经切换到 g0 栈，所以无论什么场景都是 _g_ = g0
</span><span class="c1"></span>    <span class="c1">// g0 是指当前工作线程的 g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">fn</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">throwing</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">// do not dump full stacks
</span><span class="c1"></span>		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;go of nil func value&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 禁止这时 g 的 m 被抢占因为它可以在一个局部变量中保存 p
</span><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span> <span class="c1">// disable preemption because it can be holding p in a local var
</span><span class="c1"></span>	<span class="c1">//&#34;参数+返回值&#34;所需空间(对齐)
</span><span class="c1"></span>	<span class="c1">// 参数加返回值所需要的空间（经过内存对齐）
</span><span class="c1"></span>	<span class="nx">siz</span> <span class="o">:=</span> <span class="nx">narg</span>
	<span class="nx">siz</span> <span class="p">=</span> <span class="p">(</span><span class="nx">siz</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="mi">7</span>

	<span class="c1">// We could allocate a larger initial stack if necessary.
</span><span class="c1"></span>	<span class="c1">// Not worth it: this is almost always an error.
</span><span class="c1"></span>	<span class="c1">// 4*sizeof(uintreg): extra space added below
</span><span class="c1"></span>	<span class="c1">// sizeof(uintreg): caller&#39;s LR (arm) or return address (x86, in gostartcall).
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">siz</span> <span class="o">&gt;=</span> <span class="nx">_StackMin</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">RegSize</span><span class="o">-</span><span class="nx">sys</span><span class="p">.</span><span class="nx">RegSize</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;newproc: function arguments too large for new goroutine&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">//从当前P复用链表获取空闲的G对象
</span><span class="c1"></span>	<span class="c1">// 当前工作线程所绑定的 p
</span><span class="c1"></span>    <span class="c1">// 初始化时 _p_ = g0.m.p，也就是 _p_ = allp[0]
</span><span class="c1"></span>	<span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="c1">// 从 p 的本地缓冲里获取一个没有使用的 g
</span><span class="c1"></span>	<span class="c1">//初始化时为空，返回 nil
</span><span class="c1"></span>    <span class="nx">newg</span> <span class="o">:=</span> <span class="nf">gfget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="c1">// 初始化阶段，gfget 是不可能找到 g 的
</span><span class="c1"></span>	<span class="c1">// 也可能运行中本来就已经耗尽了
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">newg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// new 一个 g 结构体对象，然后从堆上为其分配栈，并设置 g 的 stack 成员和两个 stackgard 成员
</span><span class="c1"></span>		<span class="c1">// 创建一个拥有 _StackMin 大小的栈的 g
</span><span class="c1"></span>		<span class="nx">newg</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="nx">_StackMin</span><span class="p">)</span>
		<span class="c1">// 初始化 g 的状态为 _Gdead
</span><span class="c1"></span>		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">_Gidle</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">)</span>
		<span class="c1">// 放入全局变量 allgs 切片中
</span><span class="c1"></span>		<span class="c1">// 将 Gdead 状态的 g 添加到 allg，这样 GC 不会扫描未初始化的栈
</span><span class="c1"></span>		<span class="nf">allgadd</span><span class="p">(</span><span class="nx">newg</span><span class="p">)</span> <span class="c1">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#39;t look at uninitialized stack.
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="cm">/*
</span><span class="cm">	上述代码会先从处理器的 gFree 列表中查找空闲的 Goroutine，如果不存在空闲的 Goroutine，就会通过 runtime.malg 函数创建一个栈大小足够的新结构体。
</span><span class="cm">	*/</span>
    <span class="c1">//测试 G stack
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;newproc1: newg missing stack&#34;</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="c1">//测试G status
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">_Gdead</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;newproc1: new g is not Gdead&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="cm">/*
</span><span class="cm">	接下来，我们会调用 runtime.memmove 函数将 fn 函数的全部参数拷贝到栈上，argp 和 narg 分别是参数的内存空间和大小，我们在该方法中会直接将所有参数对应的内存空间整片的拷贝到栈上：
</span><span class="cm">	*/</span>
    <span class="c1">//计算所需空间大小,并对齐
</span><span class="c1"></span>	<span class="nx">totalSize</span> <span class="o">:=</span> <span class="mi">4</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">RegSize</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">)</span> <span class="o">+</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">MinFrameSize</span> <span class="c1">// extra space in case of reads slightly beyond frame
</span><span class="c1"></span>    <span class="nx">totalSize</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">totalSize</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">SpAlign</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>                  <span class="c1">// align to spAlign
</span><span class="c1"></span>    <span class="c1">//确定SP位置
</span><span class="c1"></span>	<span class="nx">sp</span> <span class="o">:=</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">totalSize</span>
	<span class="c1">// 确定参数入栈位置
</span><span class="c1"></span>	<span class="nx">spArg</span> <span class="o">:=</span> <span class="nx">sp</span>
	<span class="k">if</span> <span class="nx">usesLR</span> <span class="p">{</span>
		<span class="c1">// caller&#39;s LR
</span><span class="c1"></span>		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nf">prepGoExitFrame</span><span class="p">(</span><span class="nx">sp</span><span class="p">)</span>
		<span class="nx">spArg</span> <span class="o">+=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">MinFrameSize</span>
	<span class="p">}</span>
	<span class="c1">// 处理参数，当有参数时，将参数拷贝到 Goroutine 的执行栈中
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">narg</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 从 argp 参数开始的位置，复制 narg 个字节到 spArg（参数拷贝）
</span><span class="c1"></span>		<span class="nf">memmove</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">spArg</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">argp</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">narg</span><span class="p">))</span>
		<span class="c1">// This is a stack-to-stack copy. If write barriers
</span><span class="c1"></span>		<span class="c1">// are enabled and the source stack is grey (the
</span><span class="c1"></span>		<span class="c1">// destination is always black), then perform a
</span><span class="c1"></span>		<span class="c1">// barrier copy. We do this *after* the memmove
</span><span class="c1"></span>		<span class="c1">// because the destination stack may have garbage on
</span><span class="c1"></span>		<span class="c1">// it.
</span><span class="c1"></span>		<span class="c1">// 栈到栈的拷贝。
</span><span class="c1"></span>		<span class="c1">// 如果启用了 write barrier 并且 源栈为灰色（目标始终为黑色），
</span><span class="c1"></span>		<span class="c1">// 则执行 barrier 拷贝。
</span><span class="c1"></span>		<span class="c1">// 因为目标栈上可能有垃圾，我们在 memmove 之后执行此操作。
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">needed</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span><span class="p">.</span><span class="nx">gcscandone</span> <span class="p">{</span>
			<span class="nx">f</span> <span class="o">:=</span> <span class="nf">findfunc</span><span class="p">(</span><span class="nx">fn</span><span class="p">.</span><span class="nx">fn</span><span class="p">)</span>
			<span class="nx">stkmap</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">stackmap</span><span class="p">)(</span><span class="nf">funcdata</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">_FUNCDATA_ArgsPointerMaps</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">stkmap</span><span class="p">.</span><span class="nx">nbit</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// We&#39;re in the prologue, so it&#39;s always stack map index 0.
</span><span class="c1"></span>				<span class="c1">// 我们正位于序言部分，因此栈 map 索引总是 0
</span><span class="c1"></span>				<span class="nx">bv</span> <span class="o">:=</span> <span class="nf">stackmapdata</span><span class="p">(</span><span class="nx">stkmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
				<span class="nf">bulkBarrierBitmap</span><span class="p">(</span><span class="nx">spArg</span><span class="p">,</span> <span class="nx">spArg</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">bv</span><span class="p">.</span><span class="nx">n</span><span class="p">)</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">bv</span><span class="p">.</span><span class="nx">bytedata</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*
</span><span class="cm">	拷贝了栈上的参数之后，runtime.newproc1 会设置新的 Goroutine 结构体的参数，包括栈指针、程序计数器并更新其状态到 _Grunnable：
</span><span class="cm">	*/</span>
	<span class="c1">//初始化用于保存执行现场的区域
</span><span class="c1"></span>	<span class="c1">// 把 newg.sched 结构体成员的所有成员设置为 0
</span><span class="c1"></span>	<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">))</span>
	<span class="c1">// 设置 newg 的 sched 成员，调度器需要依靠这些字段才能把 goroutine 调度到 CPU 上运行
</span><span class="c1"></span>	<span class="c1">//设置 sched 的 sp 字段，当 goroutine 被调度到 m 上运行时，需要通过 sp 字段来指示栈顶的位置，这里设置的就是新栈的栈顶位置。
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>
	<span class="nx">newg</span><span class="p">.</span><span class="nx">stktopsp</span> <span class="p">=</span> <span class="nx">sp</span>
	<span class="c1">//此处保存的是goexit地址
</span><span class="c1"></span>	<span class="c1">// newg.sched.pc 表示当 newg 被调度起来运行时从这个地址开始执行指令
</span><span class="c1"></span>	<span class="c1">//设置 pc 字段为函数 goexit 的地址加 1，也说是 goexit 函数的第二条指令，goexit 函数是 goroutine 退出后的一些清理工作。
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">goexit</span><span class="p">)</span> <span class="o">+</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PCQuantum</span> <span class="c1">// +PCQuantum so that previous instruction is in same function
</span><span class="c1"></span>	<span class="c1">//设置 g 字段为 newg 的地址。
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newg</span><span class="p">))</span>
	<span class="c1">//此处的调用是关键,调整sched成员和newg的栈
</span><span class="c1"></span>    <span class="nf">gostartcallfn</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span>
    <span class="c1">// 初始化 g 的基本状态
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">gopc</span> <span class="p">=</span> <span class="nx">callerpc</span>
	<span class="nx">newg</span><span class="p">.</span><span class="nx">ancestors</span> <span class="p">=</span> <span class="nf">saveAncestors</span><span class="p">(</span><span class="nx">callergp</span><span class="p">)</span>	<span class="c1">// 调试相关，追踪调用方
</span><span class="c1"></span>	<span class="c1">// 设置 newg 的 startpc 为 fn.fn，该成员主要用于函数调用栈的 traceback 和栈收缩
</span><span class="c1"></span>    <span class="c1">// newg 真正从哪里开始执行并不依赖于这个成员，而是 sched.pc
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">startpc</span> <span class="p">=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">fn</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">newg</span><span class="p">.</span><span class="nx">labels</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span><span class="p">.</span><span class="nx">labels</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nf">isSystemGoroutine</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ngsys</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">newg</span><span class="p">.</span><span class="nx">gcscanvalid</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="c1">// 设置 g 的状态为 _Grunnable，可以运行了
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
    <span class="c1">//设置唯一id
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="o">==</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcacheend</span> <span class="p">{</span>
		<span class="c1">// Sched.goidgen is the last allocated id,
</span><span class="c1"></span>		<span class="c1">// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].
</span><span class="c1"></span>        <span class="c1">// At startup sched.goidgen=0, so main goroutine receives goid=1.
</span><span class="c1"></span>        <span class="c1">//Sched.goidgen是一个全局计数器
</span><span class="c1"></span>		<span class="c1">//每次取回一段有效区间,然后在该区间分配,避免频繁地去全局操作.
</span><span class="c1"></span>		<span class="c1">// Sched.goidgen 为最后一个分配的 id，相当于一个全局计数器
</span><span class="c1"></span>		<span class="c1">// 这一批必须为 [sched.goidgen+1, sched.goidgen+GoidCacheBatch].
</span><span class="c1"></span>		<span class="c1">// 启动时 sched.goidgen=0, 因此主 Goroutine 的 goid 为 1
</span><span class="c1"></span>		<span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">goidgen</span><span class="p">,</span> <span class="nx">_GoidCacheBatch</span><span class="p">)</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="o">-=</span> <span class="nx">_GoidCacheBatch</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcacheend</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="o">+</span> <span class="nx">_GoidCacheBatch</span>
	<span class="p">}</span>
	<span class="c1">// 设置 goid
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">goid</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span><span class="p">)</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span><span class="o">++</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nx">newg</span><span class="p">.</span><span class="nx">racectx</span> <span class="p">=</span> <span class="nf">racegostart</span><span class="p">(</span><span class="nx">callerpc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGoCreate</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">startpc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="cm">/*
</span><span class="cm">	在最后，该函数会将初始化好的 Goroutine 加入处理器的运行队列并在满足条件时调用 runtime.wakep 函数唤醒新的处理执行 Goroutine：
</span><span class="cm">	*/</span>
	<span class="c1">// 将这里新创建的 g 放入 p 的本地队列或直接放入全局队列
</span><span class="c1"></span>	<span class="c1">// true 表示放入执行队列的下一个，false 表示放入队尾
</span><span class="c1"></span>	<span class="nf">runqput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">newg</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
    <span class="c1">//如果有其他空闲P,则尝试唤醒某个M出来执行任务
</span><span class="c1"></span>    <span class="c1">//如果有M处于自旋等待P或G状态,放弃
</span><span class="c1"></span>    <span class="c1">//如果当前创建的是main goroutine(runtime.main),那么还没有其他任务需要执行,放弃
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">mainStarted</span> <span class="p">{</span>
		<span class="nf">wakep</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">{</span> <span class="c1">// restore the preemption request in case we&#39;ve cleared it in newstack
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>newproc1通过两种不同的方式获取新的 runtime.g 结构体：</p>
<ul>
<li>调用runtime.gfget 从 Goroutine 所在处理器的 gFree 列表或者调度器的 sched.gFree 列表中获取 runtime.g 结构体；</li>
<li>调用 runtime.malg 函数生成一个新的 runtime.g 函数并将当前结构体追加到全局的 Goroutine 列表 allgs 中。</li>
</ul>
<h5 id="gostartcallfn">gostartcallfn</h5>
<p>在newproc1创建G任务时,我们在初始化G.sched时,pc保存的是goexit而非fn.关键秘密就是随后调用的gostartcallfn函数.</p>
<p>运行时创建 Goroutine 时会通过下面的代码设置调度相关的信息，前两行代码会分别将程序计数器和 Goroutine 设置成 runtime.goexit 函数和新创建的 Goroutine：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">	<span class="o">...</span>
	<span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">goexit</span><span class="p">)</span> <span class="o">+</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PCQuantum</span>
	<span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newg</span><span class="p">))</span>
	<span class="nf">gostartcallfn</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span>
	<span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div><p>但是这里的调度信息 sched 不是初始化后的 Goroutine 的最终结果，经过 runtime.gostartcallfn 和 runtime.gostartcall 两个函数的处理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// adjust Gobuf as if it executed a call to fn
</span><span class="c1">// and then did an immediate gosave.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gostartcallfn</span><span class="p">(</span><span class="nx">gobuf</span> <span class="o">*</span><span class="nx">gobuf</span><span class="p">,</span> <span class="nx">fv</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">fn</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="k">if</span> <span class="nx">fv</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// fn: gorotine 的入口地址，初始化时对应的是 runtime.main
</span><span class="c1"></span>		<span class="nx">fn</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">fv</span><span class="p">.</span><span class="nx">fn</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">fn</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nf">funcPC</span><span class="p">(</span><span class="nx">nilfunc</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nf">gostartcall</span><span class="p">(</span><span class="nx">gobuf</span><span class="p">,</span> <span class="nx">fn</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">fv</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// adjust Gobuf as if it executed a call to fn with context ctxt
</span><span class="c1">// and then did an immediate gosave.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gostartcall</span><span class="p">(</span><span class="nx">buf</span> <span class="o">*</span><span class="nx">gobuf</span><span class="p">,</span> <span class="nx">fn</span><span class="p">,</span> <span class="nx">ctxt</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// newg 的栈顶，目前 newg 栈上只有 fn 函数的参数，sp 指向的是 fn 的第一参数
</span><span class="c1"></span>	<span class="nx">sp</span> <span class="o">:=</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">sp</span>
	<span class="k">if</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">RegSize</span> <span class="p">&gt;</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="p">{</span>
		<span class="nx">sp</span> <span class="o">-=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="c1">// 为返回地址预留空间
</span><span class="c1"></span>	<span class="nx">sp</span> <span class="o">-=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
	<span class="c1">// 这里填的是 newproc1 函数里设置的 goexit 函数的第二条指令
</span><span class="c1"></span>    <span class="c1">// 伪装 fn 是被 goexit 函数调用的，使得 fn 执行完后返回到 goexit 继续执行，从而完成清理工作
</span><span class="c1"></span>	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span> <span class="p">=</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">pc</span>
	<span class="c1">// 重新设置 buf.sp
</span><span class="c1"></span>	<span class="c1">//然后再次设置sp和pc,此时pc才是G任务函数
</span><span class="c1"></span>	<span class="nx">buf</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>
	<span class="c1">// 当 goroutine 被调度起来执行时，会从这里的 pc 值开始执行，初始化时就是 runtime.main
</span><span class="c1"></span>	<span class="nx">buf</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
	<span class="nx">buf</span><span class="p">.</span><span class="nx">ctxt</span> <span class="p">=</span> <span class="nx">ctxt</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>函数 gostartcallfn 只是拆解出了包含在 funcval 结构体里的函数指针，转过头就调用 gostartcall。将 sp 减小了一个指针的位置，这是给返回地址留空间。果然接着就把 buf.pc 填入了栈顶的位置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span> <span class="p">=</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">pc</span>
</code></pre></td></tr></table>
</div>
</div><p>原来 buf.pc 只是做了一个搬运工。重新设置 buf.sp 为送减掉一个指针位置之后的值，设置 buf.pc 为 fn，指向要执行的函数，这里就是指的 runtime.main 函数。之后，当调度器“光顾”此 goroutine 时，取出 buf.sp 和 buf.pc，恢复 CPU 相应的寄存器，就可以构造出 goroutine 的运行环境。</p>
<p>newg 栈顶位置的内容是一个跳转地址，指向 runtime.goexit 的第二条指令，当 goroutine 退出时，这条地址会载入 CPU 的 PC 寄存器，跳转到这里执行“扫尾”工作。</p>
<h5 id="g的复用">G的复用</h5>
<p>首先,G对象默认会复用.除P本地的复用链表外,还有全局链表在多个P之间共享.</p>
<p>runtime.gfget 中包含两部分逻辑，它会根据处理器中 gFree 列表中 Goroutine 的数量做出不同的决策：</p>
<ul>
<li>当处理器的 Goroutine 列表为空时，会将调度器持有的空闲 Goroutine 转移到当前处理器上，直到 gFree 列表中的 Goroutine 数量达到 32；</li>
<li>当处理器的 Goroutine 数量充足时，会从列表头部返回一个新的 Goroutine；</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Get from gfree list.
</span><span class="c1">// If local list is empty, grab a batch from global list.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gfget</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
<span class="nx">retry</span><span class="p">:</span>
    <span class="c1">//如果本地P队列为空且全局P队列不空,尝试从全局链表中转移一批到P本地
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(!</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="o">||</span> <span class="p">!</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">noStack</span><span class="p">.</span><span class="nf">empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">// Move a batch of free Gs to the P.
</span><span class="c1"></span>        <span class="c1">//最多转移32个
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">32</span> <span class="p">{</span>
			<span class="c1">// Prefer Gs with stacks.
</span><span class="c1"></span>			<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">gp</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">noStack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
				<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">--</span>
			<span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
			<span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span>
		<span class="p">}</span>
        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">//再试
</span><span class="c1"></span>		<span class="k">goto</span> <span class="nx">retry</span>
    <span class="p">}</span>
    <span class="c1">//从P本地队列提取复用对象
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
    <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">--</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">//分配新栈
</span><span class="c1"></span>		<span class="c1">// Stack was deallocated in gfput. Allocate a new one.
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nf">stackalloc</span><span class="p">(</span><span class="nx">_FixedStack</span><span class="p">)</span>
		<span class="p">})</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">racemalloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="o">-</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
			<span class="nf">msanmalloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="o">-</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">gp</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当goroutine执行完毕,调度器相关函数会将G对象放回P复用链表</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Put on gfree list.
</span><span class="c1">// If local list is too long, transfer a batch to the global list.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gfput</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">_Gdead</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gfput: bad status (not Gdead)&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">stksize</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span>
    <span class="c1">//如果栈发生过扩张,则释放
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">stksize</span> <span class="o">!=</span> <span class="nx">_FixedStack</span> <span class="p">{</span>
		<span class="c1">// non-standard stack size - free it.
</span><span class="c1"></span>		<span class="nf">stackfree</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
    <span class="c1">//放回P本地复用链表
</span><span class="c1"></span>	<span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
    <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span>
    <span class="c1">//如果本地复用对象过多,则转移一批到全局链表
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span> <span class="o">&gt;=</span> <span class="mi">64</span> <span class="p">{</span>
        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">//本地保留32个
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span> <span class="o">&gt;=</span> <span class="mi">32</span> <span class="p">{</span>
			<span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">--</span>
			<span class="nx">gp</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">noStack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="g的创建">G的创建</h5>
<p>最初,G对象都是由malg创建的.</p>
<p>当调度器的 gFree 和处理器的 gFree 列表都不存在结构体时，运行时会调用 runtime.malg 初始化一个新的 runtime.g 结构体，如果申请的堆栈大小大于 0，在这里我们会通过 runtime.stackalloc 分配 2KB 的栈空间：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// The minimum size of stack used by Go code
</span><span class="c1"></span><span class="nx">_StackMin</span> <span class="p">=</span> <span class="mi">2048</span>
<span class="c1">// Allocate a new g, with a stack big enough for stacksize bytes.
</span><span class="c1">//给新的g分配足以容纳stacksize 字节的空间,即至少stacksize 个字节
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">malg</span><span class="p">(</span><span class="nx">stacksize</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
	<span class="nx">newg</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">stacksize</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">stacksize</span> <span class="p">=</span> <span class="nf">round2</span><span class="p">(</span><span class="nx">_StackSystem</span> <span class="o">+</span> <span class="nx">stacksize</span><span class="p">)</span>
		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">//真正申请内存stacksize大小的内存
</span><span class="c1"></span>			<span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nf">stackalloc</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">stacksize</span><span class="p">))</span>
		<span class="p">})</span>
		<span class="nx">newg</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
		<span class="nx">newg</span><span class="p">.</span><span class="nx">stackguard1</span> <span class="p">=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">newg</span>
<span class="p">}</span>
<span class="c1">//函数的功能：取得一个值使得不等式 2^n &gt;= x 成立且左边是所有成立值中的最小值
</span><span class="c1">//如：round2(15) = 16 ; round2(18)=32 ...
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">round2</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int32</span><span class="p">)</span> <span class="kt">int32</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="nb">uint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">s</span> <span class="p">&lt;</span> <span class="nx">x</span> <span class="p">{</span>
        <span class="nx">s</span><span class="o">++</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime.malg 返回的 Goroutine 会存储到全局变量 allgs 中。</p>
<p>默认采用2KB栈空间,并且都被allg引用.这是垃圾回收遍历扫描的需要,以便获取指针引用,收缩栈空间.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">allgs</span>    <span class="p">[]</span><span class="o">*</span><span class="nx">g</span>
	<span class="nx">allglock</span> <span class="nx">mutex</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">allgadd</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="o">==</span> <span class="nx">_Gidle</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;allgadd: bad status Gidle&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allglock</span><span class="p">)</span>
	<span class="nx">allgs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">allgs</span><span class="p">,</span> <span class="nx">gp</span><span class="p">)</span>
	<span class="nx">allglen</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">allgs</span><span class="p">))</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allglock</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>G似乎从来不被释放,会不会有存留过多的问题?不过好在垃圾回收会调用shrinkstack将其栈空间回收.</p>
<h3 id="g存入可运行队列">G存入可运行队列</h3>
<h4 id="runqput">runqput</h4>
<p>runtime.runqput 函数会将新创建的 Goroutine 放到运行队列上，这既可能是全局的运行队列，也可能是处理器本地的运行队列：</p>
<p>创建完毕的G任务被优先放入P本地队列等待执行,这属于无锁操作.</p>
<ol>
<li>当 next 为 true 时，将 Goroutine 设置到处理器的 runnext 上作为下一个处理器执行的任务；</li>
<li>当 next 为 false 并且本地运行队列还有剩余空间时，将 Goroutine 加入处理器持有的本地运行队列；</li>
<li>当处理器的本地运行队列已经没有剩余空间时就会把本地队列中的一部分 Goroutine 和待加入的 Goroutine 通过 runqputslow 添加到调度器持有的全局运行队列上；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// runqput tries to put g on the local runnable queue.
</span><span class="c1">// If next is false, runqput adds g to the tail of the runnable queue.
</span><span class="c1">// If next is true, runqput puts g in the _p_.runnext slot.
</span><span class="c1">// If the run queue is full, runnext puts g on the global queue.
</span><span class="c1">// Executed only by the owner P.
</span><span class="c1">// runqput 尝试将 g 放到本地可执行队列里。
</span><span class="c1">// 如果 next 为假，runqput 将 g 添加到可运行队列的尾部
</span><span class="c1">// 如果 next 为真，runqput 将 g 添加到 p.runnext 字段
</span><span class="c1">// 如果 run queue 满了，runnext 将 g 放到全局队列里
</span><span class="c1">//
</span><span class="c1">// runnext 成员中的 goroutine 会被优先调度起来运行
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runqput</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">next</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">randomizeScheduler</span> <span class="o">&amp;&amp;</span> <span class="nx">next</span> <span class="o">&amp;&amp;</span> <span class="nf">fastrand</span><span class="p">()</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">next</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">//如果可能,将G直接保存在P.runnext,作为下一个优先执行任务
</span><span class="c1"></span>	<span class="c1">//尝试把G添加到P的runnext节点，这里确保runnext只有一个G，如果之前已经有一个G则踢出来放到runq里
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">next</span> <span class="p">{</span>
	<span class="nx">retryNext</span><span class="p">:</span>
        <span class="nx">oldnext</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="nx">oldnext</span><span class="p">,</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="c1">// 有其它线程在操作 runnext 成员，需要重试
</span><span class="c1"></span>			<span class="k">goto</span> <span class="nx">retryNext</span>
		<span class="p">}</span>
		<span class="c1">// 老的 runnext 为 nil，不用管了
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">oldnext</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
        <span class="c1">// Kick the old runnext out to the regular run queue.
</span><span class="c1"></span>        <span class="c1">// 把之前的 runnext 踢到正常的 runq 中
</span><span class="c1"></span>        <span class="c1">// 原本存放在 runnext 的 gp 放入 runq 的尾部
</span><span class="c1"></span>		<span class="nx">gp</span> <span class="p">=</span> <span class="nx">oldnext</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="p">}</span>

<span class="nx">retry</span><span class="p">:</span>
    <span class="c1">//runghead是一个数组实现的循环队列
</span><span class="c1"></span>	<span class="c1">//head,tail累加,通过取模即可获得索引位置,很典型的算法
</span><span class="c1"></span>	<span class="c1">// 如果_p_.runq队列不满，则放到队尾就结束了。
</span><span class="c1"></span>  	<span class="c1">// 试想如果不放到队尾而放到队头里会怎样？如果频繁的创建G则可能后面的G总是不被执行，对后面的G不公平
</span><span class="c1"></span>	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with consumers
</span><span class="c1"></span>    <span class="nx">t</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span>
    <span class="c1">//如果本地队列未满,直接放到尾部
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="o">-</span><span class="nx">h</span> <span class="p">&lt;</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))</span> <span class="p">{</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[</span><span class="nx">t</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">set</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
		<span class="c1">// 这里使用原子操作写入 runtail，防止编译器和 CPU 指令重排，保证上一行代码对 runq 的修改发生在修改 runqtail 之前，并且保证当前线程对队列的修改对其它线程立即可见。
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">,</span> <span class="nx">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// store-release, makes the item available for consumption
</span><span class="c1"></span>		<span class="k">return</span>
    <span class="p">}</span>

	<span class="c1">//如果队列满了，尝试把G和当前P里的一部分runq放到全局队列
</span><span class="c1"></span> 	<span class="c1">//因为操作全局需要加锁,所以名字里带个slow
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">runqputslow</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// the queue is not full, now the put above must succeed
</span><span class="c1"></span>	<span class="c1">//如果将 newg 添加到全局队列失败了，说明本地队列在此过程中发生了变化，又有了位置可以添加 newg，因此重试 retry 代码段。我们也可以发现，P 的本地可运行队列的长度为 256，它是一个循环队列，因此最多只能放下 256 个 goroutine。
</span><span class="c1"></span>	<span class="k">goto</span> <span class="nx">retry</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>任务队列分为三级,桉优先级从高到低分别是P.runnext,P.runq,Sched.runq,很有些CPU多级缓存的意思.</p>
<p>往全局队列添加任务,显然需要加锁,只是专门取名为runqputslow就很有说法了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Put g and a batch of work from local runnable queue on global queue.
</span><span class="c1">// Executed only by the owner P.
</span><span class="c1">// 将 g 和 _p_ 本地队列的一半 goroutine 放入全局队列。
</span><span class="c1">// 因为要获取锁，所以会慢
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runqputslow</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">t</span> <span class="kt">uint32</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">//这意思显然是要从P本地转移一半任务到全局队列.
</span><span class="c1"></span>    <span class="c1">//&#34;+1&#34;是别忘了当前这个gp
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">batch</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nx">g</span>

    <span class="c1">// First, grab a batch from local queue.
</span><span class="c1"></span>    <span class="c1">//计算一半的实际数量
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">t</span> <span class="o">-</span> <span class="nx">h</span>
	<span class="nx">n</span> <span class="p">=</span> <span class="nx">n</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">!=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runqputslow: queue is not full&#34;</span><span class="p">)</span>
    <span class="p">}</span>
	<span class="c1">//从队列头部提取
</span><span class="c1"></span>	<span class="c1">// 从runq头部开始取出一半的runq放到临时变量batch里
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[(</span><span class="nx">h</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">ptr</span><span class="p">()</span>
    <span class="p">}</span>
	<span class="c1">//调整P队列头部位置
</span><span class="c1"></span>	<span class="c1">//如果修改失败，说明 runq 的本地队列被其他线程修改了，因此后面的操作就不进行了，直接返回 false，表示 newg 没被添加进来。
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">CasRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="o">+</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// cas-release, commits consume
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
	<span class="c1">//加上当前gp
</span><span class="c1"></span>	<span class="c1">// 把要put的g也放进batch去
</span><span class="c1"></span>	<span class="nx">batch</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">gp</span>
    <span class="c1">//对顺序进行洗牌
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">randomizeScheduler</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">j</span> <span class="o">:=</span> <span class="nf">fastrandn</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">batch</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">batch</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="c1">// 全局运行队列是一个链表，这里首先把所有需要放入全局运行队列的 g 链接起来，
</span><span class="c1"></span>    <span class="c1">// 减小锁粒度，从而降低锁冲突，提升性能
</span><span class="c1"></span>	<span class="c1">// Link the goroutines.
</span><span class="c1"></span>	<span class="c1">// 通过循环将 batch 数组里的所有 g 串成链表：
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">schedlink</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    <span class="p">}</span>
	<span class="kd">var</span> <span class="nx">q</span> <span class="nx">gQueue</span>
	<span class="nx">q</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">batch</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="nx">q</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">batch</span><span class="p">[</span><span class="nx">n</span><span class="p">])</span>

	<span class="c1">// Now put the batch on global queue.
</span><span class="c1"></span>	<span class="c1">// 将一半的runq放到global队列里,一次多转移一些省得转移频繁
</span><span class="c1"></span>    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="c1">//添加到全局队列尾部
</span><span class="c1"></span>	<span class="nf">globrunqputbatch</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">q</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果全局的队列尾 sched.runqtail 不为空，则直接将其和前面生成的链表头相接，否则说明全局的可运行列队为空，那就直接将前面生成的链表头设置到 sched.runqhead。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Put a batch of runnable goroutines on the global runnable queue.
</span><span class="c1">// This clears *batch.
</span><span class="c1">// Sched must be locked.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">globrunqputbatch</span><span class="p">(</span><span class="nx">batch</span> <span class="o">*</span><span class="nx">gQueue</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">runq</span><span class="p">.</span><span class="nf">pushBackAll</span><span class="p">(</span><span class="o">*</span><span class="nx">batch</span><span class="p">)</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">+=</span> <span class="nx">n</span>
	<span class="o">*</span><span class="nx">batch</span> <span class="p">=</span> <span class="nx">gQueue</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>若本地队列已满,一次性转移半数到全局队列.这个好理解,因为其他P可能正饿着呢.这也正好解释了newproc1最后尝试用wakep唤醒其他M/P去执行任务的意图.</p>
<p>runqput 方法归还执行完的G,runq 定义是 <code>runq [256]guintptr</code>，有固定的长度，因此当前P里的待运行G超过256的时候说明过多了，则执行 runqputslow 方法把一半G扔给全局G链表，globrunqputbatch 连接全局链表的头尾指针。</p>
<h3 id="唤醒m">唤醒M</h3>
<h4 id="startm">startm</h4>
<p>当newproc1成功创建G任务后,会尝试用wakep唤醒M执行任务.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Tries to add one more P to execute G&#39;s.
</span><span class="c1">// Called when a G is made runnable (newproc, ready).
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">wakep</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//被唤醒的线程需要绑定P,累加自旋计数,避免newproc1唤醒过多线程
</span><span class="c1"></span>	<span class="c1">// be conservative about spinning threads
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nf">startm</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>一个M被唤醒的原因总是有新工作要做。比如有了新的自由的P，或有了新的可运行G。如果调用startm函数传入的参数_p_为空，那么就从调度器的空闲P列表获取一个P作为M运行G的上下文环境。如果没有空闲的P，startm函数会直接返回，因为没有P，M也运行不了G。如果有幸得到了一个P，startm函数就会再从调度器的空闲M列表获取一个M，如果没有空闲的M就新建一个M。这个M会和P进行预联，并做好执行准备。</p>
<p>非M0的启动首先从 startm 方法开始启动，要进行调度工作必须有调度处理器P，因此先从空闲的P链表里获取一个P，在 newm 方法创建一个M与P绑定。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Schedules some M to run the p (creates an M if necessary).
</span><span class="c1">// If p==nil, tries to get an idle P, if no idle P&#39;s does nothing.
</span><span class="c1">// May run with m.p==nil, so write barriers are not allowed.
</span><span class="c1">// If spinning is set, the caller has incremented nmspinning and startm will
</span><span class="c1">// either decrement nmspinning or set m.spinning in the newly started M.
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1">// 调用 m 来绑定 p，如果没有 m，那就新建一个
</span><span class="c1">// 如果 p 为空，那就尝试获取一个处于空闲状态的 p，如果找到 p，那就什么都不做
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">startm</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">spinning</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">//如果没有指定P,尝试获取空闲P
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_p_</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">_p_</span> <span class="p">=</span> <span class="nf">pidleget</span><span class="p">()</span>
		<span class="c1">//获取失败,终止
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">_p_</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">spinning</span> <span class="p">{</span>
				<span class="c1">// The caller incremented nmspinning, but there are no idle Ps,
</span><span class="c1"></span>				<span class="c1">// so it&#39;s okay to just undo the increment and give up.
</span><span class="c1"></span>				<span class="c1">//递减自旋计数
</span><span class="c1"></span>				<span class="c1">// 如果找到 p，放弃。还原全局处于自旋状态的 m 的数量
</span><span class="c1"></span>				<span class="k">if</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;startm: negative nmspinning&#34;</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="c1">// 没有空闲的 p，直接返回
</span><span class="c1"></span>			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//获取休眠的闲置M
</span><span class="c1"></span>	<span class="c1">// 从 m 空闲队列中获取正处于睡眠之中的工作线程，
</span><span class="c1"></span>    <span class="c1">// 所有处于睡眠状态的 m 都在此队列中
</span><span class="c1"></span>	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">mget</span><span class="p">()</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">//如没有闲置M,新建
</span><span class="c1"></span>	<span class="c1">// 如果没有找到 m
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">mp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">//默认启动函数
</span><span class="c1"></span>		<span class="c1">//主要是判断M.nextp是否有暂存的P,以此调整自旋计数
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">fn</span> <span class="kd">func</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">spinning</span> <span class="p">{</span>
			<span class="c1">// The caller incremented nmspinning, so set m.spinning in the new M.
</span><span class="c1"></span>			<span class="nx">fn</span> <span class="p">=</span> <span class="nx">mspinning</span>
		<span class="p">}</span>
		<span class="c1">// 创建新的工作线程
</span><span class="c1"></span>		<span class="nf">newm</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;startm: m is spinning&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;startm: m has p&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">spinning</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;startm: p has runnable gs&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// The caller incremented nmspinning, so set m.spinning in the new M.
</span><span class="c1"></span>	<span class="c1">//设置自旋状态和暂存P
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="nx">spinning</span>
	<span class="c1">// 设置 m 马上要结合的 p
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="c1">//唤醒M
</span><span class="c1"></span>	<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>首先处理 p 为空的情况，直接从全局空闲 p 队列里找，如果没找到，则直接返回。如果设置了 spinning 为 true 的话，还需要还原全局的处于自旋状态的 m 的数值：&amp;sched.nmspinning 。</p>
<p>搞定了 p，接下来看 m。先调用 mget 函数从全局空闲的 m 队列里获取一个 m，如果没找到 m，则要调用 newm 新创建一个 m，并且如果设置了 spinning 为 true 的话，先要设置好 mstartfn：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mspinning</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// startm&#39;s caller incremented nmspinning. Set the new M&#39;s spinning.
</span><span class="c1"></span>    <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这样，启动 m 后，在 mstart1 函数里，进入 schedule 循环前，执行 mstartfn 函数，使得 m 处于自旋状态。</p>
<p>接下来是正常情况下（找到了 p 和 m）的处理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">mp</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="nx">spinning</span>
<span class="c1">// 设置 m 马上要结合的 p
</span><span class="c1"></span><span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
<span class="c1">// 唤醒 m
</span><span class="c1"></span><span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>设置 nextp 为找到的 p，调用 notewakeup 唤醒 m。之前我们讲 findrunnable 函数的时候，对于最后没有找到工作的 m，我们调用 notesleep(&amp;<em>g</em>.m.park)，使得 m 进入睡眠状态。现在终于有工作了，需要老将出山，将其唤醒：</p>
<h5 id="mget">mget</h5>
<p>startm默认优先选用闲置M,这个闲置的M从何而来?</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Try to get an m from midle list.
</span><span class="c1">// Sched must be locked.
</span><span class="c1">// May run during STW, so write barriers are not allowed.
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1">// 尝试从 midel 列表中获取一个 M
</span><span class="c1">// 调度器必须锁住
</span><span class="c1">// 可能在 STW 期间运行，故不允许 write barrier
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mget</span><span class="p">()</span> <span class="o">*</span><span class="nx">m</span> <span class="p">{</span>
	<span class="nx">mp</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">midle</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">mp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">sched</span><span class="p">.</span><span class="nx">midle</span> <span class="p">=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">schedlink</span>
		<span class="nx">sched</span><span class="p">.</span><span class="nx">nmidle</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">mp</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>被唤醒而进入工作状态的M,会陷入调度循环,从各种可能场所获取并执行G任务.只有当彻底找不到可执行任务,或因任务用时过长,系统调用阻塞等原因被剥夺P时,M才会进入休眠状态.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//停止M,使其休眠
</span><span class="c1">// Stops execution of the current m until new work is available.
</span><span class="c1">// Returns with acquired P.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">stopm</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopm holding locks&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopm holding p&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopm spinning&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nf">mput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">//休眠,等待被唤醒
</span><span class="c1"></span>	<span class="nf">notesleep</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
	<span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
	<span class="c1">//绑定P
</span><span class="c1"></span>	<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="c1">//将M放入闲置链表
</span><span class="c1">// Put mp on midle list.
</span><span class="c1">// Sched must be locked.
</span><span class="c1">// May run during STW, so write barriers are not allowed.
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mput</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">schedlink</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">midle</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">midle</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">nmidle</span><span class="o">++</span>
	<span class="nf">checkdead</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>最好不要有太多的M,且不说通过系统调用创建线程本身就有很大的性能损耗,大量闲置且不被回收的线程,M对象,g0栈空间都是自愿浪费</p>
<h5 id="newm">newm</h5>
<p>newm 方法中通过 newosproc 新建一个内核线程，并把内核线程与M以及 mstart 方法进行关联，这样内核线程执行时就可以找到M并且找到启动调度循环的方法。最后 schedule 启动调度循环</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Create a new m. It will start off with a call to fn, or else the scheduler.
</span><span class="c1">// fn needs to be static and not a heap allocated closure.
</span><span class="c1">// May run with m.p==nil, so write barriers are not allowed.
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1">// 创建一个新的 m. 它会启动并调用 fn 或调度器
</span><span class="c1">// fn 必须是静态、非堆上分配的闭包
</span><span class="c1">// 它可能在 m.p==nil 时运行，因此不允许 write barrier
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newm</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//创建M对象
</span><span class="c1"></span>	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">allocm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span>
	<span class="c1">//暂存P
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="c1">// 设置 signal mask
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">sigmask</span> <span class="p">=</span> <span class="nx">initSigmask</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">();</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedExt</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">incgo</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;plan9&#34;</span> <span class="p">{</span>
		<span class="c1">// We&#39;re on a locked M or a thread that may have been
</span><span class="c1"></span>		<span class="c1">// started by C. The kernel state of this thread may
</span><span class="c1"></span>		<span class="c1">// be strange (the user may have locked it for that
</span><span class="c1"></span>		<span class="c1">// purpose). We don&#39;t want to clone that into another
</span><span class="c1"></span>		<span class="c1">// thread. Instead, ask a known-good thread to create
</span><span class="c1"></span>		<span class="c1">// the thread for us.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// This is disabled on Plan 9. See golang.org/issue/22227.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// 我们处于一个锁定的 M 或可能由 C 启动的线程。这个线程的内核状态可能
</span><span class="c1"></span>		<span class="c1">// 很奇怪（用户可能已将其锁定）。我们不想将其克隆到另一个线程。
</span><span class="c1"></span>		<span class="c1">// 相反，请求一个已知状态良好的线程来创建给我们的线程。
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// 在 plan9 上禁用，见 golang.org/issue/22227
</span><span class="c1"></span>		<span class="c1">// TODO: This may be unnecessary on Windows, which
</span><span class="c1"></span>		<span class="c1">// doesn&#39;t model thread creation off fork.
</span><span class="c1"></span>		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">haveTemplateThread</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;on a locked thread with no template thread&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">mp</span><span class="p">.</span><span class="nx">schedlink</span> <span class="p">=</span> <span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">newm</span>
		<span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">newm</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">{</span>
			<span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">false</span>
			<span class="c1">// 唤醒 m, 自旋到非自旋
</span><span class="c1"></span>			<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">wake</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nf">newm1</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>先调用 allocm 在堆上创建一个 m，接着调用 newosproc 函数启动一个工作线程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newm1</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">iscgo</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">ts</span> <span class="nx">cgothreadstart</span>
		<span class="k">if</span> <span class="nx">_cgo_thread_start</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;_cgo_thread_start missing&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">ts</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span><span class="p">)</span>
		<span class="nx">ts</span><span class="p">.</span><span class="nx">tls</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">tls</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="nx">ts</span><span class="p">.</span><span class="nx">fn</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nf">funcPC</span><span class="p">(</span><span class="nx">mstart</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
			<span class="nf">msanwrite</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ts</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">ts</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="nx">execLock</span><span class="p">.</span><span class="nf">rlock</span><span class="p">()</span> <span class="c1">// Prevent process clone.
</span><span class="c1"></span>		<span class="nf">asmcgocall</span><span class="p">(</span><span class="nx">_cgo_thread_start</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ts</span><span class="p">))</span>
		<span class="nx">execLock</span><span class="p">.</span><span class="nf">runlock</span><span class="p">()</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">execLock</span><span class="p">.</span><span class="nf">rlock</span><span class="p">()</span> <span class="c1">// Prevent process clone.
</span><span class="c1"></span>	<span class="c1">//创建系统线程
</span><span class="c1"></span>	<span class="nf">newosproc</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="nx">execLock</span><span class="p">.</span><span class="nf">runlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当 m 被创建时，会转去运行 mstart：</p>
<ol>
<li>如果当前程序为 cgo 程序，则会通过 asmcgocall 来创建线程并调用 mstart</li>
<li>否则会调用 newosproc 来创建线程，从而调用 mstart。</li>
</ol>
<h5 id="allocm">allocm</h5>
<p>allocm 方法中创建M的同时创建了一个G与自己关联，这个G就是我们在上面说到的g0。为什么M要关联一个g0？因为 runtime 下执行一个G也需要用到栈空间来完成调度工作，而拥有执行栈的地方只有G，因此需要为每个执行线程里配置一个g0。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Allocate a new m unassociated with any thread.
</span><span class="c1">// Can use p for allocation context if needed.
</span><span class="c1">// fn is recorded as the new m&#39;s m.mstartfn.
</span><span class="c1">//
</span><span class="c1">// This function is allowed to have write barriers even if the caller
</span><span class="c1">// isn&#39;t because it borrows _p_.
</span><span class="c1">//
</span><span class="c1">//go:yeswritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">allocm</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">fn</span> <span class="kd">func</span><span class="p">())</span> <span class="o">*</span><span class="nx">m</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span> <span class="c1">// disable GC because it can be called from sysmon
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="c1">// temporarily borrow p for mallocs in this function
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="c1">// Release the free M list. We need to do this somewhere and
</span><span class="c1"></span>	<span class="c1">// this may free up a stack we can use.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">freem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="kd">var</span> <span class="nx">newList</span> <span class="o">*</span><span class="nx">m</span>
		<span class="k">for</span> <span class="nx">freem</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">freem</span><span class="p">;</span> <span class="nx">freem</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">freem</span><span class="p">.</span><span class="nx">freeWait</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">next</span> <span class="o">:=</span> <span class="nx">freem</span><span class="p">.</span><span class="nx">freelink</span>
				<span class="nx">freem</span><span class="p">.</span><span class="nx">freelink</span> <span class="p">=</span> <span class="nx">newList</span>
				<span class="nx">newList</span> <span class="p">=</span> <span class="nx">freem</span>
				<span class="nx">freem</span> <span class="p">=</span> <span class="nx">next</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="nf">stackfree</span><span class="p">(</span><span class="nx">freem</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span>
			<span class="nx">freem</span> <span class="p">=</span> <span class="nx">freem</span><span class="p">.</span><span class="nx">freelink</span>
		<span class="p">}</span>
		<span class="nx">sched</span><span class="p">.</span><span class="nx">freem</span> <span class="p">=</span> <span class="nx">newList</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">mp</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
	<span class="c1">//设置它的起始函数（mstartfn字段）。起始函数仅当运行时系统要用此M执行系统监控或垃圾回收等任务时才会被设置。
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">mstartfn</span> <span class="p">=</span> <span class="nx">fn</span>	<span class="c1">//启动函数
</span><span class="c1"></span>	<span class="nf">mcommoninit</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>	<span class="c1">//初始化
</span><span class="c1"></span>
	<span class="c1">//创建g0
</span><span class="c1"></span>	<span class="c1">// In case of cgo or Solaris or Darwin, pthread_create will make us a stack.
</span><span class="c1"></span>	<span class="c1">// Windows and Plan 9 will layout sched stack on OS stack.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">iscgo</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;solaris&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;windows&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;plan9&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;darwin&#34;</span> <span class="p">{</span>
		<span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="mi">8192</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">StackGuardMultiplier</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 把新创建的g0与M做关联
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nx">mp</span>

	<span class="k">if</span> <span class="nx">_p_</span> <span class="o">==</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">releasep</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">{</span> <span class="c1">// restore the preemption request in case we&#39;ve cleared it in newstack
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">mp</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>M最特别的就是自带一个名为g0,默认8KB栈内存的G对象属性.它的栈内存地址被传给newosproc函数,作为系统线程的默认堆栈空间(并非所有系统都支持).</p>
<p>M初始化操作会检查已有的M数量,如超出最大限制(默认为10000),会导致进程崩溃.所有M被添加到allm链表,且不被释放.</p>
<p>全局M列表除了可以通过它获取到所有M的信息以及防止M被当作垃圾回收掉之外，并没有特殊意义。</p>
<h5 id="mcommoninit">mcommoninit</h5>
<p>commoninit 仅仅只是对 M 进行一个初步的初始化， 该初始化包含对 M 及用于处理 M 信号的 G 的相关运算操作，未涉及工作线程的暂止和复始。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 初始化 m
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mcommoninit</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//如果是初始化m0, _g_ = g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="c1">// g0 stack won&#39;t make sense for user (and is not necessary unwindable).
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
		<span class="nf">callers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">createstack</span><span class="p">[:])</span>
	<span class="p">}</span>
	<span class="c1">//因为 sched 是一个全局变量，多个线程同时操作 sched 会有并发问题，因此先要加锁，操作结束之后再解锁。
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">mnext</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">mnext</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: thread ID overflow&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 设置 m 的 id
</span><span class="c1"></span>	<span class="c1">// m0 的 id 是 0，并且之后创建的 m 的 id 是递增的。
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">id</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">mnext</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">mnext</span><span class="o">++</span>
	<span class="c1">// 检查已创建系统线程是否超过了数量限制（10000）
</span><span class="c1"></span>	<span class="nf">checkmcount</span><span class="p">()</span>
	<span class="c1">// random 初始化
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1597334677</span> <span class="o">*</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nf">cputicks</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">0</span><span class="p">]|</span><span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="p">}</span>

	<span class="nf">mpreinit</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stackguard1</span> <span class="p">=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
	<span class="p">}</span>

	<span class="c1">// Add to allm so garbage collector doesn&#39;t free g-&gt;m
</span><span class="c1"></span>	<span class="c1">// when it is just in a register or thread-local storage.
</span><span class="c1"></span>	<span class="c1">// 将 m 挂到全局变量 allm 上，allm 是一个指向 m 的的指针。
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">alllink</span> <span class="p">=</span> <span class="nx">allm</span>

	<span class="c1">// NumCgoCall() iterates over allm w/o schedlock,
</span><span class="c1"></span>	<span class="c1">// so we need to publish it safely.
</span><span class="c1"></span>	<span class="c1">//这一行将 allm 变成 m 的地址，这样变成了一个循环链表。之后再新建 m 的时候，新 m 的 alllink 就会指向本次的 m，最后 allm 又会指向新创建的 m。
</span><span class="c1"></span>	<span class="nf">atomicstorep</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allm</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">mp</span><span class="p">))</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// Allocate memory to hold a cgo traceback if the cgo call crashes.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">iscgo</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;solaris&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;windows&#34;</span> <span class="p">{</span>
		<span class="nx">mp</span><span class="p">.</span><span class="nx">cgoCallers</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">cgoCallers</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">checkmcount</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// sched lock is held
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">mcount</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">maxmcount</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: program exceeds &#34;</span><span class="p">,</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">maxmcount</span><span class="p">,</span> <span class="s">&#34;-thread limit\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;thread exhaustion&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h5 id="newosproc">newosproc</h5>
<p>既然是 newosproc ，我们此刻仍在 Go 的空间中，那么实现就是操作系统特定的了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// May run with m.p==nil, so write barriers are not allowed.
</span><span class="c1">// 可能在 m.p==nil 情况下运行，因此不允许 write barrier
</span><span class="c1">//go:nowritebarrier
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newosproc</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">stk</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="p">)</span>
	<span class="cm">/*
</span><span class="cm">	 * note: strace gets confused if we use CLONE_PTRACE here.
</span><span class="cm">	 */</span>
	<span class="k">if</span> <span class="kc">false</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;newosproc stk=&#34;</span><span class="p">,</span> <span class="nx">stk</span><span class="p">,</span> <span class="s">&#34; m=&#34;</span><span class="p">,</span> <span class="nx">mp</span><span class="p">,</span> <span class="s">&#34; g=&#34;</span><span class="p">,</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span><span class="p">,</span> <span class="s">&#34; clone=&#34;</span><span class="p">,</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">clone</span><span class="p">),</span> <span class="s">&#34; id=&#34;</span><span class="p">,</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="s">&#34; ostk=&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">mp</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Disable signals during clone, so that the new thread starts
</span><span class="c1"></span>	<span class="c1">// with signals disabled. It will enable them in minit.
</span><span class="c1"></span>	<span class="c1">// 在 clone 期间禁用信号，以便新线程启动时信号被禁止。
</span><span class="c1"></span>	<span class="c1">// 他们会在 minit 中重新启用。
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">oset</span> <span class="nx">sigset</span>
	<span class="nf">sigprocmask</span><span class="p">(</span><span class="nx">_SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">sigset_all</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">oset</span><span class="p">)</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nf">clone</span><span class="p">(</span><span class="nx">cloneFlags</span><span class="p">,</span> <span class="nx">stk</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">mp</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nf">funcPC</span><span class="p">(</span><span class="nx">mstart</span><span class="p">)))</span>
	<span class="nf">sigprocmask</span><span class="p">(</span><span class="nx">_SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">oset</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">ret</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: failed to create new OS thread (have &#34;</span><span class="p">,</span> <span class="nf">mcount</span><span class="p">(),</span> <span class="s">&#34; already; errno=&#34;</span><span class="p">,</span> <span class="o">-</span><span class="nx">ret</span><span class="p">,</span> <span class="s">&#34;)\n&#34;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">ret</span> <span class="o">==</span> <span class="o">-</span><span class="nx">_EAGAIN</span> <span class="p">{</span>
			<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: may need to increase max user processes (ulimit -u)&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;newosproc&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>核心就是调用 clone 函数创建系统线程，新线程从 mstart 函数开始执行。clone 函数由汇编语言实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// int32 clone(int32 flags, void *stk, M *mp, G *gp, void (*fn)(void));
</span><span class="c1"></span><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">clone</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span><span class="nx">NOSPLIT</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span>
    <span class="c1">// 准备系统调用的参数
</span><span class="c1"></span>    <span class="nx">MOVL</span>    <span class="nx">flags</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">DI</span>
    <span class="nx">MOVQ</span>    <span class="nx">stk</span><span class="o">+</span><span class="mi">8</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">SI</span>
    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nx">DX</span>
    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nx">R10</span>

    <span class="c1">// 将 mp，gp，fn 拷贝到寄存器，对子线程可见
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">mp</span><span class="o">+</span><span class="mi">16</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">R8</span>
    <span class="nx">MOVQ</span>    <span class="nx">gp</span><span class="o">+</span><span class="mi">24</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">R9</span>
    <span class="nx">MOVQ</span>    <span class="nx">fn</span><span class="o">+</span><span class="mi">32</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">R12</span>

    <span class="c1">// 系统调用 clone
</span><span class="c1"></span>    <span class="nx">MOVL</span>    <span class="err">$</span><span class="mi">56</span><span class="p">,</span> <span class="nx">AX</span>
    <span class="nx">SYSCALL</span>

    <span class="c1">// In parent, return.
</span><span class="c1"></span>    <span class="nx">CMPQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span>
    <span class="nx">JEQ</span>    <span class="mi">3</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>
    <span class="c1">// 父线程，返回
</span><span class="c1"></span>    <span class="nx">MOVL</span>    <span class="nx">AX</span><span class="p">,</span> <span class="nx">ret</span><span class="o">+</span><span class="mi">40</span><span class="p">(</span><span class="nx">FP</span><span class="p">)</span>
    <span class="nx">RET</span>

    <span class="c1">// In child, on new stack.
</span><span class="c1"></span>    <span class="c1">// 在子线程中。设置 CPU 栈顶寄存器指向子线程的栈顶
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">SI</span><span class="p">,</span> <span class="nx">SP</span>

    <span class="c1">// If g or m are nil, skip Go-related setup.
</span><span class="c1"></span>    <span class="nx">CMPQ</span>    <span class="nx">R8</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span>    <span class="c1">// m
</span><span class="c1"></span>    <span class="nx">JEQ</span>    <span class="nx">nog</span>
    <span class="nx">CMPQ</span>    <span class="nx">R9</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span>    <span class="c1">// g
</span><span class="c1"></span>    <span class="nx">JEQ</span>    <span class="nx">nog</span>

    <span class="c1">// Initialize m-&gt;procid to Linux tid
</span><span class="c1"></span>    <span class="c1">// 通过 gettid 系统调用获取线程 ID（tid）
</span><span class="c1"></span>    <span class="nx">MOVL</span>    <span class="err">$</span><span class="mi">186</span><span class="p">,</span> <span class="nx">AX</span>    <span class="c1">// gettid
</span><span class="c1"></span>    <span class="nx">SYSCALL</span>
    <span class="c1">// 设置 m.procid = tid
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="nf">m_procid</span><span class="p">(</span><span class="nx">R8</span><span class="p">)</span>

    <span class="c1">// Set FS to point at m-&gt;tls.
</span><span class="c1"></span>    <span class="c1">// 新线程刚刚创建出来，还未设置线程本地存储，即 m 结构体对象还未与工作线程关联起来，
</span><span class="c1"></span>    <span class="c1">// 下面的指令负责设置新线程的 TLS，把 m 对象和工作线程关联起来
</span><span class="c1"></span>    <span class="nx">LEAQ</span>    <span class="nf">m_tls</span><span class="p">(</span><span class="nx">R8</span><span class="p">),</span> <span class="nx">DI</span>
    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">settls</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

    <span class="c1">// In child, set up new stack
</span><span class="c1"></span>    <span class="nf">get_tls</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
    <span class="nx">MOVQ</span>    <span class="nx">R8</span><span class="p">,</span> <span class="nf">g_m</span><span class="p">(</span><span class="nx">R9</span><span class="p">)</span> <span class="c1">// g.m = m
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">R9</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span> <span class="c1">// tls.g = &amp;m.g0
</span><span class="c1"></span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">stackcheck</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

<span class="nx">nog</span><span class="p">:</span>
    <span class="c1">// Call fn
</span><span class="c1"></span>    <span class="c1">// 调用 mstart 函数。永不返回
</span><span class="c1"></span>    <span class="nx">CALL</span>    <span class="nx">R12</span>

    <span class="c1">// It shouldn&#39;t return. If it does, exit that thread.
</span><span class="c1"></span>    <span class="nx">MOVL</span>    <span class="err">$</span><span class="mi">111</span><span class="p">,</span> <span class="nx">DI</span>
    <span class="nx">MOVL</span>    <span class="err">$</span><span class="mi">60</span><span class="p">,</span> <span class="nx">AX</span>
    <span class="nx">SYSCALL</span>
    <span class="nx">JMP</span>    <span class="o">-</span><span class="mi">3</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>    <span class="c1">// keep exiting
</span></code></pre></td></tr></table>
</div>
</div><p>先是为 clone 系统调用准备参数，参数通过寄存器传递。第一个参数指定内核创建线程时的选项，第二个参数指定新线程应该使用的栈，这两个参数都是通过 newosproc 函数传递进来的。</p>
<p>接着将 m, g0, fn 分别保存到寄存器中，待子线程创建好后再拿出来使用。因为这些参数此时是在父线程的栈上，若不保存到寄存器中，子线程就取不出来了。</p>
<p>这个几个参数保存在父线程的寄存器中，创建子线程时，操作系统内核会把父线程所有的寄存器帮我们复制一份给子线程，所以当子线程开始运行时就能拿到父线程保存在寄存器中的值，从而拿到这几个参数。</p>
<p>之后，调用 clone 系统调用，内核帮我们创建出了一个子线程。相当于原来的一个执行分支现在变成了两个执行分支，于是会有两个返回。这和著名的 fork 系统调用类似，根据返回值来判断现在是处于父线程还是子线程。
如果是父线程，就直接返回了。如果是子线程，接着还要执行一堆操作，例如设置 tls，设置 m.procid 等等。</p>
<h4 id="systemstack">systemstack</h4>
<p>在进程执行过程中,有两类代码需要运行.一类自然是用户逻辑,直接使用G栈内存;另一类是运行时管理指令,它并不便于直接在用户栈上执行,因为这需要处理与用户逻辑现场有关的一大堆事务.</p>
<p>举例来说,G任务可在中途暂停,放回队列后由其他M获取执行.如果不更改执行栈,可能会造成多个线程共享内存,从而引发混乱.另外,在执行垃圾回收操作时,如何收缩依旧被线程持有的G栈空间?因此,当需要执行管理指令时,会将线程栈临时切换到g0,与用户逻辑彻底隔离</p>
<p>systemstack就是切换到g0栈后再执行运行时相关管理操作的.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// mcall switches from the g to the g0 stack and invokes fn(g),
</span><span class="c1">// where g is the goroutine that made the call.
</span><span class="c1">// mcall saves g&#39;s current PC/SP in g-&gt;sched so that it can be restored later.
</span><span class="c1">// It is up to fn to arrange for that later execution, typically by recording
</span><span class="c1">// g in a data structure, causing something to call ready(g) later.
</span><span class="c1">// mcall returns to the original goroutine g later, when g has been rescheduled.
</span><span class="c1">// fn must not return at all; typically it ends by calling schedule, to let the m
</span><span class="c1">// run other goroutines.
</span><span class="c1">//
</span><span class="c1">// mcall can only be called from g stacks (not g0, not gsignal).
</span><span class="c1">//
</span><span class="c1">// This must NOT be go:noescape: if fn is a stack-allocated closure,
</span><span class="c1">// fn puts g on a run queue, and g executes before fn returns, the
</span><span class="c1">// closure will be invalidated while it is still executing.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mcall</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">g</span><span class="p">))</span>

<span class="c1">// systemstack runs fn on a system stack.
</span><span class="c1">// If systemstack is called from the per-OS-thread (g0) stack, or
</span><span class="c1">// if systemstack is called from the signal handling (gsignal) stack,
</span><span class="c1">// systemstack calls fn directly and returns.
</span><span class="c1">// Otherwise, systemstack is being called from the limited stack
</span><span class="c1">// of an ordinary goroutine. In this case, systemstack switches
</span><span class="c1">// to the per-OS-thread stack, calls fn, and switches back.
</span><span class="c1">// It is common to use a func literal as the argument, in order
</span><span class="c1">// to share inputs and outputs with the code around the call
</span><span class="c1">// to system stack:
</span><span class="c1">//
</span><span class="c1">//	... set up y ...
</span><span class="c1">//	systemstack(func() {
</span><span class="c1">//		x = bigcall(y)
</span><span class="c1">//	})
</span><span class="c1">//	... use x ...
</span><span class="c1">//
</span><span class="c1">//go:noescape
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">systemstack</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">())</span>

</code></pre></td></tr></table>
</div>
</div><h3 id="m开始执行">M开始执行</h3>
<h4 id="mstart">mstart</h4>
<p>我们必须在开始前计算栈边界，因此在 mstart1 之前，就是一些确定执行栈边界的工作。</p>
<p>mstart 函数设置了 stackguard0 和 stackguard1 字段后，就直接调用 mstart1() 函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Called to start an M.
</span><span class="c1">//
</span><span class="c1">// This must not split the stack because we may not even have stack
</span><span class="c1">// bounds set up yet.
</span><span class="c1">//
</span><span class="c1">// May run during STW (because it doesn&#39;t have a P yet), so write
</span><span class="c1">// barriers are not allowed.
</span><span class="c1">//
</span><span class="c1">//go:nosplit
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mstart</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 启动过程时 _g_ = m0.g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="c1">// 终于开始确定执行栈的边界了
</span><span class="c1"></span>	<span class="c1">// 通过检查 g 执行占的边界来确定是否为系统栈
</span><span class="c1"></span>	<span class="nx">osStack</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">==</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="nx">osStack</span> <span class="p">{</span>
		<span class="c1">//对于无法使用g0 stack的系统,直接在系统堆栈上划出所需空间
</span><span class="c1"></span>		<span class="c1">// Initialize stack bounds from system stack.
</span><span class="c1"></span>		<span class="c1">// Cgo may have left stack size in stack.hi.
</span><span class="c1"></span>		<span class="c1">// minit may update the stack bounds.
</span><span class="c1"></span>		<span class="nx">size</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span>
		<span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">size</span> <span class="p">=</span> <span class="mi">8192</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">StackGuardMultiplier</span>
		<span class="p">}</span>
		<span class="c1">//通过取size变量指针来确定高位地址
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">noescape</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">size</span><span class="p">)))</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">size</span> <span class="o">+</span> <span class="mi">1024</span>
	<span class="p">}</span>
	<span class="c1">// Initialize stack guards so that we can start calling
</span><span class="c1"></span>	<span class="c1">// both Go and C functions with stack growth prologues.
</span><span class="c1"></span>	<span class="c1">// 初始化栈 guard，进而可以同时调用 Go 或 C 函数。
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard1</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span>
	<span class="c1">// 启动
</span><span class="c1"></span>	<span class="nf">mstart1</span><span class="p">()</span>

	<span class="c1">// Exit this thread.
</span><span class="c1"></span>	<span class="c1">// 退出线程
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;windows&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;solaris&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;plan9&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;darwin&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;aix&#34;</span> <span class="p">{</span>
		<span class="c1">// Window, Solaris, Darwin, AIX and Plan 9 always system-allocate
</span><span class="c1"></span>		<span class="c1">// the stack, but put it in _g_.stack before mstart,
</span><span class="c1"></span>		<span class="c1">// so the logic above hasn&#39;t set osStack yet.
</span><span class="c1"></span>		<span class="c1">// 由于 windows, solaris, darwin, aix 和 plan9 总是系统分配的栈，在在 mstart 之前放进 _g_.stack 的
</span><span class="c1"></span>		<span class="c1">// 因此上面的逻辑还没有设置 osStack。
</span><span class="c1"></span>		<span class="nx">osStack</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="c1">// 退出线程
</span><span class="c1"></span>	<span class="nf">mexit</span><span class="p">(</span><span class="nx">osStack</span><span class="p">)</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">mstart1</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">_g_</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad runtime·mstart&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Record the caller for use as the top of stack in mcall and
</span><span class="c1"></span>	<span class="c1">// for terminating the thread.
</span><span class="c1"></span>	<span class="c1">// We&#39;re never coming back to mstart1 after we call schedule,
</span><span class="c1"></span>	<span class="c1">// so other calls can reuse the current frame.
</span><span class="c1"></span>	<span class="c1">// 初始化g0执行现场
</span><span class="c1"></span>	<span class="c1">// 一旦调用 schedule() 函数，永不返回
</span><span class="c1"></span>	<span class="c1">// 所以栈帧可以被复用
</span><span class="c1"></span>	<span class="c1">// 为了在 mcall 的栈顶使用调用方来结束当前线程，做记录
</span><span class="c1"></span>	<span class="c1">// 当进入 schedule 之后，我们再也不会回到 mstart1，所以其他调用可以复用当前帧。
</span><span class="c1"></span>	<span class="nf">save</span><span class="p">(</span><span class="nf">getcallerpc</span><span class="p">(),</span> <span class="nf">getcallersp</span><span class="p">())</span>
	<span class="nf">asminit</span><span class="p">()</span>
	<span class="nf">minit</span><span class="p">()</span>

	<span class="c1">// Install signal handlers; after minit so that minit can
</span><span class="c1"></span>	<span class="c1">// prepare the thread to be able to handle the signals.
</span><span class="c1"></span>	<span class="c1">// 设置信号 handler；在 minit 之后，因为 minit 可以准备处理信号的的线程
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span>
		<span class="nf">mstartm0</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">//执行启动函数
</span><span class="c1"></span>	<span class="c1">//初始化完成后，如果有起始函数，那么该M的起始函数就会执行。如果这个起始函数代表的是系统监控任务，那么该M会一直执行它，而不会继续后面的流程。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mstartfn</span><span class="p">;</span> <span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">fn</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 如果当前 m 并非 m0，则要求绑定 p
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span>
		<span class="c1">//绑定P
</span><span class="c1"></span>		<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="c1">//进入任务调度循环(不再返回)
</span><span class="c1"></span>	<span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// Associate p and the current m.
</span><span class="c1">//
</span><span class="c1">// This function is allowed to have write barriers even if the caller
</span><span class="c1">// isn&#39;t because it immediately acquires _p_.
</span><span class="c1">//
</span><span class="c1">//go:yeswritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 此处不允许 write barrier
</span><span class="c1"></span>	<span class="c1">// Do the part that isn&#39;t allowed to have write barriers.
</span><span class="c1"></span>	<span class="nf">wirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>

	<span class="c1">// Have p; write barriers now allowed.
</span><span class="c1"></span>
	<span class="c1">// Perform deferred mcache flush before this P can allocate
</span><span class="c1"></span>	<span class="c1">// from a potentially stale mcache.
</span><span class="c1"></span>	<span class="nx">_p_</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nf">prepareForSweep</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceProcStart</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当 mstart1 结束后，会执行 mexit 退出 M。mstart 也是所有新创建的 M 的起点。</p>
<p>调用 save 函数来保存调度信息到 g0.sched 结构体，来看源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// save updates getg().sched to refer to pc and sp so that a following
</span><span class="c1">// gogo will restore pc and sp.
</span><span class="c1">//
</span><span class="c1">// save must not have write barriers because invoking a write barrier
</span><span class="c1">// can clobber getg().sched.
</span><span class="c1">//
</span><span class="c1">//go:nosplit
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">save</span><span class="p">(</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nx">pc</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lr</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ret</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">_g_</span><span class="p">))</span>
	<span class="c1">// We need to ensure ctxt is zero, but can&#39;t have a write
</span><span class="c1"></span>	<span class="c1">// barrier here. However, it should always already be zero.
</span><span class="c1"></span>	<span class="c1">// Assert that.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ctxt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">badctxt</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>主要是设置了 g0.sched.sp 和 g0.sched.pc，前者指向 mstart1 函数栈上参数的位置，后者则指向 save 函数返回后的下一条指令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// wirep is the first step of acquirep, which actually associates the
</span><span class="c1">// current M to _p_. This is broken out so we can disallow write
</span><span class="c1">// barriers for this part, since we don&#39;t yet have a P.
</span><span class="c1">//
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">wirep</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;wirep: already in go&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 检查 m 是否正常，并检查要获取的 p 的状态
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Pidle</span> <span class="p">{</span>
		<span class="nx">id</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">id</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">id</span>
		<span class="p">}</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;wirep: p-&gt;m=&#34;</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="s">&#34;(&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="s">&#34;) p-&gt;status=&#34;</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;wirep: invalid p state&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">//绑定mcache
</span><span class="c1"></span>	<span class="c1">// 将 p 绑定到 m，p 和 m 互相引用
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">mcache</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>
	<span class="c1">// 修改 p 的状态
</span><span class="c1"></span>	<span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Prunning</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>准备进入工作状态的M必须绑定一个有效P,nextp临时持有待绑定的P对象.因为在未正式执行前,并不适合直接设置相关属性.P为M提供cache,以便为工作线程提供对象分配.</p>
<p>几个需要注意的细节：</p>
<ul>
<li>mstart 除了在程序引导阶段会被运行之外，也可能在每个 m 被创建时运行.</li>
<li>mstart 进入 mstart1 之后，会初始化自身用于信号处理的 g，在 mstartfn 指定时将其执行；</li>
<li>调度循环 schedule 无法返回，因此最后一个 mexit 目前还不会被执行，因此当下所有的 Go 程序创建的线程都无法被释放 （只有一个特例，当使用 runtime.LockOSThread 锁住的 G 退出时会使用 gogo 退出 M）。</li>
</ul>
<h3 id="m寻找g">M寻找G</h3>
<h4 id="schedule">schedule</h4>
<p>一切就绪后,M进入核心调度循环,这是一个由schedule,execute,goroutine fn,goexit函数构成的逻辑循环.</p>
<p>runtime.schedule 函数会从不同地方查找待执行的 Goroutine：</p>
<ol>
<li>为了保证公平，当全局运行队列中有待执行的 Goroutine 时，通过 schedtick 保证有一定几率会从全局的运行队列中查找对应的 Goroutine；</li>
<li>从处理器本地的运行队列中查找待执行的 Goroutine；</li>
<li>如果前两种方法都没有找到 Goroutine，就会通过 runtime.findrunnable 进行阻塞地查找 Goroutine；</li>
</ol>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201117171417.png" alt=""></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// One round of scheduler: find a runnable goroutine and execute it.
</span><span class="c1">// Never returns.
</span><span class="c1">// 执行一轮调度器的工作：找到一个 runnable 的 goroutine，并且执行它
</span><span class="c1">// 永不返回
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">schedule</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;schedule: holding locks&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">//如果当前M是lockedm,那么休眠
</span><span class="c1"></span>	<span class="c1">//没有立即execute(lockedg),是因为该lockedg此时可能被其他M获取
</span><span class="c1"></span>	<span class="c1">//兴许是中途用gosched暂时让出P,进入待运行队列
</span><span class="c1"></span>
	<span class="c1">// 在调度开始，判断当前M是否已被锁定。如果当前M已和某个G锁定，立即停止调度，并停止当前M
</span><span class="c1"></span>	<span class="c1">//（让它阻塞），直到与它锁定的G处于可运行状态时，才会被唤醒并继续运行锁定的G。停止当前M
</span><span class="c1"></span>	<span class="c1">// 后，相关内核线程就不能再做其他事了，调度器也不再为这个M寻找可运行的G。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">stoplockedm</span><span class="p">()</span>
		<span class="nf">execute</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="kc">false</span><span class="p">)</span> <span class="c1">// Never returns.
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="c1">// We should not schedule away from a g that is executing a cgo call,
</span><span class="c1"></span>	<span class="c1">// since the cgo call is using the m&#39;s g0 stack.
</span><span class="c1"></span>	<span class="c1">//如果当前G执行的是cgo调用的话，那么调度也会停止。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">incgo</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;schedule: in cgo&#34;</span><span class="p">)</span>
	<span class="p">}</span>

<span class="nx">top</span><span class="p">:</span>
	<span class="c1">//如果GC处于等待状态,停止M,等待GC完成被唤醒
</span><span class="c1"></span>	<span class="c1">//准备进入GC STW,休眠
</span><span class="c1"></span>	<span class="c1">//判断是否有串行运行时任务正在等待执行，判断依据就是调度器的gcwaiting字段是否为0。如果
</span><span class="c1"></span>	<span class="c1">//gcwaiting不为0，则停止并阻塞当前M直到串行运行时任务结束，才继续执行后面的调度动作。
</span><span class="c1"></span>	<span class="c1">//串行运行时任务执行时需要停止Go的调度器，官方称此操作为Stop the world，简称STW。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">gcstopm</span><span class="p">()</span>
		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">runSafePointFn</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">runSafePointFn</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">//接下来就是寻找可运行G的过程。首先试图获取执行踪迹读取任务的G。
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span>
	<span class="c1">//当从P.next提取G时,inheritTime = true
</span><span class="c1"></span>	<span class="c1">//不累加P.schedtick计数,使得它延长本地队列处理时间
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">inheritTime</span> <span class="kt">bool</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="o">||</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">shutdown</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="p">=</span> <span class="nf">traceReader</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
			<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//未果，试图获取执行GC标记任务的G。
</span><span class="c1"></span>	<span class="c1">//进入GC MarkWorker工作模式
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="p">=</span> <span class="nx">gcController</span><span class="p">.</span><span class="nf">findRunnableGCWorker</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="c1">//未果，从调度器的可运行G队列中获取可运行G。globrunqget函数负责从调度器的可运行G队列获取一个G。
</span><span class="c1"></span>	<span class="c1">//调度器每调度 61 次并且全局队列有可运行 goroutine 的情况下才会调用 globrunqget 函数尝试从全局获取可运行 goroutine。毕竟，从全局获取需要上锁，这个开销可就大了，能不做就不做。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Check the global runnable queue once in a while to ensure fairness.
</span><span class="c1"></span>		<span class="c1">// Otherwise two goroutines can completely occupy the local runqueue
</span><span class="c1"></span>		<span class="c1">// by constantly respawning each other.
</span><span class="c1"></span>		<span class="c1">// 为了公平，每调用 schedule 函数 61 次就要从全局可运行 goroutine 队列中获取
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">schedtick</span><span class="o">%</span><span class="mi">61</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="c1">// 从全局队列最大获取 1 个 gorutine
</span><span class="c1"></span>			<span class="nx">gp</span> <span class="p">=</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//未果，从本地P的可运行G队列中获取可运行G。runqget函数从本地P的可运行G队列获取一个G。
</span><span class="c1"></span>	<span class="c1">//这里说一下，runqget函数除了返回一个G之外，还会返回一个bool值。
</span><span class="c1"></span>	<span class="c1">//inheritTime值为true表示这个G要继承当前剩下的时间片。
</span><span class="c1"></span>	<span class="c1">//那么什么情况下runqget函数会返回true呢？
</span><span class="c1"></span>	<span class="c1">//当它返回的G来自本地P的runnext字段时，该函数就会返回true。
</span><span class="c1"></span>	<span class="c1">//也就是说，本地P的runnext字段中的G在执行时需要继承时间片。
</span><span class="c1"></span>	<span class="c1">//从P本地队列获取G任务
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="p">=</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
		<span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;schedule: spinning with local work&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//未果，全力查找可运行G。函数findrunnable会一直阻塞直到找到一个可运行的G。
</span><span class="c1"></span>	<span class="c1">//也就是说，这个函数返回时，一定是找到一个可运行G了。所谓不撞南墙不回头，说的就是它。
</span><span class="c1"></span>	<span class="c1">//为什么这里也有inheritTime？不难想象，这是因为全力寻找可运行G的过程中也会尝试从本地P那里获取可运行G。
</span><span class="c1"></span>	<span class="c1">//也就是说在findrunnable函数中也调用了runqget函数。
</span><span class="c1"></span>	<span class="c1">//从其他可能的地方获取G任务
</span><span class="c1"></span>	<span class="c1">//如果获取失败,会让M进入休眠状态,被唤醒后重试
</span><span class="c1"></span>	<span class="c1">// 从本地运行队列和全局运行队列都没有找到需要运行的 goroutine，
</span><span class="c1"></span>	<span class="c1">// 调用 findrunnable 函数从其它工作线程的运行队列中偷取，如果偷不到，则当前工作线程进入睡眠
</span><span class="c1"></span>	<span class="c1">// 直到获取到 runnable goroutine 之后 findrunnable 函数才会返回。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="p">=</span> <span class="nf">findrunnable</span><span class="p">()</span> <span class="c1">// blocks until work is available
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="c1">// This thread is going to run a goroutine and is not spinning anymore,
</span><span class="c1"></span>	<span class="c1">// so if it was marked as spinning we need to reset it now and potentially
</span><span class="c1"></span>	<span class="c1">// start a new spinning M.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
		<span class="c1">// 如果 m 是自旋状态，则
</span><span class="c1"></span>		<span class="c1">//   1. 从自旋到非自旋
</span><span class="c1"></span>		<span class="c1">//   2. 在没有自旋状态的 m 的情况下，再多创建一个新的自旋状态的 m
</span><span class="c1"></span>		<span class="nf">resetspinning</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">disable</span><span class="p">.</span><span class="nx">user</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">schedEnabled</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Scheduling of this goroutine is disabled. Put it on
</span><span class="c1"></span>		<span class="c1">// the list of pending runnable goroutines for when we
</span><span class="c1"></span>		<span class="c1">// re-enable user scheduling and look again.
</span><span class="c1"></span>		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">if</span> <span class="nf">schedEnabled</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Something re-enabled scheduling while we
</span><span class="c1"></span>			<span class="c1">// were acquiring the lock.
</span><span class="c1"></span>			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">sched</span><span class="p">.</span><span class="nx">disable</span><span class="p">.</span><span class="nx">runnable</span><span class="p">.</span><span class="nf">pushBack</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
			<span class="nx">sched</span><span class="p">.</span><span class="nx">disable</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="k">goto</span> <span class="nx">top</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//如果获取到的G是lockedg,那么将其连同P交给lockedm去执行
</span><span class="c1"></span>	<span class="c1">//休眠,等待唤醒后重新获取可用G
</span><span class="c1"></span>	<span class="c1">//找到的可运行G与某个M锁定。唤醒锁定的M来运行该G，然后继续为当前M寻找可运行G。
</span><span class="c1"></span>	<span class="c1">//goto top会回到第3步继续执行。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">lockedm</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Hands off own p to the locked m,
</span><span class="c1"></span>		<span class="c1">// then blocks waiting for a new p.
</span><span class="c1"></span>		<span class="nf">startlockedm</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span><span class="c1">//唤醒与gp锁定的M来执行gp
</span><span class="c1"></span>		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>
	<span class="c1">// 执行 goroutine 任务函数
</span><span class="c1"></span>    <span class="c1">// 当前运行的是 runtime 的代码，函数调用栈使用的是 g0 的栈空间
</span><span class="c1"></span>    <span class="c1">// 调用 execute 切换到 gp 的代码和栈空间去运行
</span><span class="c1"></span>	<span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="runqget">runqget</h4>
<p>调用 runqget，从 P 本地可运行队列先选出一个可运行的 goroutine.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Get g from local runnable queue.
</span><span class="c1">// If inheritTime is true, gp should inherit the remaining time in the
</span><span class="c1">// current time slice. Otherwise, it should start a new time slice.
</span><span class="c1">// Executed only by the owner P.
</span><span class="c1">// 从本地可运行队列里找到一个 g
</span><span class="c1">// 如果 inheritTime 为真，gp 应该继承这个时间片，否则，新开启一个时间片
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//优先从runnext获取
</span><span class="c1"></span>	<span class="c1">//循环尝试cas,为什么用同步操作?因为可能有其他P从本地队列偷任务
</span><span class="c1"></span>	<span class="c1">// If there&#39;s a runnext, it&#39;s the next G to run.
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">next</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span>
		<span class="k">if</span> <span class="nx">next</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// 为空，则直接跳出循环
</span><span class="c1"></span>			<span class="k">break</span>
		<span class="p">}</span>
		<span class="c1">// 再次比较 next 是否没有变化
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="nx">next</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 如果没有变化，则返回 next 所指向的 g。且需要继承时间片
</span><span class="c1"></span>			<span class="k">return</span> <span class="nx">next</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//本地队列
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// 获取队列头
</span><span class="c1"></span>		<span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with other consumers
</span><span class="c1"></span>		<span class="c1">// 获取队列尾
</span><span class="c1"></span>		<span class="nx">t</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span>
		<span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="nx">h</span> <span class="p">{</span>
			<span class="c1">// 头和尾相等，说明本地队列为空，找不到 g
</span><span class="c1"></span>			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>
		<span class="c1">// 获取队列头的 g
</span><span class="c1"></span>		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[</span><span class="nx">h</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">ptr</span><span class="p">()</span>
		<span class="c1">// 原子操作，防止这中间被其他线程因为偷工作而修改
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CasRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// cas-release, commits consume
</span><span class="c1"></span>			<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>整个源码结构比较简单，主要是两个 for 循环。</p>
<p>第一个 for 循环尝试返回 P 的 runnext 成员，因为 runnext 具有最高的运行优先级，因此要首先尝试获取 runnext。当发现 runnext 为空时，直接跳出循环，进入第二个。否则，用原子操作获取 runnext，并将其值修改为 0，也就是空。这里用到原子操作的原因是防止在这个过程中，有其他线程过来“偷工作”，导致并发修改 runnext 成员。</p>
<p>第二个 for 循环则是在尝试获取 runnext 成员失败后，尝试从本地队列中返回队列头的 goroutine。同样，先用原子操作获取队列头，使用原子操作的原因同样是防止其他线程“偷工作”时并发对队列头的并发写操作。之后，直接获取队列尾，因为不担心其他线程同时更改，所以直接获取。注意，“偷工作”时只会修改队列头。</p>
<p>比较队列头和队列尾，如果两者相等，说明 P 本地队列没有可运行的 goroutine，直接返回空。否则，算出队列头指向的 goroutine，再用一个 CAS 原子操作来尝试修改队列头，使用原子操作的原因同上。</p>
<h4 id="globrunqget">globrunqget</h4>
<p>在检查全局队列时,除返回一个可用G外,还会批量转移一批到P本地队列,毕竟不能每次加锁去操作全局队列</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Try get a batch of G&#39;s from the global runnable queue.
</span><span class="c1">// Sched must be locked.
</span><span class="c1">// 尝试从全局队列里获取可运行的 goroutine 队列
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">max</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
	<span class="c1">// 如果全局队列中没有 g 直接返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="c1">//将全局队列任务等分,计算最多能批量获取的任务数量
</span><span class="c1"></span>	<span class="c1">// 根据 p 的数量平分全局运行队列中的 goroutines
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span><span class="o">/</span><span class="nx">gomaxprocs</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span>
	<span class="p">}</span>
	<span class="c1">// 修正&#34;偷&#34;的数量
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">max</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nx">max</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nx">max</span>
	<span class="p">}</span>
	<span class="c1">//不能超过runq数组长度的一半(128)
</span><span class="c1"></span>	<span class="c1">// 最多只能&#34;偷&#34;本地工作队列一半的数量
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="p">}</span>

	<span class="c1">// 更新全局可运行队列长度
</span><span class="c1"></span>	<span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">-=</span> <span class="nx">n</span>
	<span class="c1">//返回第一个G任务,随后的才是要批量转移到本地的任务
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runq</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
	<span class="nx">n</span><span class="o">--</span>
	<span class="k">for</span> <span class="p">;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span><span class="o">--</span> <span class="p">{</span>
		<span class="c1">// 获取当前队列头
</span><span class="c1"></span>		<span class="nx">gp1</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runq</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
		<span class="c1">// 尝试将 gp1 放入 P 本地，使全局队列得到更多的执行机会
</span><span class="c1"></span>		<span class="nf">runqput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">gp1</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span><span class="c1">// 放到本地P里
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="c1">// 返回最开始获取到的队列头所指向的 goroutine
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">gp</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>代码比较简单。首先根据全局队列的可运行 goroutine 长度和 P 的总数，来计算一个数值，表示每个 P 可平均分到的 goroutine 数量。</p>
<p>然后根据函数参数中的 max 以及 P 本地队列的长度来决定把多少全局队列中的 goroutine 转移到 P 本地。</p>
<p>最后，for 循环挨个把全局队列中 n-1 个 goroutine 转移到本地，并且返回最开始获取到的队列头所指向的 goroutine，毕竟它最需要得到运行的机会。</p>
<p>把全局队列中的可运行 goroutine 转移到本地队列，给了全局队列中可运行 goroutine 运行的机会，不然全局队列中的 goroutine 一直得不到运行。</p>
<h4 id="findrunnable">findrunnable</h4>
<p>在 findrunnable 这个过程中，我们：</p>
<ol>
<li>首先检查是是否正在进行 GC，如果是则暂止当前的 m 并阻塞休眠；</li>
<li>尝试从本地队列中取 g，如果取到，则直接返回，否则继续从全局队列中找 g，如果找到则直接1. 返回；</li>
<li>检查是否存在 poll 网络的 g，如果有，则直接返回；</li>
<li>如果此时仍然无法找到 g，则从其他 P 的本地队列中偷取；</li>
<li>从其他 P 本地队列偷取的工作会执行四轮，在前两轮中只会查找 runnable 队列，后两轮则1. 会优先查找 ready 队列，如果找到，则直接返回；</li>
<li>所有的可能性都尝试过了，在准备暂止 m 之前，还要进行额外的检查；</li>
<li>首先检查此时是否是 GC mark 阶段，如果是，则直接返回 mark 阶段的 g；</li>
<li>如果仍然没有，则对当前的 p 进行快照，准备对调度器进行加锁；</li>
<li>当调度器被锁住后，我们仍然还需再次检查这段时间里是否有进入 GC，如果已经进入了 GC，则1. 回到第一步，阻塞 m 并休眠；</li>
<li>当调度器被锁住后，如果我们又在全局队列中发现了 g，则直接返回；</li>
<li>当调度器被锁住后，我们彻底找不到任务了，则归还释放当前的 P，将其放入 idle 链表中，1. 并解锁调度器；</li>
<li>当 M/P 已经解绑后，我们需要将 m 的状态切换出自旋状态，并减少 nmspinning；</li>
<li>此时我们仍然需要重新检查所有的队列；</li>
<li>如果此时我们发现有一个 P 队列不空，则立刻尝试获取一个 P，如果获取到，则回到第一步，1. 重新执行偷取工作，如果取不到，则说明系统已经满载，无需继续进行调度；</li>
<li>同样，我们还需要再检查是否有 GC mark 的 g 出现，如果有，获取 P 并回到第一步，重新1. 执行偷取工作；</li>
<li>同样，我们还需要再检查是否存在 poll 网络的 g，如果有，则直接返回；</li>
<li>终于，我们什么也没找到，暂止当前的 m 并阻塞休眠。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Finds a runnable goroutine to execute.
</span><span class="c1">// Tries to steal from other P&#39;s, get g from global queue, poll network.
</span><span class="c1">// 寻找一个可运行的 Goroutine 来执行。
</span><span class="c1">// 尝试从其他的 P 偷取、从全局队列中获取、poll 网络
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">findrunnable</span><span class="p">()</span> <span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="c1">// The conditions here and in handoffp must agree: if
</span><span class="c1"></span>	<span class="c1">// findrunnable would return a G to run, handoffp must start
</span><span class="c1"></span>	<span class="c1">// an M.
</span><span class="c1"></span>	<span class="c1">// 这里的条件与 handoffp 中的条件必须一致：
</span><span class="c1"></span>	<span class="c1">// 如果 findrunnable 将返回 G 运行，handoffp 必须启动 M.
</span><span class="c1"></span>
<span class="nx">top</span><span class="p">:</span>
	<span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="c1">//垃圾回收
</span><span class="c1"></span>	<span class="c1">//该流程依然会因串行运行时任务等待执行（gcwaiting不为0）而暂停和阻塞。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">gcstopm</span><span class="p">()</span>
		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>
	<span class="c1">//2. 获取执行终结器的G。
</span><span class="c1"></span>	<span class="c1">//获取执行终结器的G。一个终结器（或称终结函数）可以与一个对象关联，通过调用runtime.SetFinalizer函数就能产生这种关联。
</span><span class="c1"></span>	<span class="c1">//当一个对象变得不可达（未被任何其他对象引用）时，垃圾回收器在回收该对象之前，就会执行与之关联的终结函数。
</span><span class="c1"></span>	<span class="c1">//终结函数由一个专用的G执行，调度器在判定这个专用G已完成任务之后试图获取它，然后把它置为Grunnable状态并放入本地P的可运行G队列。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runSafePointFn</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">runSafePointFn</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">//fing是用来执行finalizer的goroutine
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">fingwait</span> <span class="o">&amp;&amp;</span> <span class="nx">fingwake</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">wakefing</span><span class="p">();</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">ready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// cgo 调用被终止，继续进入
</span><span class="c1"></span>	<span class="k">if</span> <span class="o">*</span><span class="nx">cgo_yield</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">asmcgocall</span><span class="p">(</span><span class="o">*</span><span class="nx">cgo_yield</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">//3. 从本地P的可运行G队列获取G。获取到就返回。
</span><span class="c1"></span>	<span class="c1">//从本地队列获取
</span><span class="c1"></span>	<span class="c1">// local runq
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="o">:=</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">);</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span>
	<span class="p">}</span>
	<span class="c1">//4. 从调度器的可运行G队列获取G。获取到就返回。
</span><span class="c1"></span>	<span class="c1">//从全局队列获取
</span><span class="c1"></span>	<span class="c1">// global runq
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//5. 从网络I/O轮询器（netpoller）获取G。
</span><span class="c1"></span>	<span class="c1">//如果netpoller已被初始化且已有过网络I/O操作，那么调度器会尝试从netpoller那里获取一个G列表。
</span><span class="c1"></span>	<span class="c1">//表头的G会作为结果返回，其余的G放入调度器的可运行G队列。
</span><span class="c1"></span>	<span class="c1">//如果netpoller还未初始化或未进行过I/O操作，就跳过。这里的获取即使没有成功也不会阻塞，那么怎么看出来是非阻塞的呢？
</span><span class="c1"></span>	<span class="c1">//因为netpoll函数带入的参数是false，它返回的是一个G的列表。
</span><span class="c1"></span>	<span class="c1">//最后要说一下的是injectglist函数，它的参数是一个G列表。
</span><span class="c1"></span>	<span class="c1">//它做的工作也很简单：将列表中的所有G从Gwaiting状态转换到Grunnable状态，然后将这些G加入调度器的可运行G队列，最后如果还有在休息的P就把这些休息的P都叫起来干活。
</span><span class="c1"></span>	<span class="c1">//这里还要注意，给injectglist函数的参数是gp.schedlink.ptr()，这其实是gp列表的第二个G。
</span><span class="c1"></span>	<span class="c1">//也就是说从网络轮询器获取的G列表的第一个G直接返回了，其余G则进入了调度器的可运行G队列。
</span><span class="c1"></span>	<span class="c1">//检查netpoll任务
</span><span class="c1"></span>	<span class="c1">// Poll network.
</span><span class="c1"></span>	<span class="c1">// This netpoll is only an optimization before we resort to stealing.
</span><span class="c1"></span>	<span class="c1">// We can safely skip it if there are no waiters or a thread is blocked
</span><span class="c1"></span>	<span class="c1">// in netpoll already. If there is any kind of logical race with that
</span><span class="c1"></span>	<span class="c1">// blocked thread (e.g. it has already returned from netpoll, but does
</span><span class="c1"></span>	<span class="c1">// not set lastpoll yet), this thread will do blocking netpoll below
</span><span class="c1"></span>	<span class="c1">// anyway.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">netpollinited</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollWaiters</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">list</span> <span class="o">:=</span> <span class="nf">netpoll</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span> <span class="p">!</span><span class="nx">list</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// non-blocking
</span><span class="c1"></span>			<span class="c1">//返回的是多任务链表,将其他任务放回全局队列
</span><span class="c1"></span>			<span class="c1">//gp.schedlink 链表结构
</span><span class="c1"></span>			<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
			<span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
			<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span><span class="c1">//将获取的G的状态从Gwaiting变为Grunnable
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
				<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//6. 从其他P的可运行G队列偷取G。不过在盗窃之前，还需要满足两个条件。所谓盗亦有道是也。
</span><span class="c1"></span>	<span class="c1">//第一个条件是：除了本地P还有其他P在干活。如果除了自己，其他P都已经休息了，那也就没必要偷了，因为他们一定比你还穷（空闲P的可运行G队列一定为空）。这时直接去第二阶段。
</span><span class="c1"></span>	<span class="c1">//虽然正在进行系统调用、cgo调用、网络I/O等待、定时等待的G会与P分离导致P处于空闲状态，但是这些G变回Grunnable状态后会加入到调度器的可运行G队列，而不会回到本地P的可运行G队列。所以也没必要去P那里偷。
</span><span class="c1"></span>	<span class="c1">// Steal work from other P&#39;s.
</span><span class="c1"></span>	<span class="nx">procs</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span><span class="c1">// 获得 p 的数量
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">==</span> <span class="nx">procs</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
		<span class="c1">// Either GOMAXPROCS=1 or everybody, except for us, is idle already.
</span><span class="c1"></span>		<span class="c1">// New work can appear from returning syscall/cgocall, network or timers.
</span><span class="c1"></span>		<span class="c1">// Neither of that submits to local run queues, so no point in stealing.
</span><span class="c1"></span>		<span class="c1">// GOMAXPROCS = 1 或除了我们之外的所有人都已经 idle 了。
</span><span class="c1"></span>		<span class="c1">// 新的 work 可能出现在 syscall/cgocall/网络/timer返回时
</span><span class="c1"></span>		<span class="c1">// 它们均没有提交到本地运行队列，因此偷取没有任何意义。
</span><span class="c1"></span>		<span class="k">goto</span> <span class="nx">stop</span>
	<span class="p">}</span>
	<span class="c1">//第二个条件是：当前M处于自旋状态，或者处于自旋状态的M的两倍比正在干活的P还要少，也就是说干活的P多，自旋的M少。
</span><span class="c1"></span>	<span class="c1">//如果当前P没有自旋，并且干活的P还少于自旋M的两倍，那也没必要偷，直接去第二 阶段。
</span><span class="c1"></span>	<span class="c1">//这主要是为了控制自旋M的数量，因为过多的自旋M会消耗大量CPU资源。
</span><span class="c1"></span>	<span class="c1">// If number of spinning M&#39;s &gt;= number of busy P&#39;s, block.
</span><span class="c1"></span>	<span class="c1">// This is necessary to prevent excessive CPU consumption
</span><span class="c1"></span>	<span class="c1">// when GOMAXPROCS&gt;&gt;1 but the program parallelism is low.
</span><span class="c1"></span>	<span class="c1">// 如果自旋状态下 m 的数量 &gt;= busy 状态下 p 的数量，直接进入阻塞
</span><span class="c1"></span>	<span class="c1">// 该步骤是有必要的，它用于当 GOMAXPROCS&gt;&gt;1 时但程序的并行机制很慢时
</span><span class="c1"></span>	<span class="c1">// 昂贵的 CPU 消耗。
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="o">&amp;&amp;</span> <span class="mi">2</span><span class="o">*</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nx">procs</span><span class="o">-</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="nx">stop</span>
	<span class="p">}</span>
	<span class="c1">//如果满足了以上两个条件，就把当前M置于自旋状态，并开始偷取G。
</span><span class="c1"></span>	<span class="c1">//调度器会使用一种伪随机算法在全局P列表中选取P，然后试着从它的可运行G队列中偷一半的G到本地P的可运行G队列。
</span><span class="c1"></span>	<span class="c1">//选P偷G的过程会重复多次，成功即停止。如果成功，返回偷到的第一个G。注意，偷取G的过程中也会因串行运行时任务等待执行（gcwaiting不为0）而停止调度并阻塞。
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
		<span class="c1">// 设置自旋状态为 true
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="c1">// 自旋状态数加 1
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">//随机挑一个P,偷些任务
</span><span class="c1"></span>	<span class="c1">//stealOrder是一个序列随机数生成器，它会返回一个包含很多随机数的容器，也就是enum。enum.next就是取下一个随机数，enum.position就是真正的随机数。
</span><span class="c1"></span>	<span class="c1">//所以allp[enum.position]就是从全局P队列中随机选一个P。runqsteal是真正执行偷G工作的函数。
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">enum</span> <span class="o">:=</span> <span class="nx">stealOrder</span><span class="p">.</span><span class="nf">start</span><span class="p">(</span><span class="nf">fastrand</span><span class="p">());</span> <span class="p">!</span><span class="nx">enum</span><span class="p">.</span><span class="nf">done</span><span class="p">();</span> <span class="nx">enum</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">top</span>
			<span class="p">}</span>
			<span class="c1">//如果尝试次数太多,连目标P.runnext都偷,这是饿得很了
</span><span class="c1"></span>			<span class="nx">stealRunNextG</span> <span class="o">:=</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">2</span> <span class="c1">// first look for ready queues with more than 1 g
</span><span class="c1"></span>			 <span class="c1">// 在这里开始针对P进行偷取操作
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">runqsteal</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">enum</span><span class="p">.</span><span class="nf">position</span><span class="p">()],</span> <span class="nx">stealRunNextG</span><span class="p">);</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nx">stop</span><span class="p">:</span>
	<span class="c1">//1. 获取执行GC标记任务的G。如果恰巧正处于GC标记阶段，且本地P可用于GC标记任务。
</span><span class="c1"></span>	<span class="c1">//那么调度器会把本地P持有的GC标记专用G置为Grunnable状态并返回这个G。
</span><span class="c1"></span>	<span class="c1">//检查GC MarkWorker
</span><span class="c1"></span>	<span class="c1">// We have nothing to do. If we&#39;re in the GC mark phase, can
</span><span class="c1"></span>	<span class="c1">// safely scan and blacken objects, and have work to do, run
</span><span class="c1"></span>	<span class="c1">// idle-time marking rather than give up the P.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">=</span> <span class="nx">gcMarkWorkerIdleMode</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="c1">//获取用于GC标记的专用G
</span><span class="c1"></span>		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span><span class="c1">//将gp并发安全的从Gwaiting状态转为Grunnable状态
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
			<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// wasm only:
</span><span class="c1"></span>	<span class="c1">// If a callback returned and no other goroutine is awake,
</span><span class="c1"></span>	<span class="c1">// then pause execution until a callback was triggered.
</span><span class="c1"></span>	<span class="c1">// 仅限于 wasm
</span><span class="c1"></span>	<span class="c1">// 如果一个回调返回后没有其他 Goroutine 是苏醒的
</span><span class="c1"></span>	<span class="c1">// 则暂停执行直到回调被触发。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">beforeIdle</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// At least one goroutine got woken.
</span><span class="c1"></span>		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>
	<span class="c1">//2. 再次从调度器的可运行G队列获取G。如果这次还是获取不到，就解除本地P与当前M的关联，并将该P放入调度器的空闲P列表。在这一步之前会将全局P列表（allp）复制一份，称为快照。
</span><span class="c1"></span>	<span class="c1">// Before we drop our P, make a snapshot of the allp slice,
</span><span class="c1"></span>	<span class="c1">// which can change underfoot once we no longer block
</span><span class="c1"></span>	<span class="c1">// safe-points. We don&#39;t need to snapshot the contents because
</span><span class="c1"></span>	<span class="c1">// everything up to cap(allp) is immutable.
</span><span class="c1"></span>	<span class="c1">// 放弃当前的 P 之前，对 allp 做一个快照
</span><span class="c1"></span>	<span class="c1">// 一旦我们不再阻塞在 safe-point 时候，可以立刻在下面进行修改
</span><span class="c1"></span>	<span class="nx">allpSnapshot</span> <span class="o">:=</span> <span class="nx">allp</span><span class="c1">//快照
</span><span class="c1"></span>
	<span class="c1">// return P and block
</span><span class="c1"></span>	<span class="c1">// 准备归还 p，对调度器加锁
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">//再次检查垃圾回收状态
</span><span class="c1"></span>	<span class="c1">// 进入了 gc，回到顶部暂止 m
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runSafePointFn</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>
	<span class="c1">//再次尝试全局队列
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">//从调度器的可运行G列表获取G
</span><span class="c1"></span>		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">// 当前工作线程解除与 p 之间的绑定，准备去休眠
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">releasep</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">_p_</span> <span class="p">{</span><span class="c1">//从调度器的可运行G列表获取G
</span><span class="c1"></span>		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;findrunnable: wrong p&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">pidleput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="c1">//将P放入调度器的空闲P列表
</span><span class="c1"></span>	<span class="c1">// 完成归还，解锁
</span><span class="c1"></span>	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// Delicate dance: thread transitions from spinning to non-spinning state,
</span><span class="c1"></span>	<span class="c1">// potentially concurrently with submission of new goroutines. We must
</span><span class="c1"></span>	<span class="c1">// drop nmspinning first and then check all per-P queues again (with
</span><span class="c1"></span>	<span class="c1">// #StoreLoad memory barrier in between). If we do it the other way around,
</span><span class="c1"></span>	<span class="c1">// another thread can submit a goroutine after we&#39;ve checked all run queues
</span><span class="c1"></span>	<span class="c1">// but before we drop nmspinning; as the result nobody will unpark a thread
</span><span class="c1"></span>	<span class="c1">// to run the goroutine.
</span><span class="c1"></span>	<span class="c1">// If we discover new work below, we need to restore m.spinning as a signal
</span><span class="c1"></span>	<span class="c1">// for resetspinning to unpark a new worker thread (because there can be more
</span><span class="c1"></span>	<span class="c1">// than one starving goroutine). However, if after discovering new work
</span><span class="c1"></span>	<span class="c1">// we also observe no idle Ps, it is OK to just park the current thread:
</span><span class="c1"></span>	<span class="c1">// the system is fully loaded so no spinning threads are required.
</span><span class="c1"></span>	<span class="c1">// Also see &#34;Worker thread parking/unparking&#34; comment at the top of the file.
</span><span class="c1"></span>	<span class="c1">// 这里要非常小心:
</span><span class="c1"></span>	<span class="c1">// 线程从自旋到非自旋状态的转换，可能与新 Goroutine 的提交同时发生。
</span><span class="c1"></span>	<span class="c1">// 我们必须首先丢弃 nmspinning，然后再次检查所有的 per-P 队列（并在期间伴随 #StoreLoad 内存屏障）
</span><span class="c1"></span>	<span class="c1">// 如果反过来，其他线程可以在我们检查了所有的队列、然后提交一个 Goroutine、再丢弃了 nmspinning
</span><span class="c1"></span>	<span class="c1">// 进而导致无法复始一个线程来运行那个 Goroutine 了。
</span><span class="c1"></span>	<span class="c1">// 如果我们发现下面的新 work，我们需要恢复 m.spinning 作为重置的信号，
</span><span class="c1"></span>	<span class="c1">// 以取消暂止新的工作线程（因为可能有多个 starving 的 Goroutine）。
</span><span class="c1"></span>	<span class="c1">// 但是，如果在发现新 work 后我们也观察到没有空闲 P，可以暂停当前线程
</span><span class="c1"></span>	<span class="c1">// 因为系统已满载，因此不需要自旋线程。
</span><span class="c1"></span>	<span class="nx">wasSpinning</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
		<span class="c1">// m 即将睡眠，不再处于自旋
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="k">if</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;findrunnable: negative nmspinning&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// check all runqueues once again
</span><span class="c1"></span>	<span class="c1">//3. 从全局P列表中的每个P的可运行G队列获取G。这里要迭代的全局P列表就是上一步的快照。
</span><span class="c1"></span>	<span class="c1">//只要发现某个P的可运行G队列不为空，就从调度器的空闲P列表中取出一个P。判定其可用后与当前M关联在一起，然后返回第一阶段重新搜索可运行的G。如果所有P的可运行队列都是空，就继续后面的搜索。
</span><span class="c1"></span>	<span class="c1">//这一步的意义是：正在干活的P还有活没干完，然而有些P却在休息，这怎么能忍？于是叫醒一个休息的P，然后给它找一个活干。
</span><span class="c1"></span>	<span class="c1">//再次检查所有P任务队列
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_p_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allpSnapshot</span> <span class="p">{</span>
		<span class="c1">// 再次检查所有的 runqueue
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 重新获取 p
</span><span class="c1"></span>			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="c1">//绑定一个空闲P,回到头部尝试偷取任务
</span><span class="c1"></span>			<span class="nx">_p_</span> <span class="p">=</span> <span class="nf">pidleget</span><span class="p">()</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="c1">// 如果能获取到 p
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="c1">// 绑定 p
</span><span class="c1"></span>				<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
				<span class="c1">// 如果此前已经被切换为自旋
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">wasSpinning</span> <span class="p">{</span>
					<span class="c1">// 重新切换回非自旋
</span><span class="c1"></span>					<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">true</span>
					<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="c1">// 这时候是有 work 的，回到顶部重新 find g
</span><span class="c1"></span>				<span class="k">goto</span> <span class="nx">top</span>
			<span class="p">}</span>
			<span class="c1">// 看来没有 idle 的 p，不需要重新 find g 了
</span><span class="c1"></span>			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//4. 再次获取执行GC标记任务的G。如果正好处于GC标记阶段，且GC标记任务相关的全局资源可用。调度器就从空闲P列表中取出一个P，如果这个P持有GC标记专用G，就将该P与当前M关联，并从第二阶段开始继续执行。否则该P会被重新放回空闲P列表。
</span><span class="c1"></span>	<span class="c1">// Check for idle-priority GC work again.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nx">_p_</span> <span class="p">=</span> <span class="nf">pidleget</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">pidleput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
			<span class="nx">_p_</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">wasSpinning</span> <span class="p">{</span>
				<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// Go back to idle GC check.
</span><span class="c1"></span>			<span class="k">goto</span> <span class="nx">stop</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//5. 再次从网络I/O轮询器（netpoller）处获取G。如果netpoller已被初始化，并且有过网络I/O操作。
</span><span class="c1"></span>	<span class="c1">//调度器会再次试图从netpoller那里获取一个G列表。注意，这里的获取是阻塞的，你可以看到这里netpoll函数带入的参数是true。
</span><span class="c1"></span>	<span class="c1">//只有当netpoller那里有可用G时，阻塞才会解除。如果netpoller还未被初始化或没进行过网络I/O操作，此步骤会跳过。
</span><span class="c1"></span>	<span class="c1">//此外这一步和第4步还有一点差别：只有当获取到一个空闲P的时候，才将获取的G返回，否则只是将获取的所有G都加入到调度器的可运行G队列。
</span><span class="c1"></span>	<span class="c1">//这是因为如果没有空闲的P，那么获得了G也执行不了，当前M还是只能先停下，也就没必要为这个M返回一个G了。
</span><span class="c1"></span>	<span class="c1">// poll network
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">netpollinited</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollWaiters</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xchg64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;findrunnable: netpoll with p&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;findrunnable: netpoll with spinning&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">list</span> <span class="o">:=</span> <span class="nf">netpoll</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// block until new work is available
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nf">nanotime</span><span class="p">()))</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">list</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="nx">_p_</span> <span class="p">=</span> <span class="nf">pidleget</span><span class="p">()</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
				<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
				<span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
				<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
					<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
			<span class="p">}</span>
			<span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//如果经历以上强劲的搜索仍然找不到一个可运行的G，那么也就只好停止当前M了。等到该M再次被唤醒的时候，它还会从第一阶段开始继续搜索。
</span><span class="c1"></span>	<span class="c1">//一无所得 休眠
</span><span class="c1"></span>	<span class="nf">stopm</span><span class="p">()</span>
	<span class="k">goto</span> <span class="nx">top</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这部分也是最能说明 M 找工作的锲而不舍精神：尽力去各个运行队列中寻找 goroutine，如果实在找不到则进入睡眠状态，等待有工作时，被其他 M 唤醒。</p>
<p>先获取当前指向的 g，也就是 g0，然后拿到其绑定的 p，即 <em>p</em>。</p>
<p>首先再次尝试从 <em>p</em> 本地队列获取 goroutine，如果没有获取到，则尝试从全局队列获取。如果还没有获取到就会尝试去“偷”了，这也是没有办法的事。</p>
<p>不过，在偷之前，先看大的局势。如果其他所有的 P 都处于空闲状态，就说明其他 P 肯定没有工作可做，就没必要再去偷了，毕竟“地主家也没有余粮了”，跳到 stop 部分。接着再看下当前正在“偷工作”的线程数量“太多了”，就没必要扎堆了，这么多人，竞争肯定大，工作肯定不好找，也不好偷。</p>
<p>在真正的“偷”工作之前，把自己的自旋状态设置为 true，全局自旋数量加 1。</p>
<p>终于到了“偷工作”的部分了，好紧张！整个过程由两层 for 循环组成，外层控制尝试偷的次数，内层控制“偷”的顺序，并真正的去“偷”。实际上，内层会遍历所有的 P，因此，整体看来，会尝试 4 次扫遍所有的 P，并去“偷工作”，是不是非常有毅力！</p>
<p>第二层的循环并不是每次都按一个固定的顺序去遍历所有的 P，这样不太科学，而是使用了一些方法，“随机”地遍历。具体是使用了下面这个变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">stealOrder</span> <span class="nx">randomOrder</span>

<span class="kd">type</span> <span class="nx">randomOrder</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">count</span>    <span class="kt">uint32</span>
    <span class="nx">coprimes</span> <span class="p">[]</span><span class="kt">uint32</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>初始化的时候会给 count 赋一个值，例如 8，根据 count 计算出 coprimes，里面的元素是小于 count 的值，且和 8 互质，算出来是：[1, 3, 5, 7]。</p>
<p>第二层循环，开始随机给一个值，例如 2，则第一个访问的 P 就是 P2；从 coprimes 里取出索引为 2 的值为 5，那么，第二个访问的 P 索引就是 2+5=7；依此类推，第三个就是 7+5=12，和 count 做一个取余操作，即 12%8=4……</p>
<p>在最后一次遍历所有的 P 的过程中，连人家的 runnext 也要尝试偷过来，毕竟前三次的失败经验证明，工作太不好“偷”了，民不聊生啊，只能做得绝一点了，stealRunNextG 控制是否要打 runnext 的主意：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">stealRunNextG</span> <span class="o">:=</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">2</span>
</code></pre></td></tr></table>
</div>
</div><p>确定好准备偷的对象 allp[enum.position() 之后，调用 runqsteal(<em>p</em>, allp[enum.position()], stealRunNextG) 函数执行。</p>
<p>回到 findrunnable 函数，经过上述三个层面的“偷窃”过程，我们仍然没有找到工作，真惨！于是就走到了 stop 这个代码块。</p>
<p>先上锁，因为要将 P 放到全局空闲 P 链表里去。在这之前还不死心，再瞧一下全局队列里是否有工作，如果有，再去尝试偷全局。</p>
<p>如果没有，就先解除当前工作线程和当前 P 的绑定关系(releasep).这之后，将其放入全局空闲 P 列表(pidleput),接下来就要真正地准备休眠了，但是仍然不死心！还要再查看一次所有的 P 是否有工作，如果发现任何一个 P 有工作的话（判断 P 的本地队列不空），就先从全局空闲 P 链表里先拿到一个 P(pidleget),做完这些之后，再次进入 top 代码段，再走一遍之前找工作的过程.最后休眠.</p>
<p>当其他线程发现有工作要做时，就会先找到空闲的 m，再通过 m.park 字段来唤醒本线程。唤醒之后，回到 findrunnable 函数，继续寻找 goroutine，找到后返回 schedule 函数，然后就会去运行找到的 goroutine。</p>
<h4 id="runqsteal">runqsteal</h4>
<p>只有当本地和全局队列都为空时,才会考虑去检查其他P任务队列.这个优先级最低,因为会影响目标P的执行(必须使用原子操作)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Steal half of elements from local runnable queue of p2
</span><span class="c1">// and put onto local runnable queue of p.
</span><span class="c1">// Returns one of the stolen elements (or nil if failed)
</span><span class="c1">//尝试从p2偷取一半任务存入p本地队列
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runqsteal</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">p2</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">stealRunNextG</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
	<span class="c1">// 队尾
</span><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span>
	<span class="c1">// 从 p2 偷取工作，放到 _p_.runq 的队尾
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="nf">runqgrab</span><span class="p">(</span><span class="nx">p2</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">stealRunNextG</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="c1">//返回尾部的G任务
</span><span class="c1"></span>	<span class="nx">n</span><span class="o">--</span>
	<span class="c1">// 找到最后一个 g，准备返回
</span><span class="c1"></span>	<span class="c1">//随机数取模确定目标P
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[(</span><span class="nx">t</span><span class="o">+</span><span class="nx">n</span><span class="p">)</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">ptr</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 说明只偷了一个 g
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">gp</span>
	<span class="p">}</span>
	<span class="c1">// 队列头
</span><span class="c1"></span>	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with consumers
</span><span class="c1"></span>	<span class="c1">// 判断是否偷太多了
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="o">-</span><span class="nx">h</span><span class="o">+</span><span class="nx">n</span> <span class="o">&gt;=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runqsteal: runq overflow&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">//调整目标队列尾部状态
</span><span class="c1"></span>	<span class="c1">// 更新队尾，将偷来的工作加入队列
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">,</span> <span class="nx">t</span><span class="o">+</span><span class="nx">n</span><span class="p">)</span> <span class="c1">// store-release, makes the item available for consumption
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">gp</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>调用 runqgrab 从 p2 偷走它一半的工作放到 <em>p</em> 本地：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">n</span> <span class="o">:=</span> <span class="nf">runqgrab</span><span class="p">(</span><span class="nx">p2</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">stealRunNextG</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>runqgrab 函数将从 p2 偷来的工作放到以 t 为地址的数组里，数组就是 <em>p</em>.runq。 我们知道，t 是 <em>p</em>.runq 的队尾，因此这行代码表达的真正意思是将从 p2 偷来的工作，神不知，鬼不觉地放到 <em>p</em>.runq 的队尾，之后，再悄悄改一下 <em>p</em>.runqtail 就把这些偷来的工作据为己有了。</p>
<p>接着往下看，返回的 n 表示偷到的工作数量。先将 n 自减 1，目的是把第 n 个工作（也就是 g）直接返回，如果这时候 n 变成 0 了，说明就只偷到了一个 g，那就直接返回。否则，将队尾往后移动 n，把偷来的工作合法化，简直完美！</p>
<h4 id="runqgrab">runqgrab</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Grabs a batch of goroutines from _p_&#39;s runnable queue into batch.
</span><span class="c1">// Batch is a ring buffer starting at batchHead.
</span><span class="c1">// Returns number of grabbed goroutines.
</span><span class="c1">// Can be executed by any P.
</span><span class="c1">// 从 _p_ 批量获取可运行 goroutine，放到 batch 数组里
</span><span class="c1">// batch 是一个环，起始于 batchHead
</span><span class="c1">// 返回偷的数量，返回的 goroutine 可被任何 P 执行
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runqgrab</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">batch</span> <span class="o">*</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="nx">guintptr</span><span class="p">,</span> <span class="nx">batchHead</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">stealRunNextG</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">uint32</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">//计算批量转移任务数量
</span><span class="c1"></span>		<span class="c1">// 队列头
</span><span class="c1"></span>		<span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with other consumers
</span><span class="c1"></span>		<span class="c1">// 队列尾
</span><span class="c1"></span>		<span class="nx">t</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with the producer
</span><span class="c1"></span>		<span class="c1">// g 的数量
</span><span class="c1"></span>		<span class="nx">n</span> <span class="o">:=</span> <span class="nx">t</span> <span class="o">-</span> <span class="nx">h</span>
		<span class="c1">// 取一半
</span><span class="c1"></span>		<span class="nx">n</span> <span class="p">=</span> <span class="nx">n</span> <span class="o">-</span> <span class="nx">n</span><span class="o">/</span><span class="mi">2</span>
		<span class="c1">//如果没有,那就尝试偷runnext
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">stealRunNextG</span> <span class="p">{</span>
				<span class="c1">// Try to steal from _p_.runnext.
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">next</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">;</span> <span class="nx">next</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="o">==</span> <span class="nx">_Prunning</span> <span class="p">{</span>
						<span class="c1">// Sleep to ensure that _p_ isn&#39;t about to run the g
</span><span class="c1"></span>						<span class="c1">// we are about to steal.
</span><span class="c1"></span>						<span class="c1">// The important use case here is when the g running
</span><span class="c1"></span>						<span class="c1">// on _p_ ready()s another g and then almost
</span><span class="c1"></span>						<span class="c1">// immediately blocks. Instead of stealing runnext
</span><span class="c1"></span>						<span class="c1">// in this window, back off to give _p_ a chance to
</span><span class="c1"></span>						<span class="c1">// schedule runnext. This will avoid thrashing gs
</span><span class="c1"></span>						<span class="c1">// between different Ps.
</span><span class="c1"></span>						<span class="c1">// A sync chan send/recv takes ~50ns as of time of
</span><span class="c1"></span>						<span class="c1">// writing, so 3us gives ~50x overshoot.
</span><span class="c1"></span>						<span class="c1">// 这里是为了防止 _p_ 执行当前 g，并且马上就要阻塞，所以会马上执行 runnext，
</span><span class="c1"></span>                    	<span class="c1">// 这个时候偷就没必要了，因为让 g 在 P 之间&#34;游走&#34;不太划算，
</span><span class="c1"></span>                    	<span class="c1">// 就不偷了，给他们一个机会。
</span><span class="c1"></span>                    	<span class="c1">// channel 一次同步的的接收发送需要 50ns 左右，因此 3us 差不多给了他们 50 次机会了，做得还是不错的
</span><span class="c1"></span>						<span class="k">if</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;windows&#34;</span> <span class="p">{</span>
							<span class="nf">usleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
						<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
							<span class="c1">// On windows system timer granularity is
</span><span class="c1"></span>							<span class="c1">// 1-15ms, which is way too much for this
</span><span class="c1"></span>							<span class="c1">// optimization. So just yield.
</span><span class="c1"></span>							<span class="nf">osyield</span><span class="p">()</span>
						<span class="p">}</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">!</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="nx">next</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">continue</span>
					<span class="p">}</span>
					<span class="c1">// 真的偷走了 next
</span><span class="c1"></span>					<span class="nx">batch</span><span class="p">[</span><span class="nx">batchHead</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">batch</span><span class="p">))]</span> <span class="p">=</span> <span class="nx">next</span>
					<span class="c1">// 返回偷的数量，只有 1 个
</span><span class="c1"></span>					<span class="k">return</span> <span class="mi">1</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="c1">// 没偷到
</span><span class="c1"></span>			<span class="k">return</span> <span class="mi">0</span>
		<span class="p">}</span>
		<span class="c1">//数据异常,不可能超过一半值,重试
</span><span class="c1"></span>		<span class="c1">// 如果 n 这时变得太大了，重新来一遍了，不能偷的太多，做得太过分了
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// read inconsistent h and t
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">//转移任务
</span><span class="c1"></span>		<span class="c1">// 将 g 放置到 bacth 中
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">g</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[(</span><span class="nx">h</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))]</span>
			<span class="nx">batch</span><span class="p">[(</span><span class="nx">batchHead</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">batch</span><span class="p">))]</span> <span class="p">=</span> <span class="nx">g</span>
		<span class="p">}</span>
		<span class="c1">//修改源P队列状态
</span><span class="c1"></span>		<span class="c1">//失败重试.因为没有修改源和目标队列位置状态,所以没有影响
</span><span class="c1"></span>		<span class="c1">// 工作被偷走了，更新一下队列头指针
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CasRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="o">+</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// cas-release, commits consume
</span><span class="c1"></span>			<span class="k">return</span> <span class="nx">n</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>外层直接就是一个无限循环，先用原子操作取出 p 的队列头和队列尾，算出一半的 g 的数量，如果 n == 0，说明地主家也没有余粮，这时看 stealRunNextG 的值。如果为假，说明不偷 runnext，那就直接返回 0，啥也没偷到；如果为真，则要尝试偷一下 runnext。</p>
<p>先判断 runnext 不为空，那就真的准备偷了。不过在这之前，要先休眠 3 us。这是为了防止 p 正在执行当前的 g，马上就要阻塞（可能是向一个非缓冲的 channel 发送数据，没有接收者），之后会马上执行 runnext。这个时候偷就没必要了，因为 runnext 马上就要执行了，偷走它还不是要去执行，那何必要偷呢？大家的愿望就是提高效率，这样让 g 在 P 之间&quot;游走&quot;不太划算，索性先不偷了，给他们一个机会。channel 一次同步的的接收或发送需要 50ns 左右，因此休眠 3us 差不多给了他们 50 次机会了，做得还是挺厚道的。</p>
<p>继续看，再次判断 n 是否小于等于 p.runq 长度的一半，因为这个时候很可能 p 也被其他线程偷了，它的 p.runq 就没那么多工作了，这个时候就不能偷这么多了，要重新再走一次循环。</p>
<p>最后一个 for 循环，将 p.runq 里的 g 放到 batch 数组里。使用原子操作更新 p 的队列头指针，往后移动 n 个位置.</p>
<h4 id="自旋状态">自旋状态</h4>
<p>自旋状态标示了M的一种工作状态。</p>
<ol>
<li>M处于自旋状态意味着它还没有找到可运行的G来运行。</li>
<li>无论是找到可运行的G，还是因未找到而被停止，当前M都会退出自旋状态。</li>
<li>一般情况下，运行时系统中至少会有一个自旋的M。</li>
<li>除非发现没有自旋的M，调度器不会新建或恢复一个M去运行新的G。</li>
<li>新建或恢复一个M时，它最初总是处于自旋状态。</li>
</ol>
<h3 id="g的运行与退出">G的运行与退出</h3>
<h4 id="execute">execute</h4>
<p>由 runtime.execute 函数执行获取的 Goroutine，做好准备工作后，它会通过 runtime.gogo 将 Goroutine 调度到当前线程上。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Schedules gp to run on the current M.
</span><span class="c1">// If inheritTime is true, gp inherits the remaining time in the
</span><span class="c1">// current time slice. Otherwise, it starts a new time slice.
</span><span class="c1">// Never returns.
</span><span class="c1">//
</span><span class="c1">// Write barriers are allowed because this is called immediately after
</span><span class="c1">// acquiring a P in several places.
</span><span class="c1">//
</span><span class="c1">//go:yeswritebarrierrec
</span><span class="c1">// 调度 gp 在当前 M 上运行
</span><span class="c1">// 如果 inheritTime 为真，gp 执行当前的时间片
</span><span class="c1">// 否则，开启一个新的时间片
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="c1">// 将 gp 的状态改为 running
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waitsince</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">inheritTime</span> <span class="p">{</span>
		<span class="c1">// 调度器调度次数增加 1
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">schedtick</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="c1">// 将 gp 和 m 关联起来
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="p">=</span> <span class="nx">gp</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span>

	<span class="c1">// Check whether the profiler needs to be turned on or off.
</span><span class="c1"></span>	<span class="nx">hz</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">profilehz</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">profilehz</span> <span class="o">!=</span> <span class="nx">hz</span> <span class="p">{</span>
		<span class="nf">setThreadCPUProfiler</span><span class="p">(</span><span class="nx">hz</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="c1">// GoSysExit has to happen when we have a P, but before GoStart.
</span><span class="c1"></span>		<span class="c1">// So we emit it here.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sysblocktraced</span> <span class="p">{</span>
			<span class="nf">traceGoSysExit</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sysexitticks</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">traceGoStart</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// gogo 完成从 g0 到 gp 真正的切换
</span><span class="c1"></span>    <span class="c1">// CPU 执行权的转让以及栈的切换
</span><span class="c1"></span>    <span class="c1">// 执行流的切换从本质上来说就是 CPU 寄存器以及函数调用栈的切换，
</span><span class="c1"></span>    <span class="c1">// 然而不管是 go 还是 c 这种高级语言都无法精确控制 CPU 寄存器的修改，
</span><span class="c1"></span>    <span class="c1">// 因而高级语言在这里也就无能为力了，只能依靠汇编指令来达成目的
</span><span class="c1"></span>	<span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>将 gp 的状态改为 _Grunning，将 m 和 gp 相互关联起来。最后，调用 gogo 完成从 g0 到 gp 的切换，CPU 的执行权将从 g0 转让到 gp。 gogo 函数用汇编语言写成，原因如下：</p>
<p>gogo 函数也是通过汇编语言编写的，这里之所以需要使用汇编，是因为 goroutine 的调度涉及不同执行流之间的切换。</p>
<p>前面我们在讨论操作系统切换线程时已经看到过，执行流的切换从本质上来说就是 CPU 寄存器以及函数调用栈的切换，然而不管是 go 还是 c 这种高级语言都无法精确控制 CPU 寄存器，因而高级语言在这里也就无能为力了，只能依靠汇编指令来达成目的。</p>
<p>继续看 gogo 函数的实现，gogo函数从g0栈切换到G栈,然后用一个JMP指令进入G任务函数代码,传入 &amp;gp.sched 参数，源码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">gogo</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">NOSPLIT</span><span class="p">,</span> <span class="err">$</span><span class="mi">8</span><span class="o">-</span><span class="mi">4</span>
	<span class="c1">// 0(FP) 表示第一个参数，即 buf = &amp;gp.sched
</span><span class="c1"></span>	<span class="nx">MOVL</span> <span class="nx">buf</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">BX</span>     <span class="c1">// 获取调度信息
</span><span class="c1"></span>	<span class="nx">MOVL</span> <span class="nf">gobuf_g</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">DX</span>
	<span class="nx">MOVL</span> <span class="mi">0</span><span class="p">(</span><span class="nx">DX</span><span class="p">),</span> <span class="nx">CX</span>         <span class="c1">// 保证 Goroutine 不为空
</span><span class="c1"></span>	<span class="c1">//get_tls 将 tls 保存到 CX 寄存器
</span><span class="c1"></span>	<span class="nf">get_tls</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
	<span class="c1">// 将 g 放入到 tls[0]
</span><span class="c1"></span>	<span class="c1">// 这样，当下次再调用 get_tls 时，取出的就是 gp，而不再是 g0，这一行完成从 g0 栈切换到 gp。
</span><span class="c1"></span>    <span class="c1">// 把要运行的 g 的指针放入线程本地存储，这样后面的代码就可以通过线程本地存储
</span><span class="c1"></span>    <span class="c1">// 获取到当前正在执行的 goroutine 的 g 结构体对象，从而找到与之关联的 m 和 p
</span><span class="c1"></span>    <span class="c1">// 运行这条指令之前，线程本地存储存放的是 g0 的地址
</span><span class="c1"></span>	<span class="nx">MOVL</span> <span class="nx">DX</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
	<span class="c1">// 把 CPU 的 SP 寄存器设置为 sched.sp，完成了栈的切换
</span><span class="c1"></span>	<span class="nx">MOVL</span> <span class="nf">gobuf_sp</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">SP</span>  <span class="c1">// 将 runtime.goexit 函数的 PC 恢复到 SP 中
</span><span class="c1"></span>	<span class="c1">// 恢复调度上下文到CPU相关寄存器
</span><span class="c1"></span>	<span class="nx">MOVL</span> <span class="nf">gobuf_ret</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">AX</span>
	<span class="nx">MOVL</span> <span class="nf">gobuf_ctxt</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">DX</span>
	<span class="c1">// 清空 sched 的值，因为我们已把相关值放入 CPU 对应的寄存器了，不再需要，这样做可以少 GC 的工作量
</span><span class="c1"></span>	<span class="nx">MOVL</span> <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nf">gobuf_sp</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
	<span class="nx">MOVL</span> <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nf">gobuf_ret</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
	<span class="nx">MOVL</span> <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nf">gobuf_ctxt</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
	<span class="c1">// 把 sched.pc 值放入 BX 寄存器
</span><span class="c1"></span>	<span class="nx">MOVL</span> <span class="nf">gobuf_pc</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BX</span>  <span class="c1">// 获取待执行函数的程序计数器
</span><span class="c1"></span>	<span class="c1">// JMP 把 BX 寄存器的包含的地址值放入 CPU 的 IP 寄存器，于是，CPU 跳转到该地址继续执行指令
</span><span class="c1"></span>	<span class="nx">JMP</span>  <span class="nx">BX</span>                <span class="c1">// 开始执行
</span></code></pre></td></tr></table>
</div>
</div><p>该函数的实现非常巧妙，它从 runtime.gobuf 中取出了 runtime.goexit 的程序计数器和待执行函数的程序计数器，其中：</p>
<ul>
<li>runtime.goexit 的程序计数器被放到了栈 SP 上；</li>
<li>待执行函数的程序计数器被放到了寄存器 BX 上；</li>
</ul>
<p>Go 语言的调用惯例，正常的函数调用都会使用 CALL 指令，该指令会将调用方的返回地址加入栈寄存器 SP 中，然后跳转到目标函数；当目标函数返回后，会从栈中查找调用的地址并跳转回调用方继续执行剩下的代码。</p>
<p>runtime.gogo 就利用了 Go 语言的调用惯例成功模拟这一调用过程，通过以下几个关键指令模拟 CALL 的过程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">MOVL</span> <span class="nf">gobuf_sp</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">SP</span>  <span class="c1">// 将 runtime.goexit 函数的 PC 恢复到 SP 中
</span><span class="c1"></span>	<span class="nx">MOVL</span> <span class="nf">gobuf_pc</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BX</span>  <span class="c1">// 获取待执行函数的程序计数器
</span><span class="c1"></span>	<span class="nx">JMP</span>  <span class="nx">BX</span>                <span class="c1">// 开始执行
</span></code></pre></td></tr></table>
</div>
</div><p>gp 执行完后，RET 指令弹出 goexit 函数地址（实际上是 funcPC(goexit)+1），CPU 跳转到 goexit 的第二条指令继续执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/asm_amd64.s
</span><span class="c1"></span>
<span class="c1">// The top-most function running on a goroutine
</span><span class="c1">// returns to goexit+PCQuantum.
</span><span class="c1"></span><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">goexit</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span><span class="nx">NOSPLIT</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">0</span>
    <span class="nx">BYTE</span>    <span class="err">$</span><span class="mh">0x90</span>    <span class="c1">// NOP
</span><span class="c1"></span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">goexit1</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>    <span class="c1">// does not return
</span><span class="c1"></span>    <span class="c1">// traceback from goexit1 must hit code range of goexit
</span><span class="c1"></span>    <span class="nx">BYTE</span>    <span class="err">$</span><span class="mh">0x90</span>    <span class="c1">// NOP
</span></code></pre></td></tr></table>
</div>
</div><h4 id="goexit">goexit</h4>
<p>gp 执行完后直接调用 runtime·goexit1：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 完成当前 Goroutine 的执行
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">goexit1</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 开始收尾工作
</span><span class="c1"></span>	<span class="nf">mcall</span><span class="p">(</span><span class="nx">goexit0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 切换到 g0 栈，执行 fn(g)
</span><span class="c1">// Fn 不能返回
</span><span class="c1"></span><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">mcall</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">NOSPLIT</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">8</span>
    <span class="c1">// 取出参数的值放入 DI 寄存器，它是 funcval 对象的指针，此场景中 fn.fn 是 goexit0 的地址
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">fn</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">DI</span>

    <span class="nf">get_tls</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
    <span class="c1">// AX = g
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">AX</span>   <span class="c1">// save state in g-&gt;sched
</span><span class="c1"></span>    <span class="c1">// mcall 返回地址放入 BX
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="mi">0</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BX</span>   <span class="c1">// caller&#39;s PC
</span><span class="c1"></span>    <span class="c1">// g.sched.pc = BX，保存 g 的 PC
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">BX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_pc</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>
    <span class="nx">LEAQ</span>    <span class="nx">fn</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">BX</span>    <span class="c1">// caller&#39;s SP
</span><span class="c1"></span>    <span class="c1">// 保存 g 的 SP
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">BX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>
    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_g</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>
    <span class="nx">MOVQ</span>    <span class="nx">BP</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_bp</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>

    <span class="c1">// switch to m-&gt;g0 &amp; its stack, call fn
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">BX</span>
    <span class="nx">MOVQ</span>    <span class="nf">g_m</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BX</span>
    <span class="c1">// SI = g0
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nf">m_g0</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">SI</span>
    <span class="nx">CMPQ</span>    <span class="nx">SI</span><span class="p">,</span> <span class="nx">AX</span>  <span class="c1">// if g == m-&gt;g0 call badmcall
</span><span class="c1"></span>    <span class="nx">JNE</span> <span class="mi">3</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>
    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">badmcall</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
    <span class="nx">JMP</span> <span class="nx">AX</span>
    <span class="c1">// 把 g0 的地址设置到线程本地存储中
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">SI</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>   <span class="c1">// g = m-&gt;g0
</span><span class="c1"></span>    <span class="c1">// 从 g 的栈切换到了 g0 的栈D
</span><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">SI</span><span class="p">),</span> <span class="nx">SP</span>  <span class="c1">// sp = m-&gt;g0-&gt;sched.sp
</span><span class="c1"></span>    <span class="c1">// AX = g，参数入栈
</span><span class="c1"></span>    <span class="nx">PUSHQ</span>   <span class="nx">AX</span>
    <span class="nx">MOVQ</span>    <span class="nx">DI</span><span class="p">,</span> <span class="nx">DX</span>
    <span class="c1">// DI 是结构体 funcval 实例对象的指针，它的第一个成员才是 goexit0 的地址
</span><span class="c1"></span>    <span class="c1">// 读取第一个成员到 DI 寄存器
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="mi">0</span><span class="p">(</span><span class="nx">DI</span><span class="p">),</span> <span class="nx">DI</span>
    <span class="c1">// 调用 goexit0(g)
</span><span class="c1"></span>    <span class="nx">CALL</span>    <span class="nx">DI</span>
    <span class="nx">POPQ</span>    <span class="nx">AX</span>
    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">badmcall2</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
    <span class="nx">JMP</span> <span class="nx">AX</span>
    <span class="nx">RET</span>
</code></pre></td></tr></table>
</div>
</div><p>函数参数是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">funcval</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">fn</span> <span class="kt">uintptr</span>
    <span class="c1">// variable-size, fn-specific data here
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>字段 fn 就表示 goexit0 函数的地址。</p>
<ul>
<li>L5 将函数参数保存到 DI 寄存器，这里 fn.fn 就是 goexit0 的地址。</li>
<li>L7 将 tls 保存到 CX 寄存器，L9 将 当前线程指向的 goroutine （非 main goroutine，称为 gp）保存到 AX 寄存器，L11 将调用者（调用 mcall 函数）的栈顶，这里就是 mcall 完成后的返回地址，存入 BX 寄存器。</li>
<li>L13 将 mcall 的返回地址保存到 gp 的 g.sched.pc 字段，L14 将 gp 的栈顶，也就是 SP 保存到 BX 寄存器，* L16 将 SP 保存到 gp 的 g.sched.sp 字段，L17 将 g 保存到 gp 的 g.sched.g 字段，L18 将 BP 保存 到 gp 的 g.sched.bp 字段。这一段主要是保存 gp 的调度信息。</li>
<li>L21 将当前指向的 g 保存到 BX 寄存器，L22 将 g.m 字段保存到 BX 寄存器，L23 将 g.m.g0 字段保存到 SI，g.m.g0 就是当前工作线程的 g0。</li>
<li>现在，SI = g0， AX = gp，L25 判断 gp 是否是 g0，如果 gp == g0 说明有问题，执行 runtime·badmcall。正常情况下，PC 值加 3，跳过下面的两条指令，直接到达 L30。</li>
<li>L30 将 g0 的地址设置到线程本地存储中，L32 将 g0.SP 设置到 CPU 的 SP 寄存器，这也就意味着我们从 gp 栈切换到了 g0 的栈，要变天了！</li>
<li>L34 将参数 gp 入栈，为调用 goexit0 构造参数。L35 将 DI 寄存器的内容设置到 DX 寄存器，DI 是结构体 funcval 实例对象的指针，它的第一个成员才是 goexit0 的地址。L36 读取 DI 第一成员，也就是 goexit0 函数的地址。</li>
<li>L40 调用 goexit0 函数，这已经是在 g0 栈上执行了，函数参数就是 gp。</li>
<li>到这里，就会去执行 goexit0 函数，注意，这里永远都不会返回。所以，在 CALL 指令后面，如果返回了，又会去调用 runtime.badmcall2 函数去处理意外情况。</li>
</ul>
<p>经过一系列函数调用，我们最终在当前线程的 g0 的栈上调用 runtime.goexit0 函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// goexit 继续在 g0 上执行
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">goexit0</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="c1">// 切换当前的 g 为 _Gdead
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">)</span>
	<span class="k">if</span> <span class="nf">isSystemGoroutine</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ngsys</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">//解除锁定设置
</span><span class="c1"></span>	<span class="c1">// 清空 gp 的一些字段
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">locked</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">lockedm</span> <span class="o">!=</span> <span class="mi">0</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">lockedm</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">paniconfault</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="c1">// 应该已经为 true，但以防万一
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="kc">nil</span> <span class="c1">// should be true already but just in case.
</span><span class="c1"></span>	<span class="c1">// Goexit 中 panic 则不为 nil， 指向栈分配的数据
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="kc">nil</span> <span class="c1">// non-nil for Goexit during panic. points at stack-allocated data.
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">writebuf</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">labels</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Flush assist credit to the global pool. This gives
</span><span class="c1"></span>		<span class="c1">// better information to pacing if the application is
</span><span class="c1"></span>		<span class="c1">// rapidly creating an exiting goroutines.
</span><span class="c1"></span>		<span class="c1">// 刷新 assist credit 到全局池。
</span><span class="c1"></span>		<span class="c1">// 如果应用在快速创建 Goroutine，这可以为 pacing 提供更好的信息。
</span><span class="c1"></span>		<span class="nx">scanCredit</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">assistWorkPerByte</span> <span class="o">*</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span><span class="p">))</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">bgScanCredit</span><span class="p">,</span> <span class="nx">scanCredit</span><span class="p">)</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="c1">// Note that gp&#39;s stack scan is now &#34;valid&#34; because it has no
</span><span class="c1"></span>	<span class="c1">// stack.
</span><span class="c1"></span>	<span class="c1">// 注意 gp 的栈 scan 目前开始变为 valid，因为它没有栈了
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">gcscanvalid</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="c1">// 解除 g 与 m 的关系
</span><span class="c1"></span>	<span class="nf">dropg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;wasm&#34;</span> <span class="p">{</span> <span class="c1">// no threads yet on wasm
</span><span class="c1"></span>		<span class="c1">// wasm 目前还没有线程支持
</span><span class="c1"></span>		<span class="c1">// 将 g 扔进 gfree 链表中等待复用
</span><span class="c1"></span>		<span class="nf">gfput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="nx">gp</span><span class="p">)</span>
		<span class="c1">// 再次进行调度
</span><span class="c1"></span>		<span class="nf">schedule</span><span class="p">()</span> <span class="c1">// never returns
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedInt</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;invalid m-&gt;lockedInt = &#34;</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedInt</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;internal lockOSThread error&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 将 g 放入 free 队列缓存起来
</span><span class="c1"></span>	<span class="nf">gfput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="nx">gp</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">locked</span> <span class="p">{</span>
		<span class="c1">// The goroutine may have locked this thread because
</span><span class="c1"></span>		<span class="c1">// it put it in an unusual kernel state. Kill it
</span><span class="c1"></span>		<span class="c1">// rather than returning it to the thread pool.
</span><span class="c1"></span>
		<span class="c1">// Return to mstart, which will release the P and exit
</span><span class="c1"></span>		<span class="c1">// the thread.
</span><span class="c1"></span>		<span class="c1">// 该 Goroutine 可能在当前线程上锁住，因为它可能导致了不正常的内核状态
</span><span class="c1"></span>		<span class="c1">// 这时候 kill 该线程，而非将 m 放回到线程池。
</span><span class="c1"></span>
		<span class="c1">// 此举会返回到 mstart，从而释放当前的 P 并退出该线程
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;plan9&#34;</span> <span class="p">{</span> <span class="c1">// See golang.org/issue/22227.
</span><span class="c1"></span>			<span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// Clear lockedExt on plan9 since we may end up re-using
</span><span class="c1"></span>			<span class="c1">// this thread.
</span><span class="c1"></span>			<span class="c1">// 因为我们可能已重用此线程结束，在 plan9 上清除 lockedExt
</span><span class="c1"></span>			<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedExt</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//重新进入调度循环
</span><span class="c1"></span>	<span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>该函数会将 Goroutine 转换会 _Gdead 状态、清理其中的字段、移除 Goroutine 和线程的关联并调用 runtime.gfput 重新加入处理器的 Goroutine 空闲列表 gFree,在最后 runtime.goexit0 函数会重新调用 runtime.schedule 触发新的 Goroutine 调度.</p>
<p>它主要完成最后的清理工作：</p>
<ol>
<li>把 g 的状态从 _Grunning 更新为_Gdead；</li>
<li>清空 g 的一些字段；</li>
<li>调用 dropg 函数解除 g 和 m 之间的关系，其实就是设置 g-&gt;m = nil, m-&gt;currg = nil；</li>
<li>把 g 放入 p 的 freeg 队列缓存起来供下次创建 g 时快速获取而不用从内存分配。freeg 就是 g 的一个对象池；</li>
<li>调用 schedule 函数再次进行调度。</li>
</ol>
<p>到这里，gp 就完成了它的历史使命，功成身退，进入了 goroutine 缓存池，待下次有任务再重新启用。</p>
<p>而工作线程，又继续调用 schedule 函数进行新一轮的调度，整个过程形成了一个循环。</p>
<h3 id="m的休眠">M的休眠</h3>
<p>无论出于什么原因，当 M 需要被暂止时，可能（因为还有其他暂止 M 的方法）会执行该调用。 此调用会将 M 进行暂止，并阻塞到它被复始时。这一过程就是工作线程的暂止和复始。</p>
<p>相关函数：</p>
<ul>
<li>stopm()：停止当前M的执行，直到有新的G变得可运行而被唤醒。</li>
<li>gcstopm()：停止当前M的执行，串行运行时任务执行完毕后被唤醒。</li>
</ul>
<h4 id="stopm">stopm</h4>
<p>stopm函数会先把当前M放入调度器的空闲M列表，然后停止当前M。注意stopm函数并不会返回，而是停在其中，当M再次被唤醒的时候，会从stopm停下的地方继续执行。接下来有两件事要做。一是如果M是因GC任务而被唤醒，那么执行完该任务之后，当前M再次停止。否则关联与M预联的P，为M的执行做最后的准备。下面的代码省略了加锁和一些辅助代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Stops execution of the current m until new work is available.
</span><span class="c1">// Returns with acquired P.
</span><span class="c1">// 休眠，停止执行工作，直到有新的工作需要做为止
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">stopm</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 当前 goroutine，g0
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopm holding locks&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopm holding p&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopm spinning&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 将 m 放回到 空闲列表中，因为我们马上就要暂止了
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">// 将 m 放到全局空闲链表里去
</span><span class="c1"></span>	<span class="nf">mput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">// 暂止当前的 M，在此阻塞，直到被唤醒
</span><span class="c1"></span>	<span class="nf">notesleep</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
	<span class="c1">// 这里被其他工作线程唤醒
</span><span class="c1"></span>	<span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
	<span class="c1">// 此时已经被复始，说明有任务要执行
</span><span class="c1"></span>	<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>先将 m 放入全局空闲链表里，注意涉及到全局变量的修改，要上锁。接着，调用 notesleep(&amp;<em>g</em>.m.park) 使得当前工作线程进入休眠状态。其他工作线程在检测到“当前有很多工作要做”，会调用 noteclear(&amp;<em>g</em>.m.park) 将其唤醒。</p>
<p>一旦M要停止，就会把它的本地P转手给别的M。一旦M被唤醒，就会先找到一个P与之关联，并且这个P一定是该M被唤醒之前由别的M预联给它的。如果handoffp函数无法把作为其参数的P转手给一个M，那么就把该P放入空闲P列表。</p>
<h4 id="notesleep">notesleep</h4>
<p>相比gosched,gopark,反应更敏捷的notesleep既不让出M,也就不会让G重回任务队列.它直接让线程休眠直到被唤醒,更适合stopm,gcMark这类近似自旋的场景.</p>
<p>在Linux,DragonFly,FreeBSD平台,notesleep是基于Futex的高性能实现</p>
<p>note类型如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// sleep and wakeup on one-time events.
</span><span class="c1">// before any calls to notesleep or notewakeup,
</span><span class="c1">// must call noteclear to initialize the Note.
</span><span class="c1">// then, exactly one thread can call notesleep
</span><span class="c1">// and exactly one thread can call notewakeup (once).
</span><span class="c1">// once notewakeup has been called, the notesleep
</span><span class="c1">// will return.  future notesleep will return immediately.
</span><span class="c1">// subsequent noteclear must be called only after
</span><span class="c1">// previous notesleep has returned, e.g. it&#39;s disallowed
</span><span class="c1">// to call noteclear straight after notewakeup.
</span><span class="c1">//
</span><span class="c1">// notetsleep is like notesleep but wakes up after
</span><span class="c1">// a given number of nanoseconds even if the event
</span><span class="c1">// has not yet happened.  if a goroutine uses notetsleep to
</span><span class="c1">// wake up early, it must wait to call noteclear until it
</span><span class="c1">// can be sure that no other goroutine is calling
</span><span class="c1">// notewakeup.
</span><span class="c1">//
</span><span class="c1">// notesleep/notetsleep are generally called on g0,
</span><span class="c1">// notetsleepg is similar to notetsleep but is called on user g.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">note</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Futex-based impl treats it as uint32 key,
</span><span class="c1"></span>	<span class="c1">// while sema-based impl as M* waitm.
</span><span class="c1"></span>	<span class="c1">// Used to be a union, but unions break precise GC.
</span><span class="c1"></span>	<span class="nx">key</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>note 的底层实现机制跟操作系统相关，不同系统使用不同的机制，比如 linux 下使用的 futex 系统调用，而 mac 下则是使用的 pthread_cond_t 条件变量，note 对这些底层机制做了一个抽象和封装。</p>
<p>这种封装给扩展性带来了很大的好处，比如当睡眠和唤醒功能需要支持新平台时，只需要在 note 层增加对特定平台的支持即可，不需要修改上层的任何代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">notesleep</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">note</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// g0
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;notesleep not on g0&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// -1 表示无限期休眠
</span><span class="c1"></span>	<span class="nx">ns</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">if</span> <span class="o">*</span><span class="nx">cgo_yield</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Sleep for an arbitrary-but-moderate interval to poll libc interceptors.
</span><span class="c1"></span>		<span class="nx">ns</span> <span class="p">=</span> <span class="mf">10e6</span>
	<span class="p">}</span>
	<span class="c1">// 这里之所以需要用一个循环，是因为 futexsleep 有可能意外从睡眠中返回，
</span><span class="c1"></span>    <span class="c1">// 所以 futexsleep 函数返回后还需要检查 note.key 是否还是 0，
</span><span class="c1"></span>    <span class="c1">// 如果是 0 则表示并不是其它工作线程唤醒了我们，
</span><span class="c1"></span>    <span class="c1">// 只是 futexsleep 意外返回了，需要再次调用 futexsleep 进入睡眠
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="nf">key32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">n</span><span class="p">.</span><span class="nx">key</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">blocked</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nf">futexsleep</span><span class="p">(</span><span class="nf">key32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">n</span><span class="p">.</span><span class="nx">key</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">ns</span><span class="p">)</span>
		<span class="k">if</span> <span class="o">*</span><span class="nx">cgo_yield</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">asmcgocall</span><span class="p">(</span><span class="o">*</span><span class="nx">cgo_yield</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">blocked</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Atomically,
</span><span class="c1">//	if(*addr == val) sleep
</span><span class="c1">// Might be woken up spuriously; that&#39;s allowed.
</span><span class="c1">// Don&#39;t sleep longer than ns; ns &lt; 0 means forever.
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">futexsleep</span><span class="p">(</span><span class="nx">addr</span> <span class="o">*</span><span class="kt">uint32</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">ns</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Some Linux kernels have a bug where futex of
</span><span class="c1"></span>	<span class="c1">// FUTEX_WAIT returns an internal error code
</span><span class="c1"></span>	<span class="c1">// as an errno. Libpthread ignores the return value
</span><span class="c1"></span>	<span class="c1">// here, and so can we: as it says a few lines up,
</span><span class="c1"></span>	<span class="c1">// spurious wakeups are allowed.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">ns</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">futex</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">addr</span><span class="p">),</span> <span class="nx">_FUTEX_WAIT_PRIVATE</span><span class="p">,</span> <span class="nx">val</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">ts</span> <span class="nx">timespec</span>
	<span class="nx">ts</span><span class="p">.</span><span class="nf">setNsec</span><span class="p">(</span><span class="nx">ns</span><span class="p">)</span>
	<span class="nf">futex</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">addr</span><span class="p">),</span> <span class="nx">_FUTEX_WAIT_PRIVATE</span><span class="p">,</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ts</span><span class="p">),</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当 *addr 和 val 相等的时候，休眠。futex 由汇编语言实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">futex</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span><span class="nx">NOSPLIT</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span>
    <span class="c1">// 为系统调用准备参数
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">addr</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">DI</span>
    <span class="nx">MOVL</span>    <span class="nx">op</span><span class="o">+</span><span class="mi">8</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">SI</span>
    <span class="nx">MOVL</span>    <span class="nx">val</span><span class="o">+</span><span class="mi">12</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">DX</span>
    <span class="nx">MOVQ</span>    <span class="nx">ts</span><span class="o">+</span><span class="mi">16</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">R10</span>
    <span class="nx">MOVQ</span>    <span class="nx">addr2</span><span class="o">+</span><span class="mi">24</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">R8</span>
    <span class="nx">MOVL</span>    <span class="nx">val3</span><span class="o">+</span><span class="mi">32</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">R9</span>
    <span class="c1">// 系统调用编号
</span><span class="c1"></span>    <span class="nx">MOVL</span>    <span class="err">$</span><span class="mi">202</span><span class="p">,</span> <span class="nx">AX</span>
    <span class="c1">// 执行 futex 系统调用进入休眠，被唤醒后接着执行下一条 MOVL 指令
</span><span class="c1"></span>    <span class="nx">SYSCALL</span>
    <span class="c1">// 保存系统调用的返回值
</span><span class="c1"></span>    <span class="nx">MOVL</span>    <span class="nx">AX</span><span class="p">,</span> <span class="nx">ret</span><span class="o">+</span><span class="mi">40</span><span class="p">(</span><span class="nx">FP</span><span class="p">)</span>
    <span class="nx">RET</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// One-time notifications.
</span><span class="c1">//重置休眠条件
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">noteclear</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">note</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">n</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们调用 notesleep(&amp;<em>g</em>.m.park)，使得 m 进入睡眠状态。notewakeup可以将其唤醒：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">notewakeup</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">note</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//如果old!=0,表示已经执行过唤醒操作
</span><span class="c1"></span>	<span class="c1">// 设置 n.key = 1, 被唤醒的线程通过查看该值是否等于 1
</span><span class="c1"></span>    <span class="c1">// 来确定是被其它线程唤醒还是意外从睡眠中苏醒
</span><span class="c1"></span>	<span class="nx">old</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xchg</span><span class="p">(</span><span class="nf">key32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">n</span><span class="p">.</span><span class="nx">key</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">old</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;notewakeup - double wakeup (&#34;</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="s">&#34;)\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;notewakeup - double wakeup&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">//唤醒后n.key==1
</span><span class="c1"></span>	<span class="nf">futexwakeup</span><span class="p">(</span><span class="nf">key32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">n</span><span class="p">.</span><span class="nx">key</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>notewakeup 函数首先使用 atomic.Xchg 设置 note.key 值为 1，这是为了使被唤醒的线程可以通过查看该值是否等于 1 来确定是被其它线程唤醒还是意外从睡眠中苏醒了过来。</p>
<p>如果该值为 1 则表示是被唤醒的，可以继续工作，但如果该值为 0 则表示是意外苏醒，需要再次进入睡眠。</p>
<p>调用 futexwakeup 来唤醒工作线程，它和 futexsleep 是相对的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// If any procs are sleeping on addr, wake up at most cnt.
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">futexwakeup</span><span class="p">(</span><span class="nx">addr</span> <span class="o">*</span><span class="kt">uint32</span><span class="p">,</span> <span class="nx">cnt</span> <span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nf">futex</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">addr</span><span class="p">),</span> <span class="nx">_FUTEX_WAKE_PRIVATE</span><span class="p">,</span> <span class="nx">cnt</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// I don&#39;t know that futex wakeup can return
</span><span class="c1"></span>	<span class="c1">// EAGAIN or EINTR, but if it does, it would be
</span><span class="c1"></span>	<span class="c1">// safe to loop and call futex again.
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;futexwakeup addr=&#34;</span><span class="p">,</span> <span class="nx">addr</span><span class="p">,</span> <span class="s">&#34; returned &#34;</span><span class="p">,</span> <span class="nx">ret</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">int32</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="mh">0x1006</span><span class="p">)))</span> <span class="p">=</span> <span class="mh">0x1006</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>futex 由汇编语言实现，前面已经分析过，这里就不重复了。主要内容就是先准备好参数，然后进行系统调用，由内核唤醒线程。</p>
<p>内核在完成唤醒工作之后当前工作线程从内核返回到 futex 函数继续执行 SYSCALL 指令之后的代码并按函数调用链原路返回，继续执行其它代码。</p>
<p>而被唤醒的工作线程则由内核负责在适当的时候调度到 CPU 上运行。</p>
<h4 id="gcstopm">gcstopm</h4>
<p>在调度过程中，如果有串行运行时任务等待执行，gcstopm函数就会被调用。该函数首先判断当前M是否处于自旋状态，如果是就退出自旋，并将调度器的自旋M数减一。一个将要停止的M理应脱离自旋状态。</p>
<p>然后gcstopm函数会依次释放本地P，并将本地P的状态设置为Pgcstop。将调度器的stopwait字段减一，并在该值等于0的时候通过调度器的stopnote字段唤醒等待执行的串行运行时任务。最后调用stopm函数停止当前M并将其放入调度器的空闲M列表。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Stops the current m for stopTheWorld.
</span><span class="c1">// Returns when the world is restarted.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gcstopm</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gcstopm: not waiting for gc&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="c1">// OK to just drop nmspinning here,
</span><span class="c1"></span>		<span class="c1">// startTheWorld will unpark threads as necessary.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gcstopm: negative nmspinning&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">_p_</span> <span class="o">:=</span> <span class="nf">releasep</span><span class="p">()</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pgcstop</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span><span class="o">--</span>
	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">stopnote</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nf">stopm</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>所有调用因调用stopm函数停止的M，都可以通过调用startm函数唤醒。通过startm唤醒被stopm停止的M可以简化如下：stopm停止一个M并等待唤醒。startm将一个P与一个M预联。stopm将预联的P与M关联。</p>
<h3 id="mg的解绑">M/G的解绑</h3>
<p>dropg 听起来很玄乎，但实际上就是指将当前 g 的 m 置空、将当前 m 的 g 置空，从而完成解绑：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// dropg removes the association between m and the current goroutine m-&gt;curg (gp for short).
</span><span class="c1">// Typically a caller sets gp&#39;s status away from Grunning and then
</span><span class="c1">// immediately calls dropg to finish the job. The caller is also responsible
</span><span class="c1">// for arranging that gp will be restarted using ready at an
</span><span class="c1">// appropriate time. After calling dropg and arranging for gp to be
</span><span class="c1">// readied later, the caller can do other work but eventually should
</span><span class="c1">// call schedule to restart the scheduling of goroutines on this m.
</span><span class="c1">// dropg 移除 m 与当前 Goroutine m-&gt;curg（简称 gp ）之间的关联。
</span><span class="c1">// 通常，调用方将 gp 的状态设置为非 _Grunning 后立即调用 dropg 完成工作。
</span><span class="c1">// 调用方也有责任在 gp 将使用 ready 时重新启动时进行相关安排。
</span><span class="c1">// 在调用 dropg 并安排 gp ready 好后，调用者可以做其他工作，但最终应该
</span><span class="c1">// 调用 schedule 来重新启动此 m 上的 Goroutine 的调度。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">dropg</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="nf">setMNoWB</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="nf">setGNoWB</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// setMNoWB performs *mp = new without a write barrier.
</span><span class="c1">// For times when it&#39;s impractical to use an muintptr.
</span><span class="c1">// setMNoWB 当使用 muintptr 不可行时，在没有 write barrier 下执行 *mp = new
</span><span class="c1">//go:nosplit
</span><span class="c1">//go:nowritebarrier
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">setMNoWB</span><span class="p">(</span><span class="nx">mp</span> <span class="o">**</span><span class="nx">m</span><span class="p">,</span> <span class="nx">new</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
	<span class="p">(</span><span class="o">*</span><span class="nx">muintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">mp</span><span class="p">)).</span><span class="nf">set</span><span class="p">(</span><span class="nx">new</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// setGNoWB performs *gp = new without a write barrier.
</span><span class="c1">// For times when it&#39;s impractical to use a guintptr.
</span><span class="c1">// setGNoWB 当使用 guintptr 不可行时，在没有 write barrier 下执行 *gp = new
</span><span class="c1">//go:nosplit
</span><span class="c1">//go:nowritebarrier
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">setGNoWB</span><span class="p">(</span><span class="nx">gp</span> <span class="o">**</span><span class="nx">g</span><span class="p">,</span> <span class="nx">new</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="p">(</span><span class="o">*</span><span class="nx">guintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">)).</span><span class="nf">set</span><span class="p">(</span><span class="nx">new</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="m的死亡">M的死亡</h3>
<p>我们已经多次提到过 m 当且仅当它所运行的 Goroutine 被锁定在该 m 且 Goroutine 退出后， m 才会退出。我们来看一看它的原因。</p>
<p>首先，我们已经知道调度循环会一直进行下去永远不会返回了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mstart</span><span class="p">()</span> <span class="p">{</span>
	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
	<span class="nf">mstart1</span><span class="p">()</span> <span class="c1">// 永不返回
</span><span class="c1"></span>	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
	<span class="nf">mexit</span><span class="p">(</span><span class="nx">osStack</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>那 mexit 究竟什么时候会被执行？ 事实上，在 mstart1 中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mstart1</span><span class="p">()</span> <span class="p">{</span>
	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
	<span class="c1">// 为了在 mcall 的栈顶使用调用方来结束当前线程，做记录
</span><span class="c1"></span>	<span class="c1">// 当进入 schedule 之后，我们再也不会回到 mstart1，所以其他调用可以复用当前帧。
</span><span class="c1"></span>	<span class="nf">save</span><span class="p">(</span><span class="nf">getcallerpc</span><span class="p">(),</span> <span class="nf">getcallersp</span><span class="p">())</span>
	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>save 记录了调用方的 pc 和 sp，而对于 save：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// getcallerpc 返回它调用方的调用方程序计数器 PC program conter
</span><span class="c1">// getcallersp 返回它调用方的调用方的栈指针 SP stack pointer
</span><span class="c1">// 实现由编译器内建，在任何平台上都没有实现它的代码
</span><span class="c1">//
</span><span class="c1">// 例如:
</span><span class="c1">//
</span><span class="c1">//	func f(arg1, arg2, arg3 int) {
</span><span class="c1">//		pc := getcallerpc()
</span><span class="c1">//		sp := getcallersp()
</span><span class="c1">//	}
</span><span class="c1">//
</span><span class="c1">// 这两行会寻找调用 f 的 PC 和 SP
</span><span class="c1">//
</span><span class="c1">// 调用 getcallerpc 和 getcallersp 必须被询问的帧中完成
</span><span class="c1">//
</span><span class="c1">// getcallersp 的结果在返回时是正确的，但是它可能会被任何随后调用的函数无效，
</span><span class="c1">// 因为它可能会重新定位堆栈，以使其增长或缩小。一般规则是，getcallersp 的结果
</span><span class="c1">// 应该立即使用，并且只能传递给 nosplit 函数。
</span><span class="c1"></span>
<span class="c1">//go:noescape
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getcallerpc</span><span class="p">()</span> <span class="kt">uintptr</span>

<span class="c1">//go:noescape
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getcallersp</span><span class="p">()</span> <span class="kt">uintptr</span> <span class="c1">// implemented as an intrinsic on all platforms
</span><span class="c1"></span>

<span class="c1">// save 更新了 getg().sched 的 pc 和 sp 的指向，并允许 gogo 能够恢复到 pc 和 sp
</span><span class="c1">//
</span><span class="c1">// save 不允许 write barrier 因为 write barrier 会破坏 getg().sched
</span><span class="c1">//
</span><span class="c1">//go:nosplit
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">save</span><span class="p">(</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="c1">// 保存当前运行现场
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nx">pc</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lr</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ret</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="c1">// 保存 g
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">_g_</span><span class="p">))</span>

	<span class="c1">// 我们必须确保 ctxt 为零，但这里不允许 write barrier。
</span><span class="c1"></span>	<span class="c1">// 所以这里只是做一个断言
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ctxt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">badctxt</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>由于 mstart/mstart1 是运行在 g0 上的，因此 save 将保存 mstart 的运行现场保存到 g0.sched 中。 当调度循环执行到 goexit0 时，会检查 m 与 g 之间是否被锁住：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">goexit0</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="p">(</span><span class="o">...</span><span class="p">)</span>
	<span class="nf">gfput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="nx">gp</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">locked</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;plan9&#34;</span> <span class="p">{</span>
			<span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果 g 锁在当前 m 上，则调用 gogo 恢复到 g0.sched 的执行现场，从而恢复到 mexit 调用。</p>
<p>最后来看 mexit：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// mexit 销毁并退出当前线程
</span><span class="c1">//
</span><span class="c1">// 请不要直接调用来退出线程，因为它必须在线程栈顶上运行。
</span><span class="c1">// 相反，请使用 gogo(&amp;_g_.m.g0.sched) 来解除栈并退出线程。
</span><span class="c1">//
</span><span class="c1">// 当调用时，m.p != nil。因此可以使用 write barrier。
</span><span class="c1">// 在退出前它会释放当前绑定的 P。
</span><span class="c1">//
</span><span class="c1">//go:yeswritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mexit</span><span class="p">(</span><span class="nx">osStack</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">g</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">m</span>

	<span class="k">if</span> <span class="nx">m</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span>
		<span class="c1">// 主线程
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// 在 linux 中，退出主线程会导致进程变为僵尸进程。
</span><span class="c1"></span>		<span class="c1">// 在 plan 9 中，退出主线程将取消阻塞等待，即使其他线程仍在运行。
</span><span class="c1"></span>		<span class="c1">// 在 Solaris 中我们既不能 exitThread 也不能返回到 mstart 中。
</span><span class="c1"></span>		<span class="c1">// 其他系统上可能发生别的糟糕的事情。
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// 我们可以尝试退出之前清理当前 M ，但信号处理非常复杂
</span><span class="c1"></span>		<span class="nf">handoffp</span><span class="p">(</span><span class="nf">releasep</span><span class="p">())</span> <span class="c1">// 让出 P
</span><span class="c1"></span>		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>    <span class="c1">// 锁住调度器
</span><span class="c1"></span>		<span class="nx">sched</span><span class="p">.</span><span class="nx">nmfreed</span><span class="o">++</span>
		<span class="nf">checkdead</span><span class="p">()</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nf">notesleep</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span> <span class="c1">// 暂止主线程，在此阻塞
</span><span class="c1"></span>		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;locked m0 woke up&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">sigblock</span><span class="p">()</span>
	<span class="nf">unminit</span><span class="p">()</span>

	<span class="c1">// 释放 gsignal 栈
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">gsignal</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">stackfree</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 将 m 从 allm 中移除
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">pprev</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">allm</span><span class="p">;</span> <span class="o">*</span><span class="nx">pprev</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">pprev</span> <span class="p">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="nx">pprev</span><span class="p">).</span><span class="nx">alllink</span> <span class="p">{</span>
		<span class="k">if</span> <span class="o">*</span><span class="nx">pprev</span> <span class="o">==</span> <span class="nx">m</span> <span class="p">{</span>
			<span class="o">*</span><span class="nx">pprev</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">alllink</span>
			<span class="k">goto</span> <span class="nx">found</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 如果没找到则是异常状态，说明 allm 管理出错
</span><span class="c1"></span>	<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;m not found in allm&#34;</span><span class="p">)</span>
<span class="nx">found</span><span class="p">:</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">osStack</span> <span class="p">{</span>
		<span class="c1">// Delay reaping m until it&#39;s done with the stack.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// If this is using an OS stack, the OS will free it
</span><span class="c1"></span>		<span class="c1">// so there&#39;s no need for reaping.
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">freeWait</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="c1">// Put m on the free list, though it will not be reaped until
</span><span class="c1"></span>		<span class="c1">// freeWait is 0. Note that the free list must not be linked
</span><span class="c1"></span>		<span class="c1">// through alllink because some functions walk allm without
</span><span class="c1"></span>		<span class="c1">// locking, so may be using alllink.
</span><span class="c1"></span>		<span class="nx">m</span><span class="p">.</span><span class="nx">freelink</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">freem</span>
		<span class="nx">sched</span><span class="p">.</span><span class="nx">freem</span> <span class="p">=</span> <span class="nx">m</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// Release the P.
</span><span class="c1"></span>	<span class="nf">handoffp</span><span class="p">(</span><span class="nf">releasep</span><span class="p">())</span>
	<span class="c1">// After this point we must not have write barriers.
</span><span class="c1"></span>
	<span class="c1">// Invoke the deadlock detector. This must happen after
</span><span class="c1"></span>	<span class="c1">// handoffp because it may have started a new M to take our
</span><span class="c1"></span>	<span class="c1">// P&#39;s work.
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">nmfreed</span><span class="o">++</span>
	<span class="nf">checkdead</span><span class="p">()</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">osStack</span> <span class="p">{</span>
		<span class="c1">// Return from mstart and let the system thread
</span><span class="c1"></span>		<span class="c1">// library free the g0 stack and terminate the thread.
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// mstart is the thread&#39;s entry point, so there&#39;s nothing to
</span><span class="c1"></span>	<span class="c1">// return to. Exit the thread directly. exitThread will clear
</span><span class="c1"></span>	<span class="c1">// m.freeWait when it&#39;s done with the stack and the m can be
</span><span class="c1"></span>	<span class="c1">// reaped.
</span><span class="c1"></span>	<span class="nf">exitThread</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">freeWait</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可惜 exitThread 在 darwin 上还是没有定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 未在 darwin 上使用，但必须定义
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">exitThread</span><span class="p">(</span><span class="nx">wait</span> <span class="o">*</span><span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在 Linux amd64 上：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-s" data-lang="s"><span class="o">//</span> <span class="n">func</span> <span class="nf">exitThread</span><span class="p">(</span><span class="n">wait</span> <span class="o">*</span><span class="n">uint32</span><span class="p">)</span>
<span class="n">TEXT</span> <span class="n">runtime</span>·<span class="nf">exitThread</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span><span class="n">NOSPLIT</span><span class="p">,</span><span class="o">$</span><span class="m">0-8</span>
	<span class="n">MOVQ</span>	<span class="n">wait</span><span class="m">+0</span><span class="p">(</span><span class="n">FP</span><span class="p">),</span> <span class="n">AX</span>
	<span class="o">//</span> 栈使用完毕
	<span class="n">MOVL</span>	<span class="o">$</span><span class="m">0</span><span class="p">,</span> <span class="p">(</span><span class="n">AX</span><span class="p">)</span>
	<span class="n">MOVL</span>	<span class="o">$</span><span class="m">0</span><span class="p">,</span> <span class="n">DI</span>	<span class="o">//</span> <span class="n">exit</span> <span class="n">code</span>
	<span class="n">MOVL</span>	<span class="o">$</span><span class="n">SYS_exit</span><span class="p">,</span> <span class="n">AX</span>
	<span class="n">SYSCALL</span>
	<span class="o">//</span> 甚至连栈都没有了
	<span class="n">INT</span>	<span class="o">$</span><span class="m">3</span>
	<span class="n">JMP</span>	<span class="m">0</span><span class="p">(</span><span class="n">PC</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>从实现上可以看出，只有 linux 中才可能正常的退出一个栈，而 darwin 只能保持暂止了。 而如果是主线程，则会始终保持 park。</p>
<h3 id="触发调度">触发调度</h3>
<p>调度器的 runtime.schedule 函数重新选择 Goroutine 在线程上执行，所以我们只要找到该函数的调用方就能找到所有触发调度的时间点，经过分析和整理，我们能得到如下的树形结构：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201111231642.png" alt=""></p>
<p>除了上图中可能触发调度的时间点，运行时还会在线程启动 runtime.mstart 和 Goroutine 执行结束 runtime.goexit0 触发调度。我们在这里会重点介绍运行时触发调度的几个路径：</p>
<ul>
<li>主动挂起 — runtime.gopark -&gt; runtime.park_m</li>
<li>系统调用 — runtime.exitsyscall -&gt; runtime.exitsyscall0</li>
<li>协作式调度 — runtime.Gosched -&gt; runtime.gosched_m -&gt; runtime.goschedImpl</li>
<li>系统监控 — runtime.sysmon -&gt; runtime.retake -&gt; runtime.preemptone</li>
</ul>
<p>我们在这里介绍的调度时间点不是直接将线程的运行权交给其他任务，而是通过调度器的 runtime.schedule 重新调度。</p>
<h4 id="主动阻塞锁定g">主动阻塞(锁定G)</h4>
<h5 id="gosched">Gosched</h5>
<p>用户调用runtime.Gosched可将当前G任务暂停,重新放回全局队列,让出当前M去执行其他任务.我们无须对G做唤醒操作,因为它总归被某个M重新拿到,并从&quot;断点&quot;恢复.</p>
<p>协作式调度即使用该方式。runtime.Gosched 就是主动让出处理器，允许其他 Goroutine 运行。该函数无法挂起 Goroutine，调度器会在自动调度当前 Goroutine：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Gosched yields the processor, allowing other goroutines to run. It does not
</span><span class="c1">// suspend the current goroutine, so execution resumes automatically.
</span><span class="c1">// Gosched 会让出当前的 P，并允许其他 Goroutine 运行。
</span><span class="c1">// 它不会推迟当前的 Goroutine，因此执行会被自动恢复
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Gosched</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">checkTimeouts</span><span class="p">()</span>
	<span class="nf">mcall</span><span class="p">(</span><span class="nx">gosched_m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>它首先会通过 note 机制通知那些等待被 ready 的 Goroutine：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// checkTimeouts 恢复那些在等待一个 note 且已经触发其 deadline 时的 Goroutine。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">checkTimeouts</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">now</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">nt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">notesWithTimeout</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">key</span> <span class="o">==</span> <span class="nx">note_cleared</span> <span class="o">&amp;&amp;</span> <span class="nx">now</span> <span class="p">&gt;</span> <span class="nx">nt</span><span class="p">.</span><span class="nx">deadline</span> <span class="p">{</span>
			<span class="nx">n</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="nx">note_timeout</span>
			<span class="nf">goready</span><span class="p">(</span><span class="nx">nt</span><span class="p">.</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>而后通过 mcall 调用 gosched_m 在 g0 上继续执行并让出 P， 实质上是让 G 放弃当前在 M 上的执行权利，转去执行其他的 G，并在上下文切换时候， 将自身放入全局队列等待后续调度：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Gosched continuation on g0.
</span><span class="c1">// Gosched 在 g0 上继续执行
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gosched_m</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGoSched</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nf">goschedImpl</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">goschedImpl</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//重置属性
</span><span class="c1"></span>	<span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">status</span><span class="o">&amp;^</span><span class="nx">_Gscan</span> <span class="o">!=</span> <span class="nx">_Grunning</span> <span class="p">{</span>
		<span class="nf">dumpgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad g status&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
	<span class="c1">// 使当前 m 放弃 g
</span><span class="c1"></span>	<span class="nf">dropg</span><span class="p">()</span>
	<span class="c1">//将当前G放回全局队列
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nf">globrunqput</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">//重新调度执行其他任务
</span><span class="c1"></span>	<span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>经过连续几次跳转，我们最终在 g0 的栈上调用 runtime.goschedImpl 函数，运行时会更新 Goroutine 的状态到 _Grunnable，让出当前的处理器并将 Goroutine 重新放回全局队列，在最后，该函数会调用 runtime.schedule 重新触发调度。</p>
<p>实现&quot;断点恢复&quot;的关键由mcall实现,它将当前执行状态,包括SP,PC寄存器等值保存到G.sched区域.</p>
<p>当execute/gogo再次执行该任务时,自然可从中恢复状态.反正执行栈是G自带的,不用担心执行数据丢失.</p>
<h5 id="触发时机">触发时机</h5>
<h6 id="用户主动调用">用户主动调用</h6>
<p>主动用户让权：通过 runtime.Gosched 调用主动让出执行机会</p>
<h6 id="sysymonretake抢占">sysymon.retake抢占</h6>
<p>主动调度弃权：当发生执行栈分段时，检查自身的抢占标记，决定是否继续执行.</p>
<h4 id="用户态的阻塞唤醒锁定g">用户态的阻塞/唤醒(锁定G)</h4>
<p>当 G 在用户态阻塞的时候(例如从 channel 读/写)，会将当前 G 的状态从 Running 改为 Wait，同时将 G 放入到一个 wait 队列中(例如 channel 的 wait 队列)。</p>
<p>当 G 被另外一个 G2 唤醒时(通过 goready 函数)，那么 G 就会尝试加入到 G2 所在 P 的 runnext 中，如果不成的话，会依次尝试 本地g队列 和 全局g队列。</p>
<h5 id="gopark">gopark</h5>
<p>与Gosched最大的区别在于,gopark并没将G放回待运行队列.也就是说,必须主动恢复,否则该任务会遗失.</p>
<p>应用层阻塞通常使用这种方式。runtime.gopark 是触发调度最常见的方法，该函数会将当前 Goroutine 暂停，被暂停的任务不会放回运行队列.</p>
<p>gopark函数做的主要事情分为两点：</p>
<ul>
<li>解除当前goroutine的m的绑定关系，将当前goroutine状态机切换为等待状态；</li>
<li>调用一次schedule()函数，在局部调度器P发起一轮新的调度。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Puts the current goroutine into a waiting state and calls unlockf.
</span><span class="c1">// If unlockf returns false, the goroutine is resumed.
</span><span class="c1">// unlockf must not access this G&#39;s stack, as it may be moved between
</span><span class="c1">// the call to gopark and the call to unlockf.
</span><span class="c1">// Reason explains why the goroutine has been parked.
</span><span class="c1">// It is displayed in stack traces and heap dumps.
</span><span class="c1">// Reasons should be unique and descriptive.
</span><span class="c1">// Do not re-use reasons, add new ones.
</span><span class="c1">// gopark 会停住当前的 goroutine 并且调用传递进来的回调函数 unlockf
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gopark</span><span class="p">(</span><span class="nx">unlockf</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">lock</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">reason</span> <span class="nx">waitReason</span><span class="p">,</span> <span class="nx">traceEv</span> <span class="kt">byte</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">reason</span> <span class="o">!=</span> <span class="nx">waitReasonSleep</span> <span class="p">{</span>
		<span class="nf">checkTimeouts</span><span class="p">()</span> <span class="c1">// timeouts may expire while two goroutines keep the scheduler busy
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">curg</span>
	<span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Grunning</span> <span class="o">&amp;&amp;</span> <span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Gscanrunning</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gopark: bad g status&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">waitlock</span> <span class="p">=</span> <span class="nx">lock</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">waitunlockf</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">unlockf</span><span class="p">))</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="nx">reason</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">waittraceev</span> <span class="p">=</span> <span class="nx">traceEv</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">waittraceskip</span> <span class="p">=</span> <span class="nx">traceskip</span>
	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="c1">// can&#39;t do anything that might move the G between Ms here.
</span><span class="c1"></span>	<span class="c1">// gopark 最终会调用 park_m，在这个函数内部会调用 unlockf
</span><span class="c1"></span>	<span class="c1">// 然后会把当前的 goroutine，也就是 g 数据结构保存到 pollDesc 的 rg 或者 wg 指针里
</span><span class="c1"></span>	<span class="nf">mcall</span><span class="p">(</span><span class="nx">park_m</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Helpers for Go. Must be NOSPLIT, must only call NOSPLIT functions, and must not block.
</span><span class="c1"></span>
<span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">acquirem</span><span class="p">()</span> <span class="o">*</span><span class="nx">m</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span>
	<span class="k">return</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span>
<span class="p">}</span>

<span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">locks</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">{</span>
		<span class="c1">// restore the preemption request in case we&#39;ve cleared it in newstack
</span><span class="c1"></span>		<span class="c1">// 如果我们在 newstack 中清除了抢占请求，则恢复抢占请求
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>可看到gopark同样是由mcall保存执行状态,还有个unlockf作为暂停判断条件.</p>
<p>该函数会通过 runtime.mcall 在切换到 g0 的栈上调用 runtime.park_m 函数</p>
<p>park_m函数主要做的几件事情就是：</p>
<ul>
<li>线程安全更新goroutine的状态，置为_Gwaiting 等待状态；</li>
<li>解除goroutine与OS thread的绑定关系；</li>
<li>调用schedule()函数，调度器会重新调度选择一个goroutine去运行；</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// park continuation on g0.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">park_m</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGoPark</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waittraceev</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waittraceskip</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">//重置属性
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
	<span class="nf">dropg</span><span class="p">()</span>
	<span class="c1">//执行解锁函数.如果返回false,则恢复运行
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waitunlockf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fn</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waitunlockf</span><span class="p">))</span>
		<span class="nx">ok</span> <span class="o">:=</span> <span class="nf">fn</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waitlock</span><span class="p">)</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waitunlockf</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waitlock</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
				<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
			<span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// Schedule it back, never returns.
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//调度执行其他任务
</span><span class="c1"></span>	<span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该函数会将当前 Goroutine 的状态从 _Grunning 切换至_Gwaiting，调用 runtime.dropg 移除线程和 Goroutine 之间的关联，在这之后就可以调用 runtime.schedule 触发新一轮的调度了。</p>
<p>当 Goroutine 等待的特定条件满足后，运行时会调用 runtime.goready 将因为调用 runtime.gopark 而陷入休眠的 Goroutine 唤醒。</p>
<p>与之配套,goready用于恢复执行,G被放回优先级最高的P.runnext</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">goready</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">ready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">traceskip</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="p">})</span>
<span class="p">}</span>

<span class="c1">// Mark gp ready to run.
</span><span class="c1">// 将 gp 标记为 ready 来运行
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">ready</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">next</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">traceskip</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>

	<span class="c1">// Mark runnable.
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="c1">// 禁止抢占，因为它可以在局部变量中保存 p
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span> <span class="c1">// disable preemption because it can be holding p in a local var
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">status</span><span class="o">&amp;^</span><span class="nx">_Gscan</span> <span class="o">!=</span> <span class="nx">_Gwaiting</span> <span class="p">{</span>
		<span class="nf">dumpgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad g-&gt;status in ready&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// status is Gwaiting or Gscanwaiting, make Grunnable and put on runq
</span><span class="c1"></span>	<span class="c1">//修正状态,重新放回本地runnext
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
	<span class="nf">runqput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">wakep</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
	<span class="c1">// 在 newstack 中已经清除它的情况下恢复抢占请求
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">{</span> <span class="c1">// restore the preemption request in Case we&#39;ve cleared it in newstack
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime.ready 会将准备就绪的 Goroutine 的状态切换至 _Grunnable 并将其加入处理器的运行队列中，等待调度器的调度。</p>
<h5 id="触发时机-1">触发时机</h5>
<h6 id="time定时操作">time定时操作</h6>
<p>time.Sleep举例:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Sleep pauses the current goroutine for at least the duration d.
</span><span class="c1">// A negative or zero duration causes Sleep to return immediately.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Sleep</span><span class="p">(</span><span class="nx">d</span> <span class="nx">Duration</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>实际定义在runtime</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">timeSleep</span><span class="p">(</span><span class="nx">ns</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">ns</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">timer</span>
	<span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">t</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">timer</span><span class="p">)</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="nx">t</span>
	<span class="p">}</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">f</span> <span class="p">=</span> <span class="nx">goroutineReady</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">arg</span> <span class="p">=</span> <span class="nx">gp</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">nextwhen</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">+</span> <span class="nx">ns</span>
	<span class="nf">gopark</span><span class="p">(</span><span class="nx">resetForSleep</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">t</span><span class="p">),</span> <span class="nx">waitReasonSleep</span><span class="p">,</span> <span class="nx">traceEvGoSleep</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>调用gopark</p>
<h6 id="使用关键字-go">使用关键字 go</h6>
<p>新开一个协程，g状态会变为_GIdle，触发调度。</p>
<h6 id="内存同步访问">内存同步访问</h6>
<p>atomic，mutex，channel 操作等会使 goroutine 阻塞，因此会被调度走。等条件满足后（例如其他 goroutine 解锁了）还会被调度上来继续运行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">chansend</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
		<span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="s">&#34;chan send (nil chan)&#34;</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unreachable&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">debugChan</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;chansend: chan=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">racereadpc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">chansend</span><span class="p">))</span>
	<span class="p">}</span>

    <span class="o">......</span><span class="p">..</span>
    <span class="c1">// 省略无关代码
</span><span class="c1"></span>    <span class="o">......</span><span class="p">..</span>

	<span class="c1">// Block on the channel. Some receiver will complete our operation for us.
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">mysg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="c1">// No stack splits between assigning elem and enqueuing mysg
</span><span class="c1"></span>	<span class="c1">// on gp.waiting where copystack can find it.
</span><span class="c1"></span>	<span class="nx">mysg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">ep</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nx">gp</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">selectdone</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="nx">mysg</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
	<span class="nf">goparkunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="s">&#34;chan send&#34;</span><span class="p">,</span> <span class="nx">traceEvGoBlockSend</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

	<span class="c1">// someone woke us up.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">mysg</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;G waiting list is corrupted&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;chansend: spurious wakeup&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="k">if</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">blockevent</span><span class="p">(</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span><span class="o">-</span><span class="nx">t0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>可以看到，还是调用ggopark，来进行调度。</p>
<h6 id="网络读写">网络读写</h6>
<h6 id="垃圾回收">垃圾回收</h6>
<p>由于进行 GC 的 goroutine 也需要在 M 上运行，因此肯定会发生调度。当然，Go scheduler 还会做很多其他的调度，例如调度不涉及堆访问的 goroutine 来运行。GC 不管栈上的内存，只会回收堆上的内存</p>
<h4 id="系统态的阻塞唤醒锁定gm">系统态的阻塞/唤醒(锁定GM)</h4>
<h5 id="同异步系统调用">同/异步系统调用</h5>
<p>当OS有能力去处理异步的系统调用时候，使用网络轮询器(network poller)去处理系统调用会更加高效。不同的操作系统分别使用了kqueue (MacOS)、epoll (Linux) 、 iocp (Windows) 对此作了实现。</p>
<p>今天许多操作系统都能处理基于网络(Networking-based)的系统调用。这也是网络轮询器(network poller)这一名字的由来，因为它的主要用途就是处理网络操作。网络系统上通过使用network poller，调度器可以防止Goroutines在系统调用的时候阻塞M。这可以让M能够去执行P的本地G队列上面的其他Goroutines，而不是再去新建一个M。这可以减少OS上的调度加载。</p>
<p>最好的方式就是给一个例子看看这些东西是如何工作的。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201118223319.png" alt=""></p>
<p>图展示了基本的调用图例。Goroutine-1正在M上面执行并且有3个Goroutine在本地G队列上等待想要获取M的时间片。network poller此时空闲没事做。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201118223357.png" alt=""></p>
<p>图中 Goroutine-1想要进行network system调用，因此Goroutine-1移到了network poller上面然后处理异步调用，一旦Goroutine-1从M上移到network poller，M便可以去执行其他本地G队列上的Goroutine。此时 Goroutine-2切换到了M上面。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201118223452.png" alt=""></p>
<p>图中，network poller的异步网络调用完成并且Goroutine-1回到了P的本地G队列上面。一旦Goroutine-1能够切换回M上，Go的相关代码便能够再次执行。很大好处是，在执行network system调用时候，我们不需要其他额外的M。network poller有一个OS线程能够有效的处理事件循环。</p>
<p>当Goroutine想进行系统调用无法异步进行该怎么办呢？这种情况下，无法使用 network poller并且Goroutine产生的系统调用会阻塞M。很不幸但是我们无法阻止这种情况发生。一个例子就是基于文件的系统调用。如果你使用CGO，当你调用C函数的时候也会有其他情况发生会阻塞M。</p>
<p>注意：Windows操作系统确实有能力去异步进行基于文件的系统调用。从技术上讲，在Windows上运行时可以使用network poller。</p>
<p>我们看一下同步系统调用(比如file I/O)阻塞M的时候会发生什么。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201118223552.png" alt=""></p>
<p>图又一次展示了我们的基本调度图例。但是这一次Goroutine-1的同步系统调用会阻塞M1</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201118223607.png" alt=""></p>
<p>图中，调度器能够确定Goroutine-1已经阻塞了M。这时，调度器会从P上拿下来M1，Goroutine-1依旧在M1上。然后调度器会拿来一个新的M2去服务P。此时本地G队列上的Goroutine-2会上下文切换到M2上。如果已经有一个可用的M了，那么直接用它会比新建一个M要更快。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201118223626.png" alt=""></p>
<p>图中，Goroutine-1的阻塞系统调用结束了。此时Goroutine-1能够回到本地G队列的后面并且能够重新被P执行。M1之后会被放置一边供未来类似的情况使用。</p>
<h5 id="同步系统调用">同步系统调用</h5>
<p>当 G 在 M 上执行系统调用后，它会阻塞，并将状态设置为 syscall 状态。M 也会进行阻塞。G 所绑定的 P 会和当前 G 和 M 解绑，寻找空闲 M，或创建新的 M，继续运行它队列中的其他 G .</p>
<p>当 M 执行完系统调用后，G 会重新寻找一个空闲的 P，进行运行，如果没有空闲的 P，那么它就会进入 全局g队列。</p>
<p>同步系统调用也会触发运行时调度器的调度，为了处理特殊的系统调用，我们甚至在 Goroutine 中加入了 _Gsyscall 状态，Go 语言通过 syscall.Syscall 和 syscall.RawSyscall 等使用汇编语言编写的方法封装了操作系统提供的所有系统调用.</p>
<p>为支持并发调度,Go专门对syscall,cgo进行了包装,以便在长时间阻塞时能切换执行其他任务.在标准库syscall包里,将系统调用函数分为Syscall和RawSyscall两类.</p>
<p>前者和后者的区别是前者会在系统调用前后分别调用entersyscall和exitsyscall(位于src/runtime/proc.go)，做一些现场保存和恢复操作，这样才能使P安全地与M解绑，并在其它M上继续执行其它G。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-s" data-lang="s"><span class="c1">#define INVOKE_SYSCALL	INT	$0x80</span>

<span class="n">TEXT</span> ·<span class="nf">Syscall</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span><span class="n">NOSPLIT</span><span class="p">,</span><span class="o">$</span><span class="m">0-28</span>
	<span class="n">CALL</span>	<span class="n">runtime</span>·<span class="nf">entersyscall</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
	<span class="kc">...</span>
	<span class="n">INVOKE_SYSCALL</span>
	<span class="kc">...</span>
	<span class="n">CALL</span>	<span class="n">runtime</span>·<span class="nf">exitsyscall</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
	<span class="n">RET</span>
<span class="n">ok</span><span class="o">:</span>
	<span class="kc">...</span>
	<span class="n">CALL</span>	<span class="n">runtime</span>·<span class="nf">exitsyscall</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
	<span class="n">RET</span>
</code></pre></td></tr></table>
</div>
</div><p>在通过汇编指令 INVOKE_SYSCALL 执行系统调用前后，上述函数会调用运行时的 runtime.entersyscall 和 runtime.exitsyscall，正是这一层包装能够让我们在陷入系统调用前触发运行时的准备和清理工作。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201112153416.png" alt=""></p>
<p>不过出于性能的考虑，如果这次系统调用不需要运行时参与，就会使用 syscall.RawSyscall 简化这一过程，不再调用运行时函数。这里包含 Go 语言对 Linux 386 架构上不同系统调用的分类，我们会按需决定是否需要运行时的参与：</p>
<table>
<thead>
<tr>
<th>系统调用</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>SYS_TIME</td>
<td>RawSyscall</td>
</tr>
<tr>
<td>SYS_GETTIMEOFDAY</td>
<td>RawSyscall</td>
</tr>
<tr>
<td>SYS_SETRLIMIT</td>
<td>RawSyscall</td>
</tr>
<tr>
<td>SYS_GETRLIMIT</td>
<td>RawSyscall</td>
</tr>
<tr>
<td>SYS_EPOLL_WAIT</td>
<td>Syscall</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>由于直接进行系统调用会阻塞当前的线程，所以只有可以立刻返回的系统调用才可能会被设置成 RawSyscall 类型，例如：SYS_EPOLL_CREATE、SYS_EPOLL_WAIT（超时时间为 0）、SYS_TIME 等。</p>
<p>正常的系统调用过程相比之下比较复杂，接下来我们将分别介绍进入系统调用前的准备工作和系统调用结束后的收尾工作。</p>
<h5 id="准备工作">准备工作</h5>
<p>runtime.entersyscall 函数会在获取当前程序计数器和栈位置之后调用 runtime.reentersyscall，它会完成 Goroutine 进入系统调用前的准备工作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Standard syscall entry used by the go syscall library and normal cgo calls.
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">entersyscall</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">reentersyscall</span><span class="p">(</span><span class="nf">getcallerpc</span><span class="p">(),</span> <span class="nf">getcallersp</span><span class="p">())</span>
<span class="p">}</span>

<span class="c1">// The goroutine g is about to enter a system call.
</span><span class="c1">// Record that it&#39;s not using the cpu anymore.
</span><span class="c1">// This is called only from the go syscall library and cgocall,
</span><span class="c1">// not from the low-level system calls used by the runtime.
</span><span class="c1">//
</span><span class="c1">// Entersyscall cannot split the stack: the gosave must
</span><span class="c1">// make g-&gt;sched refer to the caller&#39;s stack segment, because
</span><span class="c1">// entersyscall is going to return immediately after.
</span><span class="c1">//
</span><span class="c1">// Nothing entersyscall calls can split the stack either.
</span><span class="c1">// We cannot safely move the stack during an active call to syscall,
</span><span class="c1">// because we do not know which of the uintptr arguments are
</span><span class="c1">// really pointers (back into the stack).
</span><span class="c1">// In practice, this means that we make the fast path run through
</span><span class="c1">// entersyscall doing no-split things, and the slow path has to use systemstack
</span><span class="c1">// to run bigger things on the system stack.
</span><span class="c1">//
</span><span class="c1">// reentersyscall is the entry point used by cgo callbacks, where explicitly
</span><span class="c1">// saved SP and PC are restored. This is needed when exitsyscall will be called
</span><span class="c1">// from a function further up in the call stack than the parent, as g-&gt;syscallsp
</span><span class="c1">// must always point to a valid stack frame. entersyscall below is the normal
</span><span class="c1">// entry point for syscalls, which obtains the SP and PC from the caller.
</span><span class="c1">//
</span><span class="c1">// Syscall tracing:
</span><span class="c1">// At the start of a syscall we emit traceGoSysCall to capture the stack trace.
</span><span class="c1">// If the syscall does not block, that is it, we do not emit any other events.
</span><span class="c1">// If the syscall blocks (that is, P is retaken), retaker emits traceGoSysBlock;
</span><span class="c1">// when syscall returns we emit traceGoSysExit and when the goroutine starts running
</span><span class="c1">// (potentially instantly, if exitsyscallfast returns true) we emit traceGoStart.
</span><span class="c1">// To ensure that traceGoSysExit is emitted strictly after traceGoSysBlock,
</span><span class="c1">// we remember current value of syscalltick in m (_g_.m.syscalltick = _g_.m.p.ptr().syscalltick),
</span><span class="c1">// whoever emits traceGoSysBlock increments p.syscalltick afterwards;
</span><span class="c1">// and we wait for the increment before emitting traceGoSysExit.
</span><span class="c1">// Note that the increment is done even if tracing is not enabled,
</span><span class="c1">// because tracing can be enabled in the middle of syscall. We don&#39;t want the wait to hang.
</span><span class="c1">//
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">reentersyscall</span><span class="p">(</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="c1">// Disable preemption because during this function g is in Gsyscall status,
</span><span class="c1"></span>	<span class="c1">// but can have inconsistent g-&gt;sched, do not let GC observe it.
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span>

	<span class="c1">// Entersyscall must not call any function that might split/grow the stack.
</span><span class="c1"></span>	<span class="c1">// (See details in comment above.)
</span><span class="c1"></span>	<span class="c1">// Catch calls that might, by replacing the stack guard with something that
</span><span class="c1"></span>	<span class="c1">// will trip any stack check and leaving a flag to tell newstack to die.
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">throwsplit</span> <span class="p">=</span> <span class="kc">true</span>

	<span class="c1">// Leave SP around for GC and traceback.
</span><span class="c1"></span>	<span class="c1">//保存执行现场
</span><span class="c1"></span>	<span class="nf">save</span><span class="p">(</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span><span class="p">)</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">=</span> <span class="nx">sp</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallpc</span> <span class="p">=</span> <span class="nx">pc</span>
	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">_g_</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gsyscall</span><span class="p">)</span>
	<span class="c1">//确保sysmon运行
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">&lt;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">||</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="p">&lt;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">{</span>
		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;entersyscall inconsistent &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallsp</span><span class="p">),</span> <span class="s">&#34; [&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="s">&#34;,&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="p">),</span> <span class="s">&#34;]\n&#34;</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;entersyscall&#34;</span><span class="p">)</span>
		<span class="p">})</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">systemstack</span><span class="p">(</span><span class="nx">traceGoSysCall</span><span class="p">)</span>
		<span class="c1">// systemstack itself clobbers g.sched.{pc,sp} and we might
</span><span class="c1"></span>		<span class="c1">// need them later when the G is genuinely blocked in a
</span><span class="c1"></span>		<span class="c1">// syscall
</span><span class="c1"></span>		<span class="nf">save</span><span class="p">(</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">systemstack</span><span class="p">(</span><span class="nx">entersyscall_sysmon</span><span class="p">)</span>
		<span class="nf">save</span><span class="p">(</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">runSafePointFn</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// runSafePointFn may stack split if run on this stack
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="nx">runSafePointFn</span><span class="p">)</span>
		<span class="nf">save</span><span class="p">(</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">//设置相关状态
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">syscalltick</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">syscalltick</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">sysblocktraced</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">pp</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="nx">pp</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">oldp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">_Psyscall</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">systemstack</span><span class="p">(</span><span class="nx">entersyscall_gcwait</span><span class="p">)</span>
		<span class="nf">save</span><span class="p">(</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">entersyscall_sysmon</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonnote</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>禁止线程上发生的抢占，防止出现内存不一致的问题；</li>
<li>保证当前函数不会触发栈分裂或者增长；</li>
<li>保存当前的程序计数器 PC 和栈指针 SP 中的内容；</li>
<li>将 Goroutine 的状态更新至 _Gsyscall；</li>
<li>将 Goroutine 的处理器和线程暂时分离并更新处理器的状态到 _Psyscall；</li>
<li>释放当前线程上的锁；</li>
</ol>
<p>需要注意的是 runtime.reentersyscall 方法会使处理器和线程的分离，当前线程会陷入系统调用等待返回，当前线程上的锁被释放后，会有其他 Goroutine 抢占处理器资源。</p>
<p>监控线程sysmon对syscall非常重要,因为它负责将因系统调用而长时间阻塞的P抢回,判断是否需要handoffp,用于执行其他任务.否则,整体性能会严重下降,甚至整个进程都会被冻结.</p>
<p>某些系统调用本身就可以确定长时间阻塞(比如锁),那么它会选择执行entersyscallblock主动交出所关联的P</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// The same as entersyscall(), but with a hint that the syscall is blocking.
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">entersyscallblock</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span> <span class="c1">// see comment in entersyscall
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">throwsplit</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span> <span class="c1">// see comment in entersyscall
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">syscalltick</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">syscalltick</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">sysblocktraced</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">syscalltick</span><span class="o">++</span>

	<span class="c1">// Leave SP around for GC and traceback.
</span><span class="c1"></span>	<span class="nx">pc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
	<span class="nx">sp</span> <span class="o">:=</span> <span class="nf">getcallersp</span><span class="p">()</span>
	<span class="nf">save</span><span class="p">(</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span><span class="p">)</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallpc</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">&lt;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">||</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="p">&lt;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">{</span>
		<span class="nx">sp1</span> <span class="o">:=</span> <span class="nx">sp</span>
		<span class="nx">sp2</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span>
		<span class="nx">sp3</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallsp</span>
		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;entersyscallblock inconsistent &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">sp1</span><span class="p">),</span> <span class="s">&#34; &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">sp2</span><span class="p">),</span> <span class="s">&#34; &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">sp3</span><span class="p">),</span> <span class="s">&#34; [&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="s">&#34;,&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="p">),</span> <span class="s">&#34;]\n&#34;</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;entersyscallblock&#34;</span><span class="p">)</span>
		<span class="p">})</span>
	<span class="p">}</span>
	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">_g_</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gsyscall</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">&lt;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">||</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="p">&lt;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">{</span>
		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;entersyscallblock inconsistent &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallsp</span><span class="p">),</span> <span class="s">&#34; [&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="s">&#34;,&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="p">),</span> <span class="s">&#34;]\n&#34;</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;entersyscallblock&#34;</span><span class="p">)</span>
		<span class="p">})</span>
	<span class="p">}</span>

	<span class="nf">systemstack</span><span class="p">(</span><span class="nx">entersyscallblock_handoff</span><span class="p">)</span>

	<span class="c1">// Resave for traceback during blocked call.
</span><span class="c1"></span>	<span class="nf">save</span><span class="p">(</span><span class="nf">getcallerpc</span><span class="p">(),</span> <span class="nf">getcallersp</span><span class="p">())</span>

	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">entersyscallblock_handoff</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGoSysCall</span><span class="p">()</span>
		<span class="nf">traceGoSysBlock</span><span class="p">(</span><span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="c1">//释放P,让他去执行其他任务
</span><span class="c1"></span>	<span class="nf">handoffp</span><span class="p">(</span><span class="nf">releasep</span><span class="p">())</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h5 id="g的锁定">G的锁定</h5>
<p>Go 语言既然专门将线程进一步抽象为 Goroutine，自然也就不希望我们对线程做过多的操作，事实也是如此， 大部分的用户代码并不需要线程级的操作。</p>
<p>但某些情况下，当需要 使用 cgo 调用 C 端图形库（如 GLib）时，甚至需要将某个 Goroutine 用户态代码一直在主线程上执行。 我们已经知道了 runtime.LockOSThread 会将当前 Goroutine 锁在一个固定的 OS 线程上执行， 但是一旦开放了锁住某个 OS 线程后，会连带产生一些副作用。</p>
<p>比如当系统级的编程实践总是需要对线程进行操作， 尤其是当用户态代码通过系统调用将 OS 线程所在的 Linux namespace 进行修改、把线程私有化时（系统调用 unshare 和标志位 CLONE_NEWNS）， 其他 Goroutine 已经不再适合在此 OS 线程上执行。</p>
<p>这时候不得不将 M 永久的从运行时中移出，我们知道 LockOSThread/UnlockOSThread 也是目前唯一一个能够让 M 退出的做法（将 Goroutine 锁在 OS 线程上，且在 Goroutine 死亡退出时不调用 Unlock 方法）。</p>
<p>runtime包也提供了runtime.LockOSThread函数把当前G与某个M锁定，以及runtime.UnlockOSThread函数解除当前G与某个M的锁定。让我们有能力绑定 Goroutine 和线程完成一些比较特殊的操作。一个M只能与一个G锁定，反之亦然。多次调用runtime.LockOSThread只有最后一次调用有效。即便当前G没有与任何M锁定，调用runtime.UnlockOSThread函数也不会有任何副作用，它会直接返回。</p>
<p>LockOSThread 和 UnlockOSThread 在运行时包中分别提供了私有和公开的方法。 运行时私有的 lockOSThread 非常简单：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">lockOSThread</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedInt</span><span class="o">++</span>
	<span class="nf">dolockOSThread</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>因为整个运行时只有在 runtime.main 调用 main.init 、和 cgo 的 C 调用 Go 时候才会使用， 其中 main.init 其实也是为了 cgo 里 Go 调用某些 C 图形库时需要主线程支持才使用的。 因此不需要做过多复杂的处理，直接在 m 上进行计数 （计数的原因在于安全性和时钟上的一些处理，防止用户态代码误用， 例如只调用了 Unlock 而没有先调用 Lock [Mills, 2017]）， 而后调用 dolockOSThread 将 g 与 m 互相锁定：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// dolockOSThread 在修改 m.locked 后由 LockOSThread 和 lockOSThread 调用。
</span><span class="c1">// 在此调用期间不允许抢占，否则此函数中的 m 可能与调用者中的 m 不同。
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">dolockOSThread</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;wasm&#34;</span> <span class="p">{</span>
		<span class="k">return</span> <span class="c1">// no threads on wasm yet
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_g_</span><span class="p">)</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">lockedm</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime.dolockOSThread 会分别设置线程的 lockedg 字段和 Goroutine 的 lockedm 字段，这两行代码会绑定线程和 Goroutine。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">LockOSThread</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">haveTemplateThread</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;plan9&#34;</span> <span class="p">{</span>
		<span class="c1">// 如果我们需要从锁定的线程启动一个新线程，我们需要模板线程。
</span><span class="c1"></span>		<span class="c1">// 当我们处于一个已知良好的状态时，立即启动它。
</span><span class="c1"></span>		<span class="nf">startTemplateThread</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedExt</span><span class="o">++</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedExt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedExt</span><span class="o">--</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;LockOSThread nesting overflow&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">dolockOSThread</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>而用户态的公开方法则不同，还额外增加了一个模板线程的处理，这也解释了运行时其实并不希望 模板线程的存在，只有当需要时才会懒加载：</p>
<p>当 Goroutine 完成了特定的操作之后，就会调用以下函数 runtime.UnlockOSThread 分离 Goroutine 和线程：</p>
<p>Unlock 的部分非常简单，减少计数，再实际 dounlock：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// UnlockOSThread undoes an earlier call to LockOSThread.
</span><span class="c1">// If this drops the number of active LockOSThread calls on the
</span><span class="c1">// calling goroutine to zero, it unwires the calling goroutine from
</span><span class="c1">// its fixed operating system thread.
</span><span class="c1">// If there are no active LockOSThread calls, this is a no-op.
</span><span class="c1">//
</span><span class="c1">// Before calling UnlockOSThread, the caller must ensure that the OS
</span><span class="c1">// thread is suitable for running other goroutines. If the caller made
</span><span class="c1">// any permanent changes to the state of the thread that would affect
</span><span class="c1">// other goroutines, it should not call this function and thus leave
</span><span class="c1">// the goroutine locked to the OS thread until the goroutine (and
</span><span class="c1">// hence the thread) exits.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">UnlockOSThread</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedExt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedExt</span><span class="o">--</span>
	<span class="nf">dounlockOSThread</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>而且并无特殊处理，只是简单的将 lockedg 和 lockedm 两个字段清零：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// dounlockOSThread is called by UnlockOSThread and unlockOSThread below
</span><span class="c1">// after they update m-&gt;locked. Do not allow preemption during this call,
</span><span class="c1">// or else the m might be in different in this function than in the caller.
</span><span class="c1">// dounlockOSThread 在更新 m-&gt;locked 后由 UnlockOSThread 和 unlockOSThread 调用。
</span><span class="c1">// 在此调用期间不允许抢占，否则此函数中的 m 可能与调用者中的 m 不同。
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">dounlockOSThread</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;wasm&#34;</span> <span class="p">{</span>
		<span class="k">return</span> <span class="c1">// no threads on wasm yet
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedInt</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedExt</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">lockedm</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>函数执行的过程与 runtime.LockOSThread 正好相反。在多数的服务中，我们都用不到这一对函数，不过使用 CGO 或者经常与操作系统打交道的读者可能会见到它们的身影。</p>
<h5 id="恢复工作">恢复工作</h5>
<p>当系统调用结束后，会调用退出系统调用的函数 runtime.exitsyscall 为当前 Goroutine 重新分配资源，该函数有两个不同的执行路径：</p>
<ol>
<li>调用 exitsyscallfast 函数；</li>
<li>切换至调度器的 Goroutine 并调用 exitsyscall0 函数：</li>
</ol>
<p>这两种不同的路径会分别通过不同的方法查找一个用于执行当前 Goroutine 处理器 P</p>
<p>快速路径 exitsyscallfast 中包含两个不同的分支：</p>
<ol>
<li>如果 Goroutine 的原处理器处于 _Psyscall 状态，就会直接调用 wirep 将 Goroutine 与处理器进行关联；</li>
<li>如果调度器中存在闲置的处理器，就会调用 acquirep 函数使用闲置的处理器处理当前 Goroutine；</li>
</ol>
<p>另一个相对较慢的路径 exitsyscall0 就会将当前 Goroutine 切换至 _Grunnable 状态，并移除线程 M 和当前 Goroutine 的关联：</p>
<ol>
<li>当我们通过 pidleget 获取到闲置的处理器时就会在该处理器上执行 Goroutine；</li>
<li>在其它情况下，我们会将当前 Goroutine 放到全局的运行队列中，等待调度器的调度；</li>
</ol>
<p>无论哪种情况，我们在这个函数中都会调用 schedule 函数触发调度器的调度.</p>
<p>从系统调用返回时,必须检查P是否依然可用,因为可能已被sysmon抢走</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// The goroutine g exited its system call.
</span><span class="c1">// Arrange for it to run on a cpu again.
</span><span class="c1">// This is called only from the go syscall library, not
</span><span class="c1">// from the low-level system calls used by the runtime.
</span><span class="c1">//
</span><span class="c1">// Write barriers are not allowed because our P may have been stolen.
</span><span class="c1">//
</span><span class="c1">//go:nosplit
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">exitsyscall</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span> <span class="c1">// see comment in entersyscall
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">getcallersp</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;exitsyscall: syscall frame is no longer valid&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">_g_</span><span class="p">.</span><span class="nx">waitsince</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">oldp</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">oldp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">oldp</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="nf">exitsyscallfast</span><span class="p">(</span><span class="nx">oldp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;lost mcache&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">oldp</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">||</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">syscalltick</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">syscalltick</span> <span class="p">{</span>
				<span class="nf">systemstack</span><span class="p">(</span><span class="nx">traceGoStart</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="c1">// There&#39;s a cpu for us, so we can run.
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">syscalltick</span><span class="o">++</span>
		<span class="c1">// We need to cas the status and scan before resuming...
</span><span class="c1"></span>		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">_g_</span><span class="p">,</span> <span class="nx">_Gsyscall</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>

		<span class="c1">// Garbage collector isn&#39;t running (since we are),
</span><span class="c1"></span>		<span class="c1">// so okay to clear syscallsp.
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
		<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">{</span>
			<span class="c1">// restore the preemption request in case we&#39;ve cleared it in newstack
</span><span class="c1"></span>			<span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// otherwise restore the real _StackGuard, we&#39;ve spoiled it in entersyscall/entersyscallblock
</span><span class="c1"></span>			<span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
		<span class="p">}</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">throwsplit</span> <span class="p">=</span> <span class="kc">false</span>

		<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">disable</span><span class="p">.</span><span class="nx">user</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">schedEnabled</span><span class="p">(</span><span class="nx">_g_</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Scheduling of this goroutine is disabled.
</span><span class="c1"></span>			<span class="nf">Gosched</span><span class="p">()</span>
		<span class="p">}</span>

		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">_g_</span><span class="p">.</span><span class="nx">sysexitticks</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="c1">// Wait till traceGoSysBlock event is emitted.
</span><span class="c1"></span>		<span class="c1">// This ensures consistency of the trace (the goroutine is started after it is blocked).
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">oldp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">oldp</span><span class="p">.</span><span class="nx">syscalltick</span> <span class="o">==</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">syscalltick</span> <span class="p">{</span>
			<span class="nf">osyield</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="c1">// We can&#39;t trace syscall exit right now because we don&#39;t have a P.
</span><span class="c1"></span>		<span class="c1">// Tracing code can invoke write barriers that cannot run without a P.
</span><span class="c1"></span>		<span class="c1">// So instead we remember the syscall exit time and emit the event
</span><span class="c1"></span>		<span class="c1">// in execute when we have a P.
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">sysexitticks</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>

	<span class="c1">// Call the scheduler.
</span><span class="c1"></span>	<span class="nf">mcall</span><span class="p">(</span><span class="nx">exitsyscall0</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;lost mcache&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Scheduler returned, so we&#39;re allowed to run now.
</span><span class="c1"></span>	<span class="c1">// Delete the syscallsp information that we left for
</span><span class="c1"></span>	<span class="c1">// the garbage collector during the system call.
</span><span class="c1"></span>	<span class="c1">// Must wait until now because until gosched returns
</span><span class="c1"></span>	<span class="c1">// we don&#39;t know for sure that the garbage collector
</span><span class="c1"></span>	<span class="c1">// is not running.
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">syscalltick</span><span class="o">++</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">throwsplit</span> <span class="p">=</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>快速退出exitsyscallfast是指能重新绑定原有或空闲的P,以继续当前G任务的执行.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">exitsyscallfast</span><span class="p">(</span><span class="nx">oldp</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="c1">// Freezetheworld sets stopwait but does not retake P&#39;s.
</span><span class="c1"></span>	<span class="c1">//STW状态,就不要继续了
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span> <span class="o">==</span> <span class="nx">freezeStopWait</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// Try to re-acquire the last P.
</span><span class="c1"></span>	<span class="c1">//尝试关联原本的P
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">oldp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">oldp</span><span class="p">.</span><span class="nx">status</span> <span class="o">==</span> <span class="nx">_Psyscall</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">oldp</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">_Psyscall</span><span class="p">,</span> <span class="nx">_Pidle</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// There&#39;s a cpu for us, so we can run.
</span><span class="c1"></span>		<span class="nf">wirep</span><span class="p">(</span><span class="nx">oldp</span><span class="p">)</span>
		<span class="nf">exitsyscallfast_reacquired</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="c1">// Try to get any other idle P.
</span><span class="c1"></span>	<span class="c1">//获取其他空闲P
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">pidle</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">ok</span> <span class="kt">bool</span>
		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">ok</span> <span class="p">=</span> <span class="nf">exitsyscallfast_pidle</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">oldp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="c1">// Wait till traceGoSysBlock event is emitted.
</span><span class="c1"></span>					<span class="c1">// This ensures consistency of the trace (the goroutine is started after it is blocked).
</span><span class="c1"></span>					<span class="k">for</span> <span class="nx">oldp</span><span class="p">.</span><span class="nx">syscalltick</span> <span class="o">==</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">syscalltick</span> <span class="p">{</span>
						<span class="nf">osyield</span><span class="p">()</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="nf">traceGoSysExit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">})</span>
		<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">exitsyscallfast_pidle</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">_p_</span> <span class="o">:=</span> <span class="nf">pidleget</span><span class="p">()</span>
	<span class="c1">//唤醒sysmon
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonnote</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">//重新关联
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>如果多次尝试绑定P却失败,那么只能将当前任务放入待运行队列.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// exitsyscall slow path on g0.
</span><span class="c1">// Failed to acquire P, enqueue gp as runnable.
</span><span class="c1">//
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">exitsyscall0</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="c1">//修改状态,解除和M的关联
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gsyscall</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
	<span class="nf">dropg</span><span class="p">()</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">//再次获取空闲P
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span>
	<span class="k">if</span> <span class="nf">schedEnabled</span><span class="p">(</span><span class="nx">_g_</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">_p_</span> <span class="p">=</span> <span class="nf">pidleget</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_p_</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">//获取失败,放回全局任务队列
</span><span class="c1"></span>		<span class="nf">globrunqput</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonnote</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="c1">//再次检查P,以便执行当前任务
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
		<span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="c1">// Never returns.
</span><span class="c1"></span>    <span class="p">}</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Wait until another thread schedules gp and so m again.
</span><span class="c1"></span>		<span class="nf">stoplockedm</span><span class="p">()</span>
		<span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="c1">// Never returns.
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="c1">//关联P失败,休眠当前M
</span><span class="c1"></span>	<span class="nf">stopm</span><span class="p">()</span>
	<span class="nf">schedule</span><span class="p">()</span> <span class="c1">// Never returns.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="重新调度">重新调度</h5>
<p>当调度函数schedule检查到locked属性时,会适时移交,让正确的M去完成任务.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 调度器的一轮：找到 runnable Goroutine 并进行执行且永不返回
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">schedule</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;schedule: holding locks&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// m.lockedg 会在 lockosthread 下变为非零
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">stoplockedm</span><span class="p">()</span>
		<span class="nf">execute</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="kc">false</span><span class="p">)</span> <span class="c1">// 永不返回
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>简单地说,就是lockedm会休眠,直到某人将lockedg交给它.而不幸拿到lockedg的M,则要将lockedg连同P一起传递给lockedm,还负责将其唤醒.至于它自己,则因失去P而被迫休眠,知道wakep带着新的P唤醒它</p>
<ol>
<li>
<p>调度时发现当前M与某个Ｇ锁定了。调度器就会调用stoplockedm函数停止当前M。stoplockedm函数会先解除当前M与本地P的关联，并通过handoffp函数将这个P转手给其他M。hanfoffp函数会判断这个P是否有继续工作的必要，如果有，就调用startm函数唤醒一个M与该P关联，如无必要，就直接将该P放入空闲P列表。一旦P被转手，stoplockedm函数就会停止当前M的执行，并等待被唤醒。</p>
</li>
<li>
<p>当调度器为当前M找到一个可运行的G，但发现该G已经和某个M锁定了，就会调用startlockedm函数并将这个G作为参数传入。startlockedm函数会通过参数gp找到与这个G锁定的M，并强行把当前M的本地P转手给与该G锁定的M。这里的转手并不是调用handoffp函数，而是直接先解除当前M与本地P的关联，然后把这个P付给与该G锁定的M的nextp字段，将它们预联。之后startlockedm函数会调用notewakeup函数唤醒锁定的M，一旦M被唤醒，之前的预联就会变成关联，那么G也会被执行。最后，startlockedm函数还会调用stopm函数停止当前M。</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Stops execution of the current m that is locked to a g until the g is runnable again.
</span><span class="c1">// Returns with acquired P.
</span><span class="c1">// 停止当前正在执行锁住的 g 的 m 的执行，直到 g 重新变为 runnable。
</span><span class="c1">// 返回获得的 P
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">stoplockedm</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">lockedm</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stoplockedm: inconsistent locking&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 调度其他 M 来运行此 P
</span><span class="c1"></span>		<span class="c1">// Schedule another M to run this p.
</span><span class="c1"></span>		<span class="nx">_p_</span> <span class="o">:=</span> <span class="nf">releasep</span><span class="p">()</span>
		<span class="nf">handoffp</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">incidlelocked</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="c1">// Wait until another thread schedules lockedg again.
</span><span class="c1"></span>	<span class="c1">// 等待直到其他线程可以再次调度 lockedg
</span><span class="c1"></span>	<span class="nf">notesleep</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
	<span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
	<span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">status</span><span class="o">&amp;^</span><span class="nx">_Gscan</span> <span class="o">!=</span> <span class="nx">_Grunnable</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime:stoplockedm: g is not Grunnable or Gscanrunnable\n&#34;</span><span class="p">)</span>
		<span class="nf">dumpgstatus</span><span class="p">(</span><span class="nx">_g_</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stoplockedm: not runnable&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="c1">// Schedules the locked m to run the locked gp.
</span><span class="c1">// May run during STW, so write barriers are not allowed.
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">startlockedm</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="nx">mp</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">lockedm</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">mp</span> <span class="o">==</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;startlockedm: locked to me&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;startlockedm: m has p&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// directly handoff current P to the locked m
</span><span class="c1"></span>	<span class="nf">incidlelocked</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="c1">//移交P,并唤醒lockedm
</span><span class="c1"></span>	<span class="nx">_p_</span> <span class="o">:=</span> <span class="nf">releasep</span><span class="p">()</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
	<span class="c1">//当前M休眠
</span><span class="c1"></span>	<span class="nf">stopm</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从中可以看出,除lockedg只能由lockedm执行外,lockedm在完成任务或主动解除锁定前也不会执行其他任务.</p>
<h5 id="触发时机-2">触发时机</h5>
<h6 id="同步系统调用-1">同步系统调用</h6>
<p>提供给用户使用的系统调用，基本都会通知 runtime，以 entersyscall，exitsyscall 的形式来告诉 runtime，在这个 syscall 阻塞的时候，由 runtime 判断是否把 P 腾出来给其它的 M 用。解绑定指的是把 M 和 P 之间解绑，如果绑定被解除，在 syscall 返回时，这个 g 会被放入执行队列 runq 中。</p>
<p>同时 runtime 又保留了自己的特权，在执行自己的逻辑的时候，我的 P 不会被调走，这样保证了在 Go 自己“底层”使用的这些 syscall 返回之后都能被立刻处理。</p>
<p>所以同样是 epollwait，runtime 用的是不能被别人打断的，你用的 syscall.EpollWait 那显然是没有这种特权的。</p>
<h6 id="cgo">CGO</h6>
<p>CGO也会触发系统态的阻塞</p>
<h3 id="gomaxprocs">GOMAXPROCS</h3>
<p>我们知道在大部分的时间里，P 的数量是不会被动态调整的。 而 runtime.GOMAXPROCS 能够在运行时动态调整 P 的数量，我们就来看看这个调用会做什么事情。</p>
<p>对runtime.GOMAXPROCS函数的调用会会暂时让所有P都脱离运行状态，并试图阻止任何用户G的运行。新的P最大数量设置完毕后，运行时系统才开始陆续恢复它们。这对程序性能是非常大的损耗。因此最好不要去调用它，万不得已的时候也也该尽量在main函数的最前面去调用。</p>
<p>它的代码非常简单：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// GOMAXPROCS 设置能够同时执行线程的最大 CPU 数，并返回原先的设定。
</span><span class="c1">// 如果 n &lt; 1，则他不会进行任何修改。
</span><span class="c1">// 机器上的逻辑 CPU 的个数可以从 NumCPU 调用上获取。
</span><span class="c1">// 该调用会在调度器进行改进后被移除。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="o">...</span>

	<span class="c1">// 当调整 P 的数量时，调度器会被锁住
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// 返回原有设置
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">n</span> <span class="o">==</span> <span class="nx">ret</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ret</span>
	<span class="p">}</span>

	<span class="c1">// 停止一切事物，将 STW 的原因设置为 P 被调整
</span><span class="c1"></span>	<span class="nf">stopTheWorld</span><span class="p">(</span><span class="s">&#34;GOMAXPROCS&#34;</span><span class="p">)</span>

	<span class="c1">// STW 后，修改 P 的数量
</span><span class="c1"></span>	<span class="nx">newprocs</span> <span class="p">=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>

	<span class="c1">// 重新恢复
</span><span class="c1"></span>	<span class="c1">// 在这个过程中，startTheWorld 会调用 procresize 进而动态的调整 P 的数量
</span><span class="c1"></span>	<span class="nf">startTheWorld</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，GOMAXPROCS 从一出生似乎就被判了死刑，官方的注释已经明确的说明了这个调用 在后续改进调度器后会被移除。</p>
<p>它的过程也非常简单粗暴，调用他必须付出 STW 这种极大的代价。 当 P 被调整为小于 1 或与原有值相同时候，不会产生任何效果，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="模板线程">模板线程</h3>
<p>前面已经提到过，锁住系统线程带来的隐患就是某个线程的状态可能被用户态代码过分的修改， 从而不再具有产出新线程的能力，模板线程就提供了一个备用线程，不会执行 g，只用于创建安全的 m。</p>
<p>模板线程会在第一次调用 LockOSThread 的时候被创建，并将 haveTemplateThread 标记为已经存在模板线程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 如果模板线程尚未运行，则startTemplateThread将启动它。
</span><span class="c1">//
</span><span class="c1">// 调用线程本身必须处于已知良好状态。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">startTemplateThread</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;wasm&#34;</span> <span class="p">{</span> <span class="c1">// no threads on wasm yet
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">haveTemplateThread</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nf">newm</span><span class="p">(</span><span class="nx">templateThread</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>tempalteThread 这个函数会在 m 正式启动时被调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 创建一个新的 m. 它会启动并调用 fn 或调度器
</span><span class="c1">// fn 必须是静态、非堆上分配的闭包
</span><span class="c1">// 它可能在 m.p==nil 时运行，因此不允许 write barrier
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newm</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 分配一个 m
</span><span class="c1"></span>	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">allocm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span>
	<span class="o">...</span>
<span class="p">}</span>

<span class="c1">//go:yeswritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">allocm</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">fn</span> <span class="kd">func</span><span class="p">())</span> <span class="o">*</span><span class="nx">m</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nx">mp</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">mstartfn</span> <span class="p">=</span> <span class="nx">fn</span>
	<span class="o">...</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">mstart1</span><span class="p">()</span> <span class="p">{</span>
	<span class="o">...</span>

	<span class="c1">// 执行启动函数
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mstartfn</span><span class="p">;</span> <span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">fn</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个 newmHandoff 负责并串联了所有新创建的 m：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// newmHandoff 包含需要新 OS 线程的 m 的列表。
</span><span class="c1">// 在 newm 本身无法安全启动 OS 线程的情况下，newm 会使用它。
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">newmHandoff</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span> <span class="nx">mutex</span>

	<span class="c1">// newm 指向需要新 OS 线程的M结构列表。 该列表通过 m.schedlink 链接。
</span><span class="c1"></span>	<span class="nx">newm</span> <span class="nx">muintptr</span>

	<span class="c1">// waiting 表示当 m 列入列表时需要通知唤醒。
</span><span class="c1"></span>	<span class="nx">waiting</span> <span class="kt">bool</span>
	<span class="nx">wake</span>    <span class="nx">note</span>

	<span class="c1">// haveTemplateThread 表示 templateThread 已经启动。没有锁保护，使用 cas 设置为 1。
</span><span class="c1"></span>	<span class="nx">haveTemplateThread</span> <span class="kt">uint32</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>而模板线程本身不会退出，只会在需要的时，创建 m：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// templateThread是处于已知良好状态的线程，仅当调用线程可能不是良好状态时，
</span><span class="c1">// 该线程仅用于在已知良好状态下启动新线程。
</span><span class="c1">//
</span><span class="c1">// 许多程序不需要这个，所以当我们第一次进入可能导致在未知状态的线程上运行的状态时，
</span><span class="c1">// templateThread会懒启动。
</span><span class="c1">//
</span><span class="c1">// templateThread 在没有 P 的 M 上运行，因此它必须没有写障碍。
</span><span class="c1">//
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">templateThread</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">nmsys</span><span class="o">++</span>
	<span class="nf">checkdead</span><span class="p">()</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">newm</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">newm</span> <span class="o">:=</span> <span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">newm</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
			<span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">newm</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="k">for</span> <span class="nx">newm</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">next</span> <span class="o">:=</span> <span class="nx">newm</span><span class="p">.</span><span class="nx">schedlink</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
				<span class="nx">newm</span><span class="p">.</span><span class="nx">schedlink</span> <span class="p">=</span> <span class="mi">0</span>
				<span class="nf">newm1</span><span class="p">(</span><span class="nx">newm</span><span class="p">)</span>
				<span class="nx">newm</span> <span class="p">=</span> <span class="nx">next</span>
			<span class="p">}</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// 等待新的创建请求
</span><span class="c1"></span>		<span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">wake</span><span class="p">)</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nf">notesleep</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">wake</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当创建好 m 后，模板线程会休眠，直到创建新的 m 时候会被唤醒，这个我们在分析调度循环的时候已经看到过了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 创建一个新的 m. 它会启动并调用 fn 或调度器
</span><span class="c1">// fn 必须是静态、非堆上分配的闭包
</span><span class="c1">// 它可能在 m.p==nil 时运行，因此不允许 write barrier
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newm</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">();</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedExt</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">incgo</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;plan9&#34;</span> <span class="p">{</span>
		<span class="c1">// 我们处于一个锁定的 M 或可能由 C 启动的线程。这个线程的内核状态可能
</span><span class="c1"></span>		<span class="c1">// 很奇怪（用户可能已将其锁定）。我们不想将其克隆到另一个线程。
</span><span class="c1"></span>		<span class="c1">// 相反，请求一个已知状态良好的线程来创建给我们的线程。
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// 在 plan9 上禁用，见 golang.org/issue/22227
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// TODO: This may be unnecessary on Windows, which
</span><span class="c1"></span>		<span class="c1">// doesn&#39;t model thread creation off fork.
</span><span class="c1"></span>		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">haveTemplateThread</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;on a locked thread with no template thread&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">mp</span><span class="p">.</span><span class="nx">schedlink</span> <span class="p">=</span> <span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">newm</span>
		<span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">newm</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">{</span>
			<span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">false</span>
			<span class="c1">// 唤醒 m, spinning -&gt; non-spinning
</span><span class="c1"></span>			<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">wake</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nf">newm1</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>参考:
<a href="https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/">https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/</a>
<a href="https://wudaijun.com/2018/01/go-scheduler/">https://wudaijun.com/2018/01/go-scheduler/</a>
<a href="https://github.com/qyuhen/book/blob/master/Go%201.5%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%20%EF%BC%88%E4%B9%A6%E7%AD%BE%E7%89%88%EF%BC%89.pdf">https://github.com/qyuhen/book/blob/master/Go%201.5%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%20%EF%BC%88%E4%B9%A6%E7%AD%BE%E7%89%88%EF%BC%89.pdf</a>
<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/#657-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86">6.5 调度器</a>
<a href="https://qcrao91.gitbook.io/go/goroutine-tiao-du-qi/miao-shu-scheduler-de-chu-shi-hua-guo-cheng">描述 scheduler 的初始化过程</a>
<a href="https://juejin.im/post/6844903846825705485#heading-10">理解golang调度之二 ：Go调度器</a>
<a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/thread/">6.5 线程管理</a>
<a href="http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/">http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/</a>
<a href="https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/">https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/</a>
<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/#654-%E5%88%9B%E5%BB%BA-goroutine">6.5 调度器</a>
<a href="https://blog.csdn.net/puss0/article/details/80587232">地鼠宝宝的轶事奇闻之线程模型</a>
<a href="https://qcrao91.gitbook.io/go/goroutine-tiao-du-qi/goroutine-he-xian-cheng-de-qu-bie">goroutine和线程的区别</a>
<a href="https://www.bwangel.me/2020/03/16/go-schedule/">Go 的调度模型学习笔记</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2019-07-12
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go%E6%BA%90%E7%A0%81/">Go源码</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/types-from-different-packages-%E9%97%AE%E9%A2%98%E6%B5%85%E6%9E%90/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">types from different packages 问题浅析</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E5%9C%A8%E5%8D%95%E4%B8%AAsql.tx%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B/">
            <span class="next-text nav-default">为什么不要在单个sql.Tx中使用协程</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Forz</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
