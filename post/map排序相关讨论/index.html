<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>map排序相关讨论 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="map是用来存放&amp;lt;key, value&amp;gt;键值对的数据结构，可以很方便快速的根据key查到相应的value。假如存储学生和其成绩（假" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.87.0 with theme even" />


<link rel="canonical" href="/post/map%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E8%AE%A8%E8%AE%BA/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="map排序相关讨论" />
<meta property="og:description" content="map是用来存放&lt;key, value&gt;键值对的数据结构，可以很方便快速的根据key查到相应的value。假如存储学生和其成绩（假" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/map%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E8%AE%A8%E8%AE%BA/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-07-21T15:22:43+00:00" />
<meta property="article:modified_time" content="2017-07-21T15:22:43+00:00" />

<meta itemprop="name" content="map排序相关讨论">
<meta itemprop="description" content="map是用来存放&lt;key, value&gt;键值对的数据结构，可以很方便快速的根据key查到相应的value。假如存储学生和其成绩（假"><meta itemprop="datePublished" content="2017-07-21T15:22:43+00:00" />
<meta itemprop="dateModified" content="2017-07-21T15:22:43+00:00" />
<meta itemprop="wordCount" content="4294">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="map排序相关讨论"/>
<meta name="twitter:description" content="map是用来存放&lt;key, value&gt;键值对的数据结构，可以很方便快速的根据key查到相应的value。假如存储学生和其成绩（假"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/%20/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">map排序相关讨论</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-07-21 </span>
        <div class="post-category">
            <a href="/categories/stl/"> STL </a>
            </div>
          <span class="more-meta"> 约 4294 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#按value排序">按Value排序</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>map是用来存放&lt;key, value&gt;键值对的数据结构，可以很方便快速的根据key查到相应的value。假如存储学生和其成绩（假定不存在重名，当然可以对重名加以区分），我们用map来进行存储就是个不错的选择。 我们这样定义，map&lt;string, int&gt;，其中学生姓名用string类型，作为Key；该学生的成绩用int类型，作为value。这样一来，我们可以根据学生姓名快速的查找到他的成绩。</p>
<p>但是，我们除了希望能够查询某个学生的成绩，或许还想看看整体的情况。我们想把所有同学和他相应的成绩都输出来，并且按照我们想要的顺序进行输出：比如按照学生姓名的顺序进行输出，或者按照学生成绩的高低进行输出。换句话说，我们希望能够对map进行按Key排序或按Value排序，然后按序输出其键值对的内容。</p>
<p>#map中的属性为基本属性
##Map按Key排序</p>
<p>其实，为了实现快速查找，map内部本身就是按序存储的（比如红黑树）。在我们插入&lt;key, value&gt;键值对时，就会按照key的大小顺序进行存储。这也是作为key的类型必须能够进行&lt;运算比较的原因。现在我们用string类型作为key，因此，我们的存储就是按学生姓名的字典排序储存的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span><span class="cpf">&lt;map&gt;  </span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;string&gt;  </span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;  </span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>  
  
<span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">PAIR</span><span class="p">;</span>  
  
<span class="n">ostream</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">PAIR</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>  
  <span class="k">return</span> <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\t</span><span class="s">&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>  
<span class="p">}</span>  
  
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
  <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">name_score_map</span><span class="p">;</span>  
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;LiMin&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">90</span><span class="p">;</span>   
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;ZiLinMi&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">79</span><span class="p">;</span>   
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;BoB&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">92</span><span class="p">;</span>   
  <span class="n">name_score_map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&#34;Bing&#34;</span><span class="p">,</span><span class="mi">99</span><span class="p">));</span>  
  <span class="n">name_score_map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&#34;Albert&#34;</span><span class="p">,</span><span class="mi">86</span><span class="p">));</span>  
  <span class="k">for</span> <span class="p">(</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">name_score_map</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>  
       <span class="n">iter</span> <span class="o">!=</span> <span class="n">name_score_map</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>  
       <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>  
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">iter</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  
  <span class="p">}</span>  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
 <span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><p>大家都知道map是stl里面的一个模板类，现在我们来看下map的定义：</p>
<pre><code>template &lt; class Key, class T, class Compare = less&lt;Key&gt;,  
       class Allocator = allocator&lt;pair&lt;const Key,T&gt; &gt; &gt; class map;  
</code></pre>
<p>它有四个参数，其中我们比较熟悉的有两个: Key 和 Value。第四个是 Allocator，用来定义存储分配模型的，此处我们不作介绍。</p>
<p>现在我们重点看下第三个参数： class Compare = less<!-- raw HTML omitted --></p>
<p>这也是一个class类型的，而且提供了默认值 less<!-- raw HTML omitted -->。 less是stl里面的一个函数对象，那么什么是函数对象呢？
所谓的函数对象：即调用操作符的类，其对象常称为函数对象（function object），它们是行为类似函数的对象。表现出一个函数的特征，就是通过“对象名+(参数列表)”的方式使用一个 类，其实质是对operator()操作符的重载。</p>
<p>现在我们来看一下less的实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nl">less</span> <span class="p">:</span> <span class="n">binary_function</span> <span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>  
  <span class="kt">bool</span> <span class="n">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span>  
    <span class="p">{</span><span class="k">return</span> <span class="n">x</span><span class="o">&lt;</span><span class="n">y</span><span class="p">;}</span>  
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>它是一个带模板的struct，里面仅仅对()运算符进行了重载，实现很简单，但用起来很方便，这就是函数对象的优点所在。stl中还为四则运算等常见运算定义了这样的函数对象，与less相对的还有greater：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nl">greater</span> <span class="p">:</span> <span class="n">binary_function</span> <span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>  
  <span class="kt">bool</span> <span class="n">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span>  
    <span class="p">{</span><span class="k">return</span> <span class="n">x</span><span class="o">&gt;</span><span class="n">y</span><span class="p">;}</span>  
<span class="p">};</span> 
</code></pre></td></tr></table>
</div>
</div><p>map这里指定less作为其默认比较函数(对象)，所以我们通常如果不自己指定Compare，map中键值对就会按照Key的less顺序进行组织存储，因此我们就看到了上面代码输出结果是按照学生姓名的字典顺序输出的，即string的less序列。</p>
<p>我们可以在定义map的时候，指定它的第三个参数Compare，比如我们把默认的less指定为greater：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span><span class="cpf">&lt;map&gt;  </span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;string&gt;  </span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;  </span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>  
  
<span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">PAIR</span><span class="p">;</span>  
  
<span class="n">ostream</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">PAIR</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>  
  <span class="k">return</span> <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\t</span><span class="s">&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>  
<span class="p">}</span>  
  
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
  <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">name_score_map</span><span class="p">;</span>  
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;LiMin&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">90</span><span class="p">;</span>   
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;ZiLinMi&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">79</span><span class="p">;</span>   
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;BoB&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">92</span><span class="p">;</span>   
  <span class="n">name_score_map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&#34;Bing&#34;</span><span class="p">,</span><span class="mi">99</span><span class="p">));</span>  
  <span class="n">name_score_map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&#34;Albert&#34;</span><span class="p">,</span><span class="mi">86</span><span class="p">));</span>  
  <span class="k">for</span> <span class="p">(</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">name_score_map</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>  
       <span class="n">iter</span> <span class="o">!=</span> <span class="n">name_score_map</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>  
       <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>  
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">iter</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  
  <span class="p">}</span>  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
<span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><p>现在知道如何为map指定Compare类了，如果我们想自己写一个compare的类，让map按照我们想要的顺序来存储，比如，按照学生姓名的长短排序进行存储，那该怎么做呢？</p>
<p>其实很简单，只要我们自己写一个函数对象，实现想要的逻辑，定义map的时候把Compare指定为我们自己编写的这个就ok啦。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">CmpByKeyLength</span> <span class="p">{</span>  
  <span class="kt">bool</span> <span class="n">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">k1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">k2</span><span class="p">)</span> <span class="p">{</span>  
    <span class="k">return</span> <span class="n">k1</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">k2</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>  
  <span class="p">}</span>  
<span class="p">};</span> 
</code></pre></td></tr></table>
</div>
</div><p>是不是很简单！这里我们不用把它定义为模板，直接指定它的参数为string类型就可以了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>  
  <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">CmpByKeyLength</span><span class="o">&gt;</span> <span class="n">name_score_map</span><span class="p">;</span>  
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;LiMin&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">90</span><span class="p">;</span>   
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;ZiLinMi&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">79</span><span class="p">;</span>   
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;BoB&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">92</span><span class="p">;</span>   
  <span class="n">name_score_map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&#34;Bing&#34;</span><span class="p">,</span><span class="mi">99</span><span class="p">));</span>  
  <span class="n">name_score_map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&#34;Albert&#34;</span><span class="p">,</span><span class="mi">86</span><span class="p">));</span>  
  <span class="k">for</span> <span class="p">(</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">name_score_map</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>  
       <span class="n">iter</span> <span class="o">!=</span> <span class="n">name_score_map</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>  
       <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>  
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">iter</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  
  <span class="p">}</span>  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
<span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><h2 id="按value排序">按Value排序</h2>
<p>在第一部分中，我们借助map提供的参数接口，为它指定相应Compare类，就可以实现对map按Key排序，是在创建map并不断的向其中添加元素的过程中就会完成排序。</p>
<p>现在我们想要从map中得到学生按成绩的从低到高的次序输出，该如何实现呢？换句话说，该如何实现Map的按Value排序呢？</p>
<p>第一反应是利用stl中提供的sort算法实现，这个想法是好的，不幸的是，sort算法有个限制，利用sort算法只能对序列容器进行排序，就是线性的（如vector，list，deque）。map也是一个集合容器，它里面存储的元素是pair，但是它不是线性存储的（前面提过，像红黑树），所以利用sort不能直接和map结合进行排序。</p>
<p>虽然不能直接用sort对map进行排序，那么我们可不可以迂回一下，把map中的元素放到序列容器（如vector）中，然后再对这些元素进行排序呢？这个想法看似是可行的。要对序列容器中的元素进行排序，也有个必要条件：就是容器中的元素必须是可比较的，也就是实现了&lt;操作的。那么我们现在就来看下map中的元素满足这个条件么？</p>
<p>我们知道map中的元素类型为pair，具体定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T1</span><span class="p">,</span> <span class="n">class</span> <span class="n">T2</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">pair</span>  
<span class="p">{</span>  
  <span class="k">typedef</span> <span class="n">T1</span> <span class="n">first_type</span><span class="p">;</span>  
  <span class="k">typedef</span> <span class="n">T2</span> <span class="n">second_type</span><span class="p">;</span>  
  
  <span class="n">T1</span> <span class="n">first</span><span class="p">;</span>  
  <span class="n">T2</span> <span class="n">second</span><span class="p">;</span>  
  <span class="n">pair</span><span class="p">()</span> <span class="o">:</span> <span class="n">first</span><span class="p">(</span><span class="n">T1</span><span class="p">()),</span> <span class="n">second</span><span class="p">(</span><span class="n">T2</span><span class="p">())</span> <span class="p">{}</span>  
  <span class="n">pair</span><span class="p">(</span><span class="k">const</span> <span class="n">T1</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">T2</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="o">:</span> <span class="n">first</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">second</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">{}</span>  
  <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">U</span><span class="p">,</span> <span class="n">class</span> <span class="n">V</span><span class="o">&gt;</span>  
    <span class="n">pair</span> <span class="p">(</span><span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="o">:</span> <span class="n">first</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">),</span> <span class="n">second</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>  
<span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><p>pair也是一个模板类，这样就实现了良好的通用性。它仅有两个数据成员first 和 second，即 key 和 value，而且在<!-- raw HTML omitted -->头文件中，还为pair重载了 &lt; 运算符， 具体实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">_T1</span><span class="p">,</span> <span class="n">class</span> <span class="n">_T2</span><span class="o">&gt;</span>  
  <span class="kr">inline</span> <span class="kt">bool</span>  
  <span class="n">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">_T1</span><span class="p">,</span> <span class="n">_T2</span><span class="o">&gt;&amp;</span> <span class="n">__x</span><span class="p">,</span> <span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">_T1</span><span class="p">,</span> <span class="n">_T2</span><span class="o">&gt;&amp;</span> <span class="n">__y</span><span class="p">)</span>  
  <span class="p">{</span> <span class="k">return</span> <span class="n">__x</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">__y</span><span class="p">.</span><span class="n">first</span>  
           <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">__y</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">__x</span><span class="p">.</span><span class="n">first</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">__x</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">__y</span><span class="p">.</span><span class="n">second</span><span class="p">);</span> <span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="err">这个</span><span class="n">less在两种情况下返回true</span><span class="err">，第一种情况：</span><span class="n">__x</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">__y</span><span class="p">.</span><span class="n">first</span>  <span class="err">这个好理解，就是比较</span><span class="n">key</span><span class="err">，如果</span><span class="n">__x的key</span> <span class="err">小于</span> <span class="n">__y的key</span> <span class="err">则返回</span><span class="nb">true</span><span class="err">。</span>
<span class="err">第二种情况有点费解：</span>  <span class="o">!</span><span class="p">(</span><span class="n">__y</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">__x</span><span class="p">.</span><span class="n">first</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">__x</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">__y</span><span class="p">.</span><span class="n">second</span>
<span class="err">当然由于</span><span class="o">||</span><span class="err">运算具有短路作用，即当前面的条件不满足是，才进行第二种情况的判断</span> <span class="err">。第一种情况</span><span class="n">__x</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">__y</span><span class="p">.</span><span class="n">first</span> <span class="err">不成立，即</span><span class="n">__x</span><span class="p">.</span><span class="n">first</span> <span class="o">&gt;=</span> <span class="n">__y</span><span class="p">.</span><span class="n">first</span> <span class="err">成立，在这个条件下，我们来分析下</span>  <span class="o">!</span><span class="p">(</span><span class="n">__y</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">__x</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>  <span class="o">&amp;&amp;</span> <span class="n">__x</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">__y</span><span class="p">.</span><span class="n">second</span>
 <span class="o">!</span><span class="p">(</span><span class="n">__y</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">__x</span><span class="p">.</span><span class="n">first</span><span class="p">)</span> <span class="err">，看清出，这里是</span><span class="n">y的key不小于x的key</span> <span class="err">，结合前提条件，</span><span class="n">__x</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">__y</span><span class="p">.</span><span class="n">first</span> <span class="err">不成立，即</span><span class="n">x的key不小于y的key</span> 
<span class="err">即：</span>  <span class="o">!</span><span class="p">(</span><span class="n">__y</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">__x</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>  <span class="o">&amp;&amp;</span>   <span class="o">!</span><span class="p">(</span><span class="n">__x</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">__y</span><span class="p">.</span><span class="n">first</span> <span class="p">)</span>   <span class="err">等价于</span>   <span class="n">__x</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">__y</span><span class="p">.</span><span class="n">first</span> <span class="p">,</span><span class="err">也就是说，第二种情况是在</span><span class="n">key相等的情况下</span><span class="err">，比较两者的</span><span class="n">value</span><span class="err">（</span><span class="n">second</span><span class="err">）。</span>
</code></pre></td></tr></table>
</div>
</div><p>这里比较令人费解的地方就是，为什么不直接写 __x.first == __y.first 呢？ 这么写看似费解，但其实也不无道理：前面讲过，作为map的key必须实现&lt;操作符的重载，但是并不保证==符也被重载了，如果key没有提供==，那么 ，__x.first == __y.first 这样写就错了。由此可见，stl中的代码是相当严谨的，值得我们好好研读。
现在我们知道了pair类重载了&lt;符，但是它并不是按照value进行比较的，而是先对key进行比较，key相等时候才对value进行比较。显然不能满足我们按value进行排序的要求。
而且，既然pair已经重载了&lt;符，而且我们不能修改其实现，又不能在外部重复实现重载&lt;符。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">PAIR</span><span class="p">;</span>  
<span class="kt">bool</span> <span class="n">operator</span><span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">PAIR</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">PAIR</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>  
    <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>  
<span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><p>如果pair类本身没有重载&lt;符，那么我们按照上面的代码重载&lt;符，是可以实现对pair的按value比较的。现在这样做不行了，甚至会出错（编译器不同，严格的就报错）。</p>
<p>那么我们如何实现对pair按value进行比较呢？ 第一种：是最原始的方法，写一个比较函数；  第二种：刚才用到了，写一个函数对象。这两种方式实现起来都比较简单。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">PAIR</span><span class="p">;</span>  
  
<span class="kt">bool</span> <span class="nf">cmp_by_value</span><span class="p">(</span><span class="k">const</span> <span class="n">PAIR</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">PAIR</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>  
  <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>  
<span class="p">}</span>  
  
<span class="k">struct</span> <span class="n">CmpByValue</span> <span class="p">{</span>  
  <span class="kt">bool</span> <span class="n">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">PAIR</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">PAIR</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>  
    <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>  
  <span class="p">}</span>  
<span class="p">};</span>  
</code></pre></td></tr></table>
</div>
</div><p>接下来，我们看下sort算法，是不是也像map一样，可以让我们自己指定元素间如何进行比较呢？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">RandomAccessIterator</span><span class="o">&gt;</span>  
  <span class="kt">void</span> <span class="n">sort</span> <span class="p">(</span> <span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomAccessIterator</span> <span class="n">last</span> <span class="p">);</span>  
  
<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">RandomAccessIterator</span><span class="p">,</span> <span class="n">class</span> <span class="n">Compare</span><span class="o">&gt;</span>  
  <span class="kt">void</span> <span class="n">sort</span> <span class="p">(</span> <span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomAccessIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Compare</span> <span class="n">comp</span> <span class="p">);</span>  
</code></pre></td></tr></table>
</div>
</div><p>我们看到，令人兴奋的是，sort算法和map一样，也可以让我们指定元素间如何进行比较，即指定Compare。需要注意的是，map是在定义时指定的，所以传参的时候直接传入函数对象的类名，就像指定key和value时指定的类型名一样；sort算法是在调用时指定的，需要传入一个对象，当然这个也简单，类名()就会调用构造函数生成对象。这里也可以传入一个函数指针，就是把上面说的第一种方法的函数名传过来。</p>
<p><strong>值得注意的是,因为是按value排序,所以不必使用map自带的红黑树排序,此时用unordered_map代替map</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span><span class="cpf">&lt;map&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">PAIR</span><span class="p">;</span>
<span class="n">ostream</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">PAIR</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\t</span><span class="s">&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">struct</span> <span class="n">CmpByValue</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="n">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">PAIR</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">PAIR</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">name_score_map</span><span class="p">;</span>
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;LiMin&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">90</span><span class="p">;</span>
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;ZiLinMi&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">79</span><span class="p">;</span>
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;BoB&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">92</span><span class="p">;</span>
  <span class="n">name_score_map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&#34;Bing&#34;</span><span class="p">,</span><span class="mi">99</span><span class="p">));</span>
  <span class="n">name_score_map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&#34;Albert&#34;</span><span class="p">,</span><span class="mi">86</span><span class="p">));</span>
 <span class="c1">//把map中元素转存到vector中
</span><span class="c1"></span>  <span class="n">vector</span><span class="o">&lt;</span> <span class="n">PAIR</span> <span class="o">&gt;</span> <span class="n">name_score_vec</span><span class="p">(</span><span class="n">name_score_map</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">name_score_map</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="n">sort</span><span class="p">(</span><span class="n">name_score_vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">name_score_vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">CmpByValue</span><span class="p">());</span>
 <span class="c1">// sort(name_score_vec.begin(), name_score_vec.end(), cmp_by_value);
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">name_score_vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">name_score_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>参考:<a href="">http://blog.csdn.net/iicy266/article/details/11906189</a></p>
<p>#map中的属性为结构体</p>
<p>Map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。这里说下map内部数据的组织，map内部自建一颗红黑树(一种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的，后边我们会见识到有序的好处。</p>
<p>在一些特殊情况，比如关键字是一个结构体，涉及到排序就会出现问题，因为它没有小于号操作，insert等函数在编译的时候过不去，下面给出两个方法解决这个问题</p>
<p>第一种：&quot;&lt;&ldquo;号重载，程序举例</p>
<p>只要重载小于号，就OK了，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">Typedef</span> <span class="k">struct</span> <span class="n">tagStudentInfo</span>

<span class="p">{</span>

       <span class="n">Int</span>      <span class="n">nID</span><span class="p">;</span>

       <span class="n">String</span>   <span class="n">strName</span><span class="p">;</span>

       <span class="kt">bool</span> <span class="n">operator</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">tagStudentInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_A</span><span class="p">)</span> <span class="k">const</span>

       <span class="p">{</span>

              <span class="c1">//这个函数指定排序策略，按nID排序，如果nID相等的话，按strName排序
</span><span class="c1"></span>
              <span class="n">If</span><span class="p">(</span><span class="n">nID</span> <span class="o">&lt;</span> <span class="n">_A</span><span class="p">.</span><span class="n">nID</span><span class="p">)</span>  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

              <span class="n">If</span><span class="p">(</span><span class="n">nID</span> <span class="o">==</span> <span class="n">_A</span><span class="p">.</span><span class="n">nID</span><span class="p">)</span> <span class="k">return</span> <span class="n">strName</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="n">_A</span><span class="p">.</span><span class="n">strName</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>

              <span class="n">Return</span> <span class="nb">false</span><span class="p">;</span>

       <span class="p">}</span>

<span class="p">}</span><span class="n">StudentInfo</span><span class="p">,</span> <span class="o">*</span><span class="n">PStudentInfo</span><span class="p">;</span>  <span class="c1">//学生信息
</span></code></pre></td></tr></table>
</div>
</div><p>第二种：仿函数的应用，这个时候结构体中没有直接的小于号重载，程序说明</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tagStudentInfo</span>
<span class="p">{</span>
       <span class="kt">int</span>      <span class="n">nID</span><span class="p">;</span>
       <span class="n">string</span>   <span class="n">strName</span><span class="p">;</span>
<span class="p">}</span><span class="n">StudentInfo</span><span class="p">,</span> <span class="o">*</span><span class="n">PStudentInfo</span><span class="p">;</span>  <span class="c1">//学生信息
</span><span class="c1"></span>
<span class="n">classs</span> <span class="n">sort</span>
<span class="p">{</span>
       <span class="nl">Public</span><span class="p">:</span>
       <span class="n">Bool</span> <span class="n">operator</span><span class="p">()</span> <span class="p">(</span><span class="n">StudentInfo</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">_A</span><span class="p">,</span> <span class="n">StudentInfo</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">_B</span><span class="p">)</span> <span class="k">const</span>
       <span class="p">{</span>
              <span class="k">if</span><span class="p">(</span><span class="n">_A</span><span class="p">.</span><span class="n">nID</span> <span class="o">&lt;</span> <span class="n">_B</span><span class="p">.</span><span class="n">nID</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
              <span class="k">if</span><span class="p">(</span><span class="n">_A</span><span class="p">.</span><span class="n">nID</span> <span class="o">==</span> <span class="n">_B</span><span class="p">.</span><span class="n">nID</span><span class="p">)</span> <span class="k">return</span> <span class="n">_A</span><span class="p">.</span><span class="n">strName</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="n">_B</span><span class="p">.</span><span class="n">strName</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>
              <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

       <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>注意:unordered_map不能提供一个结构体的hash值,所以当map的key是结构体时,即使不需要map内部排序,也不能用unordered_map替代map。</strong></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2017-07-21
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/scanf%E5%92%8Csscanf%E8%AF%A6%E8%A7%A3/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">scanf()和sscanf()详解</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/">
            <span class="next-text nav-default">约瑟夫环</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
