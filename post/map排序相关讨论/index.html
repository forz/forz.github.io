<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>map排序相关讨论 | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="map是用来存放&lt;key, value&gt;键值对的数据结构，可以很方便快速的根据key查到相应的value。假如存储学生和其成绩（假">
<meta name="author" content="">
<link rel="canonical" href="/post/map%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E8%AE%A8%E8%AE%BA/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="map排序相关讨论" />
<meta property="og:description" content="map是用来存放&lt;key, value&gt;键值对的数据结构，可以很方便快速的根据key查到相应的value。假如存储学生和其成绩（假" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/map%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E8%AE%A8%E8%AE%BA/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-07-21T15:22:43&#43;00:00" />
<meta property="article:modified_time" content="2017-07-21T15:22:43&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="map排序相关讨论"/>
<meta name="twitter:description" content="map是用来存放&lt;key, value&gt;键值对的数据结构，可以很方便快速的根据key查到相应的value。假如存储学生和其成绩（假"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "map排序相关讨论",
      "item": "/post/map%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E8%AE%A8%E8%AE%BA/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "map排序相关讨论",
  "name": "map排序相关讨论",
  "description": "map是用来存放\u0026lt;key, value\u0026gt;键值对的数据结构，可以很方便快速的根据key查到相应的value。假如存储学生和其成绩（假",
  "keywords": [
    
  ],
  "articleBody": "map是用来存放键值对的数据结构，可以很方便快速的根据key查到相应的value。假如存储学生和其成绩（假定不存在重名，当然可以对重名加以区分），我们用map来进行存储就是个不错的选择。 我们这样定义，map，其中学生姓名用string类型，作为Key；该学生的成绩用int类型，作为value。这样一来，我们可以根据学生姓名快速的查找到他的成绩。\n但是，我们除了希望能够查询某个学生的成绩，或许还想看看整体的情况。我们想把所有同学和他相应的成绩都输出来，并且按照我们想要的顺序进行输出：比如按照学生姓名的顺序进行输出，或者按照学生成绩的高低进行输出。换句话说，我们希望能够对map进行按Key排序或按Value排序，然后按序输出其键值对的内容。\n#map中的属性为基本属性 ##Map按Key排序\n其实，为了实现快速查找，map内部本身就是按序存储的（比如红黑树）。在我们插入键值对时，就会按照key的大小顺序进行存储。这也是作为key的类型必须能够进行1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #include #include #include using namespace std; typedef pairstring, int PAIR; ostream\u0026 operator(ostream\u0026 out, const PAIR\u0026 p) { return out  p.first  \"\\t\"  p.second; } int main() { mapstring, int name_score_map; name_score_map[\"LiMin\"] = 90; name_score_map[\"ZiLinMi\"] = 79; name_score_map[\"BoB\"] = 92; name_score_map.insert(make_pair(\"Bing\",99)); name_score_map.insert(make_pair(\"Albert\",86)); for (mapstring, int::iterator iter = name_score_map.begin(); iter != name_score_map.end(); ++iter) { cout  *iter  endl; } return 0; }   大家都知道map是stl里面的一个模板类，现在我们来看下map的定义：\ntemplate , class Allocator = allocator  class map;  它有四个参数，其中我们比较熟悉的有两个: Key 和 Value。第四个是 Allocator，用来定义存储分配模型的，此处我们不作介绍。\n现在我们重点看下第三个参数： class Compare = less这也是一个class类型的，而且提供了默认值 less。 less是stl里面的一个函数对象，那么什么是函数对象呢？ 所谓的函数对象：即调用操作符的类，其对象常称为函数对象（function object），它们是行为类似函数的对象。表现出一个函数的特征，就是通过“对象名+(参数列表)”的方式使用一个 类，其实质是对operator()操作符的重载。\n现在我们来看一下less的实现：\n1 2 3 4  template class T struct less : binary_function T,T,bool { bool operator() (const T\u0026 x, const T\u0026 y) const {return xy;} };   它是一个带模板的struct，里面仅仅对()运算符进行了重载，实现很简单，但用起来很方便，这就是函数对象的优点所在。stl中还为四则运算等常见运算定义了这样的函数对象，与less相对的还有greater：\n1 2 3 4  template class T struct greater : binary_function T,T,bool { bool operator() (const T\u0026 x, const T\u0026 y) const {return xy;} };   map这里指定less作为其默认比较函数(对象)，所以我们通常如果不自己指定Compare，map中键值对就会按照Key的less顺序进行组织存储，因此我们就看到了上面代码输出结果是按照学生姓名的字典顺序输出的，即string的less序列。\n我们可以在定义map的时候，指定它的第三个参数Compare，比如我们把默认的less指定为greater：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #include #include #include using namespace std; typedef pairstring, int PAIR; ostream\u0026 operator(ostream\u0026 out, const PAIR\u0026 p) { return out  p.first  \"\\t\"  p.second; } int main() { mapstring, int, greaterstring  name_score_map; name_score_map[\"LiMin\"] = 90; name_score_map[\"ZiLinMi\"] = 79; name_score_map[\"BoB\"] = 92; name_score_map.insert(make_pair(\"Bing\",99)); name_score_map.insert(make_pair(\"Albert\",86)); for (mapstring, int::iterator iter = name_score_map.begin(); iter != name_score_map.end(); ++iter) { cout  *iter  endl; } return 0; }   现在知道如何为map指定Compare类了，如果我们想自己写一个compare的类，让map按照我们想要的顺序来存储，比如，按照学生姓名的长短排序进行存储，那该怎么做呢？\n其实很简单，只要我们自己写一个函数对象，实现想要的逻辑，定义map的时候把Compare指定为我们自己编写的这个就ok啦。\n1 2 3 4 5  struct CmpByKeyLength { bool operator()(const string\u0026 k1, const string\u0026 k2) { return k1.length()  k2.length(); } };   是不是很简单！这里我们不用把它定义为模板，直接指定它的参数为string类型就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  int main() { mapstring, int, CmpByKeyLength name_score_map; name_score_map[\"LiMin\"] = 90; name_score_map[\"ZiLinMi\"] = 79; name_score_map[\"BoB\"] = 92; name_score_map.insert(make_pair(\"Bing\",99)); name_score_map.insert(make_pair(\"Albert\",86)); for (mapstring, int::iterator iter = name_score_map.begin(); iter != name_score_map.end(); ++iter) { cout  *iter  endl; } return 0; }   按Value排序 在第一部分中，我们借助map提供的参数接口，为它指定相应Compare类，就可以实现对map按Key排序，是在创建map并不断的向其中添加元素的过程中就会完成排序。\n现在我们想要从map中得到学生按成绩的从低到高的次序输出，该如何实现呢？换句话说，该如何实现Map的按Value排序呢？\n第一反应是利用stl中提供的sort算法实现，这个想法是好的，不幸的是，sort算法有个限制，利用sort算法只能对序列容器进行排序，就是线性的（如vector，list，deque）。map也是一个集合容器，它里面存储的元素是pair，但是它不是线性存储的（前面提过，像红黑树），所以利用sort不能直接和map结合进行排序。\n虽然不能直接用sort对map进行排序，那么我们可不可以迂回一下，把map中的元素放到序列容器（如vector）中，然后再对这些元素进行排序呢？这个想法看似是可行的。要对序列容器中的元素进行排序，也有个必要条件：就是容器中的元素必须是可比较的，也就是实现了我们知道map中的元素类型为pair，具体定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12  template class T1, class T2 struct pair { typedef T1 first_type; typedef T2 second_type; T1 first; T2 second; pair() : first(T1()), second(T2()) {} pair(const T1\u0026 x, const T2\u0026 y) : first(x), second(y) {} template class U, class V pair (const pairU,V \u0026p) : first(p.first), second(p.second) { } }   pair也是一个模板类，这样就实现了良好的通用性。它仅有两个数据成员first 和 second，即 key 和 value，而且在头文件中，还为pair重载了 1 2 3 4 5  templateclass _T1, class _T2 inline bool operator(const pair_T1, _T2\u0026 __x, const pair_T1, _T2\u0026 __y) { return __x.first  __y.first || (!(__y.first  __x.first) \u0026\u0026 __x.second  __y.second); }   1 2 3 4 5  这个less在两种情况下返回true，第一种情况：__x.first  __y.first 这个好理解，就是比较key，如果__x的key 小于 __y的key 则返回true。 第二种情况有点费解： !(__y.first  __x.first) \u0026\u0026 __x.second  __y.second 当然由于||运算具有短路作用，即当前面的条件不满足是，才进行第二种情况的判断 。第一种情况__x.first  __y.first 不成立，即__x.first = __y.first 成立，在这个条件下，我们来分析下 !(__y.first  __x.first) \u0026\u0026 __x.second  __y.second !(__y.first  __x.first) ，看清出，这里是y的key不小于x的key ，结合前提条件，__x.first  __y.first 不成立，即x的key不小于y的key 即： !(__y.first  __x.first) \u0026\u0026 !(__x.first  __y.first ) 等价于 __x.first == __y.first ,也就是说，第二种情况是在key相等的情况下，比较两者的value（second）。   这里比较令人费解的地方就是，为什么不直接写 __x.first == __y.first 呢？ 这么写看似费解，但其实也不无道理：前面讲过，作为map的key必须实现1 2 3 4  typedef pairstring, int PAIR; bool operator (const PAIR\u0026 lhs, const PAIR\u0026 rhs) { return lhs.second  rhs.second; }   如果pair类本身没有重载那么我们如何实现对pair按value进行比较呢？ 第一种：是最原始的方法，写一个比较函数； 第二种：刚才用到了，写一个函数对象。这两种方式实现起来都比较简单。\n1 2 3 4 5 6 7 8 9 10 11  typedef pairstring, int PAIR; bool cmp_by_value(const PAIR\u0026 lhs, const PAIR\u0026 rhs) { return lhs.second  rhs.second; } struct CmpByValue { bool operator()(const PAIR\u0026 lhs, const PAIR\u0026 rhs) { return lhs.second  rhs.second; } };   接下来，我们看下sort算法，是不是也像map一样，可以让我们自己指定元素间如何进行比较呢？\n1 2 3 4 5  template class RandomAccessIterator void sort ( RandomAccessIterator first, RandomAccessIterator last ); template class RandomAccessIterator, class Compare void sort ( RandomAccessIterator first, RandomAccessIterator last, Compare comp );   我们看到，令人兴奋的是，sort算法和map一样，也可以让我们指定元素间如何进行比较，即指定Compare。需要注意的是，map是在定义时指定的，所以传参的时候直接传入函数对象的类名，就像指定key和value时指定的类型名一样；sort算法是在调用时指定的，需要传入一个对象，当然这个也简单，类名()就会调用构造函数生成对象。这里也可以传入一个函数指针，就是把上面说的第一种方法的函数名传过来。\n值得注意的是,因为是按value排序,所以不必使用map自带的红黑树排序,此时用unordered_map代替map\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  #include#include#include#include#includeusing namespace std; typedef pairstring, int PAIR; ostream\u0026 operator(ostream\u0026 out, const PAIR\u0026 p) { return out  p.first  \"\\t\"  p.second; } struct CmpByValue { bool operator()(const PAIR\u0026 lhs, const PAIR\u0026 rhs) { return lhs.second  rhs.second; } }; int main() { unordered_mapstring, int name_score_map; name_score_map[\"LiMin\"] = 90; name_score_map[\"ZiLinMi\"] = 79; name_score_map[\"BoB\"] = 92; name_score_map.insert(make_pair(\"Bing\",99)); name_score_map.insert(make_pair(\"Albert\",86)); //把map中元素转存到vector中  vector PAIR  name_score_vec(name_score_map.begin(), name_score_map.end()); sort(name_score_vec.begin(), name_score_vec.end(), CmpByValue()); // sort(name_score_vec.begin(), name_score_vec.end(), cmp_by_value);  for (int i = 0; i != name_score_vec.size(); ++i) { cout  name_score_vec[i]  endl; } return 0; }   参考:http://blog.csdn.net/iicy266/article/details/11906189\n#map中的属性为结构体\nMap是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。这里说下map内部数据的组织，map内部自建一颗红黑树(一种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的，后边我们会见识到有序的好处。\n在一些特殊情况，比如关键字是一个结构体，涉及到排序就会出现问题，因为它没有小于号操作，insert等函数在编译的时候过不去，下面给出两个方法解决这个问题\n第一种：\"只要重载小于号，就OK了，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  Typedef struct tagStudentInfo { Int nID; String strName; bool operator  (tagStudentInfo const\u0026 _A) const { //这个函数指定排序策略，按nID排序，如果nID相等的话，按strName排序  If(nID  _A.nID) return true; If(nID == _A.nID) return strName.compare(_A.strName)  0; Return false; } }StudentInfo, *PStudentInfo; //学生信息   第二种：仿函数的应用，这个时候结构体中没有直接的小于号重载，程序说明\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #include #include using namespace std; typedef struct tagStudentInfo { int nID; string strName; }StudentInfo, *PStudentInfo; //学生信息  classs sort { Public: Bool operator() (StudentInfo const \u0026_A, StudentInfo const \u0026_B) const { if(_A.nID  _B.nID) return true; if(_A.nID == _B.nID) return _A.strName.compare(_B.strName)  0; return false; } };   注意:unordered_map不能提供一个结构体的hash值,所以当map的key是结构体时,即使不需要map内部排序,也不能用unordered_map替代map。\n",
  "wordCount" : "4294",
  "inLanguage": "zh-cn",
  "datePublished": "2017-07-21T15:22:43Z",
  "dateModified": "2017-07-21T15:22:43Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/map%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E8%AE%A8%E8%AE%BA/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      map排序相关讨论
    </h1>
    <div class="post-meta">July 21, 2017
</div>
  </header> 
  <div class="post-content"><p>map是用来存放&lt;key, value&gt;键值对的数据结构，可以很方便快速的根据key查到相应的value。假如存储学生和其成绩（假定不存在重名，当然可以对重名加以区分），我们用map来进行存储就是个不错的选择。 我们这样定义，map&lt;string, int&gt;，其中学生姓名用string类型，作为Key；该学生的成绩用int类型，作为value。这样一来，我们可以根据学生姓名快速的查找到他的成绩。</p>
<p>但是，我们除了希望能够查询某个学生的成绩，或许还想看看整体的情况。我们想把所有同学和他相应的成绩都输出来，并且按照我们想要的顺序进行输出：比如按照学生姓名的顺序进行输出，或者按照学生成绩的高低进行输出。换句话说，我们希望能够对map进行按Key排序或按Value排序，然后按序输出其键值对的内容。</p>
<p>#map中的属性为基本属性
##Map按Key排序</p>
<p>其实，为了实现快速查找，map内部本身就是按序存储的（比如红黑树）。在我们插入&lt;key, value&gt;键值对时，就会按照key的大小顺序进行存储。这也是作为key的类型必须能够进行&lt;运算比较的原因。现在我们用string类型作为key，因此，我们的存储就是按学生姓名的字典排序储存的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span><span class="cpf">&lt;map&gt;  </span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;string&gt;  </span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;  </span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>  
  
<span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">PAIR</span><span class="p">;</span>  
  
<span class="n">ostream</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">PAIR</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>  
  <span class="k">return</span> <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\t</span><span class="s">&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>  
<span class="p">}</span>  
  
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
  <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">name_score_map</span><span class="p">;</span>  
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;LiMin&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">90</span><span class="p">;</span>   
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;ZiLinMi&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">79</span><span class="p">;</span>   
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;BoB&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">92</span><span class="p">;</span>   
  <span class="n">name_score_map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&#34;Bing&#34;</span><span class="p">,</span><span class="mi">99</span><span class="p">));</span>  
  <span class="n">name_score_map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&#34;Albert&#34;</span><span class="p">,</span><span class="mi">86</span><span class="p">));</span>  
  <span class="k">for</span> <span class="p">(</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">name_score_map</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>  
       <span class="n">iter</span> <span class="o">!=</span> <span class="n">name_score_map</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>  
       <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>  
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">iter</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  
  <span class="p">}</span>  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
 <span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><p>大家都知道map是stl里面的一个模板类，现在我们来看下map的定义：</p>
<pre><code>template &lt; class Key, class T, class Compare = less&lt;Key&gt;,  
       class Allocator = allocator&lt;pair&lt;const Key,T&gt; &gt; &gt; class map;  
</code></pre>
<p>它有四个参数，其中我们比较熟悉的有两个: Key 和 Value。第四个是 Allocator，用来定义存储分配模型的，此处我们不作介绍。</p>
<p>现在我们重点看下第三个参数： class Compare = less<!-- raw HTML omitted --></p>
<p>这也是一个class类型的，而且提供了默认值 less<!-- raw HTML omitted -->。 less是stl里面的一个函数对象，那么什么是函数对象呢？
所谓的函数对象：即调用操作符的类，其对象常称为函数对象（function object），它们是行为类似函数的对象。表现出一个函数的特征，就是通过“对象名+(参数列表)”的方式使用一个 类，其实质是对operator()操作符的重载。</p>
<p>现在我们来看一下less的实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nl">less</span> <span class="p">:</span> <span class="n">binary_function</span> <span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>  
  <span class="kt">bool</span> <span class="n">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span>  
    <span class="p">{</span><span class="k">return</span> <span class="n">x</span><span class="o">&lt;</span><span class="n">y</span><span class="p">;}</span>  
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>它是一个带模板的struct，里面仅仅对()运算符进行了重载，实现很简单，但用起来很方便，这就是函数对象的优点所在。stl中还为四则运算等常见运算定义了这样的函数对象，与less相对的还有greater：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nl">greater</span> <span class="p">:</span> <span class="n">binary_function</span> <span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>  
  <span class="kt">bool</span> <span class="n">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span>  
    <span class="p">{</span><span class="k">return</span> <span class="n">x</span><span class="o">&gt;</span><span class="n">y</span><span class="p">;}</span>  
<span class="p">};</span> 
</code></pre></td></tr></table>
</div>
</div><p>map这里指定less作为其默认比较函数(对象)，所以我们通常如果不自己指定Compare，map中键值对就会按照Key的less顺序进行组织存储，因此我们就看到了上面代码输出结果是按照学生姓名的字典顺序输出的，即string的less序列。</p>
<p>我们可以在定义map的时候，指定它的第三个参数Compare，比如我们把默认的less指定为greater：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span><span class="cpf">&lt;map&gt;  </span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;string&gt;  </span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;  </span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>  
  
<span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">PAIR</span><span class="p">;</span>  
  
<span class="n">ostream</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">PAIR</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>  
  <span class="k">return</span> <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\t</span><span class="s">&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>  
<span class="p">}</span>  
  
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
  <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">name_score_map</span><span class="p">;</span>  
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;LiMin&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">90</span><span class="p">;</span>   
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;ZiLinMi&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">79</span><span class="p">;</span>   
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;BoB&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">92</span><span class="p">;</span>   
  <span class="n">name_score_map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&#34;Bing&#34;</span><span class="p">,</span><span class="mi">99</span><span class="p">));</span>  
  <span class="n">name_score_map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&#34;Albert&#34;</span><span class="p">,</span><span class="mi">86</span><span class="p">));</span>  
  <span class="k">for</span> <span class="p">(</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">name_score_map</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>  
       <span class="n">iter</span> <span class="o">!=</span> <span class="n">name_score_map</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>  
       <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>  
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">iter</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  
  <span class="p">}</span>  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
<span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><p>现在知道如何为map指定Compare类了，如果我们想自己写一个compare的类，让map按照我们想要的顺序来存储，比如，按照学生姓名的长短排序进行存储，那该怎么做呢？</p>
<p>其实很简单，只要我们自己写一个函数对象，实现想要的逻辑，定义map的时候把Compare指定为我们自己编写的这个就ok啦。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">CmpByKeyLength</span> <span class="p">{</span>  
  <span class="kt">bool</span> <span class="n">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">k1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">k2</span><span class="p">)</span> <span class="p">{</span>  
    <span class="k">return</span> <span class="n">k1</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">k2</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>  
  <span class="p">}</span>  
<span class="p">};</span> 
</code></pre></td></tr></table>
</div>
</div><p>是不是很简单！这里我们不用把它定义为模板，直接指定它的参数为string类型就可以了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>  
  <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">CmpByKeyLength</span><span class="o">&gt;</span> <span class="n">name_score_map</span><span class="p">;</span>  
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;LiMin&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">90</span><span class="p">;</span>   
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;ZiLinMi&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">79</span><span class="p">;</span>   
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;BoB&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">92</span><span class="p">;</span>   
  <span class="n">name_score_map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&#34;Bing&#34;</span><span class="p">,</span><span class="mi">99</span><span class="p">));</span>  
  <span class="n">name_score_map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&#34;Albert&#34;</span><span class="p">,</span><span class="mi">86</span><span class="p">));</span>  
  <span class="k">for</span> <span class="p">(</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">name_score_map</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>  
       <span class="n">iter</span> <span class="o">!=</span> <span class="n">name_score_map</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>  
       <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>  
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">iter</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  
  <span class="p">}</span>  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
<span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><h2 id="按value排序">按Value排序<a hidden class="anchor" aria-hidden="true" href="#按value排序">#</a></h2>
<p>在第一部分中，我们借助map提供的参数接口，为它指定相应Compare类，就可以实现对map按Key排序，是在创建map并不断的向其中添加元素的过程中就会完成排序。</p>
<p>现在我们想要从map中得到学生按成绩的从低到高的次序输出，该如何实现呢？换句话说，该如何实现Map的按Value排序呢？</p>
<p>第一反应是利用stl中提供的sort算法实现，这个想法是好的，不幸的是，sort算法有个限制，利用sort算法只能对序列容器进行排序，就是线性的（如vector，list，deque）。map也是一个集合容器，它里面存储的元素是pair，但是它不是线性存储的（前面提过，像红黑树），所以利用sort不能直接和map结合进行排序。</p>
<p>虽然不能直接用sort对map进行排序，那么我们可不可以迂回一下，把map中的元素放到序列容器（如vector）中，然后再对这些元素进行排序呢？这个想法看似是可行的。要对序列容器中的元素进行排序，也有个必要条件：就是容器中的元素必须是可比较的，也就是实现了&lt;操作的。那么我们现在就来看下map中的元素满足这个条件么？</p>
<p>我们知道map中的元素类型为pair，具体定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T1</span><span class="p">,</span> <span class="n">class</span> <span class="n">T2</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">pair</span>  
<span class="p">{</span>  
  <span class="k">typedef</span> <span class="n">T1</span> <span class="n">first_type</span><span class="p">;</span>  
  <span class="k">typedef</span> <span class="n">T2</span> <span class="n">second_type</span><span class="p">;</span>  
  
  <span class="n">T1</span> <span class="n">first</span><span class="p">;</span>  
  <span class="n">T2</span> <span class="n">second</span><span class="p">;</span>  
  <span class="n">pair</span><span class="p">()</span> <span class="o">:</span> <span class="n">first</span><span class="p">(</span><span class="n">T1</span><span class="p">()),</span> <span class="n">second</span><span class="p">(</span><span class="n">T2</span><span class="p">())</span> <span class="p">{}</span>  
  <span class="n">pair</span><span class="p">(</span><span class="k">const</span> <span class="n">T1</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">T2</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="o">:</span> <span class="n">first</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">second</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">{}</span>  
  <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">U</span><span class="p">,</span> <span class="n">class</span> <span class="n">V</span><span class="o">&gt;</span>  
    <span class="n">pair</span> <span class="p">(</span><span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="o">:</span> <span class="n">first</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">),</span> <span class="n">second</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>  
<span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><p>pair也是一个模板类，这样就实现了良好的通用性。它仅有两个数据成员first 和 second，即 key 和 value，而且在<!-- raw HTML omitted -->头文件中，还为pair重载了 &lt; 运算符， 具体实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">_T1</span><span class="p">,</span> <span class="n">class</span> <span class="n">_T2</span><span class="o">&gt;</span>  
  <span class="kr">inline</span> <span class="kt">bool</span>  
  <span class="n">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">_T1</span><span class="p">,</span> <span class="n">_T2</span><span class="o">&gt;&amp;</span> <span class="n">__x</span><span class="p">,</span> <span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">_T1</span><span class="p">,</span> <span class="n">_T2</span><span class="o">&gt;&amp;</span> <span class="n">__y</span><span class="p">)</span>  
  <span class="p">{</span> <span class="k">return</span> <span class="n">__x</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">__y</span><span class="p">.</span><span class="n">first</span>  
           <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">__y</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">__x</span><span class="p">.</span><span class="n">first</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">__x</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">__y</span><span class="p">.</span><span class="n">second</span><span class="p">);</span> <span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="err">这个</span><span class="n">less在两种情况下返回true</span><span class="err">，第一种情况：</span><span class="n">__x</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">__y</span><span class="p">.</span><span class="n">first</span>  <span class="err">这个好理解，就是比较</span><span class="n">key</span><span class="err">，如果</span><span class="n">__x的key</span> <span class="err">小于</span> <span class="n">__y的key</span> <span class="err">则返回</span><span class="nb">true</span><span class="err">。</span>
<span class="err">第二种情况有点费解：</span>  <span class="o">!</span><span class="p">(</span><span class="n">__y</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">__x</span><span class="p">.</span><span class="n">first</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">__x</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">__y</span><span class="p">.</span><span class="n">second</span>
<span class="err">当然由于</span><span class="o">||</span><span class="err">运算具有短路作用，即当前面的条件不满足是，才进行第二种情况的判断</span> <span class="err">。第一种情况</span><span class="n">__x</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">__y</span><span class="p">.</span><span class="n">first</span> <span class="err">不成立，即</span><span class="n">__x</span><span class="p">.</span><span class="n">first</span> <span class="o">&gt;=</span> <span class="n">__y</span><span class="p">.</span><span class="n">first</span> <span class="err">成立，在这个条件下，我们来分析下</span>  <span class="o">!</span><span class="p">(</span><span class="n">__y</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">__x</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>  <span class="o">&amp;&amp;</span> <span class="n">__x</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">__y</span><span class="p">.</span><span class="n">second</span>
 <span class="o">!</span><span class="p">(</span><span class="n">__y</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">__x</span><span class="p">.</span><span class="n">first</span><span class="p">)</span> <span class="err">，看清出，这里是</span><span class="n">y的key不小于x的key</span> <span class="err">，结合前提条件，</span><span class="n">__x</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">__y</span><span class="p">.</span><span class="n">first</span> <span class="err">不成立，即</span><span class="n">x的key不小于y的key</span> 
<span class="err">即：</span>  <span class="o">!</span><span class="p">(</span><span class="n">__y</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">__x</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>  <span class="o">&amp;&amp;</span>   <span class="o">!</span><span class="p">(</span><span class="n">__x</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">__y</span><span class="p">.</span><span class="n">first</span> <span class="p">)</span>   <span class="err">等价于</span>   <span class="n">__x</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">__y</span><span class="p">.</span><span class="n">first</span> <span class="p">,</span><span class="err">也就是说，第二种情况是在</span><span class="n">key相等的情况下</span><span class="err">，比较两者的</span><span class="n">value</span><span class="err">（</span><span class="n">second</span><span class="err">）。</span>
</code></pre></td></tr></table>
</div>
</div><p>这里比较令人费解的地方就是，为什么不直接写 __x.first == __y.first 呢？ 这么写看似费解，但其实也不无道理：前面讲过，作为map的key必须实现&lt;操作符的重载，但是并不保证==符也被重载了，如果key没有提供==，那么 ，__x.first == __y.first 这样写就错了。由此可见，stl中的代码是相当严谨的，值得我们好好研读。
现在我们知道了pair类重载了&lt;符，但是它并不是按照value进行比较的，而是先对key进行比较，key相等时候才对value进行比较。显然不能满足我们按value进行排序的要求。
而且，既然pair已经重载了&lt;符，而且我们不能修改其实现，又不能在外部重复实现重载&lt;符。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">PAIR</span><span class="p">;</span>  
<span class="kt">bool</span> <span class="n">operator</span><span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">PAIR</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">PAIR</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>  
    <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>  
<span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><p>如果pair类本身没有重载&lt;符，那么我们按照上面的代码重载&lt;符，是可以实现对pair的按value比较的。现在这样做不行了，甚至会出错（编译器不同，严格的就报错）。</p>
<p>那么我们如何实现对pair按value进行比较呢？ 第一种：是最原始的方法，写一个比较函数；  第二种：刚才用到了，写一个函数对象。这两种方式实现起来都比较简单。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">PAIR</span><span class="p">;</span>  
  
<span class="kt">bool</span> <span class="nf">cmp_by_value</span><span class="p">(</span><span class="k">const</span> <span class="n">PAIR</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">PAIR</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>  
  <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>  
<span class="p">}</span>  
  
<span class="k">struct</span> <span class="n">CmpByValue</span> <span class="p">{</span>  
  <span class="kt">bool</span> <span class="n">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">PAIR</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">PAIR</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>  
    <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>  
  <span class="p">}</span>  
<span class="p">};</span>  
</code></pre></td></tr></table>
</div>
</div><p>接下来，我们看下sort算法，是不是也像map一样，可以让我们自己指定元素间如何进行比较呢？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">RandomAccessIterator</span><span class="o">&gt;</span>  
  <span class="kt">void</span> <span class="n">sort</span> <span class="p">(</span> <span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomAccessIterator</span> <span class="n">last</span> <span class="p">);</span>  
  
<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">RandomAccessIterator</span><span class="p">,</span> <span class="n">class</span> <span class="n">Compare</span><span class="o">&gt;</span>  
  <span class="kt">void</span> <span class="n">sort</span> <span class="p">(</span> <span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomAccessIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Compare</span> <span class="n">comp</span> <span class="p">);</span>  
</code></pre></td></tr></table>
</div>
</div><p>我们看到，令人兴奋的是，sort算法和map一样，也可以让我们指定元素间如何进行比较，即指定Compare。需要注意的是，map是在定义时指定的，所以传参的时候直接传入函数对象的类名，就像指定key和value时指定的类型名一样；sort算法是在调用时指定的，需要传入一个对象，当然这个也简单，类名()就会调用构造函数生成对象。这里也可以传入一个函数指针，就是把上面说的第一种方法的函数名传过来。</p>
<p><strong>值得注意的是,因为是按value排序,所以不必使用map自带的红黑树排序,此时用unordered_map代替map</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span><span class="cpf">&lt;map&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">PAIR</span><span class="p">;</span>
<span class="n">ostream</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">PAIR</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\t</span><span class="s">&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">struct</span> <span class="n">CmpByValue</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="n">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">PAIR</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">PAIR</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">name_score_map</span><span class="p">;</span>
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;LiMin&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">90</span><span class="p">;</span>
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;ZiLinMi&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">79</span><span class="p">;</span>
  <span class="n">name_score_map</span><span class="p">[</span><span class="s">&#34;BoB&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">92</span><span class="p">;</span>
  <span class="n">name_score_map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&#34;Bing&#34;</span><span class="p">,</span><span class="mi">99</span><span class="p">));</span>
  <span class="n">name_score_map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&#34;Albert&#34;</span><span class="p">,</span><span class="mi">86</span><span class="p">));</span>
 <span class="c1">//把map中元素转存到vector中
</span><span class="c1"></span>  <span class="n">vector</span><span class="o">&lt;</span> <span class="n">PAIR</span> <span class="o">&gt;</span> <span class="n">name_score_vec</span><span class="p">(</span><span class="n">name_score_map</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">name_score_map</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="n">sort</span><span class="p">(</span><span class="n">name_score_vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">name_score_vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">CmpByValue</span><span class="p">());</span>
 <span class="c1">// sort(name_score_vec.begin(), name_score_vec.end(), cmp_by_value);
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">name_score_vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">name_score_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>参考:<a href="">http://blog.csdn.net/iicy266/article/details/11906189</a></p>
<p>#map中的属性为结构体</p>
<p>Map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。这里说下map内部数据的组织，map内部自建一颗红黑树(一种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的，后边我们会见识到有序的好处。</p>
<p>在一些特殊情况，比如关键字是一个结构体，涉及到排序就会出现问题，因为它没有小于号操作，insert等函数在编译的时候过不去，下面给出两个方法解决这个问题</p>
<p>第一种：&quot;&lt;&ldquo;号重载，程序举例</p>
<p>只要重载小于号，就OK了，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">Typedef</span> <span class="k">struct</span> <span class="n">tagStudentInfo</span>

<span class="p">{</span>

       <span class="n">Int</span>      <span class="n">nID</span><span class="p">;</span>

       <span class="n">String</span>   <span class="n">strName</span><span class="p">;</span>

       <span class="kt">bool</span> <span class="n">operator</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">tagStudentInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_A</span><span class="p">)</span> <span class="k">const</span>

       <span class="p">{</span>

              <span class="c1">//这个函数指定排序策略，按nID排序，如果nID相等的话，按strName排序
</span><span class="c1"></span>
              <span class="n">If</span><span class="p">(</span><span class="n">nID</span> <span class="o">&lt;</span> <span class="n">_A</span><span class="p">.</span><span class="n">nID</span><span class="p">)</span>  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

              <span class="n">If</span><span class="p">(</span><span class="n">nID</span> <span class="o">==</span> <span class="n">_A</span><span class="p">.</span><span class="n">nID</span><span class="p">)</span> <span class="k">return</span> <span class="n">strName</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="n">_A</span><span class="p">.</span><span class="n">strName</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>

              <span class="n">Return</span> <span class="nb">false</span><span class="p">;</span>

       <span class="p">}</span>

<span class="p">}</span><span class="n">StudentInfo</span><span class="p">,</span> <span class="o">*</span><span class="n">PStudentInfo</span><span class="p">;</span>  <span class="c1">//学生信息
</span></code></pre></td></tr></table>
</div>
</div><p>第二种：仿函数的应用，这个时候结构体中没有直接的小于号重载，程序说明</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tagStudentInfo</span>
<span class="p">{</span>
       <span class="kt">int</span>      <span class="n">nID</span><span class="p">;</span>
       <span class="n">string</span>   <span class="n">strName</span><span class="p">;</span>
<span class="p">}</span><span class="n">StudentInfo</span><span class="p">,</span> <span class="o">*</span><span class="n">PStudentInfo</span><span class="p">;</span>  <span class="c1">//学生信息
</span><span class="c1"></span>
<span class="n">classs</span> <span class="n">sort</span>
<span class="p">{</span>
       <span class="nl">Public</span><span class="p">:</span>
       <span class="n">Bool</span> <span class="n">operator</span><span class="p">()</span> <span class="p">(</span><span class="n">StudentInfo</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">_A</span><span class="p">,</span> <span class="n">StudentInfo</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">_B</span><span class="p">)</span> <span class="k">const</span>
       <span class="p">{</span>
              <span class="k">if</span><span class="p">(</span><span class="n">_A</span><span class="p">.</span><span class="n">nID</span> <span class="o">&lt;</span> <span class="n">_B</span><span class="p">.</span><span class="n">nID</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
              <span class="k">if</span><span class="p">(</span><span class="n">_A</span><span class="p">.</span><span class="n">nID</span> <span class="o">==</span> <span class="n">_B</span><span class="p">.</span><span class="n">nID</span><span class="p">)</span> <span class="k">return</span> <span class="n">_A</span><span class="p">.</span><span class="n">strName</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="n">_B</span><span class="p">.</span><span class="n">strName</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>
              <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

       <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>注意:unordered_map不能提供一个结构体的hash值,所以当map的key是结构体时,即使不需要map内部排序,也不能用unordered_map替代map。</strong></p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
