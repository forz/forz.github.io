<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>布隆过滤器实现 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="前言 想象一下遇到下面的场景你会如何处理： 手机号是否重复注册 用户是否参与过某秒杀活动 伪造请求大量 id 查询不存在的记录，此时缓存未命中,如何避免缓" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.92.0 with theme even" />


<link rel="canonical" href="/post/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%AE%9E%E7%8E%B0/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="布隆过滤器实现" />
<meta property="og:description" content="前言 想象一下遇到下面的场景你会如何处理： 手机号是否重复注册 用户是否参与过某秒杀活动 伪造请求大量 id 查询不存在的记录，此时缓存未命中,如何避免缓" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%AE%9E%E7%8E%B0/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-12-07T11:25:23+00:00" />
<meta property="article:modified_time" content="2021-12-07T11:25:23+00:00" />

<meta itemprop="name" content="布隆过滤器实现">
<meta itemprop="description" content="前言 想象一下遇到下面的场景你会如何处理： 手机号是否重复注册 用户是否参与过某秒杀活动 伪造请求大量 id 查询不存在的记录，此时缓存未命中,如何避免缓"><meta itemprop="datePublished" content="2021-12-07T11:25:23+00:00" />
<meta itemprop="dateModified" content="2021-12-07T11:25:23+00:00" />
<meta itemprop="wordCount" content="4748">
<meta itemprop="keywords" content="缓存," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="布隆过滤器实现"/>
<meta name="twitter:description" content="前言 想象一下遇到下面的场景你会如何处理： 手机号是否重复注册 用户是否参与过某秒杀活动 伪造请求大量 id 查询不存在的记录，此时缓存未命中,如何避免缓"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">布隆过滤器实现</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-12-07 </span>
        <div class="post-category">
            <a href="/categories/%E7%BC%93%E5%AD%98/"> 缓存 </a>
            </div>
          <span class="more-meta"> 约 4748 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#布隆过滤器">布隆过滤器</a>
      <ul>
        <li><a href="#工作原理">工作原理</a></li>
        <li><a href="#优缺点">优缺点</a></li>
        <li><a href="#误差假阳性率">误差(假阳性率)</a></li>
        <li><a href="#无法删除">无法删除</a></li>
        <li><a href="#判断是否在黑名单">判断是否在黑名单</a></li>
        <li><a href="#预防非法-id-导致缓存穿透">预防非法 id 导致缓存穿透</a></li>
      </ul>
    </li>
    <li><a href="#代码实现">代码实现</a>
      <ul>
        <li><a href="#对象定义">对象定义</a></li>
        <li><a href="#redisbitset">redisBitSet</a></li>
        <li><a href="#k-次散列计算出-k-个位点">k 次散列计算出 k 个位点</a></li>
        <li><a href="#插入与查询">插入与查询</a></li>
        <li><a href="#改进建议">改进建议</a></li>
        <li><a href="#完整代码">完整代码</a></li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="前言">前言</h2>
<p>想象一下遇到下面的场景你会如何处理：</p>
<ol>
<li>手机号是否重复注册</li>
<li>用户是否参与过某秒杀活动</li>
<li>伪造请求大量 id 查询不存在的记录，此时缓存未命中,如何避免缓存穿透</li>
</ol>
<p>针对以上问题常规做法是：查询数据库，数据库硬扛，如果压力并不大可以使用此方法，保持简单即可。</p>
<p>改进做法：用 list/set/tree 维护一个元素集合，判断元素是否在集合内，时间复杂度或空间复杂度会比较高。如果是微服务的话可以用 redis 中的 list/set 数据结构, 数据规模非常大此方案的内存容量要求可能会非常高。</p>
<p>这些场景有个共同点，可以将问题抽象为：如何高效判断一个元素不在集合中？那么有没有一种更好方案能达到时间复杂度和空间复杂双优呢？</p>
<p>有！布隆过滤器。</p>
<h2 id="布隆过滤器">布隆过滤器</h2>
<p>布隆过滤器（英语：Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中，它的优点是空间效率和查询时间都远远超过一般的算法。</p>
<h3 id="工作原理">工作原理</h3>
<p>布隆过滤器的原理是，当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点（offset），把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：如果这些点有任何一个 0，则被检元素一定不在；如果都是 1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p>
<p>简单来说就是准备一个长度为 m 的位数组并初始化所有元素为 0，用 k 个散列函数对元素进行 k 次散列运算跟 len(m)取余得到 k 个位置并将 m 中对应位置设置为 1。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/202112071338256.png" alt=""></p>
<h3 id="优缺点">优缺点</h3>
<p>优点：</p>
<ul>
<li>空间占用极小，因为本身不存储数据而是用比特位表示数据是否存在，某种程度有保密的效果。</li>
<li>插入与查询时间复杂度均为 O(k)，常数级别，k 表示散列函数执行次数。</li>
<li>散列函数之间可以相互独立，可以在硬件指令层加速计算。</li>
</ul>
<p>缺点：</p>
<ul>
<li>误差（假阳性率）。</li>
<li>无法删除。</li>
</ul>
<h3 id="误差假阳性率">误差(假阳性率)</h3>
<p>布隆过滤器可以 100% 判断元素不在集合中，但是当元素在集合中时可能存在误判，因为当元素非常多时散列函数产生的 k 位点可能会重复。这里我们直接给结论，假设：</p>
<ul>
<li>位数组长度 m</li>
<li>散列函数个数 k</li>
<li>预期元素数量 n</li>
<li>期望误差p</li>
</ul>
<p>在创建布隆过滤器时我们为了找到合适的 m 和 k ，可以根据预期元素数量 n 与 p 来推导出最合适的 m 与 k 。</p>
<p>$ m=-\frac{n*lnp}{(ln2)^2}$</p>
<p>$ k=ln2*\frac{m}{n} $</p>
<h3 id="无法删除">无法删除</h3>
<p>位数组中的某些 k 点是多个元素重复使用的，假如我们将其中一个元素的 k 点全部置为 0 则直接就会影响其他元素。这导致我们在使用布隆过滤器时无法处理元素被删除的场景。</p>
<p>可以通过定时重建的方式清除脏数据。假如是通过 redis 来实现的话重建时不要直接删除原有的 key，而是先生成新的再通过 rename 命令删除旧数据即可。</p>
<h3 id="判断是否在黑名单">判断是否在黑名单</h3>
<p>不安全网页的黑名单包含100亿个黑名单网页，每个网页的URL最多占用64B。现在想要实现一种网页过滤系统，可以根据网页的URL判断该网页是否在黑名单上，请设计该系统。</p>
<ol>
<li>该系统允许有万分之一以下的判断失误率。</li>
<li>使用的额外空间不要超过30GB。</li>
</ol>
<p>黑名单中样本的个数为 100 亿个，记为1：失误率不能超过 0.01%，记为p：每个样本的大小为 64B，这个信息不会影响布隆过滤器的大小，只和选择哈希两数有关，一般的哈希函数都可以接收 64B 的输入对象，所以使用布隆过滤器还有一个好处是不用顾忌单个样本的大小，它丝亳不能影响布隆过滤器的大小。</p>
<p>所以n=100亿，p=0.01%，布隆过滤器的大小m 由以下公式确定：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/202112071332930.png" alt=""></p>
<p>根据公式计算出 m=19.19n， 向上取整为 20n，即需要 2000 亿个bit，也就是 25GB。</p>
<p>哈希函数的个数由以下公式决定：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/202112071333784.png" alt=""></p>
<p>计算出哈希两数的个数为k=14个。</p>
<p>然后用 25GB 的 bitMap 再单独实现 14 个哈希两数，根据如上描述生成布隆过滤器即可。</p>
<p>因为我们在确定布隆过滤器大小的过程中选择了向上取整，所以还要用如下公式确定布隆过滤器真实的失误率为：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/202112071334595.png" alt=""></p>
<p>根据这个公式算出真实的失误率为 0.006%，这是比 0.01%更低的失误率，哈希函数本身不占用什么空间，所以使用的空间就是bitMap 的大小（即 25GB），服务器的内存都可以达到这个级别，所有要求达标。之后的判断阶段如上文的描述</p>
<h3 id="预防非法-id-导致缓存穿透">预防非法 id 导致缓存穿透</h3>
<p>由于 id 不存在导致请求无法命中缓存流量直接打到数据库，同时数据库也不存在该记录导致无法写入缓存，高并发场景这无疑会极大增加数据库压力。解决方案可以采用布隆过滤器.</p>
<p>数据写入数据库时需同步写入布隆过滤器，同时如果存在脏数据场景（比如：删除）则需要定时重建布隆过滤器，使用 redis 作为存储时不可以直接删除 bloom.key，可以采用 rename key 的方式更新 bloom</p>
<h2 id="代码实现">代码实现</h2>
<p>core/bloom/bloom.go一个布隆过滤器具备两个核心属性：</p>
<ul>
<li>位数组：</li>
<li>散列函数</li>
</ul>
<p>go-zero实现的bloom filter中位数组采用的是<code>Redis.bitmap</code>，既然采用的是 redis 自然就支持分布式场景，散列函数采用的是<code>MurmurHash3</code></p>
<p>Redis.bitmap 为什么可以作为位数组呢？</p>
<p>Redis 中的并没有单独的 bitmap 数据结构，底层使用的是动态字符串（SDS）实现，而 Redis 中的字符串实际都是以二进制存储的。a 的ASCII码是 97，转换为二进制是：01100001，如果我们要将其转换为b只需要进一位即可：01100010。下面通过Redis.setbit实现这个操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">set</span> <span class="n">foo</span> <span class="n">a</span>
<span class="n">OK</span>
<span class="n">get</span> <span class="n">foo</span>
<span class="s">&#34;a&#34;</span>
<span class="n">setbit</span> <span class="n">foo</span> <span class="m">6</span> <span class="m">1</span>
<span class="m">0</span>
<span class="n">setbit</span> <span class="n">foo</span> <span class="m">7</span> <span class="m">0</span>
<span class="m">1</span>
<span class="n">get</span> <span class="n">foo</span>
<span class="s">&#34;b&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>bitmap 底层使用的动态字符串可以实现动态扩容，当 offset 到高位时其他位置 bitmap 将会自动补 0，最大支持 2^32-1 长度的位数组（占用内存 512M），需要注意的是分配大内存会阻塞Redis进程。根据上面的算法原理可以知道实现布隆过滤器主要做三件事情：</p>
<ol>
<li>k 次散列函数计算出 k 个位点。</li>
<li>插入时将位数组中 k 个位点的值设置为 1。</li>
<li>查询时根据 1 的计算结果判断 k 位点是否全部为 1，否则表示该元素一定不存在。</li>
</ol>
<h3 id="对象定义">对象定义</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 表示经过多少散列函数计算
</span><span class="c1">// 固定14次
</span><span class="c1"></span><span class="nx">maps</span> <span class="p">=</span> <span class="mi">14</span>

<span class="kd">type</span> <span class="p">(</span>
    <span class="c1">// 定义布隆过滤器结构体
</span><span class="c1"></span>    <span class="nx">Filter</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">bits</span>   <span class="kt">uint</span>
        <span class="nx">bitSet</span> <span class="nx">bitSetProvider</span>
    <span class="p">}</span>
    <span class="c1">// 位数组操作接口定义
</span><span class="c1"></span>    <span class="nx">bitSetProvider</span> <span class="kd">interface</span> <span class="p">{</span>
        <span class="nf">check</span><span class="p">([]</span><span class="kt">uint</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
        <span class="nf">set</span><span class="p">([]</span><span class="kt">uint</span><span class="p">)</span> <span class="kt">error</span>
    <span class="p">}</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>bits代表我们要用多少位来存储这个布隆过滤器。</p>
<p>bitset是一个接口，是具体用来存储布隆过滤器的结构.</p>
<p>BitSetProvider接口提供了两个方法，check是用来检查该数据是否存在，set是用来将该数据设置为存在。代码里redisBitSet实现了该接口。</p>
<h3 id="redisbitset">redisBitSet</h3>
<p>首先需要理解两段 lua 脚本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ARGV:偏移量offset数组
</span><span class="c1">// KYES[1]: setbit操作的key
</span><span class="c1">// 全部设置为1
</span><span class="c1"></span><span class="nx">setScript</span> <span class="p">=</span> <span class="s">`
</span><span class="s">    for _, offset in ipairs(ARGV) do
</span><span class="s">        redis.call(&#34;setbit&#34;, KEYS[1], offset, 1)
</span><span class="s">    end
</span><span class="s">    `</span>
<span class="c1">// ARGV:偏移量offset数组
</span><span class="c1">// KYES[1]: setbit操作的key
</span><span class="c1">// 检查是否全部为1
</span><span class="c1"></span><span class="nx">testScript</span> <span class="p">=</span> <span class="s">`
</span><span class="s">    for _, offset in ipairs(ARGV) do
</span><span class="s">        if tonumber(redis.call(&#34;getbit&#34;, KEYS[1], offset)) == 0 then
</span><span class="s">            return false
</span><span class="s">        end
</span><span class="s">    end
</span><span class="s">    return true
</span><span class="s">    `</span>
</code></pre></td></tr></table>
</div>
</div><p>为什么一定要用 lua 脚本呢? 因为需要保证整个操作是原子性执行的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// redis位数组
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">redisBitSet</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">store</span> <span class="o">*</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Client</span>
    <span class="nx">key</span>   <span class="kt">string</span>
    <span class="nx">bits</span>  <span class="kt">uint</span>
<span class="p">}</span>
<span class="c1">// 检查偏移量offset数组是否全部为1
</span><span class="c1">// 是:元素可能存在
</span><span class="c1">// 否:元素一定不存在
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span><span class="o">*</span><span class="nx">redisBitSet</span><span class="p">)</span> <span class="nf">check</span><span class="p">(</span><span class="nx">offsets</span> <span class="p">[]</span><span class="kt">uint</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">args</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">buildOffsetArgs</span><span class="p">(</span><span class="nx">offsets</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="c1">// 执行脚本
</span><span class="c1"></span>    <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">store</span><span class="p">.</span><span class="nf">Eval</span><span class="p">(</span><span class="nx">testScript</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">r</span><span class="p">.</span><span class="nx">key</span><span class="p">},</span> <span class="nx">args</span><span class="p">).</span><span class="nf">Result</span><span class="p">()</span>
    <span class="c1">// 这里需要注意一下,底层使用的go-redis
</span><span class="c1"></span>    <span class="c1">// redis.Nil表示key不存在的情况需特殊判断
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">redis</span><span class="p">.</span><span class="nx">Nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>

    <span class="nx">exists</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.(</span><span class="kt">int64</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">exists</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 将k位点全部设置为1
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">redisBitSet</span><span class="p">)</span> <span class="nf">set</span><span class="p">(</span><span class="nx">offsets</span> <span class="p">[]</span><span class="kt">uint</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">args</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">buildOffsetArgs</span><span class="p">(</span><span class="nx">offsets</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">store</span><span class="p">.</span><span class="nf">Eval</span><span class="p">(</span><span class="nx">setScript</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">r</span><span class="p">.</span><span class="nx">key</span><span class="p">},</span> <span class="nx">args</span><span class="p">).</span><span class="nf">Err</span><span class="p">()</span>
    <span class="c1">// 底层使用的是go-redis,redis.Nil表示操作的key不存在
</span><span class="c1"></span>    <span class="c1">// 需要针对key不存在的情况特殊判断
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">redis</span><span class="p">.</span><span class="nx">Nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="c1">// 构建偏移量offset字符串数组,因为go-redis执行lua脚本时参数定义为[]string
</span><span class="c1">// 因此需要转换一下
</span><span class="c1">// buildOffsetArgs 做了一点异常检查，然后转换为字符串
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">redisBitSet</span><span class="p">)</span> <span class="nf">buildOffsetArgs</span><span class="p">(</span><span class="nx">offsets</span> <span class="p">[]</span><span class="kt">uint</span><span class="p">)</span> <span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">args</span> <span class="p">[]</span><span class="kt">string</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">offset</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">offsets</span> <span class="p">{</span>
	<span class="c1">// 因为前面对bits求模了，所以正常情况这里是不会走到的
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">offset</span> <span class="o">&gt;=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">bits</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrTooLargeOffset</span>
        <span class="p">}</span>
	<span class="c1">// uint数字转换为字符
</span><span class="c1"></span>        <span class="nx">args</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">args</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">FormatUint</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">offset</span><span class="p">),</span> <span class="mi">10</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">args</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 删除
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">redisBitSet</span><span class="p">)</span> <span class="nf">del</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">store</span><span class="p">.</span><span class="nf">Del</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">key</span><span class="p">).</span><span class="nf">Err</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// 自动过期
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">redisBitSet</span><span class="p">)</span> <span class="nf">expire</span><span class="p">(</span><span class="nx">seconds</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">store</span><span class="p">.</span><span class="nf">Expire</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">seconds</span><span class="p">)).</span><span class="nf">Err</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newRedisBitSet</span><span class="p">(</span><span class="nx">store</span> <span class="o">*</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">bits</span> <span class="kt">uint</span><span class="p">)</span><span class="o">*</span><span class="nx">redisBitSet</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">redisBitSet</span><span class="p">{</span>
        <span class="nx">store</span><span class="p">:</span> <span class="nx">store</span><span class="p">,</span>
        <span class="nx">key</span><span class="p">:</span>   <span class="nx">key</span><span class="p">,</span>
        <span class="nx">bits</span><span class="p">:</span>  <span class="nx">bits</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>到这里位数组操作就全部实现了，接下来看下如何通过 k 个散列函数计算出 k 个位点</p>
<h3 id="k-次散列计算出-k-个位点">k 次散列计算出 k 个位点</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// k次散列计算出k个offset
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">Filter</span><span class="p">)</span> <span class="nf">getLocations</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">uint</span> <span class="p">{</span>
    <span class="c1">// 创建指定容量的切片
</span><span class="c1"></span>    <span class="nx">locations</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">uint</span><span class="p">,</span> <span class="nx">maps</span><span class="p">)</span>
    <span class="c1">// maps表示k值,作者定义为了常量:14
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">maps</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="c1">// 每次用当前循环的次数当做盐byte(i)，加盐算得hash值。hash算法是murmur3。
</span><span class="c1"></span>        <span class="c1">// 哈希计算,使用的是&#34;MurmurHash3&#34;算法,并每次追加一个固定的i字节进行计算
</span><span class="c1"></span>	<span class="nx">hashValue</span> <span class="o">:=</span> <span class="nx">murmur3</span><span class="p">.</span><span class="nf">Sum64</span><span class="p">(</span><span class="nb">append</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nb">byte</span><span class="p">(</span><span class="nx">i</span><span class="p">)))</span>
        <span class="c1">// 取下标offset
</span><span class="c1"></span>	<span class="c1">// 用hash值对bits求模，获得这次的位置locations[i]
</span><span class="c1"></span>        <span class="nx">locations</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">hashValue</span> <span class="o">%</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">bits</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="c1">// 14次的位置合在一起，代表了这个数据
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">locations</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="插入与查询">插入与查询</h3>
<p>添加与查询实现就非常简单了，组合一下上面的函数就行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 添加元素
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">Filter</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="c1">//算得这个数据的位置，然后标记上这个数据
</span><span class="c1"></span>    <span class="nx">locations</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nf">getLocations</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">f</span><span class="p">.</span><span class="nx">bitSet</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">locations</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 检查是否存在
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">Filter</span><span class="p">)</span> <span class="nf">Exists</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">locations</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nf">getLocations</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
    <span class="nx">isSet</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">bitSet</span><span class="p">.</span><span class="nf">check</span><span class="p">(</span><span class="nx">locations</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">isSet</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="改进建议">改进建议</h3>
<p>整体实现非常简洁高效，那么有没有改进的空间呢？</p>
<p>个人认为还是有的，上面提到过自动计算最优 m 与 k 的数学公式，如果创建参数改为：</p>
<ul>
<li>预期总数量expectedInsertions</li>
<li>期望误差falseProbability</li>
</ul>
<p>就更好了，虽然作者注释里特别提到了误差说明，但是实际上作为很多开发者对位数组长度并不敏感，无法直观知道 bits 传多少预期误差会是多少。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// New create a Filter, store is the backed redis, key is the key for the bloom filter,
</span><span class="c1">// bits is how many bits will be used, maps is how many hashes for each addition.
</span><span class="c1">// best practices:
</span><span class="c1">// elements - means how many actual elements
</span><span class="c1">// when maps = 14, formula: 0.7*(bits/maps), bits = 20*elements, the error rate is 0.000067 &lt; 1e-4
</span><span class="c1">// for detailed error rate table, see &lt;http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html&gt;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">store</span> <span class="o">*</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Redis</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">bits</span> <span class="kt">uint</span><span class="p">)</span><span class="o">*</span><span class="nx">Filter</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Filter</span><span class="p">{</span>
        <span class="nx">bits</span><span class="p">:</span>   <span class="nx">bits</span><span class="p">,</span>
        <span class="nx">bitSet</span><span class="p">:</span> <span class="nf">newRedisBitSet</span><span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">bits</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// expectedInsertions - 预期总数量
</span><span class="c1">// falseProbability - 预期误差
</span><span class="c1">// 这里也可以改为option模式不会破坏原有的兼容性
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewFilter</span><span class="p">(</span><span class="nx">store</span> <span class="o">*</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Redis</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">expectedInsertions</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">falseProbability</span> <span class="kt">float64</span><span class="p">)</span><span class="o">*</span><span class="nx">Filter</span> <span class="p">{</span>
    <span class="nx">bits</span> <span class="o">:=</span> <span class="nf">optimalNumOfBits</span><span class="p">(</span><span class="nx">expectedInsertions</span><span class="p">,</span> <span class="nx">falseProbability</span><span class="p">)</span>
    <span class="nx">k</span> <span class="o">:=</span> <span class="nf">optimalNumOfHashFunctions</span><span class="p">(</span><span class="nx">bits</span><span class="p">,</span> <span class="nx">expectedInsertions</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Filter</span><span class="p">{</span>
        <span class="nx">bits</span><span class="p">:</span>   <span class="nx">bits</span><span class="p">,</span>
        <span class="nx">bitSet</span><span class="p">:</span> <span class="nf">newRedisBitSet</span><span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">bits</span><span class="p">),</span>
        <span class="nx">k</span><span class="p">:</span>      <span class="nx">k</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 计算最优哈希次数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">optimalNumOfHashFunctions</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">uint</span><span class="p">)</span> <span class="kt">uint</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Round</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">*</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
<span class="p">}</span>

<span class="c1">// 计算最优数组长度
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">optimalNumOfBits</span><span class="p">(</span><span class="nx">n</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">p</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">uint</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">uint</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="o">-</span><span class="nx">n</span><span class="p">)</span> <span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="完整代码">完整代码</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">bloom</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;errors&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
	<span class="s">&#34;time&#34;</span>

	<span class="s">&#34;github.com/go-redis/redis&#34;</span>
	<span class="s">&#34;github.com/spaolacci/murmur3&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="c1">// for detailed error rate table, see http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html
</span><span class="c1"></span>	<span class="c1">// maps as k in the error rate table
</span><span class="c1"></span>	<span class="nx">maps</span>      <span class="p">=</span> <span class="mi">14</span>
	<span class="nx">setScript</span> <span class="p">=</span> <span class="s">`
</span><span class="s">for _, offset in ipairs(ARGV) do
</span><span class="s">	redis.call(&#34;setbit&#34;, KEYS[1], offset, 1)
</span><span class="s">end
</span><span class="s">`</span>
	<span class="nx">testScript</span> <span class="p">=</span> <span class="s">`
</span><span class="s">for _, offset in ipairs(ARGV) do
</span><span class="s">	if tonumber(redis.call(&#34;getbit&#34;, KEYS[1], offset)) == 0 then
</span><span class="s">		return false
</span><span class="s">	end
</span><span class="s">end
</span><span class="s">return true
</span><span class="s">`</span>
<span class="p">)</span>

<span class="c1">// ErrTooLargeOffset indicates the offset is too large in bitset.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">ErrTooLargeOffset</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;too large offset&#34;</span><span class="p">)</span>

<span class="kd">type</span> <span class="p">(</span>
	<span class="c1">// A Filter is a bloom filter.
</span><span class="c1"></span>	<span class="nx">Filter</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">bits</span>   <span class="kt">uint</span>
		<span class="nx">bitSet</span> <span class="nx">bitSetProvider</span>
	<span class="p">}</span>

	<span class="nx">bitSetProvider</span> <span class="kd">interface</span> <span class="p">{</span>
		<span class="nf">check</span><span class="p">([]</span><span class="kt">uint</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
		<span class="nf">set</span><span class="p">([]</span><span class="kt">uint</span><span class="p">)</span> <span class="kt">error</span>
	<span class="p">}</span>
<span class="p">)</span>

<span class="c1">// New create a Filter, store is the backed redis, key is the key for the bloom filter,
</span><span class="c1">// bits is how many bits will be used, maps is how many hashes for each addition.
</span><span class="c1">// best practices:
</span><span class="c1">// elements - means how many actual elements
</span><span class="c1">// when maps = 14, formula: 0.7*(bits/maps), bits = 20*elements, the error rate is 0.000067 &lt; 1e-4
</span><span class="c1">// for detailed error rate table, see http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">store</span> <span class="o">*</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">bits</span> <span class="kt">uint</span><span class="p">)</span> <span class="o">*</span><span class="nx">Filter</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Filter</span><span class="p">{</span>
		<span class="nx">bits</span><span class="p">:</span>   <span class="nx">bits</span><span class="p">,</span>
		<span class="nx">bitSet</span><span class="p">:</span> <span class="nf">newRedisBitSet</span><span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">bits</span><span class="p">),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Add adds data into f.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">Filter</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">locations</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nf">getLocations</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">f</span><span class="p">.</span><span class="nx">bitSet</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">locations</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Exists checks if data is in f.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">Filter</span><span class="p">)</span> <span class="nf">Exists</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">locations</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nf">getLocations</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="nx">isSet</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">bitSet</span><span class="p">.</span><span class="nf">check</span><span class="p">(</span><span class="nx">locations</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">isSet</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">Filter</span><span class="p">)</span> <span class="nf">getLocations</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">uint</span> <span class="p">{</span>
	<span class="nx">locations</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">uint</span><span class="p">,</span> <span class="nx">maps</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">maps</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">hashValue</span> <span class="o">:=</span> <span class="nx">murmur3</span><span class="p">.</span><span class="nf">Sum64</span><span class="p">(</span><span class="nb">append</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nb">byte</span><span class="p">(</span><span class="nx">i</span><span class="p">)))</span>
		<span class="nx">locations</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">hashValue</span> <span class="o">%</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">bits</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">locations</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">redisBitSet</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">store</span> <span class="o">*</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Client</span>
	<span class="nx">key</span>   <span class="kt">string</span>
	<span class="nx">bits</span>  <span class="kt">uint</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newRedisBitSet</span><span class="p">(</span><span class="nx">store</span> <span class="o">*</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">bits</span> <span class="kt">uint</span><span class="p">)</span> <span class="o">*</span><span class="nx">redisBitSet</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">redisBitSet</span><span class="p">{</span>
		<span class="nx">store</span><span class="p">:</span> <span class="nx">store</span><span class="p">,</span>
		<span class="nx">key</span><span class="p">:</span>   <span class="nx">key</span><span class="p">,</span>
		<span class="nx">bits</span><span class="p">:</span>  <span class="nx">bits</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">redisBitSet</span><span class="p">)</span> <span class="nf">buildOffsetArgs</span><span class="p">(</span><span class="nx">offsets</span> <span class="p">[]</span><span class="kt">uint</span><span class="p">)</span> <span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">args</span> <span class="p">[]</span><span class="kt">string</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">offset</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">offsets</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">offset</span> <span class="o">&gt;=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">bits</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrTooLargeOffset</span>
		<span class="p">}</span>

		<span class="nx">args</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">args</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">FormatUint</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">offset</span><span class="p">),</span> <span class="mi">10</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">args</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">redisBitSet</span><span class="p">)</span> <span class="nf">check</span><span class="p">(</span><span class="nx">offsets</span> <span class="p">[]</span><span class="kt">uint</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">args</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">buildOffsetArgs</span><span class="p">(</span><span class="nx">offsets</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">store</span><span class="p">.</span><span class="nf">Eval</span><span class="p">(</span><span class="nx">testScript</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">r</span><span class="p">.</span><span class="nx">key</span><span class="p">},</span> <span class="nx">args</span><span class="p">).</span><span class="nf">Result</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">redis</span><span class="p">.</span><span class="nx">Nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">exists</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.(</span><span class="kt">int64</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">exists</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">redisBitSet</span><span class="p">)</span> <span class="nf">del</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">store</span><span class="p">.</span><span class="nf">Del</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">key</span><span class="p">).</span><span class="nf">Err</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">redisBitSet</span><span class="p">)</span> <span class="nf">expire</span><span class="p">(</span><span class="nx">seconds</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">store</span><span class="p">.</span><span class="nf">Expire</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">seconds</span><span class="p">)).</span><span class="nf">Err</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">redisBitSet</span><span class="p">)</span> <span class="nf">set</span><span class="p">(</span><span class="nx">offsets</span> <span class="p">[]</span><span class="kt">uint</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">args</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">buildOffsetArgs</span><span class="p">(</span><span class="nx">offsets</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">err</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">store</span><span class="p">.</span><span class="nf">Eval</span><span class="p">(</span><span class="nx">setScript</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">r</span><span class="p">.</span><span class="nx">key</span><span class="p">},</span> <span class="nx">args</span><span class="p">).</span><span class="nf">Err</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">redis</span><span class="p">.</span><span class="nx">Nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<p><a href="https://mp.weixin.qq.com/s/5zHQbDs978OoA3g83NaVmw">详解布隆过滤器原理与实现</a></p>
<p><a href="https://mp.weixin.qq.com/s/8bY5IozyhUWk7opSOU71rA">Go + Redis 布隆过滤器原理与实现</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-12-07
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%BC%93%E5%AD%98/">缓存</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/linux%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Linux的进程线程模型</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/">
            <span class="next-text nav-default">如何保证缓存一致性</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
