<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>调试工具Valgrind | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="Valgrind是运行在Linux上一套基于仿真技术的程序调试和分析工具，是公认的最接近Purify的产品，它包含一个内核——一个软件合成的">
<meta name="author" content="">
<link rel="canonical" href="/post/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7valgrind/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="调试工具Valgrind" />
<meta property="og:description" content="Valgrind是运行在Linux上一套基于仿真技术的程序调试和分析工具，是公认的最接近Purify的产品，它包含一个内核——一个软件合成的" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7valgrind/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-25T05:10:36&#43;00:00" />
<meta property="article:modified_time" content="2017-06-25T05:10:36&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="调试工具Valgrind"/>
<meta name="twitter:description" content="Valgrind是运行在Linux上一套基于仿真技术的程序调试和分析工具，是公认的最接近Purify的产品，它包含一个内核——一个软件合成的"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "调试工具Valgrind",
      "item": "/post/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7valgrind/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "调试工具Valgrind",
  "name": "调试工具Valgrind",
  "description": "Valgrind是运行在Linux上一套基于仿真技术的程序调试和分析工具，是公认的最接近Purify的产品，它包含一个内核——一个软件合成的",
  "keywords": [
    
  ],
  "articleBody": "Valgrind是运行在Linux上一套基于仿真技术的程序调试和分析工具，是公认的最接近Purify的产品，它包含一个内核——一个软件合成的CPU，和一系列的小工具，每个工具都可以完成一项任务——调试，分析，或测试等。Valgrind可以检测内存泄漏和内存越界，还可以分析cache的使用等，灵活轻巧而又强大。\nValgrind 完全可以作为您的首选工具。他不仅向您报告错误的地点和原因，关键是他会抢在程序奔溃之前提醒您（这两点都是 GDB 无法做到的）。 当然 GDB 依然优秀，它能在断言失败时给出完整详尽的堆栈跟踪信息，这对调试并发代码和其他一些情况都是很必要的。\n-pedantic -Wall -Wextra 这些编译选项也是相当有用的。越来越聪明的现代编译器也能帮你定位一些未知行为。Valgrind 应该被当做对编译器的有力的补足，而非功能重叠的竞争者。\nValgrind工具集合 Memcheck 最常用的工具，用来检测程序中出现的内存问题，所有对内存的读写都会被检测到，一切对malloc、free、new、delete的调用都会被捕获。所以，它能检测以下问题：\n  对未初始化内存的使用；\n  读/写释放后的内存块；\n  读/写超出malloc分配的内存块；\n  读/写不适当的栈中内存块；\n  内存泄漏，指向一块内存的指针永远丢失；\n  不正确的malloc/free或new/delete匹配；\n  memcpy()相关函数中的dst和src指针重叠。\n  这些问题往往是C/C++程序员最头疼的问题，Memcheck能在这里帮上大忙。\nCallgrind 和gprof类似的分析工具，但它对程序的运行观察更是入微，能给我们提供更多的信息。和gprof不同，它不需要在编译源代码时附加特殊选项，但加上调试选项是推荐的。Callgrind收集程序运行时的一些数据，建立函数调用关系图，还可以有选择地进行cache模拟。在运行结束时，它会把分析数据写入一个文件。callgrind_annotate可以把这个文件的内容转化成可读的形式。\nCachegrind cachegrind是一个cache剖析器。它模拟执行CPU中的L1, D1和L2 cache，因此它能很精确的指出代码中的cache未命中。如果你需要，它可以打印出cache未命中的次数，内存引用和发生cache未命中的每一行代码，每一个函数，每一个模块和整个程序的摘要。如果你要求更细致的信息，它可以打印出每一行机器码的未命中次数。在x86和amd64上， cachegrind通过CPUID自动探测机器的cache配置，所以在多数情况下它不再需要更多的配置信息了。\nHelgrind helgrind查找多线程程序中的竞争数据。helgrind查找内存地址，那些被多于一条线程访问的内存地址，但是没有使用一致的锁就会被查出。这表示这些地址在多线程间访问的时候没有进行同步，很可能会引起很难查找的时序问题。\n它主要用来检查多线程程序中出现的竞争问题。Helgrind 寻找内存中被多个线程访问，而又没有一贯加锁的区域，这些区域往往是线程之间失去同步的地方，而且会导致难以发掘的错误。Helgrind实现了名为”Eraser” 的竞争检测算法，并做了进一步改进，减少了报告错误的次数。\nMassif 堆栈分析器，它能测量程序在堆栈中使用了多少内存，告诉我们堆块，堆管理块和栈的大小。Massif能帮助我们减少内存的使用，在带有虚拟内存的现代系统中，它还能够加速我们程序的运行，减少程序停留在交换区中的几率。\nMassif对内存的分配和释放做profile。程序开发者通过它可以深入了解程序的内存使用行为，从而对内存使用进行优化。这个功能对C++尤其有用，因为C++有很多隐藏的内存分配和释放\nlackey和nulgrind 此外，lackey和nulgrind也会提供。Lackey是小型工具，很少用到；Nulgrind只是为开发者展示如何创建一个工具。我们就不做介绍了。\nValgrind的参数 用法: valgrind [options] prog-and-args [options]: 常用选项，适用于所有Valgrind工具\n--tool=  最常用的选项。运行 valgrind中名为toolname的工具。默认memcheck。\n-h --help  显示所有选项的帮助，包括内核和选定的工具两者。\n--version  显示valgrind内核的版本，每个工具都有各自的版本。\n-q --quiet  安静地运行，只打印错误信息。\n--verbose  更详细的信息。\n--trace-children=  跟踪子线程? [default: no]\n--track-fds=  跟踪打开的文件描述？[default: no]\n--time-stamp=  增加时间戳到LOG信息? [default: no]\n--log-fd=  输出LOG到描述符文件 [2=stderr]\n--log-file=  将输出的信息写入到filename.PID的文件里，PID是运行程序的进行ID\n--log-file-exactly=  输出LOG信息到 file\nLOG信息输出\n--xml=yes  将信息以xml格式输出，只有memcheck可用\n--num-callers= show  callers in stack traces [12] --error-exitcode=  如果发现错误则返回错误代码 [0=disable]\n--db-attach=  当出现错误，valgrind会自动启动调试器gdb。[default: no]\n--db-command=  启动调试器的命令行选项[gdb -nw %f %p]\n适用于Memcheck工具的相关选项：\n--leak-check=  要求对leak给出详细信息? Leak是指，存在一块没有被引用的内存空间，或没有被释放的内存空间，如summary，只反馈一些总结信息，告诉你有多少个malloc，多少个free 等；如果是full将输出所有的leaks，也就是定位到某一个malloc/free。 [default: summary]\n--show-reachable=  如果为no，只输出没有引用的内存leaks，或指向malloc返回的内存块中部某处的leaks [default: no]\nValgrind 安装 解压安装包 tar -jxvf valgrind-3.11.0.tar.bz2 -C /usr/local/src  进入目录安装 cd /usr/local/src/valgrind-3.11.0  运行./autogen.sh 设置环境（需要标准的autoconf工具） ./autogen.sh  配置Valgrind，生成MakeFile文件 ./configure --prefix=/usr/local  编译和安装valgrind make \u0026\u0026 make install  Valgrind使用 为了valgrind发现的错误更精确，如能够定位到源代码的行，建议在编译时加上-g参数，编译优化选项选择O0(不要优化）\n利用valgrind调试内存问题，不需要重新编译源程序，它的输入就是二进制的可执行程序。\n如果程序是通过脚本启动的，可以修改脚本里启动程序的代码，或者使用–trace-children=yes选项来运行脚本。\nmemcheck 这里用到的示例程序文件名为：sample.c（如下所示）,选用的编译器为gcc。\n生成可执行程序\ngcc –g –O0 sample.c –o sample  运行valgrind，得到以下信息：\n左边显示类似行号的数字（32372）表示的是 Process ID。\n最上面的红色方框表示的是 valgrind 的版本信息。\n中间的红色方框表示 valgrind 通过运行被测试程序，发现的内存问题。通过阅读这些信息，可以发现：\n  这是一个对内存的非法写操作，非法写操作的内存是4 bytes。\n  发生错误时的函数堆栈，以及具体的源代码行号。\n  非法写操作的具体地址空间。\n  最下面的红色方框是对发现的内存问题和内存泄露问题的总结。内存泄露的大小（40 bytes）也能够被检测出来。\n示例程序显然有两个问题，一是fun函数中动态申请的堆内存没有释放；二是对堆内存的访问越界。这两个问题均被valgrind发现。\nmemcheck的示例 例1．使用未初始化的内存 代码如下\n1 2 3 4 5 6 7 8 9 10  #include  int main() { int x; if(x == 0) { printf(\"X is zero\"); } return 0; }   Valgrind提示如下\n1 2 3 4 5 6 7 8  ==14222== Conditional jump or move depends on uninitialised value(s) ==14222== at 0x400484: main (sample2.c:6) X is zero==14222== ==14222== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 5 from 1) ==14222== malloc/free: in use at exit: 0 bytes in 0 blocks. ==14222== malloc/free: 0 allocs, 0 frees, 0 bytes allocated. ==14222== For counts of detected errors, rerun with: -v ==14222== All heap blocks were freed -- no leaks are possible.   例2．内存读写越界 代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include #include int main(int argc,char *argv[]) { int len=5; int i; int *pt=(int*)malloc(len*sizeof(int)); int *p=pt; for(i=0;ilen;i++) {p++;} *p=5; printf(“%d”,*p); return; }   Valgrind提示如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  ==23045== Invalid write of size 4 ==23045== at 0x40050A: main (sample2.c:11) ==23045== Address 0x4C2E044 is 0 bytes after a block of size 20 alloc'd ==23045== at 0x4A05809: malloc (vg_replace_malloc.c:149) ==23045== by 0x4004DF: main (sample2.c:7) ==23045== ==23045== Invalid read of size 4 ==23045== at 0x400514: main (sample2.c:12) ==23045== Address 0x4C2E044 is 0 bytes after a block of size 20 alloc'd ==23045== at 0x4A05809: malloc (vg_replace_malloc.c:149) ==23045== by 0x4004DF: main (sample2.c:7) 5==23045== ==23045== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 5 from 1) ==23045== malloc/free: in use at exit: 20 bytes in 1 blocks. ==23045== malloc/free: 1 allocs, 0 frees, 20 bytes allocated. ==23045== For counts of detected errors, rerun with: -v ==23045== searching for pointers to 1 not-freed blocks. ==23045== checked 66,584 bytes. ==23045== ==23045== LEAK SUMMARY: ==23045== definitely lost: 20 bytes in 1 blocks. ==23045== possibly lost: 0 bytes in 0 blocks. ==23045== still reachable: 0 bytes in 0 blocks. ==23045== suppressed: 0 bytes in 0 blocks. ==23045== Use --leak-check=full to see details of leaked memory.   例3．src和dst内存覆盖 代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include #include #include int main(int argc,char *argv[]) { char x[50]; int i; for(i=0;i50;i++) {x[i]=i;} strncpy(x+20,x,20); //Good strncpy(x+20,x,21); //Overlap x[39]=’\\0’; strcpy(x,x+20); //Good x[39]=40; x[40]=’\\0’; strcpy(x,x+20); //Overlap return 0; }   Valgrind提示如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  ==24139== Source and destination overlap in strncpy(0x7FEFFFC09, 0x7FEFFFBF5, 21) ==24139== at 0x4A0724F: strncpy (mc_replace_strmem.c:116) ==24139== by 0x400527: main (sample3.c:10) ==24139== ==24139== Source and destination overlap in strcpy(0x7FEFFFBE0, 0x7FEFFFBF4) ==24139== at 0x4A06E47: strcpy (mc_replace_strmem.c:106) ==24139== by 0x400555: main (sample3.c:15) ==24139== ==24139== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 5 from 1) ==24139== malloc/free: in use at exit: 0 bytes in 0 blocks. ==24139== malloc/free: 0 allocs, 0 frees, 0 bytes allocated. ==24139== For counts of detected errors, rerun with: -v ==24139== All heap blocks were freed -- no leaks are possible.   例4．动态内存管理错误 常见的内存分配方式分三种：静态存储，栈上分配，堆上分配。全局变量属于静态存储，它们是在编译时就被分配了存储空间，函数内的局部变量属于栈上分配，而最灵活的内存使用方式当属堆上分配，也叫做内存动态分配了。常用的内存动态分配函数包括：malloc, alloc, realloc, new等，动态释放函数包括free, delete。\n一旦成功申请了动态内存，我们就需要自己对其进行内存管理，而这又是最容易犯错误的。常见的内存动态管理错误包括：\n申请和释放不一致 由于 C++ 兼容 C，而 C 与 C++ 的内存申请和释放函数是不同的，因此在 C++ 程序中，就有两套动态内存管理函数。一条不变的规则就是采用 C 方式申请的内存就用 C 方式释放；用 C++ 方式申请的内存，用 C++ 方式释放。也就是用 malloc/alloc/realloc 方式申请的内存，用 free 释放；用 new 方式申请的内存用 delete 释放。在上述程序中，用 malloc 方式申请了内存却用 delete 来释放，虽然这在很多情况下不会有问题，但这绝对是潜在的问题。\n申请和释放不匹配 申请了多少内存，在使用完成后就要释放多少。如果没有释放，或者少释放了就是内存泄露；多释放了也会产生问题。上述程序中，指针p和pt指向的是同一块内存，却被先后释放两次。\n释放后仍然读写 本质上说，系统会在堆上维护一个动态内存链表，如果被释放，就意味着该块内存可以继续被分配给其他部分，如果内存被释放后再访问，就可能覆盖其他部分的信息，这是一种严重的错误，上述程序第16行中就在释放后仍然写这块内存。\n下面的一段程序，就包括了内存动态管理中常见的错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13  #include #include int main(int argc,char *argv[]) { char *p=(char*)malloc(10); char *pt=p; int i; for(i=0;i10;i++) {p[i]=’z’;} delete p; p[1]=’a’; free(pt); return 0; }   Valgrind提示如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  ==25811== Mismatched free() / delete / delete [] ==25811== at 0x4A05130: operator delete(void*) (vg_replace_malloc.c:244) ==25811== by 0x400654: main (sample4.c:9) ==25811== Address 0x4C2F030 is 0 bytes inside a block of size 10 alloc'd ==25811== at 0x4A05809: malloc (vg_replace_malloc.c:149) ==25811== by 0x400620: main (sample4.c:4) ==25811== ==25811== Invalid write of size 1 ==25811== at 0x40065D: main (sample4.c:10) ==25811== Address 0x4C2F031 is 1 bytes inside a block of size 10 free'd ==25811== at 0x4A05130: operator delete(void*) (vg_replace_malloc.c:244) ==25811== by 0x400654: main (sample4.c:9) ==25811== ==25811== Invalid free() / delete / delete[] ==25811== at 0x4A0541E: free (vg_replace_malloc.c:233) ==25811== by 0x400668: main (sample4.c:11) ==25811== Address 0x4C2F030 is 0 bytes inside a block of size 10 free'd ==25811== at 0x4A05130: operator delete(void*) (vg_replace_malloc.c:244) ==25811== by 0x400654: main (sample4.c:9) ==25811== ==25811== ERROR SUMMARY: 3 errors from 3 contexts (suppressed: 5 from 1) ==25811== malloc/free: in use at exit: 0 bytes in 0 blocks. ==25811== malloc/free: 1 allocs, 2 frees, 10 bytes allocated. ==25811== For counts of detected errors, rerun with: -v ==25811== All heap blocks were freed -- no leaks are possible.   例5．内存泄漏 代码如下\n1 2 3 4 5 6 7 8 9 10  #include int main() { char *x = (char*)malloc(20); char *y = (char*)malloc(20); x=y; free(x); free(y); return 0; }   Valgrind提示如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  ==19013== Invalid free() / delete / delete[] ==19013== at 0x4A0541E: free (vg_replace_malloc.c:233) ==19013== by 0x4004F5: main (sample5.c:8) ==19013== Address 0x4C2E078 is 0 bytes inside a block of size 20 free'd ==19013== at 0x4A0541E: free (vg_replace_malloc.c:233) ==19013== by 0x4004EC: main (sample5.c:7) ==19013== ==19013== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 5 from 1) ==19013== malloc/free: in use at exit: 20 bytes in 1 blocks. ==19013== malloc/free: 2 allocs, 2 frees, 40 bytes allocated. ==19013== For counts of detected errors, rerun with: -v ==19013== searching for pointers to 1 not-freed blocks. ==19013== checked 66,584 bytes. ==19013== ==19013== LEAK SUMMARY: ==19013== definitely lost: 20 bytes in 1 blocks. ==19013== possibly lost: 0 bytes in 0 blocks. ==19013== still reachable: 0 bytes in 0 blocks. ==19013== suppressed: 0 bytes in 0 blocks. ==19013== Use --leak-check=full to see details of leaked memory.   例6．非法写/读 代码如下\n1 2 3 4 5 6 7 8  int main() { int i, *x; x = (int *)malloc(10*sizeof(int)); for (i=0; i11; i++) x[i] = i; free(x); }   Valgrind提示如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  ==21483== Invalid write of size 4 ==21483== at 0x4004EA: main (sample6.c:6) ==21483== Address 0x4C2E058 is 0 bytes after a block of size 40 alloc'd ==21483== at 0x4A05809: malloc (vg_replace_malloc.c:149) ==21483== by 0x4004C9: main (sample6.c:4) ==21483== ==21483== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 5 from 1) ==21483== malloc/free: in use at exit: 0 bytes in 0 blocks. ==21483== malloc/free: 1 allocs, 1 frees, 40 bytes allocated. ==21483== For counts of detected errors, rerun with: -v ==21483== All heap blocks were freed -- no leaks are possible.   例7．无效指针 代码如下\n1 2 3 4 5 6 7 8  #include int main() { char *x = malloc(10); x[10] = 'a'; free(x); return 0; }   Valgrind提示如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  ==15262== Invalid write of size 1 ==15262== at 0x4004D6: main (sample7.c:5) ==15262== Address 0x4C2E03A is 0 bytes after a block of size 10 alloc'd ==15262== at 0x4A05809: malloc (vg_replace_malloc.c:149) ==15262== by 0x4004C9: main (sample7.c:4) ==15262== ==15262== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 5 from 1) ==15262== malloc/free: in use at exit: 0 bytes in 0 blocks. ==15262== malloc/free: 1 allocs, 1 frees, 10 bytes allocated. ==15262== For counts of detected errors, rerun with: -v ==15262== All heap blocks were freed -- no leaks are possible.   例8．重复释放 代码如下\n1 2 3 4 5 6 7 8  #include int main() { char *x = malloc(10); free(x); free(x); return 0; }   Valgrind提示如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  ==15005== Invalid free() / delete / delete[] ==15005== at 0x4A0541E: free (vg_replace_malloc.c:233) ==15005== by 0x4004DF: main (sample8.c:6) ==15005== Address 0x4C2E030 is 0 bytes inside a block of size 10 free'd ==15005== at 0x4A0541E: free (vg_replace_malloc.c:233) ==15005== by 0x4004D6: main (sample8.c:5) ==15005== ==15005== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 5 from 1) ==15005== malloc/free: in use at exit: 0 bytes in 0 blocks. ==15005== malloc/free: 1 allocs, 2 frees, 10 bytes allocated. ==15005== For counts of detected errors, rerun with: -v ==15005== All heap blocks were freed -- no leaks are possible.   Valgrind的局限   Valgrind不对静态数组(分配在栈上)进行边界检查。如果在程序中声明了一个数组:\n1 2 3 4 5  int main() { char x[10]; x[11] = 'a'; }   ``\nValgrind则不会警告你，你可以把数组改为动态在堆上分配的数组，这样就可能进行边界检查了。这个方法好像有点得不偿失的感觉。\n  Valgrind占用了更多的内存–可达两倍于你程序的正常使用量。如果你用Valgrind来检测使用大量内存的程序就会遇到问题，它可能会用很长的时间来运行测试。大多数情况下，这都不是问题，即使速度慢也仅是检测时速度慢，如果你用Valgrind来检测一个正常运行时速度就很慢的程序，这下问题就大了。\n  Valgrind不可能检测出你在程序中犯下的所有错误–如果你不检查缓冲区溢出，Valgrind也不会告诉你代码写了它不应该写的内存。\n  参数指令 基本选项： 这些选项对所有工具都有效。\n-h --help  显示所有选项的帮助，包括内核和选定的工具两者。\n--help-debug  和–help相同，并且还能显示通常只有Valgrind的开发人员使用的调试选项。\n--version  显示Valgrind内核的版本号。工具可以有他们自已的版本号。这是一种保证工具只在它们可以运行的内核上工作的一种设置。这样可以减少在工具和内核之间版本兼容性导致奇怪问题的概率。\n-q --quiet  安静的运行，只打印错误信息。在进行回归测试或者有其它的自动化测试机制时会非常有用。\n-v --verbose  显示详细信息。在各个方面显示你的程序的额外信息，例如：共享对象加载，使用的重置，执行引擎和工具的进程，异常行为的警告信息。重复这个标记可以增加详细的级别。\n-d  调试Valgrind自身发出的信息。通常只有Valgrind开发人员对此感兴趣。重复这个标记可以产生更详细的输出。如果你希望发送一个bug报告，通过-v -v -d -d生成的输出会使你的报告更加有效。\n--tool= [default: memcheck]  运行toolname指定的Valgrind，例如，Memcheck, Addrcheck, Cachegrind,等等。\n--trace-children= [default: no]  当这个选项打开时，Valgrind会跟踪到子进程中。这经常会导致困惑，而且通常不是你所期望的，所以默认这个选项是关闭的。\n--track-fds= [default: no]  当这个选项打开时，Valgrind会在退出时打印一个打开文件描述符的列表。每个文件描述符都会打印出一个文件是在哪里打开的栈回溯，和任何与此文件描述符相关的详细信息比如文件名或socket信息。\n--time-stamp= [default: no]  当这个选项打开时，每条信息之前都有一个从程序开始消逝的时间，用天，小时，分钟，秒和毫秒表示。\n--log-fd= [default: 2, stderr]  指定Valgrind把它所有的消息都输出到一个指定的文件描述符中去。默认值2, 是标准错误输出(stderr)。注意这可能会干扰到客户端自身对stderr的使用, Valgrind的输出与客户程序的输出将穿插在一起输出到stderr。\n--log-file=  指定Valgrind把它所有的信息输出到指定的文件中。实际上，被创建文件的文件名是由filename、’.’和进程号连接起来的（即.），从而每个进程创建不同的文件。\n--log-file-exactly=  类似于–log-file，但是后缀”.pid”不会被添加。如果设置了这个选项，使用Valgrind跟踪多个进程，可能会得到一个乱七八糟的文件。\n--log-file-qualifier=  当和–log-file一起使用时，日志文件名将通过环境变量$VAR来筛选。这对于MPI程序是有益的。更多的细节，查看手册2.3节 “注解”。\n--log-socket=  指定Valgrind输出所有的消息到指定的IP，指定的端口。当使用1500端口时，端口有可能被忽略。如果不能建立一个到指定端口的连接，Valgrind将输出写到标准错误(stderr)。这个选项经常和一个Valgrind监听程序一起使用。更多的细节，查看手册2.3节 “注解”。\n错误相关选项： 这些选项适用于所有产生错误的工具，比如Memcheck, 但是Cachegrind不行。\n--xml= [default: no]  当这个选项打开时，输出将是XML格式。这是为了使用Valgrind的输出做为输入的工具，例如GUI前端更加容易些。目前这个选项只在Memcheck时生效。\n--xml-user-comment=  在XML开头 附加用户注释，仅在指定了–xml=yes时生效，否则忽略。\n--demangle= [default: yes]  打开/关闭C++的名字自动解码。默认打开。当打开时，Valgrind将尝试着把编码过的C++名字自动转回初始状态。这个解码器可以处理g++版本为2.X,3.X或4.X生成的符号。一个关于名字编码解码重要的事实是，禁止文件中的解码函数名仍然使用他们未解码的形式。Valgrind在搜寻可用的禁止条目时不对函数名解码，因为这将使禁止文件内容依赖于Valgrind的名字解码机制状态，会使速度变慢，且无意义。\n--num-callers= [default: 12]  默认情况下，Valgrind显示12层函数调用的函数名有助于确定程序的位置。可以通过这个选项来改变这个数字。这样有助在嵌套调用的层次很深时确定程序的位置。注意错误信息通常只回溯到最顶上的4个函数。(当前函数，和它的3个调用者的位置)。所以这并不影响报告的错误总数。这个值的最大值是50。注意高的设置会使Valgrind运行得慢，并且使用更多的内存,但是在嵌套调用层次比较高的程序中非常实用。\n--error-limit= [default: yes]  当这个选项打开时，在总量达到10,000,000，或者1,000个不同的错误，Valgrind停止报告错误。这是为了避免错误跟踪机制在错误很多的程序下变成一个巨大的性能负担。\n--error-exitcode= [default: 0]  指定如果Valgrind在运行过程中报告任何错误时的退出返回值，有两种情况；当设置为默认值(零)时，Valgrind返回的值将是它模拟运行的程序的返回值。当设置为非零值时，如果Valgrind发现任何错误时则返回这个值。在Valgrind做为一个测试工具套件的部分使用时这将非常有用，因为使测试工具套件只检查Valgrind返回值就可以知道哪些测试用例Valgrind报告了错误。\n--show-below-main= [default: no]  默认地，错误时的栈回溯不显示main()之下的任何函数(或者类似的函数像glibc的__libc_start_main()，如果main()没有出现在栈回溯中)；这些大部分都是令人厌倦的C库函数。如果打开这个选项，在main()之下的函数也将会显示。\n--suppressions= [default: $PREFIX/lib/valgrind/default.supp]  指定一个额外的文件读取不需要理会的错误；你可以根据需要使用任意多的额外文件。\n--gen-suppressions= [default: no]  当设置为yes时，Valgrind将会在每个错误显示之后自动暂停并且打印下面这一行：—- Print suppression ? — [Return/N/n/Y/y/C/c] —-这个提示的行为和–db-attach选项(见下面)相同。如果选择是，Valgrind会打印出一个错误的禁止条目，你可以把它剪切然后粘帖到一个文件，如果不希望在将来再看到这个错误信息。当设置为all时，Valgrind会对每一个错误打印一条禁止条目，而不向用户询问。这个选项对C++程序非常有用，它打印出编译器调整过的名字。注意打印出来的禁止条目是尽可能的特定的。如果需要把类似的条目归纳起来，比如在函数名中添加通配符。并且，有些时候两个不同的错误也会产生同样的禁止条目，这时Valgrind就会输出禁止条目不止一次，但是在禁止条目的文件中只需要一份拷贝(但是如果多于一份也不会引起什么问题)。并且，禁止条目的名字像;名字并不是很重要，它只是和-v选项一起使用打印出所有使用的禁止条目记录。\n--db-attach= [default: no]  当这个选项打开时，Valgrind将会在每次打印错误时暂停并打出如下一行：—- Attach to debugger ? — [Return/N/n/Y/y/C/c] —- 按下回车,或者N、回车，n、回车，Valgrind不会对这个错误启动调试器。按下Y、回车，或者y、回车，Valgrind会启动调试器并设定在程序运行的这个点。当调试结束时，退出，程序会继续运行。在调试器内部尝试继续运行程序，将不会生效。按下C、回车，或者c、回车，Valgrind不会启动一个调试器，并且不会再次询问。注意：–db-attach=yes与–trace-children=yes有冲突。你不能同时使用它们。Valgrind在这种情况下不能启动。\n--db-command= [default: gdb -nw %f %p]  通过–db-attach指定如何使用调试器。默认的调试器是gdb.默认的选项是一个运行时扩展Valgrind的模板。 %f会用可执行文件的文件名替换，%p会被可执行文件的进程ID替换。\n这指定了Valgrind将怎样调用调试器。默认选项不会因为在构造时是否检测到了GDB而改变,通常是/usr/bin/gdb.使用这个命令，你可以指定一些调用其它的调试器来替换。\n给出的这个命令字串可以包括一个或多个%p %f扩展。每一个%p实例都被解释成将调试的进程的PID，每一个%f实例都被解释成要调试的进程的可执行文件路径。\n--input-fd= [default: 0, stdin]  使用–db-attach=yes和–gen-suppressions=yes选项，在发现错误时，Valgrind会停下来去读取键盘输入。默认地，从标准输入读取，所以关闭了标准输入的程序会有问题。这个选项允许你指定一个文件描述符来替代标准输入读取。\n--max-stackframe= [default: 2000000]  栈的最大值。如果栈指针的偏移超过这个数量，Valgrind则会认为程序是切换到了另外一个栈执行。如果在程序中有大量的栈分配的数组，你可能需要使用这个选项。valgrind保持对程序栈指针的追踪。如果栈指针的偏移超过了这个数量，Valgrind假定你的程序切换到了另外一个栈，并且Memcheck行为与栈指\n针的偏移没有超出这个数量将会不同。通常这种机制运转得很好。然而，如果你的程序在栈上申请了大的结构，这种机制将会表现得愚蠢，并且Memcheck将会报告大量的非法栈内存访问。这个选项允许把这个阀值设置为其它值。应该只在Valgrind的调试输出中显示需要这么做时才使用这个选项。在这种情况下，它会告诉你应该指定的新的阀值。普遍地，在栈中分配大块的内存是一个坏的主意。因为这很容易用光你的栈空间，尤其是在内存受限的系统或者支持大量小堆栈的线程的系统上，因为Memcheck执行的错误检查，对于堆上的数据比对栈上的数据要高效很多。如果你使用这个选项，你可能希望考虑重写代码在堆上分配内存而不是在栈上分配。\nMALLOC()相关的选项: 对于使用自有版本的malloc() (例如Memcheck和massif)，下面的选项可以使用。\n--alignment= [default: 8]  默认Valgrind的malloc(),realloc(), 等等，是8字节对齐地址的。这是大部分处理器的标准。然而，一些程序可能假定malloc()等总是返回16字节或更多对齐的内存。提供的数值必须在8和4096区间之内，并且必须是2的幂数。\n非通用选项： 这些选项可以用于所有的工具，它们影响Valgrind core的几个特性。大部分人不会用到这些选项。\n--run-libc-freeres= [default: yes]  GNU C库(libc.so)，所有程序共用的，可能会分配一部分内存自已用。通常在程序退出时释放内存并不麻烦 – 这里没什么问题，因为Linux内核在一个进程退出时会回收进程全部的资源，所以这只是会造成速度慢。glibc的作者认识到这样会导致内存检查器，像Valgrind，在退出时检查内存错误的报告glibc的内存泄漏问题，为了避免这个问题，他们提供了一个libc_freeres()例程特别用来让glibc释放分配的所有内存。因此Memcheck在退出时尝试着去运行libc_freeres()。不幸的是，在glibc的一些版本中，libc_freeres是有bug会导致段错误的。这在Red Hat 7.1上有特别声明。所以，提供这个选项来决定是否运行libc_freeres。如果你的程序看起来在Valgrind上运行得很好，但是在退出时发生段错误，你可能需要指定–run-libc-freeres=no来修正，这将可能错误的报告libc.so的内存泄漏。\n--sim-hints=hint1,hint2,...  传递杂凑的提示给Valgrind，轻微的修改模拟行为的非标准或危险方式，可能有助于模拟奇怪的特性。默认没有提示打开。小心使用！目前已知的提示有：\nl lax-ioctls: 对ioctl的处理非常不严格，唯一的假定是大小是正确的。不需要在写时缓冲区完全的初始化。没有这个，用大量的奇怪的ioctl命令来使用一些设备驱动将会非常烦人。\nl enable-inner:打开某些特殊的效果，当运行的程序是Valgrind自身时。\n–kernel-variant=variant1,variant2,… 处理系统调用和ioctls在这个平台的默认核心上产生不同的变量。这有助于运行在改进过的内核或者支持非标准的ioctls上。小心使用。如果你不理解这个选项做的是什么那你几乎不需要它。已经知道的变量有：\nl bproc: 支持X86平台上的sys_broc系统调用。这是为了运行在BProc，它是标准Linux的一个变种，有时用来构建集群。\n–show-emwarns= [default: no] 当这个选项打开时，Valgrind在一些特定的情况下将对CPU仿真产生警告。通常这些都是不引人注意的。\n–smc-check= [default: stack] 这个选项控制Valgrind对自我修改的代码的检测。Valgrind可以不做检测，可以检测栈中自我修改的代码，或者任意地方检测自我修改的代码。注意默认选项是捕捉绝大多数情况，到目前我们了解的情况为止。使用all选项时会极大的降低速度。(但是用none选项运行极少影响速度，因为对大多数程序，非常少的代码被添加到栈中)\n调试VALGRIND选项： 还有一些选项是用来调试Valgrind自身的。在运行一般的东西时不应该需要的。如果你希望看到选项列表，使用–help-debug选项。\n内存检查选项： --leak-check= [default: summary]  当这个选项打开时，当客户程序结束时查找内存泄漏。内存泄漏意味着有用malloc分配内存块，但是没有用free释放，而且没有指针指向这块内存。这样的内存块永远不能被程序释放，因为没有指针指向它们。如果设置为summary，Valgrind会报告有多少内存泄漏发生了。如果设置为full或yes，Valgrind给出每一个独立的泄漏的详细信息。\n--show-reachable= [default: no]  当这个选项关闭时，内存泄漏检测器只显示没有指针指向的内存块，或者只能找到指向块中间的指针。当这个选项打开时，内存泄漏检测器还报告有指针指向的内存块。这些块是最有可能出现内存泄漏的地方。你的程序可能，至少在原则上，应该在退出前释放这些内存块。这些有指针指向的内存块和没有指针指向的内存块，或者只有内部指针指向的块，都可能产生内存泄漏，因为实际上没有一个指向块起始的指针可以拿来释放，即使你想去释放它。\n--leak-resolution= [default: low]  在做内存泄漏检查时，确定memcheck将怎么样考虑不同的栈是相同的情况。当设置为low时，只需要前两层栈匹配就认为是相同的情况；当设置为med，必须要四层栈匹配，当设置为high时，所有层次的栈都必须匹配。对于hardcore内存泄漏检查，你很可能需要使用–leak-resolution=high和–num-callers=40或者更大的数字。注意这将产生巨量的信息，这就是为什么默认选项是四个调用者匹配和低分辨率的匹配。注意–leak-resolution= 设置并不影响memcheck查找内存泄漏的能力。它只是改变了结果如何输出。\n--freelist-vol= [default: 5000000]  当客户程序使用free(C中)或者delete(C++)释放内存时，这些内存并不是马上就可以用来再分配的。这些内存将被标记为不可访问的，并被放到一个已释放内存的队列中。这样做的目的是，使释放的内存再次被利用的点尽可能的晚。这有利于memcheck在内存块释放后这段重要的时间检查对块不合法的访问。这个选项指定了队列所能容纳的内存总容量，以字节为单位。默认的值是5000000字节。增大这个数目会增加memcheck使用的内存，但同时也增加了对已释放内存的非法使用的检测概率。\n--workaround-gcc296-bugs= [default: no]  当这个选项打开时，假定读写栈指针以下的一小段距离是gcc 2.96的bug，并且不报告为错误。距离默认为256字节。注意gcc 2.96是一些比较老的Linux发行版(RedHat 7.X)的默认编译器，所以你可能需要使用这个选项。如果不是必要请不要使用这个选项，它可能会使一些真正的错误溜掉。一个更好的解决办法是使用较新的，修正了这个bug的gcc/g++版本。\n--partial-loads-ok= [default: no]  控制memcheck如何处理从地址读取时字长度，字对齐，因此哪些字节是可以寻址的，哪些是不可以寻址的。当设置为yes是，这样的读取并不抛出一个寻址错误。而是从非法地址读取的V字节显示为未定义，访问合法地址仍然是像平常一样映射到内存。设置为no时，从部分错误的地址读取与从完全错误的地址读取同样处理：抛出一个非法地址错误，结果的V字节显示为合法数据。注意这种代码行为是违背ISO C/C++标准，应该被认为是有问题的。如果可能，这种代码应该修正。这个选项应该只是做为一个最后考虑的方法。\n--undef-value-errors= [default: yes]  控制memcheck是否检查未定义值的危险使用。当设为yes时，Memcheck的行为像Addrcheck, 一个轻量级的内存检查工具，是Valgrind的一个部分，它并不检查未定义值的错误。使用这个选项，如果你不希望看到未定义值错误。\nCACHEGRIND选项： 手动指定I1/D1/L2缓冲配置，大小是用字节表示的。这三个必须用逗号隔开，中间没有空格，例如： valgrind –tool=cachegrind –I1=65535,2,64你可以指定一个，两个或三个I1/D1/L2缓冲。如果没有手动指定，每个级别使用普通方式(通过CPUID指令得到缓冲配置，如果失败，使用默认值)得到的配置。\n--I1=,, 指定第一级指令缓冲的大小，关联度和行大小。\n--D1=,, 指定第一级数据缓冲的大小，关联度和行大小。\n--L2=,, 指定第二级缓冲的大小，关联度和行大小。\nCALLGRIND选项： --heap= [default: yes]  当这个选项打开时，详细的追踪堆的使用情况。关闭这个选项时，massif.pid.txt或massif.pid.html将会非常的简短。\n--heap-admin= [default: 8]  每个块使用的管理字节数。这只能使用一个平均的估计值，因为它可能变化。glibc使用的分配器每块需要4~15字节，依赖于各方面的因素。管理已经释放的块也需要空间，尽管massif不计算这些。\n--stacks= [default: yes]  当打开时，在剖析信息中包含栈信息。多线程的程序可能有多个栈。\n--depth= [default: 3]  详细的堆信息中调用过程的深度。增加这个值可以给出更多的信息，但是massif会更使这个程序运行得慢，使用更多的内存，并且产生一个大的massif.pid.txt或者massif.pid.hp文件。\n--alloc-fn=  指定一个分配内存的函数。这对于使用malloc()的包装函数是有用的，可以用它来填充原来无效的上下文信息。(这些函数会给出无用的上下文信息，并在图中给出无意义的区域)。指定的函数在上下文中被忽略，例如，像对malloc()一样处理。这个选项可以在命令行中重复多次，指定多个函数。\n--format= [default: text]  产生text或者HTML格式的详细堆信息，文件的后缀名使用.txt或者.html。\nHELGRIND选项： --private-stacks= [default: no]  假定线程栈是私有的。\n--show-last-access= [default: no]  显示最后一次字访问出错的位置。\nLACKEY选项： --fnname= [default: _dl_runtime_resolve()]  对函数计数。\n--detailed-counts= [default: no]  对读取，存储和alu操作计数。\n参考：http://www.cnblogs.com/jiu0821/p/6412669.html\n",
  "wordCount" : "12649",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-25T05:10:36Z",
  "dateModified": "2017-06-25T05:10:36Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7valgrind/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      调试工具Valgrind
    </h1>
    <div class="post-meta">June 25, 2017
</div>
  </header> 
  <div class="post-content"><p>Valgrind是运行在Linux上一套基于仿真技术的程序调试和分析工具，是公认的最接近Purify的产品，它包含一个内核——一个软件合成的CPU，和一系列的小工具，每个工具都可以完成一项任务——调试，分析，或测试等。Valgrind可以检测内存泄漏和内存越界，还可以分析cache的使用等，灵活轻巧而又强大。</p>
<p>Valgrind 完全可以作为您的首选工具。他不仅向您报告错误的地点和原因，关键是他会抢在程序奔溃之前提醒您（这两点都是 GDB 无法做到的）。 当然 GDB 依然优秀，它能在断言失败时给出完整详尽的堆栈跟踪信息，这对调试并发代码和其他一些情况都是很必要的。</p>
<p>-pedantic -Wall -Wextra 这些编译选项也是相当有用的。越来越聪明的现代编译器也能帮你定位一些未知行为。Valgrind 应该被当做对编译器的有力的补足，而非功能重叠的竞争者。</p>
<h1 id="valgrind工具集合">Valgrind工具集合<a hidden class="anchor" aria-hidden="true" href="#valgrind工具集合">#</a></h1>
<h2 id="memcheck">Memcheck<a hidden class="anchor" aria-hidden="true" href="#memcheck">#</a></h2>
<p>最常用的工具，用来检测程序中出现的内存问题，所有对内存的读写都会被检测到，一切对malloc、free、new、delete的调用都会被捕获。所以，它能检测以下问题：</p>
<ol>
<li>
<p>对未初始化内存的使用；</p>
</li>
<li>
<p>读/写释放后的内存块；</p>
</li>
<li>
<p>读/写超出malloc分配的内存块；</p>
</li>
<li>
<p>读/写不适当的栈中内存块；</p>
</li>
<li>
<p>内存泄漏，指向一块内存的指针永远丢失；</p>
</li>
<li>
<p>不正确的malloc/free或new/delete匹配；</p>
</li>
<li>
<p>memcpy()相关函数中的dst和src指针重叠。</p>
</li>
</ol>
<p>这些问题往往是C/C++程序员最头疼的问题，Memcheck能在这里帮上大忙。</p>
<h2 id="callgrind">Callgrind<a hidden class="anchor" aria-hidden="true" href="#callgrind">#</a></h2>
<p>和gprof类似的分析工具，但它对程序的运行观察更是入微，能给我们提供更多的信息。和gprof不同，它不需要在编译源代码时附加特殊选项，但加上调试选项是推荐的。Callgrind收集程序运行时的一些数据，建立函数调用关系图，还可以有选择地进行cache模拟。在运行结束时，它会把分析数据写入一个文件。callgrind_annotate可以把这个文件的内容转化成可读的形式。</p>
<h2 id="cachegrind">Cachegrind<a hidden class="anchor" aria-hidden="true" href="#cachegrind">#</a></h2>
<p>cachegrind是一个cache剖析器。它模拟执行CPU中的L1, D1和L2 cache，因此它能很精确的指出代码中的cache未命中。如果你需要，它可以打印出cache未命中的次数，内存引用和发生cache未命中的每一行代码，每一个函数，每一个模块和整个程序的摘要。如果你要求更细致的信息，它可以打印出每一行机器码的未命中次数。在x86和amd64上， cachegrind通过CPUID自动探测机器的cache配置，所以在多数情况下它不再需要更多的配置信息了。</p>
<h2 id="helgrind">Helgrind<a hidden class="anchor" aria-hidden="true" href="#helgrind">#</a></h2>
<p>helgrind查找多线程程序中的竞争数据。helgrind查找内存地址，那些被多于一条线程访问的内存地址，但是没有使用一致的锁就会被查出。这表示这些地址在多线程间访问的时候没有进行同步，很可能会引起很难查找的时序问题。</p>
<p>它主要用来检查多线程程序中出现的竞争问题。Helgrind 寻找内存中被多个线程访问，而又没有一贯加锁的区域，这些区域往往是线程之间失去同步的地方，而且会导致难以发掘的错误。Helgrind实现了名为”Eraser” 的竞争检测算法，并做了进一步改进，减少了报告错误的次数。</p>
<h2 id="massif">Massif<a hidden class="anchor" aria-hidden="true" href="#massif">#</a></h2>
<p>堆栈分析器，它能测量程序在堆栈中使用了多少内存，告诉我们堆块，堆管理块和栈的大小。Massif能帮助我们减少内存的使用，在带有虚拟内存的现代系统中，它还能够加速我们程序的运行，减少程序停留在交换区中的几率。</p>
<p>Massif对内存的分配和释放做profile。程序开发者通过它可以深入了解程序的内存使用行为，从而对内存使用进行优化。这个功能对C++尤其有用，因为C++有很多隐藏的内存分配和释放</p>
<h2 id="lackey和nulgrind">lackey和nulgrind<a hidden class="anchor" aria-hidden="true" href="#lackey和nulgrind">#</a></h2>
<p>此外，lackey和nulgrind也会提供。Lackey是小型工具，很少用到；Nulgrind只是为开发者展示如何创建一个工具。我们就不做介绍了。</p>
<h1 id="valgrind的参数">Valgrind的参数<a hidden class="anchor" aria-hidden="true" href="#valgrind的参数">#</a></h1>
<p>用法: valgrind [options] prog-and-args [options]: 常用选项，适用于所有Valgrind工具</p>
<pre><code>--tool=&lt;name&gt;
</code></pre>
<p>最常用的选项。运行 valgrind中名为toolname的工具。默认memcheck。</p>
<pre><code>-h --help
</code></pre>
<p>显示所有选项的帮助，包括内核和选定的工具两者。</p>
<pre><code>--version
</code></pre>
<p>显示valgrind内核的版本，每个工具都有各自的版本。</p>
<pre><code>-q --quiet
</code></pre>
<p>安静地运行，只打印错误信息。</p>
<pre><code>--verbose
</code></pre>
<p>更详细的信息。</p>
<pre><code>--trace-children=&lt;yes|no&gt;
</code></pre>
<p>跟踪子线程? [default: no]</p>
<pre><code>--track-fds=&lt;yes|no&gt;
</code></pre>
<p>跟踪打开的文件描述？[default: no]</p>
<pre><code>--time-stamp=&lt;yes|no&gt;
</code></pre>
<p>增加时间戳到LOG信息? [default: no]</p>
<pre><code>--log-fd=&lt;number&gt;
</code></pre>
<p>输出LOG到描述符文件 [2=stderr]</p>
<pre><code>--log-file=&lt;file&gt;
</code></pre>
<p>将输出的信息写入到filename.PID的文件里，PID是运行程序的进行ID</p>
<pre><code>--log-file-exactly=&lt;file&gt;
</code></pre>
<p>输出LOG信息到 file</p>
<p>LOG信息输出</p>
<pre><code>--xml=yes
</code></pre>
<p>将信息以xml格式输出，只有memcheck可用</p>
<pre><code>--num-callers=&lt;number&gt;

show &lt;number&gt; callers in stack traces [12]

--error-exitcode=&lt;number&gt;
</code></pre>
<p>如果发现错误则返回错误代码 [0=disable]</p>
<pre><code>--db-attach=&lt;yes|no&gt;
</code></pre>
<p>当出现错误，valgrind会自动启动调试器gdb。[default: no]</p>
<pre><code>--db-command=&lt;command&gt;
</code></pre>
<p>启动调试器的命令行选项[gdb -nw %f %p]</p>
<p>适用于Memcheck工具的相关选项：</p>
<pre><code>--leak-check=&lt;no|summary|full&gt;
</code></pre>
<p>要求对leak给出详细信息? Leak是指，存在一块没有被引用的内存空间，或没有被释放的内存空间，如summary，只反馈一些总结信息，告诉你有多少个malloc，多少个free 等；如果是full将输出所有的leaks，也就是定位到某一个malloc/free。 [default: summary]</p>
<pre><code>--show-reachable=&lt;yes|no&gt;
</code></pre>
<p>如果为no，只输出没有引用的内存leaks，或指向malloc返回的内存块中部某处的leaks [default: no]</p>
<h1 id="valgrind-安装">Valgrind 安装<a hidden class="anchor" aria-hidden="true" href="#valgrind-安装">#</a></h1>
<h3 id="解压安装包">解压安装包<a hidden class="anchor" aria-hidden="true" href="#解压安装包">#</a></h3>
<pre><code>tar -jxvf valgrind-3.11.0.tar.bz2  -C /usr/local/src
</code></pre>
<h3 id="进入目录安装">进入目录安装<a hidden class="anchor" aria-hidden="true" href="#进入目录安装">#</a></h3>
<pre><code>cd /usr/local/src/valgrind-3.11.0
</code></pre>
<h3 id="运行autogensh-设置环境需要标准的autoconf工具">运行./autogen.sh 设置环境（需要标准的autoconf工具）<a hidden class="anchor" aria-hidden="true" href="#运行autogensh-设置环境需要标准的autoconf工具">#</a></h3>
<pre><code>./autogen.sh 
</code></pre>
<h3 id="配置valgrind生成makefile文件">配置Valgrind，生成MakeFile文件<a hidden class="anchor" aria-hidden="true" href="#配置valgrind生成makefile文件">#</a></h3>
<pre><code>./configure --prefix=/usr/local
</code></pre>
<h3 id="编译和安装valgrind">编译和安装valgrind<a hidden class="anchor" aria-hidden="true" href="#编译和安装valgrind">#</a></h3>
<pre><code>make  &amp;&amp; make install
</code></pre>
<h1 id="valgrind使用">Valgrind使用<a hidden class="anchor" aria-hidden="true" href="#valgrind使用">#</a></h1>
<p>为了valgrind发现的错误更精确，如能够定位到源代码的行，建议在编译时加上-g参数，编译优化选项选择O0(不要优化）</p>
<p>利用valgrind调试内存问题，不需要重新编译源程序，它的输入就是二进制的可执行程序。</p>
<p>如果程序是通过脚本启动的，可以修改脚本里启动程序的代码，或者使用–trace-children=yes选项来运行脚本。</p>
<h2 id="memcheck-1">memcheck<a hidden class="anchor" aria-hidden="true" href="#memcheck-1">#</a></h2>
<p>这里用到的示例程序文件名为：sample.c（如下所示）,选用的编译器为gcc。</p>
<p>生成可执行程序</p>
<pre><code>gcc –g –O0 sample.c –o sample
</code></pre>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/image004.jpg" alt=""  />
</p>
<p>运行valgrind，得到以下信息：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/image005.jpg" alt=""  />
</p>
<p>左边显示类似行号的数字（32372）表示的是 Process ID。</p>
<p>最上面的红色方框表示的是 valgrind 的版本信息。</p>
<p>中间的红色方框表示 valgrind 通过运行被测试程序，发现的内存问题。通过阅读这些信息，可以发现：</p>
<ol>
<li>
<p>这是一个对内存的非法写操作，非法写操作的内存是4 bytes。</p>
</li>
<li>
<p>发生错误时的函数堆栈，以及具体的源代码行号。</p>
</li>
<li>
<p>非法写操作的具体地址空间。</p>
</li>
</ol>
<p>最下面的红色方框是对发现的内存问题和内存泄露问题的总结。内存泄露的大小（40 bytes）也能够被检测出来。</p>
<p>示例程序显然有两个问题，一是fun函数中动态申请的堆内存没有释放；二是对堆内存的访问越界。这两个问题均被valgrind发现。</p>
<h1 id="memcheck的示例">memcheck的示例<a hidden class="anchor" aria-hidden="true" href="#memcheck的示例">#</a></h1>
<h2 id="例1使用未初始化的内存">例1．使用未初始化的内存<a hidden class="anchor" aria-hidden="true" href="#例1使用未初始化的内存">#</a></h2>
<p>代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;                                                              </span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;X is zero&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Valgrind提示如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">==</span><span class="mi">14222</span><span class="o">==</span> <span class="n">Conditional</span> <span class="n">jump</span> <span class="n">or</span> <span class="n">move</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">uninitialised</span> <span class="n">value</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="o">==</span><span class="mi">14222</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x400484</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">sample2</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>
<span class="n">X</span> <span class="n">is</span> <span class="n">zero</span><span class="o">==</span><span class="mi">14222</span><span class="o">==</span>
<span class="o">==</span><span class="mi">14222</span><span class="o">==</span> <span class="n">ERROR</span> <span class="nl">SUMMARY</span><span class="p">:</span> <span class="mi">1</span> <span class="n">errors</span> <span class="n">from</span> <span class="mi">1</span> <span class="n">contexts</span> <span class="p">(</span><span class="nl">suppressed</span><span class="p">:</span> <span class="mi">5</span> <span class="n">from</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">==</span><span class="mi">14222</span><span class="o">==</span> <span class="n">malloc</span><span class="o">/</span><span class="nl">free</span><span class="p">:</span> <span class="n">in</span> <span class="n">use</span> <span class="n">at</span> <span class="nl">exit</span><span class="p">:</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">0</span> <span class="n">blocks</span><span class="p">.</span>
<span class="o">==</span><span class="mi">14222</span><span class="o">==</span> <span class="n">malloc</span><span class="o">/</span><span class="nl">free</span><span class="p">:</span> <span class="mi">0</span> <span class="n">allocs</span><span class="p">,</span> <span class="mi">0</span> <span class="n">frees</span><span class="p">,</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">allocated</span><span class="p">.</span>
<span class="o">==</span><span class="mi">14222</span><span class="o">==</span> <span class="n">For</span> <span class="n">counts</span> <span class="n">of</span> <span class="n">detected</span> <span class="n">errors</span><span class="p">,</span> <span class="n">rerun</span> <span class="nl">with</span><span class="p">:</span> <span class="o">-</span><span class="n">v</span>
<span class="o">==</span><span class="mi">14222</span><span class="o">==</span> <span class="n">All</span> <span class="n">heap</span> <span class="n">blocks</span> <span class="n">were</span> <span class="n">freed</span> <span class="o">--</span> <span class="n">no</span> <span class="n">leaks</span> <span class="n">are</span> <span class="n">possible</span><span class="p">.</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="例2内存读写越界">例2．内存读写越界<a hidden class="anchor" aria-hidden="true" href="#例2内存读写越界">#</a></h2>
<p>代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">pt</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">len</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">pt</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span><span class="n">p</span><span class="o">++</span><span class="p">;}</span>
    <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="o">%</span><span class="n">d</span><span class="err">”</span><span class="p">,</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Valgrind提示如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">==</span><span class="mi">23045</span><span class="o">==</span> <span class="n">Invalid</span> <span class="n">write</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">4</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x40050A</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">sample2</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">11</span><span class="p">)</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span> <span class="n">Address</span> <span class="mh">0x4C2E044</span> <span class="n">is</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">after</span> <span class="n">a</span> <span class="n">block</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">20</span> <span class="n">alloc</span><span class="err">&#39;</span><span class="n">d</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x4A05809</span><span class="o">:</span> <span class="n">malloc</span> <span class="p">(</span><span class="n">vg_replace_malloc</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">149</span><span class="p">)</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span> <span class="n">by</span> <span class="mh">0x4004DF</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">sample2</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span> <span class="n">Invalid</span> <span class="n">read</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">4</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x400514</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">sample2</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">12</span><span class="p">)</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span> <span class="n">Address</span> <span class="mh">0x4C2E044</span> <span class="n">is</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">after</span> <span class="n">a</span> <span class="n">block</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">20</span> <span class="n">alloc</span><span class="err">&#39;</span><span class="n">d</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x4A05809</span><span class="o">:</span> <span class="n">malloc</span> <span class="p">(</span><span class="n">vg_replace_malloc</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">149</span><span class="p">)</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span> <span class="n">by</span> <span class="mh">0x4004DF</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">sample2</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>
<span class="mi">5</span><span class="o">==</span><span class="mi">23045</span><span class="o">==</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span> <span class="n">ERROR</span> <span class="nl">SUMMARY</span><span class="p">:</span> <span class="mi">2</span> <span class="n">errors</span> <span class="n">from</span> <span class="mi">2</span> <span class="n">contexts</span> <span class="p">(</span><span class="nl">suppressed</span><span class="p">:</span> <span class="mi">5</span> <span class="n">from</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span> <span class="n">malloc</span><span class="o">/</span><span class="nl">free</span><span class="p">:</span> <span class="n">in</span> <span class="n">use</span> <span class="n">at</span> <span class="nl">exit</span><span class="p">:</span> <span class="mi">20</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">1</span> <span class="n">blocks</span><span class="p">.</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span> <span class="n">malloc</span><span class="o">/</span><span class="nl">free</span><span class="p">:</span> <span class="mi">1</span> <span class="n">allocs</span><span class="p">,</span> <span class="mi">0</span> <span class="n">frees</span><span class="p">,</span> <span class="mi">20</span> <span class="n">bytes</span> <span class="n">allocated</span><span class="p">.</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span> <span class="n">For</span> <span class="n">counts</span> <span class="n">of</span> <span class="n">detected</span> <span class="n">errors</span><span class="p">,</span> <span class="n">rerun</span> <span class="nl">with</span><span class="p">:</span> <span class="o">-</span><span class="n">v</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span> <span class="n">searching</span> <span class="k">for</span> <span class="n">pointers</span> <span class="n">to</span> <span class="mi">1</span> <span class="n">not</span><span class="o">-</span><span class="n">freed</span> <span class="n">blocks</span><span class="p">.</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span> <span class="n">checked</span> <span class="mi">66</span><span class="p">,</span><span class="mi">584</span> <span class="n">bytes</span><span class="p">.</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span> <span class="n">LEAK</span> <span class="nl">SUMMARY</span><span class="p">:</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span> <span class="n">definitely</span> <span class="nl">lost</span><span class="p">:</span> <span class="mi">20</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">1</span> <span class="n">blocks</span><span class="p">.</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span> <span class="n">possibly</span> <span class="nl">lost</span><span class="p">:</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">0</span> <span class="n">blocks</span><span class="p">.</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span> <span class="n">still</span> <span class="nl">reachable</span><span class="p">:</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">0</span> <span class="n">blocks</span><span class="p">.</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span> <span class="nl">suppressed</span><span class="p">:</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">0</span> <span class="n">blocks</span><span class="p">.</span>
<span class="o">==</span><span class="mi">23045</span><span class="o">==</span> <span class="n">Use</span> <span class="o">--</span><span class="n">leak</span><span class="o">-</span><span class="n">check</span><span class="o">=</span><span class="n">full</span> <span class="n">to</span> <span class="n">see</span> <span class="n">details</span> <span class="n">of</span> <span class="n">leaked</span> <span class="n">memory</span><span class="p">.</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="例3src和dst内存覆盖">例3．src和dst内存覆盖<a hidden class="anchor" aria-hidden="true" href="#例3src和dst内存覆盖">#</a></h2>
<p>代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span> <span class="kt">char</span> <span class="n">x</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">50</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;}</span>
<span class="n">strncpy</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">20</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span> <span class="c1">//Good
</span><span class="c1"></span><span class="n">strncpy</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">20</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="mi">21</span><span class="p">);</span> <span class="c1">//Overlap
</span><span class="c1"></span><span class="n">x</span><span class="p">[</span><span class="mi">39</span><span class="p">]</span><span class="o">=</span><span class="err">’\</span><span class="mi">0</span><span class="err">’</span><span class="p">;</span>
<span class="n">strcpy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="o">+</span><span class="mi">20</span><span class="p">);</span> <span class="c1">//Good
</span><span class="c1"></span><span class="n">x</span><span class="p">[</span><span class="mi">39</span><span class="p">]</span><span class="o">=</span><span class="mi">40</span><span class="p">;</span>
<span class="n">x</span><span class="p">[</span><span class="mi">40</span><span class="p">]</span><span class="o">=</span><span class="err">’\</span><span class="mi">0</span><span class="err">’</span><span class="p">;</span>
<span class="n">strcpy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="o">+</span><span class="mi">20</span><span class="p">);</span> <span class="c1">//Overlap
</span><span class="c1"></span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Valgrind提示如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">==</span><span class="mi">24139</span><span class="o">==</span> <span class="n">Source</span> <span class="n">and</span> <span class="n">destination</span> <span class="n">overlap</span> <span class="n">in</span> <span class="n">strncpy</span><span class="p">(</span><span class="mh">0x7FEFFFC09</span><span class="p">,</span> <span class="mh">0x7FEFFFBF5</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span>

<span class="o">==</span><span class="mi">24139</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x4A0724F</span><span class="o">:</span> <span class="n">strncpy</span> <span class="p">(</span><span class="n">mc_replace_strmem</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">116</span><span class="p">)</span>

<span class="o">==</span><span class="mi">24139</span><span class="o">==</span> <span class="n">by</span> <span class="mh">0x400527</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">sample3</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span>

<span class="o">==</span><span class="mi">24139</span><span class="o">==</span>

<span class="o">==</span><span class="mi">24139</span><span class="o">==</span> <span class="n">Source</span> <span class="n">and</span> <span class="n">destination</span> <span class="n">overlap</span> <span class="n">in</span> <span class="n">strcpy</span><span class="p">(</span><span class="mh">0x7FEFFFBE0</span><span class="p">,</span> <span class="mh">0x7FEFFFBF4</span><span class="p">)</span>

<span class="o">==</span><span class="mi">24139</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x4A06E47</span><span class="o">:</span> <span class="n">strcpy</span> <span class="p">(</span><span class="n">mc_replace_strmem</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">106</span><span class="p">)</span>

<span class="o">==</span><span class="mi">24139</span><span class="o">==</span> <span class="n">by</span> <span class="mh">0x400555</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">sample3</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">15</span><span class="p">)</span>

<span class="o">==</span><span class="mi">24139</span><span class="o">==</span>

<span class="o">==</span><span class="mi">24139</span><span class="o">==</span> <span class="n">ERROR</span> <span class="nl">SUMMARY</span><span class="p">:</span> <span class="mi">2</span> <span class="n">errors</span> <span class="n">from</span> <span class="mi">2</span> <span class="n">contexts</span> <span class="p">(</span><span class="nl">suppressed</span><span class="p">:</span> <span class="mi">5</span> <span class="n">from</span> <span class="mi">1</span><span class="p">)</span>

<span class="o">==</span><span class="mi">24139</span><span class="o">==</span> <span class="n">malloc</span><span class="o">/</span><span class="nl">free</span><span class="p">:</span> <span class="n">in</span> <span class="n">use</span> <span class="n">at</span> <span class="nl">exit</span><span class="p">:</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">0</span> <span class="n">blocks</span><span class="p">.</span>

<span class="o">==</span><span class="mi">24139</span><span class="o">==</span> <span class="n">malloc</span><span class="o">/</span><span class="nl">free</span><span class="p">:</span> <span class="mi">0</span> <span class="n">allocs</span><span class="p">,</span> <span class="mi">0</span> <span class="n">frees</span><span class="p">,</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">allocated</span><span class="p">.</span>

<span class="o">==</span><span class="mi">24139</span><span class="o">==</span> <span class="n">For</span> <span class="n">counts</span> <span class="n">of</span> <span class="n">detected</span> <span class="n">errors</span><span class="p">,</span> <span class="n">rerun</span> <span class="nl">with</span><span class="p">:</span> <span class="o">-</span><span class="n">v</span>

<span class="o">==</span><span class="mi">24139</span><span class="o">==</span> <span class="n">All</span> <span class="n">heap</span> <span class="n">blocks</span> <span class="n">were</span> <span class="n">freed</span> <span class="o">--</span> <span class="n">no</span> <span class="n">leaks</span> <span class="n">are</span> <span class="n">possible</span><span class="p">.</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="例4动态内存管理错误">例4．动态内存管理错误<a hidden class="anchor" aria-hidden="true" href="#例4动态内存管理错误">#</a></h2>
<p>常见的内存分配方式分三种：静态存储，栈上分配，堆上分配。全局变量属于静态存储，它们是在编译时就被分配了存储空间，函数内的局部变量属于栈上分配，而最灵活的内存使用方式当属堆上分配，也叫做内存动态分配了。常用的内存动态分配函数包括：malloc, alloc, realloc, new等，动态释放函数包括free, delete。</p>
<p>一旦成功申请了动态内存，我们就需要自己对其进行内存管理，而这又是最容易犯错误的。常见的内存动态管理错误包括：</p>
<h3 id="申请和释放不一致">申请和释放不一致<a hidden class="anchor" aria-hidden="true" href="#申请和释放不一致">#</a></h3>
<p>由于 C++ 兼容 C，而 C 与 C++ 的内存申请和释放函数是不同的，因此在 C++ 程序中，就有两套动态内存管理函数。一条不变的规则就是采用 C 方式申请的内存就用 C 方式释放；用 C++ 方式申请的内存，用 C++ 方式释放。也就是用 malloc/alloc/realloc 方式申请的内存，用 free 释放；用 new 方式申请的内存用 delete 释放。在上述程序中，用 malloc 方式申请了内存却用 delete 来释放，虽然这在很多情况下不会有问题，但这绝对是潜在的问题。</p>
<h3 id="申请和释放不匹配">申请和释放不匹配<a hidden class="anchor" aria-hidden="true" href="#申请和释放不匹配">#</a></h3>
<p>申请了多少内存，在使用完成后就要释放多少。如果没有释放，或者少释放了就是内存泄露；多释放了也会产生问题。上述程序中，指针p和pt指向的是同一块内存，却被先后释放两次。</p>
<h3 id="释放后仍然读写">释放后仍然读写<a hidden class="anchor" aria-hidden="true" href="#释放后仍然读写">#</a></h3>
<p>本质上说，系统会在堆上维护一个动态内存链表，如果被释放，就意味着该块内存可以继续被分配给其他部分，如果内存被释放后再访问，就可能覆盖其他部分的信息，这是一种严重的错误，上述程序第16行中就在释放后仍然写这块内存。</p>
<p>下面的一段程序，就包括了内存动态管理中常见的错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">pt</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="err">’</span><span class="n">z</span><span class="err">’</span><span class="p">;}</span>
<span class="n">delete</span> <span class="n">p</span><span class="p">;</span>
<span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="err">’</span><span class="n">a</span><span class="err">’</span><span class="p">;</span>
<span class="n">free</span><span class="p">(</span><span class="n">pt</span><span class="p">);</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Valgrind提示如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">==</span><span class="mi">25811</span><span class="o">==</span> <span class="n">Mismatched</span> <span class="n">free</span><span class="p">()</span> <span class="o">/</span> <span class="n">delete</span> <span class="o">/</span> <span class="n">delete</span> <span class="p">[]</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x4A05130</span><span class="o">:</span> <span class="n">operator</span> <span class="n">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">vg_replace_malloc</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">244</span><span class="p">)</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span> <span class="n">by</span> <span class="mh">0x400654</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">sample4</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">9</span><span class="p">)</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span> <span class="n">Address</span> <span class="mh">0x4C2F030</span> <span class="n">is</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">inside</span> <span class="n">a</span> <span class="n">block</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">10</span> <span class="n">alloc</span><span class="err">&#39;</span><span class="n">d</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x4A05809</span><span class="o">:</span> <span class="n">malloc</span> <span class="p">(</span><span class="n">vg_replace_malloc</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">149</span><span class="p">)</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span> <span class="n">by</span> <span class="mh">0x400620</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">sample4</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span> <span class="n">Invalid</span> <span class="n">write</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">1</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x40065D</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">sample4</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span> <span class="n">Address</span> <span class="mh">0x4C2F031</span> <span class="n">is</span> <span class="mi">1</span> <span class="n">bytes</span> <span class="n">inside</span> <span class="n">a</span> <span class="n">block</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">10</span> <span class="n">free</span><span class="err">&#39;</span><span class="n">d</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x4A05130</span><span class="o">:</span> <span class="n">operator</span> <span class="n">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">vg_replace_malloc</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">244</span><span class="p">)</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span> <span class="n">by</span> <span class="mh">0x400654</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">sample4</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">9</span><span class="p">)</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span> <span class="n">Invalid</span> <span class="n">free</span><span class="p">()</span> <span class="o">/</span> <span class="n">delete</span> <span class="o">/</span> <span class="n">delete</span><span class="p">[]</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x4A0541E</span><span class="o">:</span> <span class="n">free</span> <span class="p">(</span><span class="n">vg_replace_malloc</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">233</span><span class="p">)</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span> <span class="n">by</span> <span class="mh">0x400668</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">sample4</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">11</span><span class="p">)</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span> <span class="n">Address</span> <span class="mh">0x4C2F030</span> <span class="n">is</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">inside</span> <span class="n">a</span> <span class="n">block</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">10</span> <span class="n">free</span><span class="err">&#39;</span><span class="n">d</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x4A05130</span><span class="o">:</span> <span class="n">operator</span> <span class="n">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">vg_replace_malloc</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">244</span><span class="p">)</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span> <span class="n">by</span> <span class="mh">0x400654</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">sample4</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">9</span><span class="p">)</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span> <span class="n">ERROR</span> <span class="nl">SUMMARY</span><span class="p">:</span> <span class="mi">3</span> <span class="n">errors</span> <span class="n">from</span> <span class="mi">3</span> <span class="n">contexts</span> <span class="p">(</span><span class="nl">suppressed</span><span class="p">:</span> <span class="mi">5</span> <span class="n">from</span> <span class="mi">1</span><span class="p">)</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span> <span class="n">malloc</span><span class="o">/</span><span class="nl">free</span><span class="p">:</span> <span class="n">in</span> <span class="n">use</span> <span class="n">at</span> <span class="nl">exit</span><span class="p">:</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">0</span> <span class="n">blocks</span><span class="p">.</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span> <span class="n">malloc</span><span class="o">/</span><span class="nl">free</span><span class="p">:</span> <span class="mi">1</span> <span class="n">allocs</span><span class="p">,</span> <span class="mi">2</span> <span class="n">frees</span><span class="p">,</span> <span class="mi">10</span> <span class="n">bytes</span> <span class="n">allocated</span><span class="p">.</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span> <span class="n">For</span> <span class="n">counts</span> <span class="n">of</span> <span class="n">detected</span> <span class="n">errors</span><span class="p">,</span> <span class="n">rerun</span> <span class="nl">with</span><span class="p">:</span> <span class="o">-</span><span class="n">v</span>

<span class="o">==</span><span class="mi">25811</span><span class="o">==</span> <span class="n">All</span> <span class="n">heap</span> <span class="n">blocks</span> <span class="n">were</span> <span class="n">freed</span> <span class="o">--</span> <span class="n">no</span> <span class="n">leaks</span> <span class="n">are</span> <span class="n">possible</span><span class="p">.</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="例5内存泄漏">例5．内存泄漏<a hidden class="anchor" aria-hidden="true" href="#例5内存泄漏">#</a></h2>
<p>代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="n">x</span><span class="o">=</span><span class="n">y</span><span class="p">;</span>
<span class="n">free</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Valgrind提示如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">==</span><span class="mi">19013</span><span class="o">==</span> <span class="n">Invalid</span> <span class="n">free</span><span class="p">()</span> <span class="o">/</span> <span class="n">delete</span> <span class="o">/</span> <span class="n">delete</span><span class="p">[]</span>

<span class="o">==</span><span class="mi">19013</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x4A0541E</span><span class="o">:</span> <span class="n">free</span> <span class="p">(</span><span class="n">vg_replace_malloc</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">233</span><span class="p">)</span>

<span class="o">==</span><span class="mi">19013</span><span class="o">==</span> <span class="n">by</span> <span class="mh">0x4004F5</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">sample5</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">8</span><span class="p">)</span>

<span class="o">==</span><span class="mi">19013</span><span class="o">==</span> <span class="n">Address</span> <span class="mh">0x4C2E078</span> <span class="n">is</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">inside</span> <span class="n">a</span> <span class="n">block</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">20</span> <span class="n">free</span><span class="err">&#39;</span><span class="n">d</span>

<span class="o">==</span><span class="mi">19013</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x4A0541E</span><span class="o">:</span> <span class="n">free</span> <span class="p">(</span><span class="n">vg_replace_malloc</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">233</span><span class="p">)</span>

<span class="o">==</span><span class="mi">19013</span><span class="o">==</span> <span class="n">by</span> <span class="mh">0x4004EC</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">sample5</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>

<span class="o">==</span><span class="mi">19013</span><span class="o">==</span>

<span class="o">==</span><span class="mi">19013</span><span class="o">==</span> <span class="n">ERROR</span> <span class="nl">SUMMARY</span><span class="p">:</span> <span class="mi">1</span> <span class="n">errors</span> <span class="n">from</span> <span class="mi">1</span> <span class="n">contexts</span> <span class="p">(</span><span class="nl">suppressed</span><span class="p">:</span> <span class="mi">5</span> <span class="n">from</span> <span class="mi">1</span><span class="p">)</span>

<span class="o">==</span><span class="mi">19013</span><span class="o">==</span> <span class="n">malloc</span><span class="o">/</span><span class="nl">free</span><span class="p">:</span> <span class="n">in</span> <span class="n">use</span> <span class="n">at</span> <span class="nl">exit</span><span class="p">:</span> <span class="mi">20</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">1</span> <span class="n">blocks</span><span class="p">.</span>

<span class="o">==</span><span class="mi">19013</span><span class="o">==</span> <span class="n">malloc</span><span class="o">/</span><span class="nl">free</span><span class="p">:</span> <span class="mi">2</span> <span class="n">allocs</span><span class="p">,</span> <span class="mi">2</span> <span class="n">frees</span><span class="p">,</span> <span class="mi">40</span> <span class="n">bytes</span> <span class="n">allocated</span><span class="p">.</span>

<span class="o">==</span><span class="mi">19013</span><span class="o">==</span> <span class="n">For</span> <span class="n">counts</span> <span class="n">of</span> <span class="n">detected</span> <span class="n">errors</span><span class="p">,</span> <span class="n">rerun</span> <span class="nl">with</span><span class="p">:</span> <span class="o">-</span><span class="n">v</span>

<span class="o">==</span><span class="mi">19013</span><span class="o">==</span> <span class="n">searching</span> <span class="k">for</span> <span class="n">pointers</span> <span class="n">to</span> <span class="mi">1</span> <span class="n">not</span><span class="o">-</span><span class="n">freed</span> <span class="n">blocks</span><span class="p">.</span>

<span class="o">==</span><span class="mi">19013</span><span class="o">==</span> <span class="n">checked</span> <span class="mi">66</span><span class="p">,</span><span class="mi">584</span> <span class="n">bytes</span><span class="p">.</span>

<span class="o">==</span><span class="mi">19013</span><span class="o">==</span>

<span class="o">==</span><span class="mi">19013</span><span class="o">==</span> <span class="n">LEAK</span> <span class="nl">SUMMARY</span><span class="p">:</span>

<span class="o">==</span><span class="mi">19013</span><span class="o">==</span> <span class="n">definitely</span> <span class="nl">lost</span><span class="p">:</span> <span class="mi">20</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">1</span> <span class="n">blocks</span><span class="p">.</span>

<span class="o">==</span><span class="mi">19013</span><span class="o">==</span> <span class="n">possibly</span> <span class="nl">lost</span><span class="p">:</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">0</span> <span class="n">blocks</span><span class="p">.</span>

<span class="o">==</span><span class="mi">19013</span><span class="o">==</span> <span class="n">still</span> <span class="nl">reachable</span><span class="p">:</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">0</span> <span class="n">blocks</span><span class="p">.</span>

<span class="o">==</span><span class="mi">19013</span><span class="o">==</span> <span class="nl">suppressed</span><span class="p">:</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">0</span> <span class="n">blocks</span><span class="p">.</span>

<span class="o">==</span><span class="mi">19013</span><span class="o">==</span> <span class="n">Use</span> <span class="o">--</span><span class="n">leak</span><span class="o">-</span><span class="n">check</span><span class="o">=</span><span class="n">full</span> <span class="n">to</span> <span class="n">see</span> <span class="n">details</span> <span class="n">of</span> <span class="n">leaked</span> <span class="n">memory</span><span class="p">.</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="例6非法写读">例6．非法写/读<a hidden class="anchor" aria-hidden="true" href="#例6非法写读">#</a></h1>
<p>代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">11</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="n">free</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Valgrind提示如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">==</span><span class="mi">21483</span><span class="o">==</span> <span class="n">Invalid</span> <span class="n">write</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">4</span>

<span class="o">==</span><span class="mi">21483</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x4004EA</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">sample6</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>

<span class="o">==</span><span class="mi">21483</span><span class="o">==</span> <span class="n">Address</span> <span class="mh">0x4C2E058</span> <span class="n">is</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">after</span> <span class="n">a</span> <span class="n">block</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">40</span> <span class="n">alloc</span><span class="err">&#39;</span><span class="n">d</span>

<span class="o">==</span><span class="mi">21483</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x4A05809</span><span class="o">:</span> <span class="n">malloc</span> <span class="p">(</span><span class="n">vg_replace_malloc</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">149</span><span class="p">)</span>

<span class="o">==</span><span class="mi">21483</span><span class="o">==</span> <span class="n">by</span> <span class="mh">0x4004C9</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">sample6</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>

<span class="o">==</span><span class="mi">21483</span><span class="o">==</span>

<span class="o">==</span><span class="mi">21483</span><span class="o">==</span> <span class="n">ERROR</span> <span class="nl">SUMMARY</span><span class="p">:</span> <span class="mi">1</span> <span class="n">errors</span> <span class="n">from</span> <span class="mi">1</span> <span class="n">contexts</span> <span class="p">(</span><span class="nl">suppressed</span><span class="p">:</span> <span class="mi">5</span> <span class="n">from</span> <span class="mi">1</span><span class="p">)</span>

<span class="o">==</span><span class="mi">21483</span><span class="o">==</span> <span class="n">malloc</span><span class="o">/</span><span class="nl">free</span><span class="p">:</span> <span class="n">in</span> <span class="n">use</span> <span class="n">at</span> <span class="nl">exit</span><span class="p">:</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">0</span> <span class="n">blocks</span><span class="p">.</span>

<span class="o">==</span><span class="mi">21483</span><span class="o">==</span> <span class="n">malloc</span><span class="o">/</span><span class="nl">free</span><span class="p">:</span> <span class="mi">1</span> <span class="n">allocs</span><span class="p">,</span> <span class="mi">1</span> <span class="n">frees</span><span class="p">,</span> <span class="mi">40</span> <span class="n">bytes</span> <span class="n">allocated</span><span class="p">.</span>

<span class="o">==</span><span class="mi">21483</span><span class="o">==</span> <span class="n">For</span> <span class="n">counts</span> <span class="n">of</span> <span class="n">detected</span> <span class="n">errors</span><span class="p">,</span> <span class="n">rerun</span> <span class="nl">with</span><span class="p">:</span> <span class="o">-</span><span class="n">v</span>

<span class="o">==</span><span class="mi">21483</span><span class="o">==</span> <span class="n">All</span> <span class="n">heap</span> <span class="n">blocks</span> <span class="n">were</span> <span class="n">freed</span> <span class="o">--</span> <span class="n">no</span> <span class="n">leaks</span> <span class="n">are</span> <span class="n">possible</span><span class="p">.</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="例7无效指针">例7．无效指针<a hidden class="anchor" aria-hidden="true" href="#例7无效指针">#</a></h2>
<p>代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">x</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
<span class="n">free</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Valgrind提示如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">==</span><span class="mi">15262</span><span class="o">==</span> <span class="n">Invalid</span> <span class="n">write</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">1</span>

<span class="o">==</span><span class="mi">15262</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x4004D6</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">sample7</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>

<span class="o">==</span><span class="mi">15262</span><span class="o">==</span> <span class="n">Address</span> <span class="mh">0x4C2E03A</span> <span class="n">is</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">after</span> <span class="n">a</span> <span class="n">block</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">10</span> <span class="n">alloc</span><span class="err">&#39;</span><span class="n">d</span>

<span class="o">==</span><span class="mi">15262</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x4A05809</span><span class="o">:</span> <span class="n">malloc</span> <span class="p">(</span><span class="n">vg_replace_malloc</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">149</span><span class="p">)</span>

<span class="o">==</span><span class="mi">15262</span><span class="o">==</span> <span class="n">by</span> <span class="mh">0x4004C9</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">sample7</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>

<span class="o">==</span><span class="mi">15262</span><span class="o">==</span>

<span class="o">==</span><span class="mi">15262</span><span class="o">==</span> <span class="n">ERROR</span> <span class="nl">SUMMARY</span><span class="p">:</span> <span class="mi">1</span> <span class="n">errors</span> <span class="n">from</span> <span class="mi">1</span> <span class="n">contexts</span> <span class="p">(</span><span class="nl">suppressed</span><span class="p">:</span> <span class="mi">5</span> <span class="n">from</span> <span class="mi">1</span><span class="p">)</span>

<span class="o">==</span><span class="mi">15262</span><span class="o">==</span> <span class="n">malloc</span><span class="o">/</span><span class="nl">free</span><span class="p">:</span> <span class="n">in</span> <span class="n">use</span> <span class="n">at</span> <span class="nl">exit</span><span class="p">:</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">0</span> <span class="n">blocks</span><span class="p">.</span>

<span class="o">==</span><span class="mi">15262</span><span class="o">==</span> <span class="n">malloc</span><span class="o">/</span><span class="nl">free</span><span class="p">:</span> <span class="mi">1</span> <span class="n">allocs</span><span class="p">,</span> <span class="mi">1</span> <span class="n">frees</span><span class="p">,</span> <span class="mi">10</span> <span class="n">bytes</span> <span class="n">allocated</span><span class="p">.</span>

<span class="o">==</span><span class="mi">15262</span><span class="o">==</span> <span class="n">For</span> <span class="n">counts</span> <span class="n">of</span> <span class="n">detected</span> <span class="n">errors</span><span class="p">,</span> <span class="n">rerun</span> <span class="nl">with</span><span class="p">:</span> <span class="o">-</span><span class="n">v</span>

<span class="o">==</span><span class="mi">15262</span><span class="o">==</span> <span class="n">All</span> <span class="n">heap</span> <span class="n">blocks</span> <span class="n">were</span> <span class="n">freed</span> <span class="o">--</span> <span class="n">no</span> <span class="n">leaks</span> <span class="n">are</span> <span class="n">possible</span><span class="p">.</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="例8重复释放">例8．重复释放<a hidden class="anchor" aria-hidden="true" href="#例8重复释放">#</a></h2>
<p>代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Valgrind提示如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">==</span><span class="mi">15005</span><span class="o">==</span> <span class="n">Invalid</span> <span class="n">free</span><span class="p">()</span> <span class="o">/</span> <span class="n">delete</span> <span class="o">/</span> <span class="n">delete</span><span class="p">[]</span>

<span class="o">==</span><span class="mi">15005</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x4A0541E</span><span class="o">:</span> <span class="n">free</span> <span class="p">(</span><span class="n">vg_replace_malloc</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">233</span><span class="p">)</span>

<span class="o">==</span><span class="mi">15005</span><span class="o">==</span> <span class="n">by</span> <span class="mh">0x4004DF</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">sample8</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>

<span class="o">==</span><span class="mi">15005</span><span class="o">==</span> <span class="n">Address</span> <span class="mh">0x4C2E030</span> <span class="n">is</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">inside</span> <span class="n">a</span> <span class="n">block</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">10</span> <span class="n">free</span><span class="err">&#39;</span><span class="n">d</span>

<span class="o">==</span><span class="mi">15005</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x4A0541E</span><span class="o">:</span> <span class="n">free</span> <span class="p">(</span><span class="n">vg_replace_malloc</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">233</span><span class="p">)</span>

<span class="o">==</span><span class="mi">15005</span><span class="o">==</span> <span class="n">by</span> <span class="mh">0x4004D6</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">sample8</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>

<span class="o">==</span><span class="mi">15005</span><span class="o">==</span>

<span class="o">==</span><span class="mi">15005</span><span class="o">==</span> <span class="n">ERROR</span> <span class="nl">SUMMARY</span><span class="p">:</span> <span class="mi">1</span> <span class="n">errors</span> <span class="n">from</span> <span class="mi">1</span> <span class="n">contexts</span> <span class="p">(</span><span class="nl">suppressed</span><span class="p">:</span> <span class="mi">5</span> <span class="n">from</span> <span class="mi">1</span><span class="p">)</span>

<span class="o">==</span><span class="mi">15005</span><span class="o">==</span> <span class="n">malloc</span><span class="o">/</span><span class="nl">free</span><span class="p">:</span> <span class="n">in</span> <span class="n">use</span> <span class="n">at</span> <span class="nl">exit</span><span class="p">:</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">0</span> <span class="n">blocks</span><span class="p">.</span>

<span class="o">==</span><span class="mi">15005</span><span class="o">==</span> <span class="n">malloc</span><span class="o">/</span><span class="nl">free</span><span class="p">:</span> <span class="mi">1</span> <span class="n">allocs</span><span class="p">,</span> <span class="mi">2</span> <span class="n">frees</span><span class="p">,</span> <span class="mi">10</span> <span class="n">bytes</span> <span class="n">allocated</span><span class="p">.</span>

<span class="o">==</span><span class="mi">15005</span><span class="o">==</span> <span class="n">For</span> <span class="n">counts</span> <span class="n">of</span> <span class="n">detected</span> <span class="n">errors</span><span class="p">,</span> <span class="n">rerun</span> <span class="nl">with</span><span class="p">:</span> <span class="o">-</span><span class="n">v</span>

<span class="o">==</span><span class="mi">15005</span><span class="o">==</span> <span class="n">All</span> <span class="n">heap</span> <span class="n">blocks</span> <span class="n">were</span> <span class="n">freed</span> <span class="o">--</span> <span class="n">no</span> <span class="n">leaks</span> <span class="n">are</span> <span class="n">possible</span><span class="p">.</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="valgrind的局限">Valgrind的局限<a hidden class="anchor" aria-hidden="true" href="#valgrind的局限">#</a></h1>
<ol>
<li>
<p>Valgrind不对静态数组(分配在栈上)进行边界检查。如果在程序中声明了一个数组:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="kt">char</span> <span class="n">x</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">x</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>``</p>
<p>Valgrind则不会警告你，你可以把数组改为动态在堆上分配的数组，这样就可能进行边界检查了。这个方法好像有点得不偿失的感觉。</p>
</li>
<li>
<p>Valgrind占用了更多的内存–可达两倍于你程序的正常使用量。如果你用Valgrind来检测使用大量内存的程序就会遇到问题，它可能会用很长的时间来运行测试。大多数情况下，这都不是问题，即使速度慢也仅是检测时速度慢，如果你用Valgrind来检测一个正常运行时速度就很慢的程序，这下问题就大了。</p>
</li>
<li>
<p>Valgrind不可能检测出你在程序中犯下的所有错误–如果你不检查缓冲区溢出，Valgrind也不会告诉你代码写了它不应该写的内存。</p>
</li>
</ol>
<h1 id="参数指令">参数指令<a hidden class="anchor" aria-hidden="true" href="#参数指令">#</a></h1>
<h2 id="基本选项">基本选项：<a hidden class="anchor" aria-hidden="true" href="#基本选项">#</a></h2>
<p>这些选项对所有工具都有效。</p>
<pre><code>-h --help
</code></pre>
<p>显示所有选项的帮助，包括内核和选定的工具两者。</p>
<pre><code>--help-debug
</code></pre>
<p>和–help相同，并且还能显示通常只有Valgrind的开发人员使用的调试选项。</p>
<pre><code>--version
</code></pre>
<p>显示Valgrind内核的版本号。工具可以有他们自已的版本号。这是一种保证工具只在它们可以运行的内核上工作的一种设置。这样可以减少在工具和内核之间版本兼容性导致奇怪问题的概率。</p>
<pre><code>-q --quiet
</code></pre>
<p>安静的运行，只打印错误信息。在进行回归测试或者有其它的自动化测试机制时会非常有用。</p>
<pre><code>-v --verbose
</code></pre>
<p>显示详细信息。在各个方面显示你的程序的额外信息，例如：共享对象加载，使用的重置，执行引擎和工具的进程，异常行为的警告信息。重复这个标记可以增加详细的级别。</p>
<pre><code>-d
</code></pre>
<p>调试Valgrind自身发出的信息。通常只有Valgrind开发人员对此感兴趣。重复这个标记可以产生更详细的输出。如果你希望发送一个bug报告，通过-v -v -d -d生成的输出会使你的报告更加有效。</p>
<pre><code>--tool=&lt;toolname&gt; [default: memcheck]
</code></pre>
<p>运行toolname指定的Valgrind，例如，Memcheck, Addrcheck, Cachegrind,等等。</p>
<pre><code>--trace-children=&lt;yes|no&gt; [default: no]
</code></pre>
<p>当这个选项打开时，Valgrind会跟踪到子进程中。这经常会导致困惑，而且通常不是你所期望的，所以默认这个选项是关闭的。</p>
<pre><code>--track-fds=&lt;yes|no&gt; [default: no]
</code></pre>
<p>当这个选项打开时，Valgrind会在退出时打印一个打开文件描述符的列表。每个文件描述符都会打印出一个文件是在哪里打开的栈回溯，和任何与此文件描述符相关的详细信息比如文件名或socket信息。</p>
<pre><code>--time-stamp=&lt;yes|no&gt; [default: no]
</code></pre>
<p>当这个选项打开时，每条信息之前都有一个从程序开始消逝的时间，用天，小时，分钟，秒和毫秒表示。</p>
<pre><code>--log-fd=&lt;number&gt; [default: 2, stderr]
</code></pre>
<p>指定Valgrind把它所有的消息都输出到一个指定的文件描述符中去。默认值2, 是标准错误输出(stderr)。注意这可能会干扰到客户端自身对stderr的使用, Valgrind的输出与客户程序的输出将穿插在一起输出到stderr。</p>
<pre><code>--log-file=&lt;filename&gt;
</code></pre>
<p>指定Valgrind把它所有的信息输出到指定的文件中。实际上，被创建文件的文件名是由filename、’.’和进程号连接起来的（即.），从而每个进程创建不同的文件。</p>
<pre><code>--log-file-exactly=&lt;filename&gt;
</code></pre>
<p>类似于–log-file，但是后缀”.pid”不会被添加。如果设置了这个选项，使用Valgrind跟踪多个进程，可能会得到一个乱七八糟的文件。</p>
<pre><code>--log-file-qualifier=&lt;VAR&gt;
</code></pre>
<p>当和–log-file一起使用时，日志文件名将通过环境变量$VAR来筛选。这对于MPI程序是有益的。更多的细节，查看手册2.3节 “注解”。</p>
<pre><code>--log-socket=&lt;ip-address:port-number&gt;
</code></pre>
<p>指定Valgrind输出所有的消息到指定的IP，指定的端口。当使用1500端口时，端口有可能被忽略。如果不能建立一个到指定端口的连接，Valgrind将输出写到标准错误(stderr)。这个选项经常和一个Valgrind监听程序一起使用。更多的细节，查看手册2.3节 “注解”。</p>
<h2 id="错误相关选项">错误相关选项：<a hidden class="anchor" aria-hidden="true" href="#错误相关选项">#</a></h2>
<p>这些选项适用于所有产生错误的工具，比如Memcheck, 但是Cachegrind不行。</p>
<pre><code>--xml=&lt;yes|no&gt; [default: no]
</code></pre>
<p>当这个选项打开时，输出将是XML格式。这是为了使用Valgrind的输出做为输入的工具，例如GUI前端更加容易些。目前这个选项只在Memcheck时生效。</p>
<pre><code>--xml-user-comment=&lt;string&gt;
</code></pre>
<p>在XML开头 附加用户注释，仅在指定了–xml=yes时生效，否则忽略。</p>
<pre><code>--demangle=&lt;yes|no&gt; [default: yes]
</code></pre>
<p>打开/关闭C++的名字自动解码。默认打开。当打开时，Valgrind将尝试着把编码过的C++名字自动转回初始状态。这个解码器可以处理g++版本为2.X,3.X或4.X生成的符号。一个关于名字编码解码重要的事实是，禁止文件中的解码函数名仍然使用他们未解码的形式。Valgrind在搜寻可用的禁止条目时不对函数名解码，因为这将使禁止文件内容依赖于Valgrind的名字解码机制状态，会使速度变慢，且无意义。</p>
<pre><code>--num-callers=&lt;number&gt; [default: 12]
</code></pre>
<p>默认情况下，Valgrind显示12层函数调用的函数名有助于确定程序的位置。可以通过这个选项来改变这个数字。这样有助在嵌套调用的层次很深时确定程序的位置。注意错误信息通常只回溯到最顶上的4个函数。(当前函数，和它的3个调用者的位置)。所以这并不影响报告的错误总数。这个值的最大值是50。注意高的设置会使Valgrind运行得慢，并且使用更多的内存,但是在嵌套调用层次比较高的程序中非常实用。</p>
<pre><code>--error-limit=&lt;yes|no&gt; [default: yes]
</code></pre>
<p>当这个选项打开时，在总量达到10,000,000，或者1,000个不同的错误，Valgrind停止报告错误。这是为了避免错误跟踪机制在错误很多的程序下变成一个巨大的性能负担。</p>
<pre><code>--error-exitcode=&lt;number&gt; [default: 0]
</code></pre>
<p>指定如果Valgrind在运行过程中报告任何错误时的退出返回值，有两种情况；当设置为默认值(零)时，Valgrind返回的值将是它模拟运行的程序的返回值。当设置为非零值时，如果Valgrind发现任何错误时则返回这个值。在Valgrind做为一个测试工具套件的部分使用时这将非常有用，因为使测试工具套件只检查Valgrind返回值就可以知道哪些测试用例Valgrind报告了错误。</p>
<pre><code>--show-below-main=&lt;yes|no&gt; [default: no]
</code></pre>
<p>默认地，错误时的栈回溯不显示main()之下的任何函数(或者类似的函数像glibc的__libc_start_main()，如果main()没有出现在栈回溯中)；这些大部分都是令人厌倦的C库函数。如果打开这个选项，在main()之下的函数也将会显示。</p>
<pre><code>--suppressions=&lt;filename&gt; [default: $PREFIX/lib/valgrind/default.supp]
</code></pre>
<p>指定一个额外的文件读取不需要理会的错误；你可以根据需要使用任意多的额外文件。</p>
<pre><code>--gen-suppressions=&lt;yes|no|all&gt; [default: no]
</code></pre>
<p>当设置为yes时，Valgrind将会在每个错误显示之后自动暂停并且打印下面这一行：—- Print suppression ? — [Return/N/n/Y/y/C/c] —-这个提示的行为和–db-attach选项(见下面)相同。如果选择是，Valgrind会打印出一个错误的禁止条目，你可以把它剪切然后粘帖到一个文件，如果不希望在将来再看到这个错误信息。当设置为all时，Valgrind会对每一个错误打印一条禁止条目，而不向用户询问。这个选项对C++程序非常有用，它打印出编译器调整过的名字。注意打印出来的禁止条目是尽可能的特定的。如果需要把类似的条目归纳起来，比如在函数名中添加通配符。并且，有些时候两个不同的错误也会产生同样的禁止条目，这时Valgrind就会输出禁止条目不止一次，但是在禁止条目的文件中只需要一份拷贝(但是如果多于一份也不会引起什么问题)。并且，禁止条目的名字像&lt;在这儿输入一个禁止条目的名字&gt;;名字并不是很重要，它只是和-v选项一起使用打印出所有使用的禁止条目记录。</p>
<pre><code>--db-attach=&lt;yes|no&gt; [default: no]
</code></pre>
<p>当这个选项打开时，Valgrind将会在每次打印错误时暂停并打出如下一行：—- Attach to debugger ? — [Return/N/n/Y/y/C/c] —- 按下回车,或者N、回车，n、回车，Valgrind不会对这个错误启动调试器。按下Y、回车，或者y、回车，Valgrind会启动调试器并设定在程序运行的这个点。当调试结束时，退出，程序会继续运行。在调试器内部尝试继续运行程序，将不会生效。按下C、回车，或者c、回车，Valgrind不会启动一个调试器，并且不会再次询问。注意：–db-attach=yes与–trace-children=yes有冲突。你不能同时使用它们。Valgrind在这种情况下不能启动。</p>
<pre><code>--db-command=&lt;command&gt; [default: gdb -nw %f %p]
</code></pre>
<p>通过–db-attach指定如何使用调试器。默认的调试器是gdb.默认的选项是一个运行时扩展Valgrind的模板。 %f会用可执行文件的文件名替换，%p会被可执行文件的进程ID替换。</p>
<p>这指定了Valgrind将怎样调用调试器。默认选项不会因为在构造时是否检测到了GDB而改变,通常是/usr/bin/gdb.使用这个命令，你可以指定一些调用其它的调试器来替换。</p>
<p>给出的这个命令字串可以包括一个或多个%p %f扩展。每一个%p实例都被解释成将调试的进程的PID，每一个%f实例都被解释成要调试的进程的可执行文件路径。</p>
<pre><code>--input-fd=&lt;number&gt; [default: 0, stdin]
</code></pre>
<p>使用–db-attach=yes和–gen-suppressions=yes选项，在发现错误时，Valgrind会停下来去读取键盘输入。默认地，从标准输入读取，所以关闭了标准输入的程序会有问题。这个选项允许你指定一个文件描述符来替代标准输入读取。</p>
<pre><code>--max-stackframe=&lt;number&gt; [default: 2000000]
</code></pre>
<p>栈的最大值。如果栈指针的偏移超过这个数量，Valgrind则会认为程序是切换到了另外一个栈执行。如果在程序中有大量的栈分配的数组，你可能需要使用这个选项。valgrind保持对程序栈指针的追踪。如果栈指针的偏移超过了这个数量，Valgrind假定你的程序切换到了另外一个栈，并且Memcheck行为与栈指</p>
<p>针的偏移没有超出这个数量将会不同。通常这种机制运转得很好。然而，如果你的程序在栈上申请了大的结构，这种机制将会表现得愚蠢，并且Memcheck将会报告大量的非法栈内存访问。这个选项允许把这个阀值设置为其它值。应该只在Valgrind的调试输出中显示需要这么做时才使用这个选项。在这种情况下，它会告诉你应该指定的新的阀值。普遍地，在栈中分配大块的内存是一个坏的主意。因为这很容易用光你的栈空间，尤其是在内存受限的系统或者支持大量小堆栈的线程的系统上，因为Memcheck执行的错误检查，对于堆上的数据比对栈上的数据要高效很多。如果你使用这个选项，你可能希望考虑重写代码在堆上分配内存而不是在栈上分配。</p>
<h2 id="malloc相关的选项">MALLOC()相关的选项:<a hidden class="anchor" aria-hidden="true" href="#malloc相关的选项">#</a></h2>
<p>对于使用自有版本的malloc() (例如Memcheck和massif)，下面的选项可以使用。</p>
<pre><code>--alignment=&lt;number&gt; [default: 8]
</code></pre>
<p>默认Valgrind的malloc(),realloc(), 等等，是8字节对齐地址的。这是大部分处理器的标准。然而，一些程序可能假定malloc()等总是返回16字节或更多对齐的内存。提供的数值必须在8和4096区间之内，并且必须是2的幂数。</p>
<h2 id="非通用选项">非通用选项：<a hidden class="anchor" aria-hidden="true" href="#非通用选项">#</a></h2>
<p>这些选项可以用于所有的工具，它们影响Valgrind core的几个特性。大部分人不会用到这些选项。</p>
<pre><code>--run-libc-freeres=&lt;yes|no&gt; [default: yes]
</code></pre>
<p>GNU C库(libc.so)，所有程序共用的，可能会分配一部分内存自已用。通常在程序退出时释放内存并不麻烦 – 这里没什么问题，因为Linux内核在一个进程退出时会回收进程全部的资源，所以这只是会造成速度慢。glibc的作者认识到这样会导致内存检查器，像Valgrind，在退出时检查内存错误的报告glibc的内存泄漏问题，为了避免这个问题，他们提供了一个libc_freeres()例程特别用来让glibc释放分配的所有内存。因此Memcheck在退出时尝试着去运行libc_freeres()。不幸的是，在glibc的一些版本中，libc_freeres是有bug会导致段错误的。这在Red Hat 7.1上有特别声明。所以，提供这个选项来决定是否运行libc_freeres。如果你的程序看起来在Valgrind上运行得很好，但是在退出时发生段错误，你可能需要指定–run-libc-freeres=no来修正，这将可能错误的报告libc.so的内存泄漏。</p>
<pre><code>--sim-hints=hint1,hint2,...
</code></pre>
<p>传递杂凑的提示给Valgrind，轻微的修改模拟行为的非标准或危险方式，可能有助于模拟奇怪的特性。默认没有提示打开。小心使用！目前已知的提示有：</p>
<p>l lax-ioctls: 对ioctl的处理非常不严格，唯一的假定是大小是正确的。不需要在写时缓冲区完全的初始化。没有这个，用大量的奇怪的ioctl命令来使用一些设备驱动将会非常烦人。</p>
<p>l enable-inner:打开某些特殊的效果，当运行的程序是Valgrind自身时。</p>
<p>&ndash;kernel-variant=variant1,variant2,&hellip;
处理系统调用和ioctls在这个平台的默认核心上产生不同的变量。这有助于运行在改进过的内核或者支持非标准的ioctls上。小心使用。如果你不理解这个选项做的是什么那你几乎不需要它。已经知道的变量有：</p>
<p>l bproc: 支持X86平台上的sys_broc系统调用。这是为了运行在BProc，它是标准Linux的一个变种，有时用来构建集群。</p>
<p>&ndash;show-emwarns=&lt;yes|no&gt; [default: no]
当这个选项打开时，Valgrind在一些特定的情况下将对CPU仿真产生警告。通常这些都是不引人注意的。</p>
<p>&ndash;smc-check=&lt;none|stack|all&gt; [default: stack]
这个选项控制Valgrind对自我修改的代码的检测。Valgrind可以不做检测，可以检测栈中自我修改的代码，或者任意地方检测自我修改的代码。注意默认选项是捕捉绝大多数情况，到目前我们了解的情况为止。使用all选项时会极大的降低速度。(但是用none选项运行极少影响速度，因为对大多数程序，非常少的代码被添加到栈中)</p>
<h2 id="调试valgrind选项">调试VALGRIND选项：<a hidden class="anchor" aria-hidden="true" href="#调试valgrind选项">#</a></h2>
<p>还有一些选项是用来调试Valgrind自身的。在运行一般的东西时不应该需要的。如果你希望看到选项列表，使用–help-debug选项。</p>
<h2 id="内存检查选项">内存检查选项：<a hidden class="anchor" aria-hidden="true" href="#内存检查选项">#</a></h2>
<pre><code>--leak-check=&lt;no|summary|yes|full&gt; [default: summary]
</code></pre>
<p>当这个选项打开时，当客户程序结束时查找内存泄漏。内存泄漏意味着有用malloc分配内存块，但是没有用free释放，而且没有指针指向这块内存。这样的内存块永远不能被程序释放，因为没有指针指向它们。如果设置为summary，Valgrind会报告有多少内存泄漏发生了。如果设置为full或yes，Valgrind给出每一个独立的泄漏的详细信息。</p>
<pre><code>--show-reachable=&lt;yes|no&gt; [default: no]
</code></pre>
<p>当这个选项关闭时，内存泄漏检测器只显示没有指针指向的内存块，或者只能找到指向块中间的指针。当这个选项打开时，内存泄漏检测器还报告有指针指向的内存块。这些块是最有可能出现内存泄漏的地方。你的程序可能，至少在原则上，应该在退出前释放这些内存块。这些有指针指向的内存块和没有指针指向的内存块，或者只有内部指针指向的块，都可能产生内存泄漏，因为实际上没有一个指向块起始的指针可以拿来释放，即使你想去释放它。</p>
<pre><code>--leak-resolution=&lt;low|med|high&gt; [default: low]
</code></pre>
<p>在做内存泄漏检查时，确定memcheck将怎么样考虑不同的栈是相同的情况。当设置为low时，只需要前两层栈匹配就认为是相同的情况；当设置为med，必须要四层栈匹配，当设置为high时，所有层次的栈都必须匹配。对于hardcore内存泄漏检查，你很可能需要使用–leak-resolution=high和–num-callers=40或者更大的数字。注意这将产生巨量的信息，这就是为什么默认选项是四个调用者匹配和低分辨率的匹配。注意–leak-resolution= 设置并不影响memcheck查找内存泄漏的能力。它只是改变了结果如何输出。</p>
<pre><code>--freelist-vol=&lt;number&gt; [default: 5000000]
</code></pre>
<p>当客户程序使用free(C中)或者delete(C++)释放内存时，这些内存并不是马上就可以用来再分配的。这些内存将被标记为不可访问的，并被放到一个已释放内存的队列中。这样做的目的是，使释放的内存再次被利用的点尽可能的晚。这有利于memcheck在内存块释放后这段重要的时间检查对块不合法的访问。这个选项指定了队列所能容纳的内存总容量，以字节为单位。默认的值是5000000字节。增大这个数目会增加memcheck使用的内存，但同时也增加了对已释放内存的非法使用的检测概率。</p>
<pre><code>--workaround-gcc296-bugs=&lt;yes|no&gt; [default: no]
</code></pre>
<p>当这个选项打开时，假定读写栈指针以下的一小段距离是gcc 2.96的bug，并且不报告为错误。距离默认为256字节。注意gcc 2.96是一些比较老的Linux发行版(RedHat 7.X)的默认编译器，所以你可能需要使用这个选项。如果不是必要请不要使用这个选项，它可能会使一些真正的错误溜掉。一个更好的解决办法是使用较新的，修正了这个bug的gcc/g++版本。</p>
<pre><code>--partial-loads-ok=&lt;yes|no&gt; [default: no]
</code></pre>
<p>控制memcheck如何处理从地址读取时字长度，字对齐，因此哪些字节是可以寻址的，哪些是不可以寻址的。当设置为yes是，这样的读取并不抛出一个寻址错误。而是从非法地址读取的V字节显示为未定义，访问合法地址仍然是像平常一样映射到内存。设置为no时，从部分错误的地址读取与从完全错误的地址读取同样处理：抛出一个非法地址错误，结果的V字节显示为合法数据。注意这种代码行为是违背ISO C/C++标准，应该被认为是有问题的。如果可能，这种代码应该修正。这个选项应该只是做为一个最后考虑的方法。</p>
<pre><code>--undef-value-errors=&lt;yes|no&gt; [default: yes]
</code></pre>
<p>控制memcheck是否检查未定义值的危险使用。当设为yes时，Memcheck的行为像Addrcheck, 一个轻量级的内存检查工具，是Valgrind的一个部分，它并不检查未定义值的错误。使用这个选项，如果你不希望看到未定义值错误。</p>
<h2 id="cachegrind选项">CACHEGRIND选项：<a hidden class="anchor" aria-hidden="true" href="#cachegrind选项">#</a></h2>
<p>手动指定I1/D1/L2缓冲配置，大小是用字节表示的。这三个必须用逗号隔开，中间没有空格，例如： valgrind –tool=cachegrind –I1=65535,2,64你可以指定一个，两个或三个I1/D1/L2缓冲。如果没有手动指定，每个级别使用普通方式(通过CPUID指令得到缓冲配置，如果失败，使用默认值)得到的配置。</p>
<pre><code>--I1=&lt;size&gt;,&lt;associativity&gt;,&lt;line size&gt;
</code></pre>
<p>指定第一级指令缓冲的大小，关联度和行大小。</p>
<pre><code>--D1=&lt;size&gt;,&lt;associativity&gt;,&lt;line size&gt;
</code></pre>
<p>指定第一级数据缓冲的大小，关联度和行大小。</p>
<pre><code>--L2=&lt;size&gt;,&lt;associativity&gt;,&lt;line size&gt;
</code></pre>
<p>指定第二级缓冲的大小，关联度和行大小。</p>
<h2 id="callgrind选项">CALLGRIND选项：<a hidden class="anchor" aria-hidden="true" href="#callgrind选项">#</a></h2>
<pre><code>--heap=&lt;yes|no&gt; [default: yes]
</code></pre>
<p>当这个选项打开时，详细的追踪堆的使用情况。关闭这个选项时，massif.pid.txt或massif.pid.html将会非常的简短。</p>
<pre><code>--heap-admin=&lt;number&gt; [default: 8]
</code></pre>
<p>每个块使用的管理字节数。这只能使用一个平均的估计值，因为它可能变化。glibc使用的分配器每块需要4~15字节，依赖于各方面的因素。管理已经释放的块也需要空间，尽管massif不计算这些。</p>
<pre><code>--stacks=&lt;yes|no&gt; [default: yes]
</code></pre>
<p>当打开时，在剖析信息中包含栈信息。多线程的程序可能有多个栈。</p>
<pre><code>--depth=&lt;number&gt; [default: 3]
</code></pre>
<p>详细的堆信息中调用过程的深度。增加这个值可以给出更多的信息，但是massif会更使这个程序运行得慢，使用更多的内存，并且产生一个大的massif.pid.txt或者massif.pid.hp文件。</p>
<pre><code>--alloc-fn=&lt;name&gt;
</code></pre>
<p>指定一个分配内存的函数。这对于使用malloc()的包装函数是有用的，可以用它来填充原来无效的上下文信息。(这些函数会给出无用的上下文信息，并在图中给出无意义的区域)。指定的函数在上下文中被忽略，例如，像对malloc()一样处理。这个选项可以在命令行中重复多次，指定多个函数。</p>
<pre><code>--format=&lt;text|html&gt; [default: text]
</code></pre>
<p>产生text或者HTML格式的详细堆信息，文件的后缀名使用.txt或者.html。</p>
<h2 id="helgrind选项">HELGRIND选项：<a hidden class="anchor" aria-hidden="true" href="#helgrind选项">#</a></h2>
<pre><code>--private-stacks=&lt;yes|no&gt; [default: no]
</code></pre>
<p>假定线程栈是私有的。</p>
<pre><code>--show-last-access=&lt;yes|some|no&gt; [default: no]
</code></pre>
<p>显示最后一次字访问出错的位置。</p>
<h2 id="lackey选项">LACKEY选项：<a hidden class="anchor" aria-hidden="true" href="#lackey选项">#</a></h2>
<pre><code>--fnname=&lt;name&gt; [default: _dl_runtime_resolve()]
</code></pre>
<p>对函数计数。</p>
<pre><code>--detailed-counts=&lt;no|yes&gt; [default: no]
</code></pre>
<p>对读取，存储和alu操作计数。</p>
<p>参考：<a href="">http://www.cnblogs.com/jiu0821/p/6412669.html</a></p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
