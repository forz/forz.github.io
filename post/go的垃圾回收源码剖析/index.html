<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go的垃圾回收源码剖析 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="垃圾分类 垃圾分为以下两类: 语义垃圾(semantic garbage)—有的被称作内存泄露 语义垃圾指的是从语法上可达(可以通过局部、全局变量引" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.92.0 with theme even" />


<link rel="canonical" href="/post/go%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go的垃圾回收源码剖析" />
<meta property="og:description" content="垃圾分类 垃圾分为以下两类: 语义垃圾(semantic garbage)—有的被称作内存泄露 语义垃圾指的是从语法上可达(可以通过局部、全局变量引" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-11-30T14:52:24+00:00" />
<meta property="article:modified_time" content="2020-11-30T14:52:24+00:00" />

<meta itemprop="name" content="Go的垃圾回收源码剖析">
<meta itemprop="description" content="垃圾分类 垃圾分为以下两类: 语义垃圾(semantic garbage)—有的被称作内存泄露 语义垃圾指的是从语法上可达(可以通过局部、全局变量引"><meta itemprop="datePublished" content="2020-11-30T14:52:24+00:00" />
<meta itemprop="dateModified" content="2020-11-30T14:52:24+00:00" />
<meta itemprop="wordCount" content="47757">
<meta itemprop="keywords" content="Go源码," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go的垃圾回收源码剖析"/>
<meta name="twitter:description" content="垃圾分类 垃圾分为以下两类: 语义垃圾(semantic garbage)—有的被称作内存泄露 语义垃圾指的是从语法上可达(可以通过局部、全局变量引"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go的垃圾回收源码剖析</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-11-30 </span>
        <div class="post-category">
            <a href="/categories/go%E6%BA%90%E7%A0%81/"> Go源码 </a>
            </div>
          <span class="more-meta"> 约 47757 字 </span>
          <span class="more-meta"> 预计阅读 96 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#垃圾分类">垃圾分类</a></li>
    <li><a href="#设计理念">设计理念</a></li>
    <li><a href="#三色抽象">三色抽象</a></li>
    <li><a href="#屏障技术">屏障技术</a>
      <ul>
        <li><a href="#插入写屏障">插入写屏障</a></li>
        <li><a href="#删除写屏障">删除写屏障</a></li>
        <li><a href="#写屏障对比">写屏障对比</a></li>
        <li><a href="#混合写屏障">混合写屏障</a></li>
      </ul>
    </li>
    <li><a href="#增量和并发">增量和并发</a>
      <ul>
        <li><a href="#增量收集器">增量收集器</a></li>
        <li><a href="#并发收集器">并发收集器</a></li>
      </ul>
    </li>
    <li><a href="#调步算法">调步算法</a></li>
    <li><a href="#源码分析">源码分析</a>
      <ul>
        <li><a href="#流程图">流程图</a></li>
        <li><a href="#全局变量">全局变量</a></li>
        <li><a href="#根对象">根对象</a></li>
        <li><a href="#触发时机">触发时机</a></li>
        <li><a href="#垃圾收集启动gcstart">垃圾收集启动:gcStart</a></li>
        <li><a href="#并发扫描与标记辅助">并发扫描与标记辅助</a></li>
        <li><a href="#标记终止-gcmarkdone">标记终止: gcMarkDone</a></li>
        <li><a href="#内存清理">内存清理</a></li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="垃圾分类">垃圾分类</h2>
<p>垃圾分为以下两类:</p>
<ul>
<li>语义垃圾(semantic garbage)—有的被称作内存泄露 语义垃圾指的是从语法上可达(可以通过局部、全局变量引用 得到)的对象，但从语义上来讲他们是垃圾，垃圾回收器对此 无能为力。</li>
<li>语法垃圾(syntactic garbage) 语法垃圾是讲那些从语法上无法到达的对象，这些才是垃圾收集器主要的收集目标。</li>
</ul>
<p>语法垃圾:</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210812214439.png" alt=""></p>
<p>在 allocOnHeap 返回后， 堆上的 a 无法访问 便成为了语法垃圾.</p>
<h2 id="设计理念">设计理念</h2>
<p>Go 实现的垃圾回收器是无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法。 从宏观的角度来看，Go 运行时的垃圾回收器主要包含五个阶段：</p>
<ol>
<li>清理终止阶段(STW):为下一个阶段的并发标记做准备工作，启动写屏障；
<ol>
<li>暂停程序，所有的处理器在这时会进入安全点（Safe point）；</li>
<li>如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元；</li>
</ol>
</li>
<li>标记阶段(并发):与赋值器并发执行，写屏障处于开启状态；
<ol>
<li>将状态切换至 _GCmark、开启写屏障、用户程序协助（Mutator Assiste）并将根对象入队；</li>
<li>恢复执行程序，标记进程和用于协助的用户程序会开始并发标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色；</li>
<li>开始扫描根对象，包括所有 Goroutine 的栈、全局对象以及不在堆中的运行时数据结构，扫描 Goroutine 栈期间会暂停当前处理器；</li>
<li>依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；</li>
<li>使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段；</li>
</ol>
</li>
<li>标记终止阶段(STW):保证一个周期内标记任务完成，停止写屏障；
<ol>
<li>暂停程序、将状态切换至_GCmarktermination 并关闭辅助标记的用户程序；</li>
<li>清理处理器上的线程缓存；</li>
</ol>
</li>
<li>清理阶段(并发):将需要回收的内存归还到堆中，写屏障处于关闭状态；
<ol>
<li>将状态切换至 _GCoff 开始清理阶段，初始化清理状态并关闭写屏障；</li>
<li>恢复用户程序，所有新创建的对象会标记成白色；</li>
<li>后台并发清理所有的内存管理单元，当 Goroutine 申请新的内存管理单元时就会触发清理；</li>
</ol>
</li>
<li>内存归还(并发):将过多的内存归还给操作系统，写屏障处于关闭状态</li>
</ol>
<p>GC流程图:</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210812215006.png" alt=""></p>
<ul>
<li>Stack scan：收集根对象（全局变量，和G stack），开启写屏障。全局变量、开启写屏障需要STW，G stack只需要停止该G就好，时间比较少。</li>
<li>Mark: 扫描所有根对象, 和根对象可以到达的所有对象, 标记它们不被回收</li>
<li>Mark Termination: 完成标记工作, 重新扫描部分根对象(要求STW)</li>
<li>Sweep: 按标记结果清扫span</li>
</ul>
<p>需要注意的是, 不是所有根对象的扫描都需要STW, 例如扫描栈上的对象只需要停止拥有该栈的G.</p>
<p>对象整理的优势是解决内存碎片问题以及“允许”使用顺序内存分配器。 但 Go 运行时的分配算法基于 tcmalloc，基本上没有碎片问题。 并且顺序内存分配器在多线程的场景下并不适用。 Go 使用的是基于 tcmalloc 的现代内存分配算法，对对象进行整理不会带来实质性的性能提升。</p>
<p>在这五个阶段中，只有标记、内存清扫和内存归还三个阶段的写屏障状态是保持不变的。 在清扫终止过程中，写屏障先出于关闭状态， 而后对上个垃圾回收阶段进行一些收尾工作（例如清理缓存池、停止调度器等等）， 然后才被启动；在标记终止阶段，写屏障先出于启动状态，完成标记阶段的收尾工作后， 写屏障被关闭，并随后对整个 GC 阶段进行的各项数据进行统计等等收尾工作。 而在实际实现过程中，垃圾回收器通过 _GCoff、_GCMark 和 _GCMarktermination 三个标记来确定写屏障状态，这时写屏障的启动状态严格的在_GCoff 到 _GCMark 到_GCMarktermination 再到 _GCoff 的切换中进行变化。</p>
<p>分代 GC 依赖分代假设，即 GC 将主要的回收目标放在新创建的对象上（存活时间短，更倾向于被回收）， 而非频繁检查所有对象。但 Go 的编译器会通过逃逸分析将大部分新生对象存储在栈上（栈直接被回收）， 只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。 也就是说，分代 GC 回收的那些存活时间短的对象在 Go 中是直接被分配到栈上， 当 goroutine 死亡后栈也会被直接回收，不需要 GC 的参与，进而分代假设并没有带来直接优势。 并且 Go 的垃圾回收器与用户代码并发执行，使得 STW 的时间与对象的代际、对象的 size 没有关系。 Go 团队更关注于如何更好地让 GC 与用户代码并发执行（使用适当的 CPU 来执行垃圾回收）， 而非减少停顿时间这一单一目标上。</p>
<h2 id="三色抽象">三色抽象</h2>
<p>三色抽象只是一种描述追踪式回收器的方法，在实践中并没有实际含义， 它的重要作用在于从逻辑上严密推导标记清理这种垃圾回收方法的正确性。 也就是说，当我们谈及三色标记法时，通常指标记清扫的垃圾回收。</p>
<p>从垃圾回收器的视角来看，三色抽象规定了三种不同类型的对象，并用不同的颜色相称：</p>
<ul>
<li>白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。</li>
<li>灰色对象（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。</li>
<li>黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。</li>
</ul>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201130153123.png" alt=""></p>
<p>这样三种不变性所定义的回收过程其实是一个 波面（Wavefront） 不断前进的过程， 这个波面同时也是黑色对象和白色对象的边界，灰色对象就是这个波面。</p>
<p>当垃圾回收开始时，只有白色对象。随着标记过程开始进行时，灰色对象开始出现（着色），这时候波面便开始扩大。当一个对象的所有子节点均完成扫描时，会被着色为黑色。当整个堆遍历完成时，只剩下黑色和白色对象，这时的黑色对象为可达对象，即存活；而白色对象为不可达对象，即死亡。这个过程可以视为以灰色对象为波面，将黑色对象和白色对象分离，使波面不断向前推进，直到所有可达的灰色对象都变为黑色对象为止的过程.</p>
<p>对象的三种颜色可以这样来判断：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">isWhite</span><span class="p">(</span><span class="nx">ref</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">!</span><span class="nf">isMarked</span><span class="p">(</span><span class="nx">ref</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">isGrey</span><span class="p">(</span><span class="nx">ref</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">worklist</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="nx">ref</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">isBlack</span><span class="p">(</span><span class="nx">ref</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">isMarked</span><span class="p">(</span><span class="nx">ref</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">isGrey</span><span class="p">(</span><span class="nx">ref</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在垃圾收集器开始工作时，程序中不存在任何的黑色对象，垃圾收集的根对象会被标记成灰色，垃圾收集器只会从灰色对象集合中取出对象开始扫描，当灰色集合中不存在任何对象时，标记阶段就会结束。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201130172557.png" alt=""></p>
<p>三色标记垃圾收集器的工作原理很简单，我们可以将其归纳成以下几个步骤：</p>
<ol>
<li>从灰色对象的集合中选择一个灰色对象并将其标记成黑色；</li>
<li>将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；</li>
<li>重复上述两个步骤直到对象图中不存在灰色对象；</li>
</ol>
<p>当三色的标记清除的标记阶段结束之后，应用程序的堆中就不存在任何的灰色对象，我们只能看到黑色的存活对象以及白色的垃圾对象，垃圾收集器可以回收这些白色的垃圾，下面是使用三色标记垃圾收集器执行标记后的堆内存，堆中只有对象 D 为待回收的垃圾：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201130172708.png" alt=""></p>
<p>因为用户程序可能在标记执行的过程中修改对象的指针，所以三色标记清除算法本身是不可以并发或者增量执行的，它仍然需要 STW，在如下所示的三色标记过程中，用户程序建立了从 A 对象到 D 对象的引用，但是因为程序中已经不存在灰色对象了，所以 D 对象会被垃圾收集器错误地回收。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201130172858.png" alt=""></p>
<p>本来不应该被回收的对象却被回收了，这在内存管理中是非常严重的错误，我们将这种错误称为悬挂指针，即指针没有指向特定类型的合法对象，影响了内存的安全性，想要并发或者增量地标记对象还是需要使用屏障技术。</p>
<p>有黑、灰、白三个集合，每种颜色的含义：</p>
<p>白色：对象未被标记，gcmarkBits对应的位为0</p>
<p>灰色：对象已被标记，但这个对象包含的子对象未标记，gcmarkBits对应的位为1</p>
<p>黑色：对象已被标记，且这个对象包含的子对象也已标记，gcmarkBits对应的位为1</p>
<p>灰色和黑色的gcmarkBits都是1，如何区分二者呢？</p>
<p>标记任务有标记队列，在标记队列中的是灰色，不在标记队里中的是黑色。标记过程见下图：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201215145230.png" alt="">
<img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201215145235.png" alt=""></p>
<p>上图中根对象A是栈上分配的对象,H是堆中分配的全局变量，根对象A、H内部有分别引用了其他对象，而其他对象内部可能还引用其他对象，各个对象见的关系如上图所示。</p>
<ol>
<li>初始状态下所有对象都是白色的。</li>
<li>接着开始扫描根对象，A、H是根对象所以被扫描到，A，H变为灰色对象。</li>
<li>接下来就开始扫描灰色对象，通过A到达B，B被标注灰色，A扫描结束后被标注黑色。同理J，K都被标注灰色，H被标注黑色。</li>
<li>继续扫描灰色对象，通过B到达C，C 被标注灰色，B被标注黑色，因为J,K没有引用对象，J,K标注黑色结束</li>
<li>最终，黑色的对象会被保留下来，白色对象D,E,F会被回收掉。</li>
</ol>
<h2 id="屏障技术">屏障技术</h2>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201215145709.png" alt=""></p>
<p>上图，假如B对象变黑后，又给B指向对象G，因为这个时候G对象已经扫描过了，所以G 对象还是白色，会被误回收。怎么解决这个问题呢？</p>
<p>最简单的方法就是STW(stop the world)。也就是说，停止所有的协程。这个方法比较暴力会引起程序的卡顿，并不友好。让GC回收器,满足下面两种情况之一时,可保对象不丢失. 所以引出强-弱三色不变式：</p>
<p>内存屏障技术是一种屏障指令，它可以让 CPU 或者编译器在执行内存相关操作时遵循特定的约束，目前的多数的现代处理器都会乱序执行指令以最大化性能，但是该技术能够保证代码对内存操作的顺序性，在内存屏障前执行的操作一定会先于内存屏障后执行的操作。</p>
<p>想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的任意一种：</p>
<ul>
<li>强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；</li>
<li>弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径；</li>
</ul>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201130173312.png" alt=""></p>
<p>上图分别展示了遵循强三色不变性和弱三色不变性的堆内存，遵循上述两个不变性中的任意一个，我们都能保证垃圾收集算法的正确性，而屏障技术就是在并发或者增量标记过程中保证三色不变性的重要技术。</p>
<p>垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性。</p>
<p>我们在这里想要介绍的是 Go 语言中使用的两种写屏障技术，分别是 Dijkstra 提出的插入写屏障和 Yuasa 提出的删除写屏障，这里会分析它们如何保证三色不变性和垃圾收集器的正确性。</p>
<h3 id="插入写屏障">插入写屏障</h3>
<p>Dijkstra 在 1978 年提出了插入写屏障，通过如下所示的写屏障，用户程序和垃圾收集器可以在交替工作的情况下保证程序执行的正确性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 灰色赋值器 Dijkstra 插入屏障
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DijkstraWritePointer</span><span class="p">(</span><span class="nx">slot</span> <span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">ptr</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">shade</span><span class="p">(</span><span class="nx">ptr</span><span class="p">)</span>
    <span class="o">*</span><span class="nx">slot</span> <span class="p">=</span> <span class="nx">ptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Slot 是 Go 代码里的被修改的指针对象</li>
<li>Ptr 是 Slot 要修改成的值</li>
</ul>
<p>上述插入写屏障的伪代码非常好理解，每当我们执行类似 *slot = ptr 的表达式时，我们会执行上述写屏障通过 shade 函数尝试改变指针的颜色。如果 ptr 指针是白色的，那么该函数会将该对象设置成灰色，其他情况则保持不变。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201130174441.png" alt=""></p>
<p>假设我们在应用程序中使用 Dijkstra 提出的插入写屏障，在一个垃圾收集器和用户程序交替运行的场景中会出现如上图所示的标记过程：</p>
<ol>
<li>垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；</li>
<li>用户程序修改 A 对象的指针，将原本指向 B 对象的指针指向 C 对象，这时触发写屏障将 C 对象标记成灰色；</li>
<li>垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色；</li>
</ol>
<p>Dijkstra 的插入写屏障是一种相对保守的屏障技术，它会将有存活可能的对象都标记成灰色以满足强三色不变性。在如上所示的垃圾收集过程中，实际上不再存活的 B 对象最后没有被回收；而如果我们在第二和第三步之间将指向 C 对象的指针改回指向 B，垃圾收集器仍然认为 C 对象是存活的，这些被错误标记的垃圾对象只有在下一个循环才会被回收。</p>
<p>在 Go 语言 v1.7 版本之前，运行时会使用 Dijkstra 插入写屏障保证强三色不变性，但是运行时并没有在所有的垃圾收集根对象上开启插入写屏障。因为 Go 语言的应用程序可能包含成百上千的 Goroutine，而垃圾收集的根对象一般包括全局变量和栈对象，如果运行时需要在几百个 Goroutine 的栈上都开启写屏障，会带来巨大的额外开销，所以 Go 团队在实现上选择了在标记阶段完成时暂停程序、将所有栈对象标记为灰色并重新扫描，在活跃 Goroutine 非常多的程序中，重新扫描的过程需要占用 10 ~ 100ms 的时间。</p>
<p>黑色对象的内存槽有两种位置, 栈和堆. 栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以“插入屏障”机制,在栈空间的对象操作中不使用. 而仅仅使用在堆空间对象的操作中。</p>
<p>插入式的 Dijkstra 写屏障虽然实现非常简单并且也能保证强三色不变性，但是它也有很明显的缺点。因为栈上的对象在垃圾收集中也会被认为是根对象，所以为了保证内存的安全，Dijkstra 在标记阶段完成重新对栈上的对象进行扫描，重新扫描栈对象时需要暂停程序,这个自然就会导致整个进程的赋值器卡顿，</p>
<h3 id="删除写屏障">删除写屏障</h3>
<p>删除写屏障也叫基于快照的写屏障方案，必须在起始时，STW 扫描整个栈（注意了，是所有的 goroutine 栈），保证所有堆上在用的对象都处于灰色保护下，保证的是弱三色不变式；</p>
<p>该算法会使用如下所示的写屏障保证增量或者并发执行垃圾收集时程序的正确性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 黑色赋值器 Yuasa 屏障
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">YuasaWritePointer</span><span class="p">(</span><span class="nx">slot</span> <span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">ptr</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">shade</span><span class="p">(</span><span class="o">*</span><span class="nx">slot</span><span class="p">)</span>
    <span class="o">*</span><span class="nx">slot</span> <span class="p">=</span> <span class="nx">ptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码会在老对象的引用被删除时，将白色的老对象涂成灰色，这样删除写屏障就可以保证弱三色不变性，老对象引用的下游对象一定可以被灰色对象引用。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201130174940.png" alt=""></p>
<p>假设我们在应用程序中使用 Yuasa 提出的删除写屏障，在一个垃圾收集器和用户程序交替运行的场景中会出现如上图所示的标记过程：</p>
<ol>
<li>垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；</li>
<li>用户程序将 A 对象原本指向 B 的指针指向 C，触发删除写屏障，但是因为 B 对象已经是灰色的，所以不做改变；</li>
<li>用户程序将 B 对象原本指向 C 的指针删除，触发删除写屏障，白色的 C 对象被涂成灰色；</li>
<li>垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色；</li>
</ol>
<p>上述过程中的第三步触发了 Yuasa 删除写屏障的着色，因为用户程序删除了 B 指向 C 对象的指针，所以 C 和 D 两个对象会分别违反强三色不变性和弱三色不变性：</p>
<ul>
<li>强三色不变性 — 黑色的 A 对象直接指向白色的 C 对象；</li>
<li>弱三色不变性 — 垃圾收集器无法从某个灰色对象出发，经过几个连续的白色对象访问白色的 C 和 D 两个对象；</li>
</ul>
<p>Yuasa 删除写屏障通过对 C 对象的着色，保证了 C 对象和下游的 D 对象能够在这一次垃圾收集的循环中存活，避免发生悬挂指针以保证用户程序的正确性。</p>
<p>由于起始快照的原因，起始也是执行 STW，删除写屏障不适用于栈特别大的场景，栈越大，STW 扫描时间越长，对于现代服务器上的程序来说，栈地址空间都很大，所以删除写屏障都不适用，一般适用于很小的栈内存，比如嵌入式，物联网的一些程序；</p>
<p>并且删除写屏障会导致扫描进度（波面）的后退，所以扫描精度不如插入写屏障；</p>
<p>思考问题：我不整机暂停 STW 栈，而是一个栈一个栈的快照，这样也没有 STW 了，是否可以满足要求？（这个就是当前 golang 混合写屏障的时候做的哈，虽然没有 STW 了，但是扫描到某一个具体的栈的时候，还是要暂停这一个 goroutine 的）</p>
<p>不行，纯粹的删除写屏障，起始必须整个栈打快照，要把所有的堆对象都处于灰色保护中才行。</p>
<p>举例：如果没有把栈完全扫黑，那么可能出现丢数据，如下：</p>
<p>初始状态：</p>
<ol>
<li>A 是 g1 栈的一个对象，g1栈已经扫描完了，并且 C 也是扫黑了的对象；</li>
<li>B 是 g2 栈的对象，指向了  C 和 D，g2 完全还没扫描，B 是一个灰色对象，D 是白色对象；</li>
</ol>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201227153353.png" alt=""></p>
<p>步骤一：g2 进行赋值变更，把 C 指向 D 对象，这个时候黑色的 C 就指向了白色的 D（由于是删除屏障，这里是不会触发hook的）</p>
<p>步骤二：把 B 指向 C 的引用删除，由于是栈对象操作，不会触发删除写屏障；</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201227160658.png" alt=""></p>
<p>步骤三：清理，因为 C 已经是黑色对象了，所以不会再扫描，所以 D 就会被错误的清理掉。</p>
<p>解决办法有如下：</p>
<p>方法一：栈上对象也 hook，所有对象赋值（插入，删除）都 hook（这个就不实际了）;</p>
<p>所有的插入，删除如果都 hook ，那么一定都不会有问题，虽然本轮精度很差，但是下轮回收可以回收了。但是还是那句话，栈，寄存器的赋值 hook 是不现实的。</p>
<p>方法二：起始快照整栈跨找，扫黑，使得整个堆上的在用对象都处于灰色保护；</p>
<p>整栈扫黑，那么在用的堆上的对象是一定处于灰色堆对象的保护下的，之后配合堆对象删除写屏障就能保证在用对象不丢失。</p>
<p>方法三：加入插入写屏障的逻辑，C 指向 D 的时候，把 D 置灰，这样扫描也没问题。这样就能去掉起始 STW 扫描，从而可以并发，一个一个栈扫描。这就成了当前在用的混合写屏障了</p>
<h3 id="写屏障对比">写屏障对比</h3>
<p>Dijkstra insertion barrier</p>
<p>优点:</p>
<ul>
<li>能够保证堆上对象的强三色不变性(无栈对象参与时)</li>
<li>能防止指针从栈被隐藏进堆(因为堆上新建的连接都会被着色)</li>
</ul>
<p>缺点:</p>
<ul>
<li>不能防止栈上的黑色对象指向堆上的白色对象(这个白色对象之前是被堆上的黑/灰指着的)</li>
<li>所以在mark结束后需要stw重新扫描所有 goroutine 栈</li>
</ul>
<p>Yuasa deletion barrier</p>
<p>优点:</p>
<ul>
<li>能够保证堆上的弱三色不变性(无栈对象参与时)</li>
<li>能防止指针从堆被隐藏进栈(因为堆上断开的连接都会被着色)</li>
</ul>
<p>缺点:</p>
<ul>
<li>不能防止堆上的黑色对象指向堆上的白色对象(这个白色对象之前是由栈的黑/灰色对象指着的)</li>
<li>所以需要 GC 开始时 STW 对栈做快照</li>
</ul>
<h3 id="混合写屏障">混合写屏障</h3>
<p>Go 语言在 v1.8 组合 Dijkstra 插入写屏障和 Yuasa 删除写屏障构成了如下所示的混合写屏障，该写屏障会将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">writePointer</span><span class="p">(</span><span class="nx">slot</span><span class="p">,</span> <span class="nx">ptr</span><span class="p">):</span>
    <span class="nf">shade</span><span class="p">(</span><span class="o">*</span><span class="nx">slot</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">current</span> <span class="nx">stack</span> <span class="nx">is</span> <span class="nx">grey</span><span class="p">:</span>
        <span class="nf">shade</span><span class="p">(</span><span class="nx">ptr</span><span class="p">)</span>
    <span class="o">*</span><span class="nx">slot</span> <span class="p">=</span> <span class="nx">ptr</span>
</code></pre></td></tr></table>
</div>
</div><p>后来Go语言团队认为 stack check 成本太高,至少要进行一次atomic操作,实际上在Go语言是如此实现的:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">writePointer</span><span class="p">(</span><span class="nx">slot</span><span class="p">,</span> <span class="nx">ptr</span><span class="p">):</span>
    <span class="nf">shade</span><span class="p">(</span><span class="o">*</span><span class="nx">slot</span><span class="p">)</span>
    <span class="nf">shade</span><span class="p">(</span><span class="nx">ptr</span><span class="p">)</span>
    <span class="o">*</span><span class="nx">slot</span> <span class="p">=</span> <span class="nx">ptr</span>
</code></pre></td></tr></table>
</div>
</div><p>混合写屏障具体操作:</p>
<ol>
<li>
<p>GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，</p>
</li>
<li>
<p>GC期间，任何在栈上创建的新对象，均为黑色。防止新分配的栈内存和堆内存中的对象被错误地回收，因为栈内存在标记阶段最终都会变为黑色，所以不再需要重新扫描栈空间。</p>
</li>
<li>
<p>被删除的对象标记为灰色。</p>
</li>
<li>
<p>被添加的对象标记为灰色。</p>
</li>
</ol>
<p>满足: 变形的弱三色不变式.</p>
<p>上面说到整个GC有两次STW，采用混合屏障后可以大幅压缩第二次STW的时间。</p>
<p>总结：</p>
<ol>
<li>混合写屏障继承了插入写屏障的优点，起始无需 STW 打快照，直接并发扫描垃圾即可；</li>
<li>混合写屏障继承了删除写屏障的优点，赋值器是黑色赋值器，扫描过一次就不需要扫描了，这样就消除了插入写屏障时期最后 STW 的重新扫描栈；</li>
<li>混合写屏障扫描精度继承了删除写屏障，比插入写屏障更低，随着带来的是 GC 过程全程无 STW；</li>
<li>混合写屏障扫描栈虽然没有 STW，但是扫描某一个具体的栈的时候，还是要停止这个 goroutine 赋值器的工作.（针对一个 goroutine 栈来说，是暂停扫的，要么全灰，要么全黑哈，原子状态切换）；</li>
</ol>
<h2 id="增量和并发">增量和并发</h2>
<p>传统的垃圾收集算法会在垃圾收集的执行期间暂停应用程序，一旦触发垃圾收集，垃圾收集器就会抢占 CPU 的使用权占据大量的计算资源以完成标记和清除工作，然而很多追求实时的应用程序无法接受长时间的 STW。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201130175911.png" alt=""></p>
<p>远古时代的计算资源还没有今天这么丰富，今天的计算机往往都是多核的处理器，垃圾收集器一旦开始执行就会浪费大量的计算资源，为了减少应用程序暂停的最长时间和垃圾收集的总暂停时间，我们会使用下面的策略优化现代的垃圾收集器：</p>
<ul>
<li>增量垃圾收集 — 增量地标记和清除垃圾，降低应用程序暂停的最长时间；</li>
<li>并发垃圾收集 — 利用多核的计算资源，在用户程序执行时并发标记和清除垃圾；</li>
</ul>
<p>因为增量和并发两种方式都可以与用户程序交替运行，所以我们需要使用屏障技术保证垃圾收集的正确性；与此同时，应用程序也不能等到内存溢出时触发垃圾收集，因为当内存不足时，应用程序已经无法分配内存，这与直接暂停程序没有什么区别，增量和并发的垃圾收集需要提前触发并在内存不足前完成整个循环，避免程序的长时间暂停。</p>
<h3 id="增量收集器">增量收集器</h3>
<p>增量式（Incremental）的垃圾收集是减少程序最长暂停时间的一种方案，它可以将原本时间较长的暂停时间切分成多个更小的 GC 时间片，虽然从垃圾收集开始到结束的时间更长了，但是这也减少了应用程序暂停的最大时间：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201130181940.png" alt=""></p>
<p>需要注意的是，增量式的垃圾收集需要与三色标记法一起使用，为了保证垃圾收集的正确性，我们需要在垃圾收集开始前打开写屏障，这样用户程序对内存的修改都会先经过写屏障的处理，保证了堆内存中对象关系的强三色不变性或者弱三色不变性。虽然增量式的垃圾收集能够减少最大的程序暂停时间，但是增量式收集也会增加一次 GC 循环的总时间，在垃圾收集期间，因为写屏障的影响用户程序也需要承担额外的计算开销，所以增量式的垃圾收集也不是只有优点的。</p>
<h3 id="并发收集器">并发收集器</h3>
<p>并发（Concurrent）的垃圾收集不仅能够减少程序的最长暂停时间，还能减少整个垃圾收集阶段的时间，通过开启读写屏障、利用多核优势与用户程序并行执行，并发垃圾收集器确实能够减少垃圾收集对应用程序的影响：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201130182040.png" alt=""></p>
<p>虽然并发收集器能够与用户程序一起运行，但是并不是所有阶段都可以与用户程序一起运行，部分阶段还是需要暂停用户程序的，不过与传统的算法相比，并发的垃圾收集可以将能够并发执行的工作尽量并发执行；当然，因为读写屏障的引入，并发的垃圾收集器也一定会带来额外开销，不仅会增加垃圾收集的总时间，还会影响用户程序，这是我们在设计垃圾收集策略时必须要注意的。</p>
<p>Go 语言在 v1.5 中引入了并发的垃圾收集器，该垃圾收集器使用了我们上面提到的三色抽象和写屏障技术保证垃圾收集器执行的正确性，如何实现并发的垃圾收集器在这里就不展开介绍了，我们来了解一些并发垃圾收集器的工作流程。</p>
<p>首先，并发垃圾收集器必须在合适的时间点触发垃圾收集循环，假设我们的 Go 语言程序运行在一台 4 核的物理机上，那么在垃圾收集开始后，收集器会占用 25% 计算资源在后台来扫描并标记内存中的对象：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201130182322.png" alt=""></p>
<p>Go 语言的并发垃圾收集器会在扫描对象之前暂停程序做一些标记对象的准备工作，其中包括启动后台标记的垃圾收集器以及开启写屏障，如果在后台执行的垃圾收集器不够快，应用程序申请内存的速度超过预期，运行时就会让申请内存的应用程序辅助完成垃圾收集的扫描阶段，在标记和标记终止阶段结束之后就会进入异步的清理阶段，将不用的内存增量回收。</p>
<p>v1.5 版本实现的并发垃圾收集策略由专门的 Goroutine 负责在处理器之间同步和协调垃圾收集的状态。当其他的 Goroutine 发现需要触发垃圾收集时，它们需要将该信息通知给负责修改状态的主 Goroutine，然而这个通知的过程会带来一定的延迟，这个延迟的时间窗口很可能是不可控的，用户程序会在这段时间分配界面很多内存空间。</p>
<p>v1.6 引入了去中心化的垃圾收集协调机制，将垃圾收集器变成一个显式的状态机，任意的 Goroutine 都可以调用方法触发状态的迁移，常见的状态迁移方法包括以下几个</p>
<ul>
<li>runtime.gcStart — 从 _GCoff 转换至_GCmark 阶段，进入并发标记阶段并打开写屏障；</li>
<li>runtime.gcMarkDone — 如果所有可达对象都已经完成扫描，调用 runtime.gcMarkTermination；</li>
<li>runtime.gcMarkTermination — 从 _GCmark 转换_GCmarktermination 阶段，进入标记终止阶段并在完成后进入 _GCoff；</li>
</ul>
<h2 id="调步算法">调步算法</h2>
<p>STW 的垃圾收集器虽然需要暂停程序，但是它能够有效地控制堆内存的大小，Go 语言运行时的默认配置会在堆内存达到上一次垃圾收集的 2 倍时，触发新一轮的垃圾收集，这个行为可以通过环境变量 GOGC 调整，在默认情况下它的值为 100，即增长 100% 的堆内存才会触发 GC。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201130183236.png" alt=""></p>
<p>因为并发垃圾收集器会与程序一起运行，所以它无法准确的控制堆内存的大小，并发收集器需要在达到目标前触发垃圾收集，这样才能够保证内存大小的可控，并发收集器需要尽可能保证垃圾收集结束时的堆内存与用户配置的 GOGC 一致。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201130183303.png" alt=""></p>
<p>Go 语言 v1.5 引入并发垃圾收集器的同时使用垃圾收集调步（Pacing）算法计算触发的垃圾收集的最佳时间，确保触发的时间既不会浪费计算资源，也不会超出预期的堆大小。如上图所示，其中黑色的部分是上一次垃圾收集后标记的堆大小，绿色部分是上次垃圾收集结束后新分配的内存，因为我们使用并发垃圾收集，所以黄色的部分就是在垃圾收集期间分配的内存，最后的红色部分是垃圾收集结束时与目标的差值，我们希望尽可能减少红色部分内存，降低垃圾收集带来的额外开销以及程序的暂停时间。</p>
<p>垃圾收集调步算法是跟随 v1.5 一同引入的，该算法的目标是优化堆的增长速度和垃圾收集器的 CPU 利用率，而在 v1.10 版本中又对该算法进行了优化，将原有的目的堆大小拆分成了软硬两个目标.</p>
<p>调步算法包含四个部分：</p>
<ol>
<li>GC 周期所需的扫描估计器</li>
<li>为用户代码根据堆分配到目标堆大小的时间估计扫描工作量的机制</li>
<li>用户代码为未充分利用 CPU 预算时进行后台扫描的调度程序</li>
<li>GC 触发比率的控制器</li>
</ol>
<p>现在我们从两个不同的视角来对这个问题进行建模。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201215105711.png" alt=""></p>
<p>Ht的时候开始GC，Ha的时候结束GC，Ha非常接近Hg。</p>
<p>如何保证在Ht开始gc时所有的span都被清扫完？</p>
<p>除了有一个后台清扫协程外，用户在分配内存时也需要辅助清扫来保证在开启下一轮的gc时span都被清扫完毕。假设有k page的span需要sweep，那么距离下一次gc还有Ht-Hm（n-1）的内存可供分配，那么平均每申请1byte内存需要清扫k/ Ht-Hm（n-1） page 的span。（k值会根据sweep进度更改）</p>
<p>辅助清扫申请新span时才会检查,辅助清扫的触发可以看cacheSpan函数, 触发时G会帮助回收&quot;工作量&quot;页的对象.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">spanBytes</span> <span class="o">*</span> <span class="n">sweepPagesPerByte</span>
</code></pre></td></tr></table>
</div>
</div><p>意思是分配的大小乘以系数sweepPagesPerByte, sweepPagesPerByte的计算在函数gcSetTriggerRatio中.</p>
<p>如何保证在Ha时gc都被mark完?</p>
<p>Gc在Ht开始，在到达Hg时尽量标记完所有的对象，除了后台的标记协程外还需要在分配内存是进行辅助mark。从Ht到Hg的内存可以分配，这个时候还有scanWorkExpected的对象需要scan，那么平均分配1byte内存需要辅助mark量：scanWorkExpected/(Hg-Ht) 个对象，scanWorkExpected会根据mark进度更改。</p>
<p>辅助标记的触发可以查看上面的mallocgc函数, 触发时G会帮助扫描&quot;工作量&quot;个对象, 工作量的计算公式是:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">debtBytes</span> <span class="o">*</span> <span class="n">assistWorkPerByte</span>
</code></pre></td></tr></table>
</div>
</div><p>意思是分配的大小乘以系数assistWorkPerByte, assistWorkPerByte的计算在函数revise中.</p>
<h2 id="源码分析">源码分析</h2>
<h3 id="流程图">流程图</h3>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201215182726.png" alt=""></p>
<p>垃圾回收代码流程</p>
<ul>
<li>gcStart -&gt; gcBgMarkWorker &amp;&amp; gcRootPrepare，这时 gcBgMarkWorker 在休眠中</li>
<li>schedule -&gt; findRunnableGCWorker 唤醒适宜数量的 gcBgMarkWorker</li>
<li>gcBgMarkWorker -&gt; gcDrain -&gt; scanobject -&gt; greyobject(set mark bit and put to gcw)</li>
<li>在 gcBgMarkWorker 中调用 gcMarkDone 排空各种 wbBuf 后，使用分布式 termination 检查算法，进入 gcMarkTermination -&gt; gcSweep 唤醒后台沉睡的 sweepg 和 scvg -&gt; sweep -&gt; wake bgsweep &amp;&amp; bgscavenge</li>
</ul>
<h3 id="全局变量">全局变量</h3>
<p>在垃圾收集中有一些比较重要的全局变量，在分析其过程之前，我们会先逐一介绍这些重要的变量，这些变量在垃圾收集的各个阶段中会反复出现，所以理解他们的功能是非常重要的，我们先介绍一些比较简单的变量：</p>
<ul>
<li>runtime.gcphase 是垃圾收集器当前处于的阶段，可能处于 _GCoff、_GCmark 和 _GCmarktermination，Goroutine 在读取或者修改该阶段时需要保证原子性；</li>
<li>runtime.gcBlackenEnabled 是一个布尔值，当垃圾收集处于标记阶段时，该变量会被置为 1，在这里辅助垃圾收集的用户程序和后台标记的任务可以将对象涂黑；</li>
<li>runtime.gcController 实现了垃圾收集的调步算法，它能够决定触发并行垃圾收集的时间和待处理的工作；</li>
<li>runtime.gcpercent 是触发垃圾收集的内存增长百分比，默认情况下为 100，即堆内存相比上次垃圾收集增长 100% 时应该触发 GC，并行的垃圾收集器会在到达该目标前完成垃圾收集；</li>
<li>runtime.writeBarrier 是一个包含写屏障状态的结构体，其中的 enabled 字段表示写屏障的开启与关闭；</li>
<li>runtime.worldsema 是全局的信号量，获取该信号量的线程有权利暂停当前应用程序；</li>
</ul>
<p>除了上述全局的变量之外，我们在这里还需要简单了解一下 runtime.work 变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">work</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">full</span>  <span class="nx">lfstack</span>          <span class="c1">// lock-free list of full blocks workbuf
</span><span class="c1"></span>	<span class="nx">empty</span> <span class="nx">lfstack</span>          <span class="c1">// lock-free list of empty blocks workbuf
</span><span class="c1"></span>	<span class="nx">pad0</span>  <span class="nx">cpu</span><span class="p">.</span><span class="nx">CacheLinePad</span> <span class="c1">// prevents false-sharing between full/empty and nproc/nwait
</span><span class="c1"></span>
	<span class="nx">wbufSpans</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">lock</span> <span class="nx">mutex</span>
		<span class="c1">// free is a list of spans dedicated to workbufs, but
</span><span class="c1"></span>		<span class="c1">// that don&#39;t currently contain any workbufs.
</span><span class="c1"></span>		<span class="nx">free</span> <span class="nx">mSpanList</span>
		<span class="c1">// busy is a list of all spans containing workbufs on
</span><span class="c1"></span>		<span class="c1">// one of the workbuf lists.
</span><span class="c1"></span>		<span class="nx">busy</span> <span class="nx">mSpanList</span>
	<span class="p">}</span>

	<span class="c1">// Restore 64-bit alignment on 32-bit.
</span><span class="c1"></span>	<span class="nx">_</span> <span class="kt">uint32</span>

	<span class="c1">// bytesMarked is the number of bytes marked this cycle. This
</span><span class="c1"></span>	<span class="c1">// includes bytes blackened in scanned objects, noscan objects
</span><span class="c1"></span>	<span class="c1">// that go straight to black, and permagrey objects scanned by
</span><span class="c1"></span>	<span class="c1">// markroot during the concurrent scan phase. This is updated
</span><span class="c1"></span>	<span class="c1">// atomically during the cycle. Updates may be batched
</span><span class="c1"></span>	<span class="c1">// arbitrarily, since the value is only read at the end of the
</span><span class="c1"></span>	<span class="c1">// cycle.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Because of benign races during marking, this number may not
</span><span class="c1"></span>	<span class="c1">// be the exact number of marked bytes, but it should be very
</span><span class="c1"></span>	<span class="c1">// close.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Put this field here because it needs 64-bit atomic access
</span><span class="c1"></span>	<span class="c1">// (and thus 8-byte alignment even on 32-bit architectures).
</span><span class="c1"></span>	<span class="nx">bytesMarked</span> <span class="kt">uint64</span>

	<span class="nx">markrootNext</span> <span class="kt">uint32</span> <span class="c1">// next markroot job
</span><span class="c1"></span>	<span class="nx">markrootJobs</span> <span class="kt">uint32</span> <span class="c1">// number of markroot jobs
</span><span class="c1"></span>
	<span class="nx">nproc</span>  <span class="kt">uint32</span>
	<span class="nx">tstart</span> <span class="kt">int64</span>
	<span class="nx">nwait</span>  <span class="kt">uint32</span>
	<span class="nx">ndone</span>  <span class="kt">uint32</span>

	<span class="c1">// Number of roots of various root types. Set by gcMarkRootPrepare.
</span><span class="c1"></span>	<span class="nx">nFlushCacheRoots</span>                               <span class="kt">int</span>
	<span class="nx">nDataRoots</span><span class="p">,</span> <span class="nx">nBSSRoots</span><span class="p">,</span> <span class="nx">nSpanRoots</span><span class="p">,</span> <span class="nx">nStackRoots</span> <span class="kt">int</span>

	<span class="c1">// Each type of GC state transition is protected by a lock.
</span><span class="c1"></span>	<span class="c1">// Since multiple threads can simultaneously detect the state
</span><span class="c1"></span>	<span class="c1">// transition condition, any thread that detects a transition
</span><span class="c1"></span>	<span class="c1">// condition must acquire the appropriate transition lock,
</span><span class="c1"></span>	<span class="c1">// re-check the transition condition and return if it no
</span><span class="c1"></span>	<span class="c1">// longer holds or perform the transition if it does.
</span><span class="c1"></span>	<span class="c1">// Likewise, any transition must invalidate the transition
</span><span class="c1"></span>	<span class="c1">// condition before releasing the lock. This ensures that each
</span><span class="c1"></span>	<span class="c1">// transition is performed by exactly one thread and threads
</span><span class="c1"></span>	<span class="c1">// that need the transition to happen block until it has
</span><span class="c1"></span>	<span class="c1">// happened.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// startSema protects the transition from &#34;off&#34; to mark or
</span><span class="c1"></span>	<span class="c1">// mark termination.
</span><span class="c1"></span>	<span class="nx">startSema</span> <span class="kt">uint32</span>
	<span class="c1">// markDoneSema protects transitions from mark to mark termination.
</span><span class="c1"></span>	<span class="nx">markDoneSema</span> <span class="kt">uint32</span>

	<span class="nx">bgMarkReady</span> <span class="nx">note</span>   <span class="c1">// signal background mark worker has started
</span><span class="c1"></span>	<span class="nx">bgMarkDone</span>  <span class="kt">uint32</span> <span class="c1">// cas to 1 when at a background mark completion point
</span><span class="c1"></span>	<span class="c1">// Background mark completion signaling
</span><span class="c1"></span>
	<span class="c1">// mode is the concurrency mode of the current GC cycle.
</span><span class="c1"></span>	<span class="nx">mode</span> <span class="nx">gcMode</span>

	<span class="c1">// userForced indicates the current GC cycle was forced by an
</span><span class="c1"></span>	<span class="c1">// explicit user call.
</span><span class="c1"></span>	<span class="nx">userForced</span> <span class="kt">bool</span>

	<span class="c1">// totaltime is the CPU nanoseconds spent in GC since the
</span><span class="c1"></span>	<span class="c1">// program started if debug.gctrace &gt; 0.
</span><span class="c1"></span>	<span class="nx">totaltime</span> <span class="kt">int64</span>

	<span class="c1">// initialHeapLive is the value of memstats.heap_live at the
</span><span class="c1"></span>	<span class="c1">// beginning of this GC cycle.
</span><span class="c1"></span>	<span class="nx">initialHeapLive</span> <span class="kt">uint64</span>

	<span class="c1">// assistQueue is a queue of assists that are blocked because
</span><span class="c1"></span>	<span class="c1">// there was neither enough credit to steal or enough work to
</span><span class="c1"></span>	<span class="c1">// do.
</span><span class="c1"></span>	<span class="nx">assistQueue</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">lock</span> <span class="nx">mutex</span>
		<span class="nx">q</span>    <span class="nx">gQueue</span>
	<span class="p">}</span>

	<span class="c1">// sweepWaiters is a list of blocked goroutines to wake when
</span><span class="c1"></span>	<span class="c1">// we transition from mark termination to sweep.
</span><span class="c1"></span>	<span class="nx">sweepWaiters</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">lock</span> <span class="nx">mutex</span>
		<span class="nx">list</span> <span class="nx">gList</span>
	<span class="p">}</span>

	<span class="c1">// cycles is the number of completed GC cycles, where a GC
</span><span class="c1"></span>	<span class="c1">// cycle is sweep termination, mark, mark termination, and
</span><span class="c1"></span>	<span class="c1">// sweep. This differs from memstats.numgc, which is
</span><span class="c1"></span>	<span class="c1">// incremented at mark termination.
</span><span class="c1"></span>	<span class="nx">cycles</span> <span class="kt">uint32</span>

	<span class="c1">// Timing/utilization stats for this cycle.
</span><span class="c1"></span>	<span class="nx">stwprocs</span><span class="p">,</span> <span class="nx">maxprocs</span>                 <span class="kt">int32</span>
	<span class="nx">tSweepTerm</span><span class="p">,</span> <span class="nx">tMark</span><span class="p">,</span> <span class="nx">tMarkTerm</span><span class="p">,</span> <span class="nx">tEnd</span> <span class="kt">int64</span> <span class="c1">// nanotime() of phase start
</span><span class="c1"></span>
	<span class="nx">pauseNS</span>    <span class="kt">int64</span> <span class="c1">// total STW time this cycle
</span><span class="c1"></span>	<span class="nx">pauseStart</span> <span class="kt">int64</span> <span class="c1">// nanotime() of last STW
</span><span class="c1"></span>
	<span class="c1">// debug.gctrace heap sizes for this cycle.
</span><span class="c1"></span>	<span class="nx">heap0</span><span class="p">,</span> <span class="nx">heap1</span><span class="p">,</span> <span class="nx">heap2</span><span class="p">,</span> <span class="nx">heapGoal</span> <span class="kt">uint64</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该结构体中包含大量垃圾收集的相关字段，例如：表示完成的垃圾收集循环的次数、当前循环时间和 CPU 的利用率、垃圾收集的模式等等，我们会在后面的小节中见到该结构体中的更多的字段。</p>
<h3 id="根对象">根对象</h3>
<p>在GC的标记阶段首先需要标记的就是&quot;根对象&quot;, 从根对象开始可到达的所有对象都会被认为是存活的.</p>
<p>根对象包含了全局变量, 各个G的栈上的变量等, GC会先扫描根对象然后再扫描根对象可到达的所有对象.</p>
<ul>
<li>Fixed Roots: 特殊的扫描工作 ：</li>
<li>fixedRootFinalizers: 扫描析构器队列</li>
<li>fixedRootFreeGStacks: 释放已中止的G的栈</li>
<li>Flush Cache Roots: 释放mcache中的所有span, 要求STW</li>
<li>Data Roots: 扫描可读写的全局变量</li>
<li>BSS Roots: 扫描只读的全局变量</li>
<li>Span Roots: 扫描各个span中特殊对象(析构器列表)</li>
<li>Stack Roots: 扫描各个G的栈</li>
</ul>
<p>标记阶段(Mark)会做其中的&quot;Fixed Roots&quot;, &ldquo;Data Roots&rdquo;, &ldquo;BSS Roots&rdquo;, &ldquo;Span Roots&rdquo;, &ldquo;Stack Roots&rdquo;.</p>
<p>完成标记阶段(Mark Termination)会做其中的&quot;Fixed Roots&quot;, &ldquo;Flush Cache Roots&rdquo;.</p>
<h3 id="触发时机">触发时机</h3>
<p>运行时会通过如下所示的 runtime.gcTrigger.test 方法决定是否需要触发垃圾收集，当满足触发垃圾收集的基本条件时 — 允许垃圾收集、程序没有崩溃并且没有处于垃圾收集循环，该方法会根据三种不同的方式触发进行不同的检查：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// gcTrigger 是一个 GC 周期开始的谓词。具体而言，它是一个 _GCoff 阶段的退出条件
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">gcTrigger</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">kind</span> <span class="nx">gcTriggerKind</span>
	<span class="nx">now</span>  <span class="kt">int64</span>  <span class="c1">// gcTriggerTime: 当前时间
</span><span class="c1"></span>	<span class="nx">n</span>    <span class="kt">uint32</span> <span class="c1">// gcTriggerCycle: 开始的周期数
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">gcTriggerKind</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="c1">// gcTriggerHeap 表示当堆大小达到控制器计算的触发堆大小时开始一个周期
</span><span class="c1"></span>	<span class="nx">gcTriggerHeap</span> <span class="nx">gcTriggerKind</span> <span class="p">=</span> <span class="kc">iota</span>

	<span class="c1">// gcTriggerTime 表示自上一个 GC 周期后当循环超过
</span><span class="c1"></span>	<span class="c1">// forcegcperiod 纳秒时应开始一个周期。
</span><span class="c1"></span>	<span class="nx">gcTriggerTime</span>

	<span class="c1">// gcTriggerCycle 表示如果我们还没有启动第 gcTrigger.n 个周期
</span><span class="c1"></span>	<span class="c1">// （相对于 work.cycles）时应开始一个周期。
</span><span class="c1"></span>	<span class="nx">gcTriggerCycle</span>
<span class="p">)</span>
<span class="c1">// test 报告当前出发条件是否满足，换句话说 _GCoff 阶段的退出条件已满足。
</span><span class="c1">// 退出条件应该在分配阶段已完成测试。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">gcTrigger</span><span class="p">)</span> <span class="nf">test</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// 如果已禁用 GC
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">enablegc</span> <span class="o">||</span> <span class="nx">panicking</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">// 根据类别做不同判断
</span><span class="c1"></span>	<span class="k">switch</span> <span class="nx">t</span><span class="p">.</span><span class="nx">kind</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">gcTriggerHeap</span><span class="p">:</span>
		<span class="c1">// 上个周期结束时剩余的加上到目前为止分配的内存 超过 触发标记阶段标准的内存
</span><span class="c1"></span>		<span class="c1">// 考虑性能问题，对非原子操作访问 heap_live 。如果我们需要触发该条件，
</span><span class="c1"></span>		<span class="c1">// 则所在线程一定会原子的写入 heap_live，从而我们会观察到我们的写入。
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span> <span class="o">&gt;=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_trigger</span>
	<span class="k">case</span> <span class="nx">gcTriggerTime</span><span class="p">:</span>
		<span class="c1">// 因为允许在运行时动态调整 gcpercent，因此需要额外再检查一遍
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">gcpercent</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
		<span class="c1">// 计算上次 gc 开始时间是否大于强制执行 GC 周期的时间
</span><span class="c1"></span>		<span class="nx">lastgc</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">last_gc_nanotime</span><span class="p">))</span>
		<span class="k">return</span> <span class="nx">lastgc</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">now</span><span class="o">-</span><span class="nx">lastgc</span> <span class="p">&gt;</span> <span class="nx">forcegcperiod</span><span class="c1">// 两分钟
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">gcTriggerCycle</span><span class="p">:</span>
		<span class="c1">// 进行测试的周期 t.n 大于实际触发的，需要进行 GC 则通过测试
</span><span class="c1"></span>		<span class="k">return</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">n</span><span class="o">-</span><span class="nx">work</span><span class="p">.</span><span class="nx">cycles</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>gcTriggerHeap — 堆内存的分配达到控制器计算的触发堆大小；</li>
<li>gcTriggerTime — 如果一定时间内没有触发，就会触发新的循环，该出发条件由 runtime.forcegcperiod 变量控制，默认为 2 分钟；</li>
<li>gcTriggerCycle — 如果当前没有开启垃圾收集，则触发新的循环；</li>
</ol>
<p>用于开启垃圾收集的方法 runtime.gcStart 会接收一个 runtime.gcTrigger 类型的谓词，我们可以根据这个触发_GCoff 退出的结构体找到所有触发的垃圾收集的代码：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210817232004.png" alt=""></p>
<ul>
<li>runtime.sysmon 和 runtime.forcegchelper — 后台运行定时检查和垃圾收集；</li>
<li>runtime.GC — 用户程序手动触发垃圾收集；</li>
<li>runtime.mallocgc — 申请内存时根据堆大小触发垃圾收集；</li>
</ul>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201201193647.png" alt=""></p>
<p>通过堆内存触发垃圾收集需要比较 runtime.mstats 中的两个字段:</p>
<ul>
<li>heap_live:表示垃圾收集中存活对象字节数的</li>
<li>gc_trigger:表示触发标记的堆内存大小的
当内存中存活的对象字节数大于触发垃圾收集的堆大小时，新一轮的垃圾收集就会开始。</li>
</ul>
<p>在这里，我们将分别介绍这两个值的计算过程：</p>
<ol>
<li>heap_live — 为了减少锁竞争，运行时只会在中心缓存分配或者释放内存管理单元以及在堆上分配大对象时才会更新；</li>
<li>gc_trigger — 在标记终止阶段调用 runtime.gcSetTriggerRatio 更新触发下一次垃圾收集的堆大小；</li>
</ol>
<p>runtime.gcController 会在每个循环结束后计算触发比例并通过 runtime.gcSetTriggerRatio 设置 gc_trigger，它能够决定触发垃圾收集的时间以及用户程序和后台处理的标记任务的多少，利用反馈控制的算法根据堆的增长情况和垃圾收集 CPU 利用率确定触发垃圾收集的时机。</p>
<h4 id="后台触发">后台触发</h4>
<p>运行时会在应用程序启动时在后台开启一个用于强制触发垃圾收集的 Goroutine，该 Goroutine 的职责非常简单 — 调用 runtime.gcStart 方法尝试启动新一轮的垃圾收集：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="nf">forcegchelper</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">forcegchelper</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">forcegc</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankForcegc</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">forcegc</span><span class="p">.</span><span class="nx">idle</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;forcegc: phase error&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">idle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="nf">goparkunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">waitReasonForceGCIdle</span><span class="p">,</span> <span class="nx">traceEvGoBlock</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="c1">// this goroutine is explicitly resumed by sysmon
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gctrace</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nb">println</span><span class="p">(</span><span class="s">&#34;GC forced&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// Time-triggered, fully concurrent.
</span><span class="c1"></span>		<span class="nf">gcStart</span><span class="p">(</span><span class="nx">gcTrigger</span><span class="p">{</span><span class="nx">kind</span><span class="p">:</span> <span class="nx">gcTriggerTime</span><span class="p">,</span> <span class="nx">now</span><span class="p">:</span> <span class="nf">nanotime</span><span class="p">()})</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>为了减少对计算资源的占用，该 Goroutine 会在循环中调用 runtime.goparkunlock 主动陷入休眠等待其他 Goroutine 的唤醒，runtime.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Puts the current goroutine into a waiting state and unlocks the lock.
</span><span class="c1">// The goroutine can be made runnable again by calling goready(gp).
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">goparkunlock</span><span class="p">(</span><span class="nx">lock</span> <span class="o">*</span><span class="nx">mutex</span><span class="p">,</span> <span class="nx">reason</span> <span class="nx">waitReason</span><span class="p">,</span> <span class="nx">traceEv</span> <span class="kt">byte</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">gopark</span><span class="p">(</span><span class="nx">parkunlock_c</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">lock</span><span class="p">),</span> <span class="nx">reason</span><span class="p">,</span> <span class="nx">traceEv</span><span class="p">,</span> <span class="nx">traceskip</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>forcegchelper 在大多数时间都是陷入休眠的，但是它会被系统监控器 runtime.sysmon 在满足垃圾收集条件时唤醒：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">sysmon</span><span class="p">()</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="o">...</span>
		<span class="k">if</span> <span class="nx">t</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">gcTrigger</span><span class="p">{</span><span class="nx">kind</span><span class="p">:</span> <span class="nx">gcTriggerTime</span><span class="p">,</span> <span class="nx">now</span><span class="p">:</span> <span class="nx">now</span><span class="p">});</span> <span class="nx">t</span><span class="p">.</span><span class="nf">test</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">idle</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="nx">forcegc</span><span class="p">.</span><span class="nx">idle</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="kd">var</span> <span class="nx">list</span> <span class="nx">gList</span>
			<span class="nx">list</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">g</span><span class="p">)</span>
			<span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>系统监控在每个循环中都会主动构建一个 runtime.gcTrigger 并检查垃圾收集的触发条件是否满足，如果满足条件，系统监控会将 runtime.forcegc 状态中持有的 Goroutine 加入全局队列等待调度器的调度。</p>
<h4 id="手动触发">手动触发</h4>
<p>用户程序会通过 runtime.GC 函数在程序运行期间主动通知运行时执行，该方法在调用时会阻塞调用方直到当前垃圾收集循环完成，在垃圾收集期间也可能会通过 STW 暂停整个程序：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// GC runs a garbage collection and blocks the caller until the
</span><span class="c1">// garbage collection is complete. It may also block the entire
</span><span class="c1">// program.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GC</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// We consider a cycle to be: sweep termination, mark, mark
</span><span class="c1"></span>	<span class="c1">// termination, and sweep. This function shouldn&#39;t return
</span><span class="c1"></span>	<span class="c1">// until a full cycle has been completed, from beginning to
</span><span class="c1"></span>	<span class="c1">// end. Hence, we always want to finish up the current cycle
</span><span class="c1"></span>	<span class="c1">// and start a new one. That means:
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 1. In sweep termination, mark, or mark termination of cycle
</span><span class="c1"></span>	<span class="c1">// N, wait until mark termination N completes and transitions
</span><span class="c1"></span>	<span class="c1">// to sweep N.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 2. In sweep N, help with sweep N.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// At this point we can begin a full cycle N+1.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 3. Trigger cycle N+1 by starting sweep termination N+1.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 4. Wait for mark termination N+1 to complete.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 5. Help with sweep N+1 until it&#39;s done.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This all has to be written to deal with the fact that the
</span><span class="c1"></span>	<span class="c1">// GC may move ahead on its own. For example, when we block
</span><span class="c1"></span>	<span class="c1">// until mark termination N, we may wake up in cycle N+2.
</span><span class="c1"></span>
	<span class="c1">// Wait until the current sweep termination, mark, and mark
</span><span class="c1"></span>	<span class="c1">// termination complete.
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">cycles</span><span class="p">)</span>
	<span class="c1">//在正式开始垃圾收集前，运行时需要通过 runtime.gcWaitOnMark 函数等待上一个循环的标记终止、标记和标记终止阶段完成；
</span><span class="c1"></span>	<span class="nf">gcWaitOnMark</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>

	<span class="c1">// We&#39;re now in sweep N or later. Trigger GC cycle N+1, which
</span><span class="c1"></span>	<span class="c1">// will first finish sweep N if necessary and then enter sweep
</span><span class="c1"></span>	<span class="c1">// termination N+1.
</span><span class="c1"></span>	<span class="c1">//调用 runtime.gcStart 触发新一轮的垃圾收集
</span><span class="c1"></span>	<span class="nf">gcStart</span><span class="p">(</span><span class="nx">gcTrigger</span><span class="p">{</span><span class="nx">kind</span><span class="p">:</span> <span class="nx">gcTriggerCycle</span><span class="p">,</span> <span class="nx">n</span><span class="p">:</span> <span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">})</span>

	<span class="c1">// Wait for mark termination N+1 to complete.
</span><span class="c1"></span>	<span class="c1">//通过 runtime.gcWaitOnMark 等待该轮垃圾收集的标记终止阶段正常结束；
</span><span class="c1"></span>	<span class="nf">gcWaitOnMark</span><span class="p">(</span><span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

	<span class="c1">// Finish sweep N+1 before returning. We do this both to
</span><span class="c1"></span>	<span class="c1">// complete the cycle and because runtime.GC() is often used
</span><span class="c1"></span>	<span class="c1">// as part of tests and benchmarks to get the system into a
</span><span class="c1"></span>	<span class="c1">// relatively stable and isolated state.
</span><span class="c1"></span>	<span class="c1">//持续调用 runtime.sweepone 清理全部待处理的内存管理单元并等待所有的清理工作完成，等待期间会调用 runtime.Gosched 让出处理器；
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">cycles</span><span class="p">)</span> <span class="o">==</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nf">sweepone</span><span class="p">()</span> <span class="o">!=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">sweep</span><span class="p">.</span><span class="nx">nbgsweep</span><span class="o">++</span>
		<span class="nf">Gosched</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// Callers may assume that the heap profile reflects the
</span><span class="c1"></span>	<span class="c1">// just-completed cycle when this returns (historically this
</span><span class="c1"></span>	<span class="c1">// happened because this was a STW GC), but right now the
</span><span class="c1"></span>	<span class="c1">// profile still reflects mark termination N, not N+1.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// As soon as all of the sweep frees from cycle N+1 are done,
</span><span class="c1"></span>	<span class="c1">// we can go ahead and publish the heap profile.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// First, wait for sweeping to finish. (We know there are no
</span><span class="c1"></span>	<span class="c1">// more spans on the sweep queue, but we may be concurrently
</span><span class="c1"></span>	<span class="c1">// sweeping spans, so we have to wait.)
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">cycles</span><span class="p">)</span> <span class="o">==</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepers</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">Gosched</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// Now we&#39;re really done with sweeping, so we can publish the
</span><span class="c1"></span>	<span class="c1">// stable heap profile. Only do this if we haven&#39;t already hit
</span><span class="c1"></span>	<span class="c1">// another mark termination.
</span><span class="c1"></span>	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
	<span class="nx">cycle</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">cycles</span><span class="p">)</span>
	<span class="c1">//完成本轮垃圾收集的清理工作后，通过 runtime.mProf_PostSweep 将该阶段的堆内存状态快照发布出来，我们可以获取这时的内存状态；
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">cycle</span> <span class="o">==</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span> <span class="o">||</span> <span class="p">(</span><span class="nx">gcphase</span> <span class="o">==</span> <span class="nx">_GCmark</span> <span class="o">&amp;&amp;</span> <span class="nx">cycle</span> <span class="o">==</span> <span class="nx">n</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">mProf_PostSweep</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>手动触发垃圾收集的过程不是特别常见，一般只会在运行时的测试代码中才会出现，不过如果我们认为触发主动垃圾收集是有必要的，我们也可以直接调用该方法，但是作者并不认为这是一种推荐的做法。</p>
<h4 id="申请内存">申请内存</h4>
<p>最后一个可能会触发垃圾收集的就是 runtime.mallocgc 函数了，我们在内存分配器中曾经介绍过运行时会将堆上的对象按大小分成微对象、小对象和大对象三类，这三类对象的创建都可能会触发新的垃圾收集循环：</p>
<ol>
<li>当前线程的内存管理单元中不存在空闲空间时，创建微对象和小对象需要调用 runtime.mcache.nextFree 方法从中心缓存或者页堆中获取新的管理单元，在这时就可能触发垃圾收集；</li>
<li>当用户程序申请分配 32KB 以上的大对象时，一定会构建 runtime.gcTrigger 结构体尝试触发 垃圾收集；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="nx">shouldhelpgc</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">maxSmallSize</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">noscan</span> <span class="o">&amp;&amp;</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">maxTinySize</span> <span class="p">{</span>
			<span class="o">...</span>
			<span class="nx">v</span> <span class="o">:=</span> <span class="nf">nextFreeFast</span><span class="p">(</span><span class="nx">span</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">v</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">nextFree</span><span class="p">(</span><span class="nx">tinySpanClass</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="o">...</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">...</span>
			<span class="nx">v</span> <span class="o">:=</span> <span class="nf">nextFreeFast</span><span class="p">(</span><span class="nx">span</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">v</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">nextFree</span><span class="p">(</span><span class="nx">spc</span><span class="p">)</span>
			<span class="p">}</span>
		  <span class="o">...</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="o">...</span>
	<span class="p">}</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nx">shouldhelpgc</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">t</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">gcTrigger</span><span class="p">{</span><span class="nx">kind</span><span class="p">:</span> <span class="nx">gcTriggerHeap</span><span class="p">});</span> <span class="nx">t</span><span class="p">.</span><span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">gcStart</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="垃圾收集启动gcstart">垃圾收集启动:gcStart</h3>
<p>垃圾收集在启动过程一定会调用 runtime.gcStart 函数，虽然该函数的实现比较复杂，但是它的主要职责就是修改全局的垃圾收集状态到 _GCmark 并做一些准备工作，我们会分以下几个阶段介绍该函数的实现：</p>
<ol>
<li>两次调用 runtime.gcTrigger.test 方法检查是否满足垃圾收集条件；</li>
<li>暂停程序、在后台启动用于处理标记任务的工作 Goroutine、确定所有内存管理单元都被清理以及其他标记阶段开始前的准备工作；</li>
<li>进入标记阶段、准备后台的标记工作、根对象的标记工作以及微对象、恢复用户程序，进入并发扫描和标记阶段；</li>
</ol>
<p>验证垃圾收集条件的同时，该方法还会在循环中不断调用 runtime.sweepone 清理已经被标记的内存单元，完成上一个垃圾收集循环的收尾工作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// gcStart starts the GC. It transitions from _GCoff to _GCmark (if
</span><span class="c1">// debug.gcstoptheworld == 0) or performs all of GC (if
</span><span class="c1">// debug.gcstoptheworld != 0).
</span><span class="c1">//
</span><span class="c1">// This may return without performing this transition in some cases,
</span><span class="c1">// such as when called on a system stack or with locks held.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gcStart</span><span class="p">(</span><span class="nx">trigger</span> <span class="nx">gcTrigger</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 判断当前G是否可抢占, 不可抢占时不触发GC
</span><span class="c1"></span>	<span class="c1">// Since this is called from malloc and malloc is called in
</span><span class="c1"></span>	<span class="c1">// the guts of a number of libraries that might be holding
</span><span class="c1"></span>	<span class="c1">// locks, don&#39;t attempt to start GC in non-preemptible or
</span><span class="c1"></span>	<span class="c1">// potentially unstable situations.
</span><span class="c1"></span>	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">();</span> <span class="nx">gp</span> <span class="o">==</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span> <span class="o">||</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">locks</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="nx">mp</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="c1">// Pick up the remaining unswept/not being swept spans concurrently
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This shouldn&#39;t happen if we&#39;re being invoked in background
</span><span class="c1"></span>	<span class="c1">// mode since proportional sweep should have just finished
</span><span class="c1"></span>	<span class="c1">// sweeping everything, but rounding errors, etc, may leave a
</span><span class="c1"></span>	<span class="c1">// few spans unswept. In forced mode, this is necessary since
</span><span class="c1"></span>	<span class="c1">// GC can be forced at any point in the sweeping cycle.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// We check the transition condition continuously here in case
</span><span class="c1"></span>	<span class="c1">// this G gets delayed in to the next GC cycle.
</span><span class="c1"></span>	<span class="c1">//验证垃圾收集条件的同时，该方法还会在循环中不断调用 runtime.sweepone 清理已经被标记的内存单元，完成上一个垃圾收集循环的收尾工作：
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">trigger</span><span class="p">.</span><span class="nf">test</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nf">sweepone</span><span class="p">()</span> <span class="o">!=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">sweep</span><span class="p">.</span><span class="nx">nbgsweep</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="c1">//在验证了垃圾收集的条件并完成了收尾工作后，该方法会通过 semacquire 获取全局的 worldsema 信号量
</span><span class="c1"></span>	<span class="c1">// Perform GC initialization and the sweep termination
</span><span class="c1"></span>	<span class="c1">// transition.
</span><span class="c1"></span>	<span class="nf">semacquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">startSema</span><span class="p">)</span>
	<span class="c1">// Re-check transition condition under transition lock.
</span><span class="c1"></span>	<span class="c1">//重新检查gcTrigger的条件是否成立, 不成立时不触发GC
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">trigger</span><span class="p">.</span><span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">startSema</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// For stats, check if this GC was forced by the user.
</span><span class="c1"></span>	<span class="c1">// 记录是否强制触发, gcTriggerCycle是runtime.GC用的
</span><span class="c1"></span>	<span class="nx">work</span><span class="p">.</span><span class="nx">userForced</span> <span class="p">=</span> <span class="nx">trigger</span><span class="p">.</span><span class="nx">kind</span> <span class="o">==</span> <span class="nx">gcTriggerCycle</span>

	<span class="c1">// In gcstoptheworld debug mode, upgrade the mode accordingly.
</span><span class="c1"></span>	<span class="c1">// We do this after re-checking the transition condition so
</span><span class="c1"></span>	<span class="c1">// that multiple goroutines that detect the heap trigger don&#39;t
</span><span class="c1"></span>	<span class="c1">// start multiple STW GCs.
</span><span class="c1"></span>	<span class="c1">// 判断是否指定了禁止并行GC的参数
</span><span class="c1"></span>	<span class="nx">mode</span> <span class="o">:=</span> <span class="nx">gcBackgroundMode</span>
	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gcstoptheworld</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nx">mode</span> <span class="p">=</span> <span class="nx">gcForceMode</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gcstoptheworld</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
		<span class="nx">mode</span> <span class="p">=</span> <span class="nx">gcForceBlockMode</span>
	<span class="p">}</span>

	<span class="c1">// Ok, we&#39;re doing it! Stop everybody else
</span><span class="c1"></span>	<span class="nf">semacquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcsema</span><span class="p">)</span>
	<span class="nf">semacquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">worldsema</span><span class="p">)</span>
	<span class="c1">// 跟踪处理
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCStart</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// Check that all Ps have finished deferred mcache flushes.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">fg</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nx">flushGen</span><span class="p">);</span> <span class="nx">fg</span> <span class="o">!=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="p">{</span>
			<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: p&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="s">&#34;flushGen&#34;</span><span class="p">,</span> <span class="nx">fg</span><span class="p">,</span> <span class="s">&#34;!= sweepgen&#34;</span><span class="p">,</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;p mcache not flushed&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//调用 runtime.gcBgMarkStartWorkers 启动后台标记任务
</span><span class="c1"></span>	<span class="nf">gcBgMarkStartWorkers</span><span class="p">()</span>
	<span class="c1">// 重置标记相关的状态
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="nx">gcResetMarkState</span><span class="p">)</span>
	<span class="c1">//修改全局变量 runtime.work 持有的状态，包括垃圾收集需要的 Goroutine 数量以及已完成的循环数。
</span><span class="c1"></span>	<span class="nx">work</span><span class="p">.</span><span class="nx">stwprocs</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">maxprocs</span> <span class="p">=</span> <span class="nx">gomaxprocs</span><span class="p">,</span> <span class="nx">gomaxprocs</span>
	<span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">stwprocs</span> <span class="p">&gt;</span> <span class="nx">ncpu</span> <span class="p">{</span>
		<span class="c1">// This is used to compute CPU time of the STW phases,
</span><span class="c1"></span>		<span class="c1">// so it can&#39;t be more than ncpu, even if GOMAXPROCS is.
</span><span class="c1"></span>		<span class="nx">work</span><span class="p">.</span><span class="nx">stwprocs</span> <span class="p">=</span> <span class="nx">ncpu</span>
	<span class="p">}</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">heap0</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">)</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">pauseNS</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">mode</span> <span class="p">=</span> <span class="nx">mode</span>
	<span class="c1">// 记录开始时间
</span><span class="c1"></span>	<span class="nx">now</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">tSweepTerm</span> <span class="p">=</span> <span class="nx">now</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">pauseStart</span> <span class="p">=</span> <span class="nx">now</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCSTWStart</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">//在系统栈中调用 runtime.stopTheWorldWithSema 停止世界
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="nx">stopTheWorldWithSema</span><span class="p">)</span>
	<span class="c1">// Finish sweep before we start concurrent scan.
</span><span class="c1"></span>	<span class="c1">// 清扫上一轮GC未清扫的span, 确保上一轮GC已完成
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">finishsweep_m</span><span class="p">()</span>
	<span class="p">})</span>

	<span class="c1">// clearpools before we start the GC. If we wait they memory will not be
</span><span class="c1"></span>	<span class="c1">// reclaimed until the next GC cycle.
</span><span class="c1"></span>	<span class="c1">// 清扫sched.sudogcache和sched.deferpool
</span><span class="c1"></span>	<span class="nf">clearpools</span><span class="p">()</span>
	<span class="c1">// 增加GC计数
</span><span class="c1"></span>	<span class="nx">work</span><span class="p">.</span><span class="nx">cycles</span><span class="o">++</span>
	<span class="c1">// 标记新一轮GC已开始
</span><span class="c1"></span>	<span class="nx">gcController</span><span class="p">.</span><span class="nf">startCycle</span><span class="p">()</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">heapGoal</span> <span class="p">=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span>

	<span class="c1">// In STW mode, disable scheduling of user Gs. This may also
</span><span class="c1"></span>	<span class="c1">// disable scheduling of this goroutine, so it may block as
</span><span class="c1"></span>	<span class="c1">// soon as we start the world again.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">mode</span> <span class="o">!=</span> <span class="nx">gcBackgroundMode</span> <span class="p">{</span>
		<span class="nf">schedEnableUser</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Enter concurrent mark phase and enable
</span><span class="c1"></span>	<span class="c1">// write barriers.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Because the world is stopped, all Ps will
</span><span class="c1"></span>	<span class="c1">// observe that write barriers are enabled by
</span><span class="c1"></span>	<span class="c1">// the time we start the world and begin
</span><span class="c1"></span>	<span class="c1">// scanning.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Write barriers must be enabled before assists are
</span><span class="c1"></span>	<span class="c1">// enabled because they must be enabled before
</span><span class="c1"></span>	<span class="c1">// any non-leaf heap objects are marked. Since
</span><span class="c1"></span>	<span class="c1">// allocations are blocked until assists can
</span><span class="c1"></span>	<span class="c1">// happen, we want enable assists as early as
</span><span class="c1"></span>	<span class="c1">// possible.
</span><span class="c1"></span>	<span class="c1">//在完成全部的准备工作后，该方法就进入了执行的最后阶段。在该阶段中，我们会修改全局的垃圾收集状态到 _GCmark 并依次执行下面的步骤：
</span><span class="c1"></span>	<span class="nf">setGCPhase</span><span class="p">(</span><span class="nx">_GCmark</span><span class="p">)</span>
	<span class="c1">//调用 runtime.gcBgMarkPrepare 函数初始化后台扫描需要的状态；
</span><span class="c1"></span>	<span class="nf">gcBgMarkPrepare</span><span class="p">()</span> <span class="c1">// Must happen before assist enable.
</span><span class="c1"></span>	<span class="c1">//调用 runtime.gcMarkRootPrepare 函数扫描栈上、全局变量等根对象并将它们加入队列；
</span><span class="c1"></span>	<span class="nf">gcMarkRootPrepare</span><span class="p">()</span>

	<span class="c1">// Mark all active tinyalloc blocks. Since we&#39;re
</span><span class="c1"></span>	<span class="c1">// allocating from these, they need to be black like
</span><span class="c1"></span>	<span class="c1">// other allocations. The alternative is to blacken
</span><span class="c1"></span>	<span class="c1">// the tiny block on every allocation from it, which
</span><span class="c1"></span>	<span class="c1">// would slow down the tiny allocator.
</span><span class="c1"></span>	<span class="c1">// 标记所有tiny alloc等待合并的对象
</span><span class="c1"></span>	<span class="nf">gcMarkTinyAllocs</span><span class="p">()</span>

	<span class="c1">// At this point all Ps have enabled the write
</span><span class="c1"></span>	<span class="c1">// barrier, thus maintaining the no white to
</span><span class="c1"></span>	<span class="c1">// black invariant. Enable mutator assists to
</span><span class="c1"></span>	<span class="c1">// put back-pressure on fast allocating
</span><span class="c1"></span>	<span class="c1">// mutators.
</span><span class="c1"></span>	<span class="c1">//设置全局变量 runtime.gcBlackenEnabled，用户程序和标记任务可以将对象涂黑；
</span><span class="c1"></span>	<span class="c1">// 启用辅助GC
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcBlackenEnabled</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

	<span class="c1">// Assists and workers can start the moment we start
</span><span class="c1"></span>	<span class="c1">// the world.
</span><span class="c1"></span>	<span class="c1">// 记录标记开始的时间
</span><span class="c1"></span>	<span class="nx">gcController</span><span class="p">.</span><span class="nx">markStartTime</span> <span class="p">=</span> <span class="nx">now</span>

	<span class="c1">// In STW mode, we could block the instant systemstack
</span><span class="c1"></span>	<span class="c1">// returns, so make sure we&#39;re not preemptible.
</span><span class="c1"></span>	<span class="nx">mp</span> <span class="p">=</span> <span class="nf">acquirem</span><span class="p">()</span>

	<span class="c1">// Concurrent mark.
</span><span class="c1"></span>	<span class="c1">// 调用 runtime.startTheWorldWithSema 启动程序，后台任务也会开始标记堆中的对象；
</span><span class="c1"></span>	<span class="c1">// 重新启动世界
</span><span class="c1"></span>	<span class="c1">// 前面创建的后台标记任务会开始工作, 所有后台标记任务都完成工作后, 进入完成标记阶段
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">now</span> <span class="p">=</span> <span class="nf">startTheWorldWithSema</span><span class="p">(</span><span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span><span class="p">)</span>
		<span class="c1">// 记录停止了多久, 和标记阶段开始的时间
</span><span class="c1"></span>		<span class="nx">work</span><span class="p">.</span><span class="nx">pauseNS</span> <span class="o">+=</span> <span class="nx">now</span> <span class="o">-</span> <span class="nx">work</span><span class="p">.</span><span class="nx">pauseStart</span>
		<span class="nx">work</span><span class="p">.</span><span class="nx">tMark</span> <span class="p">=</span> <span class="nx">now</span>
	<span class="p">})</span>

	<span class="c1">// Release the world sema before Gosched() in STW mode
</span><span class="c1"></span>	<span class="c1">// because we will need to reacquire it later but before
</span><span class="c1"></span>	<span class="c1">// this goroutine becomes runnable again, and we could
</span><span class="c1"></span>	<span class="c1">// self-deadlock otherwise.
</span><span class="c1"></span>	<span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">worldsema</span><span class="p">)</span>
	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>

	<span class="c1">// Make sure we block instead of returning to user code
</span><span class="c1"></span>	<span class="c1">// in STW mode.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">mode</span> <span class="o">!=</span> <span class="nx">gcBackgroundMode</span> <span class="p">{</span>
		<span class="nf">Gosched</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">startSema</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在分析垃圾收集的启动过程中，我们省略了几个关键的过程，其中包括暂停和恢复应用程序和后台任务的启动，下面将详细分析这几个过程的实现原理。</p>
<h4 id="gcbgmarkstartworkers">gcBgMarkStartWorkers</h4>
<p>在垃圾收集启动期间，运行时会调用 runtime.gcBgMarkStartWorkers 为全局每个处理器创建用于执行后台标记任务的 Goroutine，每一个 Goroutine 都会运行 runtime.gcBgMarkWorker，所有运行 runtime.gcBgMarkWorker 的 Goroutine 在启动后都会陷入休眠等待调度器的唤醒：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// gcBgMarkStartWorkers prepares background mark worker goroutines.
</span><span class="c1">// These goroutines will not run until the mark phase, but they must
</span><span class="c1">// be started while the work is not stopped and from a regular G
</span><span class="c1">// stack. The caller must hold worldsema.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gcBgMarkStartWorkers</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Background marking is performed by per-P G&#39;s. Ensure that
</span><span class="c1"></span>	<span class="c1">// each P has a background GC G.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
		<span class="c1">// 如果已启动则不重复启动
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">go</span> <span class="nf">gcBgMarkWorker</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
			<span class="c1">// 启动后等待该任务通知信号量bgMarkReady再继续
</span><span class="c1"></span>			<span class="nf">notetsleepg</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">bgMarkReady</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">bgMarkReady</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//zhouyunjia
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这些 Goroutine 与处理器是一一对应的关系</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201214175849.png" alt=""></p>
<h4 id="gcresetmarkstate">gcResetMarkState</h4>
<p>gcResetMarkState函数会重置标记相关的状态:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// gcResetMarkState resets global state prior to marking (concurrent
</span><span class="c1">// or STW) and resets the stack scan state of all Gs.
</span><span class="c1">//
</span><span class="c1">// This is safe to do without the world stopped because any Gs created
</span><span class="c1">// during or after this will start out in the reset state.
</span><span class="c1">//
</span><span class="c1">// gcResetMarkState must be called on the system stack because it acquires
</span><span class="c1">// the heap lock. See mheap for details.
</span><span class="c1">//
</span><span class="c1">//go:systemstack
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gcResetMarkState</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// This may be called during a concurrent phase, so make sure
</span><span class="c1"></span>	<span class="c1">// allgs doesn&#39;t change.
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allglock</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allgs</span> <span class="p">{</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">gcscandone</span> <span class="p">=</span> <span class="kc">false</span> <span class="c1">// set to true in gcphasework
</span><span class="c1"></span>		<span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allglock</span><span class="p">)</span>

	<span class="c1">// Clear page marks. This is just 1MB per 64GB of heap, so the
</span><span class="c1"></span>	<span class="c1">// time here is pretty trivial.
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">arenas</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">allArenas</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ai</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">arenas</span> <span class="p">{</span>
		<span class="nx">ha</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenas</span><span class="p">[</span><span class="nx">ai</span><span class="p">.</span><span class="nf">l1</span><span class="p">()][</span><span class="nx">ai</span><span class="p">.</span><span class="nf">l2</span><span class="p">()]</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ha</span><span class="p">.</span><span class="nx">pageMarks</span> <span class="p">{</span>
			<span class="nx">ha</span><span class="p">.</span><span class="nx">pageMarks</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">work</span><span class="p">.</span><span class="nx">bytesMarked</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">initialHeapLive</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="stoptheworldwithsema">stopTheWorldWithSema</h4>
<p>函数会停止整个世界, 这个函数必须在g0中运行:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// stopTheWorldWithSema is the core implementation of stopTheWorld.
</span><span class="c1">// The caller is responsible for acquiring worldsema and disabling
</span><span class="c1">// preemption first and then should stopTheWorldWithSema on the system
</span><span class="c1">// stack:
</span><span class="c1">//
</span><span class="c1">//	semacquire(&amp;worldsema, 0)
</span><span class="c1">//	m.preemptoff = &#34;reason&#34;
</span><span class="c1">//	systemstack(stopTheWorldWithSema)
</span><span class="c1">//
</span><span class="c1">// When finished, the caller must either call startTheWorld or undo
</span><span class="c1">// these three operations separately:
</span><span class="c1">//
</span><span class="c1">//	m.preemptoff = &#34;&#34;
</span><span class="c1">//	systemstack(startTheWorldWithSema)
</span><span class="c1">//	semrelease(&amp;worldsema)
</span><span class="c1">//
</span><span class="c1">// It is allowed to acquire worldsema once and then execute multiple
</span><span class="c1">// startTheWorldWithSema/stopTheWorldWithSema pairs.
</span><span class="c1">// Other P&#39;s are able to execute between successive calls to
</span><span class="c1">// startTheWorldWithSema and stopTheWorldWithSema.
</span><span class="c1">// Holding worldsema causes any other goroutines invoking
</span><span class="c1">// stopTheWorld to block.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">stopTheWorldWithSema</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="c1">// If we hold a lock, then we won&#39;t be able to stop another M
</span><span class="c1"></span>	<span class="c1">// that is blocked trying to acquire the lock.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopTheWorld: holding locks&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">//因为程序中活跃的最大处理数为 gomaxprocs，所以在每次发现停止的处理器时都会对该变量减一，直到所有的处理器都停止运行。
</span><span class="c1"></span>	<span class="c1">// 设置stopwait的初始值为最大的 p 的个数
</span><span class="c1"></span>	<span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span> <span class="p">=</span> <span class="nx">gomaxprocs</span>
	<span class="c1">// 设置gc等待标记, 调度时看见此标记会进入等待
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 给所有的 p 发送抢占信号，如果成功，则对应的 p 进入 idle 状态
</span><span class="c1"></span>	<span class="c1">// 抢占所有运行中的G
</span><span class="c1"></span>	<span class="nf">preemptall</span><span class="p">()</span>
	<span class="c1">//依次停止当前处理器、等待处于系统调用的处理器以及获取并抢占空闲的处理器，处理器的状态在该函数返回时都会被更新至_Pgcstop，等待垃圾收集器的重新唤醒。
</span><span class="c1"></span>	<span class="c1">// stop current P
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pgcstop</span> <span class="c1">// Pgcstop is only diagnostic.
</span><span class="c1"></span>	<span class="c1">// 减少需要停止的P数量(当前的P算一个)
</span><span class="c1"></span>	<span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span><span class="o">--</span>
	<span class="c1">// try to retake all P&#39;s in Psyscall status
</span><span class="c1"></span>	<span class="c1">// 抢占所有在Psyscall状态的P, 防止它们重新参与调度
</span><span class="c1"></span>	<span class="c1">// 遍历所有的 p 如果满足条件(p的状态为 _Psyscall)则释放这个 p , 并且把 p 的状态都设置成 _Pgcstop ; 然后stopwait--
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
		<span class="nx">s</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">status</span>
		<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">_Psyscall</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">_Pgcstop</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
				<span class="nf">traceGoSysBlock</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
				<span class="nf">traceProcStop</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">syscalltick</span><span class="o">++</span>
			<span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span><span class="o">--</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// stop idle P&#39;s
</span><span class="c1"></span>	<span class="c1">// 防止所有空闲的P重新参与调度
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">//获取idle 状态的 p, 从 _Pidle list 获取
</span><span class="c1"></span>		<span class="nx">p</span> <span class="o">:=</span> <span class="nf">pidleget</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="c1">// 把 p 状态设置为 _Pgcstop
</span><span class="c1"></span>		<span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pgcstop</span>
		<span class="c1">// 计数 stopwait --
</span><span class="c1"></span>		<span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="nx">wait</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span> <span class="p">&gt;</span> <span class="mi">0</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">// 如果仍有需要停止的P, 则等待它们停止
</span><span class="c1"></span>	<span class="c1">// wait for remaining P&#39;s to stop voluntarily
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">wait</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="c1">// wait for 100us, then try to re-preempt in case of any races
</span><span class="c1"></span>			<span class="c1">// 循环等待 + 抢占所有运行中的G
</span><span class="c1"></span>			<span class="c1">//notetsleep函数内部每隔一段时间就会返回:
</span><span class="c1"></span>			<span class="k">if</span> <span class="nf">notetsleep</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">stopnote</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
				<span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">stopnote</span><span class="p">)</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="nf">preemptall</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// sanity checks
</span><span class="c1"></span>	<span class="c1">// 逻辑正确性检查
</span><span class="c1"></span>	<span class="nx">bad</span> <span class="o">:=</span> <span class="s">&#34;&#34;</span>
	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">bad</span> <span class="p">=</span> <span class="s">&#34;stopTheWorld: not stopped (stopwait != 0)&#34;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Pgcstop</span> <span class="p">{</span>
				<span class="nx">bad</span> <span class="p">=</span> <span class="s">&#34;stopTheWorld: not stopped (status != _Pgcstop)&#34;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">freezing</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Some other thread is panicking. This can cause the
</span><span class="c1"></span>		<span class="c1">// sanity checks above to fail if the panic happens in
</span><span class="c1"></span>		<span class="c1">// the signal handler on a stopped thread. Either way,
</span><span class="c1"></span>		<span class="c1">// we should halt this thread.
</span><span class="c1"></span>		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">deadlock</span><span class="p">)</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">deadlock</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">bad</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="nx">bad</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 到这里所有运行中的G都会变为待运行, 并且所有的P都不能被M获取
</span><span class="c1"></span>	<span class="c1">// 也就是说所有的go代码(除了当前的)都会停止运行, 并且不能运行新的go代码
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">notetsleep</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">note</span><span class="p">,</span> <span class="nx">ns</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;notetsleep not on g0&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">semacreate</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>
	<span class="k">return</span> <span class="nf">notetsleep_internal</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">ns</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>暂停程序主要使用了 runtime.preemptall 函数，该函数会调用我们runtime.preemptone.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Tell all goroutines that they have been preempted and they should stop.
</span><span class="c1">// This function is purely best-effort. It can fail to inform a goroutine if a
</span><span class="c1">// processor just started running it.
</span><span class="c1">// No locks need to be held.
</span><span class="c1">// Returns true if preemption request was issued to at least one goroutine.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">preemptall</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_p_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Prunning</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nf">preemptone</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>notetsleep函数内部每隔一段时间就会返回:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">return</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="nf">key32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">n</span><span class="p">.</span><span class="nx">key</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span> <span class="c1">// n.key 为参数 &amp;shced.stopnote.key的值
</span></code></pre></td></tr></table>
</div>
</div><p>如果要想让返回值为 true 就需要满足上面的条件。 stopnote.key的值有两个函数可以控制:</p>
<ul>
<li>notewakeup 把 stopnote 设置为 1</li>
<li>noteclear 把stopnote设置为 0</li>
</ul>
<p>所以我们需要调用notewakeup才行。而这个函数我们可以看到是在gcstopm()有调用:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span><span class="o">--</span>
<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">stopnote</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当sched.stopwait为0时,会唤醒notetsleep,继续执行下面的操作.</p>
<h4 id="finishsweep_m">finishsweep_m</h4>
<p>finishsweep_m函数会清扫上一轮GC未清扫的span, 确保上一轮GC已完成:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// finishsweep_m ensures that all spans are swept.
</span><span class="c1">//
</span><span class="c1">// The world must be stopped. This ensures there are no sweeps in
</span><span class="c1">// progress.
</span><span class="c1">//
</span><span class="c1">//go:nowritebarrier
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">finishsweep_m</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// sweepone会取出一个未sweep的span然后执行sweep
</span><span class="c1"></span>	<span class="c1">// Sweeping must be complete before marking commences, so
</span><span class="c1"></span>	<span class="c1">// sweep any unswept spans. If this is a concurrent GC, there
</span><span class="c1"></span>	<span class="c1">// shouldn&#39;t be any spans left to sweep, so this should finish
</span><span class="c1"></span>	<span class="c1">// instantly. If GC was forced before the concurrent sweep
</span><span class="c1"></span>	<span class="c1">// finished, there may be spans to sweep.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nf">sweepone</span><span class="p">()</span> <span class="o">!=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">sweep</span><span class="p">.</span><span class="nx">npausesweep</span><span class="o">++</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">go115NewMCentralImpl</span> <span class="p">{</span>
		<span class="c1">// Reset all the unswept buffers, which should be empty.
</span><span class="c1"></span>		<span class="c1">// Do this in sweep termination as opposed to mark termination
</span><span class="c1"></span>		<span class="c1">// so that we can catch unswept spans and reclaim blocks as
</span><span class="c1"></span>		<span class="c1">// soon as possible.
</span><span class="c1"></span>		<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span> <span class="p">{</span>
			<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">mcentral</span>
			<span class="nx">c</span><span class="p">.</span><span class="nf">partialUnswept</span><span class="p">(</span><span class="nx">sg</span><span class="p">).</span><span class="nf">reset</span><span class="p">()</span>
			<span class="nx">c</span><span class="p">.</span><span class="nf">fullUnswept</span><span class="p">(</span><span class="nx">sg</span><span class="p">).</span><span class="nf">reset</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Sweeping is done, so if the scavenger isn&#39;t already awake,
</span><span class="c1"></span>	<span class="c1">// wake it up. There&#39;s definitely work for it to do at this
</span><span class="c1"></span>	<span class="c1">// point.
</span><span class="c1"></span>	<span class="nf">wakeScavenger</span><span class="p">()</span>
	<span class="c1">// 所有span都sweep完成后, 启动一个新的markbit时代
</span><span class="c1"></span>	<span class="c1">// 这个函数是实现span的gcmarkBits和allocBits的分配和复用的关键, 流程如下
</span><span class="c1"></span>	<span class="c1">// - span分配gcmarkBits和allocBits
</span><span class="c1"></span>	<span class="c1">// - span完成sweep
</span><span class="c1"></span>	<span class="c1">//   - 原allocBits不再被使用
</span><span class="c1"></span>	<span class="c1">//   - gcmarkBits变为allocBits
</span><span class="c1"></span>	<span class="c1">//   - 分配新的gcmarkBits
</span><span class="c1"></span>	<span class="c1">// - 开启新的markbit时代
</span><span class="c1"></span>	<span class="c1">// - span完成sweep, 同上
</span><span class="c1"></span>	<span class="c1">// - 开启新的markbit时代
</span><span class="c1"></span>	<span class="c1">//   - 2个时代之前的bitmap将不再被使用, 可以复用这些bitmap
</span><span class="c1"></span>	<span class="nf">nextMarkBitArenaEpoch</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="clearpools">clearpools</h4>
<p>clearpools函数会清理sched.sudogcache和sched.deferpool, 让它们的内存可以被回收:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">clearpools</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// clear sync.Pools
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">poolcleanup</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">poolcleanup</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// Clear central sudog cache.
</span><span class="c1"></span>	<span class="c1">// Leave per-P caches alone, they have strictly bounded size.
</span><span class="c1"></span>	<span class="c1">// Disconnect cached list before dropping it on the floor,
</span><span class="c1"></span>	<span class="c1">// so that a dangling ref to one entry does not pin all of them.
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sudoglock</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">sgnext</span> <span class="o">*</span><span class="nx">sudog</span>
	<span class="k">for</span> <span class="nx">sg</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">sudogcache</span><span class="p">;</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">sg</span> <span class="p">=</span> <span class="nx">sgnext</span> <span class="p">{</span>
		<span class="nx">sgnext</span> <span class="p">=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">next</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">sudogcache</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sudoglock</span><span class="p">)</span>

	<span class="c1">// Clear central defer pools.
</span><span class="c1"></span>	<span class="c1">// Leave per-P pools alone, they have strictly bounded size.
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">deferlock</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span> <span class="p">{</span>
		<span class="c1">// disconnect cached list before dropping it on the floor,
</span><span class="c1"></span>		<span class="c1">// so that a dangling ref to one entry does not pin all of them.
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">d</span><span class="p">,</span> <span class="nx">dlink</span> <span class="o">*</span><span class="nx">_defer</span>
		<span class="k">for</span> <span class="nx">d</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span> <span class="nx">d</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">d</span> <span class="p">=</span> <span class="nx">dlink</span> <span class="p">{</span>
			<span class="nx">dlink</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>
			<span class="nx">d</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">deferlock</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="startcycle">startCycle</h4>
<p>用于并发扫描对象的工作协程 Goroutine 总共有三种不同的模式 runtime.gcMarkWorkerMode，这三种不同模式的 Goroutine 在标记对象时使用完全不同的策略，垃圾收集控制器会按照需要执行不同类型的工作协程：</p>
<ul>
<li>gcMarkWorkerDedicatedMode — 处理器专门负责标记对象，不会被调度器抢占；</li>
<li>gcMarkWorkerFractionalMode — 当垃圾收集的后台 CPU 使用率达不到预期时（默认为 25%），启动该类型的工作协程帮助垃圾收集达到利用率的目标，因为它只占用同一个 CPU 的部分资源，所以可以被调度；</li>
<li>gcMarkWorkerIdleMode — 当处理器没有可以执行的 Goroutine 时，它会运行垃圾收集的标记任务直到被抢占；</li>
</ul>
<p>runtime.gcControllerState.startCycle 会根据全局处理器的个数以及垃圾收集的 CPU 利用率计算出 dedicatedMarkWorkersNeeded 和 fractionalUtilizationGoal 以决定不同模式的工作协程的数量。</p>
<p>因为后台标记任务的 CPU 利用率为 25%，如果主机是 4 核或者 8 核，那么垃圾收集需要 1 个或者 2 个专门处理相关任务的 Goroutine；不过如果主机是 3 核或者 6 核，因为无法被 4 整除，所以这时需要 0 个或者 1 个专门处理垃圾收集的 Goroutine，运行时需要占用某个 CPU 的部分时间，使用 gcMarkWorkerFractionalMode 模式的协程保证 CPU 的利用率。</p>
<p>正常情况下gc的CPU占用会被约束在25%，超过25%的话，应用协程经常被征用去做mark assist，应用延迟会变高</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201214182615.png" alt=""></p>
<p>三种不同模式的工作协程会相互协同保证垃圾收集的 CPU 利用率达到期望的阈值，在到达目标堆大小前完成标记任务。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// startCycle resets the GC controller&#39;s state and computes estimates
</span><span class="c1">// for a new GC cycle. The caller must hold worldsema.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gcControllerState</span><span class="p">)</span> <span class="nf">startCycle</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">scanWork</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">bgScanCredit</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">assistTime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkTime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">fractionalMarkTime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">idleMarkTime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 确保next_gc和heap_live之间最少有1MB
</span><span class="c1"></span>	<span class="c1">// Ensure that the heap goal is at least a little larger than
</span><span class="c1"></span>	<span class="c1">// the current live heap size. This may not be the case if GC
</span><span class="c1"></span>	<span class="c1">// start is delayed or if the allocation that pushed heap_live
</span><span class="c1"></span>	<span class="c1">// over gc_trigger is large or if the trigger is really close to
</span><span class="c1"></span>	<span class="c1">// GOGC. Assist is proportional to this distance, so enforce a
</span><span class="c1"></span>	<span class="c1">// minimum distance, even if it means going over the GOGC goal
</span><span class="c1"></span>	<span class="c1">// by a tiny bit.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span> <span class="p">&lt;</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="o">+</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span> <span class="p">{</span>
		<span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span> <span class="p">=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span> <span class="o">+</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span>
	<span class="p">}</span>

	<span class="c1">// 计算可以同时执行的后台标记任务的数量
</span><span class="c1"></span>	<span class="c1">// dedicatedMarkWorkersNeeded等于P的数量的25%去除小数点
</span><span class="c1"></span>	<span class="c1">// 如果可以整除则fractionalMarkWorkersNeeded等于0否则等于1
</span><span class="c1"></span>	<span class="c1">// totalUtilizationGoal是GC所占的P的目标值(例如P一共有5个时目标是1.25个P)
</span><span class="c1"></span>	<span class="c1">// fractionalUtilizationGoal是Fractiona模式的任务所占的P的目标值(例如P一共有5个时目标是0.25个P)
</span><span class="c1"></span>	<span class="c1">// Compute the background mark utilization goal. In general,
</span><span class="c1"></span>	<span class="c1">// this may not come out exactly. We round the number of
</span><span class="c1"></span>	<span class="c1">// dedicated workers so that the utilization is closest to
</span><span class="c1"></span>	<span class="c1">// 25%. For small GOMAXPROCS, this would introduce too much
</span><span class="c1"></span>	<span class="c1">// error, so we add fractional workers in that case.
</span><span class="c1"></span>	<span class="nx">totalUtilizationGoal</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span> <span class="o">*</span> <span class="nx">gcBackgroundUtilization</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">totalUtilizationGoal</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
	<span class="nx">utilError</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">)</span><span class="o">/</span><span class="nx">totalUtilizationGoal</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="kd">const</span> <span class="nx">maxUtilError</span> <span class="p">=</span> <span class="mf">0.3</span>
	<span class="k">if</span> <span class="nx">utilError</span> <span class="p">&lt;</span> <span class="o">-</span><span class="nx">maxUtilError</span> <span class="o">||</span> <span class="nx">utilError</span> <span class="p">&gt;</span> <span class="nx">maxUtilError</span> <span class="p">{</span>
		<span class="c1">// Rounding put us more than 30% off our goal. With
</span><span class="c1"></span>		<span class="c1">// gcBackgroundUtilization of 25%, this happens for
</span><span class="c1"></span>		<span class="c1">// GOMAXPROCS&lt;=3 or GOMAXPROCS=6. Enable fractional
</span><span class="c1"></span>		<span class="c1">// workers to compensate.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">totalUtilizationGoal</span> <span class="p">{</span>
			<span class="c1">// Too many dedicated workers.
</span><span class="c1"></span>			<span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="o">--</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span> <span class="p">=</span> <span class="p">(</span><span class="nx">totalUtilizationGoal</span> <span class="o">-</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">))</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="c1">// In STW mode, we just want dedicated workers.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gcstoptheworld</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="c1">// 重置P中的辅助GC所用的时间统计
</span><span class="c1"></span>	<span class="c1">// Clear per-P state
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">gcAssistTime</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">gcFractionalMarkTime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="c1">// 计算辅助GC的参数
</span><span class="c1"></span>	<span class="c1">// 参考上面对计算assistWorkPerByte的公式的分析
</span><span class="c1"></span>	<span class="c1">// Compute initial values for controls that are updated
</span><span class="c1"></span>	<span class="c1">// throughout the cycle.
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nf">revise</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gcpacertrace</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;pacer: assist ratio=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">assistWorkPerByte</span><span class="p">,</span>
			<span class="s">&#34; (scan &#34;</span><span class="p">,</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_scan</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34; MB in &#34;</span><span class="p">,</span>
			<span class="nx">work</span><span class="p">.</span><span class="nx">initialHeapLive</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34;-&gt;&#34;</span><span class="p">,</span>
			<span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34; MB)&#34;</span><span class="p">,</span>
			<span class="s">&#34; workers=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">,</span>
			<span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="setgcphase">setGCPhase</h4>
<p>setGCPhase函数会修改表示当前GC阶段的全局变量和是否开启写屏障的全局变量:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">setGCPhase</span><span class="p">(</span><span class="nx">x</span> <span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcphase</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
	<span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">needed</span> <span class="p">=</span> <span class="nx">gcphase</span> <span class="o">==</span> <span class="nx">_GCmark</span> <span class="o">||</span> <span class="nx">gcphase</span> <span class="o">==</span> <span class="nx">_GCmarktermination</span>
	<span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">=</span> <span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">needed</span> <span class="o">||</span> <span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">cgo</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>写屏障是保证 Go 语言并发标记安全不可或缺的技术，我们需要使用混合写屏障维护对象图的弱三色不变性，然而写屏障的实现需要编译器和运行时的共同协作。在 SSA 中间代码生成阶段，编译器会使用 cmd/compile/internal/ssa.writebarrier 函数在 Store、Move 和 Zero 操作中加入写屏障，生成如下所示的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
  <span class="nf">gcWriteBarrier</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="o">*</span><span class="nx">ptr</span> <span class="p">=</span> <span class="nx">val</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当 Go 语言进入垃圾收集阶段时，全局变量 runtime.writeBarrier 中的 enabled 字段会被置成开启，所有的写操作都会调用 runtime.gcWriteBarrier：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">TEXT</span> <span class="n">runtime</span>·<span class="nf">gcWriteBarrier</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span><span class="n">NOSPLIT</span><span class="p">,</span><span class="o">$</span><span class="m">28</span>
	<span class="kc">...</span>
	<span class="nf">get_tls</span><span class="p">(</span><span class="n">BX</span><span class="p">)</span>
	<span class="n">MOVL</span>	<span class="nf">g</span><span class="p">(</span><span class="n">BX</span><span class="p">),</span> <span class="n">BX</span>
	<span class="n">MOVL</span>	<span class="nf">g_m</span><span class="p">(</span><span class="n">BX</span><span class="p">),</span> <span class="n">BX</span>
	<span class="n">MOVL</span>	<span class="nf">m_p</span><span class="p">(</span><span class="n">BX</span><span class="p">),</span> <span class="n">BX</span>
	<span class="nf">MOVL	</span><span class="p">(</span><span class="n">p_wbBuf</span><span class="o">+</span><span class="n">wbBuf_next</span><span class="p">)(</span><span class="n">BX</span><span class="p">),</span> <span class="n">CX</span>
	<span class="n">LEAL</span>	<span class="m">8</span><span class="p">(</span><span class="n">CX</span><span class="p">),</span> <span class="n">CX</span>
	<span class="n">MOVL</span>	<span class="n">CX</span><span class="p">,</span> <span class="p">(</span><span class="n">p_wbBuf</span><span class="o">+</span><span class="n">wbBuf_next</span><span class="p">)(</span><span class="n">BX</span><span class="p">)</span>
	<span class="n">CMPL</span>	<span class="n">CX</span><span class="p">,</span> <span class="p">(</span><span class="n">p_wbBuf</span><span class="o">+</span><span class="n">wbBuf_end</span><span class="p">)(</span><span class="n">BX</span><span class="p">)</span>
	<span class="n">MOVL</span>	<span class="n">AX</span><span class="p">,</span> <span class="m">-8</span><span class="p">(</span><span class="n">CX</span><span class="p">)</span>	<span class="o">//</span> 记录值
	<span class="nf">MOVL	</span><span class="p">(</span><span class="n">DI</span><span class="p">),</span> <span class="n">BX</span>
	<span class="n">MOVL</span>	<span class="n">BX</span><span class="p">,</span> <span class="m">-4</span><span class="p">(</span><span class="n">CX</span><span class="p">)</span>	<span class="o">//</span> 记录 <span class="o">*</span><span class="n">slot</span>
	<span class="n">JEQ</span>	<span class="n">flush</span>
<span class="n">ret</span><span class="o">:</span>
	<span class="n">MOVL</span>	<span class="m">20</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">CX</span>
	<span class="n">MOVL</span>	<span class="m">24</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">BX</span>
	<span class="n">MOVL</span>	<span class="n">AX</span><span class="p">,</span> <span class="p">(</span><span class="n">DI</span><span class="p">)</span> <span class="o">//</span> 触发写操作
	<span class="n">RET</span>

<span class="n">flush</span><span class="o">:</span>
  <span class="kc">...</span>
	<span class="n">CALL</span>	<span class="n">runtime</span>·<span class="nf">wbBufFlush</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
  <span class="kc">...</span>
	<span class="n">JMP</span>	<span class="n">ret</span>
</code></pre></td></tr></table>
</div>
</div><p>在上述汇编函数中，DI 寄存器是写操作的目的地址，AX 寄存器中存储了被覆盖的值，该函数会覆盖原来的值并通过 runtime.wbBufFlush 通知垃圾收集器将原值和新值加入当前处理器的工作队列，因为该写屏障的实现比较复杂，所以写屏障对程序的性能还是有比较大的影响，之前只需要一条指令完成的工作，现在需要几十条指令。</p>
<p>我们在上面提到过 Dijkstra 和 Yuasa 写屏障组成的混合写屏障在开启后，所有新创建的对象都需要被直接涂成黑色，这里的标记过程是由 runtime.gcmarknewobject 完成的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="p">{</span>
		<span class="nf">gcmarknewobject</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">scanSize</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">gcmarknewobject</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">scanSize</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">markBitsForAddr</span><span class="p">(</span><span class="nx">obj</span><span class="p">).</span><span class="nf">setMarked</span><span class="p">()</span>
	<span class="nx">gcw</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">gcw</span>
	<span class="nx">gcw</span><span class="p">.</span><span class="nx">bytesMarked</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>
	<span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="o">+=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">scanSize</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime.mallocgc 会在垃圾收集开始后调用该函数，获取对象对应的内存单元以及标记位 runtime.markBits 并调用 runtime.markBits.setMarked 直接将新的对象涂成黑色。</p>
<h4 id="gcbgmarkprepare">gcBgMarkPrepare</h4>
<p>gcBgMarkPrepare函数会重置后台标记任务的计数:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// gcBgMarkPrepare sets up state for background marking.
</span><span class="c1">// Mutator assists must not yet be enabled.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gcBgMarkPrepare</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Background marking will stop when the work queues are empty
</span><span class="c1"></span>	<span class="c1">// and there are no more workers (note that, since this is
</span><span class="c1"></span>	<span class="c1">// concurrent, this may be a transient state, but mark
</span><span class="c1"></span>	<span class="c1">// termination will clean it up). Between background workers
</span><span class="c1"></span>	<span class="c1">// and assists, we don&#39;t really know how many workers there
</span><span class="c1"></span>	<span class="c1">// will be, so we pretend to have an arbitrarily large number
</span><span class="c1"></span>	<span class="c1">// of workers, almost all of which are &#34;waiting&#34;. While a
</span><span class="c1"></span>	<span class="c1">// worker is working it decrements nwait. If nproc == nwait,
</span><span class="c1"></span>	<span class="c1">// there are no workers.
</span><span class="c1"></span>	<span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span> <span class="p">=</span> <span class="p">^</span><span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">nwait</span> <span class="p">=</span> <span class="p">^</span><span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="gcmarkrootprepare">gcMarkRootPrepare</h4>
<p>gcMarkRootPrepare函数会计算扫描根对象的任务数量:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// gcMarkRootPrepare queues root scanning jobs (stacks, globals, and
</span><span class="c1">// some miscellany) and initializes scanning-related state.
</span><span class="c1">//
</span><span class="c1">// The world must be stopped.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gcMarkRootPrepare</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">nFlushCacheRoots</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 计算block数量的函数, rootBlockBytes是256KB
</span><span class="c1"></span>	<span class="c1">// Compute how many data and BSS root blocks there are.
</span><span class="c1"></span>	<span class="nx">nBlocks</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">bytes</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nf">divRoundUp</span><span class="p">(</span><span class="nx">bytes</span><span class="p">,</span> <span class="nx">rootBlockBytes</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="nx">work</span><span class="p">.</span><span class="nx">nDataRoots</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">nBSSRoots</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="c1">// Scan globals.
</span><span class="c1"></span>	<span class="c1">// 计算扫描可读写的全局变量的任务数量
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">datap</span> <span class="o">:=</span> <span class="k">range</span> <span class="nf">activeModules</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">nDataRoots</span> <span class="o">:=</span> <span class="nf">nBlocks</span><span class="p">(</span><span class="nx">datap</span><span class="p">.</span><span class="nx">edata</span> <span class="o">-</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">nDataRoots</span> <span class="p">&gt;</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nDataRoots</span> <span class="p">{</span>
			<span class="nx">work</span><span class="p">.</span><span class="nx">nDataRoots</span> <span class="p">=</span> <span class="nx">nDataRoots</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 计算扫描只读的全局变量的任务数量
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">datap</span> <span class="o">:=</span> <span class="k">range</span> <span class="nf">activeModules</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">nBSSRoots</span> <span class="o">:=</span> <span class="nf">nBlocks</span><span class="p">(</span><span class="nx">datap</span><span class="p">.</span><span class="nx">ebss</span> <span class="o">-</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">bss</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">nBSSRoots</span> <span class="p">&gt;</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nBSSRoots</span> <span class="p">{</span>
			<span class="nx">work</span><span class="p">.</span><span class="nx">nBSSRoots</span> <span class="p">=</span> <span class="nx">nBSSRoots</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Scan span roots for finalizer specials.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// We depend on addfinalizer to mark objects that get
</span><span class="c1"></span>	<span class="c1">// finalizers after root marking.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">go115NewMarkrootSpans</span> <span class="p">{</span>
		<span class="c1">// We&#39;re going to scan the whole heap (that was available at the time the
</span><span class="c1"></span>		<span class="c1">// mark phase started, i.e. markArenas) for in-use spans which have specials.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// Break up the work into arenas, and further into chunks.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// Snapshot allArenas as markArenas. This snapshot is safe because allArenas
</span><span class="c1"></span>		<span class="c1">// is append-only.
</span><span class="c1"></span>		<span class="nx">mheap_</span><span class="p">.</span><span class="nx">markArenas</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">):</span><span class="nb">len</span><span class="p">(</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">)]</span>
		<span class="nx">work</span><span class="p">.</span><span class="nx">nSpanRoots</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">markArenas</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">pagesPerArena</span> <span class="o">/</span> <span class="nx">pagesPerSpanRoot</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// We&#39;re only interested in scanning the in-use spans,
</span><span class="c1"></span>		<span class="c1">// which will all be swept at this point. More spans
</span><span class="c1"></span>		<span class="c1">// may be added to this list during concurrent GC, but
</span><span class="c1"></span>		<span class="c1">// we only care about spans that were allocated before
</span><span class="c1"></span>		<span class="c1">// this mark phase.
</span><span class="c1"></span>		<span class="nx">work</span><span class="p">.</span><span class="nx">nSpanRoots</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="o">/</span><span class="mi">2</span><span class="o">%</span><span class="mi">2</span><span class="p">].</span><span class="nf">numBlocks</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// Scan stacks.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Gs may be created after this point, but it&#39;s okay that we
</span><span class="c1"></span>	<span class="c1">// ignore them because they begin life without any roots, so
</span><span class="c1"></span>	<span class="c1">// there&#39;s nothing to scan, and any roots they create during
</span><span class="c1"></span>	<span class="c1">// the concurrent phase will be scanned during mark
</span><span class="c1"></span>	<span class="c1">// termination.
</span><span class="c1"></span>	<span class="nx">work</span><span class="p">.</span><span class="nx">nStackRoots</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Loaduintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allglen</span><span class="p">))</span>
	<span class="c1">// 计算总任务数量
</span><span class="c1"></span>	<span class="c1">// 后台标记任务会对markrootNext进行原子递增, 来决定做哪个任务
</span><span class="c1"></span>	<span class="c1">// 这种用数值来实现锁自由队列的办法挺聪明的, 尽管google工程师觉得不好(看后面markroot函数的分析)
</span><span class="c1"></span>	<span class="nx">work</span><span class="p">.</span><span class="nx">markrootNext</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">markrootJobs</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">fixedRootCount</span> <span class="o">+</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nFlushCacheRoots</span> <span class="o">+</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nDataRoots</span> <span class="o">+</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nBSSRoots</span> <span class="o">+</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nSpanRoots</span> <span class="o">+</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nStackRoots</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="gcmarktinyallocs">gcMarkTinyAllocs</h4>
<p>gcMarkTinyAllocs函数会标记所有tiny alloc等待合并的对象:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// gcMarkTinyAllocs greys all active tiny alloc blocks.
</span><span class="c1">//
</span><span class="c1">// The world must be stopped.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gcMarkTinyAllocs</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
		<span class="nx">c</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">mcache</span>
		<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// 标记各个P中的mcache中的tiny
</span><span class="c1"></span>		<span class="c1">// 在上面的mallocgc函数中可以看到tiny是当前等待合并的对象
</span><span class="c1"></span>		<span class="nx">_</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">objIndex</span> <span class="o">:=</span> <span class="nf">findObject</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="nx">gcw</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">gcw</span>
		<span class="c1">// 标记一个对象存活, 并把它加到标记队列(该对象变为灰色)
</span><span class="c1"></span>		<span class="nf">greyobject</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="nx">objIndex</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="starttheworldwithsema">startTheWorldWithSema</h4>
<p>startTheWorldWithSema函数会重新启动世界:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">startTheWorldWithSema</span><span class="p">(</span><span class="nx">emitTraceEvent</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span> <span class="c1">// disable preemption because it can be holding p in a local var
</span><span class="c1"></span>	<span class="c1">// 调用 runtime.netpoll 从网络轮询器中获取待处理的任务并加入全局队列；
</span><span class="c1"></span>	<span class="c1">// 判断收到的网络事件(fd可读可写或错误)并添加对应的G到待运行队列
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">netpollinited</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">list</span> <span class="o">:=</span> <span class="nf">netpoll</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// non-blocking
</span><span class="c1"></span>		<span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">// 如果要求改变gomaxprocs则调整P的数量
</span><span class="c1"></span>	<span class="c1">// procresize会返回有可运行任务的P的链表
</span><span class="c1"></span>	<span class="nx">procs</span> <span class="o">:=</span> <span class="nx">gomaxprocs</span>
	<span class="k">if</span> <span class="nx">newprocs</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">procs</span> <span class="p">=</span> <span class="nx">newprocs</span>
		<span class="nx">newprocs</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="c1">//调用 runtime.procresize 扩容或者缩容全局的处理器；
</span><span class="c1"></span>	<span class="nx">p1</span> <span class="o">:=</span> <span class="nf">procresize</span><span class="p">(</span><span class="nx">procs</span><span class="p">)</span>
	<span class="c1">// 取消GC等待标记
</span><span class="c1"></span>	<span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 如果sysmon在等待则唤醒它
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonnote</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">// 唤醒有可运行任务的P
</span><span class="c1"></span>	<span class="c1">//调用 runtime.notewakeup 或者 runtime.newm 依次唤醒处理器或者为处理器创建新的线程；
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">p1</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">p1</span>
		<span class="nx">p1</span> <span class="p">=</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">link</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">mp</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;startTheWorld: inconsistent mp-&gt;nextp&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
			<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// Start M to run P.  Do not start another M below.
</span><span class="c1"></span>			<span class="nf">newm</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Capture start-the-world time before doing clean-up tasks.
</span><span class="c1"></span>	<span class="nx">startTime</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">emitTraceEvent</span> <span class="p">{</span>
		<span class="nf">traceGCSTWDone</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// Wakeup an additional proc in case we have excessive runnable goroutines
</span><span class="c1"></span>	<span class="c1">// in local queues or in the global queue. If we don&#39;t, the proc will park itself.
</span><span class="c1"></span>	<span class="c1">// If we have lots of excessive work, resetspinning will unpark additional procs as necessary.
</span><span class="c1"></span>	<span class="c1">//如果当前待处理的 Goroutine 数量过多，创建额外的处理器辅助完成任务；
</span><span class="c1"></span>	<span class="nf">wakep</span><span class="p">()</span>

	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">startTime</span>
<span class="p">}</span>

<span class="c1">// Tries to add one more P to execute G&#39;s.
</span><span class="c1">// Called when a G is made runnable (newproc, ready).
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">wakep</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// be conservative about spinning threads
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nf">startm</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>重启世界后各个M会重新开始调度, 调度时会优先使用findRunnableGCWorker函数查找任务, 之后就有大约25%的P运行后台标记任务.</p>
<h3 id="并发扫描与标记辅助">并发扫描与标记辅助</h3>
<p>标记对象从哪里来?</p>
<ul>
<li>gcMarkWorker</li>
<li>Markassist</li>
<li>mutatorwrite/deleteheappointers</li>
</ul>
<p>标记对象到哪里去?</p>
<ul>
<li>Workbuffer</li>
<li>本地workbuffer=&gt;p.gcw</li>
<li>全局workbuffer=&gt;runtime.work.full • Write barrier buffer</li>
<li>本地writebarrierbuffer=&gt;p.wbBuf</li>
</ul>
<p>在调用 runtime.gcDrain 函数时，运行时会传入处理器上的 runtime.gcWork，这个结构体是垃圾收集器中工作池的抽象，它实现了一个生产者和消费者的模型，我们可以以该结构体为起点从整体理解标记工作：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201214202916.png" alt=""></p>
<p>写屏障、根对象扫描和栈扫描都会向工作池中增加额外的灰色对象等待处理，而对象的扫描过程会将灰色对象标记成黑色，同时也可能发现新的灰色对象，当工作队列中不包含灰色对象时，整个扫描过程就会结束。</p>
<p>为了减少锁竞争，运行时在每个处理器上会保存独立的待扫描工作，然而这会遇到与调度器一样的问题 — 不同处理器的资源不平均，导致部分处理器无事可做，调度器引入了工作窃取来解决这个问题，垃圾收集器也使用了差不多的机制平衡不同处理器上的待处理任务。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201214203044.png" alt=""></p>
<p>runtime.gcWork.balance 方法会将处理器本地一部分工作放回全局队列中，让其他的处理器处理，保证不同处理器负载的平衡。</p>
<p>runtime.gcWork 为垃圾收集器提供了生产和消费任务的抽象，该结构体持有了两个重要的工作缓冲区 wbuf1 和 wbuf2，这两个缓冲区分别是主缓冲区和备缓冲区：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">gcWork</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">wbuf1</span><span class="p">,</span> <span class="nx">wbuf2</span> <span class="o">*</span><span class="nx">workbuf</span>
	<span class="o">...</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">workbufhdr</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">node</span> <span class="nx">lfnode</span> <span class="c1">// must be first
</span><span class="c1"></span>	<span class="nx">nobj</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">workbuf</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">workbufhdr</span>
	<span class="nx">obj</span> <span class="p">[(</span><span class="nx">_WorkbufSize</span> <span class="o">-</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">workbufhdr</span><span class="p">{}))</span> <span class="o">/</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">]</span><span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当我们向该结构体中增加或者删除对象时，它总会先操作主缓冲区，一旦主缓冲区空间不足或者没有对象，就会触发主备缓冲区的切换；而当两个缓冲区空间都不足或者都为空时，会从全局的工作缓冲区中插入或者获取对象，该结构体相关方法的实现都非常简单，这里就不展开分析了。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210818212833.png" alt=""></p>
<p>运行时会使用 runtime.gcDrain 函数扫描工作缓冲区中的灰色对象，它会根据传入 gcDrainFlags 的不同选择不同的策略：</p>
<p>gcDrain 这个函数就是从队列里不断获取，处理这些对象，最重要的一个就是调用 scanobject 继续扫描对象。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201227003549.png" alt=""></p>
<p>markroot 从根（栈）扫描，把扫描到的对象投入扫描队列。gcDrain 等函数从里面不断获取，不断处理，并且扫描这些对象，进一步挖掘引用关系，当扫描结束之后，那些没有扫描到的就是垃圾了。</p>
<h4 id="findrunnablegcworker">findRunnableGCWorker</h4>
<p>调度器在调度循环 runtime.schedule 中可以通过垃圾收集控制器的 findRunnableGCWorker 方法获取并执行用于后台标记的任务。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// One round of scheduler: find a runnable goroutine and execute it.
</span><span class="c1">// Never returns.
</span><span class="c1">// 执行一轮调度器的工作：找到一个 runnable 的 goroutine，并且执行它
</span><span class="c1">// 永不返回
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">schedule</span><span class="p">()</span> <span class="p">{</span>
	<span class="o">...</span>
<span class="nx">top</span><span class="p">:</span>
	<span class="c1">//如果GC处于等待状态,停止M,等待GC完成被唤醒
</span><span class="c1"></span>	<span class="c1">//准备进入GC STW,休眠
</span><span class="c1"></span>	<span class="c1">//判断是否有串行运行时任务正在等待执行，判断依据就是调度器的gcwaiting字段是否为0。如果
</span><span class="c1"></span>	<span class="c1">//gcwaiting不为0，则停止并阻塞当前M直到串行运行时任务结束，才继续执行后面的调度动作。
</span><span class="c1"></span>	<span class="c1">//串行运行时任务执行时需要停止Go的调度器，官方称此操作为Stop the world，简称STW。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">gcstopm</span><span class="p">()</span>
		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">runSafePointFn</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">runSafePointFn</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">//接下来就是寻找可运行G的过程。首先试图获取执行踪迹读取任务的G。
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span>
	<span class="c1">//当从P.next提取G时,inheritTime = true
</span><span class="c1"></span>	<span class="c1">//不累加P.schedtick计数,使得它延长本地队列处理时间
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">inheritTime</span> <span class="kt">bool</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="o">||</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">shutdown</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="p">=</span> <span class="nf">traceReader</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
			<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//未果，试图获取执行GC标记任务的G。
</span><span class="c1"></span>	<span class="c1">//进入GC MarkWorker工作模式
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="p">=</span> <span class="nx">gcController</span><span class="p">.</span><span class="nf">findRunnableGCWorker</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>垃圾收集控制器会在 runtime.gcControllerState.findRunnableGCWorker 方法中设置处理器的 gcMarkWorkerMode：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// findRunnableGCWorker returns the background mark worker for _p_ if it
</span><span class="c1">// should be run. This must only be called when gcBlackenEnabled != 0.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gcControllerState</span><span class="p">)</span> <span class="nf">findRunnableGCWorker</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gcControllerState.findRunnable: blackening not enabled&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// The mark worker associated with this P is blocked
</span><span class="c1"></span>		<span class="c1">// performing a mark transition. We can&#39;t run it
</span><span class="c1"></span>		<span class="c1">// because it may be on some other run or wait queue.
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">!</span><span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// No work to be done right now. This can happen at
</span><span class="c1"></span>		<span class="c1">// the end of the mark phase when there are still
</span><span class="c1"></span>		<span class="c1">// assists tapering off. Don&#39;t bother running a worker
</span><span class="c1"></span>		<span class="c1">// now because it&#39;ll just return immediately.
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="c1">// 原子减少对应的值, 如果减少后大于等于0则返回true, 否则返回false
</span><span class="c1"></span>	<span class="nx">decIfPositive</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ptr</span> <span class="o">*</span><span class="kt">int64</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">if</span> <span class="o">*</span><span class="nx">ptr</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">true</span>
			<span class="p">}</span>
			<span class="c1">// We lost a race
</span><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">// 减少dedicatedMarkWorkersNeeded, 成功时后台标记任务的模式是Dedicated
</span><span class="c1"></span>	<span class="c1">// dedicatedMarkWorkersNeeded是当前P的数量的25%去除小数点
</span><span class="c1"></span>	<span class="c1">// 详见startCycle函数
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">decIfPositive</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// This P is now dedicated to marking until the end of
</span><span class="c1"></span>		<span class="c1">// the concurrent mark phase.
</span><span class="c1"></span>		<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">=</span> <span class="nx">gcMarkWorkerDedicatedMode</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// No need for fractional workers.
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// Is this P behind on the fractional utilization
</span><span class="c1"></span>		<span class="c1">// goal?
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// This should be kept in sync with pollFractionalWorkerExit.
</span><span class="c1"></span>		<span class="c1">// 减少fractionalMarkWorkersNeeded, 成功是后台标记任务的模式是Fractional
</span><span class="c1"></span>		<span class="c1">// 上面的计算如果小数点后有数值(不能够整除)则fractionalMarkWorkersNeeded为1, 否则为0
</span><span class="c1"></span>		<span class="c1">// 详见startCycle函数
</span><span class="c1"></span>		<span class="c1">// 举例来说, 4个P时会执行1个Dedicated模式的任务, 5个P时会执行1个Dedicated模式和1个Fractional模式的任务
</span><span class="c1"></span>		<span class="nx">delta</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">-</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">markStartTime</span>
		<span class="k">if</span> <span class="nx">delta</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcFractionalMarkTime</span><span class="p">)</span><span class="o">/</span><span class="nb">float64</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span> <span class="p">{</span>
			<span class="c1">// Nope. No need to run a fractional worker.
</span><span class="c1"></span>			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="c1">// Run a fractional worker.
</span><span class="c1"></span>		<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">=</span> <span class="nx">gcMarkWorkerFractionalMode</span>
	<span class="p">}</span>
	<span class="c1">// 安排后台标记任务执行
</span><span class="c1"></span>	<span class="c1">// Run the background mark worker
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">gp</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>控制器通过 dedicatedMarkWorkersNeeded 决定专门执行标记任务的 Goroutine 数量并根据执行标记任务的时间和总时间决定是否启动 gcMarkWorkerFractionalMode 模式的 Goroutine.</p>
<h4 id="findrunnable">findrunnable</h4>
<p>除了这两种控制器要求的工作协程之外，调度器还会在 findrunnable 函数中利用空闲的处理器执行垃圾收集以加速该过程：</p>
<p>当垃圾收集处于标记阶段并且当前处理器不需要做任何任务时，runtime.findrunnable 函数会在当前处理器上执行该 Goroutine 辅助并发的对象标记：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// Finds a runnable goroutine to execute.
</span><span class="c1">// Tries to steal from other P&#39;s, get g from global queue, poll network.
</span><span class="c1">// 寻找一个可运行的 Goroutine 来执行。
</span><span class="c1">// 尝试从其他的 P 偷取、从全局队列中获取、poll 网络
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">findrunnable</span><span class="p">()</span> <span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">top</span><span class="p">:</span>
	<span class="c1">//1. 获取执行GC标记任务的G。如果恰巧正处于GC标记阶段，且本地P可用于GC标记任务。
</span><span class="c1"></span>	<span class="c1">//那么调度器会把本地P持有的GC标记专用G置为Grunnable状态并返回这个G。
</span><span class="c1"></span>	<span class="c1">//检查GC MarkWorker
</span><span class="c1"></span>	<span class="c1">// We have nothing to do. If we&#39;re in the GC mark phase, can
</span><span class="c1"></span>	<span class="c1">// safely scan and blacken objects, and have work to do, run
</span><span class="c1"></span>	<span class="c1">// idle-time marking rather than give up the P.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">=</span> <span class="nx">gcMarkWorkerIdleMode</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="c1">//获取用于GC标记的专用G
</span><span class="c1"></span>		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span><span class="c1">//将gp并发安全的从Gwaiting状态转为Grunnable状态
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
			<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="o">...</span>
	<span class="c1">//4. 再次获取执行GC标记任务的G。如果正好处于GC标记阶段，且GC标记任务相关的全局资源可用。调度器就从空闲P列表中取出一个P，如果这个P持有GC标记专用G，就将该P与当前M关联，并从第二阶段开始继续执行。否则该P会被重新放回空闲P列表。
</span><span class="c1"></span>	<span class="c1">// Check for idle-priority GC work again.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nx">_p_</span> <span class="p">=</span> <span class="nf">pidleget</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">pidleput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
			<span class="nx">_p_</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">wasSpinning</span> <span class="p">{</span>
				<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// Go back to idle GC check.
</span><span class="c1"></span>			<span class="k">goto</span> <span class="nx">stop</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">...</span>
	<span class="k">goto</span> <span class="nx">top</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">p</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">work</span><span class="p">.</span><span class="nx">full</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span> <span class="c1">// global work available
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">markrootNext</span> <span class="p">&lt;</span> <span class="nx">work</span><span class="p">.</span><span class="nx">markrootJobs</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span> <span class="c1">// root scan work available
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="gcbgmarkworker">gcBgMarkWorker</h4>
<p>runtime.gcBgMarkWorker 是后台的标记任务执行的函数，该函数的循环中执行了对内存中对象图的扫描和标记，我们分三个部分介绍该函数的实现原理：</p>
<ol>
<li>获取当前处理器以及 Goroutine 打包成 parkInfo 类型的结构体并主动陷入休眠等待唤醒；</li>
<li>根据处理器上的 gcMarkWorkerMode 模式决定扫描任务的策略；</li>
<li>所有标记任务都完成后，调用 runtime.gcMarkDone 方法完成标记阶段；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">gcDrainUntilPreempt</span> <span class="nx">gcDrainFlags</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span>
	<span class="nx">gcDrainFlushBgCredit</span>
	<span class="nx">gcDrainIdle</span>
	<span class="nx">gcDrainFractional</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">gcBgMarkWorker</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="c1">//首先我们来看后台标记任务的准备工作，运行时在这里创建了一个 parkInfo 结构体，该结构体会预先存储处理器和当前 Goroutine，
</span><span class="c1"></span>	<span class="c1">// 用于休眠后重新获取P的构造体
</span><span class="c1"></span>	<span class="kd">type</span> <span class="nx">parkInfo</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">m</span>      <span class="nx">muintptr</span> <span class="c1">// Release this m on park.
</span><span class="c1"></span>		<span class="nx">attach</span> <span class="nx">puintptr</span> <span class="c1">// If non-nil, attach to this p on park.
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="c1">// We pass park to a gopark unlock function, so it can&#39;t be on
</span><span class="c1"></span>	<span class="c1">// the stack (see gopark). Prevent deadlock from recursively
</span><span class="c1"></span>	<span class="c1">// starting GC by disabling preemption.
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;GC worker init&#34;</span>
	<span class="nx">park</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">parkInfo</span><span class="p">)</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>
	<span class="c1">// 设置当前的M并禁止抢占
</span><span class="c1"></span>	<span class="nx">park</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nf">acquirem</span><span class="p">())</span>
	<span class="c1">// 设置当前的P(需要关联到的P)
</span><span class="c1"></span>	<span class="nx">park</span><span class="p">.</span><span class="nx">attach</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="c1">// Inform gcBgMarkStartWorkers that this worker is ready.
</span><span class="c1"></span>	<span class="c1">// After this point, the background mark worker is scheduled
</span><span class="c1"></span>	<span class="c1">// cooperatively by gcController.findRunnable. Hence, it must
</span><span class="c1"></span>	<span class="c1">// never be preempted, as this would put it into _Grunnable
</span><span class="c1"></span>	<span class="c1">// and put it on a run queue. Instead, when the preempt flag
</span><span class="c1"></span>	<span class="c1">// is set, this puts itself into _Gwaiting to be woken up by
</span><span class="c1"></span>	<span class="c1">// gcController.findRunnable at the appropriate time.
</span><span class="c1"></span>	<span class="c1">// 通知gcBgMarkStartWorkers可以继续处理
</span><span class="c1"></span>	<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">bgMarkReady</span><span class="p">)</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// 让当前G进入休眠
</span><span class="c1"></span>		<span class="c1">// Go to sleep until woken by gcController.findRunnable.
</span><span class="c1"></span>		<span class="c1">// We can&#39;t releasem yet since even the call to gopark
</span><span class="c1"></span>		<span class="c1">// may be preempted.
</span><span class="c1"></span>		<span class="c1">//当我们调用 runtime.gopark 触发休眠时，运行时会在系统栈中安全地建立处理器和后台标记任务的绑定关系
</span><span class="c1"></span>
		<span class="nf">gopark</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">parkp</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
			<span class="nx">park</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">parkInfo</span><span class="p">)(</span><span class="nx">parkp</span><span class="p">)</span>

			<span class="c1">// The worker G is no longer running, so it&#39;s
</span><span class="c1"></span>			<span class="c1">// now safe to allow preemption.
</span><span class="c1"></span>			<span class="c1">// 允许G被抢占
</span><span class="c1"></span>			<span class="nf">releasem</span><span class="p">(</span><span class="nx">park</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
			<span class="c1">// 设置关联的P
</span><span class="c1"></span>			<span class="c1">// 把当前的G设到P的gcBgMarkWorker成员, 下次findRunnableGCWorker会使用
</span><span class="c1"></span>			<span class="c1">// 设置失败时不休眠
</span><span class="c1"></span>			<span class="c1">// If the worker isn&#39;t attached to its P,
</span><span class="c1"></span>			<span class="c1">// attach now. During initialization and after
</span><span class="c1"></span>			<span class="c1">// a phase change, the worker may have been
</span><span class="c1"></span>			<span class="c1">// running on a different P. As soon as we
</span><span class="c1"></span>			<span class="c1">// attach, the owner P may schedule the
</span><span class="c1"></span>			<span class="c1">// worker, so this must be done after the G is
</span><span class="c1"></span>			<span class="c1">// stopped.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">park</span><span class="p">.</span><span class="nx">attach</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">p</span> <span class="o">:=</span> <span class="nx">park</span><span class="p">.</span><span class="nx">attach</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
				<span class="nx">park</span><span class="p">.</span><span class="nx">attach</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
				<span class="c1">// cas the worker because we may be
</span><span class="c1"></span>				<span class="c1">// racing with a new worker starting
</span><span class="c1"></span>				<span class="c1">// on this P.
</span><span class="c1"></span>				<span class="k">if</span> <span class="p">!</span><span class="nx">p</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">g</span><span class="p">)))</span> <span class="p">{</span>
					<span class="c1">// The P got a new worker.
</span><span class="c1"></span>					<span class="c1">// Exit this worker.
</span><span class="c1"></span>					<span class="k">return</span> <span class="kc">false</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">},</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">park</span><span class="p">),</span> <span class="nx">waitReasonGCWorkerIdle</span><span class="p">,</span> <span class="nx">traceEvGoBlock</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="c1">//通过 runtime.gopark 陷入休眠的 Goroutine 不会进入运行队列，它只会等待垃圾收集控制器或者调度器的直接唤醒；在休眠后，我们会根据处理器 gcMarkWorkerMode 选择不同的标记执行策略，不同的执行策略都会调用 runtime.gcDrain 扫描工作缓冲区 runtime.gcWork：
</span><span class="c1"></span>		<span class="c1">// Loop until the P dies and disassociates this
</span><span class="c1"></span>		<span class="c1">// worker (the P may later be reused, in which case
</span><span class="c1"></span>		<span class="c1">// it will get a new worker) or we failed to associate.
</span><span class="c1"></span>		<span class="c1">// 检查P的gcBgMarkWorker是否和当前的G一致, 不一致时结束当前的任务
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">gp</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="c1">// 禁止M被抢占
</span><span class="c1"></span>		<span class="c1">// Disable preemption so we can use the gcw. If the
</span><span class="c1"></span>		<span class="c1">// scheduler wants to preempt us, we&#39;ll stop draining,
</span><span class="c1"></span>		<span class="c1">// dispose the gcw, and then preempt.
</span><span class="c1"></span>		<span class="nx">park</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nf">acquirem</span><span class="p">())</span>

		<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gcBgMarkWorker: blackening not enabled&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 记录开始时间
</span><span class="c1"></span>		<span class="nx">startTime</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerStartTime</span> <span class="p">=</span> <span class="nx">startTime</span>

		<span class="nx">decnwait</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">nwait</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">decnwait</span> <span class="o">==</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span> <span class="p">{</span>
			<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: work.nwait=&#34;</span><span class="p">,</span> <span class="nx">decnwait</span><span class="p">,</span> <span class="s">&#34;work.nproc=&#34;</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;work.nwait was &gt; work.nproc&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 切换到g0运行
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// Mark our goroutine preemptible so its stack
</span><span class="c1"></span>			<span class="c1">// can be scanned. This lets two mark workers
</span><span class="c1"></span>			<span class="c1">// scan each other (otherwise, they would
</span><span class="c1"></span>			<span class="c1">// deadlock). We must not modify anything on
</span><span class="c1"></span>			<span class="c1">// the G stack. However, stack shrinking is
</span><span class="c1"></span>			<span class="c1">// disabled for mark workers, so it is safe to
</span><span class="c1"></span>			<span class="c1">// read from the G stack.
</span><span class="c1"></span>			<span class="c1">// 设置G的状态为等待中这样它的栈可以被扫描(两个后台标记任务可以互相扫描对方的栈)
</span><span class="c1"></span>			<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
			<span class="c1">// 判断后台标记任务的模式
</span><span class="c1"></span>			<span class="k">switch</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">{</span>
			<span class="k">default</span><span class="p">:</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gcBgMarkWorker: unexpected gcMarkWorkerMode&#34;</span><span class="p">)</span>
			<span class="k">case</span> <span class="nx">gcMarkWorkerDedicatedMode</span><span class="p">:</span>
				<span class="c1">//需要注意的是，gcMarkWorkerDedicatedMode 模式的任务是不能被抢占的，为了减少额外开销，第一次调用 runtime.gcDrain 方法时是允许抢占的，但是一旦处理器被抢占，当前 Goroutine会将处理器上的所有可运行的 Goroutine 转移至全局队列中，保证垃圾收集占用的 CPU 资源。
</span><span class="c1"></span>				<span class="c1">// 这个模式下P应该专心执行标记
</span><span class="c1"></span>				<span class="c1">// 执行标记, 直到被抢占, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G
</span><span class="c1"></span>				<span class="nf">gcDrain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">gcDrainUntilPreempt</span><span class="p">|</span><span class="nx">gcDrainFlushBgCredit</span><span class="p">)</span>
				<span class="c1">// 被抢占时把本地运行队列中的所有G都踢到全局运行队列
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">{</span>
					<span class="c1">// We were preempted. This is
</span><span class="c1"></span>					<span class="c1">// a useful signal to kick
</span><span class="c1"></span>					<span class="c1">// everything out of the run
</span><span class="c1"></span>					<span class="c1">// queue so it can run
</span><span class="c1"></span>					<span class="c1">// somewhere else.
</span><span class="c1"></span>					<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
					<span class="k">for</span> <span class="p">{</span>
						<span class="nx">gp</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
						<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
							<span class="k">break</span>
						<span class="p">}</span>
						<span class="nf">globrunqput</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
					<span class="p">}</span>
					<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="c1">// Go back to draining, this time
</span><span class="c1"></span>				<span class="c1">// without preemption.
</span><span class="c1"></span>				<span class="c1">// 继续执行标记, 直到无更多任务, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G
</span><span class="c1"></span>				<span class="nf">gcDrain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">gcDrainFlushBgCredit</span><span class="p">)</span>
			<span class="k">case</span> <span class="nx">gcMarkWorkerFractionalMode</span><span class="p">:</span>
				<span class="c1">// 这个模式下P应该适当执行标记
</span><span class="c1"></span>				<span class="c1">// 执行标记, 直到被抢占, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G
</span><span class="c1"></span>				<span class="nf">gcDrain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">gcDrainFractional</span><span class="p">|</span><span class="nx">gcDrainUntilPreempt</span><span class="p">|</span><span class="nx">gcDrainFlushBgCredit</span><span class="p">)</span>
			<span class="k">case</span> <span class="nx">gcMarkWorkerIdleMode</span><span class="p">:</span>
				<span class="c1">// 这个模式下P只在空闲时执行标记
</span><span class="c1"></span>				<span class="c1">// 执行标记, 直到被抢占或者达到一定的量, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G
</span><span class="c1"></span>				<span class="nf">gcDrain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">gcDrainIdle</span><span class="p">|</span><span class="nx">gcDrainUntilPreempt</span><span class="p">|</span><span class="nx">gcDrainFlushBgCredit</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 恢复G的状态到运行中
</span><span class="c1"></span>			<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
		<span class="p">})</span>
		<span class="c1">// 累加所用时间
</span><span class="c1"></span>		<span class="c1">// Account for time.
</span><span class="c1"></span>		<span class="nx">duration</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">-</span> <span class="nx">startTime</span>
		<span class="k">switch</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">gcMarkWorkerDedicatedMode</span><span class="p">:</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">dedicatedMarkTime</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">gcMarkWorkerFractionalMode</span><span class="p">:</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">fractionalMarkTime</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcFractionalMarkTime</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">gcMarkWorkerIdleMode</span><span class="p">:</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">idleMarkTime</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// Was this the last worker and did we run out
</span><span class="c1"></span>		<span class="c1">// of work?
</span><span class="c1"></span>		<span class="nx">incnwait</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">nwait</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="c1">// 判断是否所有后台标记任务都完成, 并且没有更多的任务
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">incnwait</span> <span class="p">&gt;</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span> <span class="p">{</span>
			<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: p.gcMarkWorkerMode=&#34;</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span><span class="p">,</span>
				<span class="s">&#34;work.nwait=&#34;</span><span class="p">,</span> <span class="nx">incnwait</span><span class="p">,</span> <span class="s">&#34;work.nproc=&#34;</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;work.nwait &gt; work.nproc&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// If this worker reached a background mark completion
</span><span class="c1"></span>		<span class="c1">// point, signal the main GC goroutine.
</span><span class="c1"></span>		<span class="c1">// 当所有的后台工作任务都陷入等待并且没有剩余工作时，我们就认为该轮垃圾收集的标记阶段结束了，这时我们会调用 runtime.gcMarkDone 函数：
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">incnwait</span> <span class="o">==</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Make this G preemptible and disassociate it
</span><span class="c1"></span>			<span class="c1">// as the worker for this P so
</span><span class="c1"></span>			<span class="c1">// findRunnableGCWorker doesn&#39;t try to
</span><span class="c1"></span>			<span class="c1">// schedule it.
</span><span class="c1"></span>			<span class="c1">// 取消和P的关联
</span><span class="c1"></span>			<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
			<span class="c1">// 允许G被抢占
</span><span class="c1"></span>			<span class="nf">releasem</span><span class="p">(</span><span class="nx">park</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
			<span class="c1">// 准备进入完成标记阶段
</span><span class="c1"></span>			<span class="nf">gcMarkDone</span><span class="p">()</span>

			<span class="c1">// Disable preemption and prepare to reattach
</span><span class="c1"></span>			<span class="c1">// to the P.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// We may be running on a different P at this
</span><span class="c1"></span>			<span class="c1">// point, so we can&#39;t reattach until this G is
</span><span class="c1"></span>			<span class="c1">// parked.
</span><span class="c1"></span>			<span class="c1">// 休眠之前会重新关联P
</span><span class="c1"></span>			<span class="c1">// 因为上面允许被抢占, 到这里的时候可能就会变成其他P
</span><span class="c1"></span>			<span class="c1">// 如果重新关联P失败则这个任务会结束
</span><span class="c1"></span>			<span class="nx">park</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nf">acquirem</span><span class="p">())</span>
			<span class="nx">park</span><span class="p">.</span><span class="nx">attach</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime.gcDrain 是用于扫描和标记堆内存中对象的核心方法.</p>
<h4 id="gcdrain">gcDrain</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// gcDrain scans roots and objects in work buffers, blackening grey
</span><span class="c1">// objects until it is unable to get more work. It may return before
</span><span class="c1">// GC is done; it&#39;s the caller&#39;s responsibility to balance work from
</span><span class="c1">// other Ps.
</span><span class="c1">//
</span><span class="c1">// If flags&amp;gcDrainUntilPreempt != 0, gcDrain returns when g.preempt
</span><span class="c1">// is set.
</span><span class="c1">//
</span><span class="c1">// If flags&amp;gcDrainIdle != 0, gcDrain returns when there is other work
</span><span class="c1">// to do.
</span><span class="c1">//
</span><span class="c1">// If flags&amp;gcDrainFractional != 0, gcDrain self-preempts when
</span><span class="c1">// pollFractionalWorkerExit() returns true. This implies
</span><span class="c1">// gcDrainNoBlock.
</span><span class="c1">//
</span><span class="c1">// If flags&amp;gcDrainFlushBgCredit != 0, gcDrain flushes scan work
</span><span class="c1">// credit to gcController.bgScanCredit every gcCreditSlack units of
</span><span class="c1">// scan work.
</span><span class="c1">//
</span><span class="c1">// gcDrain will always return if there is a pending STW.
</span><span class="c1">//
</span><span class="c1">//go:nowritebarrier
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gcDrain</span><span class="p">(</span><span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">,</span> <span class="nx">flags</span> <span class="nx">gcDrainFlags</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">needed</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gcDrain phase incorrect&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
	<span class="c1">// 看到抢占标志时是否要返回
</span><span class="c1"></span>	<span class="c1">// gcDrainUntilPreempt — 当 Goroutine 的 preempt 字段被设置成 true 时返回；
</span><span class="c1"></span>	<span class="nx">preemptible</span> <span class="o">:=</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">gcDrainUntilPreempt</span> <span class="o">!=</span> <span class="mi">0</span>
	<span class="c1">// gcDrainFlushBgCredit — 调用 runtime.gcFlushBgCredit 计算后台完成的标记任务量以减少并发标记期间的辅助垃圾收集的用户程序的工作量；
</span><span class="c1"></span>	<span class="c1">// 是否计算后台的扫描量来减少辅助GC和唤醒等待中的G
</span><span class="c1"></span>	<span class="nx">flushBgCredit</span> <span class="o">:=</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">gcDrainFlushBgCredit</span> <span class="o">!=</span> <span class="mi">0</span>
	<span class="c1">// 是否只执行一定量的工作
</span><span class="c1"></span>	<span class="c1">// gcDrainIdle — 调用 runtime.pollWork 函数，当处理器上包含其他待执行 Goroutine 时返回；
</span><span class="c1"></span>	<span class="nx">idle</span> <span class="o">:=</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">gcDrainIdle</span> <span class="o">!=</span> <span class="mi">0</span>
	<span class="c1">// 记录初始的已扫描数量
</span><span class="c1"></span>	<span class="nx">initScanWork</span> <span class="o">:=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span>

	<span class="c1">// checkWork is the scan work before performing the next
</span><span class="c1"></span>	<span class="c1">// self-preempt check.
</span><span class="c1"></span>	<span class="nx">checkWork</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">63</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 运行时会使用本地变量中的 check 函数检查当前是否应该退出标记任务并让出该处理器。
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">check</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">bool</span>
	<span class="c1">// gcDrainFractional — 调用 runtime.pollFractionalWorkerExit 函数，当 CPU 的占用率超过 fractionalUtilizationGoal 的 20% 时返回；
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">gcDrainIdle</span><span class="p">|</span><span class="nx">gcDrainFractional</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">checkWork</span> <span class="p">=</span> <span class="nx">initScanWork</span> <span class="o">+</span> <span class="nx">drainCheckThreshold</span>
		<span class="k">if</span> <span class="nx">idle</span> <span class="p">{</span>
			<span class="nx">check</span> <span class="p">=</span> <span class="nx">pollWork</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">gcDrainFractional</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">check</span> <span class="p">=</span> <span class="nx">pollFractionalWorkerExit</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 当我们做完准备工作后，就可以开始扫描全局变量中的根对象了，这也是标记阶段中需要最先被执行的任务：
</span><span class="c1"></span>	<span class="c1">// 如果根对象未扫描完, 则先扫描根对象
</span><span class="c1"></span>	<span class="c1">// Drain root marking jobs.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">markrootNext</span> <span class="p">&lt;</span> <span class="nx">work</span><span class="p">.</span><span class="nx">markrootJobs</span> <span class="p">{</span>
		<span class="c1">// Stop if we&#39;re preemptible or if someone wants to STW.
</span><span class="c1"></span>		<span class="c1">// 如果标记了preemptible, 循环直到被抢占
</span><span class="c1"></span>		<span class="k">for</span> <span class="p">!(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">preemptible</span> <span class="o">||</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="c1">// 从根对象扫描队列取出一个值(原子递增)
</span><span class="c1"></span>			<span class="nx">job</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">markrootNext</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
			<span class="k">if</span> <span class="nx">job</span> <span class="o">&gt;=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">markrootJobs</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="c1">//扫描根对象需要使用 runtime.markroot 函数，该函数会扫描缓存、数据段、存放全局变量和静态变量的 BSS 段以及 Goroutine 的栈内存；
</span><span class="c1"></span>			<span class="c1">// 执行根对象扫描工作
</span><span class="c1"></span>			<span class="nf">markroot</span><span class="p">(</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">job</span><span class="p">)</span>
			<span class="c1">// 如果是idle模式并且有其他工作, 则返回
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">check</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nf">check</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">done</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 一旦完成了对根对象的扫描，当前 Goroutine 会开始从本地和全局的工作缓存池中获取待执行的任务：
</span><span class="c1"></span>	<span class="c1">// 根对象已经在标记队列中, 消费标记队列
</span><span class="c1"></span>	<span class="c1">// 如果标记了preemptible, 循环直到被抢占
</span><span class="c1"></span>	<span class="c1">// Drain heap marking jobs.
</span><span class="c1"></span>	<span class="c1">// Stop if we&#39;re preemptible or if someone wants to STW.
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">!(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">preemptible</span> <span class="o">||</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="c1">// Try to keep work available on the global queue. We used to
</span><span class="c1"></span>		<span class="c1">// check if there were waiting workers, but it&#39;s better to
</span><span class="c1"></span>		<span class="c1">// just keep work available than to make workers wait. In the
</span><span class="c1"></span>		<span class="c1">// worst case, we&#39;ll do O(log(_WorkbufSize)) unnecessary
</span><span class="c1"></span>		<span class="c1">// balances.
</span><span class="c1"></span>		<span class="c1">// 如果全局标记队列为空, 把本地标记队列的一部分工作分过去
</span><span class="c1"></span>		<span class="c1">// (如果wbuf2不为空则移动wbuf2过去, 否则移动wbuf1的一半过去)
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">full</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">gcw</span><span class="p">.</span><span class="nf">balance</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="c1">// 从本地标记队列中获取对象, 获取不到则从全局标记队列获取
</span><span class="c1"></span>		<span class="nx">b</span> <span class="o">:=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nf">tryGetFast</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// 非阻塞获取
</span><span class="c1"></span>			<span class="nx">b</span> <span class="p">=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nf">tryGet</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// Flush the write barrier
</span><span class="c1"></span>				<span class="c1">// buffer; this may create
</span><span class="c1"></span>				<span class="c1">// more work.
</span><span class="c1"></span>				<span class="nf">wbBufFlush</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
				<span class="nx">b</span> <span class="p">=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nf">tryGet</span><span class="p">()</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Unable to get work.
</span><span class="c1"></span>			<span class="k">break</span>
		<span class="p">}</span>
		<span class="c1">// 扫描获取到的对象
</span><span class="c1"></span>		<span class="nf">scanobject</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">)</span>
		<span class="c1">//扫描对象会使用 runtime.scanobject，该函数会从传入的位置开始扫描，扫描期间会调用 runtime.greyobject 为找到的活跃对象上色。
</span><span class="c1"></span>		<span class="c1">// Flush background scan work credit to the global
</span><span class="c1"></span>		<span class="c1">// account if we&#39;ve accumulated enough locally so
</span><span class="c1"></span>		<span class="c1">// mutator assists can draw on it.
</span><span class="c1"></span>		<span class="c1">// 如果已经扫描了一定数量的对象(gcCreditSlack的值是2000)
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="o">&gt;=</span> <span class="nx">gcCreditSlack</span> <span class="p">{</span>
			<span class="c1">// 把扫描的对象数量添加到全局
</span><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">scanWork</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span><span class="p">)</span>
			<span class="c1">// 减少辅助GC的工作量和唤醒等待中的G
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">flushBgCredit</span> <span class="p">{</span>
				<span class="nf">gcFlushBgCredit</span><span class="p">(</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="o">-</span> <span class="nx">initScanWork</span><span class="p">)</span>
				<span class="nx">initScanWork</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="p">}</span>
			<span class="nx">checkWork</span> <span class="o">-=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span>
			<span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="c1">// 如果达到了检查的扫描量, 则检查是否有其他任务(G), 如果有则跳出循环
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">checkWork</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">checkWork</span> <span class="o">+=</span> <span class="nx">drainCheckThreshold</span>
				<span class="k">if</span> <span class="nx">check</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nf">check</span><span class="p">()</span> <span class="p">{</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nx">done</span><span class="p">:</span>
	<span class="c1">// Flush remaining scan work credit.
</span><span class="c1"></span>	<span class="c1">//当本轮的扫描因为外部条件变化而中断时，该函数会通过 runtime.gcFlushBgCredit 记录这次扫描的内存字节数用于减少辅助标记的工作量。
</span><span class="c1"></span>	<span class="c1">// 把扫描的对象数量添加到全局
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">scanWork</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span><span class="p">)</span>
		<span class="c1">// 减少辅助GC的工作量和唤醒等待中的G
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">flushBgCredit</span> <span class="p">{</span>
			<span class="nf">gcFlushBgCredit</span><span class="p">(</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="o">-</span> <span class="nx">initScanWork</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h5 id="markroot">markroot</h5>
<p>扫描以 markroot 开始，从栈，全局变量，寄存器等根对象开始扫描，创建一个有向引用图，把根对象投入到队列中.</p>
<p>markroot函数用于执行根对象扫描工作:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// markroot scans the i&#39;th root.
</span><span class="c1">//
</span><span class="c1">// Preemption must be disabled (because this uses a gcWork).
</span><span class="c1">//
</span><span class="c1">// nowritebarrier is only advisory here.
</span><span class="c1">//
</span><span class="c1">//go:nowritebarrier
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">markroot</span><span class="p">(</span><span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 判断取出的数值对应哪种任务
</span><span class="c1"></span>	<span class="c1">// (google的工程师觉得这种办法可笑)
</span><span class="c1"></span>	<span class="c1">// TODO(austin): This is a bit ridiculous. Compute and store
</span><span class="c1"></span>	<span class="c1">// the bases in gcMarkRootPrepare instead of the counts.
</span><span class="c1"></span>	<span class="nx">baseFlushCache</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">fixedRootCount</span><span class="p">)</span>
	<span class="nx">baseData</span> <span class="o">:=</span> <span class="nx">baseFlushCache</span> <span class="o">+</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">nFlushCacheRoots</span><span class="p">)</span>
	<span class="nx">baseBSS</span> <span class="o">:=</span> <span class="nx">baseData</span> <span class="o">+</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">nDataRoots</span><span class="p">)</span>
	<span class="nx">baseSpans</span> <span class="o">:=</span> <span class="nx">baseBSS</span> <span class="o">+</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">nBSSRoots</span><span class="p">)</span>
	<span class="nx">baseStacks</span> <span class="o">:=</span> <span class="nx">baseSpans</span> <span class="o">+</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">nSpanRoots</span><span class="p">)</span>
	<span class="nx">end</span> <span class="o">:=</span> <span class="nx">baseStacks</span> <span class="o">+</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">nStackRoots</span><span class="p">)</span>

	<span class="c1">// Note: if you add a case here, please also update heapdump.go:dumproots.
</span><span class="c1"></span>	<span class="k">switch</span> <span class="p">{</span>
	<span class="c1">// 释放mcache中的所有span, 要求STW
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">baseFlushCache</span> <span class="o">&lt;=</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">baseData</span><span class="p">:</span>
		<span class="nf">flushmcache</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">i</span> <span class="o">-</span> <span class="nx">baseFlushCache</span><span class="p">))</span>
	<span class="c1">// 扫描可读写的全局变量
</span><span class="c1"></span>	<span class="c1">// 这里只会扫描i对应的block, 扫描时传入包含哪里有指针的bitmap数据
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">baseData</span> <span class="o">&lt;=</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">baseBSS</span><span class="p">:</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">datap</span> <span class="o">:=</span> <span class="k">range</span> <span class="nf">activeModules</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">markrootBlock</span><span class="p">(</span><span class="nx">datap</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">edata</span><span class="o">-</span><span class="nx">datap</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">gcdatamask</span><span class="p">.</span><span class="nx">bytedata</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="nx">baseData</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="c1">// 扫描只读的全局变量
</span><span class="c1"></span>	<span class="c1">// 这里只会扫描i对应的block, 扫描时传入包含哪里有指针的bitmap数据
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">baseBSS</span> <span class="o">&lt;=</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">baseSpans</span><span class="p">:</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">datap</span> <span class="o">:=</span> <span class="k">range</span> <span class="nf">activeModules</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">markrootBlock</span><span class="p">(</span><span class="nx">datap</span><span class="p">.</span><span class="nx">bss</span><span class="p">,</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">ebss</span><span class="o">-</span><span class="nx">datap</span><span class="p">.</span><span class="nx">bss</span><span class="p">,</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">gcbssmask</span><span class="p">.</span><span class="nx">bytedata</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="nx">baseBSS</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="c1">// 扫描析构器队列
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">fixedRootFinalizers</span><span class="p">:</span>
		<span class="k">for</span> <span class="nx">fb</span> <span class="o">:=</span> <span class="nx">allfin</span><span class="p">;</span> <span class="nx">fb</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">fb</span> <span class="p">=</span> <span class="nx">fb</span><span class="p">.</span><span class="nx">alllink</span> <span class="p">{</span>
			<span class="nx">cnt</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fb</span><span class="p">.</span><span class="nx">cnt</span><span class="p">))</span>
			<span class="nf">scanblock</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fb</span><span class="p">.</span><span class="nx">fin</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nx">cnt</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">fb</span><span class="p">.</span><span class="nx">fin</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">&amp;</span><span class="nx">finptrmask</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">gcw</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="c1">// 释放已中止的G的栈
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">fixedRootFreeGStacks</span><span class="p">:</span>
		<span class="c1">// Switch to the system stack so we can call
</span><span class="c1"></span>		<span class="c1">// stackfree.
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="nx">markrootFreeGStacks</span><span class="p">)</span>
	<span class="c1">// 扫描各个span中特殊对象(析构器列表)
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">baseSpans</span> <span class="o">&lt;=</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">baseStacks</span><span class="p">:</span>
		<span class="c1">// mark mspan.specials
</span><span class="c1"></span>		<span class="nf">markrootSpans</span><span class="p">(</span><span class="nx">gcw</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="nx">baseSpans</span><span class="p">))</span>
	<span class="c1">// 扫描各个G的栈
</span><span class="c1"></span>	<span class="k">default</span><span class="p">:</span>
		<span class="c1">// the rest is scanning goroutine stacks
</span><span class="c1"></span>		<span class="c1">// 获取需要扫描的G
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span>
		<span class="k">if</span> <span class="nx">baseStacks</span> <span class="o">&lt;=</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">end</span> <span class="p">{</span>
			<span class="nx">gp</span> <span class="p">=</span> <span class="nx">allgs</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="nx">baseStacks</span><span class="p">]</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;markroot: bad index&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 记录等待开始的时间
</span><span class="c1"></span>		<span class="c1">// remember when we&#39;ve first observed the G blocked
</span><span class="c1"></span>		<span class="c1">// needed only to output in traceback
</span><span class="c1"></span>		<span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="c1">// We are not in a scan state
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="nx">status</span> <span class="o">==</span> <span class="nx">_Gwaiting</span> <span class="o">||</span> <span class="nx">status</span> <span class="o">==</span> <span class="nx">_Gsyscall</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waitsince</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">waitsince</span> <span class="p">=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">tstart</span>
		<span class="p">}</span>
		<span class="c1">// 切换到g0运行(有可能会扫到自己的栈)
</span><span class="c1"></span>		<span class="c1">// scanstack must be done on the system stack in case
</span><span class="c1"></span>		<span class="c1">// we&#39;re trying to scan our own stack.
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// If this is a self-scan, put the user G in
</span><span class="c1"></span>			<span class="c1">// _Gwaiting to prevent self-deadlock. It may
</span><span class="c1"></span>			<span class="c1">// already be in _Gwaiting if this is a mark
</span><span class="c1"></span>			<span class="c1">// worker or we&#39;re in mark termination.
</span><span class="c1"></span>			<span class="c1">// 判断扫描的栈是否自己的
</span><span class="c1"></span>			<span class="nx">userG</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
			<span class="c1">// 如果正在扫描自己的栈则切换状态到等待中防止死锁
</span><span class="c1"></span>			<span class="nx">selfScan</span> <span class="o">:=</span> <span class="nx">gp</span> <span class="o">==</span> <span class="nx">userG</span> <span class="o">&amp;&amp;</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">userG</span><span class="p">)</span> <span class="o">==</span> <span class="nx">_Grunning</span>
			<span class="k">if</span> <span class="nx">selfScan</span> <span class="p">{</span>
				<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">userG</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
				<span class="nx">userG</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="nx">waitReasonGarbageCollectionScan</span>
			<span class="p">}</span>

			<span class="c1">// TODO: suspendG blocks (and spins) until gp
</span><span class="c1"></span>			<span class="c1">// stops, which may take a while for
</span><span class="c1"></span>			<span class="c1">// running goroutines. Consider doing this in
</span><span class="c1"></span>			<span class="c1">// two phases where the first is non-blocking:
</span><span class="c1"></span>			<span class="c1">// we scan the stacks we can and ask running
</span><span class="c1"></span>			<span class="c1">// goroutines to scan themselves; and the
</span><span class="c1"></span>			<span class="c1">// second blocks.
</span><span class="c1"></span>			<span class="nx">stopped</span> <span class="o">:=</span> <span class="nf">suspendG</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">stopped</span><span class="p">.</span><span class="nx">dead</span> <span class="p">{</span>
				<span class="nx">gp</span><span class="p">.</span><span class="nx">gcscandone</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">gcscandone</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;g already scanned&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nf">scanstack</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">)</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">gcscandone</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="nf">resumeG</span><span class="p">(</span><span class="nx">stopped</span><span class="p">)</span>
			<span class="c1">// 如果正在扫描自己的栈则把状态切换回运行中
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">selfScan</span> <span class="p">{</span>
				<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">userG</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">})</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h6 id="suspendg">suspendG</h6>
<p>函数负责扫描G的栈:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// suspendG suspends goroutine gp at a safe-point and returns the
</span><span class="c1">// state of the suspended goroutine. The caller gets read access to
</span><span class="c1">// the goroutine until it calls resumeG.
</span><span class="c1">//
</span><span class="c1">// It is safe for multiple callers to attempt to suspend the same
</span><span class="c1">// goroutine at the same time. The goroutine may execute between
</span><span class="c1">// subsequent successful suspend operations. The current
</span><span class="c1">// implementation grants exclusive access to the goroutine, and hence
</span><span class="c1">// multiple callers will serialize. However, the intent is to grant
</span><span class="c1">// shared read access, so please don&#39;t depend on exclusive access.
</span><span class="c1">//
</span><span class="c1">// This must be called from the system stack and the user goroutine on
</span><span class="c1">// the current M (if any) must be in a preemptible state. This
</span><span class="c1">// prevents deadlocks where two goroutines attempt to suspend each
</span><span class="c1">// other and both are in non-preemptible states. There are other ways
</span><span class="c1">// to resolve this deadlock, but this seems simplest.
</span><span class="c1">//
</span><span class="c1">// TODO(austin): What if we instead required this to be called from a
</span><span class="c1">// user goroutine? Then we could deschedule the goroutine while
</span><span class="c1">// waiting instead of blocking the thread. If two goroutines tried to
</span><span class="c1">// suspend each other, one of them would win and the other wouldn&#39;t
</span><span class="c1">// complete the suspend until it was resumed. We would have to be
</span><span class="c1">// careful that they couldn&#39;t actually queue up suspend for each other
</span><span class="c1">// and then both be suspended. This would also avoid the need for a
</span><span class="c1">// kernel context switch in the synchronous case because we could just
</span><span class="c1">// directly schedule the waiter. The context switch is unavoidable in
</span><span class="c1">// the signal case.
</span><span class="c1">//
</span><span class="c1">//go:systemstack
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">suspendG</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="nx">suspendGState</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">mp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">;</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">curg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">curg</span><span class="p">)</span> <span class="o">==</span> <span class="nx">_Grunning</span> <span class="p">{</span>
		<span class="c1">// Since we&#39;re on the system stack of this M, the user
</span><span class="c1"></span>		<span class="c1">// G is stuck at an unsafe point. If another goroutine
</span><span class="c1"></span>		<span class="c1">// were to try to preempt m.curg, it could deadlock.
</span><span class="c1"></span>		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;suspendG from non-preemptible goroutine&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// See https://golang.org/cl/21503 for justification of the yield delay.
</span><span class="c1"></span>	<span class="kd">const</span> <span class="nx">yieldDelay</span> <span class="p">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1000</span>
	<span class="kd">var</span> <span class="nx">nextYield</span> <span class="kt">int64</span>

	<span class="c1">// Drive the goroutine to a preemption point.
</span><span class="c1"></span>	<span class="nx">stopped</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="kd">var</span> <span class="nx">asyncM</span> <span class="o">*</span><span class="nx">m</span>
	<span class="kd">var</span> <span class="nx">asyncGen</span> <span class="kt">uint32</span>
	<span class="kd">var</span> <span class="nx">nextPreemptM</span> <span class="kt">int64</span>

	<span class="c1">// 循环直到扫描完成
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 判断G的当前状态
</span><span class="c1"></span>		<span class="k">switch</span> <span class="nx">s</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">);</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">s</span><span class="o">&amp;</span><span class="nx">_Gscan</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// Someone else is suspending it. Wait
</span><span class="c1"></span>				<span class="c1">// for them to finish.
</span><span class="c1"></span>				<span class="c1">//
</span><span class="c1"></span>				<span class="c1">// TODO: It would be nicer if we could
</span><span class="c1"></span>				<span class="c1">// coalesce suspends.
</span><span class="c1"></span>				<span class="k">break</span>
			<span class="p">}</span>

			<span class="nf">dumpgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;invalid g status&#34;</span><span class="p">)</span>
		<span class="c1">// G已中止, 不需要扫描它
</span><span class="c1"></span>		<span class="k">case</span> <span class="nx">_Gdead</span><span class="p">:</span>
			<span class="c1">// Nothing to suspend.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// preemptStop may need to be cleared, but
</span><span class="c1"></span>			<span class="c1">// doing that here could race with goroutine
</span><span class="c1"></span>			<span class="c1">// reuse. Instead, goexit0 clears it.
</span><span class="c1"></span>			<span class="k">return</span> <span class="nx">suspendGState</span><span class="p">{</span><span class="nx">dead</span><span class="p">:</span> <span class="kc">true</span><span class="p">}</span>
		<span class="c1">// G的栈正在扩展, 下一轮重试
</span><span class="c1"></span>		<span class="k">case</span> <span class="nx">_Gcopystack</span><span class="p">:</span>
			<span class="c1">// The stack is being copied. We need to wait
</span><span class="c1"></span>			<span class="c1">// until this is done.
</span><span class="c1"></span>
		<span class="k">case</span> <span class="nx">_Gpreempted</span><span class="p">:</span>
			<span class="c1">// We (or someone else) suspended the G. Claim
</span><span class="c1"></span>			<span class="c1">// ownership of it by transitioning it to
</span><span class="c1"></span>			<span class="c1">// _Gwaiting.
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nf">casGFromPreempted</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gpreempted</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>

			<span class="c1">// We stopped the G, so we have to ready it later.
</span><span class="c1"></span>			<span class="nx">stopped</span> <span class="p">=</span> <span class="kc">true</span>

			<span class="nx">s</span> <span class="p">=</span> <span class="nx">_Gwaiting</span>
			<span class="k">fallthrough</span>
		<span class="c1">// G不是运行中, 首先需要防止它运行
</span><span class="c1"></span>		<span class="k">case</span> <span class="nx">_Grunnable</span><span class="p">,</span> <span class="nx">_Gsyscall</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">:</span>
			<span class="c1">// Claim goroutine by setting scan bit.
</span><span class="c1"></span>			<span class="c1">// This may race with execution or readying of gp.
</span><span class="c1"></span>			<span class="c1">// The scan bit keeps it from transition state.
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nf">castogscanstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">s</span><span class="p">|</span><span class="nx">_Gscan</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// 跳出循环
</span><span class="c1"></span>				<span class="k">break</span>
			<span class="p">}</span>

			<span class="c1">// Clear the preemption request. It&#39;s safe to
</span><span class="c1"></span>			<span class="c1">// reset the stack guard because we hold the
</span><span class="c1"></span>			<span class="c1">// _Gscan bit and thus own the stack.
</span><span class="c1"></span>			<span class="nx">gp</span><span class="p">.</span><span class="nx">preemptStop</span> <span class="p">=</span> <span class="kc">false</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">false</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>

			<span class="c1">// The goroutine was already at a safe-point
</span><span class="c1"></span>			<span class="c1">// and we&#39;ve now locked that in.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// TODO: It would be much better if we didn&#39;t
</span><span class="c1"></span>			<span class="c1">// leave it in _Gscan, but instead gently
</span><span class="c1"></span>			<span class="c1">// prevented its scheduling until resumption.
</span><span class="c1"></span>			<span class="c1">// Maybe we only use this to bump a suspended
</span><span class="c1"></span>			<span class="c1">// count and the scheduler skips suspended
</span><span class="c1"></span>			<span class="c1">// goroutines? That wouldn&#39;t be enough for
</span><span class="c1"></span>			<span class="c1">// {_Gsyscall,_Gwaiting} -&gt; _Grunning. Maybe
</span><span class="c1"></span>			<span class="c1">// for all those transitions we need to check
</span><span class="c1"></span>			<span class="c1">// suspended and deschedule?
</span><span class="c1"></span>			<span class="k">return</span> <span class="nx">suspendGState</span><span class="p">{</span><span class="nx">g</span><span class="p">:</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">stopped</span><span class="p">:</span> <span class="nx">stopped</span><span class="p">}</span>
		<span class="c1">// G正在运行
</span><span class="c1"></span>		<span class="k">case</span> <span class="nx">_Grunning</span><span class="p">:</span>
			<span class="c1">// Optimization: if there is already a pending preemption request
</span><span class="c1"></span>			<span class="c1">// (from the previous loop iteration), don&#39;t bother with the atomics.
</span><span class="c1"></span>			<span class="c1">// 如果已经有抢占请求, 则抢占成功时会帮我们处理
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptStop</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="o">==</span> <span class="nx">stackPreempt</span> <span class="o">&amp;&amp;</span> <span class="nx">asyncM</span> <span class="o">==</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">asyncM</span><span class="p">.</span><span class="nx">preemptGen</span><span class="p">)</span> <span class="o">==</span> <span class="nx">asyncGen</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="c1">// 抢占G, 抢占成功时会帮我们处理
</span><span class="c1"></span>			<span class="c1">// Temporarily block state transitions.
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nf">castogscanstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gscanrunning</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>

			<span class="c1">// Request synchronous preemption.
</span><span class="c1"></span>			<span class="nx">gp</span><span class="p">.</span><span class="nx">preemptStop</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span>

			<span class="c1">// Prepare for asynchronous preemption.
</span><span class="c1"></span>			<span class="nx">asyncM2</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span>
			<span class="nx">asyncGen2</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">asyncM2</span><span class="p">.</span><span class="nx">preemptGen</span><span class="p">)</span>
			<span class="nx">needAsync</span> <span class="o">:=</span> <span class="nx">asyncM</span> <span class="o">!=</span> <span class="nx">asyncM2</span> <span class="o">||</span> <span class="nx">asyncGen</span> <span class="o">!=</span> <span class="nx">asyncGen2</span>
			<span class="nx">asyncM</span> <span class="p">=</span> <span class="nx">asyncM2</span>
			<span class="nx">asyncGen</span> <span class="p">=</span> <span class="nx">asyncGen2</span>

			<span class="nf">casfrom_Gscanstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gscanrunning</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>

			<span class="c1">// Send asynchronous preemption. We do this
</span><span class="c1"></span>			<span class="c1">// after CASing the G back to _Grunning
</span><span class="c1"></span>			<span class="c1">// because preemptM may be synchronous and we
</span><span class="c1"></span>			<span class="c1">// don&#39;t want to catch the G just spinning on
</span><span class="c1"></span>			<span class="c1">// its status.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">preemptMSupported</span> <span class="o">&amp;&amp;</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">asyncpreemptoff</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">needAsync</span> <span class="p">{</span>
				<span class="c1">// Rate limit preemptM calls. This is
</span><span class="c1"></span>				<span class="c1">// particularly important on Windows
</span><span class="c1"></span>				<span class="c1">// where preemptM is actually
</span><span class="c1"></span>				<span class="c1">// synchronous and the spin loop here
</span><span class="c1"></span>				<span class="c1">// can lead to live-lock.
</span><span class="c1"></span>				<span class="nx">now</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
				<span class="k">if</span> <span class="nx">now</span> <span class="o">&gt;=</span> <span class="nx">nextPreemptM</span> <span class="p">{</span>
					<span class="nx">nextPreemptM</span> <span class="p">=</span> <span class="nx">now</span> <span class="o">+</span> <span class="nx">yieldDelay</span><span class="o">/</span><span class="mi">2</span>
					<span class="nf">preemptM</span><span class="p">(</span><span class="nx">asyncM</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// TODO: Don&#39;t busy wait. This loop should really only
</span><span class="c1"></span>		<span class="c1">// be a simple read/decide/CAS loop that only fails if
</span><span class="c1"></span>		<span class="c1">// there&#39;s an active race. Once the CAS succeeds, we
</span><span class="c1"></span>		<span class="c1">// should queue up the preemption (which will require
</span><span class="c1"></span>		<span class="c1">// it to be reliable in the _Grunning case, not
</span><span class="c1"></span>		<span class="c1">// best-effort) and then sleep until we&#39;re notified
</span><span class="c1"></span>		<span class="c1">// that the goroutine is suspended.
</span><span class="c1"></span>		<span class="c1">// 第一轮休眠10毫秒, 第二轮休眠5毫秒
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">nextYield</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">+</span> <span class="nx">yieldDelay</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">nextYield</span> <span class="p">{</span>
			<span class="nf">procyield</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">osyield</span><span class="p">()</span>
			<span class="nx">nextYield</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">+</span> <span class="nx">yieldDelay</span><span class="o">/</span><span class="mi">2</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>设置preemptscan后, 在抢占G成功时会调用scanstack扫描它自己的栈, 具体代码在这里.</p>
<h6 id="scanstack">scanstack</h6>
<p>这个函数是起点函数（ 起始最原始的还是 markroot，但是我们这里梳理主线 ），该扫描栈上所有可达对象，因为栈是一个根，因为你做事情总要有个开始的地方，那么“栈”就是 golang 的起点。</p>
<ol>
<li>找到这个 goroutine 栈上的内存对象（一个个找，一个个处理）；</li>
<li>找到对象之后，获取到这个对象的 type 结构，然后取出 type.ptrdata, type.gcdata ，从而我们就知道扫描的内存范围，和内存块上指针的所在位置；</li>
<li>调用 scanblock 扫描这个内存块；</li>
</ol>
<p>扫描栈用的函数是scanstack</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// scanstack scans gp&#39;s stack, greying all pointers found on the stack.
</span><span class="c1">//
</span><span class="c1">// scanstack will also shrink the stack if it is safe to do so. If it
</span><span class="c1">// is not, it schedules a stack shrink for the next synchronous safe
</span><span class="c1">// point.
</span><span class="c1">//
</span><span class="c1">// scanstack is marked go:systemstack because it must not be preempted
</span><span class="c1">// while using a workbuf.
</span><span class="c1">//
</span><span class="c1">//go:nowritebarrier
</span><span class="c1">//go:systemstack
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">scanstack</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span><span class="o">&amp;</span><span class="nx">_Gscan</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime:scanstack: gp=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="s">&#34;, goid=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">goid</span><span class="p">,</span> <span class="s">&#34;, gp-&gt;atomicstatus=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)),</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;scanstack - bad status&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="nx">_Gscan</span> <span class="p">{</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: gp=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="s">&#34;, goid=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">goid</span><span class="p">,</span> <span class="s">&#34;, gp-&gt;atomicstatus=&#34;</span><span class="p">,</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">),</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;mark - bad status&#34;</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">_Gdead</span><span class="p">:</span>
		<span class="k">return</span>
	<span class="k">case</span> <span class="nx">_Grunning</span><span class="p">:</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: gp=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="s">&#34;, goid=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">goid</span><span class="p">,</span> <span class="s">&#34;, gp-&gt;atomicstatus=&#34;</span><span class="p">,</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">),</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;scanstack: goroutine not stopped&#34;</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">_Grunnable</span><span class="p">,</span> <span class="nx">_Gsyscall</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">:</span>
		<span class="c1">// ok
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="nf">getg</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;can&#39;t scan our own stack&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nf">isShrinkStackSafe</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Shrink the stack if not much of it is being used.
</span><span class="c1"></span>		<span class="nf">shrinkstack</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// Otherwise, shrink the stack at the next sync safe point.
</span><span class="c1"></span>		<span class="nx">gp</span><span class="p">.</span><span class="nx">preemptShrink</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">state</span> <span class="nx">stackScanState</span>
	<span class="nx">state</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span>

	<span class="k">if</span> <span class="nx">stackTraceDebug</span> <span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="s">&#34;stack trace goroutine&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">goid</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">debugScanConservative</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">asyncSafePoint</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;scanning async preempted goroutine &#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">goid</span><span class="p">,</span> <span class="s">&#34; stack [&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="s">&#34;,&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="p">),</span> <span class="s">&#34;)\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Scan the saved context register. This is effectively a live
</span><span class="c1"></span>	<span class="c1">// register that gets moved back and forth between the
</span><span class="c1"></span>	<span class="c1">// register and sched.ctxt without a write barrier.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ctxt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">scanblock</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ctxt</span><span class="p">)),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">oneptrmask</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">gcw</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// scanframeworker会根据代码地址(pc)获取函数信息
</span><span class="c1"></span>	<span class="c1">// 然后找到函数信息中的stackmap.bytedata, 它保存了函数的栈上哪些地方有指针
</span><span class="c1"></span>	<span class="c1">// 再调用scanblock来扫描函数的栈空间, 同时函数的参数也会这样扫描
</span><span class="c1"></span>	<span class="c1">// Scan the stack. Accumulate a list of stack objects.
</span><span class="c1"></span>	<span class="nx">scanframe</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">frame</span> <span class="o">*</span><span class="nx">stkframe</span><span class="p">,</span> <span class="nx">unused</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="nf">scanframeworker</span><span class="p">(</span><span class="nx">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="c1">// 枚举所有调用帧, 分别调用scanframe函数
</span><span class="c1"></span>	<span class="nf">gentraceback</span><span class="p">(^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mh">0x7fffffff</span><span class="p">,</span> <span class="nx">scanframe</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="c1">// Find additional pointers that point into the stack from the heap.
</span><span class="c1"></span>	<span class="c1">// Currently this includes defers and panics. See also function copystack.
</span><span class="c1"></span>
	<span class="c1">// Find and trace all defer arguments.
</span><span class="c1"></span>	<span class="c1">// 枚举所有defer的调用帧, 分别调用scanframe函数
</span><span class="c1"></span>	<span class="nf">tracebackdefers</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">scanframe</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>

	<span class="c1">// Find and trace other pointers in defer records.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">d</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span><span class="p">;</span> <span class="nx">d</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">d</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// tracebackdefers above does not scan the func value, which could
</span><span class="c1"></span>			<span class="c1">// be a stack allocated closure. See issue 30453.
</span><span class="c1"></span>			<span class="nf">scanblock</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">fn</span><span class="p">)),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">oneptrmask</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">gcw</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// The link field of a stack-allocated defer record might point
</span><span class="c1"></span>			<span class="c1">// to a heap-allocated defer record. Keep that heap record live.
</span><span class="c1"></span>			<span class="nf">scanblock</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">link</span><span class="p">)),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">oneptrmask</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">gcw</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// Retain defers records themselves.
</span><span class="c1"></span>		<span class="c1">// Defer records might not be reachable from the G through regular heap
</span><span class="c1"></span>		<span class="c1">// tracing because the defer linked list might weave between the stack and the heap.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">heap</span> <span class="p">{</span>
			<span class="nf">scanblock</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">)),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">oneptrmask</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">gcw</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Panics are always stack allocated.
</span><span class="c1"></span>		<span class="nx">state</span><span class="p">.</span><span class="nf">putPtr</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span><span class="p">)),</span> <span class="kc">false</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Find and scan all reachable stack objects.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The state&#39;s pointer queue prioritizes precise pointers over
</span><span class="c1"></span>	<span class="c1">// conservative pointers so that we&#39;ll prefer scanning stack
</span><span class="c1"></span>	<span class="c1">// objects precisely.
</span><span class="c1"></span>	<span class="nx">state</span><span class="p">.</span><span class="nf">buildIndex</span><span class="p">()</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">,</span> <span class="nx">conservative</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nf">getPtr</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">obj</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nf">findObject</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">obj</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">t</span> <span class="o">:=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">typ</span>
		<span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// We&#39;ve already scanned this object.
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">obj</span><span class="p">.</span><span class="nf">setType</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> <span class="c1">// Don&#39;t scan it again.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">stackTraceDebug</span> <span class="p">{</span>
			<span class="nf">printlock</span><span class="p">()</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;  live stkobj at&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="o">+</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">off</span><span class="p">)),</span> <span class="s">&#34;of type&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nb">string</span><span class="p">())</span>
			<span class="k">if</span> <span class="nx">conservative</span> <span class="p">{</span>
				<span class="nb">print</span><span class="p">(</span><span class="s">&#34; (conservative)&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nb">println</span><span class="p">()</span>
			<span class="nf">printunlock</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nx">gcdata</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">gcdata</span>
		<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">kind</span><span class="o">&amp;</span><span class="nx">kindGCProg</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// This path is pretty unlikely, an object large enough
</span><span class="c1"></span>			<span class="c1">// to have a GC program allocated on the stack.
</span><span class="c1"></span>			<span class="c1">// We need some space to unpack the program into a straight
</span><span class="c1"></span>			<span class="c1">// bitmask, which we allocate/free here.
</span><span class="c1"></span>			<span class="c1">// TODO: it would be nice if there were a way to run a GC
</span><span class="c1"></span>			<span class="c1">// program without having to store all its bits. We&#39;d have
</span><span class="c1"></span>			<span class="c1">// to change from a Lempel-Ziv style program to something else.
</span><span class="c1"></span>			<span class="c1">// Or we can forbid putting objects on stacks if they require
</span><span class="c1"></span>			<span class="c1">// a gc program (see issue 27447).
</span><span class="c1"></span>			<span class="nx">s</span> <span class="p">=</span> <span class="nf">materializeGCProg</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">ptrdata</span><span class="p">,</span> <span class="nx">gcdata</span><span class="p">)</span>
			<span class="nx">gcdata</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">startAddr</span><span class="p">))</span>
		<span class="p">}</span>

		<span class="nx">b</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">off</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">conservative</span> <span class="p">{</span>
			<span class="nf">scanConservative</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">ptrdata</span><span class="p">,</span> <span class="nx">gcdata</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">scanblock</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">ptrdata</span><span class="p">,</span> <span class="nx">gcdata</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">dematerializeGCProg</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Deallocate object buffers.
</span><span class="c1"></span>	<span class="c1">// (Pointer buffers were all deallocated in the loop above.)
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">state</span><span class="p">.</span><span class="nx">head</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">x</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nx">head</span>
		<span class="nx">state</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">next</span>
		<span class="k">if</span> <span class="nx">stackTraceDebug</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">nobj</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
				<span class="nx">obj</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">x</span><span class="p">.</span><span class="nx">obj</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
				<span class="k">if</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">typ</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// reachable
</span><span class="c1"></span>					<span class="k">continue</span>
				<span class="p">}</span>
				<span class="nb">println</span><span class="p">(</span><span class="s">&#34;  dead stkobj at&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="o">+</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">off</span><span class="p">)),</span> <span class="s">&#34;of type&#34;</span><span class="p">,</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">typ</span><span class="p">.</span><span class="nb">string</span><span class="p">())</span>
				<span class="c1">// Note: not necessarily really dead - only reachable-from-ptr dead.
</span><span class="c1"></span>			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">x</span><span class="p">.</span><span class="nx">nobj</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nf">putempty</span><span class="p">((</span><span class="o">*</span><span class="nx">workbuf</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">)))</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">state</span><span class="p">.</span><span class="nx">buf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">state</span><span class="p">.</span><span class="nx">cbuf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">state</span><span class="p">.</span><span class="nx">freeBuf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;remaining pointer buffers&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h6 id="scanblock">scanblock</h6>
<p>scanblock函数是一个通用的扫描函数, 扫描全局变量和栈空间都会用它, 和scanobject不同的是bitmap需要手动传入,他的一切参数都是传入的，这个函数作为一个基础函数被很多地方调用:</p>
<ol>
<li>scanblock 这个函数非常简单，只扫描给定的一段内存块；</li>
<li>大循环每次递进 64 个字节，小循环每次递进 8 字节；</li>
<li>是否作为指针扫描是由 ptrmask 指定的；</li>
<li>只要长度和地址是对齐的，指针类型按 8 字节对齐，那么我们按照 8 字节递进扫描一定是全方位覆盖，不会漏掉一个对象的；</li>
<li>再次提醒下，uintptr 是数值类型，编译器不会标识成指针类型，所以不受扫描保护；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// scanblock scans b as scanobject would, but using an explicit
</span><span class="c1">// pointer bitmap instead of the heap bitmap.
</span><span class="c1">//
</span><span class="c1">// This is used to scan non-heap roots, so it does not update
</span><span class="c1">// gcw.bytesMarked or gcw.scanWork.
</span><span class="c1">//
</span><span class="c1">// If stk != nil, possible stack pointers are also reported to stk.putPtr.
</span><span class="c1">//go:nowritebarrier
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">scanblock</span><span class="p">(</span><span class="nx">b0</span><span class="p">,</span> <span class="nx">n0</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">ptrmask</span> <span class="o">*</span><span class="kt">uint8</span><span class="p">,</span> <span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">,</span> <span class="nx">stk</span> <span class="o">*</span><span class="nx">stackScanState</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Use local copies of original parameters, so that a stack trace
</span><span class="c1"></span>	<span class="c1">// due to one of the throws below shows the original block
</span><span class="c1"></span>	<span class="c1">// base and extent.
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="nx">b0</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">n0</span>
	<span class="c1">// 枚举扫描的地址
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="p">{</span>
		<span class="c1">// Find bits for the next word.
</span><span class="c1"></span>		<span class="c1">// 找到bitmap中对应的byte
</span><span class="c1"></span>		<span class="nx">bits</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="o">*</span><span class="nf">addb</span><span class="p">(</span><span class="nx">ptrmask</span><span class="p">,</span> <span class="nx">i</span><span class="o">/</span><span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="o">*</span><span class="mi">8</span><span class="p">)))</span>
		<span class="k">if</span> <span class="nx">bits</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">i</span> <span class="o">+=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">*</span> <span class="mi">8</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// 枚举byte
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">8</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 如果该地址包含指针
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">bits</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// 标记在该地址的对象存活, 并把它加到标记队列(该对象变为灰色)
</span><span class="c1"></span>				<span class="c1">// Same work as in scanobject; see comments there.
</span><span class="c1"></span>				<span class="nx">p</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span> <span class="o">+</span> <span class="nx">i</span><span class="p">))</span>
				<span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
										<span class="c1">// 找到该对象对应的span和bitmap
</span><span class="c1"></span>					<span class="k">if</span> <span class="nx">obj</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">objIndex</span> <span class="o">:=</span> <span class="nf">findObject</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span> <span class="nx">obj</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
						<span class="c1">// 标记一个对象存活, 并把它加到标记队列(该对象变为灰色)
</span><span class="c1"></span>						<span class="nf">greyobject</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="nx">objIndex</span><span class="p">)</span>
					<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">stk</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span> <span class="o">&gt;=</span> <span class="nx">stk</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span> <span class="p">&lt;</span> <span class="nx">stk</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="p">{</span>
						<span class="nx">stk</span><span class="p">.</span><span class="nf">putPtr</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="c1">// 处理下一个指针下一个bit
</span><span class="c1"></span>			<span class="nx">bits</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
			<span class="nx">i</span> <span class="o">+=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>greyobject用于标记一个对象存活, 并把它加到标记队列(该对象变为灰色):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// obj is the start of an object with mark mbits.
</span><span class="c1">// If it isn&#39;t already marked, mark it and enqueue into gcw.
</span><span class="c1">// base and off are for debugging only and could be removed.
</span><span class="c1">//
</span><span class="c1">// See also wbBufFlush1, which partially duplicates this logic.
</span><span class="c1">//
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">greyobject</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">base</span><span class="p">,</span> <span class="nx">off</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">span</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">,</span> <span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">,</span> <span class="nx">objIndex</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// obj should be start of allocation, and so must be at least pointer-aligned.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">obj</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;greyobject: obj not pointer-aligned&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">mbits</span> <span class="o">:=</span> <span class="nx">span</span><span class="p">.</span><span class="nf">markBitsForIndex</span><span class="p">(</span><span class="nx">objIndex</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">useCheckmark</span> <span class="p">{</span>
		<span class="c1">// checkmark是用于检查是否所有可到达的对象都被正确标记的机制, 仅除错使用
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">mbits</span><span class="p">.</span><span class="nf">isMarked</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">printlock</span><span class="p">()</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime:greyobject: checkmarks finds unexpected unmarked object obj=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: found obj at *(&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">base</span><span class="p">),</span> <span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">off</span><span class="p">),</span> <span class="s">&#34;)\n&#34;</span><span class="p">)</span>

			<span class="c1">// Dump the source (base) object
</span><span class="c1"></span>			<span class="nf">gcDumpObject</span><span class="p">(</span><span class="s">&#34;base&#34;</span><span class="p">,</span> <span class="nx">base</span><span class="p">,</span> <span class="nx">off</span><span class="p">)</span>

			<span class="c1">// Dump the object
</span><span class="c1"></span>			<span class="nf">gcDumpObject</span><span class="p">(</span><span class="s">&#34;obj&#34;</span><span class="p">,</span> <span class="nx">obj</span><span class="p">,</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

			<span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">traceback</span> <span class="p">=</span> <span class="mi">2</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;checkmark found unmarked object&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">hbits</span> <span class="o">:=</span> <span class="nf">heapBitsForAddr</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">hbits</span><span class="p">.</span><span class="nf">isCheckmarked</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">hbits</span><span class="p">.</span><span class="nf">setCheckmarked</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">hbits</span><span class="p">.</span><span class="nf">isCheckmarked</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;setCheckmarked and isCheckmarked disagree&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gccheckmark</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">span</span><span class="p">.</span><span class="nf">isFree</span><span class="p">(</span><span class="nx">objIndex</span><span class="p">)</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: marking free object &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span> <span class="s">&#34; found at *(&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">base</span><span class="p">),</span> <span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">off</span><span class="p">),</span> <span class="s">&#34;)\n&#34;</span><span class="p">)</span>
			<span class="nf">gcDumpObject</span><span class="p">(</span><span class="s">&#34;base&#34;</span><span class="p">,</span> <span class="nx">base</span><span class="p">,</span> <span class="nx">off</span><span class="p">)</span>
			<span class="nf">gcDumpObject</span><span class="p">(</span><span class="s">&#34;obj&#34;</span><span class="p">,</span> <span class="nx">obj</span><span class="p">,</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
			<span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">traceback</span> <span class="p">=</span> <span class="mi">2</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;marking free object&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 如果对象所在的span中的gcmarkBits对应的bit已经设置为1则可以跳过处理
</span><span class="c1"></span>		<span class="c1">// If marked we have nothing to do.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">mbits</span><span class="p">.</span><span class="nf">isMarked</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">mbits</span><span class="p">.</span><span class="nf">setMarked</span><span class="p">()</span>

		<span class="c1">// Mark span.
</span><span class="c1"></span>		<span class="nx">arena</span><span class="p">,</span> <span class="nx">pageIdx</span><span class="p">,</span> <span class="nx">pageMask</span> <span class="o">:=</span> <span class="nf">pageIndexOf</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
		<span class="k">if</span> <span class="nx">arena</span><span class="p">.</span><span class="nx">pageMarks</span><span class="p">[</span><span class="nx">pageIdx</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">pageMask</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// 设置对象所在的span中的gcmarkBits对应的bit为1
</span><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Or8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arena</span><span class="p">.</span><span class="nx">pageMarks</span><span class="p">[</span><span class="nx">pageIdx</span><span class="p">],</span> <span class="nx">pageMask</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// If this is a noscan object, fast-track it to black
</span><span class="c1"></span>		<span class="c1">// instead of greying it.
</span><span class="c1"></span>		<span class="c1">// 如果确定对象不包含指针(所在span的类型是noscan), 则不需要把对象放入标记队列
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">span</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">noscan</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">gcw</span><span class="p">.</span><span class="nx">bytesMarked</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Queue the obj for scanning. The PREFETCH(obj) logic has been removed but
</span><span class="c1"></span>	<span class="c1">// seems like a nice optimization that can be added back in.
</span><span class="c1"></span>	<span class="c1">// There needs to be time between the PREFETCH and the use.
</span><span class="c1"></span>	<span class="c1">// Previously we put the obj in an 8 element buffer that is drained at a rate
</span><span class="c1"></span>	<span class="c1">// to give the PREFETCH time to do its work.
</span><span class="c1"></span>	<span class="c1">// Use of PREFETCHNTA might be more appropriate than PREFETCH
</span><span class="c1"></span>	<span class="c1">// 把对象放入标记队列
</span><span class="c1"></span>	<span class="c1">// 先放入本地标记队列, 失败时把本地标记队列中的部分工作转移到全局标记队列, 再放入本地标记队列
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">putFast</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">gcw</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="scanobject">scanobject</h5>
<p>gcDrain函数扫描完根对象, 就会开始消费标记队列, 对从标记队列中取出的对象调用scanobject函数.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// scanobject scans the object starting at b, adding pointers to gcw.
</span><span class="c1">// b must point to the beginning of a heap object or an oblet.
</span><span class="c1">// scanobject consults the GC bitmap for the pointer mask and the
</span><span class="c1">// spans for the size of the object.
</span><span class="c1">//
</span><span class="c1">//go:nowritebarrier
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">scanobject</span><span class="p">(</span><span class="nx">b</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Find the bits for b and the size of the object at b.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// b is either the beginning of an object, in which case this
</span><span class="c1"></span>	<span class="c1">// is the size of the object to scan, or it points to an
</span><span class="c1"></span>	<span class="c1">// oblet, in which case we compute the size to scan below.
</span><span class="c1"></span>	<span class="c1">// 获取对象对应的bitmap
</span><span class="c1"></span>	<span class="nx">hbits</span> <span class="o">:=</span> <span class="nf">heapBitsForAddr</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="c1">// 获取对象所在的span
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nf">spanOfUnchecked</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="c1">// 获取对象的大小
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;scanobject n == 0&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 对象大小过大时(maxObletBytes是128KB)需要分割扫描
</span><span class="c1"></span>	<span class="c1">// 每次最多只扫描128KB
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nx">maxObletBytes</span> <span class="p">{</span>
		<span class="c1">// Large object. Break into oblets for better
</span><span class="c1"></span>		<span class="c1">// parallelism and lower latency.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// It&#39;s possible this is a noscan object (not
</span><span class="c1"></span>			<span class="c1">// from greyobject, but from other code
</span><span class="c1"></span>			<span class="c1">// paths), in which case we must *not* enqueue
</span><span class="c1"></span>			<span class="c1">// oblets since their bitmaps will be
</span><span class="c1"></span>			<span class="c1">// uninitialized.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">noscan</span><span class="p">()</span> <span class="p">{</span>
				<span class="c1">// Bypass the whole scan.
</span><span class="c1"></span>				<span class="nx">gcw</span><span class="p">.</span><span class="nx">bytesMarked</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="p">}</span>

			<span class="c1">// Enqueue the other oblets to scan later.
</span><span class="c1"></span>			<span class="c1">// Some oblets may be in b&#39;s scalar tail, but
</span><span class="c1"></span>			<span class="c1">// these will be marked as &#34;no more pointers&#34;,
</span><span class="c1"></span>			<span class="c1">// so we&#39;ll drop out immediately when we go to
</span><span class="c1"></span>			<span class="c1">// scan those.
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">oblet</span> <span class="o">:=</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">maxObletBytes</span><span class="p">;</span> <span class="nx">oblet</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span><span class="o">+</span><span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">;</span> <span class="nx">oblet</span> <span class="o">+=</span> <span class="nx">maxObletBytes</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">!</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">putFast</span><span class="p">(</span><span class="nx">oblet</span><span class="p">)</span> <span class="p">{</span>
					<span class="nx">gcw</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="nx">oblet</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// Compute the size of the oblet. Since this object
</span><span class="c1"></span>		<span class="c1">// must be a large object, s.base() is the beginning
</span><span class="c1"></span>		<span class="c1">// of the object.
</span><span class="c1"></span>		<span class="nx">n</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="o">-</span> <span class="nx">b</span>
		<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nx">maxObletBytes</span> <span class="p">{</span>
			<span class="nx">n</span> <span class="p">=</span> <span class="nx">maxObletBytes</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 扫描对象中的指针
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">i</span> <span class="kt">uintptr</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="p">{</span>
		<span class="c1">// Find bits for this word.
</span><span class="c1"></span>		<span class="c1">// 获取对应的bit
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Avoid needless hbits.next() on last iteration.
</span><span class="c1"></span>			<span class="nx">hbits</span> <span class="p">=</span> <span class="nx">hbits</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="c1">// Load bits once. See CL 22712 and issue 16973 for discussion.
</span><span class="c1"></span>		<span class="nx">bits</span> <span class="o">:=</span> <span class="nx">hbits</span><span class="p">.</span><span class="nf">bits</span><span class="p">()</span>
		<span class="c1">// 检查scan bit判断是否继续扫描, 注意第二个scan bit是checkmark
</span><span class="c1"></span>		<span class="c1">// During checkmarking, 1-word objects store the checkmark
</span><span class="c1"></span>		<span class="c1">// in the type bit for the one word. The only one-word objects
</span><span class="c1"></span>		<span class="c1">// are pointers, or else they&#39;d be merged with other non-pointer
</span><span class="c1"></span>		<span class="c1">// data into larger allocations.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">1</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">&amp;&amp;</span> <span class="nx">bits</span><span class="o">&amp;</span><span class="nx">bitScan</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">break</span> <span class="c1">// no more pointers in this object
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="c1">// 检查pointer bit, 不是指针则继续
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">bits</span><span class="o">&amp;</span><span class="nx">bitPointer</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">continue</span> <span class="c1">// not a pointer
</span><span class="c1"></span>		<span class="p">}</span>

		<span class="c1">// Work here is duplicated in scanblock and above.
</span><span class="c1"></span>		<span class="c1">// If you make changes here, make changes there too.
</span><span class="c1"></span>		<span class="c1">// 取出指针的值
</span><span class="c1"></span>		<span class="nx">obj</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span> <span class="o">+</span> <span class="nx">i</span><span class="p">))</span>

		<span class="c1">// At this point we have extracted the next potential pointer.
</span><span class="c1"></span>		<span class="c1">// Quickly filter out nil and pointers back to the current object.
</span><span class="c1"></span>		<span class="c1">// 如果指针在arena区域中, 则调用greyobject标记对象并把对象放到标记队列中
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">obj</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">obj</span><span class="o">-</span><span class="nx">b</span> <span class="o">&gt;=</span> <span class="nx">n</span> <span class="p">{</span>
			<span class="c1">// Test if obj points into the Go heap and, if so,
</span><span class="c1"></span>			<span class="c1">// mark the object.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// Note that it&#39;s possible for findObject to
</span><span class="c1"></span>			<span class="c1">// fail if obj points to a just-allocated heap
</span><span class="c1"></span>			<span class="c1">// object because of a race with growing the
</span><span class="c1"></span>			<span class="c1">// heap. In this case, we know the object was
</span><span class="c1"></span>			<span class="c1">// just allocated and hence will be marked by
</span><span class="c1"></span>			<span class="c1">// allocation itself.
</span><span class="c1"></span>
			<span class="k">if</span> <span class="nx">obj</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">objIndex</span> <span class="o">:=</span> <span class="nf">findObject</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span> <span class="nx">obj</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nf">greyobject</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="nx">objIndex</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 统计扫描过的大小和对象数量
</span><span class="c1"></span>	<span class="nx">gcw</span><span class="p">.</span><span class="nx">bytesMarked</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
	<span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="o">+=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="gcassistalloc">gcAssistAlloc</h4>
<p>为了保证用户程序分配内存的速度不会超出后台任务的标记速度，运行时还引入了标记辅助技术，它遵循一条非常简单并且朴实的原则，分配多少内存就需要完成多少标记任务。每一个 Goroutine 都持有 gcAssistBytes 字段，这个字段存储了当前 Goroutine 辅助标记的对象字节数。在并发标记阶段期间，当 Goroutine 调用 runtime.mallocgc 分配新的对象时，该函数会检查申请内存的 Goroutine 是否处于入不敷出的状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="kd">var</span> <span class="nx">assistG</span><span class="o">*</span><span class="nx">g</span>
	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">assistG</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">assistG</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">assistG</span> <span class="p">=</span> <span class="nx">assistG</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
		<span class="p">}</span>
		<span class="nx">assistG</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">-=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">assistG</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">gcAssistAlloc</span><span class="p">(</span><span class="nx">assistG</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">...</span>
	<span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>申请内存时调用的 runtime.gcAssistAlloc 和扫描内存时调用的 runtime.gcFlushBgCredit 分别负责『借债』和『还债』，通过这套债务管理系统，我们能够保证 Goroutine 在正常运行的同时不会为垃圾收集造成太多的压力，保证在达到堆大小目标时完成标记阶段。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201214205038.png" alt=""></p>
<p>每个 Goroutine 持有的 gcAssistBytes 表示当前协程辅助标记的字节数，全局垃圾收集控制器持有的 bgScanCredit 表示后台协程辅助标记的字节数，当本地 Goroutine 分配了较多的对象时，可以使用公用的信用 bgScanCredit 偿还。我们先来分析 runtime.gcAssistAlloc 函数的实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// gcAssistAlloc performs GC work to make gp&#39;s assist debt positive.
</span><span class="c1">// gp must be the calling user gorountine.
</span><span class="c1">//
</span><span class="c1">// This must be called with preemption enabled.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gcAssistAlloc</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//该函数会先根据 Goroutine 的 gcAssistBytes 和垃圾收集控制器的配置计算需要完成的标记任务数量，如果全局信用 bgScanCredit 中有可用的点数，那么就会减去该点数，因为并发执行没有加锁，所以全局信用可能会被更新成负值，然而在长期来看这不是一个比较重要的问题。
</span><span class="c1"></span>	<span class="c1">// Don&#39;t assist in non-preemptible contexts. These are
</span><span class="c1"></span>	<span class="c1">// generally fragile and won&#39;t allow the assist to block.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">getg</span><span class="p">()</span> <span class="o">==</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">mp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">;</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">locks</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">traced</span> <span class="o">:=</span> <span class="kc">false</span>
<span class="nx">retry</span><span class="p">:</span>
	<span class="c1">// Compute the amount of scan work we need to do to make the
</span><span class="c1"></span>	<span class="c1">// balance positive. When the required amount of work is low,
</span><span class="c1"></span>	<span class="c1">// we over-assist to build up credit for future allocations
</span><span class="c1"></span>	<span class="c1">// and amortize the cost of assisting.
</span><span class="c1"></span>	<span class="nx">debtBytes</span> <span class="o">:=</span> <span class="o">-</span><span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span>
	<span class="nx">scanWork</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">assistWorkPerByte</span> <span class="o">*</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">debtBytes</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">scanWork</span> <span class="p">&lt;</span> <span class="nx">gcOverAssistWork</span> <span class="p">{</span>
		<span class="nx">scanWork</span> <span class="p">=</span> <span class="nx">gcOverAssistWork</span>
		<span class="nx">debtBytes</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">assistBytesPerWork</span> <span class="o">*</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">scanWork</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="c1">// Steal as much credit as we can from the background GC&#39;s
</span><span class="c1"></span>	<span class="c1">// scan credit. This is racy and may drop the background
</span><span class="c1"></span>	<span class="c1">// credit below 0 if two mutators steal at the same time. This
</span><span class="c1"></span>	<span class="c1">// will just cause steals to fail until credit is accumulated
</span><span class="c1"></span>	<span class="c1">// again, so in the long run it doesn&#39;t really matter, but we
</span><span class="c1"></span>	<span class="c1">// do have to handle the negative credit case.
</span><span class="c1"></span>	<span class="nx">bgScanCredit</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Loadint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">bgScanCredit</span><span class="p">)</span>
	<span class="nx">stolen</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">bgScanCredit</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">bgScanCredit</span> <span class="p">&lt;</span> <span class="nx">scanWork</span> <span class="p">{</span>
			<span class="nx">stolen</span> <span class="p">=</span> <span class="nx">bgScanCredit</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">assistBytesPerWork</span><span class="o">*</span><span class="nb">float64</span><span class="p">(</span><span class="nx">stolen</span><span class="p">))</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">stolen</span> <span class="p">=</span> <span class="nx">scanWork</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">+=</span> <span class="nx">debtBytes</span>
		<span class="p">}</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">bgScanCredit</span><span class="p">,</span> <span class="o">-</span><span class="nx">stolen</span><span class="p">)</span>

		<span class="nx">scanWork</span> <span class="o">-=</span> <span class="nx">stolen</span>

		<span class="k">if</span> <span class="nx">scanWork</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// We were able to steal all of the credit we
</span><span class="c1"></span>			<span class="c1">// needed.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">traced</span> <span class="p">{</span>
				<span class="nf">traceGCMarkAssistDone</span><span class="p">()</span>
			<span class="p">}</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">traced</span> <span class="p">{</span>
		<span class="nx">traced</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nf">traceGCMarkAssistStart</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">//如果全局信用不足以覆盖本地的债务，运行时会在系统栈中调用 runtime.gcAssistAlloc1 执行标记任务，该函数会直接调用 runtime.gcDrainN 完成指定数量的标记任务并返回：
</span><span class="c1"></span>	<span class="c1">// Perform assist work
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">gcAssistAlloc1</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">scanWork</span><span class="p">)</span>
		<span class="c1">// The user stack may have moved, so this can&#39;t touch
</span><span class="c1"></span>		<span class="c1">// anything on it until it returns from systemstack.
</span><span class="c1"></span>	<span class="p">})</span>

	<span class="nx">completed</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="o">!=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="k">if</span> <span class="nx">completed</span> <span class="p">{</span>
		<span class="nf">gcMarkDone</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">//如果在完成标记辅助任务后，当前 Goroutine 仍然入不敷出并且 Goroutine 没有被抢占，那么运行时会执行 runtime.gcParkAssist；在该函数中，如果全局信用依然不足，runtime.gcParkAssist 会将当前 Goroutine 陷入休眠、加入全局的辅助标记队列并等待后台标记任务的唤醒。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// We were unable steal enough credit or perform
</span><span class="c1"></span>		<span class="c1">// enough work to pay off the assist debt. We need to
</span><span class="c1"></span>		<span class="c1">// do one of these before letting the mutator allocate
</span><span class="c1"></span>		<span class="c1">// more to prevent over-allocation.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// If this is because we were preempted, reschedule
</span><span class="c1"></span>		<span class="c1">// and try some more.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">{</span>
			<span class="nf">Gosched</span><span class="p">()</span>
			<span class="k">goto</span> <span class="nx">retry</span>
		<span class="p">}</span>

		<span class="c1">// Add this G to an assist queue and park. When the GC
</span><span class="c1"></span>		<span class="c1">// has more background credit, it will satisfy queued
</span><span class="c1"></span>		<span class="c1">// assists before flushing to the global credit pool.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// Note that this does *not* get woken up when more
</span><span class="c1"></span>		<span class="c1">// work is added to the work list. The theory is that
</span><span class="c1"></span>		<span class="c1">// there wasn&#39;t enough work to do anyway, so we might
</span><span class="c1"></span>		<span class="c1">// as well let background marking take care of the
</span><span class="c1"></span>		<span class="c1">// work that is available.
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nf">gcParkAssist</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="nx">retry</span>
		<span class="p">}</span>

		<span class="c1">// At this point either background GC has satisfied
</span><span class="c1"></span>		<span class="c1">// this G&#39;s assist debt, or the GC cycle is over.
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">traced</span> <span class="p">{</span>
		<span class="nf">traceGCMarkAssistDone</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// gcAssistAlloc1 is the part of gcAssistAlloc that runs on the system
</span><span class="c1">// stack. This is a separate function to make it easier to see that
</span><span class="c1">// we&#39;re not capturing anything from the user stack, since the user
</span><span class="c1">// stack may move while we&#39;re in this function.
</span><span class="c1">//
</span><span class="c1">// gcAssistAlloc1 indicates whether this assist completed the mark
</span><span class="c1">// phase by setting gp.param to non-nil. This can&#39;t be communicated on
</span><span class="c1">// the stack since it may move.
</span><span class="c1">//
</span><span class="c1">//go:systemstack
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gcAssistAlloc1</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">scanWork</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Clear the flag indicating that this assist completed the
</span><span class="c1"></span>	<span class="c1">// mark phase.
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcBlackenEnabled</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// The gcBlackenEnabled check in malloc races with the
</span><span class="c1"></span>		<span class="c1">// store that clears it but an atomic check in every malloc
</span><span class="c1"></span>		<span class="c1">// would be a performance hit.
</span><span class="c1"></span>		<span class="c1">// Instead we recheck it here on the non-preemptable system
</span><span class="c1"></span>		<span class="c1">// stack to determine if we should perform an assist.
</span><span class="c1"></span>
		<span class="c1">// GC is done, so ignore any remaining debt.
</span><span class="c1"></span>		<span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// Track time spent in this assist. Since we&#39;re on the
</span><span class="c1"></span>	<span class="c1">// system stack, this is non-preemptible, so we can
</span><span class="c1"></span>	<span class="c1">// just measure start and end time.
</span><span class="c1"></span>	<span class="nx">startTime</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>

	<span class="nx">decnwait</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">nwait</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">decnwait</span> <span class="o">==</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span> <span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: work.nwait =&#34;</span><span class="p">,</span> <span class="nx">decnwait</span><span class="p">,</span> <span class="s">&#34;work.nproc=&#34;</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;nwait &gt; work.nprocs&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// gcDrainN requires the caller to be preemptible.
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="nx">waitReasonGCAssistMarking</span>

	<span class="c1">// drain own cached work first in the hopes that it
</span><span class="c1"></span>	<span class="c1">// will be more cache friendly.
</span><span class="c1"></span>	<span class="nx">gcw</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">gcw</span>
	<span class="nx">workDone</span> <span class="o">:=</span> <span class="nf">gcDrainN</span><span class="p">(</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">scanWork</span><span class="p">)</span>

	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>

	<span class="c1">// Record that we did this much scan work.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Back out the number of bytes of assist credit that
</span><span class="c1"></span>	<span class="c1">// this scan work counts for. The &#34;1+&#34; is a poor man&#39;s
</span><span class="c1"></span>	<span class="c1">// round-up, to ensure this adds credit even if
</span><span class="c1"></span>	<span class="c1">// assistBytesPerWork is very low.
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">assistBytesPerWork</span><span class="o">*</span><span class="nb">float64</span><span class="p">(</span><span class="nx">workDone</span><span class="p">))</span>

	<span class="c1">// If this is the last worker and we ran out of work,
</span><span class="c1"></span>	<span class="c1">// signal a completion point.
</span><span class="c1"></span>	<span class="nx">incnwait</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">nwait</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">incnwait</span> <span class="p">&gt;</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span> <span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: work.nwait=&#34;</span><span class="p">,</span> <span class="nx">incnwait</span><span class="p">,</span>
			<span class="s">&#34;work.nproc=&#34;</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;work.nwait &gt; work.nproc&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">incnwait</span> <span class="o">==</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// This has reached a background completion point. Set
</span><span class="c1"></span>		<span class="c1">// gp.param to a non-nil value to indicate this. It
</span><span class="c1"></span>		<span class="c1">// doesn&#39;t matter what we set it to (it just has to be
</span><span class="c1"></span>		<span class="c1">// a valid pointer).
</span><span class="c1"></span>		<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">duration</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">-</span> <span class="nx">startTime</span>
	<span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcAssistTime</span> <span class="o">+=</span> <span class="nx">duration</span>
	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcAssistTime</span> <span class="p">&gt;</span> <span class="nx">gcAssistTimeSlack</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">assistTime</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcAssistTime</span><span class="p">)</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcAssistTime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// gcParkAssist puts the current goroutine on the assist queue and parks.
</span><span class="c1">//
</span><span class="c1">// gcParkAssist reports whether the assist is now satisfied. If it
</span><span class="c1">// returns false, the caller must retry the assist.
</span><span class="c1">//
</span><span class="c1">//go:nowritebarrier
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gcParkAssist</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">// If the GC cycle finished while we were getting the lock,
</span><span class="c1"></span>	<span class="c1">// exit the assist. The cycle can&#39;t finish while we hold the
</span><span class="c1"></span>	<span class="c1">// lock.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcBlackenEnabled</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">oldList</span> <span class="o">:=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">q</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">q</span><span class="p">.</span><span class="nf">pushBack</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>

	<span class="c1">// Recheck for background credit now that this G is in
</span><span class="c1"></span>	<span class="c1">// the queue, but can still back out. This avoids a
</span><span class="c1"></span>	<span class="c1">// race in case background marking has flushed more
</span><span class="c1"></span>	<span class="c1">// credit since we checked above.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Loadint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">bgScanCredit</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">q</span> <span class="p">=</span> <span class="nx">oldList</span>
		<span class="k">if</span> <span class="nx">oldList</span><span class="p">.</span><span class="nx">tail</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">oldList</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">schedlink</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">// Park.
</span><span class="c1"></span>	<span class="nf">goparkunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">waitReasonGCAssistWait</span><span class="p">,</span> <span class="nx">traceEvGoBlockGC</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>用于还债的 runtime.gcFlushBgCredit 实现比较简单，如果辅助队列中不存在等待的 Goroutine，那么当前的信用会直接加到全局信用 bgScanCredit 中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// gcFlushBgCredit flushes scanWork units of background scan work
</span><span class="c1">// credit. This first satisfies blocked assists on the
</span><span class="c1">// work.assistQueue and then flushes any remaining credit to
</span><span class="c1">// gcController.bgScanCredit.
</span><span class="c1">//
</span><span class="c1">// Write barriers are disallowed because this is used by gcDrain after
</span><span class="c1">// it has ensured that all work is drained and this must preserve that
</span><span class="c1">// condition.
</span><span class="c1">//
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gcFlushBgCredit</span><span class="p">(</span><span class="nx">scanWork</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">q</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// Fast path; there are no blocked assists. There&#39;s a
</span><span class="c1"></span>		<span class="c1">// small window here where an assist may add itself to
</span><span class="c1"></span>		<span class="c1">// the blocked queue and park. If that happens, we&#39;ll
</span><span class="c1"></span>		<span class="c1">// just get it on the next flush.
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">bgScanCredit</span><span class="p">,</span> <span class="nx">scanWork</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">scanBytes</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">scanWork</span><span class="p">)</span> <span class="o">*</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">assistBytesPerWork</span><span class="p">)</span>

	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">!</span><span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">q</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">scanBytes</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">q</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
		<span class="c1">// Note that gp.gcAssistBytes is negative because gp
</span><span class="c1"></span>		<span class="c1">// is in debt. Think carefully about the signs below.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">scanBytes</span><span class="o">+</span><span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Satisfy this entire assist debt.
</span><span class="c1"></span>			<span class="nx">scanBytes</span> <span class="o">+=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="c1">// It&#39;s important that we *not* put gp in
</span><span class="c1"></span>			<span class="c1">// runnext. Otherwise, it&#39;s possible for user
</span><span class="c1"></span>			<span class="c1">// code to exploit the GC worker&#39;s high
</span><span class="c1"></span>			<span class="c1">// scheduler priority to get itself always run
</span><span class="c1"></span>			<span class="c1">// before other goroutines and always in the
</span><span class="c1"></span>			<span class="c1">// fresh quantum started by GC.
</span><span class="c1"></span>			<span class="nf">ready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// Partially satisfy this assist.
</span><span class="c1"></span>			<span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">+=</span> <span class="nx">scanBytes</span>
			<span class="nx">scanBytes</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="c1">// As a heuristic, we move this assist to the
</span><span class="c1"></span>			<span class="c1">// back of the queue so that large assists
</span><span class="c1"></span>			<span class="c1">// can&#39;t clog up the assist queue and
</span><span class="c1"></span>			<span class="c1">// substantially delay small assists.
</span><span class="c1"></span>			<span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">q</span><span class="p">.</span><span class="nf">pushBack</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">scanBytes</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Convert from scan bytes back to work.
</span><span class="c1"></span>		<span class="nx">scanWork</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">scanBytes</span><span class="p">)</span> <span class="o">*</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">assistWorkPerByte</span><span class="p">)</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">bgScanCredit</span><span class="p">,</span> <span class="nx">scanWork</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果辅助队列不为空，上述函数会根据每个 Goroutine 的债务数量和已完成的工作决定是否唤醒这些陷入休眠的 Goroutine；如果唤醒所有的 Goroutine 后，标记任务量仍然有剩余，这些标记任务都会加入全局信用中。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201214222145.png" alt=""></p>
<p>用户程序辅助标记的核心目的就是避免用户程序分配内存影响垃圾收集器完成标记工作的期望时间，它通过维护账户体系保证用户程序不会对垃圾收集造成过多的负担，一旦用户程序分配了大量的内存，该用户程序就会通过辅助标记的方式平衡账本，这个过程会在最后达到相对平衡，保证标记任务在到达期望堆大小时完成。</p>
<h3 id="标记终止-gcmarkdone">标记终止: gcMarkDone</h3>
<p>当所有处理器的本地任务都完成并且不存在剩余的工作 Goroutine 时,会执行gcMarkDone函数准备进入完成标记阶段(mark termination):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// gcMarkDone transitions the GC from mark to mark termination if all
</span><span class="c1">// reachable objects have been marked (that is, there are no grey
</span><span class="c1">// objects and can be no more in the future). Otherwise, it flushes
</span><span class="c1">// all local work to the global queues where it can be discovered by
</span><span class="c1">// other workers.
</span><span class="c1">//
</span><span class="c1">// This should be called when all local mark work has been drained and
</span><span class="c1">// there are no remaining workers. Specifically, when
</span><span class="c1">//
</span><span class="c1">//   work.nwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(p)
</span><span class="c1">//
</span><span class="c1">// The calling context must be preemptible.
</span><span class="c1">//
</span><span class="c1">// Flushing local work is important because idle Ps may have local
</span><span class="c1">// work queued. This is the only way to make that work visible and
</span><span class="c1">// drive GC to completion.
</span><span class="c1">//
</span><span class="c1">// It is explicitly okay to have write barriers in this function. If
</span><span class="c1">// it does transition to mark termination, then all reachable objects
</span><span class="c1">// have been marked, so the write barrier cannot shade any more
</span><span class="c1">// objects.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gcMarkDone</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Ensure only one thread is running the ragged barrier at a
</span><span class="c1"></span>	<span class="c1">// time.
</span><span class="c1"></span>	<span class="nf">semacquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">markDoneSema</span><span class="p">)</span>

<span class="nx">top</span><span class="p">:</span>
	<span class="c1">// Re-check transition condition under transition lock.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// It&#39;s critical that this checks the global work queues are
</span><span class="c1"></span>	<span class="c1">// empty before performing the ragged barrier. Otherwise,
</span><span class="c1"></span>	<span class="c1">// there could be global work that a P could take after the P
</span><span class="c1"></span>	<span class="c1">// has passed the ragged barrier.
</span><span class="c1"></span>	<span class="c1">//当所有可达对象都被标记后，该函数会将垃圾收集的状态切换至 _GCmarktermination；如果本地队列中仍然存在待处理的任务，当前方法会将所有的任务加入全局队列并等待其他 Goroutine 完成处理：
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!(</span><span class="nx">gcphase</span> <span class="o">==</span> <span class="nx">_GCmark</span> <span class="o">&amp;&amp;</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nwait</span> <span class="o">==</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="kc">nil</span><span class="p">))</span> <span class="p">{</span>
		<span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">markDoneSema</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// forEachP needs worldsema to execute, and we&#39;ll need it to
</span><span class="c1"></span>	<span class="c1">// stop the world later, so acquire worldsema now.
</span><span class="c1"></span>	<span class="nf">semacquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">worldsema</span><span class="p">)</span>

	<span class="c1">// Flush all local buffers and collect flushedWork flags.
</span><span class="c1"></span>	<span class="nx">gcMarkDoneFlushed</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 把所有本地标记队列中的对象都推到全局标记队列
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
		<span class="c1">// Mark the user stack as preemptible so that it may be scanned.
</span><span class="c1"></span>		<span class="c1">// Otherwise, our attempt to force all P&#39;s to a safepoint could
</span><span class="c1"></span>		<span class="c1">// result in a deadlock as we attempt to preempt a worker that&#39;s
</span><span class="c1"></span>		<span class="c1">// trying to preempt us (e.g. for a stack scan).
</span><span class="c1"></span>		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
		<span class="nf">forEachP</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Flush the write barrier buffer, since this may add
</span><span class="c1"></span>			<span class="c1">// work to the gcWork.
</span><span class="c1"></span>			<span class="nf">wbBufFlush1</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
			<span class="c1">// For debugging, shrink the write barrier
</span><span class="c1"></span>			<span class="c1">// buffer so it flushes immediately.
</span><span class="c1"></span>			<span class="c1">// wbBuf.reset will keep it at this size as
</span><span class="c1"></span>			<span class="c1">// long as throwOnGCWork is set.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">debugCachedWork</span> <span class="p">{</span>
				<span class="nx">b</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">wbBuf</span>
				<span class="nx">b</span><span class="p">.</span><span class="nx">end</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">wbBufEntryPointers</span><span class="p">]))</span>
				<span class="nx">b</span><span class="p">.</span><span class="nx">debugGen</span> <span class="p">=</span> <span class="nx">gcWorkPauseGen</span>
			<span class="p">}</span>
			<span class="c1">// Flush the gcWork, since this may create global work
</span><span class="c1"></span>			<span class="c1">// and set the flushedWork flag.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// TODO(austin): Break up these workbufs to
</span><span class="c1"></span>			<span class="c1">// better distribute work.
</span><span class="c1"></span>			<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">dispose</span><span class="p">()</span>
			<span class="c1">// Collect the flushedWork flag.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">flushedWork</span> <span class="p">{</span>
				<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcMarkDoneFlushed</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
				<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">flushedWork</span> <span class="p">=</span> <span class="kc">false</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">debugCachedWork</span> <span class="p">{</span>
				<span class="c1">// For debugging, freeze the gcWork
</span><span class="c1"></span>				<span class="c1">// until we know whether we&#39;ve reached
</span><span class="c1"></span>				<span class="c1">// completion or not. If we think
</span><span class="c1"></span>				<span class="c1">// we&#39;ve reached completion, but
</span><span class="c1"></span>				<span class="c1">// there&#39;s a paused gcWork, then
</span><span class="c1"></span>				<span class="c1">// that&#39;s a bug.
</span><span class="c1"></span>				<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">pauseGen</span> <span class="p">=</span> <span class="nx">gcWorkPauseGen</span>
				<span class="c1">// Capture the G&#39;s stack.
</span><span class="c1"></span>				<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">pauseStack</span> <span class="p">{</span>
					<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">pauseStack</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
				<span class="p">}</span>
				<span class="nf">callers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">pauseStack</span><span class="p">[:])</span>
			<span class="p">}</span>
		<span class="p">})</span>
		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="k">if</span> <span class="nx">gcMarkDoneFlushed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">debugCachedWork</span> <span class="p">{</span>
			<span class="c1">// Release paused gcWorks.
</span><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcWorkPauseGen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// More grey objects were discovered since the
</span><span class="c1"></span>		<span class="c1">// previous termination check, so there may be more
</span><span class="c1"></span>		<span class="c1">// work to do. Keep going. It&#39;s possible the
</span><span class="c1"></span>		<span class="c1">// transition condition became true again during the
</span><span class="c1"></span>		<span class="c1">// ragged barrier, so re-check it.
</span><span class="c1"></span>		<span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">worldsema</span><span class="p">)</span>
		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">debugCachedWork</span> <span class="p">{</span>
		<span class="nx">throwOnGCWork</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="c1">// Release paused gcWorks. If there are any, they
</span><span class="c1"></span>		<span class="c1">// should now observe throwOnGCWork and panic.
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcWorkPauseGen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// There was no global work, no local work, and no Ps
</span><span class="c1"></span>	<span class="c1">// communicated work since we took markDoneSema. Therefore
</span><span class="c1"></span>	<span class="c1">// there are no grey objects and no more objects can be
</span><span class="c1"></span>	<span class="c1">// shaded. Transition to mark termination.
</span><span class="c1"></span>	<span class="nx">now</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">tMarkTerm</span> <span class="p">=</span> <span class="nx">now</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">pauseStart</span> <span class="p">=</span> <span class="nx">now</span>
	<span class="c1">//如果运行时中不包含全局任务、处理器中也不存在本地任务，那么当前垃圾收集循环中的灰色对象也就都标记成了黑色，我们就可以开始触发垃圾收集的阶段迁移了：
</span><span class="c1"></span>	<span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;gcing&#34;</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCSTWStart</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 停止所有运行中的G, 并禁止它们运行
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="nx">stopTheWorldWithSema</span><span class="p">)</span>
	<span class="c1">// The gcphase is _GCmark, it will transition to _GCmarktermination
</span><span class="c1"></span>	<span class="c1">// below. The important thing is that the wb remains active until
</span><span class="c1"></span>	<span class="c1">// all marking is complete. This includes writes made by the GC.
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nx">debugCachedWork</span> <span class="p">{</span>
		<span class="c1">// For debugging, double check that no work was added after we
</span><span class="c1"></span>		<span class="c1">// went around above and disable write barrier buffering.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
			<span class="nx">gcw</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">gcw</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
				<span class="nf">printlock</span><span class="p">()</span>
				<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: P &#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="s">&#34; flushedWork &#34;</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">flushedWork</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">wbuf1</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nb">print</span><span class="p">(</span><span class="s">&#34; wbuf1=&lt;nil&gt;&#34;</span><span class="p">)</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nb">print</span><span class="p">(</span><span class="s">&#34; wbuf1.n=&#34;</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">wbuf1</span><span class="p">.</span><span class="nx">nobj</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">wbuf2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nb">print</span><span class="p">(</span><span class="s">&#34; wbuf2=&lt;nil&gt;&#34;</span><span class="p">)</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nb">print</span><span class="p">(</span><span class="s">&#34; wbuf2.n=&#34;</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">wbuf2</span><span class="p">.</span><span class="nx">nobj</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nb">print</span><span class="p">(</span><span class="s">&#34;\n&#34;</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">pauseGen</span> <span class="o">==</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">putGen</span> <span class="p">{</span>
					<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: checkPut already failed at this generation&#34;</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;throwOnGCWork&#34;</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// For unknown reasons (see issue #27993), there is
</span><span class="c1"></span>		<span class="c1">// sometimes work left over when we enter mark
</span><span class="c1"></span>		<span class="c1">// termination. Detect this and resume concurrent
</span><span class="c1"></span>		<span class="c1">// mark. This is obviously unfortunate.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// Switch to the system stack to call wbBufFlush1,
</span><span class="c1"></span>		<span class="c1">// though in this case it doesn&#39;t matter because we&#39;re
</span><span class="c1"></span>		<span class="c1">// non-preemptible anyway.
</span><span class="c1"></span>		<span class="nx">restart</span> <span class="o">:=</span> <span class="kc">false</span>
		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
				<span class="nf">wbBufFlush1</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">!</span><span class="nx">p</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">restart</span> <span class="p">=</span> <span class="kc">true</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">})</span>
		<span class="k">if</span> <span class="nx">restart</span> <span class="p">{</span>
			<span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>
			<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">now</span> <span class="o">:=</span> <span class="nf">startTheWorldWithSema</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
				<span class="nx">work</span><span class="p">.</span><span class="nx">pauseNS</span> <span class="o">+=</span> <span class="nx">now</span> <span class="o">-</span> <span class="nx">work</span><span class="p">.</span><span class="nx">pauseStart</span>
			<span class="p">})</span>
			<span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">worldsema</span><span class="p">)</span>
			<span class="k">goto</span> <span class="nx">top</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//函数在最后会关闭混合写屏障、唤醒所有协助垃圾收集的用户程序、恢复用户 Goroutine 的调度并调用 runtime.gcMarkTermination 进入标记终止阶段：
</span><span class="c1"></span>	<span class="c1">// Disable assists and background workers. We must do
</span><span class="c1"></span>	<span class="c1">// this before waking blocked assists.
</span><span class="c1"></span>	<span class="c1">// 禁止辅助GC和后台标记任务的运行
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcBlackenEnabled</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="c1">// Wake all blocked assists. These will run when we
</span><span class="c1"></span>	<span class="c1">// start the world again.
</span><span class="c1"></span>	<span class="c1">// 唤醒所有因为辅助GC而休眠的G
</span><span class="c1"></span>	<span class="nf">gcWakeAllAssists</span><span class="p">()</span>

	<span class="c1">// Likewise, release the transition lock. Blocked
</span><span class="c1"></span>	<span class="c1">// workers and assists will run when we start the
</span><span class="c1"></span>	<span class="c1">// world again.
</span><span class="c1"></span>	<span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">markDoneSema</span><span class="p">)</span>

	<span class="c1">// In STW mode, re-enable user goroutines. These will be
</span><span class="c1"></span>	<span class="c1">// queued to run after we start the world.
</span><span class="c1"></span>	<span class="nf">schedEnableUser</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
	<span class="c1">// 计算下一次触发gc需要的heap大小
</span><span class="c1"></span>	<span class="c1">// endCycle depends on all gcWork cache stats being flushed.
</span><span class="c1"></span>	<span class="c1">// The termination algorithm above ensured that up to
</span><span class="c1"></span>	<span class="c1">// allocations since the ragged barrier.
</span><span class="c1"></span>	<span class="nx">nextTriggerRatio</span> <span class="o">:=</span> <span class="nx">gcController</span><span class="p">.</span><span class="nf">endCycle</span><span class="p">()</span>

	<span class="c1">// Perform mark termination. This will restart the world.
</span><span class="c1"></span>	<span class="c1">// 进入完成标记阶段, 会重新启动世界
</span><span class="c1"></span>	<span class="nf">gcMarkTermination</span><span class="p">(</span><span class="nx">nextTriggerRatio</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// gcWakeAllAssists wakes all currently blocked assists. This is used
</span><span class="c1">// at the end of a GC cycle. gcBlackenEnabled must be false to prevent
</span><span class="c1">// new assists from going to sleep after this point.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gcWakeAllAssists</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">list</span> <span class="o">:=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">q</span><span class="p">.</span><span class="nf">popList</span><span class="p">()</span>
	<span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="gcmarktermination">gcMarkTermination</h4>
<p>gcMarkTermination函数会进入完成标记阶段:</p>
<p>函数中很多数据统计的代码，包括正在使用的内存大小、本轮垃圾收集的暂停时间、CPU 的利用率等数据，这些数据能够帮助控制器决定下一轮触发垃圾收集的堆大小.</p>
<p>除了数据统计之外该函数还会调用 runtime.gcSweep 重置清理阶段的相关状态并在需要时阻塞清理所有的内存管理单元；_GCmarktermination 状态在垃圾收集中并不会持续太久，它会迅速转换至_GCoff 并恢复应用程序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">gcMarkTermination</span><span class="p">(</span><span class="nx">nextTriggerRatio</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// World is stopped.
</span><span class="c1"></span>	<span class="c1">// Start marktermination which includes enabling the write barrier.
</span><span class="c1"></span>	<span class="c1">// 禁止辅助GC和后台标记任务的运行
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcBlackenEnabled</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="c1">// 设置当前GC阶段到完成标记阶段, 并启用写屏障
</span><span class="c1"></span>	<span class="nf">setGCPhase</span><span class="p">(</span><span class="nx">_GCmarktermination</span><span class="p">)</span>
	<span class="c1">// 记录开始时间
</span><span class="c1"></span>	<span class="nx">work</span><span class="p">.</span><span class="nx">heap1</span> <span class="p">=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span>
	<span class="nx">startTime</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="c1">// 禁止G被抢占
</span><span class="c1"></span>	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;gcing&#34;</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">traceback</span> <span class="p">=</span> <span class="mi">2</span>
	<span class="c1">// 设置G的状态为等待中这样它的栈可以被扫描
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="nx">waitReasonGarbageCollection</span>

	<span class="c1">// Run gc on the g0 stack. We do this so that the g stack
</span><span class="c1"></span>	<span class="c1">// we&#39;re currently running on will no longer change. Cuts
</span><span class="c1"></span>	<span class="c1">// the root set down a bit (g0 stacks are not scanned, and
</span><span class="c1"></span>	<span class="c1">// we don&#39;t need to scan gc&#39;s internal state).  We also
</span><span class="c1"></span>	<span class="c1">// need to switch to g0 so we can shrink the stack.
</span><span class="c1"></span>	<span class="c1">// 切换到g0运行
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// 开始STW中的标记
</span><span class="c1"></span>		<span class="nf">gcMark</span><span class="p">(</span><span class="nx">startTime</span><span class="p">)</span>
		<span class="c1">// 必须立刻返回, 因为外面的G的栈有可能被移动, 不能在这之后访问外面的变量
</span><span class="c1"></span>		<span class="c1">// Must return immediately.
</span><span class="c1"></span>		<span class="c1">// The outer function&#39;s stack may have moved
</span><span class="c1"></span>		<span class="c1">// during gcMark (it shrinks stacks, including the
</span><span class="c1"></span>		<span class="c1">// outer function&#39;s stack), so we must not refer
</span><span class="c1"></span>		<span class="c1">// to any of its variables. Return back to the
</span><span class="c1"></span>		<span class="c1">// non-system stack to pick up the new addresses
</span><span class="c1"></span>		<span class="c1">// before continuing.
</span><span class="c1"></span>	<span class="p">})</span>
	<span class="c1">// 重新切换到g0运行
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">work</span><span class="p">.</span><span class="nx">heap2</span> <span class="p">=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">bytesMarked</span>
		<span class="c1">// 如果启用了checkmark则执行检查, 检查是否所有可到达的对象都有标记
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gccheckmark</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Run a full non-parallel, stop-the-world
</span><span class="c1"></span>			<span class="c1">// mark using checkmark bits, to check that we
</span><span class="c1"></span>			<span class="c1">// didn&#39;t forget to mark anything during the
</span><span class="c1"></span>			<span class="c1">// concurrent mark process.
</span><span class="c1"></span>			<span class="nf">gcResetMarkState</span><span class="p">()</span>
			<span class="nf">initCheckmarks</span><span class="p">()</span>
			<span class="nx">gcw</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">gcw</span>
			<span class="nf">gcDrain</span><span class="p">(</span><span class="nx">gcw</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
			<span class="nf">wbBufFlush1</span><span class="p">(</span><span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
			<span class="nx">gcw</span><span class="p">.</span><span class="nf">dispose</span><span class="p">()</span>
			<span class="nf">clearCheckmarks</span><span class="p">()</span>
		<span class="p">}</span>

		<span class="c1">// marking is complete so we can turn the write barrier off
</span><span class="c1"></span>		<span class="c1">//标记终止结束后，会进入 GCoff 阶段，并调用 gcSweep 来并发的使后台清扫器 Goroutine 与赋值器并发执行。
</span><span class="c1"></span>		<span class="c1">// 设置当前GC阶段到关闭, 并禁用写屏障
</span><span class="c1"></span>		<span class="nf">setGCPhase</span><span class="p">(</span><span class="nx">_GCoff</span><span class="p">)</span>
		<span class="c1">// 唤醒后台清扫任务, 将在STW结束后开始运行
</span><span class="c1"></span>		<span class="nf">gcSweep</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">mode</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="c1">// 设置G的状态为运行中
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">traceback</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
	<span class="c1">// 跟踪处理
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCDone</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// all done
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>

	<span class="k">if</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gc done but gcphase != _GCoff&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Record next_gc and heap_inuse for scavenger.
</span><span class="c1"></span>	<span class="nx">memstats</span><span class="p">.</span><span class="nx">last_next_gc</span> <span class="p">=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">last_heap_inuse</span> <span class="p">=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_inuse</span>

	<span class="c1">// Update GC trigger and pacing for the next cycle.
</span><span class="c1"></span>	<span class="c1">// 更新下一次触发gc需要的heap大小(gc_trigger)
</span><span class="c1"></span>	<span class="nf">gcSetTriggerRatio</span><span class="p">(</span><span class="nx">nextTriggerRatio</span><span class="p">)</span>
	<span class="c1">// 更新用时记录
</span><span class="c1"></span>	<span class="c1">// Update timing memstats
</span><span class="c1"></span>	<span class="nx">now</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="nx">sec</span><span class="p">,</span> <span class="nx">nsec</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">time_now</span><span class="p">()</span>
	<span class="nx">unixNow</span> <span class="o">:=</span> <span class="nx">sec</span><span class="o">*</span><span class="mf">1e9</span> <span class="o">+</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">nsec</span><span class="p">)</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">pauseNS</span> <span class="o">+=</span> <span class="nx">now</span> <span class="o">-</span> <span class="nx">work</span><span class="p">.</span><span class="nx">pauseStart</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">tEnd</span> <span class="p">=</span> <span class="nx">now</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">last_gc_unix</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">unixNow</span><span class="p">))</span> <span class="c1">// must be Unix time to make sense to user
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">last_gc_nanotime</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">now</span><span class="p">))</span> <span class="c1">// monotonic time for us
</span><span class="c1"></span>	<span class="nx">memstats</span><span class="p">.</span><span class="nx">pause_ns</span><span class="p">[</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">numgc</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">pause_ns</span><span class="p">))]</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">pauseNS</span><span class="p">)</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">pause_end</span><span class="p">[</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">numgc</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">pause_end</span><span class="p">))]</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">unixNow</span><span class="p">)</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">pause_total_ns</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">pauseNS</span><span class="p">)</span>

	<span class="c1">// Update work.totaltime.
</span><span class="c1"></span>	<span class="c1">// 更新所用cpu记录
</span><span class="c1"></span>	<span class="nx">sweepTermCpu</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">stwprocs</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">tMark</span> <span class="o">-</span> <span class="nx">work</span><span class="p">.</span><span class="nx">tSweepTerm</span><span class="p">)</span>
	<span class="c1">// We report idle marking time below, but omit it from the
</span><span class="c1"></span>	<span class="c1">// overall utilization here since it&#39;s &#34;free&#34;.
</span><span class="c1"></span>	<span class="nx">markCpu</span> <span class="o">:=</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">assistTime</span> <span class="o">+</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">dedicatedMarkTime</span> <span class="o">+</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">fractionalMarkTime</span>
	<span class="nx">markTermCpu</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">stwprocs</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">tEnd</span> <span class="o">-</span> <span class="nx">work</span><span class="p">.</span><span class="nx">tMarkTerm</span><span class="p">)</span>
	<span class="nx">cycleCpu</span> <span class="o">:=</span> <span class="nx">sweepTermCpu</span> <span class="o">+</span> <span class="nx">markCpu</span> <span class="o">+</span> <span class="nx">markTermCpu</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">totaltime</span> <span class="o">+=</span> <span class="nx">cycleCpu</span>

	<span class="c1">// Compute overall GC CPU utilization.
</span><span class="c1"></span>	<span class="nx">totalCpu</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">totaltime</span> <span class="o">+</span> <span class="p">(</span><span class="nx">now</span><span class="o">-</span><span class="nx">sched</span><span class="p">.</span><span class="nx">procresizetime</span><span class="p">)</span><span class="o">*</span><span class="nb">int64</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_cpu_fraction</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">totaltime</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">totalCpu</span><span class="p">)</span>

	<span class="c1">// Reset sweep state.
</span><span class="c1"></span>	<span class="c1">// 重置清扫状态
</span><span class="c1"></span>	<span class="nx">sweep</span><span class="p">.</span><span class="nx">nbgsweep</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">sweep</span><span class="p">.</span><span class="nx">npausesweep</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 统计强制开始GC的次数
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">userForced</span> <span class="p">{</span>
		<span class="nx">memstats</span><span class="p">.</span><span class="nx">numforcedgc</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="c1">// 统计执行GC的次数然后唤醒等待清扫的G
</span><span class="c1"></span>	<span class="c1">// Bump GC cycle count and wake goroutines waiting on sweep.
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">sweepWaiters</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">numgc</span><span class="o">++</span>
	<span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">sweepWaiters</span><span class="p">.</span><span class="nx">list</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">sweepWaiters</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// Finish the current heap profiling cycle and start a new
</span><span class="c1"></span>	<span class="c1">// heap profiling cycle. We do this before starting the world
</span><span class="c1"></span>	<span class="c1">// so events don&#39;t leak into the wrong cycle.
</span><span class="c1"></span>	<span class="c1">// 性能统计用
</span><span class="c1"></span>	<span class="nf">mProf_NextCycle</span><span class="p">()</span>
	<span class="c1">// 重新启动世界
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">startTheWorldWithSema</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">})</span>

	<span class="c1">// Flush the heap profile so we can start a new cycle next GC.
</span><span class="c1"></span>	<span class="c1">// This is relatively expensive, so we don&#39;t do it with the
</span><span class="c1"></span>	<span class="c1">// world stopped.
</span><span class="c1"></span>	<span class="c1">// 性能统计用
</span><span class="c1"></span>	<span class="nf">mProf_Flush</span><span class="p">()</span>

	<span class="c1">// Prepare workbufs for freeing by the sweeper. We do this
</span><span class="c1"></span>	<span class="c1">// asynchronously because it can take non-trivial time.
</span><span class="c1"></span>	<span class="c1">// 移动标记队列使用的缓冲区到自由列表, 使得它们可以被回收
</span><span class="c1"></span>	<span class="nf">prepareFreeWorkbufs</span><span class="p">()</span>

	<span class="c1">// Free stack spans. This must be done between GC cycles.
</span><span class="c1"></span>	<span class="c1">// 释放未使用的栈
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="nx">freeStackSpans</span><span class="p">)</span>

	<span class="c1">// Ensure all mcaches are flushed. Each P will flush its own
</span><span class="c1"></span>	<span class="c1">// mcache before allocating, but idle Ps may not. Since this
</span><span class="c1"></span>	<span class="c1">// is necessary to sweep all spans, we need to ensure all
</span><span class="c1"></span>	<span class="c1">// mcaches are flushed before we start the next GC cycle.
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">forEachP</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">_p_</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nf">prepareForSweep</span><span class="p">()</span>
		<span class="p">})</span>
	<span class="p">})</span>

	<span class="c1">// Print gctrace before dropping worldsema. As soon as we drop
</span><span class="c1"></span>	<span class="c1">// worldsema another cycle could start and smash the stats
</span><span class="c1"></span>	<span class="c1">// we&#39;re trying to print.
</span><span class="c1"></span>	<span class="c1">// 除错用
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gctrace</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">util</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_cpu_fraction</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>

		<span class="kd">var</span> <span class="nx">sbuf</span> <span class="p">[</span><span class="mi">24</span><span class="p">]</span><span class="kt">byte</span>
		<span class="nf">printlock</span><span class="p">()</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;gc &#34;</span><span class="p">,</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">numgc</span><span class="p">,</span>
			<span class="s">&#34; @&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nf">itoaDiv</span><span class="p">(</span><span class="nx">sbuf</span><span class="p">[:],</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">tSweepTerm</span><span class="o">-</span><span class="nx">runtimeInitTime</span><span class="p">)</span><span class="o">/</span><span class="mf">1e6</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="s">&#34;s &#34;</span><span class="p">,</span>
			<span class="nx">util</span><span class="p">,</span> <span class="s">&#34;%: &#34;</span><span class="p">)</span>
		<span class="nx">prev</span> <span class="o">:=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">tSweepTerm</span>
		<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">ns</span> <span class="o">:=</span> <span class="k">range</span> <span class="p">[]</span><span class="kt">int64</span><span class="p">{</span><span class="nx">work</span><span class="p">.</span><span class="nx">tMark</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">tMarkTerm</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">tEnd</span><span class="p">}</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nb">print</span><span class="p">(</span><span class="s">&#34;+&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nb">print</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nf">fmtNSAsMS</span><span class="p">(</span><span class="nx">sbuf</span><span class="p">[:],</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">ns</span><span class="o">-</span><span class="nx">prev</span><span class="p">))))</span>
			<span class="nx">prev</span> <span class="p">=</span> <span class="nx">ns</span>
		<span class="p">}</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34; ms clock, &#34;</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">ns</span> <span class="o">:=</span> <span class="k">range</span> <span class="p">[]</span><span class="kt">int64</span><span class="p">{</span><span class="nx">sweepTermCpu</span><span class="p">,</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">assistTime</span><span class="p">,</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">dedicatedMarkTime</span> <span class="o">+</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">fractionalMarkTime</span><span class="p">,</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">idleMarkTime</span><span class="p">,</span> <span class="nx">markTermCpu</span><span class="p">}</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">{</span>
				<span class="c1">// Separate mark time components with /.
</span><span class="c1"></span>				<span class="nb">print</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nb">print</span><span class="p">(</span><span class="s">&#34;+&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nb">print</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nf">fmtNSAsMS</span><span class="p">(</span><span class="nx">sbuf</span><span class="p">[:],</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">ns</span><span class="p">))))</span>
		<span class="p">}</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34; ms cpu, &#34;</span><span class="p">,</span>
			<span class="nx">work</span><span class="p">.</span><span class="nx">heap0</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34;-&gt;&#34;</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">heap1</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34;-&gt;&#34;</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">heap2</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34; MB, &#34;</span><span class="p">,</span>
			<span class="nx">work</span><span class="p">.</span><span class="nx">heapGoal</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34; MB goal, &#34;</span><span class="p">,</span>
			<span class="nx">work</span><span class="p">.</span><span class="nx">maxprocs</span><span class="p">,</span> <span class="s">&#34; P&#34;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">userForced</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34; (forced)&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">printunlock</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">worldsema</span><span class="p">)</span>
	<span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcsema</span><span class="p">)</span>
	<span class="c1">// Careful: another GC cycle may start now.
</span><span class="c1"></span>	<span class="c1">// 重新允许当前的G被抢占
</span><span class="c1"></span>	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="nx">mp</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="c1">// now that gc is done, kick off finalizer thread if needed
</span><span class="c1"></span>	<span class="c1">// 如果是并行GC, 让当前M继续运行(会回到gcBgMarkWorker然后休眠)
</span><span class="c1"></span>	<span class="c1">// 如果不是并行GC, 则让当前M开始调度
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">concurrentSweep</span> <span class="p">{</span>
		<span class="c1">// give the queued finalizers, if any, a chance to run
</span><span class="c1"></span>		<span class="nf">Gosched</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h4 id="gcmark">gcMark</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// gcMark runs the mark (or, for concurrent GC, mark termination)
</span><span class="c1">// All gcWork caches must be empty.
</span><span class="c1">// STW is in effect at this point.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gcMark</span><span class="p">(</span><span class="nx">start_time</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">allocfreetrace</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">tracegc</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCmarktermination</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;in gcMark expecting to see gcphase as _GCmarktermination&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">tstart</span> <span class="p">=</span> <span class="nx">start_time</span>

	<span class="c1">// Check that there&#39;s no marking work remaining.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">full</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">work</span><span class="p">.</span><span class="nx">markrootNext</span> <span class="p">&lt;</span> <span class="nx">work</span><span class="p">.</span><span class="nx">markrootJobs</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: full=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">full</span><span class="p">),</span> <span class="s">&#34; next=&#34;</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">markrootNext</span><span class="p">,</span> <span class="s">&#34; jobs=&#34;</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">markrootJobs</span><span class="p">,</span> <span class="s">&#34; nDataRoots=&#34;</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nDataRoots</span><span class="p">,</span> <span class="s">&#34; nBSSRoots=&#34;</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nBSSRoots</span><span class="p">,</span> <span class="s">&#34; nSpanRoots=&#34;</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nSpanRoots</span><span class="p">,</span> <span class="s">&#34; nStackRoots=&#34;</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nStackRoots</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;non-empty mark queue after concurrent mark&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gccheckmark</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// This is expensive when there&#39;s a large number of
</span><span class="c1"></span>		<span class="c1">// Gs, so only do it if checkmark is also enabled.
</span><span class="c1"></span>		<span class="nf">gcMarkRootCheck</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">full</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;work.full != 0&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Clear out buffers and double-check that all gcWork caches
</span><span class="c1"></span>	<span class="c1">// are empty. This should be ensured by gcMarkDone before we
</span><span class="c1"></span>	<span class="c1">// enter mark termination.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// TODO: We could clear out buffers just before mark if this
</span><span class="c1"></span>	<span class="c1">// has a non-negligible impact on STW time.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
		<span class="c1">// The write barrier may have buffered pointers since
</span><span class="c1"></span>		<span class="c1">// the gcMarkDone barrier. However, since the barrier
</span><span class="c1"></span>		<span class="c1">// ensured all reachable objects were marked, all of
</span><span class="c1"></span>		<span class="c1">// these must be pointers to black objects. Hence we
</span><span class="c1"></span>		<span class="c1">// can just discard the write barrier buffer.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gccheckmark</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// For debugging, flush the buffer and make
</span><span class="c1"></span>			<span class="c1">// sure it really was all marked.
</span><span class="c1"></span>			<span class="nf">wbBufFlush1</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">wbBuf</span><span class="p">.</span><span class="nf">reset</span><span class="p">()</span>
		<span class="p">}</span>

		<span class="nx">gcw</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">gcw</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">printlock</span><span class="p">()</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: P &#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="s">&#34; flushedWork &#34;</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">flushedWork</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">wbuf1</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nb">print</span><span class="p">(</span><span class="s">&#34; wbuf1=&lt;nil&gt;&#34;</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nb">print</span><span class="p">(</span><span class="s">&#34; wbuf1.n=&#34;</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">wbuf1</span><span class="p">.</span><span class="nx">nobj</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">wbuf2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nb">print</span><span class="p">(</span><span class="s">&#34; wbuf2=&lt;nil&gt;&#34;</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nb">print</span><span class="p">(</span><span class="s">&#34; wbuf2.n=&#34;</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">wbuf2</span><span class="p">.</span><span class="nx">nobj</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;\n&#34;</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;P has cached GC work at end of mark termination&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// There may still be cached empty buffers, which we
</span><span class="c1"></span>		<span class="c1">// need to flush since we&#39;re going to free them. Also,
</span><span class="c1"></span>		<span class="c1">// there may be non-zero stats because we allocated
</span><span class="c1"></span>		<span class="c1">// black after the gcMarkDone barrier.
</span><span class="c1"></span>		<span class="nx">gcw</span><span class="p">.</span><span class="nf">dispose</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// Update the marked heap stat.
</span><span class="c1"></span>	<span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_marked</span> <span class="p">=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">bytesMarked</span>

	<span class="c1">// Flush scanAlloc from each mcache since we&#39;re about to modify
</span><span class="c1"></span>	<span class="c1">// heap_scan directly. If we were to flush this later, then scanAlloc
</span><span class="c1"></span>	<span class="c1">// might have incorrect information.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
		<span class="nx">c</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">mcache</span>
		<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_scan</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">scanAlloc</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">scanAlloc</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="c1">// Update other GC heap size stats. This must happen after
</span><span class="c1"></span>	<span class="c1">// cachestats (which flushes local statistics to these) and
</span><span class="c1"></span>	<span class="c1">// flushallmcaches (which modifies heap_live).
</span><span class="c1"></span>	<span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span> <span class="p">=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">bytesMarked</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_scan</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">scanWork</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceHeapAlloc</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="gcsettriggerratio">gcSetTriggerRatio</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// gcSetTriggerRatio sets the trigger ratio and updates everything
</span><span class="c1">// derived from it: the absolute trigger, the heap goal, mark pacing,
</span><span class="c1">// and sweep pacing.
</span><span class="c1">//
</span><span class="c1">// This can be called any time. If GC is the in the middle of a
</span><span class="c1">// concurrent phase, it will adjust the pacing of that phase.
</span><span class="c1">//
</span><span class="c1">// This depends on gcpercent, memstats.heap_marked, and
</span><span class="c1">// memstats.heap_live. These must be up to date.
</span><span class="c1">//
</span><span class="c1">// mheap_.lock must be held or the world must be stopped.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gcSetTriggerRatio</span><span class="p">(</span><span class="nx">triggerRatio</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Compute the next GC goal, which is when the allocated heap
</span><span class="c1"></span>	<span class="c1">// has grown by GOGC/100 over the heap marked by the last
</span><span class="c1"></span>	<span class="c1">// cycle.
</span><span class="c1"></span>	<span class="nx">goal</span> <span class="o">:=</span> <span class="p">^</span><span class="nb">uint64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">gcpercent</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">goal</span> <span class="p">=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_marked</span> <span class="o">+</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_marked</span><span class="o">*</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">gcpercent</span><span class="p">)</span><span class="o">/</span><span class="mi">100</span>
	<span class="p">}</span>

	<span class="c1">// Set the trigger ratio, capped to reasonable bounds.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gcpercent</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">scalingFactor</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">gcpercent</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span>
		<span class="c1">// Ensure there&#39;s always a little margin so that the
</span><span class="c1"></span>		<span class="c1">// mutator assist ratio isn&#39;t infinity.
</span><span class="c1"></span>		<span class="nx">maxTriggerRatio</span> <span class="o">:=</span> <span class="mf">0.95</span> <span class="o">*</span> <span class="nx">scalingFactor</span>
		<span class="k">if</span> <span class="nx">triggerRatio</span> <span class="p">&gt;</span> <span class="nx">maxTriggerRatio</span> <span class="p">{</span>
			<span class="nx">triggerRatio</span> <span class="p">=</span> <span class="nx">maxTriggerRatio</span>
		<span class="p">}</span>

		<span class="c1">// If we let triggerRatio go too low, then if the application
</span><span class="c1"></span>		<span class="c1">// is allocating very rapidly we might end up in a situation
</span><span class="c1"></span>		<span class="c1">// where we&#39;re allocating black during a nearly always-on GC.
</span><span class="c1"></span>		<span class="c1">// The result of this is a growing heap and ultimately an
</span><span class="c1"></span>		<span class="c1">// increase in RSS. By capping us at a point &gt;0, we&#39;re essentially
</span><span class="c1"></span>		<span class="c1">// saying that we&#39;re OK using more CPU during the GC to prevent
</span><span class="c1"></span>		<span class="c1">// this growth in RSS.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// The current constant was chosen empirically: given a sufficiently
</span><span class="c1"></span>		<span class="c1">// fast/scalable allocator with 48 Ps that could drive the trigger ratio
</span><span class="c1"></span>		<span class="c1">// to &lt;0.05, this constant causes applications to retain the same peak
</span><span class="c1"></span>		<span class="c1">// RSS compared to not having this allocator.
</span><span class="c1"></span>		<span class="nx">minTriggerRatio</span> <span class="o">:=</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="nx">scalingFactor</span>
		<span class="k">if</span> <span class="nx">triggerRatio</span> <span class="p">&lt;</span> <span class="nx">minTriggerRatio</span> <span class="p">{</span>
			<span class="nx">triggerRatio</span> <span class="p">=</span> <span class="nx">minTriggerRatio</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">triggerRatio</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// gcpercent &lt; 0, so just make sure we&#39;re not getting a negative
</span><span class="c1"></span>		<span class="c1">// triggerRatio. This case isn&#39;t expected to happen in practice,
</span><span class="c1"></span>		<span class="c1">// and doesn&#39;t really matter because if gcpercent &lt; 0 then we won&#39;t
</span><span class="c1"></span>		<span class="c1">// ever consume triggerRatio further on in this function, but let&#39;s
</span><span class="c1"></span>		<span class="c1">// just be defensive here; the triggerRatio being negative is almost
</span><span class="c1"></span>		<span class="c1">// certainly undesirable.
</span><span class="c1"></span>		<span class="nx">triggerRatio</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">triggerRatio</span> <span class="p">=</span> <span class="nx">triggerRatio</span>

	<span class="c1">// Compute the absolute GC trigger from the trigger ratio.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// We trigger the next GC cycle when the allocated heap has
</span><span class="c1"></span>	<span class="c1">// grown by the trigger ratio over the marked heap size.
</span><span class="c1"></span>	<span class="nx">trigger</span> <span class="o">:=</span> <span class="p">^</span><span class="nb">uint64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">gcpercent</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">trigger</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_marked</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nx">triggerRatio</span><span class="p">))</span>
		<span class="c1">// Don&#39;t trigger below the minimum heap size.
</span><span class="c1"></span>		<span class="nx">minTrigger</span> <span class="o">:=</span> <span class="nx">heapminimum</span>
		<span class="k">if</span> <span class="p">!</span><span class="nf">isSweepDone</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// Concurrent sweep happens in the heap growth
</span><span class="c1"></span>			<span class="c1">// from heap_live to gc_trigger, so ensure
</span><span class="c1"></span>			<span class="c1">// that concurrent sweep has some heap growth
</span><span class="c1"></span>			<span class="c1">// in which to perform sweeping before we
</span><span class="c1"></span>			<span class="c1">// start the next GC cycle.
</span><span class="c1"></span>			<span class="nx">sweepMin</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">)</span> <span class="o">+</span> <span class="nx">sweepMinHeapDistance</span>
			<span class="k">if</span> <span class="nx">sweepMin</span> <span class="p">&gt;</span> <span class="nx">minTrigger</span> <span class="p">{</span>
				<span class="nx">minTrigger</span> <span class="p">=</span> <span class="nx">sweepMin</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">trigger</span> <span class="p">&lt;</span> <span class="nx">minTrigger</span> <span class="p">{</span>
			<span class="nx">trigger</span> <span class="p">=</span> <span class="nx">minTrigger</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">trigger</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: next_gc=&#34;</span><span class="p">,</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span><span class="p">,</span> <span class="s">&#34; heap_marked=&#34;</span><span class="p">,</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_marked</span><span class="p">,</span> <span class="s">&#34; heap_live=&#34;</span><span class="p">,</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">,</span> <span class="s">&#34; initialHeapLive=&#34;</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">initialHeapLive</span><span class="p">,</span> <span class="s">&#34;triggerRatio=&#34;</span><span class="p">,</span> <span class="nx">triggerRatio</span><span class="p">,</span> <span class="s">&#34; minTrigger=&#34;</span><span class="p">,</span> <span class="nx">minTrigger</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gc_trigger underflow&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">trigger</span> <span class="p">&gt;</span> <span class="nx">goal</span> <span class="p">{</span>
			<span class="c1">// The trigger ratio is always less than GOGC/100, but
</span><span class="c1"></span>			<span class="c1">// other bounds on the trigger may have raised it.
</span><span class="c1"></span>			<span class="c1">// Push up the goal, too.
</span><span class="c1"></span>			<span class="nx">goal</span> <span class="p">=</span> <span class="nx">trigger</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Commit to the trigger and goal.
</span><span class="c1"></span>	<span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_trigger</span> <span class="p">=</span> <span class="nx">trigger</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span> <span class="p">=</span> <span class="nx">goal</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceNextGC</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// Update mark pacing.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="p">{</span>
		<span class="nx">gcController</span><span class="p">.</span><span class="nf">revise</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// Update sweep pacing.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">isSweepDone</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepPagesPerByte</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// Concurrent sweep needs to sweep all of the in-use
</span><span class="c1"></span>		<span class="c1">// pages by the time the allocated heap reaches the GC
</span><span class="c1"></span>		<span class="c1">// trigger. Compute the ratio of in-use pages to sweep
</span><span class="c1"></span>		<span class="c1">// per byte allocated, accounting for the fact that
</span><span class="c1"></span>		<span class="c1">// some might already be swept.
</span><span class="c1"></span>		<span class="c1">// 当前的Heap大小
</span><span class="c1"></span>		<span class="nx">heapLiveBasis</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">)</span>
		<span class="c1">// 距离触发GC的Heap大小 = 下次触发GC的Heap大小 - 当前的Heap大小
</span><span class="c1"></span>		<span class="nx">heapDistance</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">trigger</span><span class="p">)</span> <span class="o">-</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">heapLiveBasis</span><span class="p">)</span>
		<span class="c1">// Add a little margin so rounding errors and
</span><span class="c1"></span>		<span class="c1">// concurrent sweep are less likely to leave pages
</span><span class="c1"></span>		<span class="c1">// unswept when GC starts.
</span><span class="c1"></span>		<span class="nx">heapDistance</span> <span class="o">-=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>
		<span class="k">if</span> <span class="nx">heapDistance</span> <span class="p">&lt;</span> <span class="nx">_PageSize</span> <span class="p">{</span>
			<span class="c1">// Avoid setting the sweep ratio extremely high
</span><span class="c1"></span>			<span class="nx">heapDistance</span> <span class="p">=</span> <span class="nx">_PageSize</span>
		<span class="p">}</span>

		<span class="c1">// 已清扫的页数
</span><span class="c1"></span>		<span class="nx">pagesSwept</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">pagesSwept</span><span class="p">)</span>
		<span class="nx">pagesInUse</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">pagesInUse</span><span class="p">)</span>
		<span class="c1">// 未清扫的页数 = 使用中的页数 - 已清扫的页数
</span><span class="c1"></span>		<span class="nx">sweepDistancePages</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">pagesInUse</span><span class="p">)</span> <span class="o">-</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">pagesSwept</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">sweepDistancePages</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepPagesPerByte</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 每分配1 byte(的span)需要辅助清扫的页数 = 未清扫的页数 / 距离触发GC的Heap大小
</span><span class="c1"></span>			<span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepPagesPerByte</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">sweepDistancePages</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">heapDistance</span><span class="p">)</span>
			<span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepHeapLiveBasis</span> <span class="p">=</span> <span class="nx">heapLiveBasis</span>
			<span class="c1">// Write pagesSweptBasis last, since this
</span><span class="c1"></span>			<span class="c1">// signals concurrent sweeps to recompute
</span><span class="c1"></span>			<span class="c1">// their debt.
</span><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">pagesSweptBasis</span><span class="p">,</span> <span class="nx">pagesSwept</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nf">gcPaceScavenger</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="内存清理">内存清理</h3>
<h4 id="gcsweep">gcSweep</h4>
<p>gcSweep实现非常简单，只需要将 mheap_ 相关的标志位清零，并唤醒后台清扫器 Goroutine 即可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// gcSweep must be called on the system stack because it acquires the heap
</span><span class="c1">// lock. See mheap for details.
</span><span class="c1">//
</span><span class="c1">// The world must be stopped.
</span><span class="c1">//
</span><span class="c1">//go:systemstack
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gcSweep</span><span class="p">(</span><span class="nx">mode</span> <span class="nx">gcMode</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 此时为 GCoff 阶段
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gcSweep being done but phase is not GCoff&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 增加sweepgen, 这样sweepSpans中两个队列角色会交换, 所有span都会变为&#34;待清扫&#34;的span
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">+=</span> <span class="mi">2</span>
	<span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepdone</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">go115NewMCentralImpl</span> <span class="o">&amp;&amp;</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="o">/</span><span class="mi">2</span><span class="o">%</span><span class="mi">2</span><span class="p">].</span><span class="nx">index</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// We should have drained this list during the last
</span><span class="c1"></span>		<span class="c1">// sweep phase. We certainly need to start this phase
</span><span class="c1"></span>		<span class="c1">// with an empty swept list.
</span><span class="c1"></span>		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;non-empty swept list&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">mheap_</span><span class="p">.</span><span class="nx">pagesSwept</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepArenas</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">allArenas</span>
	<span class="nx">mheap_</span><span class="p">.</span><span class="nx">reclaimIndex</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">mheap_</span><span class="p">.</span><span class="nx">reclaimCredit</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">go115NewMCentralImpl</span> <span class="p">{</span>
		<span class="nx">sweep</span><span class="p">.</span><span class="nx">centralIndex</span><span class="p">.</span><span class="nf">clear</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 如果非并行GC则在这里完成所有工作(STW中)
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">_ConcurrentSweep</span> <span class="o">||</span> <span class="nx">mode</span> <span class="o">==</span> <span class="nx">gcForceBlockMode</span> <span class="p">{</span>
		<span class="c1">// Special case synchronous sweep.
</span><span class="c1"></span>		<span class="c1">// Record that no proportional sweeping has to happen.
</span><span class="c1"></span>		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepPagesPerByte</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="c1">// Sweep all spans eagerly.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nf">sweepone</span><span class="p">()</span> <span class="o">!=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">sweep</span><span class="p">.</span><span class="nx">npausesweep</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="c1">// Free workbufs eagerly.
</span><span class="c1"></span>		<span class="c1">// freeSomeWbufs 释放一些 workbufs 回到堆中，如果需要再次调用则返回 true
</span><span class="c1"></span>		<span class="nf">prepareFreeWorkbufs</span><span class="p">()</span>
		<span class="k">for</span> <span class="nf">freeSomeWbufs</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">}</span>
		<span class="c1">// All &#34;free&#34; events for this mark/sweep cycle have
</span><span class="c1"></span>		<span class="c1">// now happened, so we can make this profile cycle
</span><span class="c1"></span>		<span class="c1">// available immediately.
</span><span class="c1"></span>		<span class="nf">mProf_NextCycle</span><span class="p">()</span>
		<span class="nf">mProf_Flush</span><span class="p">()</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 并发清扫（唤醒后台 Goroutine）
</span><span class="c1"></span>	<span class="c1">// Background sweep.
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">sweep</span><span class="p">.</span><span class="nx">parked</span> <span class="p">{</span>
		<span class="nx">sweep</span><span class="p">.</span><span class="nx">parked</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="nf">ready</span><span class="p">(</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">g</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h4 id="bgsweep">bgsweep</h4>
<p>后台清扫任务会在程序启动时调用的gcenable函数中启动.</p>
<p>清扫过程依赖下面的结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">sweep</span> <span class="nx">sweepdata</span>

<span class="kd">type</span> <span class="nx">sweepdata</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span>    <span class="nx">mutex</span>
	<span class="nx">g</span>       <span class="o">*</span><span class="nx">g</span>
	<span class="nx">parked</span>  <span class="kt">bool</span>
	<span class="nx">started</span> <span class="kt">bool</span>

	<span class="nx">nbgsweep</span>    <span class="kt">uint32</span>
	<span class="nx">npausesweep</span> <span class="kt">uint32</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该结构通过：</p>
<ul>
<li>mutex 保证清扫过程的原子性</li>
<li>g 指针来保存所在的 Goroutine</li>
<li>started 判断是否开始</li>
<li>nbgsweep 和 npausesweep 来统计清扫过程</li>
</ul>
<p>当一个后台 sweeper 从应用程序启动时休眠后，再重新唤醒时，会进入如下循环，并一直在次循环中反复休眠与被唤醒：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// The main goroutine.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nf">gcenable</span><span class="p">()</span>
	<span class="o">...</span>
<span class="p">}</span>
<span class="c1">// gcenable is called after the bulk of the runtime initialization,
</span><span class="c1">// just before we&#39;re about to start letting user code run.
</span><span class="c1">// It kicks off the background sweeper goroutine, the background
</span><span class="c1">// scavenger goroutine, and enables GC.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gcenable</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Kick off sweeping and scavenging.
</span><span class="c1"></span>	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">bgsweep</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">bgscavenge</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="o">&lt;-</span><span class="nx">c</span>
	<span class="o">&lt;-</span><span class="nx">c</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">enablegc</span> <span class="p">=</span> <span class="kc">true</span> <span class="c1">// now that runtime is initialized, GC is okay
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">bgsweep</span><span class="p">(</span><span class="nx">c</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sweep</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankSweep</span><span class="p">)</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">sweep</span><span class="p">.</span><span class="nx">parked</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">1</span>
	<span class="nf">goparkunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">waitReasonGCSweepWait</span><span class="p">,</span> <span class="nx">traceEvGoBlock</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 循环清扫
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// 清扫 span，如果清扫了一部分 span，则记录 bgsweep 的次数
</span><span class="c1"></span>		<span class="c1">// 清扫一个span, 然后进入调度(一次只做少量工作)
</span><span class="c1"></span>		<span class="k">for</span> <span class="nf">sweepone</span><span class="p">()</span> <span class="o">!=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">sweep</span><span class="p">.</span><span class="nx">nbgsweep</span><span class="o">++</span>
			<span class="nf">Gosched</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="c1">// 可抢占的释放一些 workbufs 到堆中
</span><span class="c1"></span>		<span class="c1">// 释放一些未使用的标记队列缓冲区到heap
</span><span class="c1"></span>		<span class="k">for</span> <span class="nf">freeSomeWbufs</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">Gosched</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="c1">// 在 mheap_ 上判断是否完成清扫，若未完成，则继续进行清扫
</span><span class="c1"></span>		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nf">isSweepDone</span><span class="p">()</span> <span class="p">{</span><span class="c1">// 即 mheap_.sweepdone != 0
</span><span class="c1"></span>			<span class="c1">// This can happen if a GC runs between
</span><span class="c1"></span>			<span class="c1">// gosweepone returning ^0 above
</span><span class="c1"></span>			<span class="c1">// and the lock being acquired.
</span><span class="c1"></span>			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// 否则让 Goroutine 进行 park
</span><span class="c1"></span>		<span class="c1">// 否则让后台清扫任务进入休眠, 当前M继续调度
</span><span class="c1"></span>		<span class="nx">sweep</span><span class="p">.</span><span class="nx">parked</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nf">goparkunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">waitReasonGCSweepWait</span><span class="p">,</span> <span class="nx">traceEvGoBlock</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>垃圾收集的清理中包含对象回收器（Reclaimer）和内存单元回收器，这两种回收器使用不同的算法清理堆内存：</p>
<ul>
<li>对象回收器在内存管理单元中查找并释放未被标记的对象，但是如果 runtime.mspan 中的所有对象都没有被标记，整个单元就会被直接回收，该过程会被 runtime.mcentral.cacheSpan 或者 runtime.sweepone 异步触发；</li>
<li>内存单元回收器会在内存中查找所有的对象都未被标记的 runtime.mspan，该过程会被 runtime.mheap.reclaim 触发；</li>
</ul>
<h4 id="sweepone">sweepone</h4>
<p>runtime.sweepone 是我们在垃圾收集过程中经常会见到的函数，该函数会在堆内存中查找待清理的内存管理单元：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// sweepone sweeps some unswept heap span and returns the number of pages returned
</span><span class="c1">// to the heap, or ^uintptr(0) if there was nothing to sweep.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sweepone</span><span class="p">()</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">sweepRatio</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepPagesPerByte</span> <span class="c1">// For debugging
</span><span class="c1"></span>
	<span class="c1">// increment locks to ensure that the goroutine is not preempted
</span><span class="c1"></span>	<span class="c1">// in the middle of sweep thus leaving the span in an inconsistent state for next GC
</span><span class="c1"></span>	<span class="c1">// 增加锁的数量确保 Goroutine 在 sweep 中不会被抢占，进而不会将 span 留到下个 GC 产生不一致
</span><span class="c1"></span>	<span class="c1">// 禁止G被抢占
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span>
	<span class="c1">// 检查是否已完成清扫
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepdone</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
		<span class="k">return</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 记录 sweeper 的数量
</span><span class="c1"></span>	<span class="c1">// 更新同时执行sweep的任务数量
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepers</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>

	<span class="c1">// Find a span to sweep.
</span><span class="c1"></span>	<span class="c1">// 寻找需要 sweep 的 span
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
	<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// 从sweepSpans中取出一个span
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">go115NewMCentralImpl</span> <span class="p">{</span>
			<span class="nx">s</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nf">nextSpanForSweep</span><span class="p">()</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">s</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="nx">sg</span><span class="o">/</span><span class="mi">2</span><span class="o">%</span><span class="mi">2</span><span class="p">].</span><span class="nf">pop</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="c1">// 全部清扫完毕时跳出循环
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepdone</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="c1">// 其他M已经在清扫这个span时跳过
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">state</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nf">get</span><span class="p">();</span> <span class="nx">state</span> <span class="o">!=</span> <span class="nx">mSpanInUse</span> <span class="p">{</span>
			<span class="c1">// This can happen if direct sweeping already
</span><span class="c1"></span>			<span class="c1">// swept this span, but in that case the sweep
</span><span class="c1"></span>			<span class="c1">// generation should always be up-to-date.
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!(</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span> <span class="o">||</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
				<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: bad span s.state=&#34;</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="s">&#34; s.sweepgen=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="s">&#34; sweepgen=&#34;</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;non in-use span in unswept list&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// 原子增加span的sweepgen, 失败表示其他M已经开始清扫这个span, 跳过
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Sweep the span we found.
</span><span class="c1"></span>	<span class="c1">// sweep 找到的 span
</span><span class="c1"></span>	<span class="nx">npages</span> <span class="o">:=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 清扫这个span, 然后跳出循环
</span><span class="c1"></span>		<span class="nx">npages</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">sweep</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// false 表示将其归还到 heap 中
</span><span class="c1"></span>			<span class="c1">// Whole span was freed. Count it toward the
</span><span class="c1"></span>			<span class="c1">// page reclaimer credit since these pages can
</span><span class="c1"></span>			<span class="c1">// now be used for span allocation.
</span><span class="c1"></span>			<span class="c1">// 整个 span 都已被释放，记录释放的额度，因为整个页都能用作 span 分配了
</span><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadduintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">reclaimCredit</span><span class="p">,</span> <span class="nx">npages</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// Span is still in-use, so this returned no
</span><span class="c1"></span>			<span class="c1">// pages to the heap and the span needs to
</span><span class="c1"></span>			<span class="c1">// move to the swept in-use list.
</span><span class="c1"></span>			<span class="c1">// span 还在被使用，因此返回零
</span><span class="c1"></span>			<span class="c1">// 并需要 span 移动到已经 sweep 的 in-use 列表中。
</span><span class="c1"></span>			<span class="nx">npages</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Decrement the number of active sweepers and if this is the
</span><span class="c1"></span>	<span class="c1">// last one print trace information.
</span><span class="c1"></span>	<span class="c1">// 减少 sweeper 的数量并确保最后一个运行的 sweeper 正常标记了 mheap.sweepdone
</span><span class="c1"></span>	<span class="c1">// 更新同时执行sweep的任务数量
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepers</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepdone</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Since the sweeper is done, move the scavenge gen forward (signalling
</span><span class="c1"></span>		<span class="c1">// that there&#39;s new work to do) and wake the scavenger.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// The scavenger is signaled by the last sweeper because once
</span><span class="c1"></span>		<span class="c1">// sweeping is done, we will definitely have useful work for
</span><span class="c1"></span>		<span class="c1">// the scavenger to do, since the scavenger only runs over the
</span><span class="c1"></span>		<span class="c1">// heap once per GC cyle. This update is not done during sweep
</span><span class="c1"></span>		<span class="c1">// termination because in some cases there may be a long delay
</span><span class="c1"></span>		<span class="c1">// between sweep done and sweep termination (e.g. not enough
</span><span class="c1"></span>		<span class="c1">// allocations to trigger a GC) which would be nice to fill in
</span><span class="c1"></span>		<span class="c1">// with scavenging work.
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="nx">mheap_</span><span class="p">.</span><span class="nx">pages</span><span class="p">.</span><span class="nf">scavengeStartGen</span><span class="p">()</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="p">})</span>
		<span class="c1">// Since we might sweep in an allocation path, it&#39;s not possible
</span><span class="c1"></span>		<span class="c1">// for us to wake the scavenger directly via wakeScavenger, since
</span><span class="c1"></span>		<span class="c1">// it could allocate. Ask sysmon to do it for us instead.
</span><span class="c1"></span>		<span class="nf">readyForScavenger</span><span class="p">()</span>

		<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gcpacertrace</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;pacer: sweep done at heap size &#34;</span><span class="p">,</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34;MB; allocated &#34;</span><span class="p">,</span> <span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="o">-</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepHeapLiveBasis</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34;MB during sweep; swept &#34;</span><span class="p">,</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">pagesSwept</span><span class="p">,</span> <span class="s">&#34; pages at &#34;</span><span class="p">,</span> <span class="nx">sweepRatio</span><span class="p">,</span> <span class="s">&#34; pages/byte\n&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 允许G被抢占
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
	<span class="c1">// 返回清扫的页数
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">npages</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>查找内存管理单元时会通过 state 和 sweepgen 两个字段判断当前单元是否需要处理。如果内存单元的 sweepgen 等于 mheap.sweepgen - 2，那么就意味着当前单元需要被清理，如果等于 mheap.sweepgen - 1，那么当前管理单元就正在被清理。</p>
<h4 id="sweep">sweep</h4>
<p>所有的回收工作最终都是靠 runtime.mspan.sweep 完成的，该函数会根据并发标记阶段回收内存单元中的垃圾并清除标记以免影响下一轮垃圾收集。</p>
<p>span的sweep函数用于清扫单个span:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Sweep frees or collects finalizers for blocks not marked in the mark phase.
</span><span class="c1">// It clears the mark bits in preparation for the next GC round.
</span><span class="c1">// Returns true if the span was returned to heap.
</span><span class="c1">// If preserve=true, don&#39;t return it to heap nor relink in mcentral lists;
</span><span class="c1">// caller takes care of it.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">)</span> <span class="nf">sweep</span><span class="p">(</span><span class="nx">preserve</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">go115NewMCentralImpl</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nf">oldSweep</span><span class="p">(</span><span class="nx">preserve</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// It&#39;s critical that we enter this function with preemption disabled,
</span><span class="c1"></span>	<span class="c1">// GC must not start while we are in the middle of this function.
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mallocing</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;mspan.sweep: m is not locked&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">sweepgen</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span>
	<span class="k">if</span> <span class="nx">state</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nf">get</span><span class="p">();</span> <span class="nx">state</span> <span class="o">!=</span> <span class="nx">mSpanInUse</span> <span class="o">||</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">!=</span> <span class="nx">sweepgen</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;mspan.sweep: state=&#34;</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="s">&#34; sweepgen=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="s">&#34; mheap.sweepgen=&#34;</span><span class="p">,</span> <span class="nx">sweepgen</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;mspan.sweep: bad span state&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCSweepSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="o">*</span> <span class="nx">_PageSize</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 统计已清理的页数
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">pagesSwept</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="p">))</span>

	<span class="nx">spc</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">spanclass</span>
	<span class="nx">size</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>

	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">mcache</span>

	<span class="c1">// The allocBits indicate which unmarked objects don&#39;t need to be
</span><span class="c1"></span>	<span class="c1">// processed since they were free at the end of the last GC cycle
</span><span class="c1"></span>	<span class="c1">// and were not allocated since then.
</span><span class="c1"></span>	<span class="c1">// If the allocBits index is &gt;= s.freeindex and the bit
</span><span class="c1"></span>	<span class="c1">// is not marked then the object remains unallocated
</span><span class="c1"></span>	<span class="c1">// since the last GC.
</span><span class="c1"></span>	<span class="c1">// This situation is analogous to being on a freelist.
</span><span class="c1"></span>	<span class="c1">// 判断在special中的析构器, 如果对应的对象已经不再存活则标记对象存活防止回收, 然后把析构器移到运行队列
</span><span class="c1"></span>	<span class="c1">// Unlink &amp; free special records for any objects we&#39;re about to free.
</span><span class="c1"></span>	<span class="c1">// Two complications here:
</span><span class="c1"></span>	<span class="c1">// 1. An object can have both finalizer and profile special records.
</span><span class="c1"></span>	<span class="c1">//    In such case we need to queue finalizer for execution,
</span><span class="c1"></span>	<span class="c1">//    mark the object as live and preserve the profile special.
</span><span class="c1"></span>	<span class="c1">// 2. A tiny object can have several finalizers setup for different offsets.
</span><span class="c1"></span>	<span class="c1">//    If such object is not marked, we need to queue all finalizers at once.
</span><span class="c1"></span>	<span class="c1">// Both 1 and 2 are possible at the same time.
</span><span class="c1"></span>	<span class="nx">hadSpecials</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">specials</span> <span class="o">!=</span> <span class="kc">nil</span>
	<span class="nx">specialp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">specials</span>
	<span class="nx">special</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">specialp</span>
	<span class="k">for</span> <span class="nx">special</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// A finalizer can be set for an inner byte of an object, find object beginning.
</span><span class="c1"></span>		<span class="nx">objIndex</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">special</span><span class="p">.</span><span class="nx">offset</span><span class="p">)</span> <span class="o">/</span> <span class="nx">size</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">objIndex</span><span class="o">*</span><span class="nx">size</span>
		<span class="nx">mbits</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">markBitsForIndex</span><span class="p">(</span><span class="nx">objIndex</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">mbits</span><span class="p">.</span><span class="nf">isMarked</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// This object is not marked and has at least one special record.
</span><span class="c1"></span>			<span class="c1">// Pass 1: see if it has at least one finalizer.
</span><span class="c1"></span>			<span class="nx">hasFin</span> <span class="o">:=</span> <span class="kc">false</span>
			<span class="nx">endOffset</span> <span class="o">:=</span> <span class="nx">p</span> <span class="o">-</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">size</span>
			<span class="k">for</span> <span class="nx">tmp</span> <span class="o">:=</span> <span class="nx">special</span><span class="p">;</span> <span class="nx">tmp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">tmp</span><span class="p">.</span><span class="nx">offset</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">endOffset</span><span class="p">;</span> <span class="nx">tmp</span> <span class="p">=</span> <span class="nx">tmp</span><span class="p">.</span><span class="nx">next</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">tmp</span><span class="p">.</span><span class="nx">kind</span> <span class="o">==</span> <span class="nx">_KindSpecialFinalizer</span> <span class="p">{</span>
					<span class="c1">// Stop freeing of object if it has a finalizer.
</span><span class="c1"></span>					<span class="nx">mbits</span><span class="p">.</span><span class="nf">setMarkedNonAtomic</span><span class="p">()</span>
					<span class="nx">hasFin</span> <span class="p">=</span> <span class="kc">true</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="c1">// Pass 2: queue all finalizers _or_ handle profile record.
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">special</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">special</span><span class="p">.</span><span class="nx">offset</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">endOffset</span> <span class="p">{</span>
				<span class="c1">// Find the exact byte for which the special was setup
</span><span class="c1"></span>				<span class="c1">// (as opposed to object beginning).
</span><span class="c1"></span>				<span class="nx">p</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">special</span><span class="p">.</span><span class="nx">offset</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">special</span><span class="p">.</span><span class="nx">kind</span> <span class="o">==</span> <span class="nx">_KindSpecialFinalizer</span> <span class="o">||</span> <span class="p">!</span><span class="nx">hasFin</span> <span class="p">{</span>
					<span class="c1">// Splice out special record.
</span><span class="c1"></span>					<span class="nx">y</span> <span class="o">:=</span> <span class="nx">special</span>
					<span class="nx">special</span> <span class="p">=</span> <span class="nx">special</span><span class="p">.</span><span class="nx">next</span>
					<span class="o">*</span><span class="nx">specialp</span> <span class="p">=</span> <span class="nx">special</span>
					<span class="nf">freespecial</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="nx">size</span><span class="p">)</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="c1">// This is profile record, but the object has finalizers (so kept alive).
</span><span class="c1"></span>					<span class="c1">// Keep special record.
</span><span class="c1"></span>					<span class="nx">specialp</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">special</span><span class="p">.</span><span class="nx">next</span>
					<span class="nx">special</span> <span class="p">=</span> <span class="o">*</span><span class="nx">specialp</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// object is still live: keep special record
</span><span class="c1"></span>			<span class="nx">specialp</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">special</span><span class="p">.</span><span class="nx">next</span>
			<span class="nx">special</span> <span class="p">=</span> <span class="o">*</span><span class="nx">specialp</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">hadSpecials</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">specials</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">spanHasNoSpecials</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">allocfreetrace</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">clobberfree</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">raceenabled</span> <span class="o">||</span> <span class="nx">msanenabled</span> <span class="p">{</span>
		<span class="c1">// Find all newly freed objects. This doesn&#39;t have to
</span><span class="c1"></span>		<span class="c1">// efficient; allocfreetrace has massive overhead.
</span><span class="c1"></span>		<span class="nx">mbits</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">markBitsForBase</span><span class="p">()</span>
		<span class="nx">abits</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">allocBitsForIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">mbits</span><span class="p">.</span><span class="nf">isMarked</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">abits</span><span class="p">.</span><span class="nx">index</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">||</span> <span class="nx">abits</span><span class="p">.</span><span class="nf">isMarked</span><span class="p">())</span> <span class="p">{</span>
				<span class="nx">x</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">i</span><span class="o">*</span><span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>
				<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">allocfreetrace</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="nf">tracefree</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">clobberfree</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="nf">clobberfree</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
					<span class="nf">racefree</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
					<span class="nf">msanfree</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="nx">mbits</span><span class="p">.</span><span class="nf">advance</span><span class="p">()</span>
			<span class="nx">abits</span><span class="p">.</span><span class="nf">advance</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Check for zombie objects.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="c1">// Everything &lt; freeindex is allocated and hence
</span><span class="c1"></span>		<span class="c1">// cannot be zombies.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// Check the first bitmap byte, where we have to be
</span><span class="c1"></span>		<span class="c1">// careful with freeindex.
</span><span class="c1"></span>		<span class="nx">obj</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">s</span><span class="p">.</span><span class="nx">gcmarkBits</span><span class="p">.</span><span class="nf">bytep</span><span class="p">(</span><span class="nx">obj</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span><span class="o">&amp;^*</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocBits</span><span class="p">.</span><span class="nf">bytep</span><span class="p">(</span><span class="nx">obj</span> <span class="o">/</span> <span class="mi">8</span><span class="p">))</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="nx">obj</span><span class="o">%</span><span class="mi">8</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">reportZombies</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="c1">// Check remaining bytes.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">obj</span><span class="o">/</span><span class="mi">8</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nf">divRoundUp</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="o">*</span><span class="nx">s</span><span class="p">.</span><span class="nx">gcmarkBits</span><span class="p">.</span><span class="nf">bytep</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">&amp;^*</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocBits</span><span class="p">.</span><span class="nf">bytep</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">s</span><span class="p">.</span><span class="nf">reportZombies</span><span class="p">()</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 计算释放的对象数量
</span><span class="c1"></span>	<span class="c1">// Count the number of free objects in this span.
</span><span class="c1"></span>	<span class="nx">nalloc</span> <span class="o">:=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">countAlloc</span><span class="p">())</span>
	<span class="nx">nfreed</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span> <span class="o">-</span> <span class="nx">nalloc</span>
	<span class="k">if</span> <span class="nx">nalloc</span> <span class="p">&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span> <span class="p">{</span>
		<span class="c1">// The zombie check above should have caught this in
</span><span class="c1"></span>		<span class="c1">// more detail.
</span><span class="c1"></span>		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: nelems=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">,</span> <span class="s">&#34; nalloc=&#34;</span><span class="p">,</span> <span class="nx">nalloc</span><span class="p">,</span> <span class="s">&#34; previous allocCount=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">,</span> <span class="s">&#34; nfreed=&#34;</span><span class="p">,</span> <span class="nx">nfreed</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;sweep increased allocation count&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 设置新的allocCount
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span> <span class="p">=</span> <span class="nx">nalloc</span>
	<span class="c1">// 重置freeindex, 下次分配从0开始搜索
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// reset allocation index to start of span.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">traceReclaimed</span> <span class="o">+=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">nfreed</span><span class="p">)</span> <span class="o">*</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>
	<span class="p">}</span>
	<span class="c1">// gcmarkBits变为新的allocBits
</span><span class="c1"></span>	<span class="c1">// 然后重新分配一块全部为0的gcmarkBits
</span><span class="c1"></span>	<span class="c1">// 下次分配对象时可以根据allocBits得知哪些元素是未分配的
</span><span class="c1"></span>	<span class="c1">// gcmarkBits becomes the allocBits.
</span><span class="c1"></span>	<span class="c1">// get a fresh cleared gcmarkBits in preparation for next GC
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">allocBits</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">gcmarkBits</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">gcmarkBits</span> <span class="p">=</span> <span class="nf">newMarkBits</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span>
	<span class="c1">// 更新freeindex开始的allocCache
</span><span class="c1"></span>	<span class="c1">// Initialize alloc bits cache.
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nf">refillAllocCache</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

	<span class="c1">// The span must be in our exclusive ownership until we update sweepgen,
</span><span class="c1"></span>	<span class="c1">// check for potential races.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">state</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nf">get</span><span class="p">();</span> <span class="nx">state</span> <span class="o">!=</span> <span class="nx">mSpanInUse</span> <span class="o">||</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">!=</span> <span class="nx">sweepgen</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;mspan.sweep: state=&#34;</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="s">&#34; sweepgen=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="s">&#34; mheap.sweepgen=&#34;</span><span class="p">,</span> <span class="nx">sweepgen</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;mspan.sweep: bad span state after sweep&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sweepgen</span><span class="o">+</span><span class="mi">1</span> <span class="o">||</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sweepgen</span><span class="o">+</span><span class="mi">3</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;swept cached span&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// We need to set s.sweepgen = h.sweepgen only when all blocks are swept,
</span><span class="c1"></span>	<span class="c1">// because of the potential for a concurrent free/SetFinalizer.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// But we need to set it before we make the span available for allocation
</span><span class="c1"></span>	<span class="c1">// (return it to heap or mcentral), because allocation code assumes that a
</span><span class="c1"></span>	<span class="c1">// span is already swept if available for allocation.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Serialization point.
</span><span class="c1"></span>	<span class="c1">// At this point the mark bits are cleared and allocation ready
</span><span class="c1"></span>	<span class="c1">// to go so release the span.
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">sweepgen</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">spc</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Handle spans for small objects.
</span><span class="c1"></span>		<span class="c1">// 把span加到mcentral, res等于是否添加成功
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">nfreed</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Only mark the span as needing zeroing if we&#39;ve freed any
</span><span class="c1"></span>			<span class="c1">// objects, because a fresh span that had been allocated into,
</span><span class="c1"></span>			<span class="c1">// wasn&#39;t totally filled, but then swept, still has all of its
</span><span class="c1"></span>			<span class="c1">// free slots zeroed.
</span><span class="c1"></span>			<span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="p">=</span> <span class="mi">1</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">local_nsmallfree</span><span class="p">[</span><span class="nx">spc</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()]</span> <span class="o">+=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">nfreed</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">preserve</span> <span class="p">{</span>
			<span class="c1">// The caller may not have removed this span from whatever
</span><span class="c1"></span>			<span class="c1">// unswept set its on but taken ownership of the span for
</span><span class="c1"></span>			<span class="c1">// sweeping by updating sweepgen. If this span still is in
</span><span class="c1"></span>			<span class="c1">// an unswept set, then the mcentral will pop it off the
</span><span class="c1"></span>			<span class="c1">// set, check its sweepgen, and ignore it.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">nalloc</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// Free totally free span directly back to the heap.
</span><span class="c1"></span>				<span class="nx">mheap_</span><span class="p">.</span><span class="nf">freeSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
				<span class="k">return</span> <span class="kc">true</span>
			<span class="p">}</span>
			<span class="c1">// Return span back to the right mcentral list.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">nalloc</span><span class="p">)</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
				<span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">spc</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">fullSwept</span><span class="p">(</span><span class="nx">sweepgen</span><span class="p">).</span><span class="nf">push</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">spc</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">partialSwept</span><span class="p">(</span><span class="nx">sweepgen</span><span class="p">).</span><span class="nf">push</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">!</span><span class="nx">preserve</span> <span class="p">{</span>
		<span class="c1">// Handle spans for large objects.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">nfreed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Free large object span to heap.
</span><span class="c1"></span>
			<span class="c1">// NOTE(rsc,dvyukov): The original implementation of efence
</span><span class="c1"></span>			<span class="c1">// in CL 22060046 used sysFree instead of sysFault, so that
</span><span class="c1"></span>			<span class="c1">// the operating system would eventually give the memory
</span><span class="c1"></span>			<span class="c1">// back to us again, so that an efence program could run
</span><span class="c1"></span>			<span class="c1">// longer without running out of memory. Unfortunately,
</span><span class="c1"></span>			<span class="c1">// calling sysFree here without any kind of adjustment of the
</span><span class="c1"></span>			<span class="c1">// heap data structures means that when the memory does
</span><span class="c1"></span>			<span class="c1">// come back to us, we have the wrong metadata for it, either in
</span><span class="c1"></span>			<span class="c1">// the mspan structures or in the garbage collection bitmap.
</span><span class="c1"></span>			<span class="c1">// Using sysFault here means that the program will run out of
</span><span class="c1"></span>			<span class="c1">// memory fairly quickly in efence mode, but at least it won&#39;t
</span><span class="c1"></span>			<span class="c1">// have mysterious crashes due to confused memory reuse.
</span><span class="c1"></span>			<span class="c1">// It should be possible to switch back to sysFree if we also
</span><span class="c1"></span>			<span class="c1">// implement and then call some kind of mheap.deleteSpan.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">efence</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">s</span><span class="p">.</span><span class="nx">limit</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// prevent mlookup from finding this span
</span><span class="c1"></span>				<span class="nf">sysFault</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()),</span> <span class="nx">size</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">mheap_</span><span class="p">.</span><span class="nf">freeSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">local_nlargefree</span><span class="o">++</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">local_largefree</span> <span class="o">+=</span> <span class="nx">size</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>

		<span class="c1">// Add a large span directly onto the full+swept list.
</span><span class="c1"></span>		<span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">spc</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">fullSwept</span><span class="p">(</span><span class="nx">sweepgen</span><span class="p">).</span><span class="nf">push</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从bgsweep和前面的分配器可以看出扫描阶段的工作是十分懒惰(lazy)的,实际可能会出现前一阶段的扫描还未完成, 就需要开始新一轮的GC的情况,所以每一轮GC开始之前都需要完成前一轮GC的扫描工作(Sweep Termination阶段).</p>
<h4 id="freesomewbufs">freeSomeWbufs</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// freeSomeWbufs 释放一些 workbufs 回到堆中，如果需要再次调用则返回 true
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">freeSomeWbufs</span><span class="p">(</span><span class="nx">preemptible</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="kd">const</span> <span class="nx">batchSize</span> <span class="p">=</span> <span class="mi">64</span> <span class="c1">// 每个 span 需要 ~1–2 µs
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">wbufSpans</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">// 如果此时在标记阶段、或者 wbufSpans 为空，则不需要进行释放
</span><span class="c1"></span>	<span class="c1">// 因为标记阶段 workbufs 需要被标记，而 workbufs 为空则更不需要释放
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="o">||</span> <span class="nx">work</span><span class="p">.</span><span class="nx">wbufSpans</span><span class="p">.</span><span class="nx">free</span><span class="p">.</span><span class="nf">isEmpty</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">wbufSpans</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
		<span class="c1">// 清扫一批 span，64 个，大约 ~1–2 µs
</span><span class="c1"></span>		<span class="c1">// 在需要被抢占时停止、在清扫完毕后停止
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">batchSize</span> <span class="o">&amp;&amp;</span> <span class="p">!(</span><span class="nx">preemptible</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">span</span> <span class="o">:=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">wbufSpans</span><span class="p">.</span><span class="nx">free</span><span class="p">.</span><span class="nx">first</span>
			<span class="k">if</span> <span class="nx">span</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="c1">// 将 span 移除 wbufSpans 的空闲链表中
</span><span class="c1"></span>			<span class="nx">work</span><span class="p">.</span><span class="nx">wbufSpans</span><span class="p">.</span><span class="nx">free</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">span</span><span class="p">)</span>
			<span class="c1">// 将 span 归还到 mheap 中
</span><span class="c1"></span>			<span class="nx">mheap_</span><span class="p">.</span><span class="nf">freeManual</span><span class="p">(</span><span class="nx">span</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_sys</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">})</span>
	<span class="c1">// workbufs 的空闲 span 列表尚未清空，还需要更多清扫
</span><span class="c1"></span>	<span class="nx">more</span> <span class="o">:=</span> <span class="p">!</span><span class="nx">work</span><span class="p">.</span><span class="nx">wbufSpans</span><span class="p">.</span><span class="nx">free</span><span class="p">.</span><span class="nf">isEmpty</span><span class="p">()</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">wbufSpans</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">more</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:systemstack
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">freeManual</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">,</span> <span class="nx">stat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// span 在下次被分配走时需要对该段内存进行清零
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="o">*</span><span class="nx">stat</span> <span class="o">-=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="o">&lt;&lt;</span> <span class="nx">_PageShift</span><span class="p">)</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_sys</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="o">&lt;&lt;</span> <span class="nx">_PageShift</span><span class="p">)</span> <span class="c1">// 记录并增加堆中的剩余空间
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nf">freeSpanLocked</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// 将其释放会堆中
</span><span class="c1"></span>	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">freeSpanLocked</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">,</span> <span class="nx">acctinuse</span><span class="p">,</span> <span class="nx">acctidle</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">mSpanManual</span><span class="p">:</span>
		<span class="o">...</span> <span class="c1">// panic
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">mSpanInUse</span><span class="p">:</span>
		<span class="o">...</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">pagesInUse</span> <span class="o">-=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="p">)</span>

		<span class="c1">// 清除 arena page bitmap 正在使用的二进制位
</span><span class="c1"></span>		<span class="nx">arena</span><span class="p">,</span> <span class="nx">pageIdx</span><span class="p">,</span> <span class="nx">pageMask</span> <span class="o">:=</span> <span class="nf">pageIndexOf</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
		<span class="nx">arena</span><span class="p">.</span><span class="nx">pageInUse</span><span class="p">[</span><span class="nx">pageIdx</span><span class="p">]</span> <span class="o">&amp;^=</span> <span class="nx">pageMask</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="o">...</span> <span class="c1">// panic
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">acctinuse</span> <span class="p">{</span>
		<span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_inuse</span> <span class="o">-=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="o">&lt;&lt;</span> <span class="nx">_PageShift</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">acctidle</span> <span class="p">{</span>
		<span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_idle</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="o">&lt;&lt;</span> <span class="nx">_PageShift</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">mSpanFree</span>

	<span class="c1">// 与邻居进行结合
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nf">coalesce</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>

	<span class="c1">// 插入回 treap
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">free</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<p><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#%E5%86%85%E5%AD%98%E6%B8%85%E7%90%86">7.2 垃圾收集器</a></p>
<p><a href="https://blog.csdn.net/cyq6239075/article/details/106412038">深入理解GO语言：GC原理及源码分析</a></p>
<p><a href="https://juejin.cn/post/6854573210365591559#heading-6">golang 混合写屏障深入剖析。</a></p>
<p><a href="https://wudaijun.com/2020/01/go-gc-keypoint-and-monitor/">Golang GC核心要点和度量方法</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-11-30
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go%E6%BA%90%E7%A0%81/">Go源码</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go%E4%B8%AD%E7%9A%84data-race/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go中的Data-Race</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/go%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E5%8D%8F%E4%BD%9C%E4%B8%8E%E6%8A%A2%E5%8D%A0/">
            <span class="next-text nav-default">Go调度器的协作与抢占</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
