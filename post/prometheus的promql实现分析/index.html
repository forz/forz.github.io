<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Prometheus的PromQL实现分析 | Forz Blog</title>
<meta name="keywords" content="Prometheus, Go" />
<meta name="description" content="PromQL PromQL 是 Prom 中的查询语言，提供了简洁的、贴近自然语言的语法实现时序数据的分析计算。 表达式（Expression）是其中承载数据计算逻辑的部分，对">
<meta name="author" content="">
<link rel="canonical" href="/post/prometheus%E7%9A%84promql%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Prometheus的PromQL实现分析" />
<meta property="og:description" content="PromQL PromQL 是 Prom 中的查询语言，提供了简洁的、贴近自然语言的语法实现时序数据的分析计算。 表达式（Expression）是其中承载数据计算逻辑的部分，对" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/prometheus%E7%9A%84promql%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-07-17T18:11:48&#43;00:00" />
<meta property="article:modified_time" content="2020-07-17T18:11:48&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Prometheus的PromQL实现分析"/>
<meta name="twitter:description" content="PromQL PromQL 是 Prom 中的查询语言，提供了简洁的、贴近自然语言的语法实现时序数据的分析计算。 表达式（Expression）是其中承载数据计算逻辑的部分，对"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Prometheus的PromQL实现分析",
      "item": "/post/prometheus%E7%9A%84promql%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Prometheus的PromQL实现分析",
  "name": "Prometheus的PromQL实现分析",
  "description": "PromQL PromQL 是 Prom 中的查询语言，提供了简洁的、贴近自然语言的语法实现时序数据的分析计算。 表达式（Expression）是其中承载数据计算逻辑的部分，对",
  "keywords": [
    "Prometheus", "Go"
  ],
  "articleBody": "PromQL PromQL 是 Prom 中的查询语言，提供了简洁的、贴近自然语言的语法实现时序数据的分析计算。\n表达式（Expression）是其中承载数据计算逻辑的部分，对表达式的准确理解有助于充分利用 promql 提供的计算和分析能力，本节先结合一个相对复杂的表达式来介绍 PromQL 的计算过程，然后对部分有代表性的函数实现进行了源码分析。\n计算过程 PromQL 表达式输入是一段文本，Prom 会解析这段文本，将它转化为一个结构化的语法树对象，进而实现相应的数据计算逻辑，这里选用一个相对比较复杂的表达式为例：\n1  sum(avg_over_time(go_goroutines{job=\"prometheus\"}[5m])) by (instance)   上述表达式可以从外往内分解为三层：\n sum(…) by (instance)：序列纵向分组合并序列（包含相同的 instance 会分配到一组） avg_over_time(…) go_goroutines{job=“prometheus”}[5m]  调用 Prom Restful API 查询表达式计算工作流如图 2.1.1 所示，请求数据的时候给出的 step 参数就是这里的 interval，它设定结果中相邻两个点的间隔，对 promql 的每次 evaluator 都是针对某个确定的时间点和 statement 来计算的，得到一个 vector（时间戳相同的向量）。Prom 可以将异构（时间戳不一致）的多维时间序列经过计算转化为同构（时间戳一致）的多维时间序列。\n先看 go_goroutines{job=“prometheus”}[5m] 的计算，这是一个某个时间点的 MatrixSelector 对象（图 2.1.2）。\n此处 iterator 是序列筛选结果的顺序访问接口，图 2.1.2 中获取某个时间点往前的一段历史数据，这是一个二维矩阵 (matrix)，进而由外层函数将这段历史数据汇总成一个 vector（图 2.1.3）。\n值得一提的是，很多函数（如 rate）都需要传入 matrix，尽管如此，这些函数的输出依然是针对某个时间点的 vector，它仅仅是在计算某个时间点的 vector 时考察了一部分历史数据而已。\n最后来看关键字（keyword）sum 的实现，这里注意 sum 不是函数（Function），图 2.1.4 给出了所有关键字列表。\nsum 关键字的完整语法比较复杂，本文中只介绍例子中给出的 sum(…) by (instance)。\n至此输出某个时间点的结果向量，整个表达式的计算过程在 Excel 中集中展示如图 2.1.6 所示。\n图 2.1.6 sum(avg_over_time(go_goroutines{job=“prometheus”}[5m])) by (instance) 计算过程\nPromQL 有三个很简单的原则：\n 任意 PromQL 返回的结果都不是原始数据，即使查询一个具体的 Metric（如 go_goroutines），结果也不是原始数据 任意 Metrics 经过 Function 计算后会丢失 __name__ Label 子序列间具备完全相同的 Label/Value 键值对（可以有不同的 __name__）才能进行代数运算  特别强调一些，如 2.1.1 所述，PromQL 在计算时使用的等距 interval 时间点，每个 interval 时间点的结果都是利用附近的采样点经过某种形式的估算或近似得到的，所以在 Prom 中提诸如“1:28:07 AM 发生了 113 次某种事件”是不准确的，PromQL 所有计算结果都存在误差。\n有意思的是，在 Prom 中对多维时间序列进行代数运算时，不需要严格检查两边的矩阵一致性，因为 PromQL 只会处理相同 Label/Value 的序列之间的代数运算，图 2.1.7 中对两个不相关的 Metric 进行了代数运算，来说明代数运算的基本原理，这在一些以“数据库”为核心的系统中，如 influxdb，涉及跨表运算，无论是表达式复杂度还是计算性能都会有影响。\n最后需要特别提的一点是，PromQL 表达式计算的原始数据集是共享内存空间的，但计算的中间结果是不共享内存空间的，所以从优化内存占用的角度来看，应该将常用的表达式持久化成 Metric，减少动态计算过程，让内存使用做到可控，这可以借助 Recording Rules 完成 。\n部分函数（Function）实现 Prom 提供了丰富的函数（Function）库来对数据做复杂分析，本节通过介绍几个有代表性的函数实现来介绍其用途，希望能帮助读者准确理解表达式计算结果背后的工程含义。\ndelta/rate/increase delta/rate/increase 背后共享了相同的计算逻辑（图 2.2.1），仅仅是参数不同。\n来看 extrapolatedRate 实现（图 2.2.2），基于线性外插算法估计了 interval 时间点的采样值增量，Prom 实现中大量使用了线性插值。基本原理很简单，计算 range 范围内采样点头尾斜率，然后线性延伸至实际 interval 时间点。\n特别提一下此处的两个参数 isCounter 和 isRate，其中 isCounter=true 说明数据需要保证单调递增，当 Counter 的客户端重启后，数据会归零，出现非单调递增的数据，那么 isCounter 可以控制是否对该数据进行修正；isRate=true 用来对数据做采样范围内的均值，其结果表征当前时间点一秒内的采样值增量（秒级别增量）。\n现在回头看图 2.2.1 中 delta/rate/increase 的参数就很明朗了（表 2.2.1）。 可见 delta 在处理数据时，不假设数据单调递增（isCounter=false），适合用来处理 Gauge 数据；而 increase 适合处理 Counter 数据，并获取 range 范围内增量；rate 适合处理 counter 并获取 range 范围内的秒级增量。\nXXX_over_time XXX_over_time 实现 range 范围内数据的横向汇总，即采用 range 范围内的一定量历史数据估算当前时间点的值，其中 XXX 可以是 avg/sum/max/min 等动词，图 2.2.3 中为 XXX_over_time 中的函数 。\n由于它们的区别仅仅是对 range 内数据进行横向汇总时的计算方式不同，此处不做一一介绍，只关注其中的 avg_over_time 实现（图 2.2.4）。\navg_over_time 的核心逻辑在 aggrOverTime 中实现，见图 2.2.5。\nXXX_over_time 常用来做数据平滑，过滤数据中的异常点，其中 avg_over_time 就是常见的“滑动窗口平均”，在信号处理中为一种低通滤波器实现。\nhistogram_quantile histogram_quantile（图 2.2.6）是 Prom 中比较难以理解的函数之一，可以根据 Histogram 估计估算采样数据在某个正态分布分位点的值（实际上估计的是 Upper Bound，即上限）。\n估算 quantile 采样值逻辑在 bucketQuantile（图 2.2.7）函数中实现。\n总结 Prom 是一种典型的基于 Metric 的监控系统，Metric 是多维时序数据分析在\\工程中的一种表现形式。社区中常将 Kubernetes 和 Prometheus 放到一起讨论，它的设计理念和 Kubernetes 也如出一辙：二者都为特定问题提出了标准或协议，为终端用户提供了易用的接口，专注于提供领域价值。\nProm 数据采集主要是通过 pull 模型实现的，主动从客户端拉取数据，减少了监控对象对外部系统的依赖，这种模型下监控对象只需维护少量客户端数据，保持可控、简单的实现，降低了维护复杂客户端逻辑的风险。另外，Prom 为一些临时存在的进程，如批处理任务，提供了 Push Gateway，这些客户端可以将数据 push 到 Push Gateway 中，然后由 Push Gateway 提供 pull 接口将数据暴露给 Prom Server。\n相比 Prom，常见的 Metric 监控方案（如 InfluxDB 的 metrics 客户端实现 https://github.com/rcrowley/go-metrics ）都是 push 模型，在客户端需要维护采样数据生命周期（如长时间没有存储成功的数据需要丢弃等），还需要避免客户端在数据采集和存储过程中可能出现的资源泄漏。\n此外，PromQL 是 Prom 中一个争议和亮点并存的点，它提供了友好的、贴近时序数据语义的语法，对时序数据分析有着丰富的支持，如 Prom 考虑了 Counter 这种单调递增数据由于客户端反复重启导致数据归零的问题，Prom 中很多函数在计算的时候就对这样的数据进行了容错，对数据分析完全透明，极大地提升了易用性；同时 PromQL 提供了 histogram_quantile 根据 Histogram 来估算 quantile 值的计算支持，让 quantile 在 Prom 端计算可以降低客户端带来的额外性能负担。\n总之，Prom 数据模型、分析计算接口的设计上都有着良好的一致性和扩展性。基于 pull 的数据采集模型一方面降低了客户端复杂度和对外部系统的依赖，另一方面也让客户端实现自由扩展。反观很多基于 push 模型的监控系统实现，瞬间扩展可能使监控系统服务端出现性能瓶颈，波及整个系统；还有 PromQL 简洁的接口让复杂的时序数据分析变得直观，很多工程上需要处理的数据预处理 Prom 都已经内置了，减少了数据预处理成本。\n转载:Prometheus 原理和源码分析\n",
  "wordCount" : "2878",
  "inLanguage": "zh-cn",
  "datePublished": "2020-07-17T18:11:48Z",
  "dateModified": "2020-07-17T18:11:48Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/prometheus%E7%9A%84promql%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Prometheus的PromQL实现分析
    </h1>
    <div class="post-meta">July 17, 2020
</div>
  </header> 
  <div class="post-content"><h1 id="promql">PromQL<a hidden class="anchor" aria-hidden="true" href="#promql">#</a></h1>
<p>PromQL 是 Prom 中的查询语言，提供了简洁的、贴近自然语言的语法实现时序数据的分析计算。</p>
<p>表达式（Expression）是其中承载数据计算逻辑的部分，对表达式的准确理解有助于充分利用 promql 提供的计算和分析能力，本节先结合一个相对复杂的表达式来介绍 PromQL 的计算过程，然后对部分有代表性的函数实现进行了源码分析。</p>
<h1 id="计算过程">计算过程<a hidden class="anchor" aria-hidden="true" href="#计算过程">#</a></h1>
<p>PromQL 表达式输入是一段文本，Prom 会解析这段文本，将它转化为一个结构化的语法树对象，进而实现相应的数据计算逻辑，这里选用一个相对比较复杂的表达式为例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">sum</span><span class="p">(</span><span class="nf">avg_over_time</span><span class="p">(</span><span class="nx">go_goroutines</span><span class="p">{</span><span class="nx">job</span><span class="p">=</span><span class="s">&#34;prometheus&#34;</span><span class="p">}[</span><span class="mi">5</span><span class="nx">m</span><span class="p">]))</span> <span class="nf">by</span> <span class="p">(</span><span class="nx">instance</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>上述表达式可以从外往内分解为三层：</p>
<ul>
<li>sum(…) by (instance)：序列纵向分组合并序列（包含相同的 instance 会分配到一组）</li>
<li>avg_over_time(…)</li>
<li>go_goroutines{job=&ldquo;prometheus&rdquo;}[5m]</li>
</ul>
<p>调用 Prom Restful API 查询表达式计算工作流如图 2.1.1 所示，请求数据的时候给出的 step 参数就是这里的 interval，它设定结果中相邻两个点的间隔，对 promql 的每次 evaluator 都是针对某个确定的时间点和 statement 来计算的，得到一个 vector（时间戳相同的向量）。Prom 可以将异构（时间戳不一致）的多维时间序列经过计算转化为同构（时间戳一致）的多维时间序列。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200719182619.png" alt=""  />
</p>
<p>先看 go_goroutines{job=&ldquo;prometheus&rdquo;}[5m] 的计算，这是一个某个时间点的 MatrixSelector 对象（图 2.1.2）。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200719182756.png" alt=""  />
</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200719233145.png" alt=""  />
</p>
<p>此处 iterator 是序列筛选结果的顺序访问接口，图 2.1.2 中获取某个时间点往前的一段历史数据，这是一个二维矩阵 (matrix)，进而由外层函数将这段历史数据汇总成一个 vector（图 2.1.3）。</p>
<p>值得一提的是，很多函数（如 rate）都需要传入 matrix，尽管如此，这些函数的输出依然是针对某个时间点的 vector，它仅仅是在计算某个时间点的 vector 时考察了一部分历史数据而已。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200719233216.png" alt=""  />
</p>
<p>最后来看关键字（keyword）sum 的实现，这里注意 sum 不是函数（Function），图 2.1.4 给出了所有关键字列表。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200719233228.png" alt=""  />
</p>
<p>sum 关键字的完整语法比较复杂，本文中只介绍例子中给出的 sum(…) by (instance)。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200719233251.png" alt=""  />
</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200719233259.png" alt=""  />
</p>
<p>至此输出某个时间点的结果向量，整个表达式的计算过程在 Excel 中集中展示如图 2.1.6 所示。</p>
<p>图 2.1.6 sum(avg_over_time(go_goroutines{job=&ldquo;prometheus&rdquo;}[5m])) by (instance) 计算过程</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200719233314.png" alt=""  />
</p>
<p>PromQL 有三个很简单的原则：</p>
<ul>
<li>任意 PromQL 返回的结果都不是原始数据，即使查询一个具体的 Metric（如 go_goroutines），结果也不是原始数据</li>
<li>任意 Metrics 经过 Function 计算后会丢失 <code>__name__</code> Label</li>
<li>子序列间具备完全相同的 Label/Value 键值对（可以有不同的 <code>__name__</code>）才能进行代数运算</li>
</ul>
<p>特别强调一些，如 2.1.1 所述，PromQL 在计算时使用的等距 interval 时间点，每个 interval 时间点的结果都是利用附近的采样点经过某种形式的估算或近似得到的，所以在 Prom 中提诸如“1:28:07 AM 发生了 113 次某种事件”是不准确的，PromQL 所有计算结果都存在误差。</p>
<p>有意思的是，在 Prom 中对多维时间序列进行代数运算时，不需要严格检查两边的矩阵一致性，因为 PromQL 只会处理相同 Label/Value 的序列之间的代数运算，图 2.1.7 中对两个不相关的 Metric 进行了代数运算，来说明代数运算的基本原理，这在一些以“数据库”为核心的系统中，如 influxdb，涉及跨表运算，无论是表达式复杂度还是计算性能都会有影响。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200719233441.png" alt=""  />
</p>
<p>最后需要特别提的一点是，PromQL 表达式计算的原始数据集是共享内存空间的，但计算的中间结果是不共享内存空间的，所以从优化内存占用的角度来看，应该将常用的表达式持久化成 Metric，减少动态计算过程，让内存使用做到可控，这可以借助 Recording Rules 完成 。</p>
<h1 id="部分函数function实现">部分函数（Function）实现<a hidden class="anchor" aria-hidden="true" href="#部分函数function实现">#</a></h1>
<p>Prom 提供了丰富的函数（Function）库来对数据做复杂分析，本节通过介绍几个有代表性的函数实现来介绍其用途，希望能帮助读者准确理解表达式计算结果背后的工程含义。</p>
<h2 id="deltarateincrease">delta/rate/increase<a hidden class="anchor" aria-hidden="true" href="#deltarateincrease">#</a></h2>
<p>delta/rate/increase 背后共享了相同的计算逻辑（图 2.2.1），仅仅是参数不同。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200719233532.png" alt=""  />
</p>
<p>来看 extrapolatedRate 实现（图 2.2.2），基于线性外插算法估计了 interval 时间点的采样值增量，Prom 实现中大量使用了线性插值。基本原理很简单，计算 range 范围内采样点头尾斜率，然后线性延伸至实际 interval 时间点。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200719233545.png" alt=""  />
</p>
<p>特别提一下此处的两个参数 isCounter 和 isRate，其中 isCounter=true 说明数据需要保证单调递增，当 Counter 的客户端重启后，数据会归零，出现非单调递增的数据，那么 isCounter 可以控制是否对该数据进行修正；isRate=true 用来对数据做采样范围内的均值，其结果表征当前时间点一秒内的采样值增量（秒级别增量）。</p>
<p>现在回头看图 2.2.1 中 delta/rate/increase 的参数就很明朗了（表 2.2.1）。
<img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200719233728.png" alt=""  />
</p>
<p>可见 delta 在处理数据时，不假设数据单调递增（isCounter=false），适合用来处理 Gauge 数据；而 increase 适合处理 Counter 数据，并获取 range 范围内增量；rate 适合处理 counter 并获取 range 范围内的秒级增量。</p>
<h2 id="xxx_over_time">XXX_over_time<a hidden class="anchor" aria-hidden="true" href="#xxx_over_time">#</a></h2>
<p>XXX_over_time 实现 range 范围内数据的横向汇总，即采用 range 范围内的一定量历史数据估算当前时间点的值，其中 XXX 可以是 avg/sum/max/min 等动词，图 2.2.3 中为 XXX_over_time 中的函数 。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200719233802.png" alt=""  />
</p>
<p>由于它们的区别仅仅是对 range 内数据进行横向汇总时的计算方式不同，此处不做一一介绍，只关注其中的 avg_over_time 实现（图 2.2.4）。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200719233811.png" alt=""  />
</p>
<p>avg_over_time 的核心逻辑在 aggrOverTime 中实现，见图 2.2.5。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200719233821.png" alt=""  />
</p>
<p>XXX_over_time 常用来做数据平滑，过滤数据中的异常点，其中 avg_over_time 就是常见的“滑动窗口平均”，在信号处理中为一种低通滤波器实现。</p>
<h2 id="histogram_quantile">histogram_quantile<a hidden class="anchor" aria-hidden="true" href="#histogram_quantile">#</a></h2>
<p>histogram_quantile（图 2.2.6）是 Prom 中比较难以理解的函数之一，可以根据 Histogram 估计估算采样数据在某个正态分布分位点的值（实际上估计的是 Upper Bound，即上限）。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200719233838.png" alt=""  />
</p>
<p>估算 quantile 采样值逻辑在 bucketQuantile（图 2.2.7）函数中实现。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200719233849.png" alt=""  />
</p>
<h1 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h1>
<p>Prom 是一种典型的基于 Metric 的监控系统，Metric 是多维时序数据分析在\工程中的一种表现形式。社区中常将 Kubernetes 和 Prometheus 放到一起讨论，它的设计理念和 Kubernetes 也如出一辙：二者都为特定问题提出了标准或协议，为终端用户提供了易用的接口，专注于提供领域价值。</p>
<p>Prom 数据采集主要是通过 pull 模型实现的，主动从客户端拉取数据，减少了监控对象对外部系统的依赖，这种模型下监控对象只需维护少量客户端数据，保持可控、简单的实现，降低了维护复杂客户端逻辑的风险。另外，Prom 为一些临时存在的进程，如批处理任务，提供了 Push Gateway，这些客户端可以将数据 push 到 Push Gateway 中，然后由 Push Gateway 提供 pull 接口将数据暴露给 Prom Server。</p>
<p>相比 Prom，常见的 Metric 监控方案（如 InfluxDB 的 metrics 客户端实现 <a href="https://github.com/rcrowley/go-metrics">https://github.com/rcrowley/go-metrics</a> ）都是 push 模型，在客户端需要维护采样数据生命周期（如长时间没有存储成功的数据需要丢弃等），还需要避免客户端在数据采集和存储过程中可能出现的资源泄漏。</p>
<p>此外，PromQL 是 Prom 中一个争议和亮点并存的点，它提供了友好的、贴近时序数据语义的语法，对时序数据分析有着丰富的支持，如 Prom 考虑了 Counter 这种单调递增数据由于客户端反复重启导致数据归零的问题，Prom 中很多函数在计算的时候就对这样的数据进行了容错，对数据分析完全透明，极大地提升了易用性；同时 PromQL 提供了 histogram_quantile 根据 Histogram 来估算 quantile 值的计算支持，让 quantile 在 Prom 端计算可以降低客户端带来的额外性能负担。</p>
<p>总之，Prom 数据模型、分析计算接口的设计上都有着良好的一致性和扩展性。基于 pull 的数据采集模型一方面降低了客户端复杂度和对外部系统的依赖，另一方面也让客户端实现自由扩展。反观很多基于 push 模型的监控系统实现，瞬间扩展可能使监控系统服务端出现性能瓶颈，波及整个系统；还有 PromQL 简洁的接口让复杂的时序数据分析变得直观，很多工程上需要处理的数据预处理 Prom 都已经内置了，减少了数据预处理成本。</p>
<p>转载:<a href="https://www.infoq.cn/article/Prometheus-theory-source-code">Prometheus 原理和源码分析</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/prometheus/">Prometheus</a></li>
      <li><a href="/tags/go/">Go</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
