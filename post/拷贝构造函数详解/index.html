<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>拷贝构造函数详解 | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="什么是拷贝构造函数 首先对于普通类型的对象来说，它们之间的复制是很简单的，例如： int a = 100; int b = a; 而类对象与普通对象不同，类对象内部结构一般较为">
<meta name="author" content="">
<link rel="canonical" href="/post/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="拷贝构造函数详解" />
<meta property="og:description" content="什么是拷贝构造函数 首先对于普通类型的对象来说，它们之间的复制是很简单的，例如： int a = 100; int b = a; 而类对象与普通对象不同，类对象内部结构一般较为" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-24T11:00:59&#43;00:00" />
<meta property="article:modified_time" content="2017-06-24T11:00:59&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="拷贝构造函数详解"/>
<meta name="twitter:description" content="什么是拷贝构造函数 首先对于普通类型的对象来说，它们之间的复制是很简单的，例如： int a = 100; int b = a; 而类对象与普通对象不同，类对象内部结构一般较为"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "拷贝构造函数详解",
      "item": "/post/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "拷贝构造函数详解",
  "name": "拷贝构造函数详解",
  "description": "什么是拷贝构造函数 首先对于普通类型的对象来说，它们之间的复制是很简单的，例如： int a = 100; int b = a; 而类对象与普通对象不同，类对象内部结构一般较为",
  "keywords": [
    
  ],
  "articleBody": "什么是拷贝构造函数 首先对于普通类型的对象来说，它们之间的复制是很简单的，例如：\nint a = 100; int b = a; 而类对象与普通对象不同，类对象内部结构一般较为复杂，存在各种成员变量。\n下面看一个类对象拷贝的简单例子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #include using namespace std; class CExample { private: int a; public: //构造函数  CExample(int b) { a = b;} //一般函数  void Show () { coutaendl; } }; int main() { CExample A(100); CExample B = A; //注意这里的对象初始化要调用拷贝构造函数，而非赋值  B.Show (); return 0; }   运行程序，屏幕输出100。从以上代码的运行结果可以看出，系统为对象 B 分配了内存并完成了与对象 A 的复制过程。就类对象而言，相同类型的类对象是通过拷贝构造函数来完成整个复制过程的。\n下面举例说明拷贝构造函数的工作过程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  #include using namespace std; class CExample { private: int a; public: //构造函数  CExample(int b) { a = b;} //拷贝构造函数  CExample(const CExample\u0026 C) { a = C.a; } //一般函数  void Show () { coutaendl; } }; int main() { CExample A(100); CExample B = A; // CExample B(A); 也是一样的  B.Show (); return 0; }   CExample(const CExample\u0026 C)　就是我们自定义的拷贝构造函数。可见，拷贝构造函数是一种特殊的构造函数，函数的名称必须和类名称一致，它必须的一个参数是本类型的一个引用变量。\n拷贝构造函数的调用时机 在C++中，下面三种对象需要调用拷贝构造函数！\n对象以值传递的方式传入函数参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  class CExample { private: int a; public: //构造函数  CExample(int b) { a = b; cout\"creat: \"aendl; } //拷贝构造  CExample(const CExample\u0026 C) { a = C.a; cout\"copy\"endl; } //析构函数  ~CExample() { cout \"delete: \"aendl; } void Show () { coutaendl; } }; //全局函数，传入的是对象 void g_Fun(CExample C) { cout\"test\"endl; } int main() { CExample test(1); //传入对象  g_Fun(test); return 0; }   调用g_Fun()时，会产生以下几个重要步骤：\n  test对象传入形参时，会先会产生一个临时变量，就叫 C 吧。\n  然后调用拷贝构造函数把test的值给C。 整个这两个步骤有点像：CExample C(test);\n  等g_Fun()执行完后, 析构掉 C 对象。\n  对象以值传递的方式从函数返回 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  class CExample { private: int a; public: //构造函数  CExample(int b) { a = b; } //拷贝构造  CExample(const CExample\u0026 C) { a = C.a; cout\"copy\"endl; } void Show () { coutaendl; } }; //全局函数 CExample g_Fun() { CExample temp(0); return temp; } int main() { g_Fun(); return 0; }   当g_Fun()函数执行到return时，会产生以下几个重要步骤：\n  先会产生一个临时变量，就叫XXXX吧。\n  然后调用拷贝构造函数把temp的值给XXXX。整个这两个步骤有点像：CExample XXXX(temp);\n  在函数执行到最后先析构temp局部变量。 等g_Fun()执行完后再析构掉XXXX对象。\n  对象需要通过另外一个对象进行初始化；\n  对象需要通过另外一个对象进行初始化 CExample A(100); CExample B = A; // CExample B(A);  后两句都会调用拷贝构造函数。\n默认拷贝构造函数 很多时候在我们都不知道拷贝构造函数的情况下，传递对象给函数参数或者函数返回对象都能很好的进行，这是因为编译器会给我们自动产生一个拷贝构造函数，这就是“默认拷贝构造函数”.\n这个构造函数很简单，仅仅使用“老对象”的数据成员的值对“新对象”的数据成员一一进行赋值，它一般具有以下形式：\n1 2 3 4 5  Rect::Rect(const Rect\u0026 r) { width=r.width; height=r.height; }   以上代码不用我们编写，编译器会为我们自动生成。但是如果认为这样就可以解决对象的复制问题，那就错了，让我们来考虑以下一段代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  #includeusing namespace std; class Rect { public: Rect() { count++; } ~Rect() { count--; } static int getCount() { return count; } private: int width; int height; static int count; }; int Rect::count=0; int main() { Rect rect1; cout\"The count of Rect:\"Rect::getCount()endl; Rect rect2(rect1); cout\"The count of Rect:\"Rect::getCount()endl; return 0; }   这段代码对前面的类，加入了一个静态成员，目的是进行计数。\n在主函数中，首先创建对象rect1，输出此时的对象个数，然后使用rect1复制出对象rect2，再输出此时的对象个数，按照理解，此时应该有两个对象存在，但实际程序运行时，输出的都是1，反应出只有1个对象。此外，在销毁对象时，由于会调用销毁两个对象，类的析构函数会调用两次，此时的计数器将变为负数。\n说白了，就是拷贝构造函数无法创建新的静态数据成员。\n出现这些问题最根本就在于在复制对象时，计数器没有递增，我们重新编写拷贝构造函数，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  #includeusing namespace std; class Rect { public: Rect() { count++; } Rect(const Rect\u0026 r) { width=r.width; height=r.height; count++; } ~Rect() { count--; } static int getCount() { return count; } private: int width; int height; static int count; }; int Rect::count=0; int main() { Rect rect1; cout\"The count of Rect:\"Rect::getCount()endl; Rect rect2(rect1); cout\"The count of Rect:\"Rect::getCount()endl; return 0; }   浅拷贝和深拷贝的区别 浅拷贝 所谓浅拷贝，指的是在对象复制时，只对对象中的数据成员进行简单的赋值，默认拷贝构造函数执行的也是浅拷贝。大多情况下“浅拷贝”已经能很好地工作了，但是一旦对象存在了动态成员，那么浅拷贝就会出问题了，让我们考虑如下一段代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  #include#includeusing namespace std; class Rect { public: Rect() { p=new int(100); } ~Rect() { assert(p!=NULL); delete p; } private: int width; int height; int *p; }; int main() { Rect rect1; Rect rect2(rect1); return 0; }   在这段代码运行结束之前，会出现一个运行错误。原因就在于在进行对象复制时，对于动态分配的内容没有进行正确的操作。我们来分析一下：\n在运行定义rect1对象后，由于在构造函数中有一个动态分配的语句，因此执行后的内存情况大致如下：\n在使用rect1复制rect2时，由于执行的是浅拷贝，只是将成员的值进行赋值，这时 rect1.p = rect2.p，也即这两个指针指向了堆里的同一个空间，如下图所示：\n当然，这不是我们所期望的结果，在销毁对象时，两个对象的析构函数将对同一个内存空间释放两次，这就是错误出现的原因。我们需要的不是两个p有相同的值，而是两个p指向的空间有相同的值，解决办法就是使用“深拷贝”。\n深拷贝 当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。所以，这时，必须采用深拷贝。\n在“深拷贝”的情况下，对于对象中动态成员，就不能仅仅简单地赋值了，而应该重新动态分配空间，如上面的例子就应该按照如下的方式进行处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  #include#includeusing namespace std; class Rect { public: Rect() { p=new int(100); } Rect(const Rect\u0026 r) { width=r.width; height=r.height; p=new int(100); *p=*(r.p); } ~Rect() { assert(p!=NULL); delete p; } private: int width; int height; int *p; }; int main() { Rect rect1; Rect rect2(rect1); return 0; }   此时，在完成对象的复制后，内存的一个大致情况如下：\n此时rect1的p和rect2的p各自指向一段内存空间，但它们指向的空间具有相同的内容，这就是所谓的“深拷贝”。\n默认拷贝构造函数的合成时机 编译器并不会在所有类中都生成默认拷贝构造函数.决定一个拷贝构造函数是否被生成的标准在于类是否需要\"按位拷贝\".\n在以下4种情况不需要合成默认拷贝构造函数,而是由编译器另外合成新的拷贝构造函数:\n 当class内含一个成员对象而后者的类声明中有一个拷贝构造函数. 当class继承自一个基类而后者存在一个拷贝构造函数时(不论是被显式声明还是被合成而得). 当class声明一个或多个虚函数时. 当class派生自一个继承串链,其中有一个或多个虚基类时.  对于前两种情况,编译器必须将成员对象或基类的拷贝构造函数调用操作安插到合成的拷贝构造函数中.\n情况3因为拷贝过程中会出现类的\"切割\"情况:基类拷贝派生类.此时两者的vptr指向的地址不同.需要在拷贝构造函数中显式设定实例化类对象的vptr.\n情况4由于在执行期前不知道正确的基类,无法判断是否符合\"按位拷贝\".\n为什么拷贝构造函数的形参一般是const引用类型？ Sample (Sample a);  不幸的是,即使是这样朴实无华的声明也隐含了一个微妙的错误,呵,我们来看看：当某个时候需要以一个Sample对象的值来为一个新对象进行初始化时,编译器会在各个重载的构造函数版本(如果有多个的话)搜寻,它找到的这个版本,发现声明参数与传入的对象一致,因此该构造函数将会被调用。目前为止,一切都在我们的意料之中,但问题很快来了：该函数的参数我们使用了值传递的方式,按照前面的分析,这需要调用复制构造函数,于是编译器又再度搜寻,最后当然又找到了它,于是进行调用,但同样地,传参时又要进行复制,于是再调用…这个过程周而复始,每次都是到了函数入口处就进行递归,直到堆栈空间耗尽,程序崩溃…\n由是观之,值传递看来是行不通的了;我想C语言的用户这时很快会反应到与值传递对应的方式：地址传递(传址),于是声明变为这样：\nSample (Sample *p);  只作为一般的构造函数,它应该可以运行得很好,但别忘了我们要提供的是复制构造函数,它要求能够接受一个同类型对象,像这样：\n1 2  Sample a; Sample b(a);   而不是接受指针：\n1 2  Sample a; Sample b(\u0026a); // 还要取地址?当然,它可以正确运行,但...   虽然在初始化对象时可以像上面一样人为加一个取址符,但在函数参数表中(或者函数返回)进行值传递时,编译器可不知道在找不着合适定义的情况下牵就选择你的指针版本。\n如果一个类中只存在一个参数为X\u0026的拷贝构造函数,那么就不能使用const X或volatile X的对象实行拷贝初始化.而如果定义了一个拷贝构造函数，那么编译器就不会再自动默认拷贝构造函数。\n因此若想让定义的拷贝构造函数能够支持const和普通类型的参数，需要使用const形参。\n六、防止默认拷贝发生 通过对对象复制的分析，我们发现对象的复制大多在进行“值传递”时发生，这里有一个小技巧可以防止按值传递——声明一个私有拷贝构造函数。甚至不必去定义这个拷贝构造函数，这样因为拷贝构造函数是私有的，如果用户试图按值传递或函数返回该类对象，将得到一个编译错误，从而可以避免按值传递或返回对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  //防止按值传递 class CExample { private: int a; public: //构造函数  CExample(int b) { a = b; cout\"creat: \"aendl; } private: //拷贝构造函数，只是声明 CExample(const CExample\u0026 C); public: ~CExample() { cout \"delete: \"aendl; } void Show () { coutaendl; } }; void g_Fun(CExample C) { cout\"test\"endl; } int main() { CExample test(1); //g_Fun(test); //无法在函数内生成临时变量，拷贝函数出错  return 0; }   七、拷贝构造函数的细节   拷贝构造函数的作用\n作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例。\n  参数传递过程到底发生了什么？\n将地址传递和值传递统一起来，归根结底还是传递的是”值”(地址也是值，只不过通过它可以找到另一个值)\n  值传递:\n对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)；\n对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)；如void foo(class_type obj_local){}, 如果调用foo(obj); 首先class_type obj_local(obj) ,这样就定义了局部变量obj_local供函数内部使用\n  引用传递:\n无论对内置类型还是类类型，传递引用或指针最终都是传递的地址值！而地址总是指针类型(属于简单类型), 显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用(对于类类型).\n  在类中有指针数据成员时，拷贝构造函数的使用？\n  因为默认的拷贝构造函数是按成员拷贝构造，这导致了两个不同的指针(如ptr1=ptr2)指向了相同的内存。当一个实例销毁时，调用析构函数 free(ptr1)释放了这段内存，那么剩下的一个实例的指针ptr2就无效了，在被销毁的时候free(ptr2)就会出现错误了, 这相当于重复释放一块内存两次。这种情况必须显式声明并实现自己的拷贝构造函数，来为新的实例的指针分配新的内存。\n  以下函数哪个是拷贝构造函数,为什么?\n X::X(const X\u0026); //拷贝构造函数 X::X(X); X::X(X\u0026, int a=1); //拷贝构造函数 X::X(X\u0026, int a=1, int b=2); //拷贝构造函数  解答：\n对于一个类X, 如果一个构造函数的第一个参数是下列之一:\n a) X\u0026 b) const X\u0026 c) volatile X\u0026 d) const volatile X\u0026  且没有其他参数或其他参数都有默认值,那么这个函数是拷贝构造函数.\n  一个类中可以存在多于一个的拷贝构造函数吗?\n解答：\n类中可以存在超过一个拷贝构造函数。\n1 2 3 4 5  class X { public: X(const X\u0026); // const 的拷贝构造  X(X\u0026); // 非const的拷贝构造 };   ``\n注意,如果一个类中只存在一个参数为 X\u0026 的拷贝构造函数,那么就不能使用const X或volatile X的对象实行拷贝初始化.\n如果一个类中没有定义拷贝构造函数,那么编译器会自动产生一个默认的拷贝构造函数。\n这个默认的参数可能为 X::X(const X\u0026)或 X::X(X\u0026),由编译器根据上下文决定选择哪一个。\n  什么情况下必须定义拷贝构造函数？\n当类的对象用于函数值传递时（值参数，返回类对象），拷贝构造函数会被调用。如果对象复制并非简单的值拷贝，那就必须定义拷贝构造函数。例如大的堆栈数据拷贝。如果定义了拷贝构造函数，那也必须重载赋值操作符。\n  八、拷贝构造函数和赋值运算符 在默认情况下（用户没有定义，但是也没有显式的删除），编译器会自动的隐式生成一个拷贝构造函数和赋值运算符。但用户可以使用delete来指定不生成拷贝构造函数和赋值运算符，这样的对象就不能通过值传递，也不能进行赋值运算。\n1 2 3 4 5 6 7 8 9 10 11  class Person { public: Person(const Person\u0026 p) = delete; Person\u0026 operator=(const Person\u0026 p) = delete; private: int age; string name; };   上面的定义的类Person显式的删除了拷贝构造函数和赋值运算符，在需要调用拷贝构造函数或者赋值运算符的地方，会提示无法调用该函数，它是已删除的函数。\n还有一点需要注意的是，拷贝构造函数必须以引用的方式传递参数。这是因为，在值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。\n九、调用时机 拷贝构造函数和赋值运算符的行为比较相似，都是将一个对象的值复制给另一个对象；但是其结果却有些不同，拷贝构造函数使用传入对象的值生成一个新的对象的实例，而赋值运算符是将对象的值复制给一个已经存在的实例。\n这种区别从两者的名字也可以很轻易的分辨出来，拷贝构造函数也是一种构造函数，那么它的功能就是创建一个新的对象实例；赋值运算符是执行某种运算，将一个对象的值复制给另一个对象（已经存在的）。\n调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生。如果产生了新的对象实例，那调用的就是拷贝构造函数；如果没有，那就是对已有的对象赋值，调用的是赋值运算符。\n调用拷贝构造函数主要有以下场景：\n  对象作为函数的参数，以值传递的方式传给函数。   对象作为函数的返回值，以值的方式从函数返回。\n  使用一个对象给另一个对象初始化。\n  代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  #includeusing namespace std; class Person { public: Person() { cout \"Default Constructor\"endl; } Person(const Person\u0026 p) { cout  \"Copy Constructor\"  endl; } Person\u0026 operator=(const Person\u0026 p) { cout  \"Assign Operator\"  endl; return *this; } private: int age; string name; }; void f(Person p) { return; } Person f1() { Person p; return p; } int main() { Person p; coutendl\"test 1\"endl; Person p1 = p; // 1 coutendl\"test 2\"endl; Person p2; p2 = p; // 2 coutendl\"test 3\"endl; f(p2); // 3 coutendl\"test 4\"endl; p2 = f1(); // 4 coutendl\"test 5\"endl; Person p3 = f1(); // 5 return 0; }   上面代码中定义了一个类Person，显式的定义了拷贝构造函数和赋值运算符。\n然后定义了两个函数:f，以值的方式参传入Person对象；f1，以值的方式返回Person对象。\n在main中模拟了5个场景，测试调用的是拷贝构造函数还是赋值运算符。执行结果如下：\n分析如下：\n  这是虽然使用了”=”，但是实际上使用对象p来创建一个新的对象p1。也就是产生了新的对象，所以调用的是拷贝构造函数。\n  首先声明一个对象p2，然后使用赋值运算符”=”，将p的值复制给p2，显然是调用赋值运算符，为一个已经存在的对象赋值 。\n  以值传递的方式将对象p2传入函数f内，调用拷贝构造函数构建一个函数f可用的临时变量。\n  函数f1以值的方式返回一个Person对象，在返回时会调用拷贝构造函数创建一个临时变量作为返回值，返回后调用赋值运算符将临时对象tmp赋值给p2.本应该是这样，但其实函数返回对象的时候到底是否创建临时变量，因编译器而异。在笔者编译环境下，不需要创建临时变量，直接返回函数中的相应对象。\n  由test4可知，在函数中调用默认构造函数，然后直接将该对象返回，而且p3使用返回值创建新的对象也不需要使用拷贝构造函数。\n  注意：函数返回是否创建临时变量，需要参考返回值优化。\n",
  "wordCount" : "6327",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-24T11:00:59Z",
  "dateModified": "2017-06-24T11:00:59Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      拷贝构造函数详解
    </h1>
    <div class="post-meta">June 24, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="什么是拷贝构造函数">什么是拷贝构造函数<a hidden class="anchor" aria-hidden="true" href="#什么是拷贝构造函数">#</a></h1>
<p>首先对于普通类型的对象来说，它们之间的复制是很简单的，例如：</p>
<p>int a = 100;
int b = a;
而类对象与普通对象不同，类对象内部结构一般较为复杂，存在各种成员变量。</p>
<p>下面看一个类对象拷贝的简单例子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">class</span> <span class="n">CExample</span> <span class="p">{</span>
<span class="nl">private</span><span class="p">:</span>
    　<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="nl">public</span><span class="p">:</span>
      <span class="c1">//构造函数
</span><span class="c1"></span>    　<span class="n">CExample</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
    　<span class="p">{</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;}</span>

      <span class="c1">//一般函数
</span><span class="c1"></span>    　<span class="kt">void</span> <span class="n">Show</span> <span class="p">()</span>
    　<span class="p">{</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    　<span class="n">CExample</span> <span class="n">A</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    　<span class="n">CExample</span> <span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="p">;</span> <span class="c1">//注意这里的对象初始化要调用拷贝构造函数，而非赋值
</span><span class="c1"></span>    　 <span class="n">B</span><span class="p">.</span><span class="n">Show</span> <span class="p">();</span>
    　<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行程序，屏幕输出100。从以上代码的运行结果可以看出，系统为对象 B 分配了内存并完成了与对象 A 的复制过程。就类对象而言，相同类型的类对象是通过拷贝构造函数来完成整个复制过程的。</p>
<p>下面举例说明拷贝构造函数的工作过程。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">class</span> <span class="n">CExample</span> <span class="p">{</span>
<span class="nl">private</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="c1">//构造函数
</span><span class="c1"></span>    <span class="n">CExample</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;}</span>

    <span class="c1">//拷贝构造函数
</span><span class="c1"></span>    <span class="n">CExample</span><span class="p">(</span><span class="k">const</span> <span class="n">CExample</span><span class="o">&amp;</span> <span class="n">C</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//一般函数
</span><span class="c1"></span>    <span class="kt">void</span> <span class="n">Show</span> <span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">CExample</span> <span class="n">A</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="n">CExample</span> <span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="p">;</span> <span class="c1">// CExample B(A); 也是一样的
</span><span class="c1"></span>     <span class="n">B</span><span class="p">.</span><span class="n">Show</span> <span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>CExample(const CExample&amp; C)　就是我们自定义的拷贝构造函数。可见，拷贝构造函数是一种特殊的构造函数，函数的名称必须和类名称一致，它必须的一个参数是本类型的一个引用变量。</p>
<h1 id="拷贝构造函数的调用时机">拷贝构造函数的调用时机<a hidden class="anchor" aria-hidden="true" href="#拷贝构造函数的调用时机">#</a></h1>
<p>在C++中，下面三种对象需要调用拷贝构造函数！</p>
<h3 id="对象以值传递的方式传入函数参数">对象以值传递的方式传入函数参数<a hidden class="anchor" aria-hidden="true" href="#对象以值传递的方式传入函数参数">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">CExample</span>
<span class="p">{</span>
<span class="nl">private</span><span class="p">:</span>
 <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>

<span class="nl">public</span><span class="p">:</span>
 <span class="c1">//构造函数
</span><span class="c1"></span> <span class="n">CExample</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;creat: &#34;</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
 <span class="p">}</span>

 <span class="c1">//拷贝构造
</span><span class="c1"></span> <span class="n">CExample</span><span class="p">(</span><span class="k">const</span> <span class="n">CExample</span><span class="o">&amp;</span> <span class="n">C</span><span class="p">)</span>
 <span class="p">{</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;copy&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
 <span class="p">}</span>

 <span class="c1">//析构函数
</span><span class="c1"></span> <span class="o">~</span><span class="n">CExample</span><span class="p">()</span>
 <span class="p">{</span>
  <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="s">&#34;delete: &#34;</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
 <span class="p">}</span>

     <span class="kt">void</span> <span class="n">Show</span> <span class="p">()</span>
 <span class="p">{</span>
         <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
     <span class="p">}</span>
<span class="p">};</span>

<span class="c1">//全局函数，传入的是对象
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">g_Fun</span><span class="p">(</span><span class="n">CExample</span> <span class="n">C</span><span class="p">)</span>
<span class="p">{</span>
 <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;test&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
 <span class="n">CExample</span> <span class="n">test</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="c1">//传入对象
</span><span class="c1"></span> <span class="n">g_Fun</span><span class="p">(</span><span class="n">test</span><span class="p">);</span>

 <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>调用g_Fun()时，会产生以下几个重要步骤：</p>
<ol>
<li>
<p>test对象传入形参时，会先会产生一个临时变量，就叫 C 吧。</p>
</li>
<li>
<p>然后调用拷贝构造函数把test的值给C。 整个这两个步骤有点像：CExample C(test);</p>
</li>
<li>
<p>等g_Fun()执行完后, 析构掉 C 对象。</p>
</li>
</ol>
<h3 id="对象以值传递的方式从函数返回">对象以值传递的方式从函数返回<a hidden class="anchor" aria-hidden="true" href="#对象以值传递的方式从函数返回">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">CExample</span>
<span class="p">{</span>
<span class="nl">private</span><span class="p">:</span>
 <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>

<span class="nl">public</span><span class="p">:</span>
 <span class="c1">//构造函数
</span><span class="c1"></span> <span class="n">CExample</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
 <span class="p">{</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
 <span class="p">}</span>

 <span class="c1">//拷贝构造
</span><span class="c1"></span> <span class="n">CExample</span><span class="p">(</span><span class="k">const</span> <span class="n">CExample</span><span class="o">&amp;</span> <span class="n">C</span><span class="p">)</span>
 <span class="p">{</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;copy&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
 <span class="p">}</span>

     <span class="kt">void</span> <span class="n">Show</span> <span class="p">()</span>
     <span class="p">{</span>
        	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    	<span class="p">}</span>
<span class="p">};</span>

<span class="c1">//全局函数
</span><span class="c1"></span><span class="n">CExample</span> <span class="nf">g_Fun</span><span class="p">()</span>
<span class="p">{</span>
 <span class="n">CExample</span> <span class="n">temp</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
 <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
 <span class="n">g_Fun</span><span class="p">();</span>
 <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当g_Fun()函数执行到return时，会产生以下几个重要步骤：</p>
<ol>
<li>
<p>先会产生一个临时变量，就叫XXXX吧。</p>
</li>
<li>
<p>然后调用拷贝构造函数把temp的值给XXXX。整个这两个步骤有点像：CExample XXXX(temp);</p>
</li>
<li>
<p>在函数执行到最后先析构temp局部变量。
等g_Fun()执行完后再析构掉XXXX对象。</p>
</li>
<li>
<p>对象需要通过另外一个对象进行初始化；</p>
</li>
</ol>
<h3 id="对象需要通过另外一个对象进行初始化">对象需要通过另外一个对象进行初始化<a hidden class="anchor" aria-hidden="true" href="#对象需要通过另外一个对象进行初始化">#</a></h3>
<pre><code>CExample A(100);
CExample B = A;
// CExample B(A);
</code></pre>
<p>后两句都会调用拷贝构造函数。</p>
<h1 id="默认拷贝构造函数">默认拷贝构造函数<a hidden class="anchor" aria-hidden="true" href="#默认拷贝构造函数">#</a></h1>
<p>很多时候在我们都不知道拷贝构造函数的情况下，传递对象给函数参数或者函数返回对象都能很好的进行，这是因为编译器会给我们自动产生一个拷贝构造函数，这就是“默认拷贝构造函数”.</p>
<p>这个构造函数很简单，仅仅使用“老对象”的数据成员的值对“新对象”的数据成员一一进行赋值，它一般具有以下形式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">Rect</span><span class="o">::</span><span class="n">Rect</span><span class="p">(</span><span class="k">const</span> <span class="n">Rect</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">width</span><span class="o">=</span><span class="n">r</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
    <span class="n">height</span><span class="o">=</span><span class="n">r</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>以上代码不用我们编写，编译器会为我们自动生成。但是如果认为这样就可以解决对象的复制问题，那就错了，让我们来考虑以下一段代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="n">class</span> <span class="n">Rect</span>
<span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="n">Rect</span><span class="p">()</span>
    <span class="p">{</span>
         <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
        <span class="o">~</span><span class="n">Rect</span><span class="p">()</span>
    <span class="p">{</span>
         <span class="n">count</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">getCount</span><span class="p">()</span>
    <span class="p">{</span>
         <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">private</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">Rect</span><span class="o">::</span><span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Rect</span> <span class="n">rect1</span><span class="p">;</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;The count of Rect:&#34;</span><span class="o">&lt;&lt;</span><span class="n">Rect</span><span class="o">::</span><span class="n">getCount</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">Rect</span> <span class="n">rect2</span><span class="p">(</span><span class="n">rect1</span><span class="p">);</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;The count of Rect:&#34;</span><span class="o">&lt;&lt;</span><span class="n">Rect</span><span class="o">::</span><span class="n">getCount</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这段代码对前面的类，加入了一个静态成员，目的是进行计数。</p>
<p>在主函数中，首先创建对象rect1，输出此时的对象个数，然后使用rect1复制出对象rect2，再输出此时的对象个数，按照理解，此时应该有两个对象存在，但实际程序运行时，输出的都是1，反应出只有1个对象。此外，在销毁对象时，由于会调用销毁两个对象，类的析构函数会调用两次，此时的计数器将变为负数。</p>
<p>说白了，就是<strong>拷贝构造函数无法创建新的静态数据成员。</strong></p>
<p>出现这些问题最根本就在于在复制对象时，计数器没有递增，我们重新编写拷贝构造函数，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="n">class</span> <span class="n">Rect</span>
<span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="n">Rect</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Rect</span><span class="p">(</span><span class="k">const</span> <span class="n">Rect</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">width</span><span class="o">=</span><span class="n">r</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
        <span class="n">height</span><span class="o">=</span><span class="n">r</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">Rect</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">count</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">getCount</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">private</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">Rect</span><span class="o">::</span><span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Rect</span> <span class="n">rect1</span><span class="p">;</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;The count of Rect:&#34;</span><span class="o">&lt;&lt;</span><span class="n">Rect</span><span class="o">::</span><span class="n">getCount</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">Rect</span> <span class="n">rect2</span><span class="p">(</span><span class="n">rect1</span><span class="p">);</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;The count of Rect:&#34;</span><span class="o">&lt;&lt;</span><span class="n">Rect</span><span class="o">::</span><span class="n">getCount</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="浅拷贝和深拷贝的区别">浅拷贝和深拷贝的区别<a hidden class="anchor" aria-hidden="true" href="#浅拷贝和深拷贝的区别">#</a></h1>
<h2 id="浅拷贝">浅拷贝<a hidden class="anchor" aria-hidden="true" href="#浅拷贝">#</a></h2>
<p>所谓浅拷贝，指的是在对象复制时，只对对象中的数据成员进行简单的赋值，默认拷贝构造函数执行的也是浅拷贝。大多情况下“浅拷贝”已经能很好地工作了，但是一旦对象存在了动态成员，那么浅拷贝就会出问题了，让我们考虑如下一段代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="n">class</span> <span class="n">Rect</span>
<span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="n">Rect</span><span class="p">()</span>
    <span class="p">{</span>
         <span class="n">p</span><span class="o">=</span><span class="n">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">Rect</span><span class="p">()</span>
    <span class="p">{</span>
         <span class="n">assert</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="n">delete</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Rect</span> <span class="n">rect1</span><span class="p">;</span>
    <span class="n">Rect</span> <span class="n">rect2</span><span class="p">(</span><span class="n">rect1</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这段代码运行结束之前，会出现一个运行错误。原因就在于在进行对象复制时，对于动态分配的内容没有进行正确的操作。我们来分析一下：</p>
<p>在运行定义rect1对象后，由于在构造函数中有一个动态分配的语句，因此执行后的内存情况大致如下：</p>
<p>在使用rect1复制rect2时，由于执行的是浅拷贝，只是将成员的值进行赋值，这时 rect1.p = rect2.p，也即这两个指针指向了堆里的同一个空间，如下图所示：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/28977986_1383651936Y2Or.jpg" alt=""  />
</p>
<p>当然，这不是我们所期望的结果，在销毁对象时，两个对象的析构函数将对同一个内存空间释放两次，这就是错误出现的原因。我们需要的不是两个p有相同的值，而是两个p指向的空间有相同的值，解决办法就是使用“深拷贝”。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/28977986_1383652169K2dL.jpg" alt=""  />
</p>
<h2 id="深拷贝">深拷贝<a hidden class="anchor" aria-hidden="true" href="#深拷贝">#</a></h2>
<p>当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。所以，这时，必须采用深拷贝。</p>
<p>在“深拷贝”的情况下，对于对象中动态成员，就不能仅仅简单地赋值了，而应该重新动态分配空间，如上面的例子就应该按照如下的方式进行处理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="n">class</span> <span class="n">Rect</span>
<span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="n">Rect</span><span class="p">()</span>
    <span class="p">{</span>
         <span class="n">p</span><span class="o">=</span><span class="n">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Rect</span><span class="p">(</span><span class="k">const</span> <span class="n">Rect</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span>
    <span class="p">{</span>
         <span class="n">width</span><span class="o">=</span><span class="n">r</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
        <span class="n">height</span><span class="o">=</span><span class="n">r</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
         <span class="n">p</span><span class="o">=</span><span class="n">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
        <span class="o">*</span><span class="n">p</span><span class="o">=*</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">Rect</span><span class="p">()</span>
    <span class="p">{</span>
         <span class="n">assert</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="n">delete</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Rect</span> <span class="n">rect1</span><span class="p">;</span>
    <span class="n">Rect</span> <span class="n">rect2</span><span class="p">(</span><span class="n">rect1</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>此时，在完成对象的复制后，内存的一个大致情况如下：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/28977986_1383652169K2dL.jpg" alt=""  />
</p>
<p>此时rect1的p和rect2的p各自指向一段内存空间，但它们指向的空间具有相同的内容，这就是所谓的“深拷贝”。</p>
<h1 id="默认拷贝构造函数的合成时机">默认拷贝构造函数的合成时机<a hidden class="anchor" aria-hidden="true" href="#默认拷贝构造函数的合成时机">#</a></h1>
<p>编译器并不会在所有类中都生成默认拷贝构造函数.决定一个拷贝构造函数是否被生成的标准在于类是否需要&quot;按位拷贝&quot;.</p>
<p>在以下4种情况不需要合成默认拷贝构造函数,而是由编译器另外合成新的拷贝构造函数:</p>
<ol>
<li>当class内含一个成员对象而后者的类声明中有一个拷贝构造函数.</li>
<li>当class继承自一个基类而后者存在一个拷贝构造函数时(不论是被显式声明还是被合成而得).</li>
<li>当class声明一个或多个虚函数时.</li>
<li>当class派生自一个继承串链,其中有一个或多个虚基类时.</li>
</ol>
<p>对于前两种情况,编译器必须将成员对象或基类的拷贝构造函数调用操作安插到合成的拷贝构造函数中.</p>
<p>情况3因为拷贝过程中会出现类的&quot;切割&quot;情况:基类拷贝派生类.此时两者的vptr指向的地址不同.需要在拷贝构造函数中显式设定实例化类对象的vptr.</p>
<p>情况4由于在执行期前不知道正确的基类,无法判断是否符合&quot;按位拷贝&quot;.</p>
<h1 id="为什么拷贝构造函数的形参一般是const引用类型">为什么拷贝构造函数的形参一般是const引用类型？<a hidden class="anchor" aria-hidden="true" href="#为什么拷贝构造函数的形参一般是const引用类型">#</a></h1>
<pre><code>Sample (Sample a);
</code></pre>
<p>不幸的是,即使是这样朴实无华的声明也隐含了一个微妙的错误,呵,我们来看看：当某个时候需要以一个Sample对象的值来为一个新对象进行初始化时,编译器会在各个重载的构造函数版本(如果有多个的话)搜寻,它找到的这个版本,发现声明参数与传入的对象一致,因此该构造函数将会被调用。目前为止,一切都在我们的意料之中,但问题很快来了：该函数的参数我们使用了值传递的方式,按照前面的分析,这需要调用复制构造函数,于是编译器又再度搜寻,最后当然又找到了它,于是进行调用,但同样地,传参时又要进行复制,于是再调用…这个过程周而复始,每次都是到了函数入口处就进行递归,直到堆栈空间耗尽,程序崩溃…</p>
<p>由是观之,值传递看来是行不通的了;我想C语言的用户这时很快会反应到与值传递对应的方式：地址传递(传址),于是声明变为这样：</p>
<pre><code>Sample (Sample *p);
</code></pre>
<p>只作为一般的构造函数,它应该可以运行得很好,但别忘了我们要提供的是复制构造函数,它要求能够接受一个同类型对象,像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">Sample</span> <span class="n">a</span><span class="p">;</span>
<span class="n">Sample</span> <span class="nf">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>而不是接受指针：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Sample a;
Sample b(&amp;a);   // 还要取地址?当然,它可以正确运行,但...
</code></pre></td></tr></table>
</div>
</div><p>虽然在初始化对象时可以像上面一样人为加一个取址符,但在函数参数表中(或者函数返回)进行值传递时,编译器可不知道在找不着合适定义的情况下牵就选择你的指针版本。</p>
<p>如果一个类中只存在一个参数为X&amp;的拷贝构造函数,那么就不能使用const X或volatile X的对象实行拷贝初始化.而如果定义了一个拷贝构造函数，那么编译器就不会再自动默认拷贝构造函数。</p>
<p>因此若想让定义的拷贝构造函数能够支持const和普通类型的参数，需要使用const形参。</p>
<h1 id="六防止默认拷贝发生">六、防止默认拷贝发生<a hidden class="anchor" aria-hidden="true" href="#六防止默认拷贝发生">#</a></h1>
<p>通过对对象复制的分析，我们发现对象的复制大多在进行“值传递”时发生，这里有一个小技巧可以防止按值传递——声明一个私有拷贝构造函数。甚至不必去定义这个拷贝构造函数，这样因为拷贝构造函数是私有的，如果用户试图按值传递或函数返回该类对象，将得到一个编译错误，从而可以避免按值传递或返回对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//防止按值传递
</span><span class="c1"></span><span class="n">class</span> <span class="n">CExample</span>
<span class="p">{</span>
<span class="nl">private</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="c1">//构造函数
</span><span class="c1"></span>    <span class="n">CExample</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;creat: &#34;</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">private</span><span class="p">:</span>
<span class="c1">//拷贝构造函数，只是声明
</span><span class="c1"></span><span class="n">CExample</span><span class="p">(</span><span class="k">const</span> <span class="n">CExample</span><span class="o">&amp;</span> <span class="n">C</span><span class="p">);</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="o">~</span><span class="n">CExample</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="s">&#34;delete: &#34;</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Show</span> <span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">g_Fun</span><span class="p">(</span><span class="n">CExample</span> <span class="n">C</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;test&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">CExample</span> <span class="n">test</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">//g_Fun(test);   //无法在函数内生成临时变量，拷贝函数出错
</span><span class="c1"></span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="七拷贝构造函数的细节">七、拷贝构造函数的细节<a hidden class="anchor" aria-hidden="true" href="#七拷贝构造函数的细节">#</a></h1>
<ol>
<li>
<p>拷贝构造函数的作用</p>
<p>作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例。</p>
</li>
<li>
<p>参数传递过程到底发生了什么？</p>
<p>将地址传递和值传递统一起来，归根结底还是传递的是”值”(地址也是值，只不过通过它可以找到另一个值)</p>
<ol>
<li>
<p>值传递:</p>
<p>对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)；</p>
<p>对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)；如void foo(class_type obj_local){}, 如果调用foo(obj); 首先class_type obj_local(obj) ,这样就定义了局部变量obj_local供函数内部使用</p>
</li>
<li>
<p>引用传递:</p>
<p>无论对内置类型还是类类型，传递引用或指针最终都是传递的地址值！而地址总是指针类型(属于简单类型), 显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用(对于类类型).</p>
</li>
<li>
<p>在类中有指针数据成员时，拷贝构造函数的使用？</p>
</li>
</ol>
<p>因为默认的拷贝构造函数是按成员拷贝构造，这导致了两个不同的指针(如ptr1=ptr2)指向了相同的内存。当一个实例销毁时，调用析构函数 free(ptr1)释放了这段内存，那么剩下的一个实例的指针ptr2就无效了，在被销毁的时候free(ptr2)就会出现错误了, 这相当于重复释放一块内存两次。这种情况必须显式声明并实现自己的拷贝构造函数，来为新的实例的指针分配新的内存。</p>
</li>
<li>
<p>以下函数哪个是拷贝构造函数,为什么?</p>
<pre><code> X::X(const X&amp;);   //拷贝构造函数
 X::X(X);
 X::X(X&amp;, int a=1);   //拷贝构造函数
 X::X(X&amp;, int a=1, int b=2);  //拷贝构造函数
</code></pre>
<p>解答：</p>
<p>对于一个类X, 如果一个构造函数的第一个参数是下列之一:</p>
<pre><code> a) X&amp;
 b) const X&amp;
 c) volatile X&amp;
 d) const volatile X&amp;
</code></pre>
<p>且没有其他参数或其他参数都有默认值,那么这个函数是拷贝构造函数.</p>
</li>
<li>
<p>一个类中可以存在多于一个的拷贝构造函数吗?</p>
<p>解答：</p>
<p>类中可以存在超过一个拷贝构造函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">X</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
  <span class="n">X</span><span class="p">(</span><span class="k">const</span> <span class="n">X</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// const 的拷贝构造
</span><span class="c1"></span> <span class="n">X</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// 非const的拷贝构造
</span><span class="c1"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>``</p>
<p>注意,如果一个类中只存在一个参数为 X&amp; 的拷贝构造函数,那么就不能使用const X或volatile X的对象实行拷贝初始化.</p>
<p>如果一个类中没有定义拷贝构造函数,那么编译器会自动产生一个默认的拷贝构造函数。</p>
<p>这个默认的参数可能为 X::X(const X&amp;)或 X::X(X&amp;),由编译器根据上下文决定选择哪一个。</p>
</li>
<li>
<p>什么情况下必须定义拷贝构造函数？</p>
<p>当类的对象用于函数值传递时（值参数，返回类对象），拷贝构造函数会被调用。如果对象复制并非简单的值拷贝，那就必须定义拷贝构造函数。例如大的堆栈数据拷贝。如果定义了拷贝构造函数，那也必须重载赋值操作符。</p>
</li>
</ol>
<h1 id="八拷贝构造函数和赋值运算符">八、拷贝构造函数和赋值运算符<a hidden class="anchor" aria-hidden="true" href="#八拷贝构造函数和赋值运算符">#</a></h1>
<p>在默认情况下（用户没有定义，但是也没有显式的删除），编译器会自动的隐式生成一个拷贝构造函数和赋值运算符。但用户可以使用delete来指定不生成拷贝构造函数和赋值运算符，这样的对象就不能通过值传递，也不能进行赋值运算。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Person</span>
<span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>

<span class="n">Person</span><span class="p">(</span><span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="n">delete</span><span class="p">;</span>
<span class="n">Person</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="n">delete</span><span class="p">;</span>
<span class="nl">private</span><span class="p">:</span>

<span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
<span class="n">string</span> <span class="n">name</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的定义的类Person显式的删除了拷贝构造函数和赋值运算符，在需要调用拷贝构造函数或者赋值运算符的地方，会提示无法调用该函数，它是已删除的函数。</p>
<p>还有一点需要注意的是，拷贝构造函数必须以引用的方式传递参数。这是因为，在值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170831-131457@2x.png34" alt=""  />
</p>
<h2 id="九调用时机">九、调用时机<a hidden class="anchor" aria-hidden="true" href="#九调用时机">#</a></h2>
<p>拷贝构造函数和赋值运算符的行为比较相似，都是将一个对象的值复制给另一个对象；但是其结果却有些不同，拷贝构造函数使用传入对象的值生成一个新的对象的实例，而赋值运算符是将对象的值复制给一个已经存在的实例。</p>
<p>这种区别从两者的名字也可以很轻易的分辨出来，拷贝构造函数也是一种构造函数，那么它的功能就是创建一个新的对象实例；赋值运算符是执行某种运算，将一个对象的值复制给另一个对象（已经存在的）。</p>
<p>调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生。如果产生了新的对象实例，那调用的就是拷贝构造函数；如果没有，那就是对已有的对象赋值，调用的是赋值运算符。</p>
<p>调用拷贝构造函数主要有以下场景：</p>
<ol>
<li>
<p>对象作为函数的参数，以值传递的方式传给函数。 　</p>
</li>
<li>
<p>对象作为函数的返回值，以值的方式从函数返回。</p>
</li>
<li>
<p>使用一个对象给另一个对象初始化。</p>
</li>
</ol>
<p>代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="n">class</span> <span class="n">Person</span>
<span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="n">Person</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="s">&#34;Default Constructor&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Person</span><span class="p">(</span><span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Copy Constructor&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Person</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Assign Operator&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">Person</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Person</span> <span class="nf">f1</span><span class="p">()</span>
<span class="p">{</span>
<span class="n">Person</span> <span class="n">p</span><span class="p">;</span>
<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>

<span class="n">Person</span> <span class="n">p</span><span class="p">;</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="o">&lt;&lt;</span><span class="s">&#34;test 1&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="n">Person</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>    <span class="c1">// 1
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="o">&lt;&lt;</span><span class="s">&#34;test 2&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="n">Person</span> <span class="n">p2</span><span class="p">;</span>
<span class="n">p2</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>           <span class="c1">// 2
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="o">&lt;&lt;</span><span class="s">&#34;test 3&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>            <span class="c1">// 3
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="o">&lt;&lt;</span><span class="s">&#34;test 4&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="n">p2</span> <span class="o">=</span> <span class="n">f1</span><span class="p">();</span>        <span class="c1">// 4
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="o">&lt;&lt;</span><span class="s">&#34;test 5&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="n">Person</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">f1</span><span class="p">();</span> <span class="c1">// 5
</span><span class="c1"></span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面代码中定义了一个类Person，显式的定义了拷贝构造函数和赋值运算符。</p>
<p>然后定义了两个函数:f，以值的方式参传入Person对象；f1，以值的方式返回Person对象。</p>
<p>在main中模拟了5个场景，测试调用的是拷贝构造函数还是赋值运算符。执行结果如下：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/XNOK%7B5J%25%7DMR6MM3Z%288H2D%5D1.png" alt=""  />
</p>
<p>分析如下：</p>
<ol>
<li>
<p>这是虽然使用了”=”，但是实际上使用对象p来创建一个新的对象p1。也就是产生了新的对象，所以调用的是拷贝构造函数。</p>
</li>
<li>
<p>首先声明一个对象p2，然后使用赋值运算符”=”，将p的值复制给p2，显然是调用赋值运算符，为一个已经存在的对象赋值 。</p>
</li>
<li>
<p>以值传递的方式将对象p2传入函数f内，调用拷贝构造函数构建一个函数f可用的临时变量。</p>
</li>
<li>
<p>函数f1以值的方式返回一个Person对象，在返回时会调用拷贝构造函数创建一个临时变量作为返回值，返回后调用赋值运算符将临时对象tmp赋值给p2.本应该是这样，但其实函数返回对象的时候到底是否创建临时变量，因编译器而异。在笔者编译环境下，不需要创建临时变量，直接返回函数中的相应对象。</p>
</li>
<li>
<p>由test4可知，在函数中调用默认构造函数，然后直接将该对象返回，而且p3使用返回值创建新的对象也不需要使用拷贝构造函数。</p>
</li>
</ol>
<p>注意：函数返回是否创建临时变量，需要参考返回值优化。</p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
