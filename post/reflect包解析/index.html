<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>reflect包解析 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="func Copy 1 func Copy(dst, src Value) int Copy将src的内容复制到dst，直到dst已填满或src已用完为止。它返回复制的元素数。Dst和src必须具有类型的Sl" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.96.0 with theme even" />


<link rel="canonical" href="/post/reflect%E5%8C%85%E8%A7%A3%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="reflect包解析" />
<meta property="og:description" content="func Copy 1 func Copy(dst, src Value) int Copy将src的内容复制到dst，直到dst已填满或src已用完为止。它返回复制的元素数。Dst和src必须具有类型的Sl" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/reflect%E5%8C%85%E8%A7%A3%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-07-21T21:41:17+00:00" />
<meta property="article:modified_time" content="2019-07-21T21:41:17+00:00" />

<meta itemprop="name" content="reflect包解析">
<meta itemprop="description" content="func Copy 1 func Copy(dst, src Value) int Copy将src的内容复制到dst，直到dst已填满或src已用完为止。它返回复制的元素数。Dst和src必须具有类型的Sl"><meta itemprop="datePublished" content="2019-07-21T21:41:17+00:00" />
<meta itemprop="dateModified" content="2019-07-21T21:41:17+00:00" />
<meta itemprop="wordCount" content="9094">
<meta itemprop="keywords" content="Go标准库," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="reflect包解析"/>
<meta name="twitter:description" content="func Copy 1 func Copy(dst, src Value) int Copy将src的内容复制到dst，直到dst已填满或src已用完为止。它返回复制的元素数。Dst和src必须具有类型的Sl"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">reflect包解析</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-07-21 </span>
        <div class="post-category">
            <a href="/categories/go%E6%A0%87%E5%87%86%E5%BA%93/"> Go标准库 </a>
            </div>
          <span class="more-meta"> 约 9094 字 </span>
          <span class="more-meta"> 预计阅读 19 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#func-chandir-string">func (ChanDir) String</a></li>
  </ul>

  <ul>
    <li><a href="#func-kind-string">func (Kind) String</a></li>
  </ul>

  <ul>
    <li><a href="#func-mapiter-key-112">func (*MapIter) Key 1.12</a></li>
    <li><a href="#func-mapiter-next-112">func (*MapIter) Next 1.12</a></li>
    <li><a href="#func-mapiter-value-112">func (*MapIter) Value 1.12</a></li>
  </ul>

  <ul>
    <li><a href="#func-structtag-get">func (StructTag) Get</a></li>
    <li><a href="#func-structtag-lookup-17">func (StructTag) Lookup 1.7</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="func-copy">func Copy</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Copy</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span> <span class="nx">Value</span><span class="p">)</span> <span class="kt">int</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Copy将src的内容复制到dst，直到dst已填满或src已用完为止。它返回复制的元素数。Dst和src必须具有类型的Slice或Array，并且dst和src必须具有相同的元素类型。</p>
<p>作为特例，如果dst的元素类型为Uint8，则src可以具有类型String。</p>
<h1 id="func-deepequal">func DeepEqual</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>DeepEqual报告x和y是否“非常相等”，定义如下。如果以下情况之一适用，则相同类型的两个值非常相等。不同类型的值永远不会相等。</p>
<p>当相应的元素非常相等时，数组值非常相等。</p>
<p>两个结构体,如果导出和未导出的相应字段非常相等，则结构值非常相等。</p>
<p>如果两个Func函数的value都是nil,则Func值非常相等; 否则他们就不是很平等。</p>
<p>如果它们具有非常相同的具体value，则接口值非常相等。</p>
<p>Map values are deeply equal when all of the following are true: they are both nil or both non-nil, they have the same length, and either they are the same map object or their corresponding keys (matched using Go equality) map to deeply equal values.</p>
<p>当满足以下所有条件时，map值非常相等：它们都是nil或两者都是非nil，它们具有相同的长度，并且它们是相同的map对象或它们对应的key（使用Go相等匹配)非常相等。</p>
<p>两个指针如果使用Go的==运算符相等，或者它们指向的值非常相等，则指针值非常相等。</p>
<p>当满足以下所有条件时，切片值非常相等：它们都是nil或两者都是非nil，它们具有相同的长度，并且它们指向相同底层数组的相同初始条目（即＆x [0 ] ==＆y [0]）或它们对应的元素（长度）非常相等。注意，非零空切片和nil切片（例如，[] byte {}和[] byte（nil））不是非常相等。</p>
<p>其他值如数字，bool，字符串和通道,如果使用Go的==运算符相等则非常相等。</p>
<p>In general DeepEqual is a recursive relaxation of Go&rsquo;s == operator. However, this idea is impossible to implement without some inconsistency. Specifically, it is possible for a value to be unequal to itself, either because it is of func type (uncomparable in general) or because it is a floating-point NaN value (not equal to itself in floating-point comparison), or because it is an array, struct, or interface containing such a value. On the other hand, pointer values are always equal to themselves, even if they point at or contain such problematic values, because they compare equal using Go&rsquo;s == operator, and that is a sufficient condition to be deeply equal, regardless of content. DeepEqual has been defined so that the same short-cut applies to slices and maps: if x and y are the same slice or the same map, they are deeply equal regardless of content.</p>
<p>一般来说，DeepEqual是Go的==运算符的递归松弛。但是，如果没有一些不一致的话，这个想法就无法实现。具体来说，一个值可能与自身不相等，要么是因为它是func类型（通常是不可比的），要么是因为它是一个浮点NaN值（在浮点比较中不等于它自己），或者因为它是包含这样一个值的数组，结构或接口。另一方面，指针值总是等于它们自己，即使它们指向或包含这些有问题的值，因为它们使用Go的==运算符进行比较相等，这是一个完全相同的条件，无论content如何。已定义DeepEqual，以便相同的比较相等的方式适用于切片和map：如果x和y是相同的slice或map，那么它们非常相等</p>
<p>As DeepEqual traverses the data values it may find a cycle. The second and subsequent times that DeepEqual compares two pointer values that have been compared before, it treats the values as equal rather than examining the values to which they point. This ensures that DeepEqual terminates.</p>
<p>当DeepEqual遍历数据值时，它可能会找到一个循环。如果发现两个指针之前比较过,且比较的结果是相等，它将值视为相等而不是再次检查它们指向的值。这可确保DeepEqual终止。</p>
<h1 id="func-swapper-18">func Swapper 1.8</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Swapper</span><span class="p">(</span><span class="nx">slice</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Swapper返回一个函数，用于交换提供的切片中的元素。</p>
<p>如果提供的接口不是切片，则Swapper发生混乱。</p>
<h1 id="type-chandir">type ChanDir</h1>
<p>ChanDir表示通道类型的方向。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ChanDir</span> <span class="kt">int</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nx">RecvDir</span> <span class="nx">ChanDir</span>             <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span> <span class="c1">// &lt;-chan
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">SendDir</span>                                 <span class="c1">// chan&lt;-
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">BothDir</span> <span class="p">=</span> <span class="nx">RecvDir</span> <span class="p">|</span> <span class="nx">SendDir</span>             <span class="c1">// chan
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="func-chandir-string">func (ChanDir) String</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="nx">ChanDir</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="type-kind">type Kind</h1>
<p>Kind代表Type类型值表示的具体分类。零值表示非法分类。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Kind</span> <span class="kt">uint</span>
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Invalid</span> <span class="nx">Kind</span> <span class="p">=</span> <span class="kc">iota</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Bool</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Int</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Int8</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Int16</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Int32</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Int64</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Uint</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Uint8</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Uint16</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Uint32</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Uint64</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Uintptr</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Float32</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Float64</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Complex64</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Complex128</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Array</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Chan</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Func</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Interface</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Map</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Ptr</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Slice</span>
</span></span><span class="line"><span class="cl">        <span class="nx">String</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Struct</span>
</span></span><span class="line"><span class="cl">        <span class="nx">UnsafePointer</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;reflect&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="p">[]</span><span class="kd">interface</span><span class="p">{}{</span><span class="s">&#34;hi&#34;</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{}}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">switch</span> <span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Kind</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">String</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int8</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int16</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int32</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int64</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nf">Int</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;unhandled kind %s&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Kind</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="func-kind-string">func (Kind) String</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">k</span> <span class="nx">Kind</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>String返回k的名称。</p>
<h1 id="type-mapiter-112">type MapIter 1.12</h1>
<p>MapIter是用于在map上进行range的迭代器。请参见Value.MapRange。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MapIter</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// contains filtered or unexported fields
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="func-mapiter-key-112">func (*MapIter) Key 1.12</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">it</span> <span class="o">*</span><span class="nx">MapIter</span><span class="p">)</span> <span class="nf">Key</span><span class="p">()</span> <span class="nx">Value</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Key返回迭代器当前映射键值对的key。</p>
<h2 id="func-mapiter-next-112">func (*MapIter) Next 1.12</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">it</span> <span class="o">*</span><span class="nx">MapIter</span><span class="p">)</span> <span class="nf">Next</span><span class="p">()</span> <span class="kt">bool</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Next advances the map iterator and reports whether there is another entry. It returns false when the iterator is exhausted; subsequent calls to Key, Value, or Next will panic.</p>
<p>接下来推进MapIter并报告是否有另一个键值对。迭代器耗尽时返回false; 随后对Key，Value或Next的调用将会出现panic。</p>
<h2 id="func-mapiter-value-112">func (*MapIter) Value 1.12</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">it</span> <span class="o">*</span><span class="nx">MapIter</span><span class="p">)</span> <span class="nf">Value</span><span class="p">()</span> <span class="nx">Value</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Key返回迭代器当前映射键值对的value。</p>
<h1 id="type-method">type Method</h1>
<p>Method代表一个方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Method</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Name是方法名。PkgPath是非导出字段的包路径，对导出字段该字段为&#34;&#34;。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 结合PkgPath和Name可以从方法集中指定一个方法。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 参见http://golang.org/ref/spec#Uniqueness_of_identifiers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Name</span>    <span class="kt">string</span>
</span></span><span class="line"><span class="cl">    <span class="nx">PkgPath</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Type</span>  <span class="nx">Type</span>  <span class="c1">// 方法类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Func</span>  <span class="nx">Value</span> <span class="c1">// 方法的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Index</span> <span class="kt">int</span>   <span class="c1">// 用于Type.Method的索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="type-selectcase-11">type SelectCase 1.1</h1>
<p>SelectCase描述select操作中的单条case。Case的类型由通信方向Dir决定。</p>
<p>如果Dir是SelectDefault，该条case代表default case。Chan和Send字段必须是Value零值。</p>
<p>如果Dir是SelectSend，该条case代表一个发送操作。Chan字段底层必须是一个chan类型，Send的底层必须是可以直接赋值给该chan类型成员类型的类型。如果Chan是Value零值，则不管Send字段是不是零值，该条case都会被忽略。</p>
<p>如果Dir是SelectRecv，该条case代表一个接收操作。Chan字段底层必须是一个chan类型，而Send必须是一个Value零值。如果Chan是Value零值，该条case会被忽略，但Send字段仍需是Value零值。当该条case被执行时，接收到的值会被Select返回。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SelectCase</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Dir</span>  <span class="nx">SelectDir</span> <span class="c1">// case的方向
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Chan</span> <span class="nx">Value</span>     <span class="c1">// 使用的通道（收/发）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Send</span> <span class="nx">Value</span>     <span class="c1">// 用于发送的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="type-selectdir-11">type SelectDir 1.1</h1>
<p>SelectDir描述一个SelectCase的通信方向。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SelectDir</span> <span class="kt">int</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span><span class="err">（</span>
</span></span><span class="line"><span class="cl">         <span class="nx">SelectSend</span>     <span class="nx">SelectDir</span>  <span class="c1">// case Chan &lt; -  Send
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">SelectRecv</span>               <span class="c1">// case &lt;-Chan：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">SelectDefault</span>            <span class="c1">// default
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">）</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="type-sliceheader">type SliceHeader</h1>
<p>SliceHeader代表一个运行时的切片。它不保证使用的可移植性、安全性；它的实现在未来的版本里也可能会改变。而且，Data字段也不能保证它指向的数据不会被当成垃圾收集，因此程序必须维护一个独立的、类型正确的指向底层数据的指针。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SliceHeader</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Data</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Len</span>  <span class="kt">int</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Cap</span>  <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="type-stringheader">type StringHeader</h1>
<p>StringHeader代表一个运行时的字符串。它不保证使用的可移植性、安全性；它的实现在未来的版本里也可能会改变。而且，Data字段也不能保证它指向的数据不会被当成垃圾收集，因此程序必须维护一个独立的、类型正确的指向底层数据的指针。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">StringHeader</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Data</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Len</span>  <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="type-structfield">type StructField</h1>
<p>StructField类型描述结构体中的一个字段的信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">StructField</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为&#34;&#34;。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 参见http://golang.org/ref/spec#Uniqueness_of_identifiers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Name</span>    <span class="kt">string</span>
</span></span><span class="line"><span class="cl">    <span class="nx">PkgPath</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Type</span>      <span class="nx">Type</span>      <span class="c1">// 字段的类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Tag</span>       <span class="nx">StructTag</span> <span class="c1">// 字段的标签
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Offset</span>    <span class="kt">uintptr</span>   <span class="c1">// 字段在结构体中的字节偏移量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Index</span>     <span class="p">[]</span><span class="kt">int</span>     <span class="c1">// 用于Type.FieldByIndex时的索引切片
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Anonymous</span> <span class="kt">bool</span>      <span class="c1">// 是否匿名字段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="type-structtag">type StructTag</h1>
<p>StructTag是结构体字段的标签。</p>
<p>一般来说，标签字符串是（可选的）空格分隔的一连串 `key:&ldquo;value&rdquo;` 对。每个键都是不包含控制字符、空格、双引号、冒号的非空字符串。每个值都应被双引号括起来，使用go字符串字面语法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">StructTag</span> <span class="kt">string</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;reflect&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">type</span> <span class="nx">S</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">F</span> <span class="kt">string</span> <span class="s">`species:&#34;gopher&#34; color:&#34;blue&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">S</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">st</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">field</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Field</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">field</span><span class="p">.</span><span class="nx">Tag</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;color&#34;</span><span class="p">),</span> <span class="nx">field</span><span class="p">.</span><span class="nx">Tag</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;species&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="func-structtag-get">func (StructTag) Get</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">tag</span> <span class="nx">StructTag</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>获取返回与标记字符串中的键关联的值。如果标记中没有这样的键，则Get返回空字符串。如果标记没有标准格式，则Get返回的值未指定。要确定标记是否显式设置为空字符串，请使用Lookup。</p>
<h2 id="func-structtag-lookup-17">func (StructTag) Lookup 1.7</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">tag</span> <span class="nx">StructTag</span><span class="p">)</span> <span class="nf">Lookup</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">value</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Lookup返回与标记字符串中的key关联的值。如果key存在于标记中，则返回值（可以为空）。否则返回的值将是空字符串。ok返回值报告是否在标记字符串中显式设置了值。如果标记没有标准格式，则Lookup返回的值未指定。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;reflect&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">type</span> <span class="nx">S</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">F0</span> <span class="kt">string</span> <span class="s">`alias:&#34;field_0&#34;`</span>
</span></span><span class="line"><span class="cl">		<span class="nx">F1</span> <span class="kt">string</span> <span class="s">`alias:&#34;&#34;`</span>
</span></span><span class="line"><span class="cl">		<span class="nx">F2</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">S</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">st</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">st</span><span class="p">.</span><span class="nf">NumField</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">field</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Field</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">alias</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">field</span><span class="p">.</span><span class="nx">Tag</span><span class="p">.</span><span class="nf">Lookup</span><span class="p">(</span><span class="s">&#34;alias&#34;</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">alias</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;(blank)&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">alias</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;(not specified)&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="type-type-14">type Type 1.4</h1>
<p>Type是Go类型的表示。</p>
<p>并非所有方法都适用于所有类型。每种方法的文档中都标明了限制（如果有）。在调用特定于类的方法之前，使用Kind方法找出类型的分类。调用不适合这种类型的方法会导致运行时出现混乱。</p>
<p>类型值是可比较的，例如使用==运算符，因此它们可以用作映射键。如果两个Type值表示相同的类型，则它们相等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Type</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         <span class="c1">// 返回当从内存中申请一个该类型值时，会对齐的字节数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Align</span><span class="p">()</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 返回当该类型作为结构体的字段时，会对齐的字节数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">FieldAlign</span><span class="p">()</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">//方法返回类型方法集中的第i个方法。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//如果i不在[0，NumMethod（））范围内，那就会发生恐慌。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 对非接口类型T或*T，返回值的Type字段和Func字段描述方法的未绑定函数状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 对接口类型，返回值的Type字段描述方法的签名，Func字段为nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Method</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="nx">Method</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 根据方法名返回该类型方法集中的方法，使用一个布尔值说明是否发现该方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 对非接口类型T或*T，返回值的Type字段和Func字段描述方法的未绑定函数状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 对接口类型，返回值的Type字段描述方法的签名，Func字段为nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">MethodByName</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Method</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 返回该类型的方法集中方法的数目
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 匿名字段的方法会被计算；主体类型的方法会屏蔽匿名字段的同名方法；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 匿名字段导致的歧义方法会滤除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">NumMethod</span><span class="p">()</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Name返回该类型在自身包内的类型名，如果是未命名类型会返回&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Name</span><span class="p">()</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// PkgPath返回类型的包路径，即明确指定包的import路径，如&#34;encoding/base64&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果类型为内建类型(string, error)或未命名类型(*T, struct{}, []int)，会返回&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">PkgPath</span><span class="p">()</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 返回要保存一个该类型的值需要多少字节；类似unsafe.Sizeof
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Size</span><span class="p">()</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 返回类型的字符串表示。该字符串可能会使用短包名（如用base64代替&#34;encoding/base64&#34;）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 也不保证每个类型的字符串表示不同。如果要比较两个类型是否相等，请直接用Type类型比较。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Kind返回该接口的具体分类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Kind</span><span class="p">()</span> <span class="nx">Kind</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果该类型实现了u代表的接口，会返回真
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Implements</span><span class="p">(</span><span class="nx">u</span> <span class="nx">Type</span><span class="p">)</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果该类型的值可以直接赋值给u代表的类型，返回真
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">AssignableTo</span><span class="p">(</span><span class="nx">u</span> <span class="nx">Type</span><span class="p">)</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 如该类型的值可以转换为u代表的类型，返回真
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">ConvertibleTo</span><span class="p">(</span><span class="nx">u</span> <span class="nx">Type</span><span class="p">)</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">//报告此类型的值是否具有可比性。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Comparable</span><span class="p">()</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 返回该类型的字位数。如果该类型的Kind不是Int、Uint、Float或Complex，会panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Bits</span><span class="p">()</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         <span class="c1">// 返回一个channel类型的方向，如非通道类型将会panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">ChanDir</span><span class="p">()</span> <span class="nx">ChanDir</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// IsVariadic reports whether a function type&#39;s final input parameter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// is a &#34;...&#34; parameter. If so, t.In(t.NumIn() - 1) returns the parameter&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// implicit actual type []T.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// For concreteness, if t represents func(x int, y ... float64), then
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//	t.NumIn() == 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//	t.In(0) is the reflect.Type for &#34;int&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//	t.In(1) is the reflect.Type for &#34;[]float64&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//	t.IsVariadic() == true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// IsVariadic panics if the type&#39;s Kind is not Func.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="c1">// IsVariadic报告函数类型的最终输入参数是否为“...”参数。如果是这样，t.In（t.NumIn（） -  1）返回参数的隐式实际类型[] T.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 具体来说，如果t表示func（x int，y ... float64），则//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// t.NumIn（）== 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// t.In（0）是reflect.Type for“ int“
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// t.In（1）是”[] float64“的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//反射。类型.t.IsVariadic（）== true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//如果类型的种类不是Func，则IsVariadic会发生混乱。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">IsVariadic</span><span class="p">()</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Elem returns a type&#39;s element type.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// It panics if the type&#39;s Kind is not Array, Chan, Map, Ptr, or Slice.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Elem</span><span class="p">()</span> <span class="nx">Type</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Field returns a struct type&#39;s i&#39;th field.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// It panics if the type&#39;s Kind is not Struct.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// It panics if i is not in the range [0, NumField()).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Field</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">StructField</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// FieldByIndex returns the nested field corresponding
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// to the index sequence. It is equivalent to calling Field
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// successively for each index i.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// It panics if the type&#39;s Kind is not Struct.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">FieldByIndex</span><span class="p">(</span><span class="nx">index</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="nx">StructField</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// FieldByName returns the struct field with the given name
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// and a boolean indicating if the field was found.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">FieldByName</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">StructField</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// FieldByNameFunc returns the struct field with a name
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// that satisfies the match function and a boolean indicating if
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// the field was found.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// FieldByNameFunc considers the fields in the struct itself
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// and then the fields in any embedded structs, in breadth first order,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// stopping at the shallowest nesting depth containing one or more
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// fields satisfying the match function. If multiple fields at that depth
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// satisfy the match function, they cancel each other
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// and FieldByNameFunc returns no match.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// This behavior mirrors Go&#39;s handling of name lookup in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// structs containing embedded fields.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">FieldByNameFunc</span><span class="p">(</span><span class="nx">match</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">StructField</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// In returns the type of a function type&#39;s i&#39;th input parameter.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// It panics if the type&#39;s Kind is not Func.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// It panics if i is not in the range [0, NumIn()).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">In</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Type</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Key returns a map type&#39;s key type.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// It panics if the type&#39;s Kind is not Map.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Key</span><span class="p">()</span> <span class="nx">Type</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Len returns an array type&#39;s length.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// It panics if the type&#39;s Kind is not Array.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Len</span><span class="p">()</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// NumField returns a struct type&#39;s field count.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// It panics if the type&#39;s Kind is not Struct.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">NumField</span><span class="p">()</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// NumIn returns a function type&#39;s input parameter count.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// It panics if the type&#39;s Kind is not Func.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">NumIn</span><span class="p">()</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// NumOut returns a function type&#39;s output parameter count.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// It panics if the type&#39;s Kind is not Func.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">NumOut</span><span class="p">()</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Out returns the type of a function type&#39;s i&#39;th output parameter.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// It panics if the type&#39;s Kind is not Func.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// It panics if i is not in the range [0, NumOut()).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Out</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Type</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// contains filtered or unexported methods
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>func ArrayOf 1.5
func ArrayOf(count int, elem Type) Type
ArrayOf returns the array type with the given count and element type. For example, if t represents int, ArrayOf(5, t) represents [5]int.</p>
<p>If the resulting type would be larger than the available address space, ArrayOf panics.</p>
<p>func ChanOf 1.1
func ChanOf(dir ChanDir, t Type) Type
ChanOf returns the channel type with the given direction and element type. For example, if t represents int, ChanOf(RecvDir, t) represents &lt;-chan int.</p>
<p>The gc runtime imposes a limit of 64 kB on channel element types. If t&rsquo;s size is equal to or exceeds this limit, ChanOf panics.</p>
<p>func FuncOf 1.5
func FuncOf(in, out []Type, variadic bool) Type
FuncOf returns the function type with the given argument and result types. For example if k represents int and e represents string, FuncOf([]Type{k}, []Type{e}, false) represents func(int) string.</p>
<p>The variadic argument controls whether the function is variadic. FuncOf panics if the in[len(in)-1] does not represent a slice and variadic is true.</p>
<p>func MapOf 1.1
func MapOf(key, elem Type) Type
MapOf returns the map type with the given key and element types. For example, if k represents int and e represents string, MapOf(k, e) represents map[int]string.</p>
<p>If the key type is not a valid map key type (that is, if it does not implement Go&rsquo;s == operator), MapOf panics.</p>
<p>func PtrTo
func PtrTo(t Type) Type
PtrTo returns the pointer type with element t. For example, if t represents type Foo, PtrTo(t) represents *Foo.</p>
<p>func SliceOf 1.1
func SliceOf(t Type) Type
SliceOf returns the slice type with element type t. For example, if t represents int, SliceOf(t) represents []int.</p>
<p>func StructOf 1.7
func StructOf(fields []StructField) Type
StructOf returns the struct type containing fields. The Offset and Index fields are ignored and computed as they would be by the compiler.</p>
<p>StructOf currently does not generate wrapper methods for embedded fields and panics if passed unexported StructFields. These limitations may be lifted in a future version.</p>
<p>▹ Example</p>
<p>func TypeOf
func TypeOf(i interface{}) Type
TypeOf returns the reflection Type that represents the dynamic type of i. If i is a nil interface value, TypeOf returns nil.</p>
<p>▹ Example</p>
<p>type Value
Value is the reflection interface to a Go value.</p>
<p>Not all methods apply to all kinds of values. Restrictions, if any, are noted in the documentation for each method. Use the Kind method to find out the kind of value before calling kind-specific methods. Calling a method inappropriate to the kind of type causes a run time panic.</p>
<p>The zero Value represents no value. Its IsValid method returns false, its Kind method returns Invalid, its String method returns &ldquo;<!-- raw HTML omitted -->&rdquo;, and all other methods panic. Most functions and methods never return an invalid value. If one does, its documentation states the conditions explicitly.</p>
<p>A Value can be used concurrently by multiple goroutines provided that the underlying Go value can be used concurrently for the equivalent direct operations.</p>
<p>To compare two Values, compare the results of the Interface method. Using == on two Values does not compare the underlying values they represent.</p>
<p>type Value struct {
// contains filtered or unexported fields
}
func Append
func Append(s Value, x &hellip;Value) Value
Append appends the values x to a slice s and returns the resulting slice. As in Go, each x&rsquo;s value must be assignable to the slice&rsquo;s element type.</p>
<p>func AppendSlice
func AppendSlice(s, t Value) Value
AppendSlice appends a slice t to a slice s and returns the resulting slice. The slices s and t must have the same element type.</p>
<p>func Indirect
func Indirect(v Value) Value
Indirect returns the value that v points to. If v is a nil pointer, Indirect returns a zero Value. If v is not a pointer, Indirect returns v.</p>
<p>func MakeChan
func MakeChan(typ Type, buffer int) Value
MakeChan creates a new channel with the specified type and buffer size.</p>
<p>func MakeFunc 1.1
func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value
MakeFunc returns a new function of the given Type that wraps the function fn. When called, that new function does the following:</p>
<ul>
<li>converts its arguments to a slice of Values.</li>
<li>runs results := fn(args).</li>
<li>returns the results as a slice of Values, one per formal result.
The implementation fn can assume that the argument Value slice has the number and type of arguments given by typ. If typ describes a variadic function, the final Value is itself a slice representing the variadic arguments, as in the body of a variadic function. The result Value slice returned by fn must have the number and type of results given by typ.</li>
</ul>
<p>The Value.Call method allows the caller to invoke a typed function in terms of Values; in contrast, MakeFunc allows the caller to implement a typed function in terms of Values.</p>
<p>The Examples section of the documentation includes an illustration of how to use MakeFunc to build a swap function for different types.</p>
<p>▹ Example</p>
<p>func MakeMap
func MakeMap(typ Type) Value
MakeMap creates a new map with the specified type.</p>
<p>func MakeMapWithSize 1.9
func MakeMapWithSize(typ Type, n int) Value
MakeMapWithSize creates a new map with the specified type and initial space for approximately n elements.</p>
<p>func MakeSlice
func MakeSlice(typ Type, len, cap int) Value
MakeSlice creates a new zero-initialized slice value for the specified slice type, length, and capacity.</p>
<p>func New
func New(typ Type) Value
New returns a Value representing a pointer to a new zero value for the specified type. That is, the returned Value&rsquo;s Type is PtrTo(typ).</p>
<p>func NewAt
func NewAt(typ Type, p unsafe.Pointer) Value
NewAt returns a Value representing a pointer to a value of the specified type, using p as that pointer.</p>
<p>func Select 1.1
func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)
Select executes a select operation described by the list of cases. Like the Go select statement, it blocks until at least one of the cases can proceed, makes a uniform pseudo-random choice, and then executes that case. It returns the index of the chosen case and, if that case was a receive operation, the value received and a boolean indicating whether the value corresponds to a send on the channel (as opposed to a zero value received because the channel is closed).</p>
<p>func ValueOf
func ValueOf(i interface{}) Value
ValueOf returns a new Value initialized to the concrete value stored in the interface i. ValueOf(nil) returns the zero Value.</p>
<p>func Zero
func Zero(typ Type) Value
Zero returns a Value representing the zero value for the specified type. The result is different from the zero value of the Value struct, which represents no value at all. For example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0. The returned value is neither addressable nor settable.</p>
<p>func (Value) Addr
func (v Value) Addr() Value
Addr returns a pointer value representing the address of v. It panics if CanAddr() returns false. Addr is typically used to obtain a pointer to a struct field or slice element in order to call a method that requires a pointer receiver.</p>
<p>func (Value) Bool
func (v Value) Bool() bool
Bool returns v&rsquo;s underlying value. It panics if v&rsquo;s kind is not Bool.</p>
<p>func (Value) Bytes
func (v Value) Bytes() []byte
Bytes returns v&rsquo;s underlying value. It panics if v&rsquo;s underlying value is not a slice of bytes.</p>
<p>func (Value) Call
func (v Value) Call(in []Value) []Value
Call calls the function v with the input arguments in. For example, if len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]). Call panics if v&rsquo;s Kind is not Func. It returns the output results as Values. As in Go, each input argument must be assignable to the type of the function&rsquo;s corresponding input parameter. If v is a variadic function, Call creates the variadic slice parameter itself, copying in the corresponding values.</p>
<p>func (Value) CallSlice
func (v Value) CallSlice(in []Value) []Value
CallSlice calls the variadic function v with the input arguments in, assigning the slice in[len(in)-1] to v&rsquo;s final variadic argument. For example, if len(in) == 3, v.CallSlice(in) represents the Go call v(in[0], in[1], in[2]&hellip;). CallSlice panics if v&rsquo;s Kind is not Func or if v is not variadic. It returns the output results as Values. As in Go, each input argument must be assignable to the type of the function&rsquo;s corresponding input parameter.</p>
<p>func (Value) CanAddr
func (v Value) CanAddr() bool
CanAddr reports whether the value&rsquo;s address can be obtained with Addr. Such values are called addressable. A value is addressable if it is an element of a slice, an element of an addressable array, a field of an addressable struct, or the result of dereferencing a pointer. If CanAddr returns false, calling Addr will panic.</p>
<p>func (Value) CanInterface
func (v Value) CanInterface() bool
CanInterface reports whether Interface can be used without panicking.</p>
<p>func (Value) CanSet
func (v Value) CanSet() bool
CanSet reports whether the value of v can be changed. A Value can be changed only if it is addressable and was not obtained by the use of unexported struct fields. If CanSet returns false, calling Set or any type-specific setter (e.g., SetBool, SetInt) will panic.</p>
<p>func (Value) Cap
func (v Value) Cap() int
Cap returns v&rsquo;s capacity. It panics if v&rsquo;s Kind is not Array, Chan, or Slice.</p>
<p>func (Value) Close
func (v Value) Close()
Close closes the channel v. It panics if v&rsquo;s Kind is not Chan.</p>
<p>func (Value) Complex
func (v Value) Complex() complex128
Complex returns v&rsquo;s underlying value, as a complex128. It panics if v&rsquo;s Kind is not Complex64 or Complex128</p>
<p>func (Value) Convert 1.1
func (v Value) Convert(t Type) Value
Convert returns the value v converted to type t. If the usual Go conversion rules do not allow conversion of the value v to type t, Convert panics.</p>
<p>func (Value) Elem
func (v Value) Elem() Value
Elem returns the value that the interface v contains or that the pointer v points to. It panics if v&rsquo;s Kind is not Interface or Ptr. It returns the zero Value if v is nil.</p>
<p>func (Value) Field
func (v Value) Field(i int) Value
Field returns the i&rsquo;th field of the struct v. It panics if v&rsquo;s Kind is not Struct or i is out of range.</p>
<p>func (Value) FieldByIndex
func (v Value) FieldByIndex(index []int) Value
FieldByIndex returns the nested field corresponding to index. It panics if v&rsquo;s Kind is not struct.</p>
<p>func (Value) FieldByName
func (v Value) FieldByName(name string) Value
FieldByName returns the struct field with the given name. It returns the zero Value if no field was found. It panics if v&rsquo;s Kind is not struct.</p>
<p>func (Value) FieldByNameFunc
func (v Value) FieldByNameFunc(match func(string) bool) Value
FieldByNameFunc returns the struct field with a name that satisfies the match function. It panics if v&rsquo;s Kind is not struct. It returns the zero Value if no field was found.</p>
<p>func (Value) Float
func (v Value) Float() float64
Float returns v&rsquo;s underlying value, as a float64. It panics if v&rsquo;s Kind is not Float32 or Float64</p>
<p>func (Value) Index
func (v Value) Index(i int) Value
Index returns v&rsquo;s i&rsquo;th element. It panics if v&rsquo;s Kind is not Array, Slice, or String or i is out of range.</p>
<p>func (Value) Int
func (v Value) Int() int64
Int returns v&rsquo;s underlying value, as an int64. It panics if v&rsquo;s Kind is not Int, Int8, Int16, Int32, or Int64.</p>
<p>func (Value) Interface
func (v Value) Interface() (i interface{})
Interface returns v&rsquo;s current value as an interface{}. It is equivalent to:</p>
<p>var i interface{} = (v&rsquo;s underlying value)
It panics if the Value was obtained by accessing unexported struct fields.</p>
<p>func (Value) InterfaceData
func (v Value) InterfaceData() [2]uintptr
InterfaceData returns the interface v&rsquo;s value as a uintptr pair. It panics if v&rsquo;s Kind is not Interface.</p>
<p>func (Value) IsNil
func (v Value) IsNil() bool
IsNil reports whether its argument v is nil. The argument must be a chan, func, interface, map, pointer, or slice value; if it is not, IsNil panics. Note that IsNil is not always equivalent to a regular comparison with nil in Go. For example, if v was created by calling ValueOf with an uninitialized interface variable i, i==nil will be true but v.IsNil will panic as v will be the zero Value.</p>
<p>func (Value) IsValid
func (v Value) IsValid() bool
IsValid reports whether v represents a value. It returns false if v is the zero Value. If IsValid returns false, all other methods except String panic. Most functions and methods never return an invalid value. If one does, its documentation states the conditions explicitly.</p>
<p>func (Value) Kind
func (v Value) Kind() Kind
Kind returns v&rsquo;s Kind. If v is the zero Value (IsValid returns false), Kind returns Invalid.</p>
<p>func (Value) Len
func (v Value) Len() int
Len returns v&rsquo;s length. It panics if v&rsquo;s Kind is not Array, Chan, Map, Slice, or String.</p>
<p>func (Value) MapIndex
func (v Value) MapIndex(key Value) Value
MapIndex returns the value associated with key in the map v. It panics if v&rsquo;s Kind is not Map. It returns the zero Value if key is not found in the map or if v represents a nil map. As in Go, the key&rsquo;s value must be assignable to the map&rsquo;s key type.</p>
<p>func (Value) MapKeys
func (v Value) MapKeys() []Value
MapKeys returns a slice containing all the keys present in the map, in unspecified order. It panics if v&rsquo;s Kind is not Map. It returns an empty slice if v represents a nil map.</p>
<p>func (Value) MapRange 1.12
func (v Value) MapRange() *MapIter
MapRange returns a range iterator for a map. It panics if v&rsquo;s Kind is not Map.</p>
<p>Call Next to advance the iterator, and Key/Value to access each entry. Next returns false when the iterator is exhausted. MapRange follows the same iteration semantics as a range statement.</p>
<p>Example:</p>
<p>iter := reflect.ValueOf(m).MapRange()
for iter.Next() {
k := iter.Key()
v := iter.Value()
&hellip;
}
func (Value) Method
func (v Value) Method(i int) Value
Method returns a function value corresponding to v&rsquo;s i&rsquo;th method. The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. Method panics if i is out of range or if v is a nil interface value.</p>
<p>func (Value) MethodByName
func (v Value) MethodByName(name string) Value
MethodByName returns a function value corresponding to the method of v with the given name. The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. It returns the zero Value if no method was found.</p>
<p>func (Value) NumField
func (v Value) NumField() int
NumField returns the number of fields in the struct v. It panics if v&rsquo;s Kind is not Struct.</p>
<p>func (Value) NumMethod
func (v Value) NumMethod() int
NumMethod returns the number of exported methods in the value&rsquo;s method set.</p>
<p>func (Value) OverflowComplex
func (v Value) OverflowComplex(x complex128) bool
OverflowComplex reports whether the complex128 x cannot be represented by v&rsquo;s type. It panics if v&rsquo;s Kind is not Complex64 or Complex128.</p>
<p>func (Value) OverflowFloat
func (v Value) OverflowFloat(x float64) bool
OverflowFloat reports whether the float64 x cannot be represented by v&rsquo;s type. It panics if v&rsquo;s Kind is not Float32 or Float64.</p>
<p>func (Value) OverflowInt
func (v Value) OverflowInt(x int64) bool
OverflowInt reports whether the int64 x cannot be represented by v&rsquo;s type. It panics if v&rsquo;s Kind is not Int, Int8, Int16, Int32, or Int64.</p>
<p>func (Value) OverflowUint
func (v Value) OverflowUint(x uint64) bool
OverflowUint reports whether the uint64 x cannot be represented by v&rsquo;s type. It panics if v&rsquo;s Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.</p>
<p>func (Value) Pointer
func (v Value) Pointer() uintptr
Pointer returns v&rsquo;s value as a uintptr. It returns uintptr instead of unsafe.Pointer so that code using reflect cannot obtain unsafe.Pointers without importing the unsafe package explicitly. It panics if v&rsquo;s Kind is not Chan, Func, Map, Ptr, Slice, or UnsafePointer.</p>
<p>If v&rsquo;s Kind is Func, the returned pointer is an underlying code pointer, but not necessarily enough to identify a single function uniquely. The only guarantee is that the result is zero if and only if v is a nil func Value.</p>
<p>If v&rsquo;s Kind is Slice, the returned pointer is to the first element of the slice. If the slice is nil the returned value is 0. If the slice is empty but non-nil the return value is non-zero.</p>
<p>func (Value) Recv
func (v Value) Recv() (x Value, ok bool)
Recv receives and returns a value from the channel v. It panics if v&rsquo;s Kind is not Chan. The receive blocks until a value is ready. The boolean value ok is true if the value x corresponds to a send on the channel, false if it is a zero value received because the channel is closed.</p>
<p>func (Value) Send
func (v Value) Send(x Value)
Send sends x on the channel v. It panics if v&rsquo;s kind is not Chan or if x&rsquo;s type is not the same type as v&rsquo;s element type. As in Go, x&rsquo;s value must be assignable to the channel&rsquo;s element type.</p>
<p>func (Value) Set
func (v Value) Set(x Value)
Set assigns x to the value v. It panics if CanSet returns false. As in Go, x&rsquo;s value must be assignable to v&rsquo;s type.</p>
<p>func (Value) SetBool
func (v Value) SetBool(x bool)
SetBool sets v&rsquo;s underlying value. It panics if v&rsquo;s Kind is not Bool or if CanSet() is false.</p>
<p>func (Value) SetBytes
func (v Value) SetBytes(x []byte)
SetBytes sets v&rsquo;s underlying value. It panics if v&rsquo;s underlying value is not a slice of bytes.</p>
<p>func (Value) SetCap 1.2
func (v Value) SetCap(n int)
SetCap sets v&rsquo;s capacity to n. It panics if v&rsquo;s Kind is not Slice or if n is smaller than the length or greater than the capacity of the slice.</p>
<p>func (Value) SetComplex
func (v Value) SetComplex(x complex128)
SetComplex sets v&rsquo;s underlying value to x. It panics if v&rsquo;s Kind is not Complex64 or Complex128, or if CanSet() is false.</p>
<p>func (Value) SetFloat
func (v Value) SetFloat(x float64)
SetFloat sets v&rsquo;s underlying value to x. It panics if v&rsquo;s Kind is not Float32 or Float64, or if CanSet() is false.</p>
<p>func (Value) SetInt
func (v Value) SetInt(x int64)
SetInt sets v&rsquo;s underlying value to x. It panics if v&rsquo;s Kind is not Int, Int8, Int16, Int32, or Int64, or if CanSet() is false.</p>
<p>func (Value) SetLen
func (v Value) SetLen(n int)
SetLen sets v&rsquo;s length to n. It panics if v&rsquo;s Kind is not Slice or if n is negative or greater than the capacity of the slice.</p>
<p>func (Value) SetMapIndex
func (v Value) SetMapIndex(key, val Value)
SetMapIndex sets the value associated with key in the map v to val. It panics if v&rsquo;s Kind is not Map. If val is the zero Value, SetMapIndex deletes the key from the map. Otherwise if v holds a nil map, SetMapIndex will panic. As in Go, key&rsquo;s value must be assignable to the map&rsquo;s key type, and val&rsquo;s value must be assignable to the map&rsquo;s value type.</p>
<p>func (Value) SetPointer
func (v Value) SetPointer(x unsafe.Pointer)
SetPointer sets the unsafe.Pointer value v to x. It panics if v&rsquo;s Kind is not UnsafePointer.</p>
<p>func (Value) SetString
func (v Value) SetString(x string)
SetString sets v&rsquo;s underlying value to x. It panics if v&rsquo;s Kind is not String or if CanSet() is false.</p>
<p>func (Value) SetUint
func (v Value) SetUint(x uint64)
SetUint sets v&rsquo;s underlying value to x. It panics if v&rsquo;s Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64, or if CanSet() is false.</p>
<p>func (Value) Slice
func (v Value) Slice(i, j int) Value
Slice returns v[i:j]. It panics if v&rsquo;s Kind is not Array, Slice or String, or if v is an unaddressable array, or if the indexes are out of bounds.</p>
<p>func (Value) Slice3 1.2
func (v Value) Slice3(i, j, k int) Value
Slice3 is the 3-index form of the slice operation: it returns v[i:j:k]. It panics if v&rsquo;s Kind is not Array or Slice, or if v is an unaddressable array, or if the indexes are out of bounds.</p>
<p>func (Value) String
func (v Value) String() string
String returns the string v&rsquo;s underlying value, as a string. String is a special case because of Go&rsquo;s String method convention. Unlike the other getters, it does not panic if v&rsquo;s Kind is not String. Instead, it returns a string of the form &ldquo;<!-- raw HTML omitted -->&rdquo; where T is v&rsquo;s type. The fmt package treats Values specially. It does not call their String method implicitly but instead prints the concrete values they hold.</p>
<p>func (Value) TryRecv
func (v Value) TryRecv() (x Value, ok bool)
TryRecv attempts to receive a value from the channel v but will not block. It panics if v&rsquo;s Kind is not Chan. If the receive delivers a value, x is the transferred value and ok is true. If the receive cannot finish without blocking, x is the zero Value and ok is false. If the channel is closed, x is the zero value for the channel&rsquo;s element type and ok is false.</p>
<p>func (Value) TrySend
func (v Value) TrySend(x Value) bool
TrySend attempts to send x on the channel v but will not block. It panics if v&rsquo;s Kind is not Chan. It reports whether the value was sent. As in Go, x&rsquo;s value must be assignable to the channel&rsquo;s element type.</p>
<p>func (Value) Type
func (v Value) Type() Type
Type returns v&rsquo;s type.</p>
<p>func (Value) Uint
func (v Value) Uint() uint64
Uint returns v&rsquo;s underlying value, as a uint64. It panics if v&rsquo;s Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.</p>
<p>func (Value) UnsafeAddr
func (v Value) UnsafeAddr() uintptr
UnsafeAddr returns a pointer to v&rsquo;s data. It is for advanced clients that also import the &ldquo;unsafe&rdquo; package. It panics if v is not addressable.</p>
<p>type ValueError
A ValueError occurs when a Value method is invoked on a Value that does not support it. Such cases are documented in the description of each method.</p>
<p>type ValueError struct {
Method string
Kind   Kind
}
func (*ValueError) Error
func (e *ValueError) Error() string
Bugs
☞
FieldByName and related functions consider struct field names to be equal if the names are equal, even if they are unexported names originating in different packages. The practical effect of this is that the result of t.FieldByName(&ldquo;x&rdquo;) is not well defined if the struct type t contains multiple fields named x (embedded from different packages). FieldByName may return one of the fields named x or may report that there are none. See <a href="https://golang.org/issue/4876">https://golang.org/issue/4876</a> for more details.</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2019-07-21
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go%E6%A0%87%E5%87%86%E5%BA%93/">Go标准库</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go-modules-%E6%B5%85%E6%9E%90/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go Modules 浅析</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/oltp%E4%B8%8Eolap%E7%9A%84%E5%8C%BA%E5%88%AB/">
            <span class="next-text nav-default">OLTP与OLAP的区别</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
