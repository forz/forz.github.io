<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>kill命令详解 | Forz Blog</title>
<meta name="keywords" content="Shell" />
<meta name="description" content="kill命令 kill命令用来删除执行中的程序或工作。kill可将指定的信息送至程序。预设的信息为SIGTERM(15),可将指定程序终止。若">
<meta name="author" content="">
<link rel="canonical" href="/post/kill%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="kill命令详解" />
<meta property="og:description" content="kill命令 kill命令用来删除执行中的程序或工作。kill可将指定的信息送至程序。预设的信息为SIGTERM(15),可将指定程序终止。若" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/kill%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2018-11-15T18:33:14&#43;00:00" />
<meta property="article:modified_time" content="2018-11-15T18:33:14&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="kill命令详解"/>
<meta name="twitter:description" content="kill命令 kill命令用来删除执行中的程序或工作。kill可将指定的信息送至程序。预设的信息为SIGTERM(15),可将指定程序终止。若"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "kill命令详解",
      "item": "/post/kill%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "kill命令详解",
  "name": "kill命令详解",
  "description": "kill命令 kill命令用来删除执行中的程序或工作。kill可将指定的信息送至程序。预设的信息为SIGTERM(15),可将指定程序终止。若",
  "keywords": [
    "Shell"
  ],
  "articleBody": "kill命令 kill命令用来删除执行中的程序或工作。kill可将指定的信息送至程序。预设的信息为SIGTERM(15),可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。\n程序或工作的编号可利用ps指令或job指令查看。\n语法 kill(选项)(参数)  选项 1 2 3 4 5  -a：当处理当前进程时，不限制命令名和进程号的对应关系； -l ：若不加选项，则-l参数会列出全部的信息名称； -p：指定kill 命令只打印相关进程的进程号，而不发送任何信号； -s ：指定要送出的信息； -u：指定用户。 参数 进程或作业识别号：指定要删除的进程或作业。 实例 列出所有信号名称：   只有第9种信号(SIGKILL)才可以无条件终止进程，其他信号进程都有权利忽略，下面是常用的信号：\n1 2 3 4 5 6 7  HUP 1 终端断线 INT 2 中断（同 Ctrl + C） QUIT 3 退出（同 Ctrl + \\） TERM 15 终止 KILL 9 强制终止 CONT 18 继续（与STOP相反， fg/bg命令） STOP 19 暂停（同 Ctrl + Z）   killall命令 Linux系统中的killall命令用于杀死指定名字的进程（kill processes by name）。我们可以使用kill命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用ps等命令再配合grep来查找进程，而killall把这两个过程合二为一，是一个很好用的命令。\nkillall使用进程名替代PID，并且它会kill掉所有的同名进程。例如，如果你正在运行多个Firefox浏览器的实例，可以用命令把它们全部kill掉:\nkillall firefox  命令格式 killall[参数][进程名]  命令参数 1 2 3 4 5 6 7 8 9 10 11 12  -Z 只杀死拥有scontext 的进程 -e 要求匹配进程名称 -I 忽略小写 -g 杀死进程组而不是进程 -i 交互模式，杀死进程前先询问用户 -l 列出所有的已知信号名称 -q 不输出警告信息 -s 发送指定的信号 -v 报告信号是否成功发送 -w 等待进程死亡 --help 显示帮助信息 --version 显示版本显示   范例 1. 杀死所有同名进程 killall nginx killall -9 bash  2. 交互杀死进程 ps aux |grep httpd #匹配httpd killall -I -9 httpd #删前询问是否确认删除  3. 按照终端号进行删除 踢掉linux登陆的其他用户\n1 2 3 4 5 6  [root@xkht-test ~]# w 21:53:52 up 35 days, 5:06, 2 users, load average: 0.22, 0.32, 0.34 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT root pts/0 122.71.227.215 21:49 0.00s 0.02s 0.00s w root pts/2 122.71.227.215 21:49 16.00s 0.01s 0.01s -bash [root@xkht-test ~]# pkill -9 -t pts/2   如果两个都是超级用户，先下手为强， 后下手遭殃。\npkill命令 killall和pkill是相似的,不过如果给出的进程名不完整，killall会报错。pkill或者pgrep只要给出进程名的一部分就可以终止进程。\n“pkill”命令允许使用扩展的正则表达式和其它匹配方式。你现在可以使用应用的进程名kill掉它们，而不是使用PID。例如，要kill掉Firefox浏览器，只需要运行命令：\npkill firefox  使用正则表达式匹配的话，你可以输入进程名的部分字符，比如：\npkill fire  语法 pkill(选项)(参数)  选项 1 2 3 4 5  -o：仅向找到的最小（起始）进程号发送信号； -n：仅向找到的最大（结束）进程号发送信号； -P：指定父进程号发送信号； -g：指定进程组； -t：指定开启进程的终端。   参数 进程名称：指定要查找的进程名称，同时也支持类似grep指令中的匹配模式。\n附 kill 信号列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  $ kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP 21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8 43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2 63) SIGRTMAX-1 64) SIGRTMAX   列表中，编号为1 ~ 31的信号为传统UNIX支持的信号，是不可靠信号(非实时的)，编号为32 ~ 63的信号是后来扩充的，称做可靠信号(实时信号)。不可靠信号和可靠信号的区别在于前者不支持排队，可能会造成信号丢失，而后者不会。\n下面我们对编号小于SIGRTMIN的信号进行讨论。\n1) SIGHUP 本信号在用户终端连接(正常或非正常)结束时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业, 这时它们与控制终端不再关联。\n登录Linux时，系统会分配给登录用户一个终端(Session)。在这个终端运行的所有程序，包括前台进程组和后台进程组，一般都属于这个 Session。当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP信号。这个信号的默认操作为终止进程，因此前台进程组和后台有终端输出的进程就会中止。不过可以捕获这个信号，比如wget能捕获SIGHUP信号，并忽略它，这样就算退出了Linux登录，wget也 能继续下载。\n此外，对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。\n2) SIGINT 程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl-C)时发出，用于通知前台进程组终止进程。\n3) SIGQUIT 和SIGINT类似, 但由QUIT字符(通常是Ctrl-)来控制. 进程在因收到SIGQUIT退出时会产生core文件, 在这个意义上类似于一个程序错误信号。\n4) SIGILL 执行了非法指令. 通常是因为可执行文件本身出现错误, 或者试图执行数据段. 堆栈溢出时也有可能产生这个信号。\n5) SIGTRAP 由断点指令或其它trap指令产生. 由debugger使用。\n6) SIGABRT 调用abort函数生成的信号。\n7) SIGBUS 非法地址, 包括内存地址对齐(alignment)出错。比如访问一个四个字长的整数, 但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的(如访问不属于自己存储空间或只读存储空间)。\n8) SIGFPE 在发生致命的算术运算错误时发出. 不仅包括浮点运算错误, 还包括溢出及除数为0等其它所有的算术的错误。\n9) SIGKILL 用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。如果管理员发现某个进程终止不了，可尝试发送这个信号。\n10) SIGUSR1 留给用户使用\n11) SIGSEGV 试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据.\n12) SIGUSR2 留给用户使用\n13) SIGPIPE 管道破裂。这个信号通常在进程间通信产生，比如采用FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到SIGPIPE信号。此外用Socket通信的两个进程，写进程在写Socket的时候，读进程已经终止。\n14) SIGALRM 时钟定时信号, 计算的是实际的时间或时钟时间. alarm函数使用该信号.\n15) SIGTERM 程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出，shell命令kill缺省产生这个信号。如果进程终止不了，我们才会尝试SIGKILL。\n17) SIGCHLD 子进程结束时, 父进程会收到这个信号。\n如果父进程没有处理这个信号，也没有等待(wait)子进程，子进程虽然终止，但是还会在内核进程表中占有表项，这时的子进程称为僵尸进程。这种情 况我们应该避免(父进程或者忽略SIGCHILD信号，或者捕捉它，或者wait它派生的子进程，或者父进程先终止，这时子进程的终止自动由init进程来接管)。\n18) SIGCONT 让一个停止(stopped)的进程继续执行. 本信号不能被阻塞. 可以用一个handler来让程序在由stopped状态变为继续执行时完成特定的工作. 例如, 重新显示提示符…\n19) SIGSTOP 停止(stopped)进程的执行. 注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行. 本信号不能被阻塞, 处理或忽略.\n20) SIGTSTP 停止进程的运行, 但该信号可以被处理和忽略. 用户键入SUSP字符时(通常是Ctrl-Z)发出这个信号\n21) SIGTTIN 当后台作业要从用户终端读数据时, 该作业中的所有进程会收到SIGTTIN信号. 缺省时这些进程会停止执行.\n22) SIGTTOU 类似于SIGTTIN, 但在写终端(或修改终端模式)时收到.\n23) SIGURG 有\"紧急\"数据或out-of-band数据到达socket时产生.\n24) SIGXCPU 超过CPU时间资源限制. 这个限制可以由getrlimit/setrlimit来读取/改变。\n25) SIGXFSZ 当进程企图扩大文件以至于超过文件大小资源限制。\n26) SIGVTALRM 虚拟时钟信号. 类似于SIGALRM, 但是计算的是该进程占用的CPU时间.\n27) SIGPROF 类似于SIGALRM/SIGVTALRM, 但包括该进程用的CPU时间以及系统调用的时间.\n28) SIGWINCH 窗口大小改变时发出.\n29) SIGIO 文件描述符准备就绪, 可以开始进行输入/输出操作.\n30) SIGPWR Power failure\n31) SIGSYS 非法的系统调用。\n总结 在以上列出的信号中，程序不可捕获、阻塞或忽略的信号有：SIGKILL,SIGSTOP\n不能恢复至默认动作的信号有：SIGILL,SIGTRAP\n默认会导致进程流产的信号有：SIGABRT,SIGBUS,SIGFPE,SIGILL,SIGIOT,SIGQUIT,SIGSEGV,SIGTRAP,SIGXCPU,SIGXFSZ\n默认会导致进程退出的信号有：SIGALRM,SIGHUP,SIGINT,SIGKILL,SIGPIPE,SIGPOLL,SIGPROF,SIGSYS,SIGTERM,SIGUSR1,SIGUSR2,SIGVTALRM\n默认会导致进程停止的信号有：SIGSTOP,SIGTSTP,SIGTTIN,SIGTTOU\n默认进程忽略的信号有：SIGCHLD,SIGPWR,SIGURG,SIGWINCH\n",
  "wordCount" : "3767",
  "inLanguage": "zh-cn",
  "datePublished": "2018-11-15T18:33:14Z",
  "dateModified": "2018-11-15T18:33:14Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/kill%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      kill命令详解
    </h1>
    <div class="post-meta">November 15, 2018
</div>
  </header> 
  <div class="post-content"><h1 id="kill命令">kill命令<a hidden class="anchor" aria-hidden="true" href="#kill命令">#</a></h1>
<p>kill命令用来删除执行中的程序或工作。kill可将指定的信息送至程序。预设的信息为SIGTERM(15),可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。</p>
<p>程序或工作的编号可利用ps指令或job指令查看。</p>
<h2 id="语法">语法<a hidden class="anchor" aria-hidden="true" href="#语法">#</a></h2>
<pre><code>kill(选项)(参数)
</code></pre>
<h2 id="选项">选项<a hidden class="anchor" aria-hidden="true" href="#选项">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">-a：当处理当前进程时，不限制命令名和进程号的对应关系；
-l &lt;信息编号&gt;：若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称；
-p：指定kill 命令只打印相关进程的进程号，而不发送任何信号；
-s &lt;信息名称或编号&gt;：指定要送出的信息；
-u：指定用户。 参数 进程或作业识别号：指定要删除的进程或作业。 实例 列出所有信号名称：
</code></pre></td></tr></table>
</div>
</div><p>只有第9种信号(SIGKILL)才可以无条件终止进程，其他信号进程都有权利忽略，下面是常用的信号：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">HUP 1 终端断线 
INT 2 中断（同 Ctrl + C） 
QUIT 3 退出（同 Ctrl + \）
TERM 15 终止
KILL 9 强制终止
CONT 18 继续（与STOP相反， fg/bg命令） 
STOP 19 暂停（同 Ctrl + Z）
</code></pre></td></tr></table>
</div>
</div><h1 id="killall命令">killall命令<a hidden class="anchor" aria-hidden="true" href="#killall命令">#</a></h1>
<p>Linux系统中的killall命令用于杀死指定名字的进程（kill processes by name）。我们可以使用kill命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用ps等命令再配合grep来查找进程，而killall把这两个过程合二为一，是一个很好用的命令。</p>
<p>killall使用进程名替代PID，并且它会kill掉所有的同名进程。例如，如果你正在运行多个Firefox浏览器的实例，可以用命令把它们全部kill掉:</p>
<pre><code>killall firefox
</code></pre>
<h2 id="命令格式">命令格式<a hidden class="anchor" aria-hidden="true" href="#命令格式">#</a></h2>
<pre><code>killall[参数][进程名]
</code></pre>
<h2 id="命令参数">命令参数<a hidden class="anchor" aria-hidden="true" href="#命令参数">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">-Z 只杀死拥有scontext 的进程
-e 要求匹配进程名称
-I 忽略小写
-g 杀死进程组而不是进程
-i 交互模式，杀死进程前先询问用户
-l 列出所有的已知信号名称
-q 不输出警告信息
-s 发送指定的信号
-v 报告信号是否成功发送
-w 等待进程死亡
--help 显示帮助信息
--version 显示版本显示
</code></pre></td></tr></table>
</div>
</div><h2 id="范例">范例<a hidden class="anchor" aria-hidden="true" href="#范例">#</a></h2>
<h3 id="1-杀死所有同名进程">1. 杀死所有同名进程<a hidden class="anchor" aria-hidden="true" href="#1-杀死所有同名进程">#</a></h3>
<pre><code>killall nginx
killall -9 bash
</code></pre>
<h3 id="2-交互杀死进程">2. 交互杀死进程<a hidden class="anchor" aria-hidden="true" href="#2-交互杀死进程">#</a></h3>
<pre><code>ps aux |grep httpd
#匹配httpd
killall -I -9 httpd
#删前询问是否确认删除
</code></pre>
<h3 id="3-按照终端号进行删除">3. 按照终端号进行删除<a hidden class="anchor" aria-hidden="true" href="#3-按照终端号进行删除">#</a></h3>
<p>踢掉linux登陆的其他用户</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">[root@xkht-test ~]# w
 21:53:52 up 35 days,  5:06,  2 users,  load average: 0.22, 0.32, 0.34
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    122.71.227.215   21:49    0.00s  0.02s  0.00s w
root     pts/2    122.71.227.215   21:49   16.00s  0.01s  0.01s -bash
[root@xkht-test ~]# pkill -9 -t pts/2
</code></pre></td></tr></table>
</div>
</div><p>如果两个都是超级用户，先下手为强， 后下手遭殃。</p>
<h1 id="pkill命令">pkill命令<a hidden class="anchor" aria-hidden="true" href="#pkill命令">#</a></h1>
<p>killall和pkill是相似的,不过如果给出的进程名不完整，killall会报错。pkill或者pgrep只要给出进程名的一部分就可以终止进程。</p>
<p>“pkill”命令允许使用扩展的正则表达式和其它匹配方式。你现在可以使用应用的进程名kill掉它们，而不是使用PID。例如，要kill掉Firefox浏览器，只需要运行命令：</p>
<pre><code>pkill firefox
</code></pre>
<p>使用正则表达式匹配的话，你可以输入进程名的部分字符，比如：</p>
<pre><code>pkill fire
</code></pre>
<h2 id="语法-1">语法<a hidden class="anchor" aria-hidden="true" href="#语法-1">#</a></h2>
<pre><code>pkill(选项)(参数)
</code></pre>
<h2 id="选项-1">选项<a hidden class="anchor" aria-hidden="true" href="#选项-1">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">-o：仅向找到的最小（起始）进程号发送信号；
-n：仅向找到的最大（结束）进程号发送信号；
-P：指定父进程号发送信号；
-g：指定进程组；
-t：指定开启进程的终端。
</code></pre></td></tr></table>
</div>
</div><h2 id="参数">参数<a hidden class="anchor" aria-hidden="true" href="#参数">#</a></h2>
<p>进程名称：指定要查找的进程名称，同时也支持类似grep指令中的匹配模式。</p>
<h1 id="附-kill-信号列表">附 kill 信号列表<a hidden class="anchor" aria-hidden="true" href="#附-kill-信号列表">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">$ kill -l
1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL
5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE
9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2
13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT 17) SIGCHLD
18) SIGCONT     19) SIGSTOP     20) SIGTSTP     21) SIGTTIN
22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO
30) SIGPWR      31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1
36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4  39) SIGRTMIN+5
40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8  43) SIGRTMIN+9
44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13
52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9
56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6  59) SIGRTMAX-5
60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2  63) SIGRTMAX-1
64) SIGRTMAX
</code></pre></td></tr></table>
</div>
</div><p>列表中，编号为1 ~ 31的信号为传统UNIX支持的信号，是不可靠信号(非实时的)，编号为32 ~ 63的信号是后来扩充的，称做可靠信号(实时信号)。不可靠信号和可靠信号的区别在于前者不支持排队，可能会造成信号丢失，而后者不会。</p>
<p>下面我们对编号小于SIGRTMIN的信号进行讨论。</p>
<h3 id="1-sighup">1) SIGHUP<a hidden class="anchor" aria-hidden="true" href="#1-sighup">#</a></h3>
<p>本信号在用户终端连接(正常或非正常)结束时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业, 这时它们与控制终端不再关联。</p>
<p>登录Linux时，系统会分配给登录用户一个终端(Session)。在这个终端运行的所有程序，包括前台进程组和后台进程组，一般都属于这个 Session。当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP信号。这个信号的默认操作为终止进程，因此前台进程组和后台有终端输出的进程就会中止。不过可以捕获这个信号，比如wget能捕获SIGHUP信号，并忽略它，这样就算退出了Linux登录，wget也 能继续下载。</p>
<p>此外，对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。</p>
<h3 id="2-sigint">2) SIGINT<a hidden class="anchor" aria-hidden="true" href="#2-sigint">#</a></h3>
<p>程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl-C)时发出，用于通知前台进程组终止进程。</p>
<h3 id="3-sigquit">3) SIGQUIT<a hidden class="anchor" aria-hidden="true" href="#3-sigquit">#</a></h3>
<p>和SIGINT类似, 但由QUIT字符(通常是Ctrl-)来控制. 进程在因收到SIGQUIT退出时会产生core文件, 在这个意义上类似于一个程序错误信号。</p>
<h3 id="4-sigill">4) SIGILL<a hidden class="anchor" aria-hidden="true" href="#4-sigill">#</a></h3>
<p>执行了非法指令. 通常是因为可执行文件本身出现错误, 或者试图执行数据段. 堆栈溢出时也有可能产生这个信号。</p>
<h3 id="5-sigtrap">5) SIGTRAP<a hidden class="anchor" aria-hidden="true" href="#5-sigtrap">#</a></h3>
<p>由断点指令或其它trap指令产生. 由debugger使用。</p>
<h3 id="6-sigabrt">6) SIGABRT<a hidden class="anchor" aria-hidden="true" href="#6-sigabrt">#</a></h3>
<p>调用abort函数生成的信号。</p>
<h3 id="7-sigbus">7) SIGBUS<a hidden class="anchor" aria-hidden="true" href="#7-sigbus">#</a></h3>
<p>非法地址, 包括内存地址对齐(alignment)出错。比如访问一个四个字长的整数, 但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的(如访问不属于自己存储空间或只读存储空间)。</p>
<h3 id="8-sigfpe">8) SIGFPE<a hidden class="anchor" aria-hidden="true" href="#8-sigfpe">#</a></h3>
<p>在发生致命的算术运算错误时发出. 不仅包括浮点运算错误, 还包括溢出及除数为0等其它所有的算术的错误。</p>
<h3 id="9-sigkill">9) SIGKILL<a hidden class="anchor" aria-hidden="true" href="#9-sigkill">#</a></h3>
<p>用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。如果管理员发现某个进程终止不了，可尝试发送这个信号。</p>
<h3 id="10-sigusr1">10) SIGUSR1<a hidden class="anchor" aria-hidden="true" href="#10-sigusr1">#</a></h3>
<p>留给用户使用</p>
<h3 id="11-sigsegv">11) SIGSEGV<a hidden class="anchor" aria-hidden="true" href="#11-sigsegv">#</a></h3>
<p>试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据.</p>
<h3 id="12-sigusr2">12) SIGUSR2<a hidden class="anchor" aria-hidden="true" href="#12-sigusr2">#</a></h3>
<p>留给用户使用</p>
<h3 id="13-sigpipe">13) SIGPIPE<a hidden class="anchor" aria-hidden="true" href="#13-sigpipe">#</a></h3>
<p>管道破裂。这个信号通常在进程间通信产生，比如采用FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到SIGPIPE信号。此外用Socket通信的两个进程，写进程在写Socket的时候，读进程已经终止。</p>
<h3 id="14-sigalrm">14) SIGALRM<a hidden class="anchor" aria-hidden="true" href="#14-sigalrm">#</a></h3>
<p>时钟定时信号, 计算的是实际的时间或时钟时间. alarm函数使用该信号.</p>
<h3 id="15-sigterm">15) SIGTERM<a hidden class="anchor" aria-hidden="true" href="#15-sigterm">#</a></h3>
<p>程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出，shell命令kill缺省产生这个信号。如果进程终止不了，我们才会尝试SIGKILL。</p>
<h3 id="17-sigchld">17) SIGCHLD<a hidden class="anchor" aria-hidden="true" href="#17-sigchld">#</a></h3>
<p>子进程结束时, 父进程会收到这个信号。</p>
<p>如果父进程没有处理这个信号，也没有等待(wait)子进程，子进程虽然终止，但是还会在内核进程表中占有表项，这时的子进程称为僵尸进程。这种情 况我们应该避免(父进程或者忽略SIGCHILD信号，或者捕捉它，或者wait它派生的子进程，或者父进程先终止，这时子进程的终止自动由init进程来接管)。</p>
<h3 id="18-sigcont">18) SIGCONT<a hidden class="anchor" aria-hidden="true" href="#18-sigcont">#</a></h3>
<p>让一个停止(stopped)的进程继续执行. 本信号不能被阻塞. 可以用一个handler来让程序在由stopped状态变为继续执行时完成特定的工作. 例如, 重新显示提示符&hellip;</p>
<h3 id="19-sigstop">19) SIGSTOP<a hidden class="anchor" aria-hidden="true" href="#19-sigstop">#</a></h3>
<p>停止(stopped)进程的执行. 注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行. 本信号不能被阻塞, 处理或忽略.</p>
<h3 id="20-sigtstp">20) SIGTSTP<a hidden class="anchor" aria-hidden="true" href="#20-sigtstp">#</a></h3>
<p>停止进程的运行, 但该信号可以被处理和忽略. 用户键入SUSP字符时(通常是Ctrl-Z)发出这个信号</p>
<h3 id="21-sigttin">21) SIGTTIN<a hidden class="anchor" aria-hidden="true" href="#21-sigttin">#</a></h3>
<p>当后台作业要从用户终端读数据时, 该作业中的所有进程会收到SIGTTIN信号. 缺省时这些进程会停止执行.</p>
<h3 id="22-sigttou">22) SIGTTOU<a hidden class="anchor" aria-hidden="true" href="#22-sigttou">#</a></h3>
<p>类似于SIGTTIN, 但在写终端(或修改终端模式)时收到.</p>
<h3 id="23-sigurg">23) SIGURG<a hidden class="anchor" aria-hidden="true" href="#23-sigurg">#</a></h3>
<p>有&quot;紧急&quot;数据或out-of-band数据到达socket时产生.</p>
<h3 id="24-sigxcpu">24) SIGXCPU<a hidden class="anchor" aria-hidden="true" href="#24-sigxcpu">#</a></h3>
<p>超过CPU时间资源限制. 这个限制可以由getrlimit/setrlimit来读取/改变。</p>
<h3 id="25-sigxfsz">25) SIGXFSZ<a hidden class="anchor" aria-hidden="true" href="#25-sigxfsz">#</a></h3>
<p>当进程企图扩大文件以至于超过文件大小资源限制。</p>
<h3 id="26-sigvtalrm">26) SIGVTALRM<a hidden class="anchor" aria-hidden="true" href="#26-sigvtalrm">#</a></h3>
<p>虚拟时钟信号. 类似于SIGALRM, 但是计算的是该进程占用的CPU时间.</p>
<h3 id="27-sigprof">27) SIGPROF<a hidden class="anchor" aria-hidden="true" href="#27-sigprof">#</a></h3>
<p>类似于SIGALRM/SIGVTALRM, 但包括该进程用的CPU时间以及系统调用的时间.</p>
<h3 id="28-sigwinch">28) SIGWINCH<a hidden class="anchor" aria-hidden="true" href="#28-sigwinch">#</a></h3>
<p>窗口大小改变时发出.</p>
<h3 id="29-sigio">29) SIGIO<a hidden class="anchor" aria-hidden="true" href="#29-sigio">#</a></h3>
<p>文件描述符准备就绪, 可以开始进行输入/输出操作.</p>
<h3 id="30-sigpwr">30) SIGPWR<a hidden class="anchor" aria-hidden="true" href="#30-sigpwr">#</a></h3>
<p>Power failure</p>
<h3 id="31-sigsys">31) SIGSYS<a hidden class="anchor" aria-hidden="true" href="#31-sigsys">#</a></h3>
<p>非法的系统调用。</p>
<h3 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h3>
<p>在以上列出的信号中，程序不可捕获、阻塞或忽略的信号有：SIGKILL,SIGSTOP</p>
<p>不能恢复至默认动作的信号有：SIGILL,SIGTRAP</p>
<p>默认会导致进程流产的信号有：SIGABRT,SIGBUS,SIGFPE,SIGILL,SIGIOT,SIGQUIT,SIGSEGV,SIGTRAP,SIGXCPU,SIGXFSZ</p>
<p>默认会导致进程退出的信号有：SIGALRM,SIGHUP,SIGINT,SIGKILL,SIGPIPE,SIGPOLL,SIGPROF,SIGSYS,SIGTERM,SIGUSR1,SIGUSR2,SIGVTALRM</p>
<p>默认会导致进程停止的信号有：SIGSTOP,SIGTSTP,SIGTTIN,SIGTTOU</p>
<p>默认进程忽略的信号有：SIGCHLD,SIGPWR,SIGURG,SIGWINCH</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/shell/">Shell</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
