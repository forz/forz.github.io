<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>proto生成Go代码指南 | Forz Blog</title>
<meta name="keywords" content="protobuf" />
<meta name="description" content="本页确切描述了protocol buffer编译器为任何给定的协议定义生成的Go代码。突出显示了proto2和proto3生成的代码之间的任何">
<meta name="author" content="">
<link rel="canonical" href="/post/proto%E7%94%9F%E6%88%90go%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="proto生成Go代码指南" />
<meta property="og:description" content="本页确切描述了protocol buffer编译器为任何给定的协议定义生成的Go代码。突出显示了proto2和proto3生成的代码之间的任何" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/proto%E7%94%9F%E6%88%90go%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-04-16T17:37:51&#43;00:00" />
<meta property="article:modified_time" content="2021-04-16T17:37:51&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="proto生成Go代码指南"/>
<meta name="twitter:description" content="本页确切描述了protocol buffer编译器为任何给定的协议定义生成的Go代码。突出显示了proto2和proto3生成的代码之间的任何"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "proto生成Go代码指南",
      "item": "/post/proto%E7%94%9F%E6%88%90go%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "proto生成Go代码指南",
  "name": "proto生成Go代码指南",
  "description": "本页确切描述了protocol buffer编译器为任何给定的协议定义生成的Go代码。突出显示了proto2和proto3生成的代码之间的任何",
  "keywords": [
    "protobuf"
  ],
  "articleBody": "本页确切描述了protocol buffer编译器为任何给定的协议定义生成的Go代码。突出显示了proto2和proto3生成的代码之间的任何差异-请注意，这些差异在本文档中描述的生成的代码中，而不是在基本API中，这在两个版本中都是相同的。在阅读本文档之前，您应该阅读 proto2语言指南和/或 proto3语言指南。\n编译器调用 protocol buffer编译器需要一个插件来生成Go代码。通过运行以下命令使用Go 1.16或更高版本进行安装：\n1  go install google.golang.org/protobuf/cmd/protoc-gen-go@latest   这将在$GOBIN中安装protoc-gen-go二进制文件。设置$GOBIN环境变量以更改安装位置。它必须是在你$PATH的协议缓冲编译器找到它。\nproto编译器使用该go_out标志调用时，会生成Go输出。go_out标志的参数是您希望编译器在其中写入Go输出的目录。编译器为每个.proto文件输入创建一个源文件。通过将.proto扩展名替换为来创建输出文件的名称.pb.go。\n生成的.pb.go文件在输出目录中的放置位置取决于编译器标志。有几种输出模式：\n 如果指定了path = import标志，则将输出文件放置在以Go软件包的导入路径命名的目录中。 例如，输入文件protos / buzz.proto的go导入路径为example.com/project/protos/fizz，则输出文件为example.com/project/protos/fizz/buzz.pb.go。 如果未指定路径标志，则这是默认的输出模式。 如果指定了module = $ PREFIX标志，则将输出文件放置在以Go软件包的导入路径命名的目录中，但将从输出文件名中删除指定的目录前缀。 例如，将Go导入路径为example.com/project/protos/fizz和example.com/project指定为模块前缀的输入文件protos / buzz.proto会在protos / fizz / buzz.pb中生成输出文件.go。 在模块路径之外生成任何Go软件包都会导致错误。 此模式对于将生成的文件直接输出到Go模块很有用。 如果指定了paths = source_relative标志，则将输出文件放置在与输入文件相同的相对目录中。例如，输入文件protos / buzz.proto导致输出文件为protos / buzz.pb.go。  protoc-gen-go通过go_opt调用时传递标志来提供特定于的标志protoc。go_opt可以传递多个标志。例如，运行时：\n1  protoc --proto_path=src --go_out=out --go_opt=paths=source_relative foo.proto bar/baz.proto   编译器将从src目录中读取输入文件foo.proto和bar / baz.proto，并将输出文件foo.pb.go和bar / baz.pb.go写入out目录。 如有必要，编译器会自动创建嵌套的输出子目录，但不会自行创建输出目录。\nPackages 为了生成Go代码，必须为每个.proto文件提供Go包的导入路径（包括.proto正在生成的文件所依赖的文件）。有两种方法可以指定Go导入路径：\n 通过在.proto文件中声明它，或者 通过在调用时在命令行上声明它protoc。  我们建议在.proto文件中声明它，以便.proto可以使用.proto文件本身在中央标识文件的Go包， 并简化调用时传递的标志集protoc。如果给定.proto文件的Go导入路径由.proto文件本身和命令行提供，则后者优先于前者。\n.proto通过go_package在Go包的完整导入路径中声明一个选项，可以在文件中本地指定Go导入路径。用法示例：\n1  option go_package = \"example.com/project/protos/fizz\";  可以在调用编译器时通过传递一个或多个M${PROTO_FILE}=${GO_IMPORT_PATH}标志的方式在命令行上指定Go导入路径。用法示例：\n1 2 3 4  protoc --proto_path=src \\ --go_opt=Mprotos/buzz.proto=example.com/project/protos/fizz \\ --go_opt=Mprotos/bar.proto=example.com/project/protos/foo \\ protos/buzz.proto protos/bar.proto   由于所有.proto文件到它们的Go导入路径的映射都可能很大，因此指定Go导入路径的这种模式通常由对整个依赖树具有控制权的某些构建工具（例如Bazel）执行。如果给定.proto文件的条目重复，则最后指定的条目优先。\n对于go_package选项和M标志，该值都可以包含一个显式的程序包名称，该名称与导入路径之间用分号分隔。例如：“example.com/protos/foo;package_name”。不鼓励使用此方法，因为默认情况下，软件包名称将以合理的方式从导入路径派生。\n导入路径用于确定当一个.proto文件导入另一.proto文件时必须生成哪些导入语句。例如，如果a.protoimports b.proto，则生成的a.pb.go文件需要导入包含生成的b.pb.go文件的Go包（除非两个文件都在同一个包中）。导入路径还用于构造输出文件名。有关详细信息，请参见上面的“编译器调用”部分。\nGo导入路径与.proto文件中的包说明符之间没有任何关联。 后者仅与protobuf命名空间有关，而前者仅与Go命名空间有关。 此外，Go导入路径和.proto导入路径之间没有关联。\nMessages 给定一个简单的消息声明：\n1  message Foo {}  proto buffer’s编译器生成一个称为Foo的结构。 * Foo实现了proto.Message接口。\n该 proto软件包 提供了对消息进行操作的功能，包括与二进制格式之间的转换。\n该proto.Message接口定义了一个ProtoReflect方法。此方法返回 protoreflect.Message ，提供消息的基于反射的视图。\n该optimize_for选项不会影响Go代码生成器的输出。\n嵌套类型 一条消息可以在另一条消息中声明。例如：\n1 2 3 4  message Foo { message Bar { }}  在这种情况下，编译器会生成两个结构：Foo和 Foo_Bar。\nFields protocol buffer编译器为消息中定义的每个字段生成一个结构字段。此字段的确切性质取决于其类型以及它是单数字段，重复字段，映射字段还是oneof字段。\n请注意，即使.proto文件中的字段名称使用带下划线的小写字母（应如此），生成的Go字段名称也始终使用驼峰式命名。大小写转换的工作方式如下：\n 第一个字母大写用于导出。如果第一个字符是下划线，则将其删除并以大写字母X开头。 如果内部下划线后跟小写字母，则下划线将被删除，并且以下字母大写。  因此，原始字段foo_bar_baz变为 FooBarBazGo，_my_field_name_2变为 XMyFieldName_2。\n单独常量字段（proto3） 对于此字段定义：\n1  int32 foo = 1;  编译器将生成一个结构，该结构具有一个int32名为的字段 Foo和一个访问器方法GetFoo()，如果未设置该字段，则返回该类型的 int32值Foo或 零值（0对于数字，对于字符串为空字符串）。\n对于其他标量字段类型（包括bool， bytes和string），int32根据标量值类型表将其替换为相应的Go类型 。原型中未设置的值将表示为该类型的 零值（0对于数字，对于字符串，为空字符串）。\n单独消息字段 给定消息类型：\n1  message Bar {}  对于带有Bar字段的消息：\n1 2 3 4  // proto3 message Baz { Bar foo = 1;}  编译器将生成一个Go结构\n1 2 3  type Baz struct { Foo *Bar }   可以将消息字段设置为nil，这意味着未设置该字段，从而有效地清除了该字段。 这不等于将值设置为消息结构的“空”实例。\n编译器还会生成一个func (m *Baz) GetFoo()*Bar 辅助函数。如果m为nil或未foo设置,此函数返回nil *Bar。这样就可以在没有中间nil检查的情况下链式调用获取。\n重复字段 每个重复的字段T都会在Go的结构中生成一个字段切片，该字段的元素类型为T。对于具有重复字段的此消息：\n1 2 3  message Baz { repeated Bar foo = 1;}  编译器生成Go结构：\n1 2 3  type Baz struct { Foo []*Bar }   同样，对于字段定义repeated bytes foo = 1;，编译器将使用名为[][]byte的字段 生成Go结构Foo。对于重复枚举 repeated MyEnum bar = 2;，编译器生成一个结构，该结构带有一个名为Bar的[]MyEnum。\n以下示例显示如何设置字段：\n1 2 3 4 5 6  baz := \u0026Baz{ Foo: []*Bar{ {}, // First element.  {}, // Second element.  }, }   要访问该字段，您可以执行以下操作：\n1 2  foo := baz.GetFoo() // foo type is []*Bar. b1 := foo[0] // b1 type is *Bar, the first element in foo.   Map 每个映射字段都会在类型的结构中生成一个字段， map[TKey]TValue其中，TKey是字段的键类型和TValue字段的值类型。对于带有地图字段的此消息：\n1 2 3 4 5  message Bar {}message Baz { mapstring, Bar foo = 1;}  编译器生成Go结构：\n1 2 3  type Baz struct { Foo map[string]*Bar }   oneof 对于一个oneof字段，protobuf编译器会生成一个具有接口type的单个字段isMessageName_MyField。它还为其中一个中的每个单独字段生成一个结构。这些都实现此isMessageName_MyField接口。\n对于带有oneof字段的此消息：\n1 2 3 4 5 6 7  package account;message Profile { oneof avatar { string image_url = 1; bytes image_data = 2; }}  编译器生成以下结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  type Profile struct { // Types that are valid to be assigned to Avatar:  // *Profile_ImageUrl  // *Profile_ImageData  Avatar isProfile_Avatar `protobuf_oneof:\"avatar\"` } type Profile_ImageUrl struct { ImageUrl string } type Profile_ImageData struct { ImageData []byte }   *Profile_ImageUrl和*Profile_ImageData 实现isProfile_Avatar通过提供一个空的 isProfile_Avatar()方法。\n以下示例显示如何设置字段：\n1 2 3 4 5 6 7 8 9  p1 := \u0026account.Profile{ Avatar: \u0026account.Profile_ImageUrl{\"http://example.com/image.png\"}, } // imageData is []byte imageData := getImageData() p2 := \u0026account.Profile{ Avatar: \u0026account.Profile_ImageData{imageData}, }   要访问该字段，可以使用值上的类型开关来处理不同的消息类型。\n1 2 3 4 5 6 7 8 9 10 11 12  switch x := m.Avatar.(type) { case *account.Profile_ImageUrl: // Load profile image based on URL  // using x.ImageUrl case*account.Profile_ImageData: // Load profile image based on bytes  // using x.ImageData case nil: // The field is not set. default: return fmt.Errorf(\"Profile.Avatar has unexpected type %T\", x) }   编译器还会生成get方法 func (m *Profile) GetImageUrl() string和 func (m *Profile) GetImageData() []byte。每个get函数都返回该字段的值，如果未设置，则返回零值。\n枚举 给定一个像这样的枚举：\n1 2 3 4 5 6 7 8 9 10 11 12 13  message SearchRequest { enum Corpus { UNIVERSAL = 0; WEB = 1; IMAGES = 2; LOCAL = 3; NEWS = 4; PRODUCTS = 5; VIDEO = 6; } Corpus corpus = 1; ...}  protocol buffer编译器会生成一个类型和一系列带有该类型的常量。\n对于消息中的枚举（如上面的枚举），类型名称以消息名称开头：\n1  type SearchRequest_Corpus int32   对于包级枚举：\n1 2 3 4 5  enum Foo { DEFAULT_BAR = 0; BAR_BELLS = 1; BAR_B_CUE = 2;}  Go类型名称不对原始枚举名称进行修改：\n1  type Foo int32   此类型具有一种String()返回给定值名称的方法。\n该Enum()方法使用给定值初始化新分配的内存，并返回相应的指针：\n1  func (Foo) Enum() *Foo   protocol buffer编译器会为枚举中的每个值生成一个常量。对于消息中的枚举，常量以包含消息的名称开头：\n1 2 3 4 5 6 7 8 9  const ( SearchRequest_UNIVERSAL SearchRequest_Corpus = 0 SearchRequest_WEB SearchRequest_Corpus = 1 SearchRequest_IMAGES SearchRequest_Corpus = 2 SearchRequest_LOCAL SearchRequest_Corpus = 3 SearchRequest_NEWS SearchRequest_Corpus = 4 SearchRequest_PRODUCTS SearchRequest_Corpus = 5 SearchRequest_VIDEO SearchRequest_Corpus = 6 )   对于包级枚举，常量以枚举名称开头：\n1 2 3 4 5  const ( Foo_DEFAULT_BAR Foo = 0 Foo_BAR_BELLS Foo = 1 Foo_BAR_B_CUE Foo = 2 )   protobuf编译器还会生成一个从整数值到字符串名称的映射以及从名称到值的映射：\n1 2 3 4 5 6 7 8 9 10  var Foo_name = map[int32]string{ 0: \"DEFAULT_BAR\", 1: \"BAR_BELLS\", 2: \"BAR_B_CUE\", } var Foo_value = map[string]int32{ \"DEFAULT_BAR\": 0, \"BAR_BELLS\": 1, \"BAR_B_CUE\": 2, }   请注意，.proto语言允许多个枚举符号具有相同的数值。 具有相同数值的符号是同义词。 这些在Go中以完全相同的方式表示，具有对应于相同数值的多个名称。 反向映射包含一个将数字值输入到.proto文件中最先出现的名称的条目。\n服务 默认情况下，Go代码生成器不会为服务生成输出。如果启用了gRPC插件（请参阅 gRPC Go快速入门指南），那么将生成支持gRPC的代码。\n",
  "wordCount" : "4444",
  "inLanguage": "zh-cn",
  "datePublished": "2021-04-16T17:37:51Z",
  "dateModified": "2021-04-16T17:37:51Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/proto%E7%94%9F%E6%88%90go%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      proto生成Go代码指南
    </h1>
    <div class="post-meta">April 16, 2021
</div>
  </header> 
  <div class="post-content"><p>本页确切描述了protocol buffer编译器为任何给定的协议定义生成的Go代码。突出显示了proto2和proto3生成的代码之间的任何差异-请注意，这些差异在本文档中描述的生成的代码中，而不是在基本API中，这在两个版本中都是相同的。在阅读本文档之前，您应该阅读 proto2语言指南和/或 proto3语言指南。</p>
<h2 id="编译器调用">编译器调用<a hidden class="anchor" aria-hidden="true" href="#编译器调用">#</a></h2>
<p>protocol buffer编译器需要一个插件来生成Go代码。通过运行以下命令使用Go 1.16或更高版本进行安装：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
</code></pre></td></tr></table>
</div>
</div><p>这将在<code>$GOBIN</code>中安装protoc-gen-go二进制文件。设置<code>$GOBIN</code>环境变量以更改安装位置。它必须是在你$PATH的协议缓冲编译器找到它。</p>
<p>proto编译器使用该go_out标志调用时，会生成Go输出。go_out标志的参数是您希望编译器在其中写入Go输出的目录。编译器为每个.proto文件输入创建一个源文件。通过将.proto扩展名替换为来创建输出文件的名称.pb.go。</p>
<p>生成的.pb.go文件在输出目录中的放置位置取决于编译器标志。有几种输出模式：</p>
<ul>
<li>如果指定了path = import标志，则将输出文件放置在以Go软件包的导入路径命名的目录中。 例如，输入文件protos / buzz.proto的go导入路径为example.com/project/protos/fizz，则输出文件为example.com/project/protos/fizz/buzz.pb.go。 如果未指定路径标志，则这是默认的输出模式。</li>
<li>如果指定了module = $ PREFIX标志，则将输出文件放置在以Go软件包的导入路径命名的目录中，但将从输出文件名中删除指定的目录前缀。 例如，将Go导入路径为example.com/project/protos/fizz和example.com/project指定为模块前缀的输入文件protos / buzz.proto会在protos / fizz / buzz.pb中生成输出文件.go。 在模块路径之外生成任何Go软件包都会导致错误。 此模式对于将生成的文件直接输出到Go模块很有用。</li>
<li>如果指定了paths = source_relative标志，则将输出文件放置在与输入文件相同的相对目录中。例如，输入文件protos / buzz.proto导致输出文件为protos / buzz.pb.go。</li>
</ul>
<p>protoc-gen-go通过go_opt调用时传递标志来提供特定于的标志protoc。go_opt可以传递多个标志。例如，运行时：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">protoc</span> <span class="o">--</span><span class="n">proto_path</span><span class="o">=</span><span class="n">src</span> <span class="o">--</span><span class="n">go_out</span><span class="o">=</span><span class="n">out</span> <span class="o">--</span><span class="n">go_opt</span><span class="o">=</span><span class="n">paths</span><span class="o">=</span><span class="n">source_relative</span> <span class="n">foo.proto</span> <span class="n">bar</span><span class="o">/</span><span class="n">baz.proto</span>
</code></pre></td></tr></table>
</div>
</div><p>编译器将从src目录中读取输入文件foo.proto和bar / baz.proto，并将输出文件foo.pb.go和bar / baz.pb.go写入out目录。 如有必要，编译器会自动创建嵌套的输出子目录，但不会自行创建输出目录。</p>
<h2 id="packages">Packages<a hidden class="anchor" aria-hidden="true" href="#packages">#</a></h2>
<p>为了生成Go代码，必须为每个.proto文件提供Go包的导入路径（包括.proto正在生成的文件所依赖的文件）。有两种方法可以指定Go导入路径：</p>
<ul>
<li>通过在.proto文件中声明它，或者</li>
<li>通过在调用时在命令行上声明它protoc。</li>
</ul>
<p>我们建议在.proto文件中声明它，以便.proto可以使用.proto文件本身在中央标识文件的Go包， 并简化调用时传递的标志集protoc。如果给定.proto文件的Go导入路径由.proto文件本身和命令行提供，则后者优先于前者。</p>
<p>.proto通过go_package在Go包的完整导入路径中声明一个选项，可以在文件中本地指定Go导入路径。用法示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="k">option</span> <span class="n">go_package</span> <span class="o">=</span> <span class="s">&#34;example.com/project/protos/fizz&#34;</span><span class="p">;</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>可以在调用编译器时通过传递一个或多个<code>M${PROTO_FILE}=${GO_IMPORT_PATH}</code>标志的方式在命令行上指定Go导入路径。用法示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">protoc</span> <span class="o">--</span><span class="n">proto_path</span><span class="o">=</span><span class="n">src</span> <span class="n">\</span>
  <span class="o">--</span><span class="n">go_opt</span><span class="o">=</span><span class="n">Mprotos</span><span class="o">/</span><span class="n">buzz.proto</span><span class="o">=</span><span class="n">example.com</span><span class="o">/</span><span class="n">project</span><span class="o">/</span><span class="n">protos</span><span class="o">/</span><span class="n">fizz</span> <span class="n">\</span>
  <span class="o">--</span><span class="n">go_opt</span><span class="o">=</span><span class="n">Mprotos</span><span class="o">/</span><span class="n">bar.proto</span><span class="o">=</span><span class="n">example.com</span><span class="o">/</span><span class="n">project</span><span class="o">/</span><span class="n">protos</span><span class="o">/</span><span class="n">foo</span> <span class="n">\</span>
  <span class="n">protos</span><span class="o">/</span><span class="n">buzz.proto</span> <span class="n">protos</span><span class="o">/</span><span class="n">bar.proto</span>
</code></pre></td></tr></table>
</div>
</div><p>由于所有.proto文件到它们的Go导入路径的映射都可能很大，因此指定Go导入路径的这种模式通常由对整个依赖树具有控制权的某些构建工具（例如Bazel）执行。如果给定.proto文件的条目重复，则最后指定的条目优先。</p>
<p>对于go_package选项和M标志，该值都可以包含一个显式的程序包名称，该名称与导入路径之间用分号分隔。例如：&ldquo;example.com/protos/foo;package_name&rdquo;。不鼓励使用此方法，因为默认情况下，软件包名称将以合理的方式从导入路径派生。</p>
<p>导入路径用于确定当一个.proto文件导入另一.proto文件时必须生成哪些导入语句。例如，如果a.protoimports b.proto，则生成的a.pb.go文件需要导入包含生成的b.pb.go文件的Go包（除非两个文件都在同一个包中）。导入路径还用于构造输出文件名。有关详细信息，请参见上面的“编译器调用”部分。</p>
<p>Go导入路径与.proto文件中的包说明符之间没有任何关联。 后者仅与protobuf命名空间有关，而前者仅与Go命名空间有关。 此外，Go导入路径和.proto导入路径之间没有关联。</p>
<h2 id="messages">Messages<a hidden class="anchor" aria-hidden="true" href="#messages">#</a></h2>
<p>给定一个简单的消息声明：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">Foo</span> <span class="p">{}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>proto buffer&rsquo;s编译器生成一个称为Foo的结构。 * Foo实现了proto.Message接口。</p>
<p>该 proto软件包 提供了对消息进行操作的功能，包括与二进制格式之间的转换。</p>
<p>该proto.Message接口定义了一个ProtoReflect方法。此方法返回 protoreflect.Message ，提供消息的基于反射的视图。</p>
<p>该optimize_for选项不会影响Go代码生成器的输出。</p>
<h3 id="嵌套类型">嵌套类型<a hidden class="anchor" aria-hidden="true" href="#嵌套类型">#</a></h3>
<p>一条消息可以在另一条消息中声明。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">Foo</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="kd">message</span> <span class="nc">Bar</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="p">}</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>在这种情况下，编译器会生成两个结构：Foo和 Foo_Bar。</p>
<h2 id="fields">Fields<a hidden class="anchor" aria-hidden="true" href="#fields">#</a></h2>
<p>protocol buffer编译器为消息中定义的每个字段生成一个结构字段。此字段的确切性质取决于其类型以及它是单数字段，重复字段，映射字段还是oneof字段。</p>
<p>请注意，即使.proto文件中的字段名称使用带下划线的小写字母（应如此），生成的Go字段名称也始终使用驼峰式命名。大小写转换的工作方式如下：</p>
<ol>
<li>第一个字母大写用于导出。如果第一个字符是下划线，则将其删除并以大写字母X开头。</li>
<li>如果内部下划线后跟小写字母，则下划线将被删除，并且以下字母大写。</li>
</ol>
<p>因此，原始字段foo_bar_baz变为 FooBarBazGo，_my_field_name_2变为 XMyFieldName_2。</p>
<h3 id="单独常量字段proto3">单独常量字段（proto3）<a hidden class="anchor" aria-hidden="true" href="#单独常量字段proto3">#</a></h3>
<p>对于此字段定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kt">int32</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>编译器将生成一个结构，该结构具有一个int32名为的字段 Foo和一个访问器方法GetFoo()，如果未设置该字段，则返回该类型的 int32值Foo或 零值（0对于数字，对于字符串为空字符串）。</p>
<p>对于其他标量字段类型（包括bool， bytes和string），int32根据标量值类型表将其替换为相应的Go类型 。原型中未设置的值将表示为该类型的 零值（0对于数字，对于字符串，为空字符串）。</p>
<h3 id="单独消息字段">单独消息字段<a hidden class="anchor" aria-hidden="true" href="#单独消息字段">#</a></h3>
<p>给定消息类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">Bar</span> <span class="p">{}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>对于带有Bar字段的消息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="c1">// proto3
</span><span class="c1"></span><span class="kd">message</span> <span class="nc">Baz</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="n">Bar</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>编译器将生成一个Go结构</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Baz</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">Foo</span> <span class="o">*</span><span class="nx">Bar</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以将消息字段设置为nil，这意味着未设置该字段，从而有效地清除了该字段。 这不等于将值设置为消息结构的“空”实例。</p>
<p>编译器还会生成一个<code>func (m *Baz) GetFoo()*Bar</code> 辅助函数。如果m为nil或未foo设置,此函数返回<code>nil *Bar</code>。这样就可以在没有中间nil检查的情况下链式调用获取。</p>
<h3 id="重复字段">重复字段<a hidden class="anchor" aria-hidden="true" href="#重复字段">#</a></h3>
<p>每个重复的字段T都会在Go的结构中生成一个字段切片，该字段的元素类型为T。对于具有重复字段的此消息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">Baz</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">repeated</span> <span class="n">Bar</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>编译器生成Go结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Baz</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">Foo</span>  <span class="p">[]</span><span class="o">*</span><span class="nx">Bar</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>同样，对于字段定义<code>repeated bytes foo = 1;</code>，编译器将使用名为<code>[][]byte</code>的字段 生成Go结构Foo。对于重复枚举 <code>repeated MyEnum bar = 2;</code>，编译器生成一个结构，该结构带有一个名为Bar的<code>[]MyEnum</code>。</p>
<p>以下示例显示如何设置字段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">baz</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Baz</span><span class="p">{</span>
  <span class="nx">Foo</span><span class="p">:</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Bar</span><span class="p">{</span>
    <span class="p">{},</span> <span class="c1">// First element.
</span><span class="c1"></span>    <span class="p">{},</span> <span class="c1">// Second element.
</span><span class="c1"></span>  <span class="p">},</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>要访问该字段，您可以执行以下操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">foo</span> <span class="o">:=</span> <span class="nx">baz</span><span class="p">.</span><span class="nf">GetFoo</span><span class="p">()</span> <span class="c1">// foo type is []*Bar.
</span><span class="c1"></span><span class="nx">b1</span> <span class="o">:=</span> <span class="nx">foo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// b1 type is *Bar, the first element in foo.
</span></code></pre></td></tr></table>
</div>
</div><h3 id="map">Map<a hidden class="anchor" aria-hidden="true" href="#map">#</a></h3>
<p>每个映射字段都会在类型的结构中生成一个字段， map[TKey]TValue其中，TKey是字段的键类型和TValue字段的值类型。对于带有地图字段的此消息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">Bar</span> <span class="p">{}</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="kd">message</span> <span class="nc">Baz</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="n">map</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">Bar</span><span class="p">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>编译器生成Go结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Baz</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">Foo</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">Bar</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="oneof">oneof<a hidden class="anchor" aria-hidden="true" href="#oneof">#</a></h3>
<p>对于一个oneof字段，protobuf编译器会生成一个具有接口type的单个字段isMessageName_MyField。它还为其中一个中的每个单独字段生成一个结构。这些都实现此isMessageName_MyField接口。</p>
<p>对于带有oneof字段的此消息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kn">package</span> <span class="nn">account</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="kd">message</span> <span class="nc">Profile</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">oneof</span> <span class="n">avatar</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>    <span class="kt">string</span> <span class="n">image_url</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="kt">bytes</span> <span class="n">image_data</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="p">}</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>编译器生成以下结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Profile</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="c1">// Types that are valid to be assigned to Avatar:
</span><span class="c1"></span>        <span class="c1">//      *Profile_ImageUrl
</span><span class="c1"></span>        <span class="c1">//      *Profile_ImageData
</span><span class="c1"></span>        <span class="nx">Avatar</span> <span class="nx">isProfile_Avatar</span> <span class="s">`protobuf_oneof:&#34;avatar&#34;`</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Profile_ImageUrl</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">ImageUrl</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">Profile_ImageData</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">ImageData</span> <span class="p">[]</span><span class="kt">byte</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p><code>*Profile_ImageUrl</code>和<code>*Profile_ImageData</code> 实现<code>isProfile_Avatar</code>通过提供一个空的 <code>isProfile_Avatar()</code>方法。</p>
<p>以下示例显示如何设置字段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">p1</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">account</span><span class="p">.</span><span class="nx">Profile</span><span class="p">{</span>
  <span class="nx">Avatar</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">account</span><span class="p">.</span><span class="nx">Profile_ImageUrl</span><span class="p">{</span><span class="s">&#34;http://example.com/image.png&#34;</span><span class="p">},</span>
<span class="p">}</span>

<span class="c1">// imageData is []byte
</span><span class="c1"></span><span class="nx">imageData</span> <span class="o">:=</span> <span class="nf">getImageData</span><span class="p">()</span>
<span class="nx">p2</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">account</span><span class="p">.</span><span class="nx">Profile</span><span class="p">{</span>
  <span class="nx">Avatar</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">account</span><span class="p">.</span><span class="nx">Profile_ImageData</span><span class="p">{</span><span class="nx">imageData</span><span class="p">},</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>要访问该字段，可以使用值上的类型开关来处理不同的消息类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">switch</span> <span class="nx">x</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Avatar</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">*</span><span class="nx">account</span><span class="p">.</span><span class="nx">Profile_ImageUrl</span><span class="p">:</span>
        <span class="c1">// Load profile image based on URL
</span><span class="c1"></span>        <span class="c1">// using x.ImageUrl
</span><span class="c1"></span><span class="k">case</span><span class="o">*</span><span class="nx">account</span><span class="p">.</span><span class="nx">Profile_ImageData</span><span class="p">:</span>
        <span class="c1">// Load profile image based on bytes
</span><span class="c1"></span>        <span class="c1">// using x.ImageData
</span><span class="c1"></span><span class="k">case</span> <span class="kc">nil</span><span class="p">:</span>
        <span class="c1">// The field is not set.
</span><span class="c1"></span><span class="k">default</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Profile.Avatar has unexpected type %T&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>编译器还会生成get方法 <code>func (m *Profile) GetImageUrl() string和 func (m *Profile) GetImageData() []byte</code>。每个get函数都返回该字段的值，如果未设置，则返回零值。</p>
<h2 id="枚举">枚举<a hidden class="anchor" aria-hidden="true" href="#枚举">#</a></h2>
<p>给定一个像这样的枚举：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">SearchRequest</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="kd">enum</span> <span class="n">Corpus</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>    <span class="n">UNIVERSAL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="n">WEB</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="n">IMAGES</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="n">LOCAL</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="n">NEWS</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="n">PRODUCTS</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="n">VIDEO</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="p">}</span><span class="err">
</span><span class="err"></span>  <span class="n">Corpus</span> <span class="n">corpus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="o">...</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>protocol buffer编译器会生成一个类型和一系列带有该类型的常量。</p>
<p>对于消息中的枚举（如上面的枚举），类型名称以消息名称开头：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SearchRequest_Corpus</span> <span class="kt">int32</span>
</code></pre></td></tr></table>
</div>
</div><p>对于包级枚举：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">enum</span> <span class="n">Foo</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="n">DEFAULT_BAR</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="n">BAR_BELLS</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="n">BAR_B_CUE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>Go类型名称不对原始枚举名称进行修改：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Foo</span> <span class="kt">int32</span>
</code></pre></td></tr></table>
</div>
</div><p>此类型具有一种String()返回给定值名称的方法。</p>
<p>该Enum()方法使用给定值初始化新分配的内存，并返回相应的指针：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">Foo</span><span class="p">)</span> <span class="nf">Enum</span><span class="p">()</span> <span class="o">*</span><span class="nx">Foo</span>
</code></pre></td></tr></table>
</div>
</div><p>protocol buffer编译器会为枚举中的每个值生成一个常量。对于消息中的枚举，常量以包含消息的名称开头：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
        <span class="nx">SearchRequest_UNIVERSAL</span> <span class="nx">SearchRequest_Corpus</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="nx">SearchRequest_WEB</span>       <span class="nx">SearchRequest_Corpus</span> <span class="p">=</span> <span class="mi">1</span>
        <span class="nx">SearchRequest_IMAGES</span>    <span class="nx">SearchRequest_Corpus</span> <span class="p">=</span> <span class="mi">2</span>
        <span class="nx">SearchRequest_LOCAL</span>     <span class="nx">SearchRequest_Corpus</span> <span class="p">=</span> <span class="mi">3</span>
        <span class="nx">SearchRequest_NEWS</span>      <span class="nx">SearchRequest_Corpus</span> <span class="p">=</span> <span class="mi">4</span>
        <span class="nx">SearchRequest_PRODUCTS</span>  <span class="nx">SearchRequest_Corpus</span> <span class="p">=</span> <span class="mi">5</span>
        <span class="nx">SearchRequest_VIDEO</span>     <span class="nx">SearchRequest_Corpus</span> <span class="p">=</span> <span class="mi">6</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>对于包级枚举，常量以枚举名称开头：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
        <span class="nx">Foo_DEFAULT_BAR</span> <span class="nx">Foo</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="nx">Foo_BAR_BELLS</span>   <span class="nx">Foo</span> <span class="p">=</span> <span class="mi">1</span>
        <span class="nx">Foo_BAR_B_CUE</span>   <span class="nx">Foo</span> <span class="p">=</span> <span class="mi">2</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>protobuf编译器还会生成一个从整数值到字符串名称的映射以及从名称到值的映射：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">Foo_name</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int32</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="s">&#34;DEFAULT_BAR&#34;</span><span class="p">,</span>
        <span class="mi">1</span><span class="p">:</span> <span class="s">&#34;BAR_BELLS&#34;</span><span class="p">,</span>
        <span class="mi">2</span><span class="p">:</span> <span class="s">&#34;BAR_B_CUE&#34;</span><span class="p">,</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">Foo_value</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int32</span><span class="p">{</span>
        <span class="s">&#34;DEFAULT_BAR&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s">&#34;BAR_BELLS&#34;</span><span class="p">:</span>   <span class="mi">1</span><span class="p">,</span>
        <span class="s">&#34;BAR_B_CUE&#34;</span><span class="p">:</span>   <span class="mi">2</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>请注意，.proto语言允许多个枚举符号具有相同的数值。 具有相同数值的符号是同义词。 这些在Go中以完全相同的方式表示，具有对应于相同数值的多个名称。 反向映射包含一个将数字值输入到.proto文件中最先出现的名称的条目。</p>
<h2 id="服务">服务<a hidden class="anchor" aria-hidden="true" href="#服务">#</a></h2>
<p>默认情况下，Go代码生成器不会为服务生成输出。如果启用了gRPC插件（请参阅 gRPC Go快速入门指南），那么将生成支持gRPC的代码。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/protobuf/">protobuf</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
