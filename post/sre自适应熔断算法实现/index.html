<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>SRE自适应熔断算法实现 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="前言 断路器(Circuit Breakers): 为了限制操作的持续时间，我们可以使用超时，超时可以防止挂起操作并保证系统可以响应。因为我们处于高度动态的环境中，" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.92.1 with theme even" />


<link rel="canonical" href="/post/sre%E8%87%AA%E9%80%82%E5%BA%94%E7%86%94%E6%96%AD%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="SRE自适应熔断算法实现" />
<meta property="og:description" content="前言 断路器(Circuit Breakers): 为了限制操作的持续时间，我们可以使用超时，超时可以防止挂起操作并保证系统可以响应。因为我们处于高度动态的环境中，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/sre%E8%87%AA%E9%80%82%E5%BA%94%E7%86%94%E6%96%AD%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-03-21T10:36:35+00:00" />
<meta property="article:modified_time" content="2021-03-21T10:36:35+00:00" />

<meta itemprop="name" content="SRE自适应熔断算法实现">
<meta itemprop="description" content="前言 断路器(Circuit Breakers): 为了限制操作的持续时间，我们可以使用超时，超时可以防止挂起操作并保证系统可以响应。因为我们处于高度动态的环境中，"><meta itemprop="datePublished" content="2021-03-21T10:36:35+00:00" />
<meta itemprop="dateModified" content="2021-03-21T10:36:35+00:00" />
<meta itemprop="wordCount" content="5017">
<meta itemprop="keywords" content="服务治理," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SRE自适应熔断算法实现"/>
<meta name="twitter:description" content="前言 断路器(Circuit Breakers): 为了限制操作的持续时间，我们可以使用超时，超时可以防止挂起操作并保证系统可以响应。因为我们处于高度动态的环境中，"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">SRE自适应熔断算法实现</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-03-21 </span>
        <div class="post-category">
            <a href="/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"> 服务治理 </a>
            </div>
          <span class="more-meta"> 约 5017 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#算法原理">算法原理</a></li>
    <li><a href="#全局变量">全局变量</a></li>
    <li><a href="#熔断器-breaker">熔断器: breaker</a></li>
    <li><a href="#熔断器组-group">熔断器组: Group</a></li>
    <li><a href="#srebreaker">sreBreaker</a></li>
    <li><a href="#初始化-sre">初始化 SRE</a></li>
    <li><a href="#marksuccess--markfailed">MarkSuccess &amp; MarkFailed</a></li>
    <li><a href="#熔断判定-allow">熔断判定: Allow</a></li>
    <li><a href="#一般使用">一般使用</a></li>
    <li><a href="#降级策略">降级策略</a>
      <ul>
        <li><a href="#降级方案">降级方案</a></li>
        <li><a href="#降级---case-study">降级 - Case Study</a></li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="前言">前言</h2>
<p>断路器(Circuit Breakers): 为了限制操作的持续时间，我们可以使用超时，超时可以防止挂起操作并保证系统可以响应。因为我们处于高度动态的环境中，几乎不可能确定在每种情况下都能正常工作的准确的时间限制。断路器以现实世界的电子元件命名，因为它们的行为是都是相同的。断路器在分布式系统中非常有用，因为重复的故障可能会导致雪球效应，并使整个系统崩溃。</p>
<ul>
<li>服务依赖的资源出现大量错误。</li>
<li>某个用户超过资源配额时，后端任务会快速拒绝请求，返回“配额不足”的错误，但是拒绝回复仍然会消耗一定资源。有可能后端忙着不停发送拒绝请求，导致过载。</li>
</ul>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210113223815.png" alt=""></p>
<p>这类熔断算法的算法核心是：当请求失败比率达到一定阈值之后，熔断器开启，并休眠一段时间（由配置决定），这段休眠期过后，熔断器将处于半开状态，在此状态下将试探性的放过一部分流量，如果这部分流量调用成功后，再次将熔断器关闭，否则熔断器继续保持开启并进入下一轮休眠周期。</p>
<p>但这个熔断算法有一个问题，过于一刀切。是否可以做到在熔断器开启状态下（但是后端未 Shutdown）仍然可以放行少部分流量呢？当然，这里有个前提，需要看后端此时还能够接受多少流量。下一步我们来看看 Google 的策略实现。</p>
<h2 id="算法原理">算法原理</h2>
<p>We implemented client-side throttling through a technique we call adaptive throttling：该算法称为（客户端）自适应限流。</p>
<p>现实中，过载是极易发生的异常状态： 一方面，当客户端检测到最近的请求出现错误都是 “out of quota（配额不足）”，说明可能这个客户端超过了资源配额，后端任务会快速拒绝请求，返回 “配额不足” 的错误，有可能后端忙着不停发送拒绝请求，导致过载； 另一方面，当依赖的资源出现大量错误，处于对下游的保护，也需要在客户端本地进行限流操作</p>
<p>解决的办法就是客户端自行限制请求速度，限制生成请求的数量, 超过这个数量的请求直接在本地回复失败，而不会真是发送到服务端</p>
<p>该算法统计的指标依赖如下两种，每个客户端记录过去两分钟内的以下信息（一般代码中以滑动窗口实现）：</p>
<ul>
<li>
<p>requests（客户端尝试的请求数）： The number of requests attempted by the application layer(at the client, on top of the adaptive throttling system)</p>
</li>
<li>
<p>accepts 后端接受的请求数(客户端发送的请求数-后端拒绝的请求数量)： The number of requests accepted by the backend</p>
</li>
</ul>
<p>该算法的通用描述如下：</p>
<ol>
<li>在通常情况下（无错误发生时） requests==accepts</li>
<li>当后端出现异常情况时，accepts 的数量会逐渐小于 requests</li>
<li>当后端持续异常时，客户端可以继续发送请求直到 requests=K×accepts，一旦超过这个值，客户端就启动自适应限流机制，新产生的请求在本地会以 p 概率（下面描述的 Client request rejection probability 定义）被拒绝</li>
<li>当客户端主动丢弃请求时，requests 值会一直增大，在某个时间点会超过 K×accepts，使概率 p 计算出来的值大于 0，此时客户端会以此概率对请求做主动丢弃。</li>
<li>当后端逐渐恢复时，accepts 增加，（同时 requests 值也会增加，但是由于 K 的关系，K×accepts 的放大倍数更快），使得<code>(requests−K×accepts)/(requests+1)</code>变为负数，从而概率 p==0，客户端自适应限流结束</li>
</ol>
<p>客户端请求拒绝的概率（Client request rejection probability）基于如下公式计算（其中 K 为倍率 - multiplier，常用的值为 2）：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210321203250.png" alt=""></p>
<p>该公式的解释如下： 当 requests−K×accepts&gt;=0 时，概率 p==0，客户端不会主动丢弃请求；反之，则概率 p，会随着 accepts 值的变小而增加，即成功接受的请求数越少，本地丢弃请求的概率就越高。通俗点说，Client 可以发送请求直到 requests=K×accepts，一旦超过限制，按照概率进行截流。</p>
<p>从 Google 的文档描述中，该算法在实际中使用效果极为良好，可以使整体上保持一个非常稳定的请求速率。对于后端而言，调整 K 值可以使得自适应限流算法适配不同的后端。关于 K 值的意义，原文描述如下：</p>
<ul>
<li>Reducing the multiplier will make adaptive throttling behave more aggressively</li>
<li>Increasing the multiplier will make adaptive throttling behave less aggressively</li>
</ul>
<p>翻译上面两句话就是：</p>
<ul>
<li>降低 K 值会使自适应限流算法更加激进（允许客户端在算法启动时拒绝更多本地请求）</li>
<li>增加 K 值会使自适应限流算法不再那么激进（允许服务端在算法启动时尝试接收更多的请求，与上面相反）</li>
</ul>
<p>通过修改算法中的K(倍值)，可以调节熔断器的敏感度，当降低该倍值会使自适应熔断算法更敏感，当增加该倍值会使得自适应熔断算法降低敏感度，举例来说，假设将调用方的请求上限从 <code>requests = 2 * acceptst</code> 调整为 <code>requests = 1.1 * accepts</code> 那么就意味着调用方每十个请求之中就有一个请求会触发熔断</p>
<h2 id="全局变量">全局变量</h2>
<p>在 breaker.go) 中定义了 3 个全局变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
<span class="nx">_mu</span>   <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
<span class="nx">_conf</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Config</span><span class="p">{</span>
    <span class="nx">Window</span><span class="p">:</span>  <span class="nx">xtime</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">),</span>
    <span class="nx">Bucket</span><span class="p">:</span>  <span class="mi">10</span><span class="p">,</span>
    <span class="nx">Request</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>

    <span class="c1">// Percentage of failures must be lower than 33.33%
</span><span class="c1"></span>    <span class="nx">K</span><span class="p">:</span> <span class="mf">1.5</span><span class="p">,</span>

    <span class="c1">// Pattern: &#34;&#34;,
</span><span class="c1"></span><span class="p">}</span>
<span class="nx">_group</span> <span class="p">=</span> <span class="nf">NewGroup</span><span class="p">(</span><span class="nx">_conf</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="熔断器-breaker">熔断器: breaker</h2>
<p>熔断器 breaker 的公共部分封装 在此，包含了熔断器的实现接口、熔断器组的定义，以及配置等等。</p>
<p>单个熔断器的接口定义如下：</p>
<ul>
<li>Allow 方法：每次 RPC、接口调用时均会调用，用来判断是否在熔断状态，根据结果（error）来决定后续动作</li>
<li>MarkSuccess：每次 RPC 接口完成后，上报 Succ 状态（Kratos 中用 RollingPolicy 结构）</li>
<li>MarkFailed：每次 RPC 接口完成后，上报 Failed 状态</li>
</ul>
<p>MarkSuccess 和 MarkFailed 都是用来完成熔断器状态检测的计算依据，所以针对何种错误下进行标记十分重要。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Breaker is a CircuitBreaker pattern.
</span><span class="c1">// FIXME on int32 atomic.LoadInt32(&amp;b.on) == _switchOn
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Breaker</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Allow</span><span class="p">()</span> <span class="kt">error</span>
	<span class="nf">MarkSuccess</span><span class="p">()</span>
	<span class="nf">MarkFailed</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>熔断器的配置 Config：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Config</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">K</span> <span class="kt">float64</span>  <span class="c1">// 触发熔断的错误率（K = 1 - 1 / 错误率）
</span><span class="c1"></span>	<span class="nx">Window</span>  <span class="nx">xtime</span><span class="p">.</span><span class="nx">Duration</span> <span class="c1">// 统计桶窗口时间
</span><span class="c1"></span>	<span class="nx">Bucket</span>  <span class="kt">int</span>  <span class="c1">// 统计桶大小
</span><span class="c1"></span>	<span class="nx">Request</span> <span class="kt">int64</span> <span class="c1">// 触发熔断的最少请求数量（请求少于该值时不会触发熔断）
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>newBreaker 方法，生成一个 breaker 对象，其中 newSRE 是创建对应的熔断器对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// newBreaker new a breaker.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newBreaker</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Config</span><span class="p">)</span> <span class="p">(</span><span class="nx">b</span> <span class="nx">Breaker</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// factory
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">newSRE</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="熔断器组-group">熔断器组: Group</h2>
<p>熔断器组的定义如下，注意 brks 是一个 map，以不通的 key 标识不同的熔断器，比如在 gRPC 中，我们可能对每个不同的 RPC 方法创建熔断器，那么使用 RPC 的名字作为 key 就非常合适。此外 Breaker 是 interface{} 类型，这里会被实例化为用户实现的熔断器类型，比如 Kratos 中的 SREBreaker：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Group represents a class of CircuitBreaker and forms a namespace in which
</span><span class="c1">// units of CircuitBreaker.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Group</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">mu</span>   <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>		<span class="c1">// 用来保护 brks 并发
</span><span class="c1"></span>	<span class="nx">brks</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">Breaker</span>
	<span class="nx">conf</span> <span class="o">*</span><span class="nx">Config</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>和 Group 有关的操作如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NewGroup new a breaker group container, if conf nil use default conf.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewGroup</span><span class="p">(</span><span class="nx">conf</span> <span class="o">*</span><span class="nx">Config</span><span class="p">)</span><span class="o">*</span><span class="nx">Group</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">conf</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">_mu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
		<span class="nx">conf</span> <span class="p">=</span><span class="nx">_conf</span>
		<span class="nx">_mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">conf</span><span class="p">.</span><span class="nf">fix</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 构建 group 组
</span><span class="c1"></span>	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Group</span><span class="p">{</span>
		<span class="nx">conf</span><span class="p">:</span> <span class="nx">conf</span><span class="p">,</span>
		<span class="nx">brks</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">Breaker</span><span class="p">),</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Get get a breaker by a specified key, if breaker not exists then make a new one.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">Group</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Breaker</span> <span class="p">{</span>
	<span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
	<span class="nx">brk</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">brks</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
	<span class="nx">conf</span> <span class="o">:=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">conf</span>
	<span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="c1">// 如果 key 对应的 Breaker 存在，则直接返回
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">brk</span>
	<span class="p">}</span>
	<span class="c1">// 否则创建一个新的熔断器，并返回
</span><span class="c1"></span>	<span class="nx">brk</span> <span class="p">=</span> <span class="nf">newBreaker</span><span class="p">(</span><span class="nx">conf</span><span class="p">)</span>
	<span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">if_</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">brks</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">g</span><span class="p">.</span><span class="nx">brks</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">brk</span>
	<span class="p">}</span>
	<span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">brk</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Reload 方法，重新（按照传入的 conf 配置）初始化熔断器组：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Reload reload the group by specified config, this may let all inner breaker
</span><span class="c1">// reset to a new one.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">Group</span><span class="p">)</span> <span class="nf">Reload</span><span class="p">(</span><span class="nx">conf</span><span class="o">*</span><span class="nx">Config</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">conf</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">conf</span><span class="p">.</span><span class="nf">fix</span><span class="p">()</span>
	<span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">g</span><span class="p">.</span><span class="nx">conf</span> <span class="p">=</span> <span class="nx">conf</span>
	<span class="nx">g</span><span class="p">.</span><span class="nx">brks</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">Breaker</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">brks</span><span class="p">))</span>
	<span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Go 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Go runs your function while tracking the breaker state of group.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">Group</span><span class="p">)</span> <span class="nf">Go</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">run</span><span class="p">,</span> <span class="nx">fallback</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">breaker</span> <span class="o">:=</span> <span class="nx">g</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">breaker</span><span class="p">.</span><span class="nf">Allow</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">fallback</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">run</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>此外，Breaker 还暴露了一个使用默认熔断器（全局变量）配置的 Go 方法，应用程序可以直接调用，就像 hystix-Go 的 Go 方法那样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Go runs your function while tracking the breaker state of default group.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Go</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">run</span><span class="p">,</span> <span class="nx">fallback</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">breaker</span> <span class="o">:=</span> <span class="nx">_group</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">breaker</span><span class="p">.</span><span class="nf">Allow</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">fallback</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">run</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="srebreaker">sreBreaker</h2>
<p>SRE-Breaker 是 Breaker 的实现（的一种），按照 Breaker 定义的接口描述实现了具体的功能。</p>
<p>首先看下 sreBreaker 的定义，它使用了 metric.RollingCounter 作为统计结构，这也比较好理解，对于熔断器的判定指标，只需要关注一段时间内，正确响应和失败响应这两个指标的数量即可。另外，使用 rand.Rand 生成一个随机数，用来与 <strong>客户端请求拒绝的概率</strong> 做比较.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// sreBreaker is a sre CircuitBreaker pattern.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">sreBreaker</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">stat</span> <span class="nx">metric</span><span class="p">.</span><span class="nx">RollingCounter</span>
	<span class="nx">r</span>    <span class="o">*</span><span class="nx">rand</span><span class="p">.</span><span class="nx">Rand</span>
	<span class="c1">// rand.New(...) returns a non thread safe object
</span><span class="c1"></span>	<span class="nx">randLock</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>

	<span class="nx">k</span>       <span class="kt">float64</span>		<span class="c1">// 比率
</span><span class="c1"></span>	<span class="nx">request</span> <span class="kt">int64</span>

	<span class="nx">state</span> <span class="kt">int32</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="初始化-sre">初始化 SRE</h2>
<p>通过 newSRE 来创建一个 SreBreaker：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newSRE</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Config</span><span class="p">)</span> <span class="nx">Breaker</span> <span class="p">{</span>
	<span class="nx">counterOpts</span> <span class="o">:=</span> <span class="nx">metric</span><span class="p">.</span><span class="nx">RollingCounterOpts</span><span class="p">{</span>
		<span class="nx">Size</span><span class="p">:</span>           <span class="nx">c</span><span class="p">.</span><span class="nx">Bucket</span><span class="p">,</span>		<span class="c1">// 滑动窗口的桶数
</span><span class="c1"></span>		<span class="nx">BucketDuration</span><span class="p">:</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Window</span><span class="p">)</span> <span class="o">/</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Bucket</span><span class="p">)),</span>
	<span class="p">}</span>
	<span class="c1">// 创建 NewRollingCounter
</span><span class="c1"></span>	<span class="nx">stat</span> <span class="o">:=</span> <span class="nx">metric</span><span class="p">.</span><span class="nf">NewRollingCounter</span><span class="p">(</span><span class="nx">counterOpts</span><span class="p">)</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">sreBreaker</span><span class="p">{</span>
		<span class="nx">stat</span><span class="p">:</span> <span class="nx">stat</span><span class="p">,</span>
		<span class="nx">r</span><span class="p">:</span>    <span class="nx">rand</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">NewSource</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">())),</span>

		<span class="nx">request</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span><span class="c1">// 触发熔断的最少请求数量（请求少于该值时不会触发熔断）
</span><span class="c1"></span>		<span class="nx">k</span><span class="p">:</span>       <span class="nx">c</span><span class="p">.</span><span class="nx">K</span><span class="p">,</span>
		<span class="nx">state</span><span class="p">:</span>   <span class="nx">StateClosed</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="marksuccess--markfailed">MarkSuccess &amp; MarkFailed</h2>
<p>在 SreBreaker 中简单封装了RollingCounter 的 Add 操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">sreBreaker</span><span class="p">)</span> <span class="nf">MarkSuccess</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 接口调用成功
</span><span class="c1"></span>	<span class="nx">b</span><span class="p">.</span><span class="nx">stat</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">sreBreaker</span><span class="p">)</span> <span class="nf">MarkFailed</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// NOTE: when client reject requets locally, continue add counter let the
</span><span class="c1"></span>	<span class="c1">// drop ratio higher.
</span><span class="c1"></span>	<span class="c1">// 接口调用失败
</span><span class="c1"></span>	<span class="nx">b</span><span class="p">.</span><span class="nx">stat</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="熔断判定-allow">熔断判定: Allow</h2>
<p>Allow 方法是 Breaker 判定的核心方法，在每次服务端执行真正的 RPC 请求前都需要调用 Allow 方法来进行熔断状态判定，Allow 方法的大致流程如下：</p>
<ol>
<li>通过 summary() 方法拿到当前滑动窗口 metric.RollingCounter 中统计的（滑动窗口）成功量 success 和请求总量 total</li>
<li>根据 GoogleSRE 算法来进行熔断状态判定：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">sreBreaker</span><span class="p">)</span> <span class="nf">Allow</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">// b.summary() -- 从滑动窗口中拿到
</span><span class="c1"></span>	<span class="nx">success</span><span class="p">,</span> <span class="nx">total</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">summary</span><span class="p">()</span>
	<span class="nx">k</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">k</span> <span class="o">*</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">success</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">log</span><span class="p">.</span><span class="nf">V</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="s">&#34;breaker: request: %d, succee: %d, fail: %d&#34;</span><span class="p">,</span> <span class="nx">total</span><span class="p">,</span> <span class="nx">success</span><span class="p">,</span> <span class="nx">total</span><span class="o">-</span><span class="nx">success</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// check overflow requests = K * success
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">total</span> <span class="p">&lt;</span><span class="nx">b</span><span class="p">.</span><span class="nx">request</span> <span class="o">||</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">total</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">k</span> <span class="p">{</span>
		<span class="c1">// total &lt;= K * success 时，关闭熔断；
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">.</span><span class="nx">state</span><span class="p">)</span> <span class="o">==</span> <span class="nx">StateOpen</span> <span class="p">{</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">StateOpen</span><span class="p">,</span> <span class="nx">StateClosed</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="c1">// 否则，熔断器开启（说明 total &gt; K * success）
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">.</span><span class="nx">state</span><span class="p">)</span> <span class="o">==</span> <span class="nx">StateClosed</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">StateClosed</span><span class="p">,</span> <span class="nx">StateOpen</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 根据 googleSRE 的算法计算拿到客户端请求拒绝的概率
</span><span class="c1"></span>	<span class="nx">dr</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">total</span><span class="p">)</span><span class="o">-</span><span class="nx">k</span><span class="p">)</span><span class="o">/</span><span class="nb">float64</span><span class="p">(</span><span class="nx">total</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
	<span class="c1">// 概率判定，返回 true OR false
</span><span class="c1"></span>	<span class="nx">drop</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">trueOnProba</span><span class="p">(</span><span class="nx">dr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">log</span><span class="p">.</span><span class="nf">V</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="s">&#34;breaker: drop ratio: %f, drop: %t&#34;</span><span class="p">,</span> <span class="nx">dr</span><span class="p">,</span> <span class="nx">drop</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">drop</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ecode</span><span class="p">.</span><span class="nx">ServiceUnavailable</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>进行统计的方法 summary 实现如下，调用 RollingCounter.Reduce 方法，累加滑动窗口 Bucket 中的 bucket.Count 和 bucket.Points：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">sreBreaker</span><span class="p">)</span> <span class="nf">summary</span><span class="p">()</span> <span class="p">(</span><span class="nx">success</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">total</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">stat</span><span class="p">.</span><span class="nf">Reduce</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">iterator</span> <span class="nx">metric</span><span class="p">.</span><span class="nx">Iterator</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">iterator</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">bucket</span> <span class="o">:=</span> <span class="nx">iterator</span><span class="p">.</span><span class="nf">Bucket</span><span class="p">()</span>
			<span class="nx">total</span> <span class="o">+=</span> <span class="nx">bucket</span><span class="p">.</span><span class="nx">Count</span>
			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">bucket</span><span class="p">.</span><span class="nx">Points</span> <span class="p">{</span>
				<span class="nx">success</span> <span class="o">+=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">})</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>而 trueOnProba 方法就是产生一个 0-1 之间的浮点数，和 proba 进行比较，间接实现了比较大小得出某个概率的方法,其中 b.r.Float64() 的 r 为 *rand.Rand 类型，此方法返回一个取值范围在 [0.0, 1.0) 的伪随机 Float64 值。 当 proba 越大时，truth 为真的概率就越大。有个细节是 b.r.Float64() 是非线程安全的，所以加了 Lock：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">sreBreaker</span><span class="p">)</span> <span class="nf">trueOnProba</span><span class="p">(</span><span class="nx">proba</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">(</span><span class="nx">truth</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">randLock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">truth</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nf">Float64</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">proba</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">randLock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="一般使用">一般使用</h2>
<p>客户端场景可以使用熔断器来进行服务保护：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;github.com/go-kratos/kratos/pkg/net/netutil/breaker&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 初始化熔断器组
</span><span class="c1"></span>	<span class="c1">// 一组熔断器公用同一个配置项，可从分组内取出单个熔断器使用。可用在比如 mysql 主从分离等场景。
</span><span class="c1"></span>	<span class="nx">brkGroup</span> <span class="o">:=</span> <span class="nx">breaker</span><span class="p">.</span><span class="nf">NewGroup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">breaker</span><span class="p">.</span><span class="nx">Config</span><span class="p">{})</span>
	<span class="c1">// 为每一个连接指定一个 brekaker
</span><span class="c1"></span>	<span class="c1">// 此处假设一个客户端连接对象实例为 conn
</span><span class="c1"></span>	<span class="c1">// breakName 定义熔断器名称 一般可以使用连接地址
</span><span class="c1"></span>	<span class="nx">breakName</span> <span class="p">=</span> <span class="nx">conn</span><span class="p">.</span><span class="nx">Addr</span>
	<span class="nx">conn</span><span class="p">.</span><span class="nx">breaker</span> <span class="p">=</span> <span class="nx">brkGroup</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">breakName</span><span class="p">)</span>
	<span class="c1">// 在连接发出请求前判断熔断器状态
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nx">breaker</span><span class="p">.</span><span class="nf">Allow</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 连接执行成功或失败将结果告知 breaker
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">respErr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">conn</span><span class="p">.</span><span class="nx">breaker</span><span class="p">.</span><span class="nf">MarkFailed</span><span class="p">()</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">conn</span><span class="p">.</span><span class="nx">breaker</span><span class="p">.</span><span class="nf">MarkSuccess</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="降级策略">降级策略</h2>
<p>配置自动熔断降级前，首先我们需要识别出可能出现不稳定的服务，然后判断其是否可降级。降级处理通常是快速失败，当然我们业可以自定义降级处理结果（Fallback），例如：尝试包装返回默认结果（兜底降级），返回上一次请求的缓存结果（时效性降级），包装返回处理失败的提示结果等。</p>
<p>对弱依赖和次要功能的降级通常是人工推送开关来完成的，而Sentinel的熔断降级主要是在“调用端”自动判断并执行的，Sentinel基于规则中配置的时间窗口内的平均响应时间、错误比例、错误数等统计指标来执行自动熔断降级。</p>
<p>举个例子：我们系统同时支持“余额支付”和“银行卡支付”，这两个功能对应的接口默认在相同应用的同一线程池中，任何一方出现RT抖动和大量超时都可能请求积压并导致线程池被耗尽。假设从业务角度来看“余额支付”的比例更高，保障的优先级也更高。那么我们可以在检查到 “银行卡支付”接口（依赖第三方，不稳定）中RT持续上升或者发生大量异常时对其执行“自动熔断降级”（前提是不能导致数据不一致等影响业务流程的问题），这样优先保证“余额支付”的功能可以继续正常使用。</p>
<p>通过降级回复来减少工作量，或者丢弃不重要的请求。而且需要了解哪些流量可以降级，并且有能力区分不同的请求。我们通常提供降低回复的质量来答复减少所需的计算量或者时间。我们自动降级通常需要考虑几个点：</p>
<ul>
<li>确定具体采用哪个指标作为流量评估和优雅降级的决定性指标(如，CPU、延迟、队列长度、线程数量、错误等)。</li>
<li>当服务进入降级模式时，需要执行什么动作？
<ul>
<li>从远程缓存返回数据</li>
<li>从本地缓存返回数据</li>
<li>返回空回复</li>
</ul>
</li>
<li>流量抛弃或者优雅降级应该在服务的哪一层实现？是否需要在整个服务的每一层都实现，还是可以选择某个高层面的关键节点来实现？</li>
</ul>
<p>同时我们要考虑一下几点：</p>
<ul>
<li>优雅降级不应该被经常触发 - 通常触发条件显示了容量规划的失误，或者是意外的负载。</li>
<li>演练，代码平时不会触发和使用，需要定期针对一小部分的流量进行演练，保证模式的正常。</li>
<li>应该足够简单。</li>
</ul>
<h3 id="降级方案">降级方案</h3>
<p>降级本质为: 提供有损服务。</p>
<ul>
<li>UI 模块化，非核心模块降级。
<ul>
<li>BFF 层聚合 API，模块降级。</li>
</ul>
</li>
<li>页面上一次缓存副本。</li>
<li>默认值、热门推荐等。</li>
<li>流量拦截 + 定期数据缓存(过期副本策略)。
处理策略</li>
<li>页面降级、延迟服务、写/读降级、缓存降级</li>
<li>抛异常、返回约定协议、Mock 数据、Fallback 处理</li>
</ul>
<h3 id="降级---case-study">降级 - Case Study</h3>
<ul>
<li>客户端解析协议失败，app 奔溃。</li>
<li>客户端部分协议不兼容，导致页面失败。</li>
<li>local cache 数据源缓存，发版失效 + 依赖接口故障，引起的白屏。
<ul>
<li>local cache 在 remote cache缓存一份,双保险.</li>
</ul>
</li>
<li>没有 playbook，导致的 MTTR 上升。</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://pandaychen.github.io/2020/07/12/KRATOS-BREAKER-ANALYSIS/">Kratos 源码分析：熔断器 Breaker</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-03-21
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/">服务治理</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/pkg-errors%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">pkg-errors使用介绍</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99docker%E9%95%9C%E5%83%8F/">
            <span class="next-text nav-default">如何编写Docker镜像</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
