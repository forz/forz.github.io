<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Forz Blog</title>
    <link>/post/</link>
    <description>Recent content in Posts on Forz Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 24 Jan 2021 11:29:23 +0000</lastBuildDate>
    
	<atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>负载均衡P2C&#43;EWMA算法</title>
      <link>/post/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1p2c&#43;ewma%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 24 Jan 2021 11:29:23 +0000</pubDate>
      
      <guid>/post/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1p2c&#43;ewma%E7%AE%97%E6%B3%95/</guid>
      <description>P2C算法 介绍 常见的Load balance算法想必大家都不陌生，Random、Round-robin、Least connection、Con</description>
    </item>
    
    <item>
      <title>GRPC的服务发现与负载均衡</title>
      <link>/post/grpc%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</link>
      <pubDate>Fri, 22 Jan 2021 23:13:10 +0000</pubDate>
      
      <guid>/post/grpc%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</guid>
      <description>负载均衡的方法 构建高可用、高性能的通信服务，通常采用服务注册与发现、负载均衡和容错处理等机制实现。根据负载均衡实现所在的位置不同，通常可分为</description>
    </item>
    
    <item>
      <title>GRPC的ClientConn源码剖析</title>
      <link>/post/grpc%E7%9A%84clientconn%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Fri, 22 Jan 2021 18:03:09 +0000</pubDate>
      
      <guid>/post/grpc%E7%9A%84clientconn%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description>ClientConn 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69</description>
    </item>
    
    <item>
      <title>Go实现分片锁</title>
      <link>/post/go%E5%AE%9E%E7%8E%B0%E5%88%86%E7%89%87%E9%94%81/</link>
      <pubDate>Tue, 19 Jan 2021 17:01:41 +0000</pubDate>
      
      <guid>/post/go%E5%AE%9E%E7%8E%B0%E5%88%86%E7%89%87%E9%94%81/</guid>
      <description>虽然使用读写锁可以提供线程安全的 map,但是在大量并发读写的情况下,锁的竞争会非常激烈。锁是性能下降的万恶之源之一。 在并发编程中,我们的一条</description>
    </item>
    
    <item>
      <title>Go的同步原语源码剖析</title>
      <link>/post/go%E7%9A%84%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Thu, 14 Jan 2021 15:58:21 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description>基本原语 Go 语言在 sync 包中提供了用于同步的一些基本原语，包括常见的 sync.Mutex、sync.RWMutex、sync.WaitGroup、</description>
    </item>
    
    <item>
      <title>使用commitizen规范Git提交说明</title>
      <link>/post/%E4%BD%BF%E7%94%A8commitizen%E8%A7%84%E8%8C%83git%E6%8F%90%E4%BA%A4%E8%AF%B4%E6%98%8E/</link>
      <pubDate>Tue, 12 Jan 2021 18:25:52 +0000</pubDate>
      
      <guid>/post/%E4%BD%BF%E7%94%A8commitizen%E8%A7%84%E8%8C%83git%E6%8F%90%E4%BA%A4%E8%AF%B4%E6%98%8E/</guid>
      <description>前言 Git 每次提交代码时，都需要写 Commit Message (提交说明)，否则就不允许提交。 1 git commit -m &amp;#39;第一次提交&amp;#39; 在工作中一份清晰简介规范的 Commit Message 能让后</description>
    </item>
    
    <item>
      <title>Go中的测试技巧</title>
      <link>/post/go%E4%B8%AD%E7%9A%84%E6%B5%8B%E8%AF%95%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Mon, 11 Jan 2021 21:51:22 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E7%9A%84%E6%B5%8B%E8%AF%95%E6%8A%80%E5%B7%A7/</guid>
      <description>前言 Go 使编写测试非常简单。实际上，测试工具是内置在标准工具链里的，你可以简单地运行 go test 来运行你的测试，无需安装任何额外的依赖或任何别的东西。</description>
    </item>
    
    <item>
      <title>Go如何生成随机数</title>
      <link>/post/go%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</link>
      <pubDate>Sat, 09 Jan 2021 23:44:37 +0000</pubDate>
      
      <guid>/post/go%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</guid>
      <description>math/rand 包 math/rand 包实现了伪随机数生成器 主要方法 （1）func Seed(seed int64) 设置随机种子，不设置则默认Seed(1) （2）func Int() int 返回一个非负的伪随机int值</description>
    </item>
    
    <item>
      <title>Gotest禁用测试缓存</title>
      <link>/post/gotest%E7%A6%81%E7%94%A8%E6%B5%8B%E8%AF%95%E7%BC%93%E5%AD%98/</link>
      <pubDate>Sat, 09 Jan 2021 23:40:03 +0000</pubDate>
      
      <guid>/post/gotest%E7%A6%81%E7%94%A8%E6%B5%8B%E8%AF%95%E7%BC%93%E5%AD%98/</guid>
      <description>背景 项目开发在做单元测试， 发现跑测试 cases 的时候，每一个跑完，日志后都带有一个 (cached) 的标志。尽管代码的实现已经做了修改（比如返回不同数据）， 但是发现</description>
    </item>
    
    <item>
      <title>Go的条件编译</title>
      <link>/post/go%E7%9A%84%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/</link>
      <pubDate>Sat, 09 Jan 2021 17:09:59 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/</guid>
      <description>前言 Go语言可以通过go/build包里定义的tags和命名约定来让Go的包可以运行不同的代码。 在源代码里添加标注，通常称之为编译标签（bu</description>
    </item>
    
    <item>
      <title>如何实现gin的timeout-Middleware</title>
      <link>/post/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0gin%E7%9A%84timeout-middleware/</link>
      <pubDate>Sat, 09 Jan 2021 14:59:04 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0gin%E7%9A%84timeout-middleware/</guid>
      <description>前言 说到Golang中应用最广泛的web框架，恐怕非gin-gonic/gin莫属了。在服务中，如果它依赖的后端服务出现异常，我们希望错误能</description>
    </item>
    
    <item>
      <title>Godoc介绍</title>
      <link>/post/godoc%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Sun, 03 Jan 2021 16:23:49 +0000</pubDate>
      
      <guid>/post/godoc%E4%BB%8B%E7%BB%8D/</guid>
      <description>go doc go doc命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。 所谓Go语言的程</description>
    </item>
    
    <item>
      <title>Yaml语法介绍</title>
      <link>/post/yaml%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Tue, 29 Dec 2020 19:53:37 +0000</pubDate>
      
      <guid>/post/yaml%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D/</guid>
      <description>简介 YAML 是 &amp;ldquo;YAML Ain&amp;rsquo;t a Markup Language&amp;rdquo;（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：&amp;ldquo</description>
    </item>
    
    <item>
      <title>Go的栈空间管理源码剖析</title>
      <link>/post/go%E7%9A%84%E6%A0%88%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Fri, 18 Dec 2020 17:46:19 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E6%A0%88%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description>设计原理 栈区的内存一般由编译器自动进行分配和释放，其中存储着函数的入参以及局部变量，这些参数会随着函数的创建而创建，函数的返回而消亡，一般不</description>
    </item>
    
    <item>
      <title>Go服务的优雅关闭与重启</title>
      <link>/post/go%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BC%98%E9%9B%85%E5%85%B3%E9%97%AD%E4%B8%8E%E9%87%8D%E5%90%AF/</link>
      <pubDate>Fri, 11 Dec 2020 14:13:08 +0000</pubDate>
      
      <guid>/post/go%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BC%98%E9%9B%85%E5%85%B3%E9%97%AD%E4%B8%8E%E9%87%8D%E5%90%AF/</guid>
      <description>背景 在业务快速增长中，前期只是验证模式是否可行，初期忽略程序发布重启带来的暂短停机影响。当模式实验成熟之后会逐渐放量，此时我们的发布停机带来</description>
    </item>
    
    <item>
      <title>Go中的信号处理</title>
      <link>/post/go%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</link>
      <pubDate>Wed, 09 Dec 2020 14:50:42 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</guid>
      <description>信号 信号是事件发生时对进程的通知机制。有时也称之为软件中断。信号与硬件中断的相似之处在于打断了程序执行的正常流程，大多数情况下，无法预测信号</description>
    </item>
    
    <item>
      <title>并发情况的错误处理:errgroup</title>
      <link>/post/%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86errgroup/</link>
      <pubDate>Tue, 08 Dec 2020 11:23:21 +0000</pubDate>
      
      <guid>/post/%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86errgroup/</guid>
      <description>文档 概述 程序包errgroup为在常规任务的子任务上工作的goroutine组提供同步，错误传播和上下文取消。 type Group 1 2 3 type Group struct { // contains filtered or unexported fields</description>
    </item>
    
    <item>
      <title>Go中的Data-Race</title>
      <link>/post/go%E4%B8%AD%E7%9A%84data-race/</link>
      <pubDate>Tue, 08 Dec 2020 18:27:35 +0800</pubDate>
      
      <guid>/post/go%E4%B8%AD%E7%9A%84data-race/</guid>
      <description>数据竞争与竞态条件 数据竞争 定义：①多个线程对于同一个变量、②同时地、③进行读/写操作的现象并且④至少有一个线程进行写操作。（也就是说，如果所</description>
    </item>
    
    <item>
      <title>Go的垃圾回收源码剖析</title>
      <link>/post/go%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Mon, 30 Nov 2020 14:52:24 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description>设计理念 Go 实现的垃圾回收器是无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫</description>
    </item>
    
    <item>
      <title>Go调度器的协作与抢占</title>
      <link>/post/go%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E5%8D%8F%E4%BD%9C%E4%B8%8E%E6%8A%A2%E5%8D%A0/</link>
      <pubDate>Fri, 27 Nov 2020 17:25:33 +0000</pubDate>
      
      <guid>/post/go%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E5%8D%8F%E4%BD%9C%E4%B8%8E%E6%8A%A2%E5%8D%A0/</guid>
      <description>前言 如果某个 G 执行时间过长，其他的 G 如何才能被正常的调度？ 这便涉及到有关调度的两个理念：协作式调度与抢占式调度。 协作式和抢占式这两个理念解释</description>
    </item>
    
    <item>
      <title>Go的信号处理源码剖析</title>
      <link>/post/go%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Thu, 26 Nov 2020 22:58:57 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description>前言 我们已经知道了 Go 运行时调度以 Goroutine 的方式调度了所有用户态代码。 每个 Goroutine 都有可能在不同的线程上重新被执行。 那么如果用户态的某个 Goroutine 需要接收系统信号</description>
    </item>
    
    <item>
      <title>Go的内存分配器源码剖析</title>
      <link>/post/go%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Mon, 23 Nov 2020 10:26:14 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description>设计原理 分级分配 线程缓存分配（Thread-Caching Malloc，TCMalloc）是用于分配内存的机制，它比 glibc 中的 malloc 函数还要快很多.</description>
    </item>
    
    <item>
      <title>微服务概览与治理</title>
      <link>/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E6%B2%BB%E7%90%86/</link>
      <pubDate>Sun, 22 Nov 2020 15:23:43 +0000</pubDate>
      
      <guid>/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E6%B2%BB%E7%90%86/</guid>
      <description>微服务概览 单体架构 尽管也是模块化逻辑，但是最终它还是会打包并部署为单体式应用。其中最主要问题就是这个应用太复杂，以至于任何单个开发者都不可能</description>
    </item>
    
    <item>
      <title>Linux的网络IO模型</title>
      <link>/post/linux%E7%9A%84%E7%BD%91%E7%BB%9Cio%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Thu, 19 Nov 2020 11:30:00 +0000</pubDate>
      
      <guid>/post/linux%E7%9A%84%E7%BD%91%E7%BB%9Cio%E6%A8%A1%E5%9E%8B/</guid>
      <description>用户空间与内核空间 现代操作系统都是采用虚拟存储器，那么对 32 位操作系统而言，它的寻址空间（虚拟存储空间）为 4G（2 的 32 次方）。操作系统的核心是</description>
    </item>
    
    <item>
      <title>Go的程序生命周期源码剖析</title>
      <link>/post/go%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Wed, 18 Nov 2020 14:34:06 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description>程序生命周期 在 proc.go 和 runtime2.go 文件中，有一些很重要全局的变量，我们先列出来： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 所有 g 的长度 allglen uintptr // 保</description>
    </item>
    
    <item>
      <title>Go的网络轮询器源码剖析</title>
      <link>/post/go%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BD%AE%E8%AF%A2%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Sat, 14 Nov 2020 22:52:29 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BD%AE%E8%AF%A2%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description>导言 Go 基于 I/O multiplexing 和 goroutine scheduler 构建了一个简洁而高性能的原生网络模型(基于 Go 的 I/O 多路复用 netpoller )，提供了 goroutine-per-connection 这样简单的网络编程模式。在这种模式下，开发者使用的</description>
    </item>
    
    <item>
      <title>Go的系统监控源码剖析</title>
      <link>/post/go%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Thu, 12 Nov 2020 19:32:21 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description>设计原理 Go 语言的系统监控起到了很重要的作用，它在内部启动了一个不会中止的循环，在循环的内部会轮询网络、抢占长期运行或者处于系统调用的 Goroutine 以及触</description>
    </item>
    
    <item>
      <title>GRPC的balancer源码剖析</title>
      <link>/post/grpc%E7%9A%84balancer%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Fri, 23 Oct 2020 11:34:29 +0000</pubDate>
      
      <guid>/post/grpc%E7%9A%84balancer%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description>源码分析 基本概念 ClientConn 对象是连接管理的入口，表示到服务端的一个逻辑的连接，会做名字解析、负载均衡、KeepAlive 等连接管理方面的操作，是个线</description>
    </item>
    
    <item>
      <title>Opentracing包解析</title>
      <link>/post/opentracing%E5%8C%85%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Fri, 09 Oct 2020 16:40:11 +0000</pubDate>
      
      <guid>/post/opentracing%E5%8C%85%E8%A7%A3%E6%9E%90/</guid>
      <description>Variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var ( // ErrUnsupportedFormat occurs when the `format` passed to Tracer.Inject() or // Tracer.Extract() is not recognized by the Tracer implementation. ErrUnsupportedFormat = errors.New(&amp;#34;opentracing: Unknown or unsupported Inject/Extract format&amp;#34;) // ErrSpanContextNotFound occurs when the `carrier` passed to // Tracer.Extract() is valid and uncorrupted but</description>
    </item>
    
    <item>
      <title>Http2与h2c</title>
      <link>/post/http2%E4%B8%8Eh2c/</link>
      <pubDate>Tue, 15 Sep 2020 13:03:24 +0000</pubDate>
      
      <guid>/post/http2%E4%B8%8Eh2c/</guid>
      <description>了解一下http2和h2c (HTTP/2 over TCP,HTTP/2 without TLS)。 http/1.1 的服务器 我们经常会在代码中启动一个http服务器，最简单的http/1.1服务器如下所示： 1 2</description>
    </item>
    
    <item>
      <title>Protobuf的import功能</title>
      <link>/post/protobuf%E7%9A%84import%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Mon, 14 Sep 2020 21:10:00 +0000</pubDate>
      
      <guid>/post/protobuf%E7%9A%84import%E5%8A%9F%E8%83%BD/</guid>
      <description>业务场景 我们会有这样的需求：在不同的文件夹中定义了不同的 proto 文件，这些不同的文件夹可能是一些不同的 gRPC 服务。因为不想重复定义某一个 message</description>
    </item>
    
    <item>
      <title>GRPC如何支持HTTP</title>
      <link>/post/grpc%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81http/</link>
      <pubDate>Fri, 11 Sep 2020 18:10:07 +0000</pubDate>
      
      <guid>/post/grpc%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81http/</guid>
      <description>grpc基于HTTP/2 grpc的client和server通信是基于HTTP/2，client发出的消息是HTTP/2协议格式，serve</description>
    </item>
    
    <item>
      <title>Go的文件系统抽象系统:Afero</title>
      <link>/post/go%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%BD%E8%B1%A1%E7%B3%BB%E7%BB%9F-afero/</link>
      <pubDate>Sun, 30 Aug 2020 23:08:43 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%BD%E8%B1%A1%E7%B3%BB%E7%BB%9F-afero/</guid>
      <description>概观 Afero 是一个文件系统框架,提供与任何文件系统的简单,统一和通用的交互 API。作为提供接口,类型和方法的抽象层，Afero 具有非常干净的接口和</description>
    </item>
    
    <item>
      <title>Go的类型断言</title>
      <link>/post/go%E7%9A%84%E7%BC%96%E8%AF%91%E6%9C%9F%E6%96%AD%E8%A8%80/</link>
      <pubDate>Wed, 26 Aug 2020 23:04:21 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E7%BC%96%E8%AF%91%E6%9C%9F%E6%96%AD%E8%A8%80/</guid>
      <description>编译时类型断言来检查接口 作为一个热身，来看一个在 Go 中熟知的编译期断言：接口满意度检查。 在这段代码中，var _ stringWriter = W{}行确保类型 W 是一个 st</description>
    </item>
    
    <item>
      <title>依赖注入:Wire包介绍</title>
      <link>/post/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5wire%E5%8C%85%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Sun, 23 Aug 2020 15:48:25 +0000</pubDate>
      
      <guid>/post/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5wire%E5%8C%85%E4%BB%8B%E7%BB%8D/</guid>
      <description>wire是 Google 开源的一个依赖注入工具。它是一个代码生成器，并不是一个框架。我们只需要在一个特殊的go文件中告诉wire类型之间的依赖关系，它会</description>
    </item>
    
    <item>
      <title>控制反转（IoC）与依赖注入（DI）</title>
      <link>/post/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACioc%E4%B8%8E%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5di/</link>
      <pubDate>Sat, 22 Aug 2020 23:58:15 +0000</pubDate>
      
      <guid>/post/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACioc%E4%B8%8E%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5di/</guid>
      <description>依赖倒置原则 要了解控制反转( Inversion of Control ), 我觉得有必要先了解软件设计的一个重要思想：依赖倒置原则（Dependency Inversion Principle ）。 什么是依赖倒置原则？</description>
    </item>
    
    <item>
      <title>分布式链路跟踪工具:Jaeger</title>
      <link>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA%E5%B7%A5%E5%85%B7jaeger/</link>
      <pubDate>Wed, 19 Aug 2020 15:30:54 +0000</pubDate>
      
      <guid>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA%E5%B7%A5%E5%85%B7jaeger/</guid>
      <description>架构 如上图所示，Jaeger 主要由以下几部分组成。 Agent（客户端代理） jaeger的agent，是一个监听在 UDP 端口上接收 span 数据的网络守护</description>
    </item>
    
    <item>
      <title>Golangci Lint配置介绍</title>
      <link>/post/golangci-lint%E9%85%8D%E7%BD%AE%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Mon, 17 Aug 2020 23:47:01 +0000</pubDate>
      
      <guid>/post/golangci-lint%E9%85%8D%E7%BD%AE%E4%BB%8B%E7%BB%8D/</guid>
      <description>介绍 要查看支持的Linter列表以及启用/禁用的Linter： 1 golangci-lint help linters 默认情况下启用Linter: govet -Vet检查Go源代码并报告可疑构造，例</description>
    </item>
    
    <item>
      <title>Go1 13的错误处理</title>
      <link>/post/go1-13%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 17 Aug 2020 19:05:17 +0000</pubDate>
      
      <guid>/post/go1-13%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <description>介绍 在过去的十年中， Go的errors are values的理念在编码实践中运行得也很良好。尽管标准库对错误处理的的支持很少（只有errors.N</description>
    </item>
    
    <item>
      <title>Go语言实践:编写可维护的程序的建议</title>
      <link>/post/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%B7%B5%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BB%BA%E8%AE%AE/</link>
      <pubDate>Sat, 15 Aug 2020 18:35:56 +0000</pubDate>
      
      <guid>/post/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%B7%B5%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BB%BA%E8%AE%AE/</guid>
      <description>指导原则 我们要谈论在一个编程语言中的最佳实践，那么我们首先应该明确什么是“最佳”。如果您们听了我昨天那场讲演的话，您一定看到了来自 Go 团队的 Russ</description>
    </item>
    
    <item>
      <title>Go代码审查建议</title>
      <link>/post/go%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E5%BB%BA%E8%AE%AE/</link>
      <pubDate>Sat, 15 Aug 2020 16:11:22 +0000</pubDate>
      
      <guid>/post/go%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E5%BB%BA%E8%AE%AE/</guid>
      <description>当前页面收集了在 Go 代码审核期间的常见意见，以便一个详细说明能被快速参考。这是一个常见错误的清单，而非综合性的风格指南。 你也可以将它作为是 Effective Go</description>
    </item>
    
    <item>
      <title>Go编码建议</title>
      <link>/post/go%E7%BC%96%E7%A0%81%E5%BB%BA%E8%AE%AE/</link>
      <pubDate>Fri, 14 Aug 2020 15:13:13 +0000</pubDate>
      
      <guid>/post/go%E7%BC%96%E7%A0%81%E5%BB%BA%E8%AE%AE/</guid>
      <description>注释 可以通过 /……/ 或者 // ……增加注释， //之后应该加一个空格。 如果你想在每个文件中的头部加上注释，需要在版权注释和 Package前面加一个</description>
    </item>
    
    <item>
      <title>TinyLFU缓存:ristretto</title>
      <link>/post/tinylfu%E7%BC%93%E5%AD%98ristretto/</link>
      <pubDate>Tue, 04 Aug 2020 17:24:43 +0000</pubDate>
      
      <guid>/post/tinylfu%E7%BC%93%E5%AD%98ristretto/</guid>
      <description>Overview Ristretto是一种快速的，固定大小的内存中高速缓存，同时关注吞吐量和命中率性能。您可以轻松地将Ristretto添加到现有系统，并将</description>
    </item>
    
    <item>
      <title>序列化:vmihailenco-Msgpack</title>
      <link>/post/%E5%BA%8F%E5%88%97%E5%8C%96vmihailenco-msgpack/</link>
      <pubDate>Sun, 02 Aug 2020 18:46:32 +0000</pubDate>
      
      <guid>/post/%E5%BA%8F%E5%88%97%E5%8C%96vmihailenco-msgpack/</guid>
      <description>func Marshal 1 func Marshal(v interface{}) ([]byte, error) Marshal 返回v的MessagePack编码。 Example Code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type Item struct { Foo string } b, err := msgpack.Marshal(&amp;amp;Item{Foo: &amp;#34;bar&amp;#34;}) if err != nil { panic(err) } var item Item err = msgpack.Unmarshal(b, &amp;amp;item)</description>
    </item>
    
    <item>
      <title>序列化:MessagePack介绍</title>
      <link>/post/%E5%BA%8F%E5%88%97%E5%8C%96messagepack%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Sun, 02 Aug 2020 17:05:08 +0000</pubDate>
      
      <guid>/post/%E5%BA%8F%E5%88%97%E5%8C%96messagepack%E4%BB%8B%E7%BB%8D/</guid>
      <description>介绍 MessagePack是一种高效的二进制序列化格式。它允许您像JSON一样在多个语言之间交换数据。但是，它更快并且更小。小整数被编码为一</description>
    </item>
    
    <item>
      <title>Go Advice</title>
      <link>/post/go-advice/</link>
      <pubDate>Tue, 28 Jul 2020 19:17:28 +0000</pubDate>
      
      <guid>/post/go-advice/</guid>
      <description>Go-advice 中文版本 Go 箴言 Go 之禅 代码 并发 性能 模块 构建 测试 工具 Misc Go-advice 中文版本 Go 箴言 不要通过共享内存进行通信，通过通信共享内存 并发不是并行 通道编排；互斥体序</description>
    </item>
    
    <item>
      <title>Uber的Go语言编码规范</title>
      <link>/post/uber%E7%9A%84go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</link>
      <pubDate>Tue, 28 Jul 2020 17:12:51 +0000</pubDate>
      
      <guid>/post/uber%E7%9A%84go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</guid>
      <description>Uber Go 语言编码规范 Uber 是一家美国硅谷的科技公司，也是 Go 语言的早期 adopter。其开源了很多 golang 项目，诸如被 Gopher 圈熟知的 zap、jaeger 等。20</description>
    </item>
    
    <item>
      <title>缓存驱逐算法:W-TinyLFU</title>
      <link>/post/%E7%BC%93%E5%AD%98%E9%A9%B1%E9%80%90%E7%AE%97%E6%B3%95w-tinylfu/</link>
      <pubDate>Sun, 26 Jul 2020 17:32:53 +0000</pubDate>
      
      <guid>/post/%E7%BC%93%E5%AD%98%E9%A9%B1%E9%80%90%E7%AE%97%E6%B3%95w-tinylfu/</guid>
      <description>W-TinyLFU 我们有三种常见的缓存驱逐策略： FIFO:先进先出，在这种淘汰算法中，先进入缓存的会先被淘汰。这种可谓是最简单的了，但是会导致我们命中率很低</description>
    </item>
    
    <item>
      <title>Bigcache优化技巧</title>
      <link>/post/bigcache%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Sun, 26 Jul 2020 15:19:19 +0000</pubDate>
      
      <guid>/post/bigcache%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/</guid>
      <description>设计BigCache的初衷 bigcache的作者也不是想当然的开发一个库，而且项目遇到了需求。需求如下： 支持http协议 支持 10K RPS (5k 写，5k 读</description>
    </item>
    
    <item>
      <title>Go中如何实现高性能本地缓存</title>
      <link>/post/go%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/</link>
      <pubDate>Fri, 24 Jul 2020 18:29:28 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/</guid>
      <description>前言 在大部分业务系统中，都会使用诸如 Redis、Memcached 等远程缓存，一方面可以避免自身进程内存占用过大而导致的 OOM 或 GC 问题，另一方面</description>
    </item>
    
    <item>
      <title>Gocache:一个功能齐全且易于扩展的Go缓存库</title>
      <link>/post/gocache%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E9%BD%90%E5%85%A8%E4%B8%94%E6%98%93%E4%BA%8E%E6%89%A9%E5%B1%95%E7%9A%84go%E7%BC%93%E5%AD%98%E5%BA%93/</link>
      <pubDate>Thu, 23 Jul 2020 23:23:02 +0000</pubDate>
      
      <guid>/post/gocache%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E9%BD%90%E5%85%A8%E4%B8%94%E6%98%93%E4%BA%8E%E6%89%A9%E5%B1%95%E7%9A%84go%E7%BC%93%E5%AD%98%E5%BA%93/</guid>
      <description>存储(store) 首先，当你准备缓存一些数据时，你必须选择缓存的存储方式：简单的直接放进内存？使用 Redis 或者 Memcache？或者其它某种形式的</description>
    </item>
    
    <item>
      <title>Prometheus的PromQL实现分析</title>
      <link>/post/prometheus%E7%9A%84promql%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 17 Jul 2020 18:11:48 +0000</pubDate>
      
      <guid>/post/prometheus%E7%9A%84promql%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/</guid>
      <description>PromQL PromQL 是 Prom 中的查询语言，提供了简洁的、贴近自然语言的语法实现时序数据的分析计算。 表达式（Expression）是其中承载数据计算逻辑的部分，对</description>
    </item>
    
    <item>
      <title>Prometheus的GoClient分析</title>
      <link>/post/prometheus%E7%9A%84goclient%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 17 Jul 2020 16:43:42 +0000</pubDate>
      
      <guid>/post/prometheus%E7%9A%84goclient%E5%88%86%E6%9E%90/</guid>
      <description>整体结构分析 无论是 Prom 拉取 (pull) 数据，还是客户端主动推送 (push) 数据，都可以从 Collector 获取 Metric 的定义，UML 图描述了 Go 客户端中主要结构和接口之间的关系。 Collector pro</description>
    </item>
    
    <item>
      <title>在HTTPAPI中使用PromQL</title>
      <link>/post/%E5%9C%A8httpapi%E4%B8%AD%E4%BD%BF%E7%94%A8promql/</link>
      <pubDate>Wed, 15 Jul 2020 10:11:30 +0000</pubDate>
      
      <guid>/post/%E5%9C%A8httpapi%E4%B8%AD%E4%BD%BF%E7%94%A8promql/</guid>
      <description>在 HTTP API 中使用 PromQL Prometheus 当前稳定的 HTTP API 可以通过 /api/v1 访问。 API 响应格式 Prometheus API 使用了 JSON 格式的响应内容。 当 API 调用成功后将会返回 2xx 的 HTTP 状态码。 反之，当 API 调用失败时</description>
    </item>
    
    <item>
      <title>Prometheus的内置函数</title>
      <link>/post/prometheus%E7%9A%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 15 Jul 2020 10:10:14 +0000</pubDate>
      
      <guid>/post/prometheus%E7%9A%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</guid>
      <description>PromQL 内置函数 Prometheus 提供了其它大量的内置函数，可以对时序数据进行丰富的处理。某些函数有默认的参数，例如：year(v=vector(time()) i</description>
    </item>
    
    <item>
      <title>Prometheus的数据存储</title>
      <link>/post/prometheus%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</link>
      <pubDate>Wed, 15 Jul 2020 10:09:36 +0000</pubDate>
      
      <guid>/post/prometheus%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</guid>
      <description>存储 Prometheus 2.x 默认将时间序列数据库保存在本地磁盘中，同时也可以将数据保存到任意第三方的存储服务中。 本地存储 Prometheus 采用自定义的存储格式将样本数据保存在本</description>
    </item>
    
    <item>
      <title>prometheus的四种指标类型</title>
      <link>/post/promethues%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%8C%87%E6%A0%87%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Tue, 14 Jul 2020 18:28:18 +0000</pubDate>
      
      <guid>/post/promethues%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%8C%87%E6%A0%87%E7%B1%BB%E5%9E%8B/</guid>
      <description>Counter（计数器） Counter 类型代表一种样本数据单调递增的指标，即只增不减，除非监控系统发生了重置。例如，你可以使用 counter 类型的指标来表示服务的请</description>
    </item>
    
    <item>
      <title>Prometheus的client_golang</title>
      <link>/post/prometheus%E7%9A%84client_golang/</link>
      <pubDate>Tue, 14 Jul 2020 17:21:00 +0000</pubDate>
      
      <guid>/post/prometheus%E7%9A%84client_golang/</guid>
      <description>prometheus包 概述 普罗米修斯软件包是仪器仪表的核心。它为度量代码提供度量原语以进行监视。它还提供了Metric注册表。子包允许通过H</description>
    </item>
    
    <item>
      <title>Go的代码生成库:jennifer</title>
      <link>/post/go%E7%9A%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%BA%93jennifer/</link>
      <pubDate>Wed, 24 Jun 2020 19:21:22 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%BA%93jennifer/</guid>
      <description>简介 Jennifer是Go的代码生成器。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( &amp;#34;fmt&amp;#34; . &amp;#34;github.com/dave/jennifer/jen&amp;#34; ) func main() { f := NewFile(&amp;#34;main&amp;#34;) f.Func().Id(&amp;#34;main&amp;#34;).Params().Block( Qual(&amp;#34;fmt&amp;#34;, &amp;#34;Println&amp;#34;).Call(Lit(&amp;#34;Hello, world&amp;#34;)), ) fmt.Printf(&amp;#34;%#v&amp;#34;, f) } Output: 1 2 3 4 5 6 7 package main import &amp;#34;fmt&amp;#34; func</description>
    </item>
    
    <item>
      <title>Go的代码生成库jennifer使用</title>
      <link>/post/go%E7%9A%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%BA%93jennifer%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 24 Jun 2020 16:46:20 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%BA%93jennifer%E4%BD%BF%E7%94%A8/</guid>
      <description>简介 jennifer支持所有的 Go 语法和特性，可以用它来生成任何 Go 语言代码。 快速使用 先安装： 1 $ go get github.com/dave/jennifer 今天我们换个思路来介绍jennifer这</description>
    </item>
    
    <item>
      <title>Go命令行库Cobra的使用</title>
      <link>/post/go%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%93cobra%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 23 Jun 2020 22:08:13 +0000</pubDate>
      
      <guid>/post/go%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%93cobra%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>Cobra提供简单的接口来创建强大的现代化CLI接口，比如git与go工具。Cobra同时也是一个程序, 用于创建CLI程序 功能 简易的子命令行</description>
    </item>
    
    <item>
      <title>MongoDB的批量写操作</title>
      <link>/post/mongodb%E7%9A%84%E6%89%B9%E9%87%8F%E5%86%99%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 23 Jun 2020 11:41:54 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E6%89%B9%E9%87%8F%E5%86%99%E6%93%8D%E4%BD%9C/</guid>
      <description>概述 MongoDB使客户端能够批量执行写操作。批量写入操作会影响单个集合。MongoDB允许应用程序确定批量写入操作所需的可接受的确认级别。</description>
    </item>
    
    <item>
      <title>Go将Private仓库用作module依赖</title>
      <link>/post/go%E5%B0%86private%E4%BB%93%E5%BA%93%E7%94%A8%E4%BD%9Cmodule%E4%BE%9D%E8%B5%96/</link>
      <pubDate>Thu, 18 Jun 2020 13:51:25 +0000</pubDate>
      
      <guid>/post/go%E5%B0%86private%E4%BB%93%E5%BA%93%E7%94%A8%E4%BD%9Cmodule%E4%BE%9D%E8%B5%96/</guid>
      <description>本文简单介绍一下Go语言在1.11版本之后推出的go mod使用私有仓库时遇到的问题。 直接使用go get 直接使用go get ...添加私有仓库依赖时，会</description>
    </item>
    
    <item>
      <title>MySQL的索引合并</title>
      <link>/post/mysql%E7%9A%84%E7%B4%A2%E5%BC%95%E5%90%88%E5%B9%B6/</link>
      <pubDate>Wed, 10 Jun 2020 16:06:11 +0000</pubDate>
      
      <guid>/post/mysql%E7%9A%84%E7%B4%A2%E5%BC%95%E5%90%88%E5%B9%B6/</guid>
      <description>索引合并 索引合并访问方法可以在查询中对一个表使用多个索引,对它们同时扫描，并且合并结果(intersect/union)。 此访问方法合并来自</description>
    </item>
    
    <item>
      <title>缓存穿透、缓存击穿、缓存雪崩</title>
      <link>/post/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/</link>
      <pubDate>Tue, 09 Jun 2020 18:12:50 +0000</pubDate>
      
      <guid>/post/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/</guid>
      <description>缓存穿透 什么是缓存穿透 正常情况下，查询的数据都存在，如果请求一个不存在的数据，也就是缓存和数据库都查不到这个数据，每次都会去数据库查询，这种</description>
    </item>
    
    <item>
      <title>MongoDB的四种日志</title>
      <link>/post/mongodb%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%97%A5%E5%BF%97/</link>
      <pubDate>Tue, 09 Jun 2020 17:09:13 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%97%A5%E5%BF%97/</guid>
      <description>任何一种数据库都有各种各样的日志，MongoDB也不例外。MongoDB中有4种日志，分别是系统日志、Journal日志、oplog主从日志</description>
    </item>
    
    <item>
      <title>MongoDB的数据库探查器输出</title>
      <link>/post/mongodb%E7%9A%84%E6%8E%A2%E6%9F%A5%E5%99%A8%E8%BE%93%E5%87%BA/</link>
      <pubDate>Tue, 09 Jun 2020 15:11:50 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E6%8E%A2%E6%9F%A5%E5%99%A8%E8%BE%93%E5%87%BA/</guid>
      <description>示例system.profile文档 下面显示了在system.profile集合中找到的一些示例文档，这些文档可 用于独立运行： 以下文档sys</description>
    </item>
    
    <item>
      <title>MongoDB的探查器配置</title>
      <link>/post/mongodb%E7%9A%84%E6%8E%A2%E6%9F%A5%E5%99%A8%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Tue, 09 Jun 2020 13:13:51 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E6%8E%A2%E6%9F%A5%E5%99%A8%E9%85%8D%E7%BD%AE/</guid>
      <description>前言 数据库事件探查器收集有关针对正在运行的mongod实例执行的数据库命令的详细信息。这包括CRUD操作以及配置和管理命令。探查器将其收集的</description>
    </item>
    
    <item>
      <title>Redis开发规范</title>
      <link>/post/redis%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</link>
      <pubDate>Sat, 06 Jun 2020 22:50:09 +0000</pubDate>
      
      <guid>/post/redis%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</guid>
      <description>一、键值设计 1. key名设计 (1)【建议】: 可读性和可管理性 以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id</description>
    </item>
    
    <item>
      <title>go-redis的常用操作总结</title>
      <link>/post/go-redis%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 05 Jun 2020 15:32:19 +0000</pubDate>
      
      <guid>/post/go-redis%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>流水线 1 2 3 4 5 6 7 8 9 10 11 12 13 pipe := rdb.Pipeline() incr := pipe.Incr(&amp;#34;pipeline_counter&amp;#34;) pipe.Expire(&amp;#34;pipeline_counter&amp;#34;, time.Hour) // Execute // // INCR pipeline_counter // EXPIRE pipeline_counts 3600 // // using one rdb-server roundtrip. _, err := pipe.Exec() fmt.Println(incr.Val(), err) 上面的代码也可以写成下面的形式: 1 2 3 4 5 6 7 var</description>
    </item>
    
    <item>
      <title>MongoDB的聚合管道</title>
      <link>/post/mongodb%E7%9A%84%E8%81%9A%E5%90%88%E7%AE%A1%E9%81%93/</link>
      <pubDate>Sun, 17 May 2020 21:34:04 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E8%81%9A%E5%90%88%E7%AE%A1%E9%81%93/</guid>
      <description>聚合管道 MongoDB聚合管道包括阶段。每个阶段在文档通过管道时都会对其进行转换。流水线阶段不需要为每个输入文档都生成一个输出文档。例如，某</description>
    </item>
    
    <item>
      <title>MongoDB的单用途聚合</title>
      <link>/post/mongodb%E7%9A%84%E5%8D%95%E7%9B%AE%E7%9A%84%E8%81%9A%E5%90%88/</link>
      <pubDate>Sun, 17 May 2020 17:10:00 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E5%8D%95%E7%9B%AE%E7%9A%84%E8%81%9A%E5%90%88/</guid>
      <description>count 定义 此页面记录了mongoshell方法，并且 没有引用MongoDB Node.js驱动程序（或任何其他驱动程序）方法。对于相应的Mongo</description>
    </item>
    
    <item>
      <title>MongoDB的聚合操作</title>
      <link>/post/mongodb%E7%9A%84%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 17 May 2020 15:41:49 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C/</guid>
      <description>前言 聚合操作处理数据记录并返回计算结果。聚合操作将来自多个文档的值组合在一起，并且可以对分组的数据执行各种操作以返回单个结果。MongoDB</description>
    </item>
    
    <item>
      <title>MongoShell中的数据类型</title>
      <link>/post/mongoshell%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sun, 17 May 2020 01:04:59 +0000</pubDate>
      
      <guid>/post/mongoshell%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>日期 所述mongo外壳提供了各种方法来返回日期，无论是作为一个字符串或作为Date对象： Date() 以字符串形式返回当前日期的方法。 new Date()构造</description>
    </item>
    
    <item>
      <title>MongoDB的数组更新运算符</title>
      <link>/post/mongodb%E7%9A%84%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Thu, 14 May 2020 16:54:36 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>$ $运算符标识要更新的数组中的元素，而无需显式指定数组中元素的位置。 消歧 要通过读取操作$投影或返回数组元素，请参阅投影运算符。 要更新数组中的</description>
    </item>
    
    <item>
      <title>MongoDB的字段更新运算符</title>
      <link>/post/mongodb%E7%9A%84%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Thu, 14 May 2020 16:54:32 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>$currentDate $ currentDate运算符将字段的值设置为当前日期，可以是Date或时间戳。默认类型为日期。 $currentDate的形式为： 1 { $currentDate: {</description>
    </item>
    
    <item>
      <title>MongoDB的投影运算符</title>
      <link>/post/mongodb%E7%9A%84%E6%8A%95%E5%BD%B1%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Wed, 13 May 2020 15:45:55 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E6%8A%95%E5%BD%B1%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>$ (projection) 定义 $运算符&amp;lt;array&amp;gt;将查询结果中的内容限制为仅包含与查询文档匹配的第一个元素。 当您在选定文档中只需要一个特定的数组元素</description>
    </item>
    
    <item>
      <title>MongoDB的数组查询运算符</title>
      <link>/post/mongodb%E7%9A%84%E6%95%B0%E7%BB%84%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Wed, 13 May 2020 15:45:43 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E6%95%B0%E7%BB%84%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>$all 在$all选择的文件，其中一个字段的值是包含所有指定元素的数组。要指定$all表达式，请使用以下原型： 1 { &amp;lt;field&amp;gt;: { $all: [ &amp;lt;value1&amp;gt; , &amp;lt;value2&amp;gt; ... ] } } 特性 等效于</description>
    </item>
    
    <item>
      <title>MongoDB的评估查询运算符</title>
      <link>/post/mongodb%E7%9A%84%E8%AF%84%E4%BC%B0%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Wed, 13 May 2020 15:45:30 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E8%AF%84%E4%BC%B0%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>$expr 允许在查询语言中使用聚合表达式。 $expr 具有以下语法： 1 { $expr: { &amp;lt;expression&amp;gt; } } 参数可以是任何有效的聚合表达式。有关更多信息，请参见表达式。 特性 $expr可</description>
    </item>
    
    <item>
      <title>MongoDB的元素查询运算符</title>
      <link>/post/mongodb%E7%9A%84%E5%85%83%E7%B4%A0%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Wed, 13 May 2020 15:44:52 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E5%85%83%E7%B4%A0%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>$exists 语法：{ field: { $exists: &amp;lt;boolean&amp;gt; } } 如果&amp;lt;boolean&amp;gt;为true，则$exists匹配包含该字段的文档，包括字段值为的文档 null。如果&amp;</description>
    </item>
    
    <item>
      <title>MongoDB的逻辑查询运算符</title>
      <link>/post/mongodb%E7%9A%84%E9%80%BB%E8%BE%91%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Wed, 13 May 2020 00:47:14 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E9%80%BB%E8%BE%91%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>$and 语法：{ $and: [ { &amp;lt;expression1&amp;gt; }, { &amp;lt;expression2&amp;gt; } , ... , { &amp;lt;expressionN&amp;gt; } ] } $and在一个或多个表达式（例如&amp;lt;expression1&amp;gt;，&amp;lt;expressio</description>
    </item>
    
    <item>
      <title>MongoDB的比较查询运算符</title>
      <link>/post/mongodb%E7%9A%84%E6%AF%94%E8%BE%83%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Tue, 12 May 2020 17:06:03 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E6%AF%94%E8%BE%83%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>比较/排序顺序 比较不同BSON类型的值时，MongoDB使用以下比较顺序，从最低到最高： MinKey（内部类型） 空值 数字（整数，整数，双精度</description>
    </item>
    
    <item>
      <title>MongoDB的findAndModify</title>
      <link>/post/mongodb%E7%9A%84findandmodify/</link>
      <pubDate>Tue, 12 May 2020 14:45:50 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84findandmodify/</guid>
      <description>db.collection.findAndModify（） 定义 findAndModify()方法具有以下形式： 1 2 3 4 5 6 7 8 9 10 11 12 13 db.collection.findAndModify({ query:</description>
    </item>
    
    <item>
      <title>MongoDB查询性能分析</title>
      <link>/post/mongodb%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 12 May 2020 13:55:28 +0000</pubDate>
      
      <guid>/post/mongodb%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</guid>
      <description>db.collection.explain（） 评估查询的性能 inventory包含以下文档的集合： 1 2 3 4 5 6 7 8 9 10 { &amp;#34;_id&amp;#34; : 1, &amp;#34;item&amp;#34; : &amp;#34;f1&amp;#34;, type: &amp;#34;food&amp;#34;, quantity: 500</description>
    </item>
    
    <item>
      <title>MongoDB优化查询性能</title>
      <link>/post/mongodb%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD/</link>
      <pubDate>Tue, 12 May 2020 11:12:12 +0000</pubDate>
      
      <guid>/post/mongodb%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD/</guid>
      <description>创建索引来支持查询 对于常见的查询，请创建索引。如果查询搜索多个字段，请创建一个复合索引。扫描索引比扫描集合快得多。索引结构小于文档参考，并按</description>
    </item>
    
    <item>
      <title>MongoDB的删除操作</title>
      <link>/post/mongodb%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 11 May 2020 20:46:44 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/</guid>
      <description>示例集合 此页面使用以下MongoDB Go驱动程序功能： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43</description>
    </item>
    
    <item>
      <title>MongoDB的更新操作</title>
      <link>/post/mongodb%E7%9A%84%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 11 May 2020 17:36:36 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C/</guid>
      <description>示例集合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66</description>
    </item>
    
    <item>
      <title>MongoDB的查询操作</title>
      <link>/post/mongodb%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 10 May 2020 22:50:11 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C/</guid>
      <description>示例集合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 docs := []interface{}{ bson.D{ {&amp;#34;item&amp;#34;, &amp;#34;journal&amp;#34;}, {&amp;#34;qty&amp;#34;, 25}, {&amp;#34;size&amp;#34;, bson.D{ {&amp;#34;h&amp;#34;, 14},</description>
    </item>
    
    <item>
      <title>Git同步远程仓库分支</title>
      <link>/post/git%E5%90%8C%E6%AD%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%88%86%E6%94%AF/</link>
      <pubDate>Thu, 07 May 2020 23:56:04 +0000</pubDate>
      
      <guid>/post/git%E5%90%8C%E6%AD%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%88%86%E6%94%AF/</guid>
      <description>何谓同步远程分支？ 有下面几种情况， 本地有新分支，远程仓库没有。 远程仓库有新分支，本地没有。 本地删除了分支，远程也想删除。 远程删除了分支，本地</description>
    </item>
    
    <item>
      <title>MongoDB的插入操作</title>
      <link>/post/mongodb%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 06 May 2020 14:55:26 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</guid>
      <description>创建collection 如果该集合当前不存在，则插入操作将创建该集合。 插入一个文档 Collection.InsertOne 将单个文档插入到集合中。 以下示例将一个新文档插入到inv</description>
    </item>
    
    <item>
      <title>JSON风格指南</title>
      <link>/post/json%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/</link>
      <pubDate>Wed, 29 Apr 2020 16:17:43 +0000</pubDate>
      
      <guid>/post/json%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/</guid>
      <description>JSON风格指南 版本：0.9 英文版：https://google.github.io/styleguide/jsoncstyleguide.</description>
    </item>
    
    <item>
      <title>RESTful API设计规范</title>
      <link>/post/restful-api%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/</link>
      <pubDate>Tue, 28 Apr 2020 16:13:14 +0000</pubDate>
      
      <guid>/post/restful-api%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/</guid>
      <description>理解架构 名称 REST，即Representational State Transfer的缩写。我对这个词组的翻译是&amp;quot;表现层状态转化&amp;rdquo</description>
    </item>
    
    <item>
      <title>Rocketmq的最佳实践</title>
      <link>/post/rocketmq%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Sat, 25 Apr 2020 23:40:10 +0000</pubDate>
      
      <guid>/post/rocketmq%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid>
      <description>Topic 与 Tag 最佳实践 在RocketMQ中，Topic 与 Tag 都是业务上用来归类的标识，区分在于 Topic 是一级分类，而 Tag 可以理解为是二级分类。您可通过本文了解</description>
    </item>
    
    <item>
      <title>Rocketmq的消息轨迹</title>
      <link>/post/rocketmq%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%A8%E8%BF%B9/</link>
      <pubDate>Sat, 25 Apr 2020 23:07:27 +0000</pubDate>
      
      <guid>/post/rocketmq%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%A8%E8%BF%B9/</guid>
      <description>设计思路 RocketMQ消息轨迹，主要跟踪消息发送、消息消费的轨迹，即详细记录消息各个处理环节的日志，从设计上至少需要解决如下三个核心问题：</description>
    </item>
    
    <item>
      <title>Rocketmq的namespace</title>
      <link>/post/rocketmq%E7%9A%84namespace/</link>
      <pubDate>Sat, 25 Apr 2020 18:52:33 +0000</pubDate>
      
      <guid>/post/rocketmq%E7%9A%84namespace/</guid>
      <description>namespace 1 2 3 if p.options.Namespace != &amp;#34;&amp;#34; { msg.Topic = p.options.Namespace + &amp;#34;%&amp;#34; + msg.Topic } 生产者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package main</description>
    </item>
    
    <item>
      <title>Rocketmq的ACL机制</title>
      <link>/post/rocketmq%E7%9A%84acl%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sat, 25 Apr 2020 16:30:55 +0000</pubDate>
      
      <guid>/post/rocketmq%E7%9A%84acl%E6%9C%BA%E5%88%B6/</guid>
      <description>什么是ACL? RocketMQ在4.4.0版本开始支持ACL。ACL是access control list的简称，俗称访问控制列表。访问控制，基本上会涉及</description>
    </item>
    
    <item>
      <title>Rocketmq客户端的拦截器</title>
      <link>/post/rocketmq%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8/</link>
      <pubDate>Sat, 25 Apr 2020 15:50:32 +0000</pubDate>
      
      <guid>/post/rocketmq%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8/</guid>
      <description>生产者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package main import ( &amp;#34;context&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; &amp;#34;github.com/apache/rocketmq-client-go/v2&amp;#34; &amp;#34;github.com/apache/rocketmq-client-go/v2/primitive&amp;#34; &amp;#34;github.com/apache/rocketmq-client-go/v2/producer&amp;#34;</description>
    </item>
    
    <item>
      <title>rocketmq的消费负载均衡</title>
      <link>/post/rocketmq%E7%9A%84%E6%B6%88%E8%B4%B9%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</link>
      <pubDate>Fri, 24 Apr 2020 23:01:45 +0000</pubDate>
      
      <guid>/post/rocketmq%E7%9A%84%E6%B6%88%E8%B4%B9%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</guid>
      <description>负载均衡 要做负载均衡，必须知道一些全局信息，也就是一个ConsumerGroup里到底有多少个Consumer，知道了全局信息，才可以根据某</description>
    </item>
    
    <item>
      <title>路由中心NameServer</title>
      <link>/post/%E8%B7%AF%E7%94%B1%E4%B8%AD%E5%BF%83nameserver/</link>
      <pubDate>Fri, 24 Apr 2020 14:24:33 +0000</pubDate>
      
      <guid>/post/%E8%B7%AF%E7%94%B1%E4%B8%AD%E5%BF%83nameserver/</guid>
      <description>架构设计 消息中间件的设计思路一般基于主题的订阅发布机制，消息生产者（ Producer）发送某一主题的消息到消息服务器，消息服务器负责该消息的</description>
    </item>
    
    <item>
      <title>RmqClient源码分析</title>
      <link>/post/rmqclient%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 23 Apr 2020 15:43:10 +0000</pubDate>
      
      <guid>/post/rmqclient%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>前言 RmqClient是客户端各种类型的Consumer和Producer的底层类。这个类首先从NameServer获取并保存各种配置信息，</description>
    </item>
    
    <item>
      <title>PushConsumer源码分析</title>
      <link>/post/pushconsumer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 23 Apr 2020 14:42:04 +0000</pubDate>
      
      <guid>/post/pushconsumer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>整体流程 NewPushConsumer 创建pushConsumer对象.配置负载均衡策略. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39</description>
    </item>
    
    <item>
      <title>rocketmq的消息过滤机制</title>
      <link>/post/rocketmq%E7%9A%84%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Wed, 22 Apr 2020 22:56:38 +0000</pubDate>
      
      <guid>/post/rocketmq%E7%9A%84%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4%E6%9C%BA%E5%88%B6/</guid>
      <description>在Broker端进行消息过滤，可以减少无效消息发送到Consumer，少占用网络带宽从而提高吞吐量。Broker端有三种方式进行消息过滤。 消</description>
    </item>
    
    <item>
      <title>rocketmq的事务消息</title>
      <link>/post/rocketmq%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/</link>
      <pubDate>Tue, 21 Apr 2020 17:37:34 +0000</pubDate>
      
      <guid>/post/rocketmq%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/</guid>
      <description>事务消息 RocketMQ的事务消息，是指发送消息事件和其他事件需要同时成功或同时失败。比如银行转账，A银行的某账户要转一万元到B银行的某账户</description>
    </item>
    
    <item>
      <title>rocketmq的定时消息</title>
      <link>/post/rocketmq%E7%9A%84%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF/</link>
      <pubDate>Tue, 21 Apr 2020 17:36:23 +0000</pubDate>
      
      <guid>/post/rocketmq%E7%9A%84%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF/</guid>
      <description>定时消息 定时消息是指消息发送到Broker后，并不立即被消费者消费而是要等到特定的时间后才能被消费，RocketMQ并不支持任意的时间精度，</description>
    </item>
    
    <item>
      <title>rocketmq的顺序消息</title>
      <link>/post/rocketmq%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF/</link>
      <pubDate>Tue, 21 Apr 2020 17:30:32 +0000</pubDate>
      
      <guid>/post/rocketmq%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF/</guid>
      <description>顺序消息 RocketMQ支持局部消息顺序消费，可以确保同一个消息消费队列中的消息被顺序消费，如果需要做到全局顺序消费则可以将主题配置成一一个</description>
    </item>
    
    <item>
      <title>Rocketmq中的offset</title>
      <link>/post/rocketmq%E4%B8%AD%E7%9A%84offset/</link>
      <pubDate>Tue, 21 Apr 2020 14:22:06 +0000</pubDate>
      
      <guid>/post/rocketmq%E4%B8%AD%E7%9A%84offset/</guid>
      <description>实际运行中的系统，难免会遇到重新消费某条消息、跳过一段时间内的消息等情况。这些异常情况的处理，都和Offset有关。 首先来明确一下Offse</description>
    </item>
    
    <item>
      <title>rocketmq的消息发送</title>
      <link>/post/rocketmq%E7%9A%84%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/</link>
      <pubDate>Tue, 21 Apr 2020 00:25:16 +0000</pubDate>
      
      <guid>/post/rocketmq%E7%9A%84%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/</guid>
      <description>前言 RocketMQ支持3种消息发送方式:同步(sync)、异步(async)、单向 (oneway) 同步:发送者向MQ执行发送消息API时,同步等待,直到</description>
    </item>
    
    <item>
      <title>rocketmq的消息消费</title>
      <link>/post/rocketmq%E7%9A%84%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9/</link>
      <pubDate>Mon, 20 Apr 2020 15:51:58 +0000</pubDate>
      
      <guid>/post/rocketmq%E7%9A%84%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9/</guid>
      <description>概述 消息消费以组的模式开展，一个消费组内可以包含多个消费者，每一个消费组可订阅多个主题，消费组之间有集群模式与广播模式两种消费模式。集群模式</description>
    </item>
    
    <item>
      <title>基于docker搭建rocketmq环境</title>
      <link>/post/%E5%9F%BA%E4%BA%8Edocker%E6%90%AD%E5%BB%BArocketmq%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Sun, 19 Apr 2020 23:52:04 +0000</pubDate>
      
      <guid>/post/%E5%9F%BA%E4%BA%8Edocker%E6%90%AD%E5%BB%BArocketmq%E7%8E%AF%E5%A2%83/</guid>
      <description>准备工作 在搭建之前，我们需要做一些准备工作，这里我们需要使用 docker 搭建服务，所以需要提前安装 docker。此外，由于 rocketmq 需要部署 broker 与 nameserver ，考虑到分开</description>
    </item>
    
    <item>
      <title>Go-Micro使用:实现GRPC网关</title>
      <link>/post/go-micro%E4%BD%BF%E7%94%A8%E5%AE%9E%E7%8E%B0grpc%E7%BD%91%E5%85%B3/</link>
      <pubDate>Mon, 13 Apr 2020 18:27:03 +0000</pubDate>
      
      <guid>/post/go-micro%E4%BD%BF%E7%94%A8%E5%AE%9E%E7%8E%B0grpc%E7%BD%91%E5%85%B3/</guid>
      <description>预置条件 我们需要下面准备工作： 安装protobuf: 1 2 3 4 5 6 7 8 9 mkdir tmp cd tmp git clone https://github.com/google/protobuf cd protobuf ./autogen.sh ./configure make make check sudo make install 安装插件 1 2 go get -u github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway go get -u github.com/micro/protobuf/protoc-gen-go Greeter Service 例子</description>
    </item>
    
    <item>
      <title>Go-Micro使用:客户端中间件</title>
      <link>/post/go-micro%E4%BD%BF%E7%94%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/</link>
      <pubDate>Sun, 12 Apr 2020 22:16:08 +0000</pubDate>
      
      <guid>/post/go-micro%E4%BD%BF%E7%94%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/</guid>
      <description>日志中间件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65</description>
    </item>
    
    <item>
      <title>Go-Micro使用:构建GRPC服务端与客户端</title>
      <link>/post/go-micro%E4%BD%BF%E7%94%A8%E6%9E%84%E5%BB%BAgrpc%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF/</link>
      <pubDate>Sun, 12 Apr 2020 17:23:48 +0000</pubDate>
      
      <guid>/post/go-micro%E4%BD%BF%E7%94%A8%E6%9E%84%E5%BB%BAgrpc%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF/</guid>
      <description>proto hello.proto 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 syntax = &amp;#34;proto3&amp;#34;;package go.micro.srv.greeter;service Say { rpc Hello(Request) returns (Response) {}}message Request { string name = 1;}message Response { string msg = 1;} 执行命令: 1 protoc --proto_path=. --micro_out=. --go_out=. hello.proto 生成代码: hello.pb.go: 1 2 3 4 5 6 7 8 9 10 11 12</description>
    </item>
    
    <item>
      <title>Go-Micro使用:HTTP服务注册与发现</title>
      <link>/post/go-micro%E4%BD%BF%E7%94%A8http%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/</link>
      <pubDate>Sun, 12 Apr 2020 09:56:41 +0000</pubDate>
      
      <guid>/post/go-micro%E4%BD%BF%E7%94%A8http%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/</guid>
      <description>服务注册 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package main import ( &amp;#34;github.com/micro/go-micro/v2/registry&amp;#34; &amp;#34;github.com/micro/go-micro/v2/registry/etcd&amp;#34; &amp;#34;log&amp;#34; &amp;#34;github.com/gin-gonic/gin&amp;#34; &amp;#34;github.com/micro/go-micro/v2/web&amp;#34; ) type Say struct{} func (s *Say) Anything(c *gin.Context) { log.Print(&amp;#34;Received Say.Anything</description>
    </item>
    
    <item>
      <title>Go-Micro使用:构建HTTP服务</title>
      <link>/post/go-micro%E4%BD%BF%E7%94%A8%E6%9E%84%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Sat, 11 Apr 2020 22:39:34 +0000</pubDate>
      
      <guid>/post/go-micro%E4%BD%BF%E7%94%A8%E6%9E%84%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package main import ( &amp;#34;log&amp;#34; &amp;#34;github.com/gin-gonic/gin&amp;#34; &amp;#34;github.com/micro/go-micro/v2/web&amp;#34; ) type Say struct{} func (s *Say) Anything(c *gin.Context) { log.Print(&amp;#34;Received Say.Anything API request&amp;#34;) c.JSON(200, map[string]string{ &amp;#34;message&amp;#34;: &amp;#34;Hi, this is the Greeter</description>
    </item>
    
    <item>
      <title>GoKit脚手架:GoKit-CLI</title>
      <link>/post/gokit%E8%84%9A%E6%89%8B%E6%9E%B6gokit-cli/</link>
      <pubDate>Sat, 11 Apr 2020 14:58:53 +0000</pubDate>
      
      <guid>/post/gokit%E8%84%9A%E6%89%8B%E6%9E%B6gokit-cli/</guid>
      <description>前言 如果你是一个 Go 开发者，go-kit 为开发者提供了一套抽象，包和接口，这样你实现的服务就可以标准化。 我想开始一个使用 go-kit 工具的深入教程。我们</description>
    </item>
    
    <item>
      <title>MongoDB分片集群机制及原理</title>
      <link>/post/mongodb%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sun, 29 Mar 2020 16:14:17 +0000</pubDate>
      
      <guid>/post/mongodb%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8E%9F%E7%90%86/</guid>
      <description>为什么要使用分片集群？ 数据容量日益增大，访问性能日渐降低，怎么破？ 新品上线异常火爆，如何支撑更多的并发用户？ 单库已有10TB数据，恢复需要1</description>
    </item>
    
    <item>
      <title>MongoDB复制集机制及原理</title>
      <link>/post/mongodb%E5%A4%8D%E5%88%B6%E9%9B%86%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sat, 28 Mar 2020 22:58:32 +0000</pubDate>
      
      <guid>/post/mongodb%E5%A4%8D%E5%88%B6%E9%9B%86%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8E%9F%E7%90%86/</guid>
      <description>复制集的作用 MongoDB复制集的主要意义在于实现服务高可用. 它的实现依赖于两个方面的功能： 数据写入时将数据迅速复制到另一个独立节点上. 在接</description>
    </item>
    
    <item>
      <title>MongoDB的模式构建</title>
      <link>/post/mongodb%E7%9A%84%E6%A8%A1%E5%BC%8F%E6%9E%84%E5%BB%BA/</link>
      <pubDate>Sat, 28 Mar 2020 15:33:58 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E6%A8%A1%E5%BC%8F%E6%9E%84%E5%BB%BA/</guid>
      <description>前言 当涉及MongoDB时，一个经常被问到的问题是“我如何在MongoDB中为我的应用程序构造模式（schema）？”老实说，这要看情况而定</description>
    </item>
    
    <item>
      <title>MongoDB的文档模型设计三部曲</title>
      <link>/post/mongodb%E7%9A%84%E6%96%87%E6%A1%A3%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E4%B8%89%E9%83%A8%E6%9B%B2/</link>
      <pubDate>Sat, 28 Mar 2020 10:27:52 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E6%96%87%E6%A1%A3%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E4%B8%89%E9%83%A8%E6%9B%B2/</guid>
      <description>三部曲 MongoDB文档模型设计三部曲为基础建模,工况细化,套用设计模式: 基础建模 找到对象:根据概念模型或者业务需求推导出逻辑模型 明确关系:</description>
    </item>
    
    <item>
      <title>MongoDB的事务实现解析</title>
      <link>/post/mongodb%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Fri, 27 Mar 2020 18:47:35 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90/</guid>
      <description>Session Session 是 MongoDB 3.6 版本引入的概念，引入这个特性主要就是为实现多文档事务做准备。Session 本质上就是一个「上下文」。 在以前的版本，MongoDB 只</description>
    </item>
    
    <item>
      <title>MongoDB的事务机制介绍</title>
      <link>/post/mongodb%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Fri, 27 Mar 2020 16:00:16 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D/</guid>
      <description>前言 MongoDB虽然已经在4.2开始全面支持了多文档事务，但并不代表大家应该毫无节制地使用它。相反，对事务的使用原则应该是：能不用尽量不用</description>
    </item>
    
    <item>
      <title>MongoDB的ReadConcern</title>
      <link>/post/mongodb%E7%9A%84readconcern/</link>
      <pubDate>Thu, 26 Mar 2020 23:53:52 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84readconcern/</guid>
      <description>综述 在读取数据的过程中我们需要关注以下两个问题 从哪里读？关注数据节点位置 什么样的数据可以读？关注数据的隔离性 第一个问题是是由 readPreference 来解決 第二个问</description>
    </item>
    
    <item>
      <title>MongoDB的WriteConcern</title>
      <link>/post/mongodb%E7%9A%84writeconcern/</link>
      <pubDate>Thu, 26 Mar 2020 17:10:36 +0000</pubDate>
      
      <guid>/post/mongodb%E7%9A%84writeconcern/</guid>
      <description>WriteConcern write Concern 決定一个写操作落到多少个节点上オ算成功。包括以下3个字段: { w: &amp;lt;value&amp;gt;, j: &amp;lt;boolean&amp;gt;, wtimeout: &amp;lt;number&amp;gt; } MongoDB支持的WriteConncern选项如下 w选项</description>
    </item>
    
    <item>
      <title>Kingshard的SQL黑名单功能介绍</title>
      <link>/post/kingshard%E7%9A%84sql%E9%BB%91%E5%90%8D%E5%8D%95%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Thu, 26 Mar 2020 10:54:28 +0000</pubDate>
      
      <guid>/post/kingshard%E7%9A%84sql%E9%BB%91%E5%90%8D%E5%8D%95%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/</guid>
      <description>kingshard SQL黑名单功能介绍 应用场景介绍 在kingshard开源之后，有用户多次提到能不能在kingshard中加入SQL黑名单机制，让kings</description>
    </item>
    
    <item>
      <title>Kingshard集群与监控</title>
      <link>/post/kingshard%E9%9B%86%E7%BE%A4%E4%B8%8E%E7%9B%91%E6%8E%A7/</link>
      <pubDate>Thu, 26 Mar 2020 10:16:49 +0000</pubDate>
      
      <guid>/post/kingshard%E9%9B%86%E7%BE%A4%E4%B8%8E%E7%9B%91%E6%8E%A7/</guid>
      <description>如何使用ks+lvs实现完美集群 前言 很多ks的用户会问到ks如何配合LVS做流量切换?ks如何配合keepalived做高可用?ks如何做到</description>
    </item>
    
    <item>
      <title>Kingshard管理端介绍</title>
      <link>/post/kingshard%E7%AE%A1%E7%90%86%E7%AB%AF%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Thu, 26 Mar 2020 10:12:53 +0000</pubDate>
      
      <guid>/post/kingshard%E7%AE%A1%E7%90%86%E7%AB%AF%E4%BB%8B%E7%BB%8D/</guid>
      <description>管理端命令 kingshard的管理端口复用了工作端口，通过特定的关键字来标示，目前支持对后端DB常用的管理操作。kingshard支持了多用</description>
    </item>
    
    <item>
      <title>Kingshard使用指南</title>
      <link>/post/kingshard%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Wed, 25 Mar 2020 00:10:16 +0000</pubDate>
      
      <guid>/post/kingshard%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>应用场景 现在很多互联网公司还是在大量使用MySQL来存储各种类型的关系型数据。随着访问量和数据量的增长，开发者不得不考虑一些MySQL相关的</description>
    </item>
    
    <item>
      <title>Kingshard架构设计和功能实现</title>
      <link>/post/kingshard%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Tue, 24 Mar 2020 17:13:47 +0000</pubDate>
      
      <guid>/post/kingshard%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</guid>
      <description>kingshard简介 kingshard是一个由Go开发高性能MySQL Proxy项目，kingshard在满足基本的读写分离的功能上，致力</description>
    </item>
    
    <item>
      <title>Go生成和识别二维码</title>
      <link>/post/go%E7%94%9F%E6%88%90%E5%92%8C%E8%AF%86%E5%88%AB%E4%BA%8C%E7%BB%B4%E7%A0%81%E4%B8%8E%E6%9D%A1%E5%BD%A2%E7%A0%81/</link>
      <pubDate>Fri, 20 Mar 2020 17:06:44 +0000</pubDate>
      
      <guid>/post/go%E7%94%9F%E6%88%90%E5%92%8C%E8%AF%86%E5%88%AB%E4%BA%8C%E7%BB%B4%E7%A0%81%E4%B8%8E%E6%9D%A1%E5%BD%A2%E7%A0%81/</guid>
      <description>什么是二维码 二维条码是指在一维条码的基础上扩展出另一维具有可读性的条码，使用黑白矩形图案表示二进制数据，被设备扫描后可获取其中所包含的信息。</description>
    </item>
    
    <item>
      <title>GoKit使用:结合Gin框架</title>
      <link>/post/gokit%E4%BD%BF%E7%94%A8%E7%BB%93%E5%90%88gin%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Sun, 15 Mar 2020 16:36:48 +0000</pubDate>
      
      <guid>/post/gokit%E4%BD%BF%E7%94%A8%E7%BB%93%E5%90%88gin%E6%A1%86%E6%9E%B6/</guid>
      <description>service.go 1 2 3 4 5 6 7 8 9 10 11 12 13 type Service interface { Status(ctx context.Context) (string, error) } type statusService struct{} func NewService() Service { return statusService{} } func (statusService) Status(ctx context.Context) (string, error) { return &amp;#34;ok&amp;#34;, nil } endpoints.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type statusRequest struct{} type statusResponse</description>
    </item>
    
    <item>
      <title>GoKit使用:三层架构</title>
      <link>/post/gokit%E4%BD%BF%E7%94%A8%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Sat, 14 Mar 2020 15:55:21 +0000</pubDate>
      
      <guid>/post/gokit%E4%BD%BF%E7%94%A8%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/</guid>
      <description>架构 基于Go kit的应用程序体系结构包含三个主要组件： Transport Endpoint Service Transport 当您构建基于微服务的分布式系统时，服务通常使用诸如HTTP或gRPC之类的具体</description>
    </item>
    
    <item>
      <title>Git撤销操作总结</title>
      <link>/post/git%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 13 Mar 2020 15:55:46 +0000</pubDate>
      
      <guid>/post/git%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>分支提交错误 有时我们会遇到这种情况：我们从develop 分支新建一个名为feat/home 分支去做A功能，然后由于一些其他原因A 功能需要延后</description>
    </item>
    
    <item>
      <title>服务发布策略</title>
      <link>/post/%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E7%AD%96%E7%95%A5/</link>
      <pubDate>Tue, 03 Mar 2020 17:57:28 +0000</pubDate>
      
      <guid>/post/%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E7%AD%96%E7%95%A5/</guid>
      <description>软件产品环境 一个软件产品从开发到用户使用都涉及哪些环境？ 开发环境、测试环境、回归环境、预发布环境、生产环境。 下面说说我个人对这些环境的理解：</description>
    </item>
    
    <item>
      <title>Git工作流:Git-Flow</title>
      <link>/post/git%E5%B7%A5%E4%BD%9C%E6%B5%81git-flow/</link>
      <pubDate>Tue, 25 Feb 2020 18:00:26 +0000</pubDate>
      
      <guid>/post/git%E5%B7%A5%E4%BD%9C%E6%B5%81git-flow/</guid>
      <description>简介 Gitflow是一个基于feature分支管理的版本发布方案。它是由Vincent Driessen设计研发，开源项目地址gitflow-</description>
    </item>
    
    <item>
      <title>Git工作流对比</title>
      <link>/post/git%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AF%B9%E6%AF%94/</link>
      <pubDate>Tue, 25 Feb 2020 15:20:28 +0000</pubDate>
      
      <guid>/post/git%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AF%B9%E6%AF%94/</guid>
      <description>工作流 WorkFlow 的字面意思，工作流，即工作流程。在分支篇里，有说过这样的话：因为有分支的存在，才构成了多工作流的特色。事实的确如此，因为项目开发中，</description>
    </item>
    
    <item>
      <title>Git LFS操作指南</title>
      <link>/post/git-lfs%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/</link>
      <pubDate>Wed, 12 Feb 2020 22:09:20 +0000</pubDate>
      
      <guid>/post/git-lfs%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/</guid>
      <description>背景 在游戏开发过程中,设计资源占用了很大一部分空间. 像png,psd等文件是二进制(blob)的,体积也很庞大. 但git的diff/patc</description>
    </item>
    
    <item>
      <title>MemStats与GCStats</title>
      <link>/post/memstats%E4%B8%8Egcstats/</link>
      <pubDate>Tue, 11 Feb 2020 23:59:16 +0000</pubDate>
      
      <guid>/post/memstats%E4%B8%8Egcstats/</guid>
      <description>关于内存分配的情况，最简单的方式是利用 runtime 包的 MemStats。 上面这种是不修改一行代码的情况下，完全使用外部工具/参数，无侵入式的 GC 监控。 另</description>
    </item>
    
    <item>
      <title>Go调试器:GODEBUG</title>
      <link>/post/go%E8%B0%83%E8%AF%95%E5%99%A8godebug/</link>
      <pubDate>Tue, 11 Feb 2020 10:22:37 +0000</pubDate>
      
      <guid>/post/go%E8%B0%83%E8%AF%95%E5%99%A8godebug/</guid>
      <description>介绍 让 Go 更强大的原因之一莫过于它的 GODEBUG 工具，GODEBUG 的设置可以让 Go 程序在运行时输出调试信息，可以根据你的要求很直观的看到你想要的调度器或</description>
    </item>
    
    <item>
      <title>堆栈跟踪:Stack-Trace</title>
      <link>/post/%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AAstack-trace/</link>
      <pubDate>Tue, 11 Feb 2020 09:44:31 +0000</pubDate>
      
      <guid>/post/%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AAstack-trace/</guid>
      <description>Stack Trace表示堆栈跟踪，这是一个或多个堆栈帧的有序的集合。在程序出现panic的时候你会看到控制台有Stack Trace信息打印出来。 介绍</description>
    </item>
    
    <item>
      <title>Go性能分析:trace</title>
      <link>/post/go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90trace/</link>
      <pubDate>Mon, 10 Feb 2020 16:53:58 +0000</pubDate>
      
      <guid>/post/go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90trace/</guid>
      <description>trace 你有没有考虑过，你的goroutines是如何被go的runtime系统调度的？是否尝试理解过为什么在程序中增加了并发，但并没有给它带来更</description>
    </item>
    
    <item>
      <title>Pprof实战:解决内存泄露</title>
      <link>/post/pprof%E5%AE%9E%E6%88%98%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/</link>
      <pubDate>Sun, 09 Feb 2020 18:49:21 +0000</pubDate>
      
      <guid>/post/pprof%E5%AE%9E%E6%88%98%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/</guid>
      <description>前言 关于Go的内存泄露有这么一句话不知道你听过没有： 10次内存泄露，有9次是goroutine泄露。 我所解决的问题，也是goroutine泄</description>
    </item>
    
    <item>
      <title>Pprof实战:从零开始排查炸弹程序</title>
      <link>/post/pprof%E5%AE%9E%E6%88%98%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8E%92%E6%9F%A5%E7%82%B8%E5%BC%B9%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sun, 09 Feb 2020 17:45:44 +0000</pubDate>
      
      <guid>/post/pprof%E5%AE%9E%E6%88%98%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8E%92%E6%9F%A5%E7%82%B8%E5%BC%B9%E7%A8%8B%E5%BA%8F/</guid>
      <description>前言 如果要说在 golang 开发过程进行性能调优，pprof 一定是一个大杀器般的工具。但在网上找到的教程都偏向简略，难寻真的能应用于实战的教程。这也无可</description>
    </item>
    
    <item>
      <title>Pprof实战:Profiling Go Programs</title>
      <link>/post/pprof%E5%AE%9E%E6%88%98profiling-go-programs/</link>
      <pubDate>Sun, 02 Feb 2020 21:36:55 +0000</pubDate>
      
      <guid>/post/pprof%E5%AE%9E%E6%88%98profiling-go-programs/</guid>
      <description>背景 在Scala Days 2011，Robert Hundt 发表了一篇名为 Loop Recognition in C++/Java/Go/Scala 的论文。 该论文实现了一种特定的循环查找算法，例如您可以在C++，Go，Jav</description>
    </item>
    
    <item>
      <title>Pprof实战:利用火焰图优化代码</title>
      <link>/post/pprof%E5%AE%9E%E6%88%98%E5%88%A9%E7%94%A8%E7%81%AB%E7%84%B0%E5%9B%BE%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Sun, 02 Feb 2020 11:28:43 +0000</pubDate>
      
      <guid>/post/pprof%E5%AE%9E%E6%88%98%E5%88%A9%E7%94%A8%E7%81%AB%E7%84%B0%E5%9B%BE%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/</guid>
      <description>这里使用火焰图复现 logger 100% CPU 问题。 先看现象， 用 wrk 压测 logger 1 wrk -t1 -c100 -d30 --script=post.lua &amp;#39;http://127.0.0.1:4500/marco/log&amp;#39; 查看 CPU 占用情况 采集 30s 的 CPU profile 火焰图 图中红色标记部分 startSink 函数中 runtime.selectgo 消耗了大量 CPU，</description>
    </item>
    
    <item>
      <title>Pprof替代库:pkg Profile</title>
      <link>/post/pprof%E6%9B%BF%E4%BB%A3%E5%BA%93pkg-profile/</link>
      <pubDate>Sat, 01 Feb 2020 22:32:29 +0000</pubDate>
      
      <guid>/post/pprof%E6%9B%BF%E4%BB%A3%E5%BA%93pkg-profile/</guid>
      <description>简介 Go 运行时的分析接口存在于 runtime/pprof 包中。 runtime/pprof 是一个非常低级的工具，由于历史原因，不同类型 profile 的接口并不统一,而且使用起来还不是太方便，例如：输出数据</description>
    </item>
    
    <item>
      <title>pprof实战:利用runtime-pprof优化代码</title>
      <link>/post/pprof%E5%AE%9E%E6%88%98%E5%88%A9%E7%94%A8runtime-pprof%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Sat, 01 Feb 2020 17:23:12 +0000</pubDate>
      
      <guid>/post/pprof%E5%AE%9E%E6%88%98%E5%88%A9%E7%94%A8runtime-pprof%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/</guid>
      <description>示例代码 我们写一个程序来计算单词数量： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;io&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; &amp;#34;unicode&amp;#34; ) func</description>
    </item>
    
    <item>
      <title>Go优化建议汇总</title>
      <link>/post/go%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE%E6%B1%87%E6%80%BB/</link>
      <pubDate>Sat, 01 Feb 2020 15:48:07 +0000</pubDate>
      
      <guid>/post/go%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE%E6%B1%87%E6%80%BB/</guid>
      <description>1 将多个小对象合并成一个大的对象 2 减少不必要的指针间接引用，多使用copy引用 例如使用bytes.Buffer代替*bytes.Buffer</description>
    </item>
    
    <item>
      <title>pprof实战:结合benchmark优化代码</title>
      <link>/post/pprof%E5%AE%9E%E6%88%98%E7%BB%93%E5%90%88benchmark%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Fri, 31 Jan 2020 23:09:56 +0000</pubDate>
      
      <guid>/post/pprof%E5%AE%9E%E6%88%98%E7%BB%93%E5%90%88benchmark%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/</guid>
      <description>示例代码:数独 sodoku.go: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62</description>
    </item>
    
    <item>
      <title>Go性能分析:pprof</title>
      <link>/post/go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90pprof/</link>
      <pubDate>Thu, 30 Jan 2020 21:54:05 +0000</pubDate>
      
      <guid>/post/go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90pprof/</guid>
      <description>简介 什么是pprof 代码上线前，我们通过压测可以获知系统的性能，例如每秒能处理的请求数，平均响应时间，错误率等指标。这样，我们对自己服务的性</description>
    </item>
    
    <item>
      <title>Go的编译优化:内联与死码消除</title>
      <link>/post/go%E7%9A%84%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%86%85%E8%81%94%E4%B8%8E%E6%AD%BB%E7%A0%81%E6%B6%88%E9%99%A4/</link>
      <pubDate>Thu, 30 Jan 2020 16:33:02 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%86%85%E8%81%94%E4%B8%8E%E6%AD%BB%E7%A0%81%E6%B6%88%E9%99%A4/</guid>
      <description>内联 在 Go 中，函数调用有固定的开销；栈和抢占检查。 硬件分支预测器改善了其中的一些功能，但就功能大小和时钟周期而言，这仍然是一个成本。 内联是避免</description>
    </item>
    
    <item>
      <title>Go中的基准测试</title>
      <link>/post/go%E4%B8%AD%E7%9A%84%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Thu, 30 Jan 2020 15:46:41 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E7%9A%84%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</guid>
      <description>基准测试的基本规则 在进行基准测试之前，我们必须要有一个稳定的环境来获得可重现的结果。 机器必须是空闲的——不要运行在共享硬件上，在长时间运行基</description>
    </item>
    
    <item>
      <title>Package:httptest(1.13)</title>
      <link>/post/packagehttptest1.13/</link>
      <pubDate>Tue, 28 Jan 2020 18:56:15 +0000</pubDate>
      
      <guid>/post/packagehttptest1.13/</guid>
      <description>Constants DefaultRemoteAddr是默认的远端地址。如果ResponseRecorder未显式的设置该属性，RemoteAddr方法就会返</description>
    </item>
    
    <item>
      <title>RESTAPI测试框架:httpexpect</title>
      <link>/post/restapi%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6httpexpect/</link>
      <pubDate>Tue, 28 Jan 2020 18:03:14 +0000</pubDate>
      
      <guid>/post/restapi%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6httpexpect/</guid>
      <description>简介 httpexpect基本上，是一组基于HTTP请求和基于HTTP的断言( 例如HTTP响应和负载)，位于net/HTTP和几个实用程序包之</description>
    </item>
    
    <item>
      <title>Sql模拟库:go-sqlmock</title>
      <link>/post/sql%E6%A8%A1%E6%8B%9F%E5%BA%93go-sqlmock/</link>
      <pubDate>Mon, 27 Jan 2020 16:26:17 +0000</pubDate>
      
      <guid>/post/sql%E6%A8%A1%E6%8B%9F%E5%BA%93go-sqlmock/</guid>
      <description>简介 sqlmock是一个实现sql/driver的模拟库。它有一个唯一的目的:在测试中模拟任何sql驱动程序行为，而无需真正的数据库连接。它</description>
    </item>
    
    <item>
      <title>打桩框架:gomonkey</title>
      <link>/post/%E6%89%93%E6%A1%A9%E6%A1%86%E6%9E%B6gomonkey/</link>
      <pubDate>Mon, 27 Jan 2020 15:30:34 +0000</pubDate>
      
      <guid>/post/%E6%89%93%E6%A1%A9%E6%A1%86%E6%9E%B6gomonkey/</guid>
      <description>介绍 gomonkey 是 golang 的一款打桩框架，目标是让用户在单元测试中低成本的完成打桩，从而将精力聚焦于业务功能的开发。gomonkey 接口友好，功能强大，目前</description>
    </item>
    
    <item>
      <title>猴子补丁:monkey</title>
      <link>/post/%E7%8C%B4%E5%AD%90%E8%A1%A5%E4%B8%81monkey/</link>
      <pubDate>Sat, 25 Jan 2020 23:36:00 +0000</pubDate>
      
      <guid>/post/%E7%8C%B4%E5%AD%90%E8%A1%A5%E4%B8%81monkey/</guid>
      <description>前言 我们已经知道： 全局变量可通过GoStub框架打桩 过程可通过GoStub框架打桩 函数可通过GoStub框架打桩 interface可通过Go</description>
    </item>
    
    <item>
      <title>interface的mock:gomock</title>
      <link>/post/interface%E7%9A%84mockgomock/</link>
      <pubDate>Tue, 07 Jan 2020 15:59:29 +0000</pubDate>
      
      <guid>/post/interface%E7%9A%84mockgomock/</guid>
      <description>序言 GoMock是由Golang官方开发维护的测试框架，实现了较为完整的基于interface的Mock功能，能够与Golang内置的tes</description>
    </item>
    
    <item>
      <title>变量与函数打桩:gostub</title>
      <link>/post/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E6%89%93%E6%A1%A9gostub/</link>
      <pubDate>Tue, 07 Jan 2020 14:50:32 +0000</pubDate>
      
      <guid>/post/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E6%89%93%E6%A1%A9gostub/</guid>
      <description>简介 gostub用于在测试中添加变量，并在测试运行后重置原始值。 这可以用于对静态变量和静态函数进行打桩。要打桩静态变量，请使用stub函数：</description>
    </item>
    
    <item>
      <title>测试金字塔实战</title>
      <link>/post/%E6%B5%8B%E8%AF%95%E9%87%91%E5%AD%97%E5%A1%94%E5%AE%9E%E6%88%98/</link>
      <pubDate>Sun, 05 Jan 2020 23:06:06 +0000</pubDate>
      
      <guid>/post/%E6%B5%8B%E8%AF%95%E9%87%91%E5%AD%97%E5%A1%94%E5%AE%9E%E6%88%98/</guid>
      <description>前言 “测试金字塔”是一个比喻，它告诉我们要把软件测试按照不同粒度来分组。它也告诉我们每个组应该有多少测试。虽然测试金字塔的概念已经存在了一段</description>
    </item>
    
    <item>
      <title>使用goconvey简化BDD单元测试</title>
      <link>/post/%E4%BD%BF%E7%94%A8goconvey%E7%AE%80%E5%8C%96bdd%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Sun, 05 Jan 2020 22:11:30 +0000</pubDate>
      
      <guid>/post/%E4%BD%BF%E7%94%A8goconvey%E7%AE%80%E5%8C%96bdd%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid>
      <description>GoConvey简介 GoConvey是一款针对Golang的测试框架，可以管理和运行测试用例，同时提供了丰富的断言函数，并支持很多 Web 界面特性</description>
    </item>
    
    <item>
      <title>使用testify简化TDD测试</title>
      <link>/post/%E4%BD%BF%E7%94%A8testify%E7%AE%80%E5%8C%96tdd%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Sun, 05 Jan 2020 16:43:26 +0000</pubDate>
      
      <guid>/post/%E4%BD%BF%E7%94%A8testify%E7%AE%80%E5%8C%96tdd%E6%B5%8B%E8%AF%95/</guid>
      <description>简介 testify的功能包括： Easy assertions Mocking Testing suite interfaces and functions assert 该assert软件包提供了一些有用的方法，使您可以在Go中编写更好的测试代码。 打印友好，易于</description>
    </item>
    
    <item>
      <title>Go语言快速解析JSON:gjson</title>
      <link>/post/go%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E8%A7%A3%E6%9E%90jsongjson/</link>
      <pubDate>Mon, 23 Dec 2019 19:38:12 +0000</pubDate>
      
      <guid>/post/go%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E8%A7%A3%E6%9E%90jsongjson/</guid>
      <description>前言 GJSON是一个Go包，它提供了一种快速，简单的方法来从json文档中获取值。它具有诸如单行检索，点符号路径，迭代和解析json行之类的</description>
    </item>
    
    <item>
      <title>TDD与BDD</title>
      <link>/post/tdd%E4%B8%8Ebdd/</link>
      <pubDate>Tue, 17 Dec 2019 20:23:27 +0000</pubDate>
      
      <guid>/post/tdd%E4%B8%8Ebdd/</guid>
      <description>前言 如果你关注软件开发最佳实践方面的话题，你肯定听说过测试驱动开发(TDD - Test Driven Development) 和行为驱动开发(BDD - Behavior Driven Development)。这篇</description>
    </item>
    
    <item>
      <title>Go中的参数验证:validator</title>
      <link>/post/go%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81validator/</link>
      <pubDate>Sat, 14 Dec 2019 16:36:40 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81validator/</guid>
      <description>validator 在 Web 应用中，有一块内容非常重要，却很容易被我们忽略：参数验证，忘了之后常常会给我们造成大量的处理错误问题，甚至直接造成应用崩溃。之前我在 你</description>
    </item>
    
    <item>
      <title>package:validator.v9</title>
      <link>/post/packagevalidator.v9/</link>
      <pubDate>Thu, 12 Dec 2019 20:43:20 +0000</pubDate>
      
      <guid>/post/packagevalidator.v9/</guid>
      <description>标准库 package validator import &amp;ldquo;gopkg.in/go-playground/validator.v9&amp;rdquo; Package validator 基于标签对结构和单个字段实现值验证. 它还可以处理嵌套结构的跨字段和跨结构验证，并具有深入研究任何类型的数组和映射的能力。 查</description>
    </item>
    
    <item>
      <title>Go语言检测一个文件的类型</title>
      <link>/post/go%E8%AF%AD%E8%A8%80%E6%A3%80%E6%B5%8B%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Thu, 12 Dec 2019 10:12:53 +0000</pubDate>
      
      <guid>/post/go%E8%AF%AD%E8%A8%80%E6%A3%80%E6%B5%8B%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B/</guid>
      <description>做 Web 应用程序时，经常需要对用户上传的文件类型做一下检查，比如判断上传的是否是 png 、gif、jpg 等图片类型，还是 pdf。并针对不同的类型做一些</description>
    </item>
    
    <item>
      <title>Header:Content-Disposition</title>
      <link>/post/headercontent-disposition/</link>
      <pubDate>Wed, 11 Dec 2019 20:47:09 +0000</pubDate>
      
      <guid>/post/headercontent-disposition/</guid>
      <description>Content-Disposition Content-Disposition 有两种应用场景。 用在HTTP响应头中 场景一是用在HTTP的响应头中，指示响应的内容该以何种形式展示。是以内联的形式（即网页或者页面的一部</description>
    </item>
    
    <item>
      <title>如何防止XSS攻击</title>
      <link>/post/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2xss%E6%94%BB%E5%87%BB/</link>
      <pubDate>Wed, 11 Dec 2019 10:50:53 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2xss%E6%94%BB%E5%87%BB/</guid>
      <description>XSS 攻击的介绍 在开始本文之前，我们先提出一个问题，请判断以下两个说法是否正确： XSS 防范是后端 RD（研发人员）的责任，后端 RD 应该在所有用户提交数据</description>
    </item>
    
    <item>
      <title>如何防止CSRF攻击</title>
      <link>/post/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2csrf%E6%94%BB%E5%87%BB/</link>
      <pubDate>Wed, 11 Dec 2019 10:50:46 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2csrf%E6%94%BB%E5%87%BB/</guid>
      <description>CSRF攻击 CSRF漏洞的发生 相比XSS，CSRF的名气似乎并不是那么大，很多人都认为CSRF“不那么有破坏性”。真的是这样吗？ 接下来有请小</description>
    </item>
    
    <item>
      <title>如何在Go中使用JWT</title>
      <link>/post/%E5%A6%82%E4%BD%95%E5%9C%A8go%E4%B8%AD%E4%BD%BF%E7%94%A8jwt/</link>
      <pubDate>Sun, 08 Dec 2019 15:39:17 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E5%9C%A8go%E4%B8%AD%E4%BD%BF%E7%94%A8jwt/</guid>
      <description>jwt-go 编写jwt工具 我们需要编写一个jwt的工具，我们在pkg下的util目录新建jwt.go，写入文件内容： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17</description>
    </item>
    
    <item>
      <title>判断星期几:基姆拉尔森计算公式</title>
      <link>/post/%E5%88%A4%E6%96%AD%E6%98%9F%E6%9C%9F%E5%87%A0%E5%9F%BA%E5%A7%86%E6%8B%89%E5%B0%94%E6%A3%AE%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F/</link>
      <pubDate>Thu, 05 Dec 2019 18:14:56 +0000</pubDate>
      
      <guid>/post/%E5%88%A4%E6%96%AD%E6%98%9F%E6%9C%9F%E5%87%A0%E5%9F%BA%E5%A7%86%E6%8B%89%E5%B0%94%E6%A3%AE%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F/</guid>
      <description>需求 给定一个xxxx-xx-xx日期，计算为星期几。 设定 1 2 3 4 int y; //年 int m; //月 int d; //日 int w; //周几 从 公元0年1月1日星期日 开始 推导 对</description>
    </item>
    
    <item>
      <title>点赞系统的设计</title>
      <link>/post/%E7%82%B9%E8%B5%9E%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Fri, 29 Nov 2019 21:23:47 +0000</pubDate>
      
      <guid>/post/%E7%82%B9%E8%B5%9E%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid>
      <description>概述 点赞功能在很多系统中都有，但别看功能小，想要做好需要考虑的东西还挺多的。 点赞、取消点赞是高频次的操作，若每次都读写数据库，大量的操作会影</description>
    </item>
    
    <item>
      <title>Go如何生成swagger文档</title>
      <link>/post/go%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90swagger%E6%96%87%E6%A1%A3/</link>
      <pubDate>Wed, 27 Nov 2019 15:45:15 +0000</pubDate>
      
      <guid>/post/go%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90swagger%E6%96%87%E6%A1%A3/</guid>
      <description>swagger Swagger是一个简单但功能强大的API表达工具。它具有地球上最大的API工具生态系统，数以千计的开发人员，使用几乎所有的现代编程语言，</description>
    </item>
    
    <item>
      <title>Go强大的调试日志打印工具:go:Spew</title>
      <link>/post/go%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%B0%83%E8%AF%95%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E5%B7%A5%E5%85%B7go-spew/</link>
      <pubDate>Fri, 22 Nov 2019 11:15:12 +0000</pubDate>
      
      <guid>/post/go%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%B0%83%E8%AF%95%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E5%B7%A5%E5%85%B7go-spew/</guid>
      <description>引言 我们在使用Golang（Go语言）开发的过程中，会通过经常通过调试的方式查找问题的原因，解决问题，尤其是当遇到一个很棘手的问题的时候，就</description>
    </item>
    
    <item>
      <title>Go调用Python</title>
      <link>/post/go%E8%B0%83%E7%94%A8python/</link>
      <pubDate>Mon, 11 Nov 2019 13:47:29 +0000</pubDate>
      
      <guid>/post/go%E8%B0%83%E7%94%A8python/</guid>
      <description>Go-Python 环境配置 Python ：确保Python正确安装，所谓正确安装，就是在系统中能找到libpython.so(dylib)，找到Python.h。一般l</description>
    </item>
    
    <item>
      <title>hystrix-go源码剖析</title>
      <link>/post/hystrix-go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Mon, 04 Nov 2019 16:07:01 +0000</pubDate>
      
      <guid>/post/hystrix-go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description>执行:Do与Go 同步执行，直接调用Do方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48</description>
    </item>
    
    <item>
      <title>time-rate源码剖析</title>
      <link>/post/time-rate%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Mon, 04 Nov 2019 14:01:16 +0000</pubDate>
      
      <guid>/post/time-rate%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description>主要逻辑 Allow Allow 方法的调用链：lim.Allow() bool → lim.AllowN(time.Now(), 1) → lim.reserveN(now, n, 0).ok，因此 reserveN 方法的实现很关键 1 2 3 4 5 6 7 8 9 10 11 12 // Allow is shorthand for AllowN(time.Now(), 1). func (lim *Limiter)</description>
    </item>
    
    <item>
      <title>单机限流算法总结</title>
      <link>/post/%E5%8D%95%E6%9C%BA%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 04 Nov 2019 11:51:54 +0000</pubDate>
      
      <guid>/post/%E5%8D%95%E6%9C%BA%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
      <description>限流 在开发中我们可能会遇到接口访问频次过高，这时候就需要做流量限制，你可能是用的 Nginx 这种 Web Server 来控制也可能是用了一些流行的类库实现。在分布式系统</description>
    </item>
    
    <item>
      <title>Go中的熔断器:hystrix-Go</title>
      <link>/post/go%E4%B8%AD%E7%9A%84%E7%86%94%E6%96%AD%E5%99%A8hystrix-go/</link>
      <pubDate>Sun, 03 Nov 2019 17:13:27 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E7%9A%84%E7%86%94%E6%96%AD%E5%99%A8hystrix-go/</guid>
      <description>引言 熔断器是当依赖的服务已经出现故障时，为了保证自身服务的正常运行不再访问依赖的服务，防止雪崩效应.Hystrix断路器的工作原理是： 熔断器</description>
    </item>
    
    <item>
      <title>为什么Response.Body需要被关闭</title>
      <link>/post/%E4%B8%BA%E4%BB%80%E4%B9%88response.body%E9%9C%80%E8%A6%81%E8%A2%AB%E5%85%B3%E9%97%AD/</link>
      <pubDate>Thu, 31 Oct 2019 15:27:42 +0000</pubDate>
      
      <guid>/post/%E4%B8%BA%E4%BB%80%E4%B9%88response.body%E9%9C%80%E8%A6%81%E8%A2%AB%E5%85%B3%E9%97%AD/</guid>
      <description>为什么需要关闭? 1 2 3 4 5 6 7 Body io.ReadCloser The http Client and Transport guarantee that Body is always non-nil, even on responses without a body or responses with a zero-length body. It is the caller&amp;#39;s responsibility to close Body. The default HTTP client&amp;#39;s Transport does not attempt to reuse HTTP/1.0 or HTTP/1.1 TCP connections (&amp;#34;keep-alive&amp;#34;) unless the Body is read to</description>
    </item>
    
    <item>
      <title>GoKit使用:链路追踪Zipkin</title>
      <link>/post/gokit%E4%BD%BF%E7%94%A8%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AAzipkin/</link>
      <pubDate>Wed, 30 Oct 2019 14:57:53 +0000</pubDate>
      
      <guid>/post/gokit%E4%BD%BF%E7%94%A8%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AAzipkin/</guid>
      <description>服务端trace 增加trace代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //创建zipkin上报管理器 reporter := http.NewReporter(&amp;#34;http://localhost:9411/api/v2/spans&amp;#34;) //运行结束，关闭上报管理器的f</description>
    </item>
    
    <item>
      <title>GoKit使用:监控功能</title>
      <link>/post/gokit%E4%BD%BF%E7%94%A8%E7%9B%91%E6%8E%A7%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Tue, 29 Oct 2019 16:19:40 +0000</pubDate>
      
      <guid>/post/gokit%E4%BD%BF%E7%94%A8%E7%9B%91%E6%8E%A7%E5%8A%9F%E8%83%BD/</guid>
      <description>引言 目前，几乎所有的研发人员每天都在跟API打交道：后端为实现业务不停的生产API，前端为实现产品功能不停的调用API。API已经成为前端与</description>
    </item>
    
    <item>
      <title>Go中的限流器time-rate</title>
      <link>/post/go%E4%B8%AD%E7%9A%84%E9%99%90%E6%B5%81%E5%99%A8time-rate/</link>
      <pubDate>Tue, 29 Oct 2019 11:04:24 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E7%9A%84%E9%99%90%E6%B5%81%E5%99%A8time-rate/</guid>
      <description>引言 限流器，从字面上理解就是用来限制流量，有时候流量突增(可预期的比如“双11”，不可预期的微博的热门话题等)，会将后端服务压垮，甚至直接宕</description>
    </item>
    
    <item>
      <title>GoKit使用:熔断与限流</title>
      <link>/post/gokit%E4%BD%BF%E7%94%A8%E7%86%94%E6%96%AD%E4%B8%8E%E9%99%90%E6%B5%81/</link>
      <pubDate>Mon, 28 Oct 2019 19:54:31 +0000</pubDate>
      
      <guid>/post/gokit%E4%BD%BF%E7%94%A8%E7%86%94%E6%96%AD%E4%B8%8E%E9%99%90%E6%B5%81/</guid>
      <description>限流 限流实现 gokit 基于go包 golang.org/x/time/rate 内置了一种实现. 本次实现基于gokit内建的类型endpoint.Middleware，该类型实际上是一个func</description>
    </item>
    
    <item>
      <title>GoKit使用:日志功能</title>
      <link>/post/gokit%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Mon, 28 Oct 2019 17:59:10 +0000</pubDate>
      
      <guid>/post/gokit%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD/</guid>
      <description>基础日志 Gokit有自身的基础日志模块,配置如下: 1 2 3 4 5 6 var logger log.Logger { logger = log.NewLogfmtLogger(os.Stderr) //错误输出到控制台 logger = log.With(logger, &amp;#34;ts&amp;#34;, log.DefaultTimestampUTC) logger = log.With(logger, &amp;#34;caller&amp;#34;, log.DefaultCaller) } 如果我们想要加入通用日</description>
    </item>
    
    <item>
      <title>GoKit使用:注册发现</title>
      <link>/post/gokit%E4%BD%BF%E7%94%A8%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0/</link>
      <pubDate>Mon, 28 Oct 2019 17:12:19 +0000</pubDate>
      
      <guid>/post/gokit%E4%BD%BF%E7%94%A8%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0/</guid>
      <description>server 服务注册: 1、连接注册中心 2、注册当前服务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48</description>
    </item>
    
    <item>
      <title>container包解析(1.13)</title>
      <link>/post/container%E5%8C%85%E8%A7%A3%E6%9E%90-1-13/</link>
      <pubDate>Wed, 23 Oct 2019 18:38:22 +0000</pubDate>
      
      <guid>/post/container%E5%8C%85%E8%A7%A3%E6%9E%90-1-13/</guid>
      <description>heap heap包提供了对任意类型（实现了heap.Interface接口）的堆操作。（最小）堆是具有“每个节点都是以其为根的子树中最小值”属性的</description>
    </item>
    
    <item>
      <title>层级时间轮的Golang实现</title>
      <link>/post/%E5%B1%82%E7%BA%A7%E6%97%B6%E9%97%B4%E8%BD%AE%E7%9A%84golang%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 23 Oct 2019 17:21:10 +0000</pubDate>
      
      <guid>/post/%E5%B1%82%E7%BA%A7%E6%97%B6%E9%97%B4%E8%BD%AE%E7%9A%84golang%E5%AE%9E%E7%8E%B0/</guid>
      <description>引言 最近在工作中负责制定重构计划，需要将部分业务代码从 Python 迁移到 Golang。其中一些功能涉及到 Celery 延时任务，所以一直在思考 Golang 中处理延时任务的有</description>
    </item>
    
    <item>
      <title>Golang如何获取MySQL的各类型数据</title>
      <link>/post/golang%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96mysql%E7%9A%84%E5%90%84%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Wed, 23 Oct 2019 13:57:52 +0000</pubDate>
      
      <guid>/post/golang%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96mysql%E7%9A%84%E5%90%84%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE/</guid>
      <description>数据类型对应关系 时间类型的转换 修改DSN 构建 DSN 时增加 loc 指定时区，并区增加对时间的解析。打印出来的 uri： 1 xiaoju:@tcp(127.0.0.1:3306)/test?charset=utf8&amp;amp;loc=Asia%2FShanghai&amp;amp;parseTime=true 后面的 parseTime 必须要有，用法如下： 这样</description>
    </item>
    
    <item>
      <title>Go中TrimLeft和TrimPrefix的区别</title>
      <link>/post/go%E4%B8%ADtrimleft%E5%92%8Ctrimprefix%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 21 Oct 2019 20:07:38 +0000</pubDate>
      
      <guid>/post/go%E4%B8%ADtrimleft%E5%92%8Ctrimprefix%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>问题 看这样一个例子： 1 2 3 4 5 6 7 8 9 10 11 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;strings&amp;#34; ) func main() { str := &amp;#34;/some/key&amp;#34; fmt.Println(strings.TrimLeft(str, &amp;#34;/some&amp;#34;)) } 1 2 3 key Program exited. 上例有正确返回,再看一例: 1 2 3 4 5 6 7 8 9 10 11 package main import</description>
    </item>
    
    <item>
      <title>Go的timer和ticker用法</title>
      <link>/post/go%E7%9A%84timer%E5%92%8Cticker%E7%94%A8%E6%B3%95/</link>
      <pubDate>Mon, 21 Oct 2019 15:53:41 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84timer%E5%92%8Cticker%E7%94%A8%E6%B3%95/</guid>
      <description>定时器:timer time包中有两个函数可以帮我们初始化 time.Timer （类型） 在高性能场景下，不应该使用time.After，而应该使用New.Time</description>
    </item>
    
    <item>
      <title>Go的定时器源码剖析</title>
      <link>/post/go%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Mon, 21 Oct 2019 15:23:59 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description>数据结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 ┌──</description>
    </item>
    
    <item>
      <title>Linux内核时钟系统和定时器实现</title>
      <link>/post/linux%E5%86%85%E6%A0%B8%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 21 Oct 2019 11:44:32 +0000</pubDate>
      
      <guid>/post/linux%E5%86%85%E6%A0%B8%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0/</guid>
      <description>Linux内核时钟系统和定时器实现 Linux 2.6.16之前，内核只支持低精度时钟，内核定时器的工作方式： 系统启动后，会读取时钟源设备(RTC, HP</description>
    </item>
    
    <item>
      <title>单机定时器的实现方案</title>
      <link>/post/%E5%8D%95%E6%9C%BA%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</link>
      <pubDate>Sun, 20 Oct 2019 16:43:10 +0000</pubDate>
      
      <guid>/post/%E5%8D%95%E6%9C%BA%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</guid>
      <description>理解定时器 很多场景会用到定时器，例如 使用 TCP 长连接时，客户端需要定时向服务端发送心跳请求。 财务系统每个月的月末定时生成对账单。 双 11 的 0 点，定时</description>
    </item>
    
    <item>
      <title>异步任务队列:machinery源码剖析</title>
      <link>/post/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97machinery%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Thu, 17 Oct 2019 18:22:26 +0000</pubDate>
      
      <guid>/post/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97machinery%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description>导语 异步任务，是每一位开发者都遇到过的技术名词，在任何一个稍微复杂的后台系统中，异步任务总是无法避免的，而任务队列由于其松耦合、易扩展的特性</description>
    </item>
    
    <item>
      <title>异步任务队列:machinery使用方法</title>
      <link>/post/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97machinery%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 16 Oct 2019 21:09:01 +0000</pubDate>
      
      <guid>/post/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97machinery%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description>Config machinery的配置结构体是config包中的Config类型,具体结构如下: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Config holds all configuration for our program type Config struct {</description>
    </item>
    
    <item>
      <title>分布式延时任务方案</title>
      <link>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%96%B9%E6%A1%88/</link>
      <pubDate>Wed, 16 Oct 2019 17:02:02 +0000</pubDate>
      
      <guid>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%96%B9%E6%A1%88/</guid>
      <description>引言 在开发中，往往会遇到一些关于延时任务的需求。例如 生成订单30分钟未支付，则自动取消 生成订单60秒后,给用户发短信 对上述的任务，我们给一</description>
    </item>
    
    <item>
      <title>Dcron:基于一致性哈希算法实现分布式定时任务</title>
      <link>/post/dcron%E5%9F%BA%E4%BA%8E%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</link>
      <pubDate>Wed, 16 Oct 2019 14:59:13 +0000</pubDate>
      
      <guid>/post/dcron%E5%9F%BA%E4%BA%8E%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</guid>
      <description>背景 在开发过程中，往往需要系统执行一些定时的任务，例如我们需要将数据进行迁移，又或者需要做一些数据的离线统计工作，这些都需要定时任务来进行处</description>
    </item>
    
    <item>
      <title>cron库源码剖析</title>
      <link>/post/cron%E5%BA%93%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Tue, 15 Oct 2019 11:19:03 +0000</pubDate>
      
      <guid>/post/cron%E5%BA%93%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description>Cron表达式 基本cron格式: 1 2 3 4 5 6 7 8 # cron格式說明 # ┌──分鐘（0 - 59） # │ ┌──小時（0 - 23） # | │ ┌──日（1 - 31</description>
    </item>
    
    <item>
      <title>Groupcache的一致性哈希算法</title>
      <link>/post/groupcache%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 14 Oct 2019 13:41:45 +0000</pubDate>
      
      <guid>/post/groupcache%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</guid>
      <description>源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68</description>
    </item>
    
    <item>
      <title>Go如何嵌入静态资源</title>
      <link>/post/go%E5%A6%82%E4%BD%95%E5%B5%8C%E5%85%A5%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/</link>
      <pubDate>Fri, 11 Oct 2019 16:54:16 +0000</pubDate>
      
      <guid>/post/go%E5%A6%82%E4%BD%95%E5%B5%8C%E5%85%A5%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/</guid>
      <description>背景 Go 中一个常被吹捧的特性是 Go 应用容易部署，原因是 Go 写的程序是静态编译的。但在你 运行一个 Web 应用时，如果需要管理一系列文件的路径和权限的话，这</description>
    </item>
    
    <item>
      <title>一致性哈希算法-Maglev算法</title>
      <link>/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95-maglev%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 09 Oct 2019 21:03:19 +0000</pubDate>
      
      <guid>/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95-maglev%E7%AE%97%E6%B3%95/</guid>
      <description>Maglev一致性哈希算法 Maglev哈希算法来自 Google ， 在其2016年发布的一篇论文中[1]， 介绍了自2008年起服役的网络负载均衡器Magl</description>
    </item>
    
    <item>
      <title>一致性哈希算法-跳跃一致性哈希法</title>
      <link>/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95-%E8%B7%B3%E8%B7%83%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E6%B3%95/</link>
      <pubDate>Wed, 09 Oct 2019 21:03:05 +0000</pubDate>
      
      <guid>/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95-%E8%B7%B3%E8%B7%83%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E6%B3%95/</guid>
      <description>算法内容 对于分布式存储系统，当一个节点失效时，我们并不期望它被移除，而是使用备份节点替换它，或者将它恢复起来，因为我们不期望丢掉它上面的数据</description>
    </item>
    
    <item>
      <title>一致性哈希算法-哈希环法</title>
      <link>/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C%E7%8E%AF%E6%B3%95/</link>
      <pubDate>Wed, 09 Oct 2019 21:02:54 +0000</pubDate>
      
      <guid>/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C%E7%8E%AF%E6%B3%95/</guid>
      <description>哈希环法的神秘面纱 哈希环法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而哈希环法是对$2^{32}$取模，什么意思呢</description>
    </item>
    
    <item>
      <title>一致性哈希算法概论</title>
      <link>/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA/</link>
      <pubDate>Wed, 09 Oct 2019 20:03:19 +0000</pubDate>
      
      <guid>/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA/</guid>
      <description>如何代理一个简单的kvdb？ 假如我们有一个简单的kvdb (key-value-database)， 它支持两个简单的操作： 由于单节点系统的服务</description>
    </item>
    
    <item>
      <title>梅森旋转算法与伪随机数</title>
      <link>/post/%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95%E4%B8%8E%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/</link>
      <pubDate>Wed, 09 Oct 2019 18:26:14 +0000</pubDate>
      
      <guid>/post/%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95%E4%B8%8E%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/</guid>
      <description>现代编程语言，大都在标准库中包含了随机库。例如，C++ 在 C++11 标准中添加了 random 头文件，提供了现代的随机库；Python 则有 random。C++11</description>
    </item>
    
    <item>
      <title>线性同余法与伪随机数</title>
      <link>/post/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%B3%95%E4%B8%8E%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/</link>
      <pubDate>Wed, 09 Oct 2019 15:10:17 +0000</pubDate>
      
      <guid>/post/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%B3%95%E4%B8%8E%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/</guid>
      <description>公式定义 在离散数据及其应用中，如果 那么，称a模m同余b（或者称模m时，a等价于b），可以记为 而线性同余式就可以这样表示： 线性同余发生器与上面</description>
    </item>
    
    <item>
      <title>go generate介绍</title>
      <link>/post/go-generate%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Thu, 26 Sep 2019 15:44:33 +0000</pubDate>
      
      <guid>/post/go-generate%E4%BB%8B%E7%BB%8D/</guid>
      <description>介绍 go generate命令是go 1.4版本里面新添加的一个命令，当运行go generate时，它将扫描与当前包相关的源代码文件，找出所有包含</description>
    </item>
    
    <item>
      <title>乐观锁与悲观锁解析</title>
      <link>/post/%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Mon, 23 Sep 2019 21:21:58 +0000</pubDate>
      
      <guid>/post/%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%E8%A7%A3%E6%9E%90/</guid>
      <description></description>
    </item>
    
    <item>
      <title>事务的隔离机制解析</title>
      <link>/post/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Mon, 23 Sep 2019 20:49:41 +0000</pubDate>
      
      <guid>/post/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/</guid>
      <description>数据不一致性 并发操作带来的数据不一致性包括丢失修改、不可重复读和读“脏”数据。 产生上述三类数据不一致性的主要原因是并发操作破坏了事务的隔离性</description>
    </item>
    
    <item>
      <title>分布式系统的死锁处理</title>
      <link>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 23 Sep 2019 10:24:33 +0000</pubDate>
      
      <guid>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/</guid>
      <description>产生死锁的必要条件 互斥使用：进程对其申请的资源进行排他控制，其他申请资源的进程必须等待。 不可剥夺：占用资源的进程只能自己释放资源，不能被其他</description>
    </item>
    
    <item>
      <title>理解CAP和ACID的一致性</title>
      <link>/post/%E7%90%86%E8%A7%A3cap%E5%92%8Cacid%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Fri, 20 Sep 2019 19:50:25 +0000</pubDate>
      
      <guid>/post/%E7%90%86%E8%A7%A3cap%E5%92%8Cacid%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      <description>ACID和CAP定理中都有C，代表Consistent一致性，很多人容易将这两个C混为一谈，其实这两个一致性是有区别的。这里可以区分成“内部</description>
    </item>
    
    <item>
      <title>ACID理论与BASE理论</title>
      <link>/post/acid%E7%90%86%E8%AE%BA%E4%B8%8Ebase%E7%90%86%E8%AE%BA/</link>
      <pubDate>Fri, 20 Sep 2019 17:22:31 +0000</pubDate>
      
      <guid>/post/acid%E7%90%86%E8%AE%BA%E4%B8%8Ebase%E7%90%86%E8%AE%BA/</guid>
      <description>ACID 事务具有4个特性：原子性（Atomicity)、一致性（Consistency)、隔离性（Isolation)和持续性（Durabilit</description>
    </item>
    
    <item>
      <title>初识分布式系统</title>
      <link>/post/%E5%88%9D%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Fri, 20 Sep 2019 15:47:40 +0000</pubDate>
      
      <guid>/post/%E5%88%9D%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</guid>
      <description>集中式系统 在学习分布式之前，先了解一下与之相对应的集中式系统是什么样的。 集中式系统用一句话概括就是：一个主机带多个终端。终端没有数据处理能力</description>
    </item>
    
    <item>
      <title>分布式理论:CAP定理</title>
      <link>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA-cap%E5%AE%9A%E7%90%86/</link>
      <pubDate>Thu, 19 Sep 2019 17:18:05 +0000</pubDate>
      
      <guid>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA-cap%E5%AE%9A%E7%90%86/</guid>
      <description>定义 CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partiti</description>
    </item>
    
    <item>
      <title>用redis实现分布式锁</title>
      <link>/post/%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link>
      <pubDate>Tue, 17 Sep 2019 15:49:58 +0000</pubDate>
      
      <guid>/post/%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid>
      <description>单实例Redis 一个Go的实现：https://github.com/bsm/redislock (基于go-redis) 使用方法: 1 2 3 4 5</description>
    </item>
    
    <item>
      <title>etcd的MVCC</title>
      <link>/post/etcd%E7%9A%84mvcc/</link>
      <pubDate>Mon, 16 Sep 2019 13:50:13 +0000</pubDate>
      
      <guid>/post/etcd%E7%9A%84mvcc/</guid>
      <description>MVCC MVCC（Multi-version Cocurrent Control）即多版本并发控制技术，多用于数据库中的事务管理，其基本思想是保存一个数据的多个历史版</description>
    </item>
    
    <item>
      <title>etcd的事务机制</title>
      <link>/post/etcd%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sat, 07 Sep 2019 21:18:50 +0000</pubDate>
      
      <guid>/post/etcd%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/</guid>
      <description>事务机制 序列化（访问序列化） 像etcd这类分布式一致性系统时常要处理非常多的来自不同并发客户端的并发请求。尽管有众多并发的读和写，原子性依然</description>
    </item>
    
    <item>
      <title>用eTcd实现选举</title>
      <link>/post/%E7%94%A8etcd%E5%AE%9E%E7%8E%B0%E9%80%89%E4%B8%BE/</link>
      <pubDate>Sat, 07 Sep 2019 16:32:17 +0000</pubDate>
      
      <guid>/post/%E7%94%A8etcd%E5%AE%9E%E7%8E%B0%E9%80%89%E4%B8%BE/</guid>
      <description>选举 etcd的选举则需要在我们熟悉它的一系列基本概念后，调动我们充分的想象力： 1、MVCC，key存在版本属性，没被创建时版本号为0； 2、C</description>
    </item>
    
    <item>
      <title>etcd2和3的区别</title>
      <link>/post/etcd2%E5%92%8C3%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 06 Sep 2019 21:18:46 +0000</pubDate>
      
      <guid>/post/etcd2%E5%92%8C3%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>从 etcd2 到 etcd3 etcd 最早是被设计用来解决 CoreOS 升级时机器的协调问题的。现在它被用于分布式网络、服务发现、配置管理、任务调度和负载均衡等服务中。原始设计的部</description>
    </item>
    
    <item>
      <title>用Etcd实现分布式锁</title>
      <link>/post/%E7%94%A8etcd%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link>
      <pubDate>Fri, 06 Sep 2019 20:49:18 +0000</pubDate>
      
      <guid>/post/%E7%94%A8etcd%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid>
      <description>Etcd的v3版本官方client里有一个concurrency的包，里面实现了分布式锁和选主。本文分析一下它是如何实现的。 分布式锁 在cod</description>
    </item>
    
    <item>
      <title>分布式锁的实现</title>
      <link>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Fri, 06 Sep 2019 18:02:26 +0000</pubDate>
      
      <guid>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>为何需要分布式锁 一般我们使用分布式锁有两个场景: 效率:使用分布式锁可以避免不同节点重复相同的工作，这些工作会浪费资源。比如用户付了钱之后有可</description>
    </item>
    
    <item>
      <title>Golang读写Excel</title>
      <link>/post/golang%E8%AF%BB%E5%86%99excel/</link>
      <pubDate>Thu, 05 Sep 2019 18:06:03 +0000</pubDate>
      
      <guid>/post/golang%E8%AF%BB%E5%86%99excel/</guid>
      <description>简介 Excelize 是 Go 语言编写的用于操作 Office Excel 文档类库，基于 ECMA-376 Office OpenXML 标准。可以使用它来读取、写入由 Microsoft Excel™ 2007 及以上版本创建的 XLSX 文档。相比较其他的开源类</description>
    </item>
    
    <item>
      <title>etcd：从应用场景到实现原理的全方位解读</title>
      <link>/post/etcd%E4%BB%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E7%9A%84%E5%85%A8%E6%96%B9%E4%BD%8D%E8%A7%A3%E8%AF%BB/</link>
      <pubDate>Wed, 04 Sep 2019 14:39:33 +0000</pubDate>
      
      <guid>/post/etcd%E4%BB%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E7%9A%84%E5%85%A8%E6%96%B9%E4%BD%8D%E8%A7%A3%E8%AF%BB/</guid>
      <description>很多人对这个问题的第一反应可能是，它是一个键值存储仓库，却没有重视官方定义的后半句，用于配置共享和服务发现。 A highly-available key value store for shared configuration and service discovery. 实际上，e</description>
    </item>
    
    <item>
      <title>Go如何操作etcd</title>
      <link>/post/go%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9Cetcd/</link>
      <pubDate>Mon, 02 Sep 2019 20:17:28 +0000</pubDate>
      
      <guid>/post/go%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9Cetcd/</guid>
      <description>ETCD ETCD是用于共享配置和服务发现的分布式，一致性的KV存储系统。ETCD是CoreOS公司发起的一个开源项目，授权协议为Apache。 核心</description>
    </item>
    
    <item>
      <title>GoKit源码:服务注册与发现</title>
      <link>/post/gokit%E6%BA%90%E7%A0%81%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0/</link>
      <pubDate>Mon, 02 Sep 2019 17:43:22 +0000</pubDate>
      
      <guid>/post/gokit%E6%BA%90%E7%A0%81%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0/</guid>
      <description>etcdv3目录结构 1 2 3 4 5 6 7 8 ├── client.go 客户端 ├── doc.go ├── example_test.go ├── instancer.go 服务实例 ├── instancer_test.go ├── integration_test.go ├── registrar.go 注册器 └── registrar_test.go 目录中主要的是这三个</description>
    </item>
    
    <item>
      <title>MySQL批量SQL插入性能优化</title>
      <link>/post/mysql%E6%89%B9%E9%87%8Fsql%E6%8F%92%E5%85%A5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <pubDate>Thu, 29 Aug 2019 14:13:48 +0000</pubDate>
      
      <guid>/post/mysql%E6%89%B9%E9%87%8Fsql%E6%8F%92%E5%85%A5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <description>对于一些数据量较大的系统，数据库面临的问题除了查询效率低下，还有就是数据入库时间长。特别像报表系统，每天花费在数据导入上的时间可能会长达几个</description>
    </item>
    
    <item>
      <title>如何优雅地比较两个未知结构的JSON</title>
      <link>/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E6%9C%AA%E7%9F%A5%E7%BB%93%E6%9E%84%E7%9A%84json/</link>
      <pubDate>Tue, 27 Aug 2019 10:53:46 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E6%9C%AA%E7%9F%A5%E7%BB%93%E6%9E%84%E7%9A%84json/</guid>
      <description>这是之前遇到的一道面试题，后来也确实在工作中实际遇到了。于是记录一下，如何（优雅的）比较两个未知结构的json。 假设，现在有两个简单的jso</description>
    </item>
    
    <item>
      <title>Go中的map和slice查询性能对比</title>
      <link>/post/go%E4%B8%AD%E7%9A%84map%E5%92%8Cslice%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/</link>
      <pubDate>Mon, 26 Aug 2019 15:21:06 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E7%9A%84map%E5%92%8Cslice%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/</guid>
      <description>看到标题，第一反应，map肯定秒杀slice啊，我当时也是这么想的，毕竟前者的查询复杂度是O(1)，后者是O(n)。 1 2 3 4 5 6 7 8 9 10 11 12</description>
    </item>
    
    <item>
      <title>Go中的slice和map的比较方法</title>
      <link>/post/go%E4%B8%AD%E7%9A%84slice%E5%92%8Cmap%E7%9A%84%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 26 Aug 2019 13:21:13 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E7%9A%84slice%E5%92%8Cmap%E7%9A%84%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95/</guid>
      <description>思路 开发中经常会遇到需要比较两个slice或map包含的元素是否完全相等的情况，一般来说有两个思路： reflect比较的方法 循环遍历比较的方</description>
    </item>
    
    <item>
      <title>Go中的interface{}比较方法</title>
      <link>/post/go%E4%B8%AD%E7%9A%84interface-%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 26 Aug 2019 13:21:07 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E7%9A%84interface-%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95/</guid>
      <description>类型不确定 在不确定类型需要反射的时候，DeepEqual是我们不可不用的强大工具。 比如： 1 2 3 4 5 6 7 func main(){ m1:=map[string]interface{}{&amp;#34;a&amp;#34;:&amp;#34;1&amp;#34;, &amp;#34;b&amp;#34;:2, &amp;#34;c&amp;#34;:3}; m2:=map[string]interface{}{&amp;#34;a&amp;#34;:1, &amp;#34;c&amp;#34;:&amp;#34;3&amp;#34;, &amp;#34;b&amp;#34;:2}; fmt.Println(`reflect.DeepEqual(m1[&amp;#34;a&amp;#34;],m2[&amp;#34;a&amp;#34;]`,reflect.DeepEqual(m1[&amp;#34;a&amp;#34;],m2[&amp;#34;a&amp;#34;])); fmt.Println(`reflect.DeepEqual(m1[&amp;#34;b&amp;#34;],m2[&amp;#34;b&amp;#34;]`,reflect.DeepEqual(m1[&amp;#34;b&amp;#34;],m2[&amp;#34;b&amp;#34;])); } 执行结果： 1 2 3</description>
    </item>
    
    <item>
      <title>DeepEqual浅析</title>
      <link>/post/deepequal%E6%B5%85%E6%9E%90/</link>
      <pubDate>Mon, 19 Aug 2019 20:02:22 +0000</pubDate>
      
      <guid>/post/deepequal%E6%B5%85%E6%9E%90/</guid>
      <description>规则 不同类型的值不会深度相等 Values of distinct types are never deeply equal. 1 2 3 4 5 6 7 8 9 10 type S1 struct { Field int } type S2 struct { Field int } func main() { fmt.Println(reflect.DeepEqual(S1{1}, S2{1})) } 对应输出false 当两个数组的元素对</description>
    </item>
    
    <item>
      <title>Go和HTTPS</title>
      <link>/post/go%E5%92%8Chttps/</link>
      <pubDate>Mon, 19 Aug 2019 13:36:12 +0000</pubDate>
      
      <guid>/post/go%E5%92%8Chttps/</guid>
      <description>HTTPS简介 日常生活中，我们上网用的最多的应用层协议就是HTTP协议了，直至目前全世界的网站中大多数依然只支持HTTP访问。 使用Go创建一</description>
    </item>
    
    <item>
      <title>Go中map的使用方式</title>
      <link>/post/go%E4%B8%ADmap%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Fri, 16 Aug 2019 19:29:21 +0000</pubDate>
      
      <guid>/post/go%E4%B8%ADmap%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</guid>
      <description>初始化 使用 map 的时候需要注意，你需要显式地初始化才能对 map 进行操作. 1 2 var m map[string]string m[&amp;#34;a&amp;#34;]=&amp;#34;sssss&amp;#34; 上面的代码会报 panic: assignment to entry in nil map ，必须用内建的 make() 函数才行. 1 2 m:=make(map[string]string) m[&amp;#34;a&amp;#34;]=&amp;#34;sssss&amp;#34; key</description>
    </item>
    
    <item>
      <title>Go中的内置类型比较</title>
      <link>/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83/</link>
      <pubDate>Fri, 16 Aug 2019 16:25:53 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83/</guid>
      <description>概念 首先区分几个概念：变量可比较，可排序，可赋值 可赋值 规范里面对赋值是这么定义的：https://golang.org/ref/spec#A</description>
    </item>
    
    <item>
      <title>Go语言的浮点数计算</title>
      <link>/post/go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Wed, 14 Aug 2019 18:28:02 +0000</pubDate>
      
      <guid>/post/go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97/</guid>
      <description>浮点数计算不精确 浮点数与整数计算 先看两个case 1 2 3 4 5 6 7 // case1: 135.90*100 ==== // float32 var f1 float32 = 135.90 fmt.Println(f1 * 100) // output:13589.999 // float64 var f2 float64 = 135.90 fmt.Println(f2 * 100) // output:13590 浮点数在单精度下, 13</description>
    </item>
    
    <item>
      <title>IEEE 754浮点数标准详解</title>
      <link>/post/ieee-754%E6%B5%AE%E7%82%B9%E6%95%B0%E6%A0%87%E5%87%86%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 14 Aug 2019 10:50:56 +0000</pubDate>
      
      <guid>/post/ieee-754%E6%B5%AE%E7%82%B9%E6%95%B0%E6%A0%87%E5%87%86%E8%AF%A6%E8%A7%A3/</guid>
      <description>在计算机系统的发展过程中，业界曾经提出过许多种实数的表达方法，比较典型的有相对于浮点数（Floating Point Number）的定点数（Fixed</description>
    </item>
    
    <item>
      <title>go语言为什么没有min/max(int, int)函数</title>
      <link>/post/go%E8%AF%AD%E8%A8%80%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89min-max-int-int-%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 13 Aug 2019 20:13:15 +0000</pubDate>
      
      <guid>/post/go%E8%AF%AD%E8%A8%80%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89min-max-int-int-%E5%87%BD%E6%95%B0/</guid>
      <description>为什么没有? 我们知道go语言math包里面定义了min/max函数，但是是float64类型的，而并没有整数类型的min/max。 go语言的</description>
    </item>
    
    <item>
      <title>cookie-session机制与JWT机制对比</title>
      <link>/post/cookie-session%E6%9C%BA%E5%88%B6%E4%B8%8Ejwt%E6%9C%BA%E5%88%B6%E5%AF%B9%E6%AF%94/</link>
      <pubDate>Tue, 06 Aug 2019 15:17:51 +0000</pubDate>
      
      <guid>/post/cookie-session%E6%9C%BA%E5%88%B6%E4%B8%8Ejwt%E6%9C%BA%E5%88%B6%E5%AF%B9%E6%AF%94/</guid>
      <description>前言 认证和授权，其实吧简单来说就是:认证就是让服务器知道你是谁，授权就是服务器让你知道你什么能干，什么不能干，认证授权俩种方式：Sessio</description>
    </item>
    
    <item>
      <title>Go Modules 浅析</title>
      <link>/post/go-modules-%E6%B5%85%E6%9E%90/</link>
      <pubDate>Thu, 25 Jul 2019 10:49:06 +0000</pubDate>
      
      <guid>/post/go-modules-%E6%B5%85%E6%9E%90/</guid>
      <description>go mod 命令 1 2 3 4 5 6 7 8 download download modules to local cache (下载依赖的module到本地cache)) edit edit go.mod from tools or scripts (编辑go.mod文件) graph print module requirement graph (打印模块依</description>
    </item>
    
    <item>
      <title>reflect包解析</title>
      <link>/post/reflect%E5%8C%85%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sun, 21 Jul 2019 21:41:17 +0000</pubDate>
      
      <guid>/post/reflect%E5%8C%85%E8%A7%A3%E6%9E%90/</guid>
      <description>func Copy 1 func Copy(dst, src Value) int Copy将src的内容复制到dst，直到dst已填满或src已用完为止。它返回复制的元素数。Dst和src必须具有类型的Sl</description>
    </item>
    
    <item>
      <title>OLTP与OLAP的介绍</title>
      <link>/post/oltp%E4%B8%8Eolap%E7%9A%84%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Fri, 19 Jul 2019 17:34:37 +0000</pubDate>
      
      <guid>/post/oltp%E4%B8%8Eolap%E7%9A%84%E4%BB%8B%E7%BB%8D/</guid>
      <description>介绍 数据处理大致可以分成两大类：联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Proc</description>
    </item>
    
    <item>
      <title>mongo-go-driver使用总结</title>
      <link>/post/mongo-go-driver%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 16 Jul 2019 16:38:41 +0000</pubDate>
      
      <guid>/post/mongo-go-driver%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</guid>
      <description>创建main 创建文件main.go并导入bson，mongo和mongo/options包： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main</description>
    </item>
    
    <item>
      <title>types from different packages 问题浅析</title>
      <link>/post/types-from-different-packages-%E9%97%AE%E9%A2%98%E6%B5%85%E6%9E%90/</link>
      <pubDate>Tue, 16 Jul 2019 14:44:54 +0000</pubDate>
      
      <guid>/post/types-from-different-packages-%E9%97%AE%E9%A2%98%E6%B5%85%E6%9E%90/</guid>
      <description>先看一段代码: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main var X interface{} type T struct{} func F() { type T struct{} X = T{} } func G() { type T struct{} _ = X.(T) } func main() { F() G() } 我们总是可以说“来</description>
    </item>
    
    <item>
      <title>Go的调度器源码剖析</title>
      <link>/post/go%E7%9A%84%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Fri, 12 Jul 2019 13:29:52 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description>设计原理 协程 进程时代 最初的计算机上面没有操作系统，更别提进程、线程和协程了。 后来，现代化的计算机有了操作系统，每个程序都是一个进程，但是操作</description>
    </item>
    
    <item>
      <title>为什么不要在单个sql.Tx中使用协程</title>
      <link>/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E5%9C%A8%E5%8D%95%E4%B8%AAsql.tx%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Thu, 04 Jul 2019 16:03:49 +0000</pubDate>
      
      <guid>/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E5%9C%A8%E5%8D%95%E4%B8%AAsql.tx%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B/</guid>
      <description>问题来源 简单来说就是企图在一个事务中开启多个协程执行并发查询,会出现busy buffer的问题 接下来这篇文章将尝试深入探讨产生 busy buffer 的根本原因</description>
    </item>
    
    <item>
      <title>配置sql.DB获得更好的性能</title>
      <link>/post/%E9%85%8D%E7%BD%AEsql-db%E8%8E%B7%E5%BE%97%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%80%A7%E8%83%BD/</link>
      <pubDate>Thu, 04 Jul 2019 14:44:14 +0000</pubDate>
      
      <guid>/post/%E9%85%8D%E7%BD%AEsql-db%E8%8E%B7%E5%BE%97%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%80%A7%E8%83%BD/</guid>
      <description>事实上你可以使用SetMaxOpenConns（）、SetMaxIdleConns（）和SetConnmaxLifetime（）方法。来配置</description>
    </item>
    
    <item>
      <title>MySQL各种超时参数的含义</title>
      <link>/post/mysql%E5%90%84%E7%A7%8D%E8%B6%85%E6%97%B6%E5%8F%82%E6%95%B0%E7%9A%84%E5%90%AB%E4%B9%89/</link>
      <pubDate>Wed, 03 Jul 2019 19:05:49 +0000</pubDate>
      
      <guid>/post/mysql%E5%90%84%E7%A7%8D%E8%B6%85%E6%97%B6%E5%8F%82%E6%95%B0%E7%9A%84%E5%90%AB%E4%B9%89/</guid>
      <description>简介 今日在查看锁超时的设置时，看到show variables like &amp;lsquo;%timeout%&#39;;语句输出结果中的十几种超时参数时突然想整理一下，不知道大家</description>
    </item>
    
    <item>
      <title>UUID算法浅析</title>
      <link>/post/uuid%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/</link>
      <pubDate>Sun, 30 Jun 2019 16:48:48 +0000</pubDate>
      
      <guid>/post/uuid%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/</guid>
      <description>UUID UUID的全称是universally unique identifier，全局唯一认证，它是一个128比特的数字，用来辨认计算机系统中的信息。术语GU</description>
    </item>
    
    <item>
      <title>Mysql主键设计</title>
      <link>/post/mysql%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Sun, 30 Jun 2019 16:36:54 +0000</pubDate>
      
      <guid>/post/mysql%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1/</guid>
      <description>MySQL主键设计原则 MySQL主键应当是对用户没有意义的 所有涉及到业务的字段，无论它看上去是否唯一，都决不能用作主键。例如，用户表的Ema</description>
    </item>
    
    <item>
      <title>TP50、TP90、TP99、TP999解释</title>
      <link>/post/tp50tp90tp99tp999%E8%A7%A3%E9%87%8A/</link>
      <pubDate>Sun, 30 Jun 2019 16:00:41 +0000</pubDate>
      
      <guid>/post/tp50tp90tp99tp999%E8%A7%A3%E9%87%8A/</guid>
      <description>TP=Top Percentile，Top百分数，是一个统计学里的术语，与平均数、中位数都是一类。 TP50、TP90和TP99等指标常用于系统性能监控场</description>
    </item>
    
    <item>
      <title>分布式ID生成:leaf算法浅析</title>
      <link>/post/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90-leaf%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/</link>
      <pubDate>Sun, 30 Jun 2019 14:29:50 +0000</pubDate>
      
      <guid>/post/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90-leaf%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/</guid>
      <description>Leaf-segment Leaf-segment方案，在使用数据库的方案上，做了如下改变： 原方案每次获取ID都得读写一次数据库，造成数据库压力大。改为利用prox</description>
    </item>
    
    <item>
      <title>分布式ID生成方案简单总结</title>
      <link>/post/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 29 Jun 2019 16:59:28 +0000</pubDate>
      
      <guid>/post/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/</guid>
      <description>背景 在我们的业务需求中通常有需要一些唯一的ID，来记录我们某个数据的标识: 某个用户的ID 某个订单的单号 某个信息的ID 通常我们会调研各种各样的</description>
    </item>
    
    <item>
      <title>分布式ID生成:snowflake算法浅析</title>
      <link>/post/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90-snowflake%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/</link>
      <pubDate>Thu, 27 Jun 2019 19:31:40 +0000</pubDate>
      
      <guid>/post/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90-snowflake%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/</guid>
      <description>snowflake 大部分分布式系统中，对一些互斥资源通常需要一个集群唯一的ID，比如消息id，订单号等。而且很多业务需求往往要求这些ID必须具有先后顺序，以</description>
    </item>
    
    <item>
      <title>etcdctl命令操作</title>
      <link>/post/etcdctl%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 23 Jun 2019 13:40:47 +0000</pubDate>
      
      <guid>/post/etcdctl%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/</guid>
      <description>etcdctl v2 v3 etcd2和etcd3是不兼容的，两者的api参数也不一样，详细请查看 etcdctl -h 。 可以使用api2 和 api3 写入 etcd3 数据，但是需要注意，使用不同的a</description>
    </item>
    
    <item>
      <title>etcd部署与配置</title>
      <link>/post/etcd%E9%83%A8%E7%BD%B2%E4%B8%8E%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 17 Jun 2019 14:09:04 +0000</pubDate>
      
      <guid>/post/etcd%E9%83%A8%E7%BD%B2%E4%B8%8E%E9%85%8D%E7%BD%AE/</guid>
      <description>集群配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66</description>
    </item>
    
    <item>
      <title>Go中mysql驱动的DSN解析</title>
      <link>/post/go%E4%B8%ADmysql%E9%A9%B1%E5%8A%A8%E7%9A%84dsn%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 11 Jun 2019 16:15:20 +0000</pubDate>
      
      <guid>/post/go%E4%B8%ADmysql%E9%A9%B1%E5%8A%A8%E7%9A%84dsn%E8%A7%A3%E6%9E%90/</guid>
      <description>DSN 数据源名称具有通用格式，例如PEAR DB使用它，但没有类型前缀（可选部分用方括号标记）： 1 [username[:password]@][protocol[(address)]]/dbname[?param1=value1&amp;amp;...&amp;amp;paramN=valueN] DSN最完整的形式： 1 username:password@protocol(address)/dbname?param=value 除databasena</description>
    </item>
    
    <item>
      <title>Golang事务使用的正确方法</title>
      <link>/post/golang%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 06 Jun 2019 16:35:08 +0000</pubDate>
      
      <guid>/post/golang%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%96%B9%E6%B3%95/</guid>
      <description>defer防止panic 利用 Commit() 之后 Rollback() 不会真正执行的特性,可以在创建tx时使用defer防止panic出现没有释放tx 1 2 3 4 5 6 7 8 9 10 11 12</description>
    </item>
    
    <item>
      <title>println与fmt.Println</title>
      <link>/post/println%E4%B8%8Efmt-println/</link>
      <pubDate>Tue, 04 Jun 2019 16:42:08 +0000</pubDate>
      
      <guid>/post/println%E4%B8%8Efmt-println/</guid>
      <description>简介 println是一种内置于语言中的函数。它位于规范的Bootstrapping部分。 当前实现提供了几个在引导期间有用的内置函数。记录这些</description>
    </item>
    
    <item>
      <title>Go中的nil解析</title>
      <link>/post/go%E4%B8%AD%E7%9A%84nil%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 04 Jun 2019 14:31:13 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E7%9A%84nil%E8%A7%A3%E6%9E%90/</guid>
      <description>定义 nil 为预声明的标示符，定义在builtin/builtin.go， 1 2 3 4 5 6 7 8 9 // nil is a predeclared identifier representing the zero value for a // pointer, channel, func, interface, map, or slice type. // Type must be a pointer,</description>
    </item>
    
    <item>
      <title>Go处理数据库的NULL</title>
      <link>/post/go%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84null/</link>
      <pubDate>Tue, 04 Jun 2019 11:32:07 +0000</pubDate>
      
      <guid>/post/go%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84null/</guid>
      <description>golang是强类型语言，在赋值和解析过程中需要先定义好数据类型，否在会报类型错误，下面总结在处理数据库表时遇到字段为空或零值的情况 场景 假如</description>
    </item>
    
    <item>
      <title>优秀的代码都是如何分层的？</title>
      <link>/post/%E4%BC%98%E7%A7%80%E7%9A%84%E4%BB%A3%E7%A0%81%E9%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%86%E5%B1%82%E7%9A%84/</link>
      <pubDate>Mon, 03 Jun 2019 13:40:42 +0000</pubDate>
      
      <guid>/post/%E4%BC%98%E7%A7%80%E7%9A%84%E4%BB%A3%E7%A0%81%E9%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%86%E5%B1%82%E7%9A%84/</guid>
      <description>一、背景 说起应用分层，大部分人都会认为这个不是很简单嘛 就controller，service, mapper三层。看起来简单，很多人其实并没有</description>
    </item>
    
    <item>
      <title>Go语言MySQL中如何为单个事务设置隔离级别</title>
      <link>/post/go%E8%AF%AD%E8%A8%80mysql%E4%B8%AD%E5%A6%82%E4%BD%95%E4%B8%BA%E5%8D%95%E4%B8%AA%E4%BA%8B%E5%8A%A1%E8%AE%BE%E7%BD%AE%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</link>
      <pubDate>Thu, 25 Apr 2019 16:16:38 +0000</pubDate>
      
      <guid>/post/go%E8%AF%AD%E8%A8%80mysql%E4%B8%AD%E5%A6%82%E4%BD%95%E4%B8%BA%E5%8D%95%E4%B8%AA%E4%BA%8B%E5%8A%A1%E8%AE%BE%E7%BD%AE%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</guid>
      <description>MySQL 相比起简单的锁表，事务提供了更好的并发性能，但同时也带来更大的复杂性，如隔离级别，mvcc，死锁等。网上关于事务隔离级别的介绍遍地都是，就</description>
    </item>
    
    <item>
      <title>NATS:高性能轻量级消息队列浅析</title>
      <link>/post/nats-%E9%AB%98%E6%80%A7%E8%83%BD%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%B5%85%E6%9E%90/</link>
      <pubDate>Thu, 25 Apr 2019 15:14:52 +0000</pubDate>
      
      <guid>/post/nats-%E9%AB%98%E6%80%A7%E8%83%BD%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%B5%85%E6%9E%90/</guid>
      <description>简介 NATS是一个开源、轻量级、高性能的分布式消息中间件，实现了高可伸缩性和优雅的Publish/Subscribe模型，使用Golang语</description>
    </item>
    
    <item>
      <title>NATS Streaming浅析</title>
      <link>/post/nats-streaming%E6%B5%85%E6%9E%90/</link>
      <pubDate>Wed, 24 Apr 2019 17:05:20 +0000</pubDate>
      
      <guid>/post/nats-streaming%E6%B5%85%E6%9E%90/</guid>
      <description>简介 基本的NATS服务器专为高性能和简洁而设计，它不会为通过NATS发布的消息提供持久性存储。缺乏对消息的持久存储对于许多分布式系统来说都是</description>
    </item>
    
    <item>
      <title>NSQ:异步消息队列浅析</title>
      <link>/post/nsq-%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%B5%85%E6%9E%90/</link>
      <pubDate>Mon, 22 Apr 2019 18:34:24 +0000</pubDate>
      
      <guid>/post/nsq-%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%B5%85%E6%9E%90/</guid>
      <description>NSQ组件 NSQ 是由四个重要组件构成： nsqd：一个负责接收、排队、转发消息到客户端的守护进程 nsqlookupd：管理拓扑信息并提供最终一致性</description>
    </item>
    
    <item>
      <title>Go中捕获panic信息到日志文件中</title>
      <link>/post/go%E4%B8%AD%E6%8D%95%E8%8E%B7panic%E4%BF%A1%E6%81%AF%E5%88%B0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E4%B8%AD/</link>
      <pubDate>Mon, 22 Apr 2019 10:36:47 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E6%8D%95%E8%8E%B7panic%E4%BF%A1%E6%81%AF%E5%88%B0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E4%B8%AD/</guid>
      <description>根据“墨菲定律”，我们编写的后台的服务都有出现crash的可能，一种情况是Go的后台服务我们经常也会遇到panic的情况。出问题不可怕，我们</description>
    </item>
    
    <item>
      <title>Go语言在Linux终端输出彩色字符</title>
      <link>/post/go%E8%AF%AD%E8%A8%80%E5%9C%A8linux%E7%BB%88%E7%AB%AF%E8%BE%93%E5%87%BA%E5%BD%A9%E8%89%B2%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Thu, 18 Apr 2019 13:13:00 +0000</pubDate>
      
      <guid>/post/go%E8%AF%AD%E8%A8%80%E5%9C%A8linux%E7%BB%88%E7%AB%AF%E8%BE%93%E5%87%BA%E5%BD%A9%E8%89%B2%E5%AD%97%E7%AC%A6/</guid>
      <description>Linux终端输出颜色 开发工作中经常见到终端中各种命令输出的彩色文字，例如 ls 命令就以不同颜色表示文件的不同类型。 而在我们自己写的程序输出的信</description>
    </item>
    
    <item>
      <title>Golang的单引号、双引号与反引号</title>
      <link>/post/golang%E7%9A%84%E5%8D%95%E5%BC%95%E5%8F%B7%E5%8F%8C%E5%BC%95%E5%8F%B7%E4%B8%8E%E5%8F%8D%E5%BC%95%E5%8F%B7/</link>
      <pubDate>Sun, 14 Apr 2019 16:45:01 +0000</pubDate>
      
      <guid>/post/golang%E7%9A%84%E5%8D%95%E5%BC%95%E5%8F%B7%E5%8F%8C%E5%BC%95%E5%8F%B7%E4%B8%8E%E5%8F%8D%E5%BC%95%E5%8F%B7/</guid>
      <description>简介 一个Go语言字符串是一个任意字节的常量序列。Go语言的字符串类型在本质上就与其他语言的字符串类型不同。 Java的String、C++的s</description>
    </item>
    
    <item>
      <title>更优雅的Go错误处理</title>
      <link>/post/%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84go%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <pubDate>Fri, 05 Apr 2019 21:50:59 +0000</pubDate>
      
      <guid>/post/%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84go%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <description>错误类型解析 error 接口 Go 继承了 C，以返回值为错误处理的主要方式。但与 C 不同的是，在 Go 的惯用法中，返回值不是整型等常用返回值类型（errno），而</description>
    </item>
    
    <item>
      <title>Go中的内置函数</title>
      <link>/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 04 Apr 2019 17:19:42 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</guid>
      <description>func new 1 func new(Type) *Type 内建函数new分配内存。其第一个实参为类型，而非值。其返回值为指向该类型的新分配的零值的指针。 在调用new函数时，将类型名作为参</description>
    </item>
    
    <item>
      <title>context包解析(1.11)</title>
      <link>/post/context%E5%8C%85%E8%A7%A3%E6%9E%90-1-11/</link>
      <pubDate>Mon, 25 Mar 2019 17:53:14 +0000</pubDate>
      
      <guid>/post/context%E5%8C%85%E8%A7%A3%E6%9E%90-1-11/</guid>
      <description>包context定义了上下文类型，它跨API边界和进程之间承载截止日期、取消信号和其他请求范围的值。 对服务器的传入请求应创建context，</description>
    </item>
    
    <item>
      <title>神奇的2006-01-02 15:04:05</title>
      <link>/post/%E7%A5%9E%E5%A5%87%E7%9A%842006-01-02-15-04-05/</link>
      <pubDate>Wed, 13 Feb 2019 16:58:24 +0000</pubDate>
      
      <guid>/post/%E7%A5%9E%E5%A5%87%E7%9A%842006-01-02-15-04-05/</guid>
      <description>神奇的日期 刚接触Golang时，阅读代码的时候总会在代码中发现这么一个日期， 1 2006-01-02 15:04:05 刚看到这段代码的时候，我当时想：这个人好随便啊，随便写一个</description>
    </item>
    
    <item>
      <title>sort包解析(1.11)</title>
      <link>/post/sort%E5%8C%85%E8%A7%A3%E6%9E%90-1-11/</link>
      <pubDate>Tue, 29 Jan 2019 15:49:44 +0000</pubDate>
      
      <guid>/post/sort%E5%8C%85%E8%A7%A3%E6%9E%90-1-11/</guid>
      <description>func Float64s 1 func Float64s（a [] float64） Float64s按递增顺序对一组切片的float64进行排序（非数值被视为小于其他值）。 1 2</description>
    </item>
    
    <item>
      <title>Go中接口的类型转换与判断</title>
      <link>/post/go%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%88%A4%E6%96%AD/</link>
      <pubDate>Mon, 28 Jan 2019 19:22:50 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%88%A4%E6%96%AD/</guid>
      <description>类型转换和类型断言 Go语言的类型转换和类型断言: 类型转换在编译期完成，包括强制转换和隐式转换 类型断言在运行时确定，包括安全类型断言和非安全类</description>
    </item>
    
    <item>
      <title>Go中的内置类型转换</title>
      <link>/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Sat, 26 Jan 2019 21:22:18 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description>隐型转换 转换是T（x）形式的表达式，其中T是类型，x是可以转换为类型T的表达式。 1 Conversion = Type &amp;#34;(&amp;#34; Expression [ &amp;#34;,&amp;#34; ] &amp;#34;)&amp;#34; . 如果类型以operator *或&amp;lt;</description>
    </item>
    
    <item>
      <title>Go中获取程序所在目录</title>
      <link>/post/go%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F%E6%89%80%E5%9C%A8%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Fri, 25 Jan 2019 15:47:00 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F%E6%89%80%E5%9C%A8%E7%9B%AE%E5%BD%95/</guid>
      <description>代码1： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; &amp;#34;path/filepath&amp;#34; ) func main() { dir, err := filepath.Abs(filepath.Dir(os.Args[0])) if err != nil { log.Fatal(err) } fmt.Println(dir) } 代码2： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( &amp;#34;fmt&amp;#34;</description>
    </item>
    
    <item>
      <title>Go中文件及文件夹相关操作</title>
      <link>/post/go%E4%B8%AD%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Fri, 25 Jan 2019 14:43:50 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</guid>
      <description>万物皆文件 UNIX 的一个基础设计就是&amp;quot;万物皆文件&amp;rdquo;(everything is a file)。我们不必知道一个文件到底映射成什么，</description>
    </item>
    
    <item>
      <title>Go实现重入锁</title>
      <link>/post/go%E5%AE%9E%E7%8E%B0%E9%87%8D%E5%85%A5%E9%94%81/</link>
      <pubDate>Fri, 25 Jan 2019 13:18:41 +0000</pubDate>
      
      <guid>/post/go%E5%AE%9E%E7%8E%B0%E9%87%8D%E5%85%A5%E9%94%81/</guid>
      <description>重入锁 接下来,我们来讨论“重入”这个问题。在说这个问题前,我先解释一下个概念,叫“可重入锁”。 当一个线程获取锁时,如果没有其它线程拥有这个锁</description>
    </item>
    
    <item>
      <title>Go语言的可变参数详解</title>
      <link>/post/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 15 Jan 2019 20:46:21 +0000</pubDate>
      
      <guid>/post/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/</guid>
      <description>什么是可变参数函数？ 可变参数函数即其参数数量是可变的 —— 0 个或多个。声明可变参数函数的方式是在其参数类型前带上省略符（三个点）前缀。 译者注：</description>
    </item>
    
    <item>
      <title>Go中Map类型Chan类型和Slice类型在函数中的传递</title>
      <link>/post/go%E4%B8%ADmap%E7%B1%BB%E5%9E%8Bchan%E7%B1%BB%E5%9E%8B%E5%92%8Cslice%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E4%BC%A0%E9%80%92/</link>
      <pubDate>Thu, 10 Jan 2019 20:17:20 +0000</pubDate>
      
      <guid>/post/go%E4%B8%ADmap%E7%B1%BB%E5%9E%8Bchan%E7%B1%BB%E5%9E%8B%E5%92%8Cslice%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E4%BC%A0%E9%80%92/</guid>
      <description>什么是传值（值传递） 传值的意思是：函数传递的总是原来这个东西的一个副本，一副拷贝。比如我们传递一个int类型的参数，传递的其实是这个参数的一</description>
    </item>
    
    <item>
      <title>GO中使用select实现带优先级的channel队列</title>
      <link>/post/go%E4%B8%AD%E4%BD%BF%E7%94%A8select%E5%AE%9E%E7%8E%B0%E5%B8%A6%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84channel%E9%98%9F%E5%88%97/</link>
      <pubDate>Wed, 09 Jan 2019 20:39:44 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E4%BD%BF%E7%94%A8select%E5%AE%9E%E7%8E%B0%E5%B8%A6%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84channel%E9%98%9F%E5%88%97/</guid>
      <description>一般Go语言同时使用多个channel的方法是使用select/case语句配合&amp;lt;-操作符，比如 1 2 3 4 5 6 select { case &amp;lt;- chan1: // do something case &amp;lt;- chan2: // do</description>
    </item>
    
    <item>
      <title>package:sync(1.13)</title>
      <link>/post/packagesync1.13/</link>
      <pubDate>Wed, 09 Jan 2019 20:06:49 +0000</pubDate>
      
      <guid>/post/packagesync1.13/</guid>
      <description>type Cond Cond实现了一个条件变量，一个等待或宣布事件发生的goroutines的集合点。 每个Cond都有一个相关的Locker L（通常是* Mu</description>
    </item>
    
    <item>
      <title>在GO中用名字调用函数</title>
      <link>/post/%E5%9C%A8go%E4%B8%AD%E7%94%A8%E5%90%8D%E5%AD%97%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 09 Jan 2019 16:12:05 +0000</pubDate>
      
      <guid>/post/%E5%9C%A8go%E4%B8%AD%E7%94%A8%E5%90%8D%E5%AD%97%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/</guid>
      <description>Golang 中的函数跟 C 的一样，是个代码块，由于golong中函数也是类型,它可以像其他类型那样赋值给一个变量。 在 Golang 中，你不能这样做： 1 2 3 4 5 func foobar() {</description>
    </item>
    
    <item>
      <title>append的陷阱</title>
      <link>/post/append%E7%9A%84%E9%99%B7%E9%98%B1/</link>
      <pubDate>Sat, 05 Jan 2019 11:24:39 +0000</pubDate>
      
      <guid>/post/append%E7%9A%84%E9%99%B7%E9%98%B1/</guid>
      <description>背景 问题代码如下： 1 2 3 4 5 6 7 8 9 10 11 package main import &amp;#34;fmt&amp;#34; func main() { s := []byte(&amp;#34;&amp;#34;) s1 := append(s, &amp;#39;a&amp;#39;) s2 := append(s, &amp;#39;b&amp;#39;) //fmt.Println(s1, &amp;#34;==========&amp;#34;, s2) fmt.Println(string(s1), &amp;#34;==========&amp;#34;, string(s2)) } // 出现个让我理解不了的现象, 注释时候输出是 b ========== b //</description>
    </item>
    
    <item>
      <title>Go中的make和new的区别</title>
      <link>/post/go%E4%B8%AD%E7%9A%84make%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Wed, 26 Dec 2018 21:26:14 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E7%9A%84make%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>new(T) 返回的是 T 的指针 new(T) 为一个 T 类型新值分配空间并将此空间初始化为 T 的零值，返回的是新值的地址，也就是 T 类型的指针 *T，该指针指向 T 的新分配的零</description>
    </item>
    
    <item>
      <title>Go的编译优化:逃逸分析</title>
      <link>/post/go%E7%9A%84%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 21 Dec 2018 14:54:40 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</guid>
      <description>变量的生命周期 生命周期是指程序执行过程中变量存在的时间段。下面我们分别来看看包变量（全局变量）和局部变量两种变量的生命周期。 包变量一直常驻在</description>
    </item>
    
    <item>
      <title>time包解析(1.11)</title>
      <link>/post/time%E5%8C%85%E8%A7%A3%E6%9E%90-1-13/</link>
      <pubDate>Fri, 21 Dec 2018 13:23:32 +0000</pubDate>
      
      <guid>/post/time%E5%8C%85%E8%A7%A3%E6%9E%90-1-13/</guid>
      <description>常量 这些预定义的版式用于Time.Format和Time.Parse函数。用在版式中的参考时间是： 1 Mon Jan 2 15:04:05 MST 2006 对应的Unix时间是1136</description>
    </item>
    
    <item>
      <title> Gin实现自动注册路由</title>
      <link>/post/gin%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%86%8C%E8%B7%AF%E7%94%B1/</link>
      <pubDate>Fri, 21 Dec 2018 12:53:03 +0000</pubDate>
      
      <guid>/post/gin%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%86%8C%E8%B7%AF%E7%94%B1/</guid>
      <description>因为在使用gin框架，在配置路由的时候需要手动配置，如下: 1 2 r.GET(&amp;#34;/page&amp;#34;,controller.Page) r.GET(&amp;#34;/index&amp;#34;,controller.Index) 其中controller是包名，如果在controller包中再增加方法，</description>
    </item>
    
    <item>
      <title>database-sql包源码剖析</title>
      <link>/post/database-sql%E5%8C%85%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Thu, 20 Dec 2018 15:40:47 +0000</pubDate>
      
      <guid>/post/database-sql%E5%8C%85%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description>连接与连接池 database/sql database/sql是golang的标准库之一，它提供了一系列接口方法，用于访问关系数据库。它并不会提供数据库特有的方法，</description>
    </item>
    
    <item>
      <title>Go连接MySql数据库too many connections错误解决</title>
      <link>/post/go%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93too-many-connections%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</link>
      <pubDate>Thu, 20 Dec 2018 14:07:16 +0000</pubDate>
      
      <guid>/post/go%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93too-many-connections%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</guid>
      <description>连接Mysql数据库，在有一定量的查询结果以后，会出先too many connection的错误。 google了一下，很多文章都建议修改MySql的</description>
    </item>
    
    <item>
      <title>database/sql包解析(1.11)</title>
      <link>/post/database-sql%E5%8C%85%E8%A7%A3%E6%9E%90-1-11/</link>
      <pubDate>Tue, 18 Dec 2018 17:57:32 +0000</pubDate>
      
      <guid>/post/database-sql%E5%8C%85%E8%A7%A3%E6%9E%90-1-11/</guid>
      <description>Variables 对于已经返回到连接池的连接执行的任何操作，都会返回ErrConnDone。 1 var ErrConnDone = errors.New(&amp;#34;sql: connection is already closed&amp;#34;) 当QueryRow方法没有返回一个row时，调</description>
    </item>
    
    <item>
      <title>如何优雅地控制goroutine</title>
      <link>/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E6%8E%A7%E5%88%B6goroutine/</link>
      <pubDate>Fri, 14 Dec 2018 18:17:38 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E6%8E%A7%E5%88%B6goroutine/</guid>
      <description>如何控制goroutine的数量 用什么方法控制goroutine的数量？ 要在每一次执行go之前判断goroutine的数量，如果数量超了，就</description>
    </item>
    
    <item>
      <title>Golang中的闭包</title>
      <link>/post/golang%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/</link>
      <pubDate>Thu, 13 Dec 2018 20:24:03 +0000</pubDate>
      
      <guid>/post/golang%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/</guid>
      <description>函数式编程概论 在过去近十年时间里，面向对象编程大行其道，以至于在大学的教育里，老师也只会教给我们两种编程模型，面向过程和面向对象。孰不知，在</description>
    </item>
    
    <item>
      <title>Go实现HTTP长连接和短连接</title>
      <link>/post/go%E5%AE%9E%E7%8E%B0http%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Thu, 13 Dec 2018 15:33:35 +0000</pubDate>
      
      <guid>/post/go%E5%AE%9E%E7%8E%B0http%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5/</guid>
      <description>TCP的长连接与短连接 Server和Client建立通讯后，确保连接的及时断开就非常重要。否则，多个客户端长时间占用着连接不关闭，是非常可怕</description>
    </item>
    
    <item>
      <title>HTTP中的长连接与短连接</title>
      <link>/post/http%E4%B8%AD%E7%9A%84%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Thu, 13 Dec 2018 13:43:21 +0000</pubDate>
      
      <guid>/post/http%E4%B8%AD%E7%9A%84%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5/</guid>
      <description>HTTP协议与TCP/IP协议的关系 HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题</description>
    </item>
    
    <item>
      <title>Go中的可寻址详解</title>
      <link>/post/go%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%AF%BB%E5%9D%80%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 12 Dec 2018 20:02:18 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%AF%BB%E5%9D%80%E8%AF%A6%E8%A7%A3/</guid>
      <description>Go语言规范中规定了可寻址(addressable)对象的定义, For an operand x of type T, the address operation &amp;amp;x generates a pointer of type *T to x. The operand must be addressable, that is, either a variable, pointer indirection, or slice indexing operation; or a field</description>
    </item>
    
    <item>
      <title>空结构体struct{}解析</title>
      <link>/post/%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93struct-%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 12 Dec 2018 17:41:14 +0000</pubDate>
      
      <guid>/post/%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93struct-%E8%A7%A3%E6%9E%90/</guid>
      <description>空对象 空对象是个神奇的东西。它指的是没有字段的结构类型。 1 type Q struct{} 不占用空间,长度为0 1 2 var s struct{} fmt.Println(unsafe.Sizeof(s)) // prints 0 如果结构体中仅有一个空结构字段,那么结</description>
    </item>
    
    <item>
      <title>如何优雅地关闭Go channel</title>
      <link>/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%85%B3%E9%97%ADgo-channel/</link>
      <pubDate>Thu, 29 Nov 2018 15:41:26 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%85%B3%E9%97%ADgo-channel/</guid>
      <description>几天前，我写了一篇文章来说明golang中channel的使用规范。在reddit和HN，那篇文章收到了很多赞同，但是我也收到了下面几个关于</description>
    </item>
    
    <item>
      <title>slice操作总结</title>
      <link>/post/slice%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 28 Nov 2018 14:27:26 +0000</pubDate>
      
      <guid>/post/slice%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>append函数 append主要用于给某个切片（slice）追加元素,只要slice定义后就可以使用append,不需要先初始化. 如果该切片</description>
    </item>
    
    <item>
      <title>深入Golang之unsafe</title>
      <link>/post/%E6%B7%B1%E5%85%A5golang%E4%B9%8Bunsafe/</link>
      <pubDate>Tue, 27 Nov 2018 19:58:06 +0000</pubDate>
      
      <guid>/post/%E6%B7%B1%E5%85%A5golang%E4%B9%8Bunsafe/</guid>
      <description>Pointer与uintptr unsafe.Pointer在Golang中是用于各种类型转化的桥梁，Pointer代表了一个指向任意类型的指</description>
    </item>
    
    <item>
      <title>string与byte与rune</title>
      <link>/post/string%E4%B8%8Ebyte%E4%B8%8Erune/</link>
      <pubDate>Tue, 27 Nov 2018 15:24:50 +0000</pubDate>
      
      <guid>/post/string%E4%B8%8Ebyte%E4%B8%8Erune/</guid>
      <description>string与[]byte 何为string？ 字符串是一系列8位字节的集合，通常但不一定代表UTF-8编码的文本。字符串可以为空，但不能为ni</description>
    </item>
    
    <item>
      <title>Golang 超大文件读取的两个方案</title>
      <link>/post/golang-%E8%B6%85%E5%A4%A7%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%A1%88/</link>
      <pubDate>Tue, 27 Nov 2018 10:37:47 +0000</pubDate>
      
      <guid>/post/golang-%E8%B6%85%E5%A4%A7%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%A1%88/</guid>
      <description>问题 比如我们有一个log文件，运行了几年，有100G之大。按照我们之前的操作可能代码会这样写： 1 2 3 4 5 6 7 func ReadFile(filePath string) []byte{ content, err := ioutil.ReadFile(filePath) if err != nil { log.Println(&amp;#34;Read error&amp;#34;) }</description>
    </item>
    
    <item>
      <title>Go中写文件的方式比较</title>
      <link>/post/go%E4%B8%AD%E5%86%99%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83/</link>
      <pubDate>Mon, 26 Nov 2018 17:33:49 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E5%86%99%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83/</guid>
      <description>ioutil.WriteFile 1 2 // 写入[]byte类型的data到filename文件中，文件权限为perm func WriteFile(filename string, data []byte, perm os.FileMode) error 示例: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import</description>
    </item>
    
    <item>
      <title>Go中读文件的方式比较</title>
      <link>/post/go%E4%B8%AD%E8%AF%BB%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83/</link>
      <pubDate>Mon, 26 Nov 2018 14:27:18 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E8%AF%BB%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83/</guid>
      <description>使用golang语言去读取一个文件默认会有多种方式，这里主要介绍以下几种。 ioutil.ReadFile 1 2 //读取文件内容，并返回[]byte数据和错误信息。err ==</description>
    </item>
    
    <item>
      <title>寻找高效的字符串拼接方法</title>
      <link>/post/%E5%AF%BB%E6%89%BE%E9%AB%98%E6%95%88%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 23 Nov 2018 17:45:33 +0000</pubDate>
      
      <guid>/post/%E5%AF%BB%E6%89%BE%E9%AB%98%E6%95%88%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%96%B9%E6%B3%95/</guid>
      <description>实现方法 1. 直接使用运算符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func BenchmarkAddStringWithOperator(b *testing.B) { hello := &amp;#34;hello&amp;#34; world := &amp;#34;world&amp;#34; for i := 0; i &amp;lt; b.N; i++ { _ = hello + &amp;#34;,&amp;#34; + world } } func BenchmarkAddMoreStringWithOperator(b *testing.B) { hello := &amp;#34;hello&amp;#34; world := &amp;#34;world&amp;#34; for i</description>
    </item>
    
    <item>
      <title>json包解析</title>
      <link>/post/json%E5%8C%85%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Fri, 23 Nov 2018 16:22:15 +0000</pubDate>
      
      <guid>/post/json%E5%8C%85%E8%A7%A3%E6%9E%90/</guid>
      <description>func Compact func Compact(dst *bytes.Buffer, src []byte) error 将src删除空格符号,并附加到dst中 func HTMLEscape func HTMLEscape(dst *bytes.Buffer, src []byte) HTMLEscape 函数将json编码的src中的&amp;lt;、&amp;gt;、&amp;amp;、U+20</description>
    </item>
    
    <item>
      <title>开源Json库性能分析</title>
      <link>/post/%E5%BC%80%E6%BA%90json%E5%BA%93%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 23 Nov 2018 16:01:54 +0000</pubDate>
      
      <guid>/post/%E5%BC%80%E6%BA%90json%E5%BA%93%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</guid>
      <description>开源Json库性能分析 Json 作为一种重要的数据格式，具有良好的可读性以及自描述性，广泛地应用在各种数据传输场景中。Go 语言里面原生支持了这种数据</description>
    </item>
    
    <item>
      <title>Go中新建文件的权限与设置不符的原因与解决方案</title>
      <link>/post/go%E4%B8%AD%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E7%9A%84%E6%9D%83%E9%99%90%E4%B8%8E%E8%AE%BE%E7%BD%AE%E4%B8%8D%E7%AC%A6%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Fri, 23 Nov 2018 15:43:28 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E7%9A%84%E6%9D%83%E9%99%90%E4%B8%8E%E8%AE%BE%E7%BD%AE%E4%B8%8D%E7%AC%A6%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <description>问题描述: 今天学习 Golang 文件操作实践时，当我创建一个文件（夹）出现文件权限与我代码设置不一致的问题 以下为我创建文件夹的代码： 1 2 3 4 5 6 func main() { err</description>
    </item>
    
    <item>
      <title>如何运行exec.Command时输出详细错误信息</title>
      <link>/post/%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8Cexec-command%E6%97%B6%E8%BE%93%E5%87%BA%E8%AF%A6%E7%BB%86%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Fri, 23 Nov 2018 15:37:53 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8Cexec-command%E6%97%B6%E8%BE%93%E5%87%BA%E8%AF%A6%E7%BB%86%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF/</guid>
      <description>当运行下面的代码时： 1 2 3 4 5 6 7 8 9 cmd := exec.Command(&amp;#34;find&amp;#34;, &amp;#34;/&amp;#34;, &amp;#34;-maxdepth&amp;#34;, &amp;#34;1&amp;#34;, &amp;#34;-exec&amp;#34;, &amp;#34;wc&amp;#34;, &amp;#34;-c&amp;#34;, &amp;#34;{}&amp;#34;, &amp;#34;\\&amp;#34;) var out bytes.Buffer cmd.Stdout = &amp;amp;out err := cmd.Run() if err != nil { fmt.Println(err) return } fmt.Println(&amp;#34;Result: &amp;#34; + out.String()) 我得到这个错误： 1 exit status 1 解决方案是使用</description>
    </item>
    
    <item>
      <title>umask命令解析</title>
      <link>/post/umask%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Thu, 22 Nov 2018 11:19:29 +0000</pubDate>
      
      <guid>/post/umask%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/</guid>
      <description>umask命令用来设置限制新建文件权限的掩码。当新文件被创建时，其最初的权限由文件创建掩码决定。用户每次注册进入系统时，umask命令都被执</description>
    </item>
    
    <item>
      <title>linux端口连通性测试</title>
      <link>/post/linux%E7%AB%AF%E5%8F%A3%E8%BF%9E%E9%80%9A%E6%80%A7%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Wed, 21 Nov 2018 16:01:15 +0000</pubDate>
      
      <guid>/post/linux%E7%AB%AF%E5%8F%A3%E8%BF%9E%E9%80%9A%E6%80%A7%E6%B5%8B%E8%AF%95/</guid>
      <description>telnet telnet是windows标准服务，可以直接用；如果是linux机器，需要安装telnet. 用法: telnet ip port 1）先用telnet连接不存在的</description>
    </item>
    
    <item>
      <title>supervisor安装与相关配置</title>
      <link>/post/supervisor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Tue, 20 Nov 2018 22:53:20 +0000</pubDate>
      
      <guid>/post/supervisor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</guid>
      <description>介绍 Supervisor是一个进程控制系统。 它是一个C/S系统,服务端是supervisord进程，控制端使用supervisorctl来进</description>
    </item>
    
    <item>
      <title>如何查看linux版本</title>
      <link>/post/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8Blinux%E7%89%88%E6%9C%AC/</link>
      <pubDate>Tue, 20 Nov 2018 18:12:41 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8Blinux%E7%89%88%E6%9C%AC/</guid>
      <description>在 Linux 系统之下若想要查询发行版名称与版本的资讯有许多种方法，而不同的 Linux 发行版适用的方式也不同，以下整理了一些常见的方法。 查询 Linux 发行版与版本 Linux 发</description>
    </item>
    
    <item>
      <title>软连接的创建修改与删除</title>
      <link>/post/%E8%BD%AF%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%88%9B%E5%BB%BA%E4%BF%AE%E6%94%B9%E4%B8%8E%E5%88%A0%E9%99%A4/</link>
      <pubDate>Tue, 20 Nov 2018 17:55:16 +0000</pubDate>
      
      <guid>/post/%E8%BD%AF%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%88%9B%E5%BB%BA%E4%BF%AE%E6%94%B9%E4%B8%8E%E5%88%A0%E9%99%A4/</guid>
      <description>创建软链接 ln -s [源文件或目录] [目标文件或目录] 例如： 当前路径创建test 引向/var/www/test 文件夹 ln –s /var/www/test test 创建/var/tes</description>
    </item>
    
    <item>
      <title>Linux:too many open files问题及解决方式</title>
      <link>/post/linux-too-many-open-files%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Tue, 20 Nov 2018 17:15:36 +0000</pubDate>
      
      <guid>/post/linux-too-many-open-files%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/</guid>
      <description>文件数可以从三个维度限制:分别为操作系统限制,shell限制,以及进程限制. 查看进程占用的句柄数 查看当前shell下的文件句柄数限制: ulimit -a 查</description>
    </item>
    
    <item>
      <title>四种常见的POST提交数据方式</title>
      <link>/post/%E5%9B%9B%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84post%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Fri, 16 Nov 2018 11:14:41 +0000</pubDate>
      
      <guid>/post/%E5%9B%9B%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84post%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E6%96%B9%E5%BC%8F/</guid>
      <description>我们知道，HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样： 1 2 3</description>
    </item>
    
    <item>
      <title>strings包解析</title>
      <link>/post/strings%E5%8C%85%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Thu, 15 Nov 2018 18:45:27 +0000</pubDate>
      
      <guid>/post/strings%E5%8C%85%E8%A7%A3%E6%9E%90/</guid>
      <description>func EqualFold 1 func EqualFold(s, t string) bool 判断两个utf-8编码字符串（将unicode大写、小写、标题三种格式字符视为相同）是否相同。 1 2 3 4 5 6 7 Example fmt.Println(strings.EqualFold(&amp;#34;Go&amp;#34;, &amp;#34;go&amp;#34;)) Output: true func HasPrefix 1</description>
    </item>
    
    <item>
      <title>strconv包解析</title>
      <link>/post/strconv%E5%8C%85%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Thu, 15 Nov 2018 18:44:53 +0000</pubDate>
      
      <guid>/post/strconv%E5%8C%85%E8%A7%A3%E6%9E%90/</guid>
      <description>Constants const IntSize = intSize IntSize是int或uint类型的字位数。 Variables var ErrRange = errors.New(&amp;quot;value out of range&amp;quot;) ErrRange表示超出目标类型表示范围。 var ErrSyntax = errors.New(&amp;quot;invalid syntax&amp;quot;) ErrSynta</description>
    </item>
    
    <item>
      <title>tar命令详解</title>
      <link>/post/tar%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 15 Nov 2018 18:44:27 +0000</pubDate>
      
      <guid>/post/tar%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid>
      <description>Linux包含了多种文件压缩工具。虽然听上去不错，但这实际上经常会在用户下载文件时造成混淆。表4-7列出了Linux上的文件压缩工具。 gzi</description>
    </item>
    
    <item>
      <title>后台模式详解</title>
      <link>/post/%E5%90%8E%E5%8F%B0%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 15 Nov 2018 18:43:54 +0000</pubDate>
      
      <guid>/post/%E5%90%8E%E5%8F%B0%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</guid>
      <description>jobs jos 命令用于显示 Linux 中的任务列表及任务状态，包括后台运行的任务。该命令可以显示任务号及其对应的进程号。其中，任务号是以普通用户的角度进行的，而</description>
    </item>
    
    <item>
      <title>SSH原理与运用</title>
      <link>/post/ssh%E5%8E%9F%E7%90%86%E4%B8%8E%E8%BF%90%E7%94%A8/</link>
      <pubDate>Thu, 15 Nov 2018 18:43:05 +0000</pubDate>
      
      <guid>/post/ssh%E5%8E%9F%E7%90%86%E4%B8%8E%E8%BF%90%E7%94%A8/</guid>
      <description>一、什么是SSH？ Secure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）所制定；SSH为一项创建在应用层和传输</description>
    </item>
    
    <item>
      <title>scp命令详解</title>
      <link>/post/scp%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 15 Nov 2018 18:42:36 +0000</pubDate>
      
      <guid>/post/scp%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid>
      <description>Linux scp命令 Linux scp命令用于Linux之间复制文件和目录。 scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件</description>
    </item>
    
    <item>
      <title>regexp包解析</title>
      <link>/post/regexp%E5%8C%85%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Thu, 15 Nov 2018 18:41:39 +0000</pubDate>
      
      <guid>/post/regexp%E5%8C%85%E8%A7%A3%E6%9E%90/</guid>
      <description>正则表达式 正则表达式是一种进行模式匹配和文本操纵的复杂而又强大的工具。虽然正则表达式比纯粹的文本匹配效率低，但是 它却更灵活。按照它的语法规则</description>
    </item>
    
    <item>
      <title>os包解析</title>
      <link>/post/os%E5%8C%85%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Thu, 15 Nov 2018 18:41:03 +0000</pubDate>
      
      <guid>/post/os%E5%8C%85%E8%A7%A3%E6%9E%90/</guid>
      <description>概观 Package os为操作系统功能提供了一个平台无关的接口。虽然错误处理类似于 Go，但设计类似 Unix，失败的调用返回类型错误的值而不是错误号。错误中</description>
    </item>
    
    <item>
      <title>os:exec包解析</title>
      <link>/post/os-exec%E5%8C%85%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Thu, 15 Nov 2018 18:40:11 +0000</pubDate>
      
      <guid>/post/os-exec%E5%8C%85%E8%A7%A3%E6%9E%90/</guid>
      <description>概观 包 exec 执行外部命令。它包装了 os.StartProcess ，以便重新映射 stdin 和 stdout ，使用管道连接 I/O 并进行其他调整。 与来自 C 和其他语言的“系统”库调用不同，os/exec 包</description>
    </item>
    
    <item>
      <title>package:url(1.13)</title>
      <link>/post/packageurl1.13/</link>
      <pubDate>Thu, 15 Nov 2018 18:38:36 +0000</pubDate>
      
      <guid>/post/packageurl1.13/</guid>
      <description>func PathEscape 1 func PathEscape(s string) string PathEscape转义字符串，以便可以安全地放置在URL路径段中。 根据需要用％XX序列替换特殊字符（包括/） func PathUnescape 1 func PathUnescape(s string) (string, error)</description>
    </item>
    
    <item>
      <title>multipart包解析</title>
      <link>/post/multipart%E5%8C%85%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Thu, 15 Nov 2018 18:37:14 +0000</pubDate>
      
      <guid>/post/multipart%E5%8C%85%E8%A7%A3%E6%9E%90/</guid>
      <description>type File 1 2 3 4 5 6 type File interface { io.Reader io.ReaderAt io.Seeker io.Closer } File是一个接口，实现了对一个multipart信息中文件记录的访问。它的内容可以保持在内存或者硬盘中，</description>
    </item>
    
    <item>
      <title>lsof命令详解</title>
      <link>/post/lsof%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 15 Nov 2018 18:36:39 +0000</pubDate>
      
      <guid>/post/lsof%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid>
      <description>概论 lsof命令用于查看你进程打开的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。是十分方便的系统监视工具，</description>
    </item>
    
    <item>
      <title>kill命令详解</title>
      <link>/post/kill%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 15 Nov 2018 18:33:14 +0000</pubDate>
      
      <guid>/post/kill%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid>
      <description>kill命令 kill命令用来删除执行中的程序或工作。kill可将指定的信息送至程序。预设的信息为SIGTERM(15),可将指定程序终止。若</description>
    </item>
    
    <item>
      <title>io包解析</title>
      <link>/post/io%E5%8C%85%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Thu, 15 Nov 2018 18:32:33 +0000</pubDate>
      
      <guid>/post/io%E5%8C%85%E8%A7%A3%E6%9E%90/</guid>
      <description>Variables var EOF = errors.New(&amp;quot;EOF&amp;quot;) EOF当无法得到更多输入时，Read方法返回EOF。当函数一切正常的到达输入的结束时，就应返回EOF。如果在一个结构化数据流中EO</description>
    </item>
    
    <item>
      <title>ioutil包解析</title>
      <link>/post/ioutil%E5%8C%85%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Thu, 15 Nov 2018 18:31:51 +0000</pubDate>
      
      <guid>/post/ioutil%E5%8C%85%E8%A7%A3%E6%9E%90/</guid>
      <description>Variables var Discard io.Writer = devNull(0) Discard是一个io.Writer接口，对它的所有Write调用都会无实际操作的成功返回。 func NopCloser func NopCloser(r io.Reader) io.ReadCloser NopCloser用一</description>
    </item>
    
    <item>
      <title>http包解析</title>
      <link>/post/http%E5%8C%85%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Thu, 15 Nov 2018 18:28:57 +0000</pubDate>
      
      <guid>/post/http%E5%8C%85%E8%A7%A3%E6%9E%90/</guid>
      <description>预设值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 const ( StatusContinue = 100 StatusSwitchingProtocols = 101 StatusOK = 200 StatusCreated = 201 StatusAccepted = 202 StatusNonAuthoritativeInfo = 203 StatusNoContent = 204 StatusResetContent</description>
    </item>
    
    <item>
      <title>Go的静态库和动态库的编译与使用</title>
      <link>/post/go%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 15 Nov 2018 18:28:11 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description>go语言静态库的编译和使用 本文主要介绍go语言静态库的编译和使用方法，以windows平台为例，linux平台步骤一样，具体环境如下： &amp;gt;echo %GOPATH% E:\share\git\go_practice\</description>
    </item>
    
    <item>
      <title>Go的交叉编译</title>
      <link>/post/go%E7%9A%84%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</link>
      <pubDate>Thu, 15 Nov 2018 18:26:56 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</guid>
      <description>交叉编译 通俗地讲就是在一种平台上编译出能运行在体系结构不同的另一种平台上的程序，比如在PC平台（X86 CPU）上编译出能运行在以ARM为内核</description>
    </item>
    
    <item>
      <title>Go中的HTTP操作总结</title>
      <link>/post/go%E4%B8%AD%E7%9A%84http%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 15 Nov 2018 18:26:03 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E7%9A%84http%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>客户端:发送请求 http.Get GET请求的数据会附在URL之后(就是把数据放置在HTTP协议头中), ?分割URL和传输数据，参数之间以&amp;amp;相连. G</description>
    </item>
    
    <item>
      <title>Go中的Json编解码总结</title>
      <link>/post/go%E4%B8%AD%E7%9A%84json%E7%BC%96%E8%A7%A3%E7%A0%81%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 15 Nov 2018 18:25:06 +0000</pubDate>
      
      <guid>/post/go%E4%B8%AD%E7%9A%84json%E7%BC%96%E8%A7%A3%E7%A0%81%E6%80%BB%E7%BB%93/</guid>
      <description>编码 数据结构map json源于javascript的对象结构，golang中直接对应其数据结构，可是golang的map也是key-valu</description>
    </item>
    
    <item>
      <title>Gin源码剖析:gin</title>
      <link>/post/gin%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-gin/</link>
      <pubDate>Thu, 15 Nov 2018 18:24:16 +0000</pubDate>
      
      <guid>/post/gin%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-gin/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70</description>
    </item>
    
    <item>
      <title>Gin源码剖析:context</title>
      <link>/post/gin%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-context/</link>
      <pubDate>Thu, 15 Nov 2018 18:20:19 +0000</pubDate>
      
      <guid>/post/gin%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-context/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70</description>
    </item>
    
    <item>
      <title>Gin源码剖析:auth</title>
      <link>/post/gin%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-auth/</link>
      <pubDate>Thu, 15 Nov 2018 18:17:00 +0000</pubDate>
      
      <guid>/post/gin%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-auth/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70</description>
    </item>
    
    <item>
      <title>fmt包解析</title>
      <link>/post/fmt%E5%8C%85%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Thu, 15 Nov 2018 18:15:52 +0000</pubDate>
      
      <guid>/post/fmt%E5%8C%85%E8%A7%A3%E6%9E%90/</guid>
      <description>Printing verb： 通用： 1 2 3 4 5 %v 值的默认格式表示 %+v 类似%v，但输出结构体时会添加字段名 %#v 值的Go语法表示 %T 值的类型的Go语法表示 %% 百分号 布尔值</description>
    </item>
    
    <item>
      <title>bufio包解析</title>
      <link>/post/bufio%E5%8C%85%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Thu, 15 Nov 2018 18:12:08 +0000</pubDate>
      
      <guid>/post/bufio%E5%8C%85%E8%A7%A3%E6%9E%90/</guid>
      <description>Constants 1 2 3 4 const ( // 用于缓冲一个token，实际需要的最大token尺寸可能小一些，例如缓冲中需要保存一整行内容 MaxScanTokenSize = 64 * 1024 ) Variables 1 2 3 4 5 6 var ( ErrInvalidUnreadByte</description>
    </item>
    
    <item>
      <title>背包九讲</title>
      <link>/post/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/</link>
      <pubDate>Fri, 15 Sep 2017 11:25:54 +0000</pubDate>
      
      <guid>/post/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/</guid>
      <description>1 01背包问题 1.1 题目 1.2 基本思路 1.3 优化空间复杂度 1.4 初始化的细节问题 1.5 一个常数优化 1.6 小结 01背包问题是最基本的背包问题，它包含了背包问题中设计状</description>
    </item>
    
    <item>
      <title>查找二叉树的中心节点</title>
      <link>/post/%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BF%83%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 14 Sep 2017 21:04:37 +0000</pubDate>
      
      <guid>/post/%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BF%83%E8%8A%82%E7%82%B9/</guid>
      <description>LeetCode 310. Minimum Height Trees For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels. Format The graph contains n nodes which</description>
    </item>
    
    <item>
      <title>守护进程详解</title>
      <link>/post/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 10 Sep 2017 22:36:38 +0000</pubDate>
      
      <guid>/post/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E8%AF%A6%E8%A7%A3/</guid>
      <description>背景知识： 守护进程是脱离终端并在后台运行的进程，执行过程中信息不会显示在终端上并且也不会被终端发出的信号打断。 操作步骤： 创建子进程，父进程退</description>
    </item>
    
    <item>
      <title>多进程模型详解</title>
      <link>/post/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 10 Sep 2017 22:25:16 +0000</pubDate>
      
      <guid>/post/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</guid>
      <description>简介 每一个进程是资源分配的基本单位。进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。实际上在</description>
    </item>
    
    <item>
      <title>进程间通信方式(IPC)总结</title>
      <link>/post/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8Fipc%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 09 Sep 2017 21:59:17 +0000</pubDate>
      
      <guid>/post/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8Fipc%E6%80%BB%E7%BB%93/</guid>
      <description>同一主机上的进程通信方式 UNIX进程间通信方式: 包括管道(PIPE), 有名管道(FIFO), 和信号(Signal) System V进程通信方式：包括信号</description>
    </item>
    
    <item>
      <title>ifconfig和route和nslookup和host命令详解</title>
      <link>/post/ifconfig%E5%92%8Croute%E5%92%8Cnslookup%E5%92%8Chost%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 09 Sep 2017 21:29:11 +0000</pubDate>
      
      <guid>/post/ifconfig%E5%92%8Croute%E5%92%8Cnslookup%E5%92%8Chost%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid>
      <description>ifconfig host和nslookup route</description>
    </item>
    
    <item>
      <title>top和ps和pgrep命令详解</title>
      <link>/post/top%E5%92%8Cps%E5%92%8Cpgrep%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 09 Sep 2017 20:50:48 +0000</pubDate>
      
      <guid>/post/top%E5%92%8Cps%E5%92%8Cpgrep%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid>
      <description>ps 当程序运行在系统上时，我们称之为进程(process)。想监测这些进程，需要熟悉ps命令的用法。 默认情况下，ps命令并不会提供那么多的信息</description>
    </item>
    
    <item>
      <title>列出1小时内占用CPU最多的10个进程</title>
      <link>/post/%E5%88%97%E5%87%BA1%E5%B0%8F%E6%97%B6%E5%86%85%E5%8D%A0%E7%94%A8cpu%E6%9C%80%E5%A4%9A%E7%9A%8410%E4%B8%AA%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Sat, 09 Sep 2017 20:40:33 +0000</pubDate>
      
      <guid>/post/%E5%88%97%E5%87%BA1%E5%B0%8F%E6%97%B6%E5%86%85%E5%8D%A0%E7%94%A8cpu%E6%9C%80%E5%A4%9A%E7%9A%8410%E4%B8%AA%E8%BF%9B%E7%A8%8B/</guid>
      <description></description>
    </item>
    
    <item>
      <title>找出指定目录中最大的10个文件</title>
      <link>/post/%E6%89%BE%E5%87%BA%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%8410%E4%B8%AA%E6%96%87%E4%BB%B6/</link>
      <pubDate>Sat, 09 Sep 2017 20:17:25 +0000</pubDate>
      
      <guid>/post/%E6%89%BE%E5%87%BA%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%8410%E4%B8%AA%E6%96%87%E4%BB%B6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>grep命令详解</title>
      <link>/post/grep%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 09 Sep 2017 19:14:34 +0000</pubDate>
      
      <guid>/post/grep%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid>
      <description>基本内容 你会经常需要在大文件中找一行数据，而这行数据又埋藏在文件的中间。这时并不需要手动 翻看整个文件，用grep命令来帮助查找就行了。gre</description>
    </item>
    
    <item>
      <title>wc命令详解</title>
      <link>/post/wc%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 09 Sep 2017 18:52:15 +0000</pubDate>
      
      <guid>/post/wc%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid>
      <description>wc命令可以对对数据中的文本进行计数。默认情况下，它会输出3个值: 文本的行数 文本的词数 文本的字节数 通过将文本文件重定向到wc命令，你立刻就可</description>
    </item>
    
    <item>
      <title>head与tail命令详解</title>
      <link>/post/head%E4%B8%8Etail%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 09 Sep 2017 18:30:19 +0000</pubDate>
      
      <guid>/post/head%E4%B8%8Etail%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid>
      <description>简介 当査看上千行的大文件时，我们可不会用cat命令把整个文件内容给打印出来。相反，我们 只会査看文件的一小部分内容（例如文件的前10行或后10</description>
    </item>
    
    <item>
      <title>查找符号链接及其指向目标</title>
      <link>/post/%E6%9F%A5%E6%89%BE%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E5%8F%8A%E5%85%B6%E6%8C%87%E5%90%91%E7%9B%AE%E6%A0%87/</link>
      <pubDate>Sat, 09 Sep 2017 18:26:00 +0000</pubDate>
      
      <guid>/post/%E6%9F%A5%E6%89%BE%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E5%8F%8A%E5%85%B6%E6%8C%87%E5%90%91%E7%9B%AE%E6%A0%87/</guid>
      <description></description>
    </item>
    
    <item>
      <title>sort和uniq命令详解</title>
      <link>/post/sort%E5%92%8Cuniq%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 09 Sep 2017 09:17:18 +0000</pubDate>
      
      <guid>/post/sort%E5%92%8Cuniq%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid>
      <description>简介 同文本文件打交道时，总避不开排序，那是因为对于文本处理任务而言，排序（sort)可以起到不小的作用。sort命令能够帮助我们对文本文件和</description>
    </item>
    
    <item>
      <title>find命令详解</title>
      <link>/post/find%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 08 Sep 2017 21:32:58 +0000</pubDate>
      
      <guid>/post/find%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid>
      <description>简介 find是UNIX/Linux命令行工具箱中最棒的工具之一。这个命令对编写shell脚本很有帮助，但是多数人由于对它缺乏认识，并不能有效</description>
    </item>
    
    <item>
      <title>history命令详解</title>
      <link>/post/history%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 08 Sep 2017 12:55:02 +0000</pubDate>
      
      <guid>/post/history%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid>
      <description>bash shell会跟踪你用过的命令。你可以唤回这些命令 并重新使用。 要查看最近用过的命令列表，可以输入不带选项的history命令。 你可以设置保存</description>
    </item>
    
    <item>
      <title>alias命令详解</title>
      <link>/post/alias%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 08 Sep 2017 12:34:30 +0000</pubDate>
      
      <guid>/post/alias%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid>
      <description>alias命令别名允许你为常用的命令(及其参数)创建另一 个名称，从而将输入量减少到最低。 要查看当前可用的别名，使用alias命令以及选项-p</description>
    </item>
    
    <item>
      <title>数组和关联数组</title>
      <link>/post/%E6%95%B0%E7%BB%84%E5%92%8C%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 08 Sep 2017 12:14:36 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E7%BB%84%E5%92%8C%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84/</guid>
      <description>数组变量 环境变量有一个很酷的特性就是，它们可作为数组使用。数组是能够存储多个值的变量。这 些值可以单独引用，也可以作为整个数组来引用。 要给某个</description>
    </item>
    
    <item>
      <title>back_inserter()用法</title>
      <link>/post/-stdcopy%E5%92%8Cstdback_inserter%E7%94%A8%E6%B3%95/</link>
      <pubDate>Thu, 07 Sep 2017 17:39:18 +0000</pubDate>
      
      <guid>/post/-stdcopy%E5%92%8Cstdback_inserter%E7%94%A8%E6%B3%95/</guid>
      <description>头文件: #include &amp;lt;iterator&amp;gt; 函数原型: 1 2 template &amp;lt;class Container&amp;gt; back_insert_iterator&amp;lt;Container&amp;gt; back_inserter (Container&amp;amp; x); 用法: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47</description>
    </item>
    
    <item>
      <title>df和du命令详解</title>
      <link>/post/df%E5%92%8Cdu%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 07 Sep 2017 17:13:30 +0000</pubDate>
      
      <guid>/post/df%E5%92%8Cdu%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid>
      <description>df(Disk Free) df命令直接读取分区的超级块信息获取分区使用情况。它的数据是基于分区元数据的，所以只能针对整个分区。由于df直接读取超级块，所以运行速度</description>
    </item>
    
    <item>
      <title>echo命令与printf命令详解</title>
      <link>/post/echo%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 07 Sep 2017 11:31:30 +0000</pubDate>
      
      <guid>/post/echo%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid>
      <description>echo echo是用于终端打印的基本命令。 在默认情况下，echo会将一个换行符追加到输出文本的尾部。可以使用标志-n来忽略结尾的换行符。 $ echo &amp;quot;Welcome to Bash&amp;quot;</description>
    </item>
    
    <item>
      <title>虚函数与纯虚函数的区别</title>
      <link>/post/%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Tue, 05 Sep 2017 22:11:55 +0000</pubDate>
      
      <guid>/post/%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>虚函数和纯虚函数有以下方面的区别。 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖</description>
    </item>
    
    <item>
      <title>野指针及其危害</title>
      <link>/post/%E9%87%8E%E6%8C%87%E9%92%88%E5%8F%8A%E5%85%B6%E5%8D%B1%E5%AE%B3/</link>
      <pubDate>Tue, 05 Sep 2017 21:47:16 +0000</pubDate>
      
      <guid>/post/%E9%87%8E%E6%8C%87%E9%92%88%E5%8F%8A%E5%85%B6%E5%8D%B1%E5%AE%B3/</guid>
      <description>“野指针”不是NULL指针，而是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，i</description>
    </item>
    
    <item>
      <title>指向常量字符串的指针</title>
      <link>/post/%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8C%87%E9%92%88/</link>
      <pubDate>Tue, 05 Sep 2017 21:39:17 +0000</pubDate>
      
      <guid>/post/%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8C%87%E9%92%88/</guid>
      <description>指针的比较 数组用作比较,自动退化为指向首元素的指针. 对指针指向字符串的修改 非常量指针在初始化可以指向字符串常量. 上面的代码中，node1和n</description>
    </item>
    
    <item>
      <title>类函数与this指针</title>
      <link>/post/%E7%B1%BB%E5%87%BD%E6%95%B0%E4%B8%8Ethis%E6%8C%87%E9%92%88/</link>
      <pubDate>Tue, 05 Sep 2017 16:57:43 +0000</pubDate>
      
      <guid>/post/%E7%B1%BB%E5%87%BD%E6%95%B0%E4%B8%8Ethis%E6%8C%87%E9%92%88/</guid>
      <description>这里需要明白类函数是如何被编译以及如何被执行的。 对于类成员函数而言，并不是一个对象对应一个单独的成员函数体，而是此类的所有对象共用这个成员函</description>
    </item>
    
    <item>
      <title>C&#43;&#43;中的默认参数</title>
      <link>/post/c-%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/</link>
      <pubDate>Tue, 05 Sep 2017 16:41:31 +0000</pubDate>
      
      <guid>/post/c-%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/</guid>
      <description>C++可以给函数定义默认参数值。在函数调用时没有指定与形参相对应的实参时，就自动 使用默认参数。 默认参数的语法与使用： 在函数声明或定义时，直接</description>
    </item>
    
    <item>
      <title>如何判断一段程序是由C编译还是由C&#43;&#43;编译</title>
      <link>/post/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E6%AE%B5%E7%A8%8B%E5%BA%8F%E6%98%AF%E7%94%B1c%E7%BC%96%E8%AF%91%E8%BF%98%E6%98%AF%E7%94%B1c-%E7%BC%96%E8%AF%91/</link>
      <pubDate>Tue, 05 Sep 2017 16:13:32 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E6%AE%B5%E7%A8%8B%E5%BA%8F%E6%98%AF%E7%94%B1c%E7%BC%96%E8%AF%91%E8%BF%98%E6%98%AF%E7%94%B1c-%E7%BC%96%E8%AF%91/</guid>
      <description>如果编译器在编译cpp文件，那么_Cplusplus就会被定义，如果是一个c文件在被编译，那么_STDC_就会被定义。_STDC_是预定义宏</description>
    </item>
    
    <item>
      <title>如何建立和理解非常复杂的声明</title>
      <link>/post/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%90%86%E8%A7%A3%E9%9D%9E%E5%B8%B8%E5%A4%8D%E6%9D%82%E7%9A%84%E5%A3%B0%E6%98%8E/</link>
      <pubDate>Tue, 05 Sep 2017 15:57:45 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%90%86%E8%A7%A3%E9%9D%9E%E5%B8%B8%E5%A4%8D%E6%9D%82%E7%9A%84%E5%A3%B0%E6%98%8E/</guid>
      <description></description>
    </item>
    
    <item>
      <title>不用流程控制语句,如何打印1~1000的数</title>
      <link>/post/%E4%B8%8D%E7%94%A8%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5-%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B01-1000%E7%9A%84%E6%95%B0/</link>
      <pubDate>Tue, 05 Sep 2017 15:49:05 +0000</pubDate>
      
      <guid>/post/%E4%B8%8D%E7%94%A8%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5-%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B01-1000%E7%9A%84%E6%95%B0/</guid>
      <description>采用构造函数与静态构造变量结合的方法实现。首先在类中定义一个静态成员变量，然后在构造函数里面打印该静态变量的值，并对静态变量进行自增操作，同</description>
    </item>
    
    <item>
      <title>通过绝对内存地址进行参数赋值与函数调用</title>
      <link>/post/%E9%80%9A%E8%BF%87%E7%BB%9D%E5%AF%B9%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8C%E5%8F%82%E6%95%B0%E8%B5%8B%E5%80%BC%E4%B8%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</link>
      <pubDate>Tue, 05 Sep 2017 15:15:29 +0000</pubDate>
      
      <guid>/post/%E9%80%9A%E8%BF%87%E7%BB%9D%E5%AF%B9%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8C%E5%8F%82%E6%95%B0%E8%B5%8B%E5%80%BC%E4%B8%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</guid>
      <description>同一个数可以通过不同的方式表达出来，对于函数的访问，变量的赋值除了直接对变量赋值以外，还可以通过绝对内存地址进行参数赋值与函数调用。 1) 通过地</description>
    </item>
    
    <item>
      <title>不用sizeof(),如何判断操作系统是16位还是32位</title>
      <link>/post/%E4%B8%8D%E7%94%A8sizeof-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF16%E4%BD%8D%E8%BF%98%E6%98%AF32%E4%BD%8D/</link>
      <pubDate>Tue, 05 Sep 2017 14:21:05 +0000</pubDate>
      
      <guid>/post/%E4%B8%8D%E7%94%A8sizeof-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF16%E4%BD%8D%E8%BF%98%E6%98%AF32%E4%BD%8D/</guid>
      <description>对0值取反，不同位数下的0值取反，其结果不一样。例如，在32位机器下，按位取反运算，结果为1111111111111111111111111</description>
    </item>
    
    <item>
      <title>包含无符号数的计算</title>
      <link>/post/%E5%8C%85%E5%90%AB%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Tue, 05 Sep 2017 14:11:14 +0000</pubDate>
      
      <guid>/post/%E5%8C%85%E5%90%AB%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97/</guid>
      <description>当表达式中存在有符号类型和无符号类型时，所有的操作数都自动转换成无符号类型。 例一 运行如下程序： 1 2 3 4 5 #include &amp;lt;stdio.h&amp;gt;int main() unsigned int i=3; printf(&amp;#34;&amp;#34;%u\n,i*-1); return 0; 程序输出结果： 4294967293 在</description>
    </item>
    
    <item>
      <title>利用位运算计算数的绝对值</title>
      <link>/post/%E5%88%A9%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E8%AE%A1%E7%AE%97%E6%95%B0%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%80%BC/</link>
      <pubDate>Tue, 05 Sep 2017 12:53:07 +0000</pubDate>
      
      <guid>/post/%E5%88%A9%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E8%AE%A1%E7%AE%97%E6%95%B0%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%80%BC/</guid>
      <description></description>
    </item>
    
    <item>
      <title>实现位运算求两个数的平均值</title>
      <link>/post/%E5%AE%9E%E7%8E%B0%E4%BD%8D%E8%BF%90%E7%AE%97%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC/</link>
      <pubDate>Tue, 05 Sep 2017 12:46:38 +0000</pubDate>
      
      <guid>/post/%E5%AE%9E%E7%8E%B0%E4%BD%8D%E8%BF%90%E7%AE%97%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC/</guid>
      <description></description>
    </item>
    
    <item>
      <title>struct和union的区别</title>
      <link>/post/struct%E5%92%8Cunion%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Tue, 05 Sep 2017 12:08:16 +0000</pubDate>
      
      <guid>/post/struct%E5%92%8Cunion%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>struct (结构体）与union (联合体）是C语言中两种不同的数据结构，两者都是常见的复合结构，其区别主要表现在以下两个方面： 结构体与联合体虽然都是</description>
    </item>
    
    <item>
      <title>typedef和define的区别</title>
      <link>/post/typedef%E5%92%8Cdefine%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Tue, 05 Sep 2017 11:32:25 +0000</pubDate>
      
      <guid>/post/typedef%E5%92%8Cdefine%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>typedef与define都是替一个对象取一个别名，以此来增强程序的可读性，但是它们在使用和作用上也存在着以下几个方面的不同： 1) 原理不同。</description>
    </item>
    
    <item>
      <title>如何判断一个变量是有符号数还是无符号数</title>
      <link>/post/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%98%AF%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E8%BF%98%E6%98%AF%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0/</link>
      <pubDate>Tue, 05 Sep 2017 10:57:25 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%98%AF%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E8%BF%98%E6%98%AF%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0/</guid>
      <description>通过改变符号位判断。把A进行一个位运算，将最高位置1,判断是否大于0。 程序示例如下： 1 2 3 4 5 6 7 8 9 10 11 #include &amp;lt;stdio.h&amp;gt; int main() { unsigned A = 10; A = A|(1&amp;lt;&amp;lt;31); if(A &amp;gt; 0) pr</description>
    </item>
    
    <item>
      <title>string类的一种正确写法</title>
      <link>/post/string%E7%B1%BB%E7%9A%84%E4%B8%80%E7%A7%8D%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95/</link>
      <pubDate>Tue, 05 Sep 2017 09:36:56 +0000</pubDate>
      
      <guid>/post/string%E7%B1%BB%E7%9A%84%E4%B8%80%E7%A7%8D%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95/</guid>
      <description>转载:https://coolshell.cn/articles/10478.html C++ 的一个常见面试题是让你实现一个 String 类，限于时间，不可能</description>
    </item>
    
    <item>
      <title>栈空间的最大值是多少?</title>
      <link>/post/%E6%A0%88%E7%A9%BA%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E6%98%AF%E5%A4%9A%E5%B0%91/</link>
      <pubDate>Mon, 04 Sep 2017 22:05:45 +0000</pubDate>
      
      <guid>/post/%E6%A0%88%E7%A9%BA%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E6%98%AF%E5%A4%9A%E5%B0%91/</guid>
      <description>在windows下，栈地址是向低地址扩展的数据结构，是一块连续的内存区域。栈顶的地址和栈的最大容量是系统预先规定好的，在windows下，栈</description>
    </item>
    
    <item>
      <title>解析“explicit”</title>
      <link>/post/%E8%A7%A3%E6%9E%90explicit/</link>
      <pubDate>Mon, 04 Sep 2017 21:53:36 +0000</pubDate>
      
      <guid>/post/%E8%A7%A3%E6%9E%90explicit/</guid>
      <description>转载http://blog.csdn.net/fengbingchun/article/details/51168728 C++中的关键字ex</description>
    </item>
    
    <item>
      <title>解析&#34;export&#34;</title>
      <link>/post/%E8%A7%A3%E6%9E%90export/</link>
      <pubDate>Mon, 04 Sep 2017 21:41:58 +0000</pubDate>
      
      <guid>/post/%E8%A7%A3%E6%9E%90export/</guid>
      <description>为了访问其他编译单元（如另一代码文件）中的变量或对象，对普通类型（包括基本数据类、结构和类），可以利用关键字extern，来使用这些变量或对</description>
    </item>
    
    <item>
      <title>前置运算符和后置运算符的区别</title>
      <link>/post/%E5%89%8D%E7%BD%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E5%90%8E%E7%BD%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 04 Sep 2017 18:23:48 +0000</pubDate>
      
      <guid>/post/%E5%89%8D%E7%BD%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E5%90%8E%E7%BD%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>以++操作为例，对于变量a, ++a表示取a的地址，增加它的内容，然后把值放在寄存器 中；a++表示取a的地址，把它的值装入寄存器，然后增加内存</description>
    </item>
    
    <item>
      <title>C语言中操作符的优先级总结</title>
      <link>/post/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 04 Sep 2017 18:11:42 +0000</pubDate>
      
      <guid>/post/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%80%BB%E7%BB%93/</guid>
      <description></description>
    </item>
    
    <item>
      <title>数组和指针的区别</title>
      <link>/post/%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 04 Sep 2017 17:59:37 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>指针可以随时指向任意类型的内存块，而数组可以在静态存储区被创建。例如，全局数组 可以在栈上被创建。从原理与定义上看，虽然指针与数组表示的是不同</description>
    </item>
    
    <item>
      <title>画匠问题</title>
      <link>/post/%E7%94%BB%E5%8C%A0%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 03 Sep 2017 21:43:56 +0000</pubDate>
      
      <guid>/post/%E7%94%BB%E5%8C%A0%E9%97%AE%E9%A2%98/</guid>
      <description>题目: 给定一个整型数组arr,数组中的每个值都为正数，表示完成一幅画作需要的时间，再给定一个整数num表示画匠的数量，每个画匠只能画连在一起</description>
    </item>
    
    <item>
      <title>丢棋子问题</title>
      <link>/post/%E4%B8%A2%E6%A3%8B%E5%AD%90%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 03 Sep 2017 19:11:19 +0000</pubDate>
      
      <guid>/post/%E4%B8%A2%E6%A3%8B%E5%AD%90%E9%97%AE%E9%A2%98/</guid>
      <description>题目: 举例: 解析: map[i][j]的意义为i个棋子扔j次最多搞定的楼数。 0 1 2 3 4 5 6 7 8 9 10 -&amp;gt;次数 1 0 1 2 3 4 5 6 7 8 9 10 2 0 1</description>
    </item>
    
    <item>
      <title>两个排序数组中的查找问题</title>
      <link>/post/%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 03 Sep 2017 18:26:54 +0000</pubDate>
      
      <guid>/post/%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 4. Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 解</description>
    </item>
    
    <item>
      <title>一种消息接收并打印的结构设计</title>
      <link>/post/%E4%B8%80%E7%A7%8D%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%E5%B9%B6%E6%89%93%E5%8D%B0%E7%9A%84%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Sun, 03 Sep 2017 18:07:34 +0000</pubDate>
      
      <guid>/post/%E4%B8%80%E7%A7%8D%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%E5%B9%B6%E6%89%93%E5%8D%B0%E7%9A%84%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</guid>
      <description>题目: 要求: 消息流最终会吐出全部的1〜N当然最终也会打印完所有的要求接收和打印1~N的整个过程,时间复杂度为O(N)的。 解析: 1 2 3 4 5 6 7</description>
    </item>
    
    <item>
      <title>从N个数中等概率打印M个数</title>
      <link>/post/%E4%BB%8En%E4%B8%AA%E6%95%B0%E4%B8%AD%E7%AD%89%E6%A6%82%E7%8E%87%E6%89%93%E5%8D%B0m%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Sun, 03 Sep 2017 17:02:02 +0000</pubDate>
      
      <guid>/post/%E4%BB%8En%E4%B8%AA%E6%95%B0%E4%B8%AD%E7%AD%89%E6%A6%82%E7%8E%87%E6%89%93%E5%8D%B0m%E4%B8%AA%E6%95%B0/</guid>
      <description>题目: 给定一个长度为N且没有重复元素的数组air和一个整数n,实现函数等概率随机打印arr中的M个数。 要求: 相同的数不要重复打印。 时间复杂度</description>
    </item>
    
    <item>
      <title>正整数数组的最小不可组成和</title>
      <link>/post/%E6%AD%A3%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E4%B8%8D%E5%8F%AF%E7%BB%84%E6%88%90%E5%92%8C/</link>
      <pubDate>Sun, 03 Sep 2017 16:30:08 +0000</pubDate>
      
      <guid>/post/%E6%AD%A3%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E4%B8%8D%E5%8F%AF%E7%BB%84%E6%88%90%E5%92%8C/</guid>
      <description>题目: 给定一个正数数组arr,其中所有的值都为整数，以下是最小不可组成和的概念： 把arr每个子集内的所有元素加起来会出现很多值，其中最小的记</description>
    </item>
    
    <item>
      <title>路径数组变为统计数组</title>
      <link>/post/%E8%B7%AF%E5%BE%84%E6%95%B0%E7%BB%84%E5%8F%98%E4%B8%BA%E7%BB%9F%E8%AE%A1%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sun, 03 Sep 2017 16:08:55 +0000</pubDate>
      
      <guid>/post/%E8%B7%AF%E5%BE%84%E6%95%B0%E7%BB%84%E5%8F%98%E4%B8%BA%E7%BB%9F%E8%AE%A1%E6%95%B0%E7%BB%84/</guid>
      <description>题目: 要求: 如果paths长度为N，请达到时间复杂度为O(N),额外空间复杂度为0(1)。 解析: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22</description>
    </item>
    
    <item>
      <title>调整[0,x)区间上的数出现的频率</title>
      <link>/post/%E8%B0%83%E6%95%B40x%E5%8C%BA%E9%97%B4%E4%B8%8A%E7%9A%84%E6%95%B0%E5%87%BA%E7%8E%B0%E7%9A%84%E9%A2%91%E7%8E%87/</link>
      <pubDate>Sun, 03 Sep 2017 14:47:00 +0000</pubDate>
      
      <guid>/post/%E8%B0%83%E6%95%B40x%E5%8C%BA%E9%97%B4%E4%B8%8A%E7%9A%84%E6%95%B0%E5%87%BA%E7%8E%B0%E7%9A%84%E9%A2%91%E7%8E%87/</guid>
      <description>题目: 解析: 1 2 3 4 5 6 7 8 9 10 public static double randXPowerK(int k) { if (k &amp;lt; 1) { return 0; } double res = -1; for (int i = 0; i != k; i++) { res = Math.max(res, Math.random()); } return res; }</description>
    </item>
    
    <item>
      <title>最大的leftMax与rightMax之差的绝对值</title>
      <link>/post/%E6%9C%80%E5%A4%A7%E7%9A%84leftmax%E4%B8%8Erightmax%E4%B9%8B%E5%B7%AE%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%80%BC/</link>
      <pubDate>Sun, 03 Sep 2017 14:36:45 +0000</pubDate>
      
      <guid>/post/%E6%9C%80%E5%A4%A7%E7%9A%84leftmax%E4%B8%8Erightmax%E4%B9%8B%E5%B7%AE%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%80%BC/</guid>
      <description>题目: 给定一个长度为N的整型数组arr,可以划分成左右两个部分，左部分为arr[O..K],右部分为arr[K+1..N-1], K可以取值的</description>
    </item>
    
    <item>
      <title>设计有setAll功能的哈希表</title>
      <link>/post/%E8%AE%BE%E8%AE%A1%E6%9C%89setall%E5%8A%9F%E8%83%BD%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8/</link>
      <pubDate>Sun, 03 Sep 2017 14:09:29 +0000</pubDate>
      
      <guid>/post/%E8%AE%BE%E8%AE%A1%E6%9C%89setall%E5%8A%9F%E8%83%BD%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8/</guid>
      <description>题目: 哈希表常见的三个操作是put、get和containsKey,而且这三个操作的时间复杂度为O(1)。现在想加一个setAll功能，就是</description>
    </item>
    
    <item>
      <title>蓄水池算法</title>
      <link>/post/%E8%93%84%E6%B0%B4%E6%B1%A0%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 03 Sep 2017 13:18:55 +0000</pubDate>
      
      <guid>/post/%E8%93%84%E6%B0%B4%E6%B1%A0%E7%AE%97%E6%B3%95/</guid>
      <description>算法简介 在不知道文件总行数的情况下，如何从文件中随机的抽取一行？ 首先想到的是我们做过类似的题目吗?当然，在知道文件行数的情况下，我们可以很容</description>
    </item>
    
    <item>
      <title>折纸问题</title>
      <link>/post/%E6%8A%98%E7%BA%B8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 03 Sep 2017 12:59:00 +0000</pubDate>
      
      <guid>/post/%E6%8A%98%E7%BA%B8%E9%97%AE%E9%A2%98/</guid>
      <description>题目: 请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折i次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从</description>
    </item>
    
    <item>
      <title>numeric库操作总结</title>
      <link>/post/numeric-%E5%BA%93%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 03 Sep 2017 11:30:37 +0000</pubDate>
      
      <guid>/post/numeric-%E5%BA%93%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>accumulate 介绍 template &amp;lt;class InputIterator, class T&amp;gt; T accumulate (InputIterator first, InputIterator last, T init); template &amp;lt;class InputIterator, class T, class BinaryOperation&amp;gt; T accumulate (InputIterator first, InputIterator last, T init, BinaryOperation binary_op); 1 2 3 4 5 6 7 8 9 template &amp;lt;class InputIterator, class T&amp;gt; T accumulate (InputIterator first, InputIterator last, T init) { while (first!=last) { init = init + *first; // or: init=binary_op(init,*first) for the binary_op</description>
    </item>
    
    <item>
      <title>哈希算法</title>
      <link>/post/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 03 Sep 2017 06:13:55 +0000</pubDate>
      
      <guid>/post/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</guid>
      <description>简介 hash table可提供对任何有名项（nameditem)的存取操作和删除操作。由于操作对象是有名项，所以hashtable也可被视为一种字典</description>
    </item>
    
    <item>
      <title>数据结构:unordered_map、unordered_set</title>
      <link>/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-unordered-mapunordered-set/</link>
      <pubDate>Sun, 03 Sep 2017 05:21:46 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-unordered-mapunordered-set/</guid>
      <description>hashtable的数据结构 bucket所维护的linked list，并不采用STL的list或slist，而是自行维护上述的hashtab</description>
    </item>
    
    <item>
      <title>数据结构:set、multiset、map、multimap</title>
      <link>/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-setmultisetmapmultimap/</link>
      <pubDate>Sun, 03 Sep 2017 05:21:28 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-setmultisetmapmultimap/</guid>
      <description>set et的特性是，所有元素都会根据元素的键值自动被排序。set的元素不像map那样可以同时拥有实值（m/m)和键值，set元素的键值就是实值，</description>
    </item>
    
    <item>
      <title>数据结构:list、forward_list</title>
      <link>/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-listforward-list/</link>
      <pubDate>Sat, 02 Sep 2017 21:04:17 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-listforward-list/</guid>
      <description>list 概述 相较于vector的连续线性空间，list就显得复杂许多，它的好处是每次插入或删除一个元素，就配置或释放一个元素空间。因此，list对</description>
    </item>
    
    <item>
      <title>数据结构:deque、stack、queue</title>
      <link>/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-dequestackqueue/</link>
      <pubDate>Sat, 02 Sep 2017 21:03:59 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-dequestackqueue/</guid>
      <description>deque 概述 vector是单向开口的连续线性空间，deque则是一种双向开口的连续线性空 间。所谓双向开口，意思是可以在头尾两端分别做元素的插人和删</description>
    </item>
    
    <item>
      <title>数据结构:vector、priority_queue</title>
      <link>/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-vectorpriority-queue/</link>
      <pubDate>Sat, 02 Sep 2017 21:03:25 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-vectorpriority-queue/</guid>
      <description>vector 概述 vector的数据安排以及操作方式，与array非常相似。两者的唯一差别在于 空间的运用的灵活性。array是静态空间，一旦配置了就不能</description>
    </item>
    
    <item>
      <title>空间配置器Allocator</title>
      <link>/post/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8allocator/</link>
      <pubDate>Sat, 02 Sep 2017 19:55:36 +0000</pubDate>
      
      <guid>/post/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8allocator/</guid>
      <description>Allocator 一般而言，我们所习惯的C++内存配置操作和释放操作是这样的: class Foo {}； Foo* pf = new Foo； // 配置内存，然后构造对象 delete pf； //将对象析构，然后</description>
    </item>
    
    <item>
      <title>判断点是否在图形内部</title>
      <link>/post/%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%9B%BE%E5%BD%A2%E5%86%85%E9%83%A8/</link>
      <pubDate>Sat, 02 Sep 2017 16:48:56 +0000</pubDate>
      
      <guid>/post/%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%9B%BE%E5%BD%A2%E5%86%85%E9%83%A8/</guid>
      <description>判断一个点是否在矩形内部 题目: 在二维坐标系中，所有的值都是double类型那么一个矩形可以由4个点来代表:（x1,y1)为最左的点、（x2,</description>
    </item>
    
    <item>
      <title>阶乘相关问题</title>
      <link>/post/%E9%98%B6%E4%B9%98%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 02 Sep 2017 16:20:21 +0000</pubDate>
      
      <guid>/post/%E9%98%B6%E4%B9%98%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 172. Factorial Trailing Zeroes Given an integer n, return the number of trailing zeroes in n!. Note: Your solution should be in logarithmic time complexity. 解析： 这个问题很简单。 因为所有的尾随0来自因子5 2。 计算包含的2和5组成的pair的个数</description>
    </item>
    
    <item>
      <title>malloc/free的用法详解</title>
      <link>/post/malloc-free%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 02 Sep 2017 15:45:26 +0000</pubDate>
      
      <guid>/post/malloc-free%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</guid>
      <description>malloc()函数 malloc的全称是memory allocation，中文叫动态内存分配。 extern void *malloc(unsigned int num_bytes); 说明： 分配长度为num_bytes字</description>
    </item>
    
    <item>
      <title>从5随机到7随机及其扩展</title>
      <link>/post/%E4%BB%8E5%E9%9A%8F%E6%9C%BA%E5%88%B07%E9%9A%8F%E6%9C%BA%E5%8F%8A%E5%85%B6%E6%89%A9%E5%B1%95/</link>
      <pubDate>Sat, 02 Sep 2017 12:31:15 +0000</pubDate>
      
      <guid>/post/%E4%BB%8E5%E9%9A%8F%E6%9C%BA%E5%88%B07%E9%9A%8F%E6%9C%BA%E5%8F%8A%E5%85%B6%E6%89%A9%E5%B1%95/</guid>
      <description>题目一 给定一个等概率随机产生1〜5的随机函数rand1To5如下： public int randlTo5() { return (int) (Math.random() * 5) + 1; } 除此之外，不能使用任何额外的随机机制，请用rand</description>
    </item>
    
    <item>
      <title>数组中未出现的最小正整数</title>
      <link>/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%AA%E5%87%BA%E7%8E%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0/</link>
      <pubDate>Sat, 02 Sep 2017 11:57:54 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%AA%E5%87%BA%E7%8E%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0/</guid>
      <description>题目: 给定一个无序整型数组arr,找到数组中未出现的最小正整数。 解析: 1 2 3 4 5 6 7 8 9 10 11 12 13 public static int missNum(int[] arr) { int l = 0; int r = arr.length; while (l &amp;lt; r) { if (arr[l] ==</description>
    </item>
    
    <item>
      <title>打印N个数组整体最大的Top K</title>
      <link>/post/%E6%89%93%E5%8D%B0n%E4%B8%AA%E6%95%B0%E7%BB%84%E6%95%B4%E4%BD%93%E6%9C%80%E5%A4%A7%E7%9A%84top-k/</link>
      <pubDate>Fri, 01 Sep 2017 23:54:58 +0000</pubDate>
      
      <guid>/post/%E6%89%93%E5%8D%B0n%E4%B8%AA%E6%95%B0%E7%BB%84%E6%95%B4%E4%BD%93%E6%9C%80%E5%A4%A7%E7%9A%84top-k/</guid>
      <description>题目: 有N个长度不一的数组，所有的数组都是有序的，请从大到小打印这N个数组整体最大的前K个数。 例如，输入含有N行元素的二维数组可以代表N个一</description>
    </item>
    
    <item>
      <title>在数组中找到一个局部最小的位置</title>
      <link>/post/%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E5%B1%80%E9%83%A8%E6%9C%80%E5%B0%8F%E7%9A%84%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Fri, 01 Sep 2017 23:36:04 +0000</pubDate>
      
      <guid>/post/%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E5%B1%80%E9%83%A8%E6%9C%80%E5%B0%8F%E7%9A%84%E4%BD%8D%E7%BD%AE/</guid>
      <description>题目: 解析: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public static int getLessIndex(int[] arr) { if (arr == null || arr.length == 0) { return -1; // no exist } if (arr.length == 1 || arr[0] &amp;lt; arr[1]) { return 0; } if (arr[arr.length - 1] &amp;lt; arr[arr.length</description>
    </item>
    
    <item>
      <title>不包含本位置值的累乘数组</title>
      <link>/post/%E4%B8%8D%E5%8C%85%E5%90%AB%E6%9C%AC%E4%BD%8D%E7%BD%AE%E5%80%BC%E7%9A%84%E7%B4%AF%E4%B9%98%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 01 Sep 2017 23:07:27 +0000</pubDate>
      
      <guid>/post/%E4%B8%8D%E5%8C%85%E5%90%AB%E6%9C%AC%E4%BD%8D%E7%BD%AE%E5%80%BC%E7%9A%84%E7%B4%AF%E4%B9%98%E6%95%B0%E7%BB%84/</guid>
      <description>LeetCode 238. Product of Array Except Self Given an array of n integers where n &amp;gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Solve it without division and in O(n). For example, given [1,2,3,4], return [24,12,8,6]. Follow up: Could you solve it with constant space complexity? (Note: The output array does not count as extra</description>
    </item>
    
    <item>
      <title>下标与数值相关联的排序</title>
      <link>/post/%E4%B8%8B%E6%A0%87%E4%B8%8E%E6%95%B0%E5%80%BC%E7%9B%B8%E5%85%B3%E8%81%94%E7%9A%84%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Fri, 01 Sep 2017 22:37:16 +0000</pubDate>
      
      <guid>/post/%E4%B8%8B%E6%A0%87%E4%B8%8E%E6%95%B0%E5%80%BC%E7%9B%B8%E5%85%B3%E8%81%94%E7%9A%84%E6%8E%92%E5%BA%8F/</guid>
      <description>题目: 给定一个长度为N的整型数组arr,其中有N个互不相等的自然数1〜N,请实现arr的排序，但是不要把下标0〜N-1位置上的数通过直接赋值</description>
    </item>
    
    <item>
      <title>计算数组的小和</title>
      <link>/post/%E8%AE%A1%E7%AE%97%E6%95%B0%E7%BB%84%E7%9A%84%E5%B0%8F%E5%92%8C/</link>
      <pubDate>Fri, 01 Sep 2017 22:07:01 +0000</pubDate>
      
      <guid>/post/%E8%AE%A1%E7%AE%97%E6%95%B0%E7%BB%84%E7%9A%84%E5%B0%8F%E5%92%8C/</guid>
      <description>题目: 解析: 下面介绍一种时间复杂度为O(NlogN)、额外空间复杂度为O(N)的方法，这是一种在归并排序的过程中，利用组间在进行合并时产生小</description>
    </item>
    
    <item>
      <title>用引用方式捕捉异常</title>
      <link>/post/%E7%94%A8%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8D%95%E6%8D%89%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Fri, 01 Sep 2017 17:20:45 +0000</pubDate>
      
      <guid>/post/%E7%94%A8%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8D%95%E6%8D%89%E5%BC%82%E5%B8%B8/</guid>
      <description>当你写一个 catch 子句时，必须确定让异常通过何种方式传递到 catch 子句里。你可以 有三个选择:与你给函数传递参数一样，通过指针(by pointer)，通过</description>
    </item>
    
    <item>
      <title>“抛出exception”与“传递参数”或“调用虚函数”之间的区别</title>
      <link>/post/%E6%8A%9B%E5%87%BAexception%E4%B8%8E%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E6%88%96%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 01 Sep 2017 17:18:07 +0000</pubDate>
      
      <guid>/post/%E6%8A%9B%E5%87%BAexception%E4%B8%8E%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E6%88%96%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>从语法上看，在函数里声明参数与在 catch 子句中声明参数几乎没有什么差别: 1 2 3 4 5 6 7 8 9 10 11 class Widget { ... }; void f1(Widget w); void f2(Widget&amp;amp; w); void f3(const Widget&amp;amp; w); void f4(Widget *pw); void f5(const Widget *pw); catch (Widget w) ...</description>
    </item>
    
    <item>
      <title>不要以多态方式处理数组</title>
      <link>/post/%E4%B8%8D%E8%A6%81%E4%BB%A5%E5%A4%9A%E6%80%81%E6%96%B9%E5%BC%8F%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 01 Sep 2017 14:46:17 +0000</pubDate>
      
      <guid>/post/%E4%B8%8D%E8%A6%81%E4%BB%A5%E5%A4%9A%E6%80%81%E6%96%B9%E5%BC%8F%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84/</guid>
      <description>类继承的最重要的特性是你可以通过基类指针或引用来操作派生类。这样的指针或引用具有行为的多态性，就好像它们同时具有多种形态。C++允许你通过基</description>
    </item>
    
    <item>
      <title>利用构造函数和析构函数防止泄漏资源</title>
      <link>/post/%E5%88%A9%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E9%81%BF%E5%85%8D%E6%B3%84%E6%BC%8F%E8%B5%84%E6%BA%90/</link>
      <pubDate>Fri, 01 Sep 2017 14:40:41 +0000</pubDate>
      
      <guid>/post/%E5%88%A9%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E9%81%BF%E5%85%8D%E6%B3%84%E6%BC%8F%E8%B5%84%E6%BA%90/</guid>
      <description>使用析构函数防止资源泄漏 定义一个类 class ALA { public: virtual void processAdoption() ; ... }; 函数循环遍历 dataSource 内的信息，处理它所遇到的每个项目。唯一要记住的一 点是在每次循环结尾处删除</description>
    </item>
    
    <item>
      <title>如何在同一程序中混合使用C&#43;&#43;和C</title>
      <link>/post/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%90%8C%E4%B8%80%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8c-%E5%92%8Cc/</link>
      <pubDate>Fri, 01 Sep 2017 13:45:29 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%90%8C%E4%B8%80%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8c-%E5%92%8Cc/</guid>
      <description>兼容性 许多年来，你一直担心编制程序时一部分使用 C++一部分使用 C，就如同在全部用 C 编 程的年代同时使用多个编译器来生成程序一样。没办法多编译器</description>
    </item>
    
    <item>
      <title>解析“static”</title>
      <link>/post/%E8%A7%A3%E6%9E%90static/</link>
      <pubDate>Fri, 01 Sep 2017 13:38:13 +0000</pubDate>
      
      <guid>/post/%E8%A7%A3%E6%9E%90static/</guid>
      <description>修饰全局变量与函数 static修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是extern外部声明也不可以。</description>
    </item>
    
    <item>
      <title>重载和覆盖的区别</title>
      <link>/post/%E9%87%8D%E8%BD%BD%E5%92%8C%E8%A6%86%E7%9B%96%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 01 Sep 2017 13:26:43 +0000</pubDate>
      
      <guid>/post/%E9%87%8D%E8%BD%BD%E5%92%8C%E8%A6%86%E7%9B%96%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>重载 重载是指函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。在同一可访问区域内被声</description>
    </item>
    
    <item>
      <title>排列组合的解法总结</title>
      <link>/post/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E7%9A%84%E8%A7%A3%E6%B3%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 31 Aug 2017 21:48:38 +0000</pubDate>
      
      <guid>/post/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E7%9A%84%E8%A7%A3%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
      <description>一.特殊元素和特殊位置优先策略 二.相邻元素捆绑策略 三.不相邻问题插空策略 四.定序问题倍缩空位插入策略 五.重排问题求幂策略 六.环排问题线排策略</description>
    </item>
    
    <item>
      <title>operator=的正确写法</title>
      <link>/post/operator-%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95/</link>
      <pubDate>Thu, 31 Aug 2017 12:10:49 +0000</pubDate>
      
      <guid>/post/operator-%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95/</guid>
      <description>返回一个 reference to *this。 关于赋值，有趣的是你可以把它们写成连锁形式： int x, y, z; x = y - z = 15; //赋值连锁形式 同样有趣的是，赋值采用右结合律，所</description>
    </item>
    
    <item>
      <title>绝不在构造和析构过程中调用virtual函数</title>
      <link>/post/%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 30 Aug 2017 23:31:05 +0000</pubDate>
      
      <guid>/post/%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0/</guid>
      <description>假设你有个class继承体系，用来塑模股市交易如买进、卖出的订单等等。这样的交易一定要经过审计，所以每当创建一个交易对象，在审计日志（aud</description>
    </item>
    
    <item>
      <title>析构函数详解</title>
      <link>/post/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 30 Aug 2017 21:58:15 +0000</pubDate>
      
      <guid>/post/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</guid>
      <description>析构函数 在有两种情况下会调用析构函数。第一种是当对象在正常状态下被销毁,也就是当它离开了它的生存空间或是被明确的删除。第二种是当对象被异常处</description>
    </item>
    
    <item>
      <title>跨编译单元的初始化次序问题浅析</title>
      <link>/post/%E8%B7%A8%E7%BC%96%E8%AF%91%E5%8D%95%E5%85%83%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%AC%A1%E5%BA%8F%E9%97%AE%E9%A2%98%E6%B5%85%E6%9E%90/</link>
      <pubDate>Wed, 30 Aug 2017 21:14:15 +0000</pubDate>
      
      <guid>/post/%E8%B7%A8%E7%BC%96%E8%AF%91%E5%8D%95%E5%85%83%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%AC%A1%E5%BA%8F%E9%97%AE%E9%A2%98%E6%B5%85%E6%9E%90/</guid>
      <description>如果某编译单元内的某个non-local static对象的初始化动作使用了另一编译单元内的某个non-local static对象，它所用到的</description>
    </item>
    
    <item>
      <title>尽量以 const, enum, inline 替换 #define</title>
      <link>/post/%E5%B0%BD%E9%87%8F%E4%BB%A5-const-enum-inline-%E6%9B%BF%E6%8D%A2-define/</link>
      <pubDate>Wed, 30 Aug 2017 16:14:14 +0000</pubDate>
      
      <guid>/post/%E5%B0%BD%E9%87%8F%E4%BB%A5-const-enum-inline-%E6%9B%BF%E6%8D%A2-define/</guid>
      <description>原因 单纯常量 const与define enum与define 函数宏 表达式形式的宏定义一例： #define ExpressionName(Var1,Var2) ((Var1)+(Var2))*((Var1)-(Var2)) 为什么要取代这种形式呢，且听我道来： 首先谈一下</description>
    </item>
    
    <item>
      <title>C&#43;&#43;变量的自动初始化</title>
      <link>/post/c-%E5%8F%98%E9%87%8F%E7%9A%84%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Wed, 30 Aug 2017 16:08:30 +0000</pubDate>
      
      <guid>/post/c-%E5%8F%98%E9%87%8F%E7%9A%84%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>对于内置变量的自动初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include&amp;lt;stdio.h&amp;gt;#define CONST 100 int *p1; int a[2]; int b; static int c; main() { int d; static int e; int f[2]; int *p2; printf(&amp;#34;CONST=%d\n&amp;#34;,CONST); printf(&amp;#34;a[0]=%d\n&amp;#34;,a[0]); //printf(&amp;#34;*p1=%d\n&amp;#34;,*p1); printf(&amp;#34;b=%d\n&amp;#34;,b); printf(&amp;#34;c=%d\n&amp;#34;,c); printf(&amp;#34;d=%d\n&amp;#34;,d); printf(&amp;#34;e=%d\n&amp;#34;,e); printf(&amp;#34;f[0]=%d\n&amp;#34;,f[0]); printf(&amp;#34;*p2=%d\n&amp;#34;,*p2); } 输出：</description>
    </item>
    
    <item>
      <title>构造函数与成员初始化列表详解</title>
      <link>/post/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 29 Aug 2017 15:03:52 +0000</pubDate>
      
      <guid>/post/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E8%AF%A6%E8%A7%A3/</guid>
      <description>成员初始化列表 何谓初始化列表 与其他函数不同，构造函数除了有名字，参数列表和函数体之外，还可以有初始化列表，初始化列表以冒号开头，后跟一系列以</description>
    </item>
    
    <item>
      <title>未排序数组中累加和为定值的最长子数组</title>
      <link>/post/%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 28 Aug 2017 16:50:52 +0000</pubDate>
      
      <guid>/post/%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>未排序正数数组中累加和为给定值的最长子数组长度 题目: 给定一个数组arr,该数组无序，但每个值均为正数，再给定一个正数k,求arr的所有子数组</description>
    </item>
    
    <item>
      <title>最长的可整合子数组的长度</title>
      <link>/post/%E6%9C%80%E9%95%BF%E7%9A%84%E5%8F%AF%E6%95%B4%E5%90%88%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Mon, 28 Aug 2017 15:16:49 +0000</pubDate>
      
      <guid>/post/%E6%9C%80%E9%95%BF%E7%9A%84%E5%8F%AF%E6%95%B4%E5%90%88%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6/</guid>
      <description>题目: 先给出可整合数组的定义。如果一个数组在排序之后，每相邻两个数差的绝对值都为1，则该数组为可整合数组。例如，[5,3,4,6,2]排序之</description>
    </item>
    
    <item>
      <title>需要排序的最短子数组长度</title>
      <link>/post/%E9%9C%80%E8%A6%81%E6%8E%92%E5%BA%8F%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Mon, 28 Aug 2017 14:16:17 +0000</pubDate>
      
      <guid>/post/%E9%9C%80%E8%A6%81%E6%8E%92%E5%BA%8F%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6/</guid>
      <description>题目: 给定一个无序数组air,求出需要排序的最短子数组长度。 例如：arr = [1，5, 3，4，2, 6，7]返回4，因为只有[5，3, 4，2]需</description>
    </item>
    
    <item>
      <title>找到无序数组中的第k个数</title>
      <link>/post/%E6%89%BE%E5%88%B0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Sun, 27 Aug 2017 20:16:25 +0000</pubDate>
      
      <guid>/post/%E6%89%BE%E5%88%B0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%95%B0/</guid>
      <description>LeetCode 215. Kth Largest Element in an Array Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. For example, Given [3,2,1,5,6,4] and k = 2, return 5. Note: You may assume k is always valid, 1 ≤ k ≤ array’s length. 解析：求第K</description>
    </item>
    
    <item>
      <title>“之”字形打印矩阵</title>
      <link>/post/%E4%B9%8B%E5%AD%97%E5%BD%A2%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Sun, 27 Aug 2017 20:04:40 +0000</pubDate>
      
      <guid>/post/%E4%B9%8B%E5%AD%97%E5%BD%A2%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</guid>
      <description>题目: 解析: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public static void printMatrixZigZag(int[][] matrix) { int tR = 0; int tC = 0; int dR = 0; int dC = 0; int endR = matrix.length - 1; int endC = matrix[0].length</description>
    </item>
    
    <item>
      <title>汉明距离</title>
      <link>/post/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</link>
      <pubDate>Sun, 27 Aug 2017 19:49:03 +0000</pubDate>
      
      <guid>/post/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</guid>
      <description>LeetCode 461. Hamming Distance The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. 解析：利用异或来求出不同的位，然后取出每一个1. 1 2 3 4 5 6 7 8 9 10 11 class Solution {</description>
    </item>
    
    <item>
      <title>只用位运算不用算术运算实现整数的加减乘除运算</title>
      <link>/post/%E5%8F%AA%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B8%8D%E7%94%A8%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E6%95%B4%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97/</link>
      <pubDate>Sun, 27 Aug 2017 19:01:06 +0000</pubDate>
      
      <guid>/post/%E5%8F%AA%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B8%8D%E7%94%A8%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E6%95%B4%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97/</guid>
      <description>题目: 给定两个32位整数a和b,可正、可负、可0。不能使用算术运算符，分别实现a和b的加减乘除运算。如果给定的a和b执行加减乘除的某些结果本</description>
    </item>
    
    <item>
      <title>不用任何比较判断找出两个数中较大的数</title>
      <link>/post/%E4%B8%8D%E7%94%A8%E4%BB%BB%E4%BD%95%E6%AF%94%E8%BE%83%E5%88%A4%E6%96%AD%E6%89%BE%E5%87%BA%E4%B8%A4%E4%B8%AA%E6%95%B0%E4%B8%AD%E8%BE%83%E5%A4%A7%E7%9A%84%E6%95%B0/</link>
      <pubDate>Sun, 27 Aug 2017 18:35:10 +0000</pubDate>
      
      <guid>/post/%E4%B8%8D%E7%94%A8%E4%BB%BB%E4%BD%95%E6%AF%94%E8%BE%83%E5%88%A4%E6%96%AD%E6%89%BE%E5%87%BA%E4%B8%A4%E4%B8%AA%E6%95%B0%E4%B8%AD%E8%BE%83%E5%A4%A7%E7%9A%84%E6%95%B0/</guid>
      <description>题目: 给定两个32位整数a和b，返回a和b中较大的。不用任何比较判断。包括等于号. 解析: 第一种方法。得到a-b的值的符号，就可以知道是返回a</description>
    </item>
    
    <item>
      <title>不用额外变量交换两个整数的值</title>
      <link>/post/%E4%B8%8D%E7%94%A8%E9%A2%9D%E5%A4%96%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E5%80%BC/</link>
      <pubDate>Sun, 27 Aug 2017 18:16:47 +0000</pubDate>
      
      <guid>/post/%E4%B8%8D%E7%94%A8%E9%A2%9D%E5%A4%96%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E5%80%BC/</guid>
      <description>题目: 如何不用任何额外变量交换两个整数的值？ 解析: 如果给定整数a和b,用以下三行代码即可交换a和b的值。 a = a ^ b; b = a ^ b; a = a ^ b; 如何理</description>
    </item>
    
    <item>
      <title>找到被指的新类型字符</title>
      <link>/post/%E6%89%BE%E5%88%B0%E8%A2%AB%E6%8C%87%E7%9A%84%E6%96%B0%E7%B1%BB%E5%9E%8B%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Sun, 27 Aug 2017 00:41:28 +0000</pubDate>
      
      <guid>/post/%E6%89%BE%E5%88%B0%E8%A2%AB%E6%8C%87%E7%9A%84%E6%96%B0%E7%B1%BB%E5%9E%8B%E5%AD%97%E7%AC%A6/</guid>
      <description>题目: 新类型字符的定义如下： 新类型字符是长度为1或者2的字符串。 表现形式可以仅是小写字母,例如”e&amp;rdquo;;也可以是大写字母+小写字母</description>
    </item>
    
    <item>
      <title>拼接字符串产生字典顺序最小的字符串</title>
      <link>/post/%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A7%E7%94%9F%E5%AD%97%E5%85%B8%E9%A1%BA%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sat, 26 Aug 2017 23:22:11 +0000</pubDate>
      
      <guid>/post/%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A7%E7%94%9F%E5%AD%97%E5%85%B8%E9%A1%BA%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>LeetCode 179. Largest Number Given a list of non negative integers, arrange them such that they form the largest number. For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330. Note: The result may be very large, so you need to return a string instead of an integer. 解析： 把所有数全部转换成字符串，方便</description>
    </item>
    
    <item>
      <title>字符串匹配</title>
      <link>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Sat, 26 Aug 2017 16:09:41 +0000</pubDate>
      
      <guid>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</guid>
      <description>LeetCode 459. Repeated Substring Pattern 给定一个非空字符串检查，如果它可以通过取其子字符串并将子字符串的多个副本附加在一起构造。 您可以假定给定字符串仅由小写英文字母组成，</description>
    </item>
    
    <item>
      <title>构造回文字符串</title>
      <link>/post/%E6%9E%84%E9%80%A0%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sat, 26 Aug 2017 15:56:04 +0000</pubDate>
      
      <guid>/post/%E6%9E%84%E9%80%A0%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>添加最少字符使字符串整体都是回文字符串 题目: 给定一个字符串str,如果可以在str的任意位置添加字符，请返回在添加字符最少的 情况下，让str</description>
    </item>
    
    <item>
      <title>数组中两个字符串的最小距离</title>
      <link>/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/</link>
      <pubDate>Sat, 26 Aug 2017 14:12:18 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/</guid>
      <description>题目: 给定一个字符串数组strs，再给定两个字符串str1和str2,返回在strs中str1与str2的 最小距离，如果str1或str2为</description>
    </item>
    
    <item>
      <title>字符串的调整与替换</title>
      <link>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%B0%83%E6%95%B4%E4%B8%8E%E6%9B%BF%E6%8D%A2/</link>
      <pubDate>Fri, 25 Aug 2017 14:18:57 +0000</pubDate>
      
      <guid>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%B0%83%E6%95%B4%E4%B8%8E%E6%9B%BF%E6%8D%A2/</guid>
      <description>字符串的替换 题目: 给定一个字符类型的数组chas[], chas右半区全是空字符，左半区不含有空字符。现 在想将左半区中所有的空格字符替换成&amp;r</description>
    </item>
    
    <item>
      <title>在有序但含有空的数组中查找字符串</title>
      <link>/post/%E5%9C%A8%E6%9C%89%E5%BA%8F%E4%BD%86%E5%90%AB%E6%9C%89%E7%A9%BA%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Thu, 24 Aug 2017 23:09:25 +0000</pubDate>
      
      <guid>/post/%E5%9C%A8%E6%9C%89%E5%BA%8F%E4%BD%86%E5%90%AB%E6%9C%89%E7%A9%BA%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目: 给定一个字符串数组strs[],在sirs中有些位置为null,但在不为null的位置上，其字符串是按照字典顺序由小到大依次出现的。再</description>
    </item>
    
    <item>
      <title>替换字符串中连续出现的指定字符串</title>
      <link>/post/%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E8%BF%9E%E7%BB%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Thu, 24 Aug 2017 17:24:37 +0000</pubDate>
      
      <guid>/post/%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E8%BF%9E%E7%BB%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目: 给定三个字符串str、from和to,把str中所有from的子串全部替换成to字符串，对 连续出现from的部分要求只替换成一个to字</description>
    </item>
    
    <item>
      <title>去掉字符串中连续出现k个0的子串</title>
      <link>/post/%E5%8E%BB%E6%8E%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E8%BF%9E%E7%BB%AD%E5%87%BA%E7%8E%B0k%E4%B8%AA0%E7%9A%84%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Thu, 24 Aug 2017 15:36:11 +0000</pubDate>
      
      <guid>/post/%E5%8E%BB%E6%8E%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E8%BF%9E%E7%BB%AD%E5%87%BA%E7%8E%B0k%E4%B8%AA0%E7%9A%84%E5%AD%90%E4%B8%B2/</guid>
      <description>题目: 给定一个字符串str和一个整数如果str中正好有连续的yt个•0&#39;字符出现时，把k个 连续的&amp;rsquo;0’字符去除，返回处理后的字符</description>
    </item>
    
    <item>
      <title>字符串中数字子串的求和</title>
      <link>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%95%B0%E5%AD%97%E5%AD%90%E4%B8%B2%E7%9A%84%E6%B1%82%E5%92%8C/</link>
      <pubDate>Thu, 24 Aug 2017 14:00:27 +0000</pubDate>
      
      <guid>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%95%B0%E5%AD%97%E5%AD%90%E4%B8%B2%E7%9A%84%E6%B1%82%E5%92%8C/</guid>
      <description>题目: 给定一个字符串stn求其中全部数字串所代表的数字之和。 忽略小数点字符，例如&amp;quot;A1.3&amp;rdquo;,其中包含两个数字1和3。</description>
    </item>
    
    <item>
      <title>排成一条线的博弈问题</title>
      <link>/post/%E6%8E%92%E6%88%90%E4%B8%80%E6%9D%A1%E7%BA%BF%E7%9A%84%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 23 Aug 2017 21:07:22 +0000</pubDate>
      
      <guid>/post/%E6%8E%92%E6%88%90%E4%B8%80%E6%9D%A1%E7%BA%BF%E7%9A%84%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/</guid>
      <description>LintCode Coins in a Line II 有 n 个不同价值的硬币排成一条线。两个参赛者轮流从左边依次拿走 1 或 2 个硬币，直到没有硬币为止。计算两个人分别拿到的硬币总价值，价值</description>
    </item>
    
    <item>
      <title>公式字符串求值</title>
      <link>/post/%E5%85%AC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B1%82%E5%80%BC/</link>
      <pubDate>Wed, 23 Aug 2017 17:30:52 +0000</pubDate>
      
      <guid>/post/%E5%85%AC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B1%82%E5%80%BC/</guid>
      <description>LeetCode 150. Evaluate Reverse Polish Notation Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Some examples: [&amp;quot;2&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;+&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;*&amp;quot;] -&amp;gt; ((2 + 1) * 3) -&amp;gt; 9 [&amp;quot;4&amp;quot;, &amp;quot;13&amp;quot;, &amp;quot;5&amp;quot;, &amp;quot;/&amp;quot;, &amp;quot;+&amp;quot;] -&amp;gt; (4 + (13 / 5)) -&amp;gt; 6 解析：用栈来模拟运</description>
    </item>
    
    <item>
      <title>字符串切分</title>
      <link>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E5%88%86/</link>
      <pubDate>Wed, 23 Aug 2017 14:46:27 +0000</pubDate>
      
      <guid>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E5%88%86/</guid>
      <description>数字字符串转换为字母组合的种数 给定一个字符串str, str全部由数字字符组成，如果str中某一个或某相邻两个字符组 成的子串值在1〜26之间，</description>
    </item>
    
    <item>
      <title>字符串交错组成</title>
      <link>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A4%E9%94%99%E7%BB%84%E6%88%90/</link>
      <pubDate>Tue, 22 Aug 2017 22:44:02 +0000</pubDate>
      
      <guid>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A4%E9%94%99%E7%BB%84%E6%88%90/</guid>
      <description>LeetCode 97. Interleaving String Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. For example, Given: s1 = “aabcc”, s2 = “dbbca”, When s3 = “aadbbcbcac”, return true. When s3 = “aadbb</description>
    </item>
    
    <item>
      <title>最长公共子序列/子串</title>
      <link>/post/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Tue, 22 Aug 2017 17:42:36 +0000</pubDate>
      
      <guid>/post/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E5%AD%90%E4%B8%B2/</guid>
      <description>最长公共子序列 题目: 给定两个字符串str1和str2,返回两个字符串的最长公共子序列。 解析: 如果str1的长度为M，str2的长度为N,生成</description>
    </item>
    
    <item>
      <title>一道题了解动态规划</title>
      <link>/post/%E4%B8%80%E9%81%93%E9%A2%98%E4%BA%86%E8%A7%A3%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Tue, 22 Aug 2017 15:31:13 +0000</pubDate>
      
      <guid>/post/%E4%B8%80%E9%81%93%E9%A2%98%E4%BA%86%E8%A7%A3%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>题目 给定数组arr，arr中所有的值都为正数且不重复。每个值代表一种面值的货币，每种 面值的货币可以使用任意张，再给定一个整数aim代表要找的</description>
    </item>
    
    <item>
      <title>在二叉树中找到一个节点的后继节点</title>
      <link>/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sat, 19 Aug 2017 22:51:16 +0000</pubDate>
      
      <guid>/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9/</guid>
      <description>题目: 现在有一种新的二叉树节点类型如下： public class Node { public int value; public Node left; public Node right; public Node parent; public Node(int data) { this.value = data; } 该结构比普通二叉树节点结构多了一个指向父节点的par</description>
    </item>
    
    <item>
      <title>判断二叉树的类型</title>
      <link>/post/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 19 Aug 2017 22:07:36 +0000</pubDate>
      
      <guid>/post/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%B1%BB%E5%9E%8B/</guid>
      <description>LeetCode 110. Balanced Binary Tree Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 解析：dfs求每个节点的高度，在求高度的同时判断当前</description>
    </item>
    
    <item>
      <title>调整搜索二叉树中两个错误的节点</title>
      <link>/post/%E8%B0%83%E6%95%B4%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sat, 19 Aug 2017 20:13:36 +0000</pubDate>
      
      <guid>/post/%E8%B0%83%E6%95%B4%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>LeetCode 99. Recover Binary Search Tree Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Note: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? 解析： 中序遍历二叉树，出现的节点的值会升序排序，如果有两</description>
    </item>
    
    <item>
      <title>查找二叉树中的搜索二叉树</title>
      <link>/post/%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E5%AD%90%E6%A0%91/</link>
      <pubDate>Fri, 18 Aug 2017 22:03:48 +0000</pubDate>
      
      <guid>/post/%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E5%AD%90%E6%A0%91/</guid>
      <description>查找二叉树中的最大搜索二叉子树 给定一棵二叉树的头节点head,己知其中所有节点的值都不一样，找到含有节点最多 的搜索二叉子树，并返回这棵子树的</description>
    </item>
    
    <item>
      <title>如何较为直观地打印二叉树</title>
      <link>/post/%E5%A6%82%E4%BD%95%E8%BE%83%E4%B8%BA%E7%9B%B4%E8%A7%82%E5%9C%B0%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Fri, 18 Aug 2017 14:16:02 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E8%BE%83%E4%B8%BA%E7%9B%B4%E8%A7%82%E5%9C%B0%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目: 二叉树可以用常规的三种遍历结果来描述其结构，但是不够直观，尤其是二叉树中有 重复值的时候，仅通过三种遍历的结果来构造二叉树的真实结构更是</description>
    </item>
    
    <item>
      <title>打印二叉树的边界节点</title>
      <link>/post/%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BE%B9%E7%95%8C%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 17 Aug 2017 17:32:32 +0000</pubDate>
      
      <guid>/post/%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BE%B9%E7%95%8C%E8%8A%82%E7%82%B9/</guid>
      <description>题目 给定一棵二叉树的头节点head,按照如下两种标准分别实现二叉树边界节点的逆时针打印。 标准一： 头节点为边界节点。 叶节点为边界节点。 如果节点</description>
    </item>
    
    <item>
      <title>向有序的环形单链表插入新节点</title>
      <link>/post/%E5%90%91%E6%9C%89%E5%BA%8F%E7%9A%84%E7%8E%AF%E5%BD%A2%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%96%B0%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 17 Aug 2017 16:01:21 +0000</pubDate>
      
      <guid>/post/%E5%90%91%E6%9C%89%E5%BA%8F%E7%9A%84%E7%8E%AF%E5%BD%A2%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%96%B0%E8%8A%82%E7%82%B9/</guid>
      <description>题目: 一个环形单链表从头节点head幵始不降序，同时由最后的节点指回头节点。给定这样一个环形单链表的头节点head和一个整数num，请生成节</description>
    </item>
    
    <item>
      <title>删除无序单链表中值重复出现的点</title>
      <link>/post/%E5%88%A0%E9%99%A4%E6%97%A0%E5%BA%8F%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%BC%E9%87%8D%E5%A4%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E7%82%B9/</link>
      <pubDate>Thu, 17 Aug 2017 14:18:44 +0000</pubDate>
      
      <guid>/post/%E5%88%A0%E9%99%A4%E6%97%A0%E5%BA%8F%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%BC%E9%87%8D%E5%A4%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E7%82%B9/</guid>
      <description>删除无序单链表中值重复出现的点 给定一个无序单链表的头节点head,删除其中值重复出现的节点。 例如：1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;</description>
    </item>
    
    <item>
      <title>构造数组的MaxTree</title>
      <link>/post/%E6%9E%84%E9%80%A0%E6%95%B0%E7%BB%84%E7%9A%84maxtree/</link>
      <pubDate>Wed, 16 Aug 2017 18:26:35 +0000</pubDate>
      
      <guid>/post/%E6%9E%84%E9%80%A0%E6%95%B0%E7%BB%84%E7%9A%84maxtree/</guid>
      <description>题目 对于一个没有重复元素的整数数组，请用其中元素构造一棵MaxTree，MaxTree定义为一棵二叉树，其中的节点与数组元素一一对应，同时对</description>
    </item>
    
    <item>
      <title>用一个栈实现另一个栈的排序</title>
      <link>/post/%E7%94%A8%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%88%E7%9A%84%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Wed, 16 Aug 2017 17:45:36 +0000</pubDate>
      
      <guid>/post/%E7%94%A8%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%88%E7%9A%84%E6%8E%92%E5%BA%8F/</guid>
      <description>一个栈中元素的类型为整型，现在想将该栈从顶到底按从大到小的顺序排序，只许申 请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。如</description>
    </item>
    
    <item>
      <title>猫狗队列</title>
      <link>/post/%E7%8C%AB%E7%8B%97%E9%98%9F%E5%88%97/</link>
      <pubDate>Wed, 16 Aug 2017 17:33:03 +0000</pubDate>
      
      <guid>/post/%E7%8C%AB%E7%8B%97%E9%98%9F%E5%88%97/</guid>
      <description>题目: 宠物、狗和猫的类如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Pet { private String type ; public Pet(String type) { this.type = type ; } public String getPetType() { return this.type ; } } public class Dog extends Pet{ public</description>
    </item>
    
    <item>
      <title>如何仅用递归函数和栈操作逆序一个栈</title>
      <link>/post/%E5%A6%82%E4%BD%95%E4%BB%85%E7%94%A8%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88%E6%93%8D%E4%BD%9C%E9%80%86%E5%BA%8F%E4%B8%80%E4%B8%AA%E6%A0%88/</link>
      <pubDate>Wed, 16 Aug 2017 17:05:28 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E4%BB%85%E7%94%A8%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88%E6%93%8D%E4%BD%9C%E9%80%86%E5%BA%8F%E4%B8%80%E4%B8%AA%E6%A0%88/</guid>
      <description>题目: 一个栈依次压入1、2、3、4、5,那么从栈顶到栈底分别为5、4、3、2、1。将这个栈 转置后，从栈顶到桟底为1、2、3、4、5,也就是实</description>
    </item>
    
    <item>
      <title>汉诺塔问题分析</title>
      <link>/post/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 16 Aug 2017 16:39:46 +0000</pubDate>
      
      <guid>/post/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</guid>
      <description></description>
    </item>
    
    <item>
      <title>嵌入式SQL入门</title>
      <link>/post/%E5%B5%8C%E5%85%A5%E5%BC%8Fsql%E5%85%A5%E9%97%A8/</link>
      <pubDate>Wed, 16 Aug 2017 10:48:58 +0000</pubDate>
      
      <guid>/post/%E5%B5%8C%E5%85%A5%E5%BC%8Fsql%E5%85%A5%E9%97%A8/</guid>
      <description>嵌入式SQL的处理过程 嵌入式SQL是将SQL语句嵌入程序设计语言中，被嵌入的程序设计语言，如C、C++、 Java等称为宿主语言，简称主语言。</description>
    </item>
    
    <item>
      <title>E-R模型与关系模型</title>
      <link>/post/e-r%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Tue, 15 Aug 2017 16:06:24 +0000</pubDate>
      
      <guid>/post/e-r%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/</guid>
      <description>实体之间的联系 (1) 两个实体型之间的联系 ### 一对一联系（1:1) 如果对于实体集乂中的每一个实体，实体集S中至多有一个（也可以没有）实体与之 联系，反</description>
    </item>
    
    <item>
      <title>索引和聚簇浅析</title>
      <link>/post/%E7%B4%A2%E5%BC%95%E5%92%8C%E8%81%9A%E7%B0%87%E6%B5%85%E6%9E%90/</link>
      <pubDate>Tue, 15 Aug 2017 16:03:34 +0000</pubDate>
      
      <guid>/post/%E7%B4%A2%E5%BC%95%E5%92%8C%E8%81%9A%E7%B0%87%E6%B5%85%E6%9E%90/</guid>
      <description>存取方法 存取方法是快速存取数据库中数据的技术。数据库管理系统一般提供多种存取方法。常用的存取方法为索引方法和聚簇（clustering)方法</description>
    </item>
    
    <item>
      <title>数据库的规范化</title>
      <link>/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96/</link>
      <pubDate>Tue, 15 Aug 2017 15:59:45 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96/</guid>
      <description>函数依赖 函数依赖和别的数据依赖一样是语义范畴的概念，只能根据语义来确定一个函数依赖。例如，姓名一年龄这个函数依赖只有在该部门没有同名人的条件</description>
    </item>
    
    <item>
      <title>数据库完整性浅析</title>
      <link>/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E6%B5%85%E6%9E%90/</link>
      <pubDate>Tue, 15 Aug 2017 15:55:24 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E6%B5%85%E6%9E%90/</guid>
      <description>介绍 数据库的完整性（integrity )是指数据的正确性（correctness)和相容性（compat- ability )。数据的正确性是指数据是符合现</description>
    </item>
    
    <item>
      <title>视图详解</title>
      <link>/post/%E8%A7%86%E5%9B%BE%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 15 Aug 2017 13:44:26 +0000</pubDate>
      
      <guid>/post/%E8%A7%86%E5%9B%BE%E8%AF%A6%E8%A7%A3/</guid>
      <description>简介 视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库中只存放视图的定义，而不存放视图对应的数据，这些数据仍存放</description>
    </item>
    
    <item>
      <title>SQL语句:DML语句-数据查询</title>
      <link>/post/sql%E8%AF%AD%E5%8F%A5-dml%E8%AF%AD%E5%8F%A5-%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Sun, 13 Aug 2017 23:42:36 +0000</pubDate>
      
      <guid>/post/sql%E8%AF%AD%E5%8F%A5-dml%E8%AF%AD%E5%8F%A5-%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/</guid>
      <description>介绍 数据查询是数据库的核心操作。SQL提供了 SELECT语句进行数据查询，该语句具有 灵活的使用方式和丰富的功能。其一般格式为 SELECT [ALL丨DI</description>
    </item>
    
    <item>
      <title>SQL语句:DML语句-数据更新</title>
      <link>/post/sql%E8%AF%AD%E5%8F%A5-dml%E8%AF%AD%E5%8F%A5-%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0/</link>
      <pubDate>Sun, 13 Aug 2017 20:09:33 +0000</pubDate>
      
      <guid>/post/sql%E8%AF%AD%E5%8F%A5-dml%E8%AF%AD%E5%8F%A5-%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0/</guid>
      <description>1.插入记录 插入元组 表创建好后，就可以往里插入记录了，插入记录的基本语法如下: INSERT INTO tablename (field1,field2,......fieldn) VALUES(value1,value2,......valuesn); 例如，向表 emp 中插入以下记录:ename 为 zzx1，h</description>
    </item>
    
    <item>
      <title>SQL语句:DCL语句</title>
      <link>/post/sql%E8%AF%AD%E5%8F%A5-dcl%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Sun, 13 Aug 2017 20:09:30 +0000</pubDate>
      
      <guid>/post/sql%E8%AF%AD%E5%8F%A5-dcl%E8%AF%AD%E5%8F%A5/</guid>
      <description>SQL中使用GRANT和REVOKE语句向用户授予或收回对数据的操作权限。GRANT语句向用户授予权限，REVOKE语句收回已经授予用户的权</description>
    </item>
    
    <item>
      <title>SQL语句:DDL语句</title>
      <link>/post/sql%E8%AF%AD%E5%8F%A5-ddl%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Sun, 13 Aug 2017 20:09:20 +0000</pubDate>
      
      <guid>/post/sql%E8%AF%AD%E5%8F%A5-ddl%E8%AF%AD%E5%8F%A5/</guid>
      <description>DDL 是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的 操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不</description>
    </item>
    
    <item>
      <title>正则表达式详解</title>
      <link>/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 12 Aug 2017 22:39:08 +0000</pubDate>
      
      <guid>/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/</guid>
      <description>定义 正则表达式是你所定义的模式模板(pattern template)，Linux工具可以用它来过滤文本。Linux 工具(比如sed编辑器或g</description>
    </item>
    
    <item>
      <title>一行sed实现文本翻转</title>
      <link>/post/%E4%B8%80%E8%A1%8Csed%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BF%BB%E8%BD%AC/</link>
      <pubDate>Sat, 12 Aug 2017 15:19:46 +0000</pubDate>
      
      <guid>/post/%E4%B8%80%E8%A1%8Csed%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BF%BB%E8%BD%AC/</guid>
      <description>要实现这个效果(先显示最后一行，最 后显示第一行)，你得利用保持空间做一些特别的铺垫工作。 你得像这样使用模式空间: (1) 在模式空间中放置一行; (2) 将</description>
    </item>
    
    <item>
      <title>gawk编辑器详解</title>
      <link>/post/gawk%E7%BC%96%E8%BE%91%E5%99%A8%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 11 Aug 2017 20:45:01 +0000</pubDate>
      
      <guid>/post/gawk%E7%BC%96%E8%BE%91%E5%99%A8%E8%AF%A6%E8%A7%A3/</guid>
      <description>介绍 虽然sed编辑器是非常方便自动修改文本文件的工具，但其也有自身的限制。通常你需要一 个用来处理文件中的数据的更高级工具，它能提供一个类编程</description>
    </item>
    
    <item>
      <title>sed编辑器进阶</title>
      <link>/post/sed%E7%BC%96%E8%BE%91%E5%99%A8%E8%BF%9B%E9%98%B6/</link>
      <pubDate>Fri, 11 Aug 2017 20:44:40 +0000</pubDate>
      
      <guid>/post/sed%E7%BC%96%E8%BE%91%E5%99%A8%E8%BF%9B%E9%98%B6/</guid>
      <description>多行命令 sed编辑器包含了三个可用来处理多行文本的特殊命令。 N:将数据流中的下一行加进来创建一个多行组(multiline group)来处理</description>
    </item>
    
    <item>
      <title>sed编辑器入门</title>
      <link>/post/sed%E7%BC%96%E8%BE%91%E5%99%A8%E5%85%A5%E9%97%A8/</link>
      <pubDate>Fri, 11 Aug 2017 20:44:36 +0000</pubDate>
      
      <guid>/post/sed%E7%BC%96%E8%BE%91%E5%99%A8%E5%85%A5%E9%97%A8/</guid>
      <description>介绍 sed编辑器被称作流编辑器(stream editor)，和普通的交互式文本编辑器恰好相反。在交互式 文本编辑器中(比如vim)，你可以用键</description>
    </item>
    
    <item>
      <title>shell脚本中的函数使用</title>
      <link>/post/shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 11 Aug 2017 10:26:30 +0000</pubDate>
      
      <guid>/post/shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/</guid>
      <description>基本的脚本函数 函数是一个脚本代码块，你可以为其命名并在代码中任何位置重 用。要在脚本中使用该代码块时，只要使用所起的函数名就行了(这个过程称为</description>
    </item>
    
    <item>
      <title>定时运行作业</title>
      <link>/post/%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%E4%BD%9C%E4%B8%9A/</link>
      <pubDate>Fri, 11 Aug 2017 09:47:13 +0000</pubDate>
      
      <guid>/post/%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%E4%BD%9C%E4%B8%9A/</guid>
      <description>Linux系统提供了多个在预选时间运行脚本的方法:at命令和cron表。每个方法都使用不同的技 术来安排脚本的运行时间和频率。 at命令来计划执</description>
    </item>
    
    <item>
      <title>date命令详解</title>
      <link>/post/date%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 10 Aug 2017 22:08:24 +0000</pubDate>
      
      <guid>/post/date%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid>
      <description>定义 date命令是显示或设置系统时间与日期。 很多shell脚本里面需要打印不同格式的时间或日期，以及要根据时间和日期执行操作。延时通常用于脚</description>
    </item>
    
    <item>
      <title>作业控制、调整nice值</title>
      <link>/post/%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6%E8%B0%83%E6%95%B4nice%E5%80%BC/</link>
      <pubDate>Thu, 10 Aug 2017 21:08:16 +0000</pubDate>
      
      <guid>/post/%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6%E8%B0%83%E6%95%B4nice%E5%80%BC/</guid>
      <description>作业控制 在作业停止后， Linux系统会让你选择是终止还是重启。你可以用kill命令终止该进程。要重启停止的进程需要 向其发送一个SIGCONT</description>
    </item>
    
    <item>
      <title>shell对信号的处理</title>
      <link>/post/shell%E5%AF%B9%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86/</link>
      <pubDate>Thu, 10 Aug 2017 19:58:23 +0000</pubDate>
      
      <guid>/post/shell%E5%AF%B9%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86/</guid>
      <description>处理信号 Linux系统和应用程序可以生成超过30个信号。下表列出了在Linux编程时会遇到的最常见的Linux系统信号。 默认情况下，bash</description>
    </item>
    
    <item>
      <title>创建临时文件和目录</title>
      <link>/post/%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Thu, 10 Aug 2017 17:12:14 +0000</pubDate>
      
      <guid>/post/%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</guid>
      <description>创建临时文件 Linux系统有特殊的目录，专供临时文件使用。Linux使用/tmp目录来存放不需要永久保留的 文件。大多数Linux发行版配置了</description>
    </item>
    
    <item>
      <title>Go的堆栈打印</title>
      <link>/post/go%E7%9A%84%E5%A0%86%E6%A0%88%E6%89%93%E5%8D%B0/</link>
      <pubDate>Thu, 10 Aug 2017 14:08:15 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E5%A0%86%E6%A0%88%E6%89%93%E5%8D%B0/</guid>
      <description>打印全部堆栈 Stack trace是指堆栈回溯信息，在当前时间，以当前方法的执行点开始，回溯调用它的方法的方法的执行点，然后继续回溯，这样就可以跟踪整</description>
    </item>
    
    <item>
      <title>输入输出重定向</title>
      <link>/post/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/</link>
      <pubDate>Thu, 10 Aug 2017 14:08:15 +0000</pubDate>
      
      <guid>/post/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/</guid>
      <description>标准文件描述符 Linux系统将每个对象当作文件处理。这包括输入和输出进程。Linux用文件描述符(file descriptor)来标识每个文</description>
    </item>
    
    <item>
      <title>利用read获取用户输入</title>
      <link>/post/%E5%88%A9%E7%94%A8read%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/</link>
      <pubDate>Thu, 10 Aug 2017 10:53:44 +0000</pubDate>
      
      <guid>/post/%E5%88%A9%E7%94%A8read%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/</guid>
      <description>尽管命令行选项和参数是从脚本用户处获得输入的一种重要方式，但有时脚本的交互性还需 要更强一些。比如你想要在脚本运行时问个问题，并等待运行脚本的</description>
    </item>
    
    <item>
      <title>脚本对命令行选项的处理方法</title>
      <link>/post/%E8%84%9A%E6%9C%AC%E5%AF%B9%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 10 Aug 2017 10:42:41 +0000</pubDate>
      
      <guid>/post/%E8%84%9A%E6%9C%AC%E5%AF%B9%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</guid>
      <description>基本方法 表面上看，命令行选项也没什么特殊的。在命令行上，它们紧跟在脚本名之后，就跟命令行 参数一样。实际上，如果愿意，你可以像处理命令行参数一</description>
    </item>
    
    <item>
      <title>命令行参数和特殊参数</title>
      <link>/post/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%92%8C%E7%89%B9%E6%AE%8A%E5%8F%82%E6%95%B0/</link>
      <pubDate>Wed, 09 Aug 2017 22:23:24 +0000</pubDate>
      
      <guid>/post/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%92%8C%E7%89%B9%E6%AE%8A%E5%8F%82%E6%95%B0/</guid>
      <description>命令行参数 向shell脚本传递数据的最基本方法是使用命令行参数。命令行参数允许在运行脚本时向命令行添加数据。 $ ./addem 10 30 读取参数 bash shell会将</description>
    </item>
    
    <item>
      <title>循环命令while、until、break、continue详解</title>
      <link>/post/%E5%BE%AA%E7%8E%AF%E5%91%BD%E4%BB%A4whileuntil%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 09 Aug 2017 20:48:16 +0000</pubDate>
      
      <guid>/post/%E5%BE%AA%E7%8E%AF%E5%91%BD%E4%BB%A4whileuntil%E8%AF%A6%E8%A7%A3/</guid>
      <description>while命令 while命令允许定义一个要测试 的命令，然后循环执行一组命令，只要定义的测试命令返回的是退出状态码0。它会在每次迭代的 一开始测</description>
    </item>
    
    <item>
      <title>循环命令for详解</title>
      <link>/post/%E5%BE%AA%E7%8E%AF%E5%91%BD%E4%BB%A4for%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 09 Aug 2017 18:46:05 +0000</pubDate>
      
      <guid>/post/%E5%BE%AA%E7%8E%AF%E5%91%BD%E4%BB%A4for%E8%AF%A6%E8%A7%A3/</guid>
      <description>for命令 bash shell提供了for命令，允许你创建一个遍历一系列值的循环。每次迭代都使用其中一个值来执行已定义好的一组命令。下面是bash s</description>
    </item>
    
    <item>
      <title>if-then的测试功能</title>
      <link>/post/if-then%E7%9A%84%E6%B5%8B%E8%AF%95%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Wed, 09 Aug 2017 16:17:02 +0000</pubDate>
      
      <guid>/post/if-then%E7%9A%84%E6%B5%8B%E8%AF%95%E5%8A%9F%E8%83%BD/</guid>
      <description>退出状态码 定义 shell中运行的每个命令都使用退出状态码(exit status)告诉shell它已经运行完毕。退出状态 码是一个0~255的整</description>
    </item>
    
    <item>
      <title>通过shell进行数学运算</title>
      <link>/post/%E9%80%9A%E8%BF%87shell%E8%BF%9B%E8%A1%8C%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97/</link>
      <pubDate>Wed, 09 Aug 2017 16:16:09 +0000</pubDate>
      
      <guid>/post/%E9%80%9A%E8%BF%87shell%E8%BF%9B%E8%A1%8C%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97/</guid>
      <description>expr命令 expr命令允许在命令行上处理数学表达式，但是特别笨拙。 许多expr命令操作符在shell中另有含义(比如星号)。当它们出现在在</description>
    </item>
    
    <item>
      <title>文件权限解析</title>
      <link>/post/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 09 Aug 2017 09:54:34 +0000</pubDate>
      
      <guid>/post/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E8%A7%A3%E6%9E%90/</guid>
      <description>文件权限 ls命令可以用来查看Linux系统上的文件、目录和设备的权限。 输出结果的第一个字段就是描述文件和目录权限的编码。这个字段的第一个字符</description>
    </item>
    
    <item>
      <title>用户账户和组管理</title>
      <link>/post/%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7%E5%92%8C%E7%BB%84%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 07 Aug 2017 23:05:37 +0000</pubDate>
      
      <guid>/post/%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7%E5%92%8C%E7%BB%84%E7%AE%A1%E7%90%86/</guid>
      <description>Linux 的安全性 Linux安全系统的核心是用户账户。每个能进入Linux系统的用户都会被分配唯一的用户账 户。用户对系统中各种对象的访问权限取决于他</description>
    </item>
    
    <item>
      <title>定位系统环境变量</title>
      <link>/post/%E5%AE%9A%E4%BD%8D%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 07 Aug 2017 22:09:00 +0000</pubDate>
      
      <guid>/post/%E5%AE%9A%E4%BD%8D%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</guid>
      <description>启动shell 在你登入Linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。这些 文件叫作启动文件或环境文件。</description>
    </item>
    
    <item>
      <title>环境变量的使用</title>
      <link>/post/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 07 Aug 2017 18:27:36 +0000</pubDate>
      
      <guid>/post/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>什么是环境变量 bash shell用一个叫作环境变量(environment variable)的特性来存储有关shell会话和工作环境的信息(这也是</description>
    </item>
    
    <item>
      <title>Shell的內建命令</title>
      <link>/post/shell%E7%9A%84%E5%85%A7%E5%BB%BA%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 07 Aug 2017 17:23:40 +0000</pubDate>
      
      <guid>/post/shell%E7%9A%84%E5%85%A7%E5%BB%BA%E5%91%BD%E4%BB%A4/</guid>
      <description>外部命令 外部命令，有时候也被称为文件系统命令，是存在于bash shell之外的程序。它们并不是shell 程序的一部分。外部命令程序通常位于/</description>
    </item>
    
    <item>
      <title>Shell的父子关系</title>
      <link>/post/shell%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Mon, 07 Aug 2017 17:23:08 +0000</pubDate>
      
      <guid>/post/shell%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB/</guid>
      <description>创建子shell 在CLI提示符后输入/bin/bash命令或其他等效的bash命令时，会创建一个新的shell程序。 这个shell程序被称为</description>
    </item>
    
    <item>
      <title>磁盘空间命令</title>
      <link>/post/%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 07 Aug 2017 11:49:47 +0000</pubDate>
      
      <guid>/post/%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E5%91%BD%E4%BB%A4/</guid>
      <description>挂载存储媒体 mount命令 Linux上用来挂载媒体的命令叫作mount。默认情况下，mount命令会输出当前系统上挂载的设备列表. mount</description>
    </item>
    
    <item>
      <title>基本的Shell命令(一)</title>
      <link>/post/%E5%9F%BA%E6%9C%AC%E7%9A%84shell%E5%91%BD%E4%BB%A4%E4%B8%80/</link>
      <pubDate>Sun, 06 Aug 2017 22:25:51 +0000</pubDate>
      
      <guid>/post/%E5%9F%BA%E6%9C%AC%E7%9A%84shell%E5%91%BD%E4%BB%A4%E4%B8%80/</guid>
      <description>遍历目录 在Linux文件系统上，可以使用切换目录命令cd将shell会话切换到另一个目录。cd命令的格 式非常简单: cd destination cd命令可接受单个参数</description>
    </item>
    
    <item>
      <title>欧拉函数浅析</title>
      <link>/post/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90/</link>
      <pubDate>Wed, 02 Aug 2017 18:54:51 +0000</pubDate>
      
      <guid>/post/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90/</guid>
      <description>欧拉函数 欧拉函数用希腊字母φ表示,φ(N)表示N的欧拉函数. 对φ(N)的值,我们可以通俗地理解为小于N且与N互质的数的个数(包含1). 欧拉函</description>
    </item>
    
    <item>
      <title>GCD、扩展GCD和中国剩余定理</title>
      <link>/post/gcd%E6%89%A9%E5%B1%95gcd%E5%92%8C%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</link>
      <pubDate>Wed, 02 Aug 2017 18:54:00 +0000</pubDate>
      
      <guid>/post/gcd%E6%89%A9%E5%B1%95gcd%E5%92%8C%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</guid>
      <description>辗转相除法 辗转相除是求两个数的最大公约数的。 要证这个定理成立，只需要证明 gcd(a, b) = gcd(b, a % b) 就行了 证明：令a % b = r, 所以a = k * b + r, 所以r = a -</description>
    </item>
    
    <item>
      <title>矩阵快速幂解析</title>
      <link>/post/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 02 Aug 2017 12:48:59 +0000</pubDate>
      
      <guid>/post/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E8%A7%A3%E6%9E%90/</guid>
      <description>快速幂 题目:Implement pow(x, n). 解析：快速幂，此处需要判断边界值n，如果n为-2^31，那么需要另外设置一个long long变量存储其相反</description>
    </item>
    
    <item>
      <title>最小生成树算法总结</title>
      <link>/post/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 01 Aug 2017 23:07:09 +0000</pubDate>
      
      <guid>/post/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
      <description>Prim 基本思想 Prim算法根据点进行求解. 对于图G而言，V是所有顶点的集合；现在，设置两个新的集合U和T，其中U用于存放G的最小生成树中的顶点，</description>
    </item>
    
    <item>
      <title>基本进程状态和PV操作浅析</title>
      <link>/post/%E5%9F%BA%E6%9C%AC%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%92%8Cpv%E6%93%8D%E4%BD%9C%E6%B5%85%E6%9E%90/</link>
      <pubDate>Tue, 01 Aug 2017 17:18:05 +0000</pubDate>
      
      <guid>/post/%E5%9F%BA%E6%9C%AC%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%92%8Cpv%E6%93%8D%E4%BD%9C%E6%B5%85%E6%9E%90/</guid>
      <description>进程的三种基本状态 （1）就绪状态：进程已获得除CPU外的所有必要资源，只等待CPU时的状态。一个系统会将多个处于就绪状态的进程排成一个就绪队</description>
    </item>
    
    <item>
      <title>multimap中查找方法</title>
      <link>/post/multimap%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 01 Aug 2017 00:09:24 +0000</pubDate>
      
      <guid>/post/multimap%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95/</guid>
      <description>在multimap中，同一个键关联的元素必然相邻存放。基于这个事实，就可以将某个键对应的值一一输出。 使用find和count函数。count</description>
    </item>
    
    <item>
      <title>最短路径算法总结</title>
      <link>/post/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 31 Jul 2017 14:45:52 +0000</pubDate>
      
      <guid>/post/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
      <description>BFS 4. 举例 题目: 用一个整型矩阵matrix表示一个网络，1代表有路，0代表无路，每一个位置只要不越界，都有上下左右4个方向，求从最左上角到最右</description>
    </item>
    
    <item>
      <title>为什么把无穷大INF设置成0x3f3f3f3f?</title>
      <link>/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%8A%E6%97%A0%E7%A9%B7%E5%A4%A7inf%E8%AE%BE%E7%BD%AE%E6%88%900x3f3f3f3f/</link>
      <pubDate>Mon, 31 Jul 2017 13:14:13 +0000</pubDate>
      
      <guid>/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%8A%E6%97%A0%E7%A9%B7%E5%A4%A7inf%E8%AE%BE%E7%BD%AE%E6%88%900x3f3f3f3f/</guid>
      <description>如果问题中各数据的范围明确，那么无穷大的设定不是问题，在不明确的情况下，很多程序员都取0x7fffffff作为无穷大，因为这是32-bit i</description>
    </item>
    
    <item>
      <title>ICMP协议详解</title>
      <link>/post/icmp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 30 Jul 2017 17:29:26 +0000</pubDate>
      
      <guid>/post/icmp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</guid>
      <description>为了更有效地转发ip数据报和提高交付成功的机会，在网际层使用了网际控制报文协 议 ICMP (Internet Control Message Protocol) 。ICMP 允许主机或路由器报告差错情况和提供有关异常</description>
    </item>
    
    <item>
      <title>ARP协议详解</title>
      <link>/post/arp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 30 Jul 2017 15:45:45 +0000</pubDate>
      
      <guid>/post/arp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</guid>
      <description>IP地址与MAC地址 在学习IP地址时，很重要的一点就是要弄懂主机的IP地址与硬件地址的区别。 从层次的角度看，物理地址是数据链路层和物理层使用</description>
    </item>
    
    <item>
      <title>IP协议头详解</title>
      <link>/post/ip%E5%8D%8F%E8%AE%AE%E5%A4%B4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 30 Jul 2017 11:26:06 +0000</pubDate>
      
      <guid>/post/ip%E5%8D%8F%E8%AE%AE%E5%A4%B4%E8%AF%A6%E8%A7%A3/</guid>
      <description>IPv4 (1) 版本:占4位，指IP协议的版本。通信双方使用的IP协议的版本必须一致。目 前广泛使用的IP协议版本号为4 (即IPv4)。 (2) 首部长度:占4位</description>
    </item>
    
    <item>
      <title>UDP协议详解</title>
      <link>/post/udp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 29 Jul 2017 17:41:42 +0000</pubDate>
      
      <guid>/post/udp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</guid>
      <description>概述 用户数据报协议UDP只在IP的数据报服务之上增加了很少一点的功能，这就是复用和 分用的功能以及差错检测的功能。UDP的主要特点是： UDP是</description>
    </item>
    
    <item>
      <title>IP协议详解</title>
      <link>/post/ip%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 29 Jul 2017 17:28:42 +0000</pubDate>
      
      <guid>/post/ip%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</guid>
      <description>IP协议概述 网际协议IP是TCP/IP体系中两个最主要的协议之一[STEV94][COME06][FORO10],也 是最重要的因特网标准协议</description>
    </item>
    
    <item>
      <title>algorithm库操作总结</title>
      <link>/post/algorithm%E5%BA%93%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 27 Jul 2017 21:50:23 +0000</pubDate>
      
      <guid>/post/algorithm%E5%BA%93%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>非修改序列操作 for_each 1 2 template &amp;lt;class InputIterator, class Function&amp;gt; Function for_each (InputIterator first, InputIterator last, Function fn); 1 2 3 4 5 6 7 8 9 template&amp;lt;class InputIterator, class Function&amp;gt; Function for_each(InputIterator first, InputIterator last, Function fn) { while (first!=last) { fn (*first); ++first; } return fn; // or, since C++11: return move(fn); } all_of 1 2 3 4 5 6 7 8 9</description>
    </item>
    
    <item>
      <title>rand()和srand()函数总结</title>
      <link>/post/rand-%E5%92%8Csrand-%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 27 Jul 2017 21:18:00 +0000</pubDate>
      
      <guid>/post/rand-%E5%92%8Csrand-%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</guid>
      <description>转载:http://www.cnblogs.com/guihailiuli/p/4154416.html 要计算机产生一个随机数不像扔色子一样</description>
    </item>
    
    <item>
      <title>静态链接和动态链接区别浅析</title>
      <link>/post/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%8C%BA%E5%88%AB%E6%B5%85%E6%9E%90/</link>
      <pubDate>Thu, 27 Jul 2017 20:39:57 +0000</pubDate>
      
      <guid>/post/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%8C%BA%E5%88%AB%E6%B5%85%E6%9E%90/</guid>
      <description>一、静态库与动态库 通常情况下，对函数库的链接是放在编译时期（compile time）完成的。所有相关的对象文件（object file）与牵涉</description>
    </item>
    
    <item>
      <title>cctype库操作总结</title>
      <link>/post/cctype%E5%BA%93%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 27 Jul 2017 20:39:29 +0000</pubDate>
      
      <guid>/post/cctype%E5%BA%93%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>常用函数:</description>
    </item>
    
    <item>
      <title> 如何判断map容器的key是否存在 </title>
      <link>/post/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADmap%E5%AE%B9%E5%99%A8%E7%9A%84key%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/</link>
      <pubDate>Thu, 27 Jul 2017 16:01:24 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADmap%E5%AE%B9%E5%99%A8%E7%9A%84key%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/</guid>
      <description>首先，不推荐使用[]来判断key是否存在，因为使用操作符[]会向map容器里插入一个元素。 map的operator[]重载大致是这样一个内容</description>
    </item>
    
    <item>
      <title>#pragma 预处理指令浅析</title>
      <link>/post/pragma-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%E6%B5%85%E6%9E%90/</link>
      <pubDate>Tue, 25 Jul 2017 12:31:48 +0000</pubDate>
      
      <guid>/post/pragma-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%E6%B5%85%E6%9E%90/</guid>
      <description>功能 在所有的预处理指令中，#pragma 指令可能是最复杂的了，它的作用是设定编译器的状态或者是指示编译器完成一些特定的动作。 #pragma指</description>
    </item>
    
    <item>
      <title>C语言程序可以没有main函数</title>
      <link>/post/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E5%8F%AF%E4%BB%A5%E6%B2%A1%E6%9C%89main%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 25 Jul 2017 12:19:56 +0000</pubDate>
      
      <guid>/post/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E5%8F%AF%E4%BB%A5%E6%B2%A1%E6%9C%89main%E5%87%BD%E6%95%B0/</guid>
      <description>几乎所有程序员的第一堂课都是学习helloworld程序，下面我们先来重温一下经典的C语言helloworld。 1 2 3 4 5 6 7 /* hello.c */ #include &amp;lt;stdio.h&amp;gt; int main()</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 中头文件（.h）和源文件（.cc）</title>
      <link>/post/c-%E4%B8%AD%E5%A4%B4%E6%96%87%E4%BB%B6-h%E5%92%8C%E6%BA%90%E6%96%87%E4%BB%B6-cc/</link>
      <pubDate>Tue, 25 Jul 2017 10:51:30 +0000</pubDate>
      
      <guid>/post/c-%E4%B8%AD%E5%A4%B4%E6%96%87%E4%BB%B6-h%E5%92%8C%E6%BA%90%E6%96%87%E4%BB%B6-cc/</guid>
      <description>头文件的作用 头文件的作用主要表现为以下两个方面： 通过头文件来调用库功能。出于对源代码保密的考虑，源代码不便（或不准）向用户公布，只要向用户提</description>
    </item>
    
    <item>
      <title>math库数值处理函数总结</title>
      <link>/post/%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 23 Jul 2017 19:57:02 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</guid>
      <description>向上取整ceil() double ceil (double x); float ceil (float x); long double ceil (long double x); double ceil (T x); // additional overloads for integral types 向上取整,返回大于等于x的值. 示例: 1 2 3 4 5 6 7 8 9 10 11 #include &amp;lt;stdio.h&amp;gt; /* printf */#include &amp;lt;math.h&amp;gt; /*</description>
    </item>
    
    <item>
      <title>scanf()和sscanf()详解</title>
      <link>/post/scanf%E5%92%8Csscanf%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 23 Jul 2017 17:08:51 +0000</pubDate>
      
      <guid>/post/scanf%E5%92%8Csscanf%E8%AF%A6%E8%A7%A3/</guid>
      <description>函数原型 int sscanf( string str, string fmt, mixed var1, mixed var2 ... ); int scanf( const char *format [,argument]... ); 返回值 一般使用scanf函数时都是为某个变量赋值，不考虑它的返回值。但是任何函数都是需要返回的</description>
    </item>
    
    <item>
      <title>map排序相关讨论</title>
      <link>/post/map%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E8%AE%A8%E8%AE%BA/</link>
      <pubDate>Fri, 21 Jul 2017 15:22:43 +0000</pubDate>
      
      <guid>/post/map%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E8%AE%A8%E8%AE%BA/</guid>
      <description>map是用来存放&amp;lt;key, value&amp;gt;键值对的数据结构，可以很方便快速的根据key查到相应的value。假如存储学生和其成绩（假</description>
    </item>
    
    <item>
      <title>约瑟夫环</title>
      <link>/post/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</link>
      <pubDate>Thu, 20 Jul 2017 21:33:51 +0000</pubDate>
      
      <guid>/post/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</guid>
      <description>题目: n 个数字（0,1,…,n-1）形成一个圆圈，从数字 k 开始，每次从这个圆圈中删除第 m 个数字（第一个 为当前数字本身，第二个为当前数字的下一</description>
    </item>
    
    <item>
      <title>使用互斥锁、条件变量实现读写锁 </title>
      <link>/post/%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E9%94%81/</link>
      <pubDate>Thu, 20 Jul 2017 17:16:29 +0000</pubDate>
      
      <guid>/post/%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E9%94%81/</guid>
      <description>要实现读写锁，首先要知道读写锁的特性，除了“读者可并发，写者要排它”之外还要考虑避免写者饥饿的问题。综合考虑后可以讲读写锁的实现总结为一下四</description>
    </item>
    
    <item>
      <title>哈弗曼树详解</title>
      <link>/post/%E5%93%88%E5%BC%97%E6%9B%BC%E6%A0%91%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 20 Jul 2017 13:51:59 +0000</pubDate>
      
      <guid>/post/%E5%93%88%E5%BC%97%E6%9B%BC%E6%A0%91%E8%AF%A6%E8%A7%A3/</guid>
      <description>一、哈夫曼树的定义 什么是哈夫曼树？ 让我们先举一个例子。 判定树： 在很多问题的处理过程中，需要进行大量的条件判断，这些判断结构的设计直接影响着程</description>
    </item>
    
    <item>
      <title>main函数执行前、后执行的代码</title>
      <link>/post/main%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%89%8D%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Wed, 19 Jul 2017 15:00:12 +0000</pubDate>
      
      <guid>/post/main%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%89%8D%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81/</guid>
      <description>main函数前 main函数执行之前，主要就是初始化系统相关资源： 1.设置栈指针 2.初始化static静态和global全局变量，即data段</description>
    </item>
    
    <item>
      <title>Singleton的相关实现</title>
      <link>/post/singleton%E7%9A%84%E7%9B%B8%E5%85%B3%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 19 Jul 2017 11:46:01 +0000</pubDate>
      
      <guid>/post/singleton%E7%9A%84%E7%9B%B8%E5%85%B3%E5%AE%9E%E7%8E%B0/</guid>
      <description>单线程 在单线程下，下面这个是常见的写法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template&amp;lt;typename T&amp;gt; class Singleton { public: static T&amp;amp; getInstance() { if (!value_) { value_ = new T(); } return *value_; } private: Singleton(); ~Singleton(); static T* value_;</description>
    </item>
    
    <item>
      <title>string与其他类型间的转换</title>
      <link>/post/string%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Mon, 17 Jul 2017 20:38:39 +0000</pubDate>
      
      <guid>/post/string%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</guid>
      <description>string与char数组的转换 string转char数组 使用c_str函数 string a=&amp;quot;hello world&amp;quot;; const char* ch=a.c_str(); 注意: c_str函数的返回值是const char*的</description>
    </item>
    
    <item>
      <title>unordered_map操作总结</title>
      <link>/post/unordered-map%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 17 Jul 2017 15:07:03 +0000</pubDate>
      
      <guid>/post/unordered-map%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>构造函数 empty (1) explicit unordered_map ( size_type n = /* see below */, const hasher&amp;amp; hf = hasher(), const key_equal&amp;amp; eql = key_equal(), const allocator_type&amp;amp; alloc = allocator_type() ); explicit unordered_map ( const allocator_type&amp;amp; alloc ); range (2) template &amp;lt;class InputIterator&amp;gt; unordered_map ( InputIterator first, InputIterator last, size_type n = /* see below */, const hasher&amp;amp; hf = hasher(), const key_equal&amp;amp; eql = key_equal(), const allocator_type&amp;amp; alloc</description>
    </item>
    
    <item>
      <title>unordered_set操作总结</title>
      <link>/post/unordered-set%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 17 Jul 2017 15:06:46 +0000</pubDate>
      
      <guid>/post/unordered-set%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>#构造函数 empty (1) explicit unordered_set ( size_type n = /* see below */, const hasher&amp;amp; hf = hasher(), const key_equal&amp;amp; eql = key_equal(), const allocator_type&amp;amp; alloc = allocator_type() ); explicit unordered_set ( const allocator_type&amp;amp; alloc ); range (2) template &amp;lt;class InputIterator&amp;gt; unordered_set ( InputIterator first, InputIterator last, size_type n = /* see below */, const hasher&amp;amp; hf = hasher(), const key_equal&amp;amp; eql = key_equal(), const allocator_type&amp;amp;</description>
    </item>
    
    <item>
      <title>set和multiset操作总结</title>
      <link>/post/set%E5%92%8Cmultiset%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 16 Jul 2017 21:22:10 +0000</pubDate>
      
      <guid>/post/set%E5%92%8Cmultiset%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>set 构造函数 empty (1) explicit set (const key_compare&amp;amp; comp = key_compare(), const allocator_type&amp;amp; alloc = allocator_type()); explicit set (const allocator_type&amp;amp; alloc); range (2) template &amp;lt;class InputIterator&amp;gt; set (InputIterator first, InputIterator last, const key_compare&amp;amp; comp = key_compare(), const allocator_type&amp;amp; = allocator_type()); copy (3) set (const set&amp;amp; x); set (const set&amp;amp; x, const allocator_type&amp;amp; alloc); move (4) set (set&amp;amp;&amp;amp; x); set (set&amp;amp;&amp;amp; x, const allocator_type&amp;amp; alloc); initializer list (5)</description>
    </item>
    
    <item>
      <title>map和multimap操作总结</title>
      <link>/post/map%E5%92%8Cmultimap%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 16 Jul 2017 21:21:42 +0000</pubDate>
      
      <guid>/post/map%E5%92%8Cmultimap%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>map 构造函数 empty (1) explicit map (const key_compare&amp;amp; comp = key_compare(), const allocator_type&amp;amp; alloc = allocator_type()); explicit map (const allocator_type&amp;amp; alloc); range (2) template &amp;lt;class InputIterator&amp;gt; map (InputIterator first, InputIterator last, const key_compare&amp;amp; comp = key_compare(), const allocator_type&amp;amp; = allocator_type()); copy (3) map (const map&amp;amp; x); map (const map&amp;amp; x, const allocator_type&amp;amp; alloc); move (4) map (map&amp;amp;&amp;amp; x); map (map&amp;amp;&amp;amp; x, const allocator_type&amp;amp; alloc); initializer list (5)</description>
    </item>
    
    <item>
      <title>stack,queue,priority_queue操作总结</title>
      <link>/post/stack-queue-priority-queue%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 16 Jul 2017 16:25:55 +0000</pubDate>
      
      <guid>/post/stack-queue-priority-queue%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>stack queue priority_queue priority_queue 对于基本类型的使用方法相对简单。他的模板声明带有三个参数: priority_queue&amp;lt;Type, Container, Functional&amp;gt; 其中Type 为数据类型， Container 为保存数据的容器，Functional 为元</description>
    </item>
    
    <item>
      <title>forward_list操作总结</title>
      <link>/post/forward-list%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 16 Jul 2017 16:25:06 +0000</pubDate>
      
      <guid>/post/forward-list%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>构造函数 default (1) explicit forward_list (const allocator_type&amp;amp; alloc = allocator_type()); fill (2) explicit forward_list (size_type n); explicit forward_list (size_type n, const value_type&amp;amp; val, const allocator_type&amp;amp; alloc = allocator_type()); range (3) template &amp;lt;class InputIterator&amp;gt; forward_list (InputIterator first, InputIterator last, const allocator_type&amp;amp; alloc = allocator_type()); copy (4) forward_list (const forward_list&amp;amp; fwdlst); forward_list (const forward_list&amp;amp; fwdlst, const allocator_type&amp;amp; alloc); move (5) forward_list (forward_list&amp;amp;&amp;amp; fwdlst); forward_list (forward_list&amp;amp;&amp;amp; fwdlst, const allocator_type&amp;amp; alloc);</description>
    </item>
    
    <item>
      <title>deque操作总结</title>
      <link>/post/deque%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 15 Jul 2017 17:01:53 +0000</pubDate>
      
      <guid>/post/deque%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>deque操作和vector操作基本相同 构造函数 default (1) explicit deque (const allocator_type&amp;amp; alloc = allocator_type()); fill (2) explicit deque (size_type n); deque (size_type n, const value_type&amp;amp; val, const allocator_type&amp;amp; alloc = allocator_type()); range (3) template &amp;lt;class InputIterator&amp;gt; deque (InputIterator first, InputIterator last, const allocator_type&amp;amp; alloc = allocator_type()); copy (4) deque (const deque&amp;amp;</description>
    </item>
    
    <item>
      <title>list操作总结</title>
      <link>/post/list%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 15 Jul 2017 11:56:15 +0000</pubDate>
      
      <guid>/post/list%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>构造函数 default (1) explicit list (const allocator_type&amp;amp; alloc = allocator_type()); fill (2) explicit list (size_type n); list (size_type n, const value_type&amp;amp; val, const allocator_type&amp;amp; alloc = allocator_type()); range (3) template &amp;lt;class InputIterator&amp;gt; list (InputIterator first, InputIterator last, const allocator_type&amp;amp; alloc = allocator_type()); copy (4) list (const list&amp;amp; x); list (const list&amp;amp; x, const allocator_type&amp;amp; alloc); move (5) list (list&amp;amp;&amp;amp; x); list (list&amp;amp;&amp;amp; x, const allocator_type&amp;amp; alloc); initializer</description>
    </item>
    
    <item>
      <title>vector操作总结</title>
      <link>/post/vector%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 15 Jul 2017 11:56:07 +0000</pubDate>
      
      <guid>/post/vector%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>vector容器的相关操作和string非常相似. 构造函数 default (1) explicit vector (const allocator_type&amp;amp; alloc = allocator_type()); fill (2) explicit vector (size_type n); vector (size_type n, const value_type&amp;amp; val, const allocator_type&amp;amp; alloc = allocator_type()); range (3) template &amp;lt;class InputIterator&amp;gt; vector (InputIterator first, InputIterator last, const allocator_type&amp;amp; alloc = allocator_type());</description>
    </item>
    
    <item>
      <title>reverse_iterator的用法</title>
      <link>/post/reverse_iterator%E7%9A%84%E7%94%A8%E6%B3%95/</link>
      <pubDate>Fri, 14 Jul 2017 14:50:51 +0000</pubDate>
      
      <guid>/post/reverse_iterator%E7%9A%84%E7%94%A8%E6%B3%95/</guid>
      <description>基本区别 调用reverse_iterator的base()成员函数可以得到“与之相对应的”iterator，但是这句话实际上并没有说明真正的</description>
    </item>
    
    <item>
      <title>流对象为什么可以作为条件表达式？</title>
      <link>/post/cin-out%E6%B5%81%E5%AF%B9%E8%B1%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Thu, 13 Jul 2017 16:33:26 +0000</pubDate>
      
      <guid>/post/cin-out%E6%B5%81%E5%AF%B9%E8%B1%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>转载： http://blog.csdn.net/bladelyer/article/details/8505912. http://blog.csdn.net/andyelvis/article/details/4529592 原理解释 相信很多人都遇到过这样的例子： 1 2 3 string str; while( cin &amp;gt;&amp;gt; str ) cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; flush; 似乎，大多数初学者都不明白【cin &amp;raquo; str】怎么可以作为whi</description>
    </item>
    
    <item>
      <title>KMP算法详解</title>
      <link>/post/kmp%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 28 Jun 2017 21:17:06 +0000</pubDate>
      
      <guid>/post/kmp%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</guid>
      <description>算法目标 kmp算法完成的任务是：给定两个字符串O和f，长度分别为n和m，判断f是否在O中出现，如果出现则返回出现的位置。常规方法是遍历a的每</description>
    </item>
    
    <item>
      <title>八大经典排序算法</title>
      <link>/post/%E5%85%AB%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 25 Jun 2017 22:45:48 +0000</pubDate>
      
      <guid>/post/%E5%85%AB%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      <description>八大排序算法总结 排序算法稳定性 假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中</description>
    </item>
    
    <item>
      <title>二叉树的类型</title>
      <link>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sun, 25 Jun 2017 22:45:38 +0000</pubDate>
      
      <guid>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%B1%BB%E5%9E%8B/</guid>
      <description>二叉树的定义 二叉树是每个节点最多有两个子树的树结构。它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。 二</description>
    </item>
    
    <item>
      <title>位图排序</title>
      <link>/post/%E4%BD%8D%E5%9B%BE%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 25 Jun 2017 22:45:30 +0000</pubDate>
      
      <guid>/post/%E4%BD%8D%E5%9B%BE%E6%8E%92%E5%BA%8F/</guid>
      <description>计数排序与位图排序 计数排序(Counting sort)是一种稳定的线性时间排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组</description>
    </item>
    
    <item>
      <title>求两个数组的交集</title>
      <link>/post/%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</link>
      <pubDate>Sun, 25 Jun 2017 22:45:21 +0000</pubDate>
      
      <guid>/post/%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</guid>
      <description>有序数组 以下两种方法都可以适用于数组中数据重复的情况。 长度相似 采用二路归并法来进行求解交集 对于数组A,B分别以i,j从头遍历数组。如果当前位</description>
    </item>
    
    <item>
      <title>根据数据范围选择解题方法</title>
      <link>/post/%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E9%80%89%E6%8B%A9%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 25 Jun 2017 22:45:00 +0000</pubDate>
      
      <guid>/post/%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E9%80%89%E6%8B%A9%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95/</guid>
      <description>N&amp;lt;=10 • O(N!) • 全排列枚举 N&amp;lt;=15 • O(2^N) • 01规划 • 状压dp N&amp;lt;=50 • O(N^4) • 枚举一个矩形(x,y),(x+w,y+h) N&amp;lt;=100 • O(N^3) • Floyd求任意两点最短路 • 高斯消元 N&amp;lt;=1000</description>
    </item>
    
    <item>
      <title>AVL树详解</title>
      <link>/post/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 25 Jun 2017 22:44:51 +0000</pubDate>
      
      <guid>/post/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/</guid>
      <description>转载： http://www.cnblogs.com/QG-whz/p/5167238.html. http://blog.csdn.net/sp_programmer/article/details/41812787. 定义 AVL树又称为高度平衡的二叉搜索树。它能保持二叉树的高度平衡，尽量降低二叉树的高度，减少树的平均搜索长度。 性质 AVL树本质上还</description>
    </item>
    
    <item>
      <title>红黑树详解</title>
      <link>/post/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 25 Jun 2017 22:44:42 +0000</pubDate>
      
      <guid>/post/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3/</guid>
      <description>转载： http://www.cnblogs.com/skywang12345/p/3245399.html http://blog.csdn.net/v_july_v/article/details/6105630 简介 红黑树并不追求“完全平衡”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。 红黑树能够以O(lgn) 的时间复</description>
    </item>
    
    <item>
      <title>海量数据处理总结</title>
      <link>/post/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 25 Jun 2017 22:44:31 +0000</pubDate>
      
      <guid>/post/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/</guid>
      <description>转载：http://blog.csdn.net/v_july_v/article/details/7382693 前言 一般而言，标题含有“秒杀</description>
    </item>
    
    <item>
      <title>从B树、B&#43;树、B*树谈到R树</title>
      <link>/post/%E4%BB%8Eb%E6%A0%91b-%E6%A0%91b-%E6%A0%91%E8%B0%88%E5%88%B0r%E6%A0%91/</link>
      <pubDate>Sun, 25 Jun 2017 22:44:23 +0000</pubDate>
      
      <guid>/post/%E4%BB%8Eb%E6%A0%91b-%E6%A0%91b-%E6%A0%91%E8%B0%88%E5%88%B0r%E6%A0%91/</guid>
      <description>前言 动态查找树主要有：二叉查找树（Binary Search Tree），平衡二叉查找树（Balanced Binary Search Tree），红黑树(Red-Black Tree )，</description>
    </item>
    
    <item>
      <title>认识布隆过滤器</title>
      <link>/post/%E8%AE%A4%E8%AF%86%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</link>
      <pubDate>Sun, 25 Jun 2017 22:44:09 +0000</pubDate>
      
      <guid>/post/%E8%AE%A4%E8%AF%86%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</guid>
      <description>转载：http://blog.csdn.net/v_july_v/article/details/6685894 什么是Bloom Filter Bloom Filt</description>
    </item>
    
    <item>
      <title>深入理解HTTP协议</title>
      <link>/post/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3http%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Sun, 25 Jun 2017 20:08:31 +0000</pubDate>
      
      <guid>/post/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3http%E5%8D%8F%E8%AE%AE/</guid>
      <description>介绍 HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。今天普遍使用的一个版本——HTTP 1.1。 HTTP协议（HyperTe</description>
    </item>
    
    <item>
      <title>TCP连接管理浅析</title>
      <link>/post/tcp%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E6%B5%85%E6%9E%90/</link>
      <pubDate>Sun, 25 Jun 2017 20:08:22 +0000</pubDate>
      
      <guid>/post/tcp%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E6%B5%85%E6%9E%90/</guid>
      <description>相对于SOCKET开发者,TCP创建过程和折除过程是由TCP/IP协议栈自动创建的.因此开发者并不需要控制这个过程.但是对于理解TCP底层运</description>
    </item>
    
    <item>
      <title>TCP连接中的RST</title>
      <link>/post/tcp%E8%BF%9E%E6%8E%A5%E4%B8%AD%E7%9A%84rst/</link>
      <pubDate>Sun, 25 Jun 2017 20:08:15 +0000</pubDate>
      
      <guid>/post/tcp%E8%BF%9E%E6%8E%A5%E4%B8%AD%E7%9A%84rst/</guid>
      <description>RST简介 RST标示复位、用来异常的关闭连接。 发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓冲区中的包，发送RST。 而接收端</description>
    </item>
    
    <item>
      <title>网络常用协议</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%B8%B8%E7%94%A8%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Sun, 25 Jun 2017 20:08:06 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%B8%B8%E7%94%A8%E5%8D%8F%E8%AE%AE/</guid>
      <description>应用层常用协议 DNS:域名系统（TCP和UDP） DNS同时占用UDP和TCP端口53 DNS：域名系统。DNS是因特网使用的命名系统，用来把便</description>
    </item>
    
    <item>
      <title>DNS原理总结及其解析过程详解</title>
      <link>/post/dns%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93%E5%8F%8A%E5%85%B6%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 25 Jun 2017 20:07:58 +0000</pubDate>
      
      <guid>/post/dns%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93%E5%8F%8A%E5%85%B6%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</guid>
      <description>域名系统概述 域名系统DNS(Domain Name System)是因特网使用的命名系统，用来把便于人们使用的机器名字转换成为IP地址。域名系统其实就</description>
    </item>
    
    <item>
      <title>TCP差错控制浅析</title>
      <link>/post/tcp%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%E6%B5%85%E6%9E%90/</link>
      <pubDate>Sun, 25 Jun 2017 20:07:49 +0000</pubDate>
      
      <guid>/post/tcp%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%E6%B5%85%E6%9E%90/</guid>
      <description>差错控制 TCP使用差错控制来提供可靠性。差错控制包括以下的一些机制： 检测和重传受到损伤的报文段、 重传丢失的报文段、 丢弃重传的报文段并重传该报</description>
    </item>
    
    <item>
      <title>TCP流量控制浅析</title>
      <link>/post/tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%B5%85%E6%9E%90/</link>
      <pubDate>Sun, 25 Jun 2017 20:07:40 +0000</pubDate>
      
      <guid>/post/tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%B5%85%E6%9E%90/</guid>
      <description>MTU与MSS与SMSS MTU：maximum transmission unit，最大传输单元，由硬件规定，如以太网的MTU为1500字节。 MSS：maximum segment</description>
    </item>
    
    <item>
      <title>TCP拥塞控制浅析</title>
      <link>/post/tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%B5%85%E6%9E%90/</link>
      <pubDate>Sun, 25 Jun 2017 20:07:31 +0000</pubDate>
      
      <guid>/post/tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%B5%85%E6%9E%90/</guid>
      <description>拥塞的发生与不可避免 拥塞发生的主要原因在于网络能够提供的资源不足以满足用户的需求，这些资源包括缓存空间、链路带宽容量和中间节点的处理能力。由</description>
    </item>
    
    <item>
      <title>TCP中的四大定时器</title>
      <link>/post/tcp%E4%B8%AD%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%AE%9A%E6%97%B6%E5%99%A8/</link>
      <pubDate>Sun, 25 Jun 2017 20:02:48 +0000</pubDate>
      
      <guid>/post/tcp%E4%B8%AD%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%AE%9A%E6%97%B6%E5%99%A8/</guid>
      <description>转载：http://blog.csdn.net/ns_code/article/details/32343979 前言 对于每个TCP连接，TC</description>
    </item>
    
    <item>
      <title>当你输入一个网址的时候，实际会发生什么?</title>
      <link>/post/%E5%BD%93%E4%BD%A0%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E6%97%B6%E5%80%99%E5%AE%9E%E9%99%85%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/</link>
      <pubDate>Sun, 25 Jun 2017 20:02:36 +0000</pubDate>
      
      <guid>/post/%E5%BD%93%E4%BD%A0%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E6%97%B6%E5%80%99%E5%AE%9E%E9%99%85%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/</guid>
      <description>打开网页的原理 作为一个软件开发者，你一定会对网络应用如何工作有一个完整的层次化的认知，同样这里也包括这些应用所用到的技术：像浏览器，HTTP</description>
    </item>
    
    <item>
      <title>CDN的实现原理</title>
      <link>/post/cdn%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sun, 25 Jun 2017 20:02:18 +0000</pubDate>
      
      <guid>/post/cdn%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>CDN的全称Content Delivery Network，(缩写：CDN)即内容分发网络。 CDN是一个经策略性部署的整体系统，从技术上全面解决由于网络带宽</description>
    </item>
    
    <item>
      <title>TCP粘包问题</title>
      <link>/post/tcp%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 25 Jun 2017 20:02:04 +0000</pubDate>
      
      <guid>/post/tcp%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/</guid>
      <description>粘包原因 TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都</description>
    </item>
    
    <item>
      <title>TCP协议头详解</title>
      <link>/post/tcp%E5%8D%8F%E8%AE%AE%E5%A4%B4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 25 Jun 2017 20:01:54 +0000</pubDate>
      
      <guid>/post/tcp%E5%8D%8F%E8%AE%AE%E5%A4%B4%E8%AF%A6%E8%A7%A3/</guid>
      <description>TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。一个TCP报文段分为 首部和数据两部分，而TCP的全部功能都体现在它首部中各字段的</description>
    </item>
    
    <item>
      <title>网络地址转换NAT原理及应用</title>
      <link>/post/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2nat%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/</link>
      <pubDate>Sun, 25 Jun 2017 20:01:42 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2nat%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/</guid>
      <description>名词解释 公有IP地址：也叫全局地址，是指合法的IP地址，它是由NIC（网络信息中心）或者ISP(网络服务提供商)分配的地址，对外代表一个或多</description>
    </item>
    
    <item>
      <title>DDoS攻击原理</title>
      <link>/post/ddos%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sun, 25 Jun 2017 20:01:31 +0000</pubDate>
      
      <guid>/post/ddos%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86/</guid>
      <description>转载：http://www.cnblogs.com/2myroad/articles/3881042.html DDoS攻击基础 DDoS（Di</description>
    </item>
    
    <item>
      <title>常见性能优化思路</title>
      <link>/post/%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Sun, 25 Jun 2017 19:39:19 +0000</pubDate>
      
      <guid>/post/%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/</guid>
      <description>性能 性能优化有三个层次： 系统层次 算法层次 代码层次 系统层次关注系统的控制流程和数据流程，优化主要考虑如何减少消息传递的个数；如何使系统的负载更</description>
    </item>
    
    <item>
      <title>软件质量特性</title>
      <link>/post/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%89%B9%E6%80%A7/</link>
      <pubDate>Sun, 25 Jun 2017 19:39:10 +0000</pubDate>
      
      <guid>/post/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%89%B9%E6%80%A7/</guid>
      <description>一、功能性：是指当软件在指定条件下使用，软件产品满足明确和隐含要求功能的能力。 适合性：是指软件产品与指定的任务和用户目标提供一组合适的功能的</description>
    </item>
    
    <item>
      <title>libevent源码剖析(十三)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%81%E4%B8%89/</link>
      <pubDate>Sun, 25 Jun 2017 17:02:30 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%81%E4%B8%89/</guid>
      <description>前面讲到了 libevent 实现多线程的方法，然而在多线程的环境中注册信号事件，还是有一些情况需要小心处理，那就是不能在多个 libevent 实例上注册信号事件。依然冠名追</description>
    </item>
    
    <item>
      <title>libevent源码剖析(十二)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%81%E4%BA%8C/</link>
      <pubDate>Sun, 25 Jun 2017 17:02:21 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%81%E4%BA%8C/</guid>
      <description>Libevent本身不是多线程安全的，在多核的时代，如何能充分利用CPU的能力呢，这一节来说说如何在多线程环境中使用libevent，跟源代</description>
    </item>
    
    <item>
      <title>libevent源码剖析(十一)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%81%E4%B8%80/</link>
      <pubDate>Sun, 25 Jun 2017 17:02:12 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%81%E4%B8%80/</guid>
      <description>为了支持定时器，Libevent必须和系统时间打交道，这一部分的内容也比较简单，主要涉及到时间的加减辅助函数、时间缓存、时间校正和定时器堆的</description>
    </item>
    
    <item>
      <title>libevent源码剖析(十)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%81/</link>
      <pubDate>Sun, 25 Jun 2017 17:02:01 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8D%81/</guid>
      <description>Libevent的核心是事件驱动、同步非阻塞，为了达到这一目标，必须采用系统提供的I/O多路复用技术，而这些在Windows、Linux、U</description>
    </item>
    
    <item>
      <title>libevent源码剖析(九)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B9%9D/</link>
      <pubDate>Sun, 25 Jun 2017 17:01:53 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B9%9D/</guid>
      <description>现在再来详细分析libevent中I/O事件和Timer事件的集成，与Signal相比，Timer事件的集成会直观和简单很多。Libeven</description>
    </item>
    
    <item>
      <title>libevent源码剖析(八)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%85%AB/</link>
      <pubDate>Sun, 25 Jun 2017 17:01:43 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%85%AB/</guid>
      <description>现在我们已经了解了libevent的基本框架：事件管理框架和事件主循环。上节提到了libevent中I/O事件和Signal以及Timer事</description>
    </item>
    
    <item>
      <title>libevent源码剖析(七)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%83/</link>
      <pubDate>Sun, 25 Jun 2017 17:01:35 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%83/</guid>
      <description>现在我们已经初步了解了libevent的Reactor组件——event_base和事件管理框架，接下来就是libevent事件处理的中心部</description>
    </item>
    
    <item>
      <title>libevent源码剖析(六)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%85%AD/</link>
      <pubDate>Sun, 25 Jun 2017 17:01:26 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%85%AD/</guid>
      <description>前面已经对libevent的事件处理框架和event结构体做了描述，现在是时候剖析libevent对事件的详细处理流程了，本节将分析libe</description>
    </item>
    
    <item>
      <title>libevent源码剖析(五</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%BA%94/</link>
      <pubDate>Sun, 25 Jun 2017 17:01:17 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%BA%94/</guid>
      <description>对事件处理流程有了高层的认识后，本节将详细介绍libevent的核心结构event，以及libevent对event的管理。 1 libeven</description>
    </item>
    
    <item>
      <title>libevent源码剖析(四)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%9B%9B/</link>
      <pubDate>Sun, 25 Jun 2017 17:01:08 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%9B%9B/</guid>
      <description>1 前言 详细分析源代码之前，如果能对其代码文件的基本结构有个大概的认识和分类，对于代码的分析将是大有裨益的。本节内容不多，我想并不是说它不重要</description>
    </item>
    
    <item>
      <title>libevent源码剖析(三)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%89/</link>
      <pubDate>Sun, 25 Jun 2017 17:00:59 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%89/</guid>
      <description>1 前言 学习源代码该从哪里入手？我觉得从程序的基本使用场景和代码的整体处理流程入手是个不错的方法，至少从个人的经验上讲，用此方法分析libev</description>
    </item>
    
    <item>
      <title>libevent源码剖析(二)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%BA%8C/</link>
      <pubDate>Sun, 25 Jun 2017 17:00:51 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%BA%8C/</guid>
      <description>前面讲到，整个libevent本身就是一个Reactor，因此本节将专门对Reactor模式进行必要的介绍，并列出libevnet中的几个重</description>
    </item>
    
    <item>
      <title>libevent源码剖析(一)</title>
      <link>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%80/</link>
      <pubDate>Sun, 25 Jun 2017 17:00:40 +0000</pubDate>
      
      <guid>/post/libevent%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%80/</guid>
      <description>1 前言 Libevent是一个轻量级的开源高性能网络库，使用者众多，研究者更甚，相关文章也不少。写这一系列文章的用意在于，一则分享心得；二则对</description>
    </item>
    
    <item>
      <title>SQL 和 NoSQL 的区别</title>
      <link>/post/sql-%E5%92%8C-nosql-%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 25 Jun 2017 16:50:09 +0000</pubDate>
      
      <guid>/post/sql-%E5%92%8C-nosql-%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>转载：http://www.cnblogs.com/jeakeven/p/5402095.html 一、概念 SQL (Structured Query Language) 数据库，指关系型数据库。主</description>
    </item>
    
    <item>
      <title>大端模式和小端模式转化及网络字节序</title>
      <link>/post/%E5%A4%A7%E7%AB%AF%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F%E8%BD%AC%E5%8C%96%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F/</link>
      <pubDate>Sun, 25 Jun 2017 16:49:07 +0000</pubDate>
      
      <guid>/post/%E5%A4%A7%E7%AB%AF%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F%E8%BD%AC%E5%8C%96%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F/</guid>
      <description>转载：http://blog.csdn.net/szchtx/article/details/42834391 一、定义 大端模式（Big End</description>
    </item>
    
    <item>
      <title>可重入函数与不可重入函数的区别</title>
      <link>/post/%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0%E4%B8%8E%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 25 Jun 2017 16:48:59 +0000</pubDate>
      
      <guid>/post/%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0%E4%B8%8E%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>基本定义 可重入函数可以做这样的基本定义：重入意味着这个函数可以重复进入，可以被并行调用，可以被中断，它只使用自身栈上的数据变量，它不依赖于任</description>
    </item>
    
    <item>
      <title>浅谈数据库并发控制</title>
      <link>/post/%E6%B5%85%E8%B0%88%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Sun, 25 Jun 2017 16:48:51 +0000</pubDate>
      
      <guid>/post/%E6%B5%85%E8%B0%88%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</guid>
      <description>概述 如何控制并发是数据库领域中非常重要的问题之一，不过到今天为止事务并发的控制已经有了很多成熟的解决方案，而这些方案的原理就是这篇文章想要介</description>
    </item>
    
    <item>
      <title>面向对象三大基本特性,五大基本原则</title>
      <link>/post/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7-%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</link>
      <pubDate>Sun, 25 Jun 2017 16:38:30 +0000</pubDate>
      
      <guid>/post/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7-%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</guid>
      <description>转载：http://www.cnblogs.com/alex09/articles/4380115.html 三大基本特性 三大特性是：封装,继</description>
    </item>
    
    <item>
      <title>Linux文件系统浅析</title>
      <link>/post/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%B5%85%E6%9E%90/</link>
      <pubDate>Sun, 25 Jun 2017 14:24:05 +0000</pubDate>
      
      <guid>/post/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%B5%85%E6%9E%90/</guid>
      <description>分区和目录 Linux的文件结构是单个的树状结构.可以用tree进行展示。 在Ubuntu下安装tree（sudo apt-get install tree）,并可通过命令来</description>
    </item>
    
    <item>
      <title>设置用户ID位，保存设置用户ID，有效用户ID，实际用户ID</title>
      <link>/post/%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7id%E4%BD%8D%E4%BF%9D%E5%AD%98%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7id%E6%9C%89%E6%95%88%E7%94%A8%E6%88%B7id%E5%AE%9E%E9%99%85%E7%94%A8%E6%88%B7id/</link>
      <pubDate>Sun, 25 Jun 2017 14:23:56 +0000</pubDate>
      
      <guid>/post/%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7id%E4%BD%8D%E4%BF%9D%E5%AD%98%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7id%E6%9C%89%E6%95%88%E7%94%A8%E6%88%B7id%E5%AE%9E%E9%99%85%E7%94%A8%E6%88%B7id/</guid>
      <description>基本概念 实际用户ID（RUID） 用于标识一个系统中用户是谁，一般是在登录之后，就被唯一确定的，就是登陆的用户的uid 有效用户ID（EUID）</description>
    </item>
    
    <item>
      <title>带缓存IO和不带缓存IO</title>
      <link>/post/%E5%B8%A6%E7%BC%93%E5%AD%98io%E5%92%8C%E4%B8%8D%E5%B8%A6%E7%BC%93%E5%AD%98io/</link>
      <pubDate>Sun, 25 Jun 2017 14:23:32 +0000</pubDate>
      
      <guid>/post/%E5%B8%A6%E7%BC%93%E5%AD%98io%E5%92%8C%E4%B8%8D%E5%B8%A6%E7%BC%93%E5%AD%98io/</guid>
      <description>系统调用 系统调用，英文名system call，每个操作系统都在内核里有一些内建的函数库，这些函数可以用来完成一些系统系统调用把应用程序的请求</description>
    </item>
    
    <item>
      <title>netstat命令详解</title>
      <link>/post/netstat%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 25 Jun 2017 14:23:11 +0000</pubDate>
      
      <guid>/post/netstat%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid>
      <description>简介 Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。 输出信</description>
    </item>
    
    <item>
      <title>多线程之间共享哪些资源？</title>
      <link>/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E5%93%AA%E4%BA%9B%E8%B5%84%E6%BA%90/</link>
      <pubDate>Sun, 25 Jun 2017 14:22:33 +0000</pubDate>
      
      <guid>/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E5%93%AA%E4%BA%9B%E8%B5%84%E6%BA%90/</guid>
      <description>共享资源 正文段. 程序的代码 数据段。程序的全局内存。包括全局变量和静态变量: 全局变量它是与具体某一函数无关的，所以也与特定线程无关；因此也是共</description>
    </item>
    
    <item>
      <title>父子进程的联系</title>
      <link>/post/%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%81%94%E7%B3%BB/</link>
      <pubDate>Sun, 25 Jun 2017 14:22:23 +0000</pubDate>
      
      <guid>/post/%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%81%94%E7%B3%BB/</guid>
      <description>两者联系 子进程得到父进程的数据空间，堆和栈的副本，但是两者是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程</description>
    </item>
    
    <item>
      <title>linux多线程信号处理</title>
      <link>/post/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</link>
      <pubDate>Sun, 25 Jun 2017 14:22:16 +0000</pubDate>
      
      <guid>/post/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</guid>
      <description>linux 多线程信号总结(一) 在多线程环境下，产生的信号是传递给整个进程的，一般而言，所有线程都有机会收到这个信号，进程在收到信号的的线程上下文执行</description>
    </item>
    
    <item>
      <title>Linux系统内存管理</title>
      <link>/post/linux%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sun, 25 Jun 2017 14:22:07 +0000</pubDate>
      
      <guid>/post/linux%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>地址 相关概念 物理地址 内存是由若干个存储单元组成的，每个存储单元有一个编号，这种编号可唯一标识一个存储单元，称为内存地址（或物理地址）。我们可</description>
    </item>
    
    <item>
      <title>常见的端口扫描类型及原理</title>
      <link>/post/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sun, 25 Jun 2017 14:21:58 +0000</pubDate>
      
      <guid>/post/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%8E%9F%E7%90%86/</guid>
      <description>常见的扫描类型有以下几种： 秘密扫描是一种不被审计工具所检测的扫描技术。 它通常用于在通过普通的防火墙或路由器的筛选（filtering）时隐藏</description>
    </item>
    
    <item>
      <title>解析shutdown()和close()</title>
      <link>/post/%E8%A7%A3%E6%9E%90shutdown-%E5%92%8Cclose/</link>
      <pubDate>Sun, 25 Jun 2017 14:21:49 +0000</pubDate>
      
      <guid>/post/%E8%A7%A3%E6%9E%90shutdown-%E5%92%8Cclose/</guid>
      <description>TCP连接的关闭有两个方法close和shutdown，这篇文章将尽量精简的说明它们分别做了些什么。 为方便阅读，我们可以带着以下5个问题来阅</description>
    </item>
    
    <item>
      <title>SOCKETOPT-SO_LINGER选项</title>
      <link>/post/socketopt-so-linger%E9%80%89%E9%A1%B9/</link>
      <pubDate>Sun, 25 Jun 2017 14:21:41 +0000</pubDate>
      
      <guid>/post/socketopt-so-linger%E9%80%89%E9%A1%B9/</guid>
      <description>当调用closesocket关闭套接字时，SO_LINGER将决定系统如何处理残存在套接字发送队列中的数据。处理方式无非两种：丢弃或者将数据</description>
    </item>
    
    <item>
      <title>SO_REUESADDR和SO_REUSEPORT</title>
      <link>/post/socketopt-so-reuesaddr%E9%80%89%E9%A1%B9/</link>
      <pubDate>Sun, 25 Jun 2017 14:21:30 +0000</pubDate>
      
      <guid>/post/socketopt-so-reuesaddr%E9%80%89%E9%A1%B9/</guid>
      <description>简介 一般来说，一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。 这个套接字选项通知内核</description>
    </item>
    
    <item>
      <title>TCP长连接详解</title>
      <link>/post/tcp%E9%95%BF%E8%BF%9E%E6%8E%A5%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 25 Jun 2017 14:21:22 +0000</pubDate>
      
      <guid>/post/tcp%E9%95%BF%E8%BF%9E%E6%8E%A5%E8%AF%A6%E8%A7%A3/</guid>
      <description>TCP协议中有长连接和短连接之分。短连接在数据包发送完成后就会自己断开，长连接在发包完毕后，会在一定的时间内保持连接，即我们通常所说的Kee</description>
    </item>
    
    <item>
      <title>open/read/write和fopen/fread/fwrite的区别</title>
      <link>/post/open-read-write%E5%92%8Cfopen-fread-fwrite%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 25 Jun 2017 14:21:12 +0000</pubDate>
      
      <guid>/post/open-read-write%E5%92%8Cfopen-fread-fwrite%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>介绍 open：系统调用，返回的是文件描述符，即文件句柄，是文件在文件描述副表里的索引。 fopen：C语言库函数，返回的是一个指向文件结构的指</description>
    </item>
    
    <item>
      <title>文件指针和文件描述符的区别</title>
      <link>/post/%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 25 Jun 2017 14:21:03 +0000</pubDate>
      
      <guid>/post/%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>FILE文件指针 C语言中使用文件指针做为I/O的句柄。文件指针指向进程用户区中的一个被称为FILE结构的数据结构。 FILE结构包括缓冲区和文</description>
    </item>
    
    <item>
      <title>linux平台下防火墙iptables原理</title>
      <link>/post/linux%E5%B9%B3%E5%8F%B0%E4%B8%8B%E9%98%B2%E7%81%AB%E5%A2%99iptables%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sun, 25 Jun 2017 14:20:52 +0000</pubDate>
      
      <guid>/post/linux%E5%B9%B3%E5%8F%B0%E4%B8%8B%E9%98%B2%E7%81%AB%E5%A2%99iptables%E5%8E%9F%E7%90%86/</guid>
      <description>iptables简介 netfilter/iptables（简称为iptables）组成Linux平台下的包过滤防火墙，与大多数的Linux软</description>
    </item>
    
    <item>
      <title>多线程模型详解</title>
      <link>/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 25 Jun 2017 14:20:42 +0000</pubDate>
      
      <guid>/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</guid>
      <description>转载: https://github.com/linw7/Skill-Tree/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#mutex 简介 我们这里讨论的是用户态的多线程模型，同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被虽有的</description>
    </item>
    
    <item>
      <title>socket通信过程</title>
      <link>/post/socket%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Sun, 25 Jun 2017 14:20:32 +0000</pubDate>
      
      <guid>/post/socket%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B/</guid>
      <description>下图是基于TCP协议的客户端/服务器程序的一般流程： 服务器调用socket()、bind()、listen()完成初始化后，调用accept</description>
    </item>
    
    <item>
      <title>Linux历史上线程的3种实现模型</title>
      <link>/post/linux%E5%8E%86%E5%8F%B2%E4%B8%8A%E7%BA%BF%E7%A8%8B%E7%9A%843%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sun, 25 Jun 2017 14:19:38 +0000</pubDate>
      
      <guid>/post/linux%E5%8E%86%E5%8F%B2%E4%B8%8A%E7%BA%BF%E7%A8%8B%E7%9A%843%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9E%8B/</guid>
      <description>一.概述 这里以Linux为例。Linux历史上，最开始使用的线程是LinuxThreads，但LinuxThreads有些方面受限于内核的特</description>
    </item>
    
    <item>
      <title>利用linux的mtrace命令定位内存泄露(Memory Leak)</title>
      <link>/post/%E5%88%A9%E7%94%A8linux%E7%9A%84mtrace%E5%91%BD%E4%BB%A4%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2-memory-leak/</link>
      <pubDate>Sun, 25 Jun 2017 14:19:16 +0000</pubDate>
      
      <guid>/post/%E5%88%A9%E7%94%A8linux%E7%9A%84mtrace%E5%91%BD%E4%BB%A4%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2-memory-leak/</guid>
      <description>最令Linux程序员头疼的莫过于内存泄露了，即使你是在优秀的程序员，你也不能保证所以的malloc操作都有对应的free，那必要的工具就是必</description>
    </item>
    
    <item>
      <title>GCC编译器介绍</title>
      <link>/post/gcc%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Sun, 25 Jun 2017 14:19:06 +0000</pubDate>
      
      <guid>/post/gcc%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%8B%E7%BB%8D/</guid>
      <description>gcc命令 gcc命令使用GNU推出的基于C/C++的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点。现</description>
    </item>
    
    <item>
      <title>用GDB调试程序</title>
      <link>/post/%E7%94%A8gdb%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sun, 25 Jun 2017 05:44:19 +0000</pubDate>
      
      <guid>/post/%E7%94%A8gdb%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/</guid>
      <description>转载自陈皓博客： http://blog.csdn.net/haoel GDB概述 GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。或许，各位比较喜欢那种图形界面方式的，像VC、B</description>
    </item>
    
    <item>
      <title>coredump详解</title>
      <link>/post/coredump%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 25 Jun 2017 05:44:05 +0000</pubDate>
      
      <guid>/post/coredump%E8%AF%A6%E8%A7%A3/</guid>
      <description>一，什么是coredump 我们经常听到大家说到程序core掉了，需要定位解决，这里说的大部分是指对应程序由于各种异常或者bug导致在运行过程</description>
    </item>
    
    <item>
      <title>ping命令和traceroute命令详解</title>
      <link>/post/ping%E5%91%BD%E4%BB%A4%E5%92%8Ctraceroute%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 25 Jun 2017 05:43:53 +0000</pubDate>
      
      <guid>/post/ping%E5%91%BD%E4%BB%A4%E5%92%8Ctraceroute%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid>
      <description>ping命令 基本原理 Ping命令利用ICMP协议进行工作，ICMP是Internet控制消息协议，用于在主机和路由器之间传递控制消息。Pin</description>
    </item>
    
    <item>
      <title>Linux运行级别</title>
      <link>/post/linux%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB/</link>
      <pubDate>Sun, 25 Jun 2017 05:43:44 +0000</pubDate>
      
      <guid>/post/linux%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB/</guid>
      <description>运行级别 运行级别就是操作系统当前正在运行的功能级别。级别是从0到6，具有不同的功能。这些级别定义在/ect/inittab文件中。这个文件是</description>
    </item>
    
    <item>
      <title>Linux内核的组成部分</title>
      <link>/post/linux%E5%86%85%E6%A0%B8%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/</link>
      <pubDate>Sun, 25 Jun 2017 05:43:32 +0000</pubDate>
      
      <guid>/post/linux%E5%86%85%E6%A0%B8%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/</guid>
      <description>组成 Linux内核主要有 5个子系统组成：进程调度 (SCHED) ,内存管理 (MM) ,虚拟文件系统 (VFS) ,网络接口 (NET)和进程间通信 ( IPC )。 1、进程调度 进程在进程</description>
    </item>
    
    <item>
      <title>Linux用户态与内核态</title>
      <link>/post/linux%E7%94%A8%E6%88%B7%E6%80%81%E4%B8%8E%E5%86%85%E6%A0%B8%E6%80%81/</link>
      <pubDate>Sun, 25 Jun 2017 05:43:20 +0000</pubDate>
      
      <guid>/post/linux%E7%94%A8%E6%88%B7%E6%80%81%E4%B8%8E%E5%86%85%E6%A0%B8%E6%80%81/</guid>
      <description>一、 Unix/Linux的体系架构 如上图所示，从宏观上来看，Linux操作系统的体系架构分为用户态和内核态。 内核从本质上看是一种软件——控制</description>
    </item>
    
    <item>
      <title>Socket处在网络层的什么位置？</title>
      <link>/post/socket%E5%A4%84%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E4%BB%80%E4%B9%88%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Sun, 25 Jun 2017 05:43:09 +0000</pubDate>
      
      <guid>/post/socket%E5%A4%84%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E4%BB%80%E4%B9%88%E4%BD%8D%E7%BD%AE/</guid>
      <description>描述一个网络中各个协议层的常用方法是使用国际标准化组织（ISO）的计算机通信开放系统互连（open systems interconnection , OSI）模型。 OSI模型的底下两层是</description>
    </item>
    
    <item>
      <title>Linux进程管理</title>
      <link>/post/linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sun, 25 Jun 2017 05:42:58 +0000</pubDate>
      
      <guid>/post/linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</guid>
      <description>进程的组成 在Linux系统中进程由以下三部分组成： 进程控制块PCB 有了这个数据结构，进程才能成为内核调度的一个基本单位接受内核的调度。同时，</description>
    </item>
    
    <item>
      <title>Linux操作系统的组成和基本功能</title>
      <link>/post/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Sun, 25 Jun 2017 05:42:46 +0000</pubDate>
      
      <guid>/post/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/</guid>
      <description>组成 Linux系统一般有4个主要部分：内核、shell、文件系统和应用程序。内核、shell和文件系统一起形成了基本的操作系统结构，它们使得</description>
    </item>
    
    <item>
      <title>跟我一起写 Makefile</title>
      <link>/post/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99-makefile/</link>
      <pubDate>Sun, 25 Jun 2017 05:42:14 +0000</pubDate>
      
      <guid>/post/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99-makefile/</guid>
      <description>转载自陈皓blog：http://blog.csdn.net/haoel Makefile 介绍 make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么</description>
    </item>
    
    <item>
      <title>调试工具Valgrind</title>
      <link>/post/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7valgrind/</link>
      <pubDate>Sun, 25 Jun 2017 05:10:36 +0000</pubDate>
      
      <guid>/post/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7valgrind/</guid>
      <description>Valgrind是运行在Linux上一套基于仿真技术的程序调试和分析工具，是公认的最接近Purify的产品，它包含一个内核——一个软件合成的</description>
    </item>
    
    <item>
      <title>Linux启动过程详解</title>
      <link>/post/linux%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 25 Jun 2017 05:10:23 +0000</pubDate>
      
      <guid>/post/linux%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</guid>
      <description>转载：http://blog.chinaunix.net/uid-26495963-id-3066282.html 启动第一步－－加载BIOS</description>
    </item>
    
    <item>
      <title>数组中和为定值的多元组</title>
      <link>/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BA%E5%AE%9A%E5%80%BC%E7%9A%84%E5%A4%9A%E5%85%83%E7%BB%84/</link>
      <pubDate>Sun, 25 Jun 2017 02:28:52 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BA%E5%AE%9A%E5%80%BC%E7%9A%84%E5%A4%9A%E5%85%83%E7%BB%84/</guid>
      <description>LeetCode 1. Two Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 解析</description>
    </item>
    
    <item>
      <title>模拟数组/字符串/链表的相加与相乘</title>
      <link>/post/%E6%A8%A1%E6%8B%9F%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E5%8A%A0%E4%B8%8E%E7%9B%B8%E4%B9%98/</link>
      <pubDate>Sun, 25 Jun 2017 02:28:43 +0000</pubDate>
      
      <guid>/post/%E6%A8%A1%E6%8B%9F%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E5%8A%A0%E4%B8%8E%E7%9B%B8%E4%B9%98/</guid>
      <description>LeetCode 2. Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6</description>
    </item>
    
    <item>
      <title>最长子串/子序列</title>
      <link>/post/%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Sun, 25 Jun 2017 02:28:32 +0000</pubDate>
      
      <guid>/post/%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>LeetCode 392. Is Subsequence Given a string s and a string t, check if s is subsequence of t. You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (&amp;lt;=100). A subsequence of a string is a new string which is formed from the original string by deleting</description>
    </item>
    
    <item>
      <title>查找回文子串和回文子序列</title>
      <link>/post/%E6%9F%A5%E6%89%BE%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E5%92%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Sun, 25 Jun 2017 02:28:08 +0000</pubDate>
      
      <guid>/post/%E6%9F%A5%E6%89%BE%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E5%92%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>LeetCode 409. Longest Palindrome Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example “Aa” is not considered a palindrome here. Note: Assume the length of given string will not exceed 1,010. Example: Input: &amp;ldquo;abccccdd&amp;rdquo; Output: 7 Explanation: One longest palindrome that can be built is “</description>
    </item>
    
    <item>
      <title>“之”字形翻译字符串</title>
      <link>/post/%E4%B9%8B%E5%AD%97%E5%BD%A2%E7%BF%BB%E8%AF%91%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sun, 25 Jun 2017 02:27:57 +0000</pubDate>
      
      <guid>/post/%E4%B9%8B%E5%AD%97%E5%BD%A2%E7%BF%BB%E8%AF%91%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>LeetCode 6. ZigZag Conversion 字符串“PAYPALISHIRING”以给定数目的行以之字形模式写入，如下所示：（您可能希望以固定字体显示此模式以更好的易读性） P A</description>
    </item>
    
    <item>
      <title>数字字符串转成数字</title>
      <link>/post/%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%88%90%E6%95%B0%E5%AD%97/</link>
      <pubDate>Sun, 25 Jun 2017 02:27:46 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%88%90%E6%95%B0%E5%AD%97/</guid>
      <description>LeetCode 7. Reverse Integer Reverse digits of an integer. Example1: x = 123, return 321 Example2: x = -123, return -321 click to show spoilers. Note: The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. 解析：需要注意溢出的问题。一个int可以表示数字</description>
    </item>
    
    <item>
      <title>判断回文串</title>
      <link>/post/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E4%B8%B2/</link>
      <pubDate>Sun, 25 Jun 2017 02:27:37 +0000</pubDate>
      
      <guid>/post/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E4%B8%B2/</guid>
      <description>LeetCode 9. Palindrome Number Determine whether an integer is a palindrome. Do this without extra space. Some hints: Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Intege</description>
    </item>
    
    <item>
      <title>模拟除法</title>
      <link>/post/%E6%A8%A1%E6%8B%9F%E9%99%A4%E6%B3%95/</link>
      <pubDate>Sun, 25 Jun 2017 02:27:26 +0000</pubDate>
      
      <guid>/post/%E6%A8%A1%E6%8B%9F%E9%99%A4%E6%B3%95/</guid>
      <description>LeetCode 166. Fraction to Recurring Decimal Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. For example, Given numerator = 1, denominator = 2, return “0.5”. Given numerator = 2, denominator = 1, return “2”. Given numerator = 2, denominator = 3,</description>
    </item>
    
    <item>
      <title>在有序矩阵中找数</title>
      <link>/post/%E5%9C%A8%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%89%BE%E6%95%B0/</link>
      <pubDate>Sun, 25 Jun 2017 02:27:16 +0000</pubDate>
      
      <guid>/post/%E5%9C%A8%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%89%BE%E6%95%B0/</guid>
      <description>LeetCode 74. Search a 2D Matrix Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. 解析： 因为每行从小到大排序，而且每</description>
    </item>
    
    <item>
      <title>先序、中序、后序数组两两组合重构二叉树</title>
      <link>/post/%E5%85%88%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%A4%E4%B8%A4%E7%BB%84%E5%90%88%E9%87%8D%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91-/</link>
      <pubDate>Sun, 25 Jun 2017 02:26:54 +0000</pubDate>
      
      <guid>/post/%E5%85%88%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%A4%E4%B8%A4%E7%BB%84%E5%90%88%E9%87%8D%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91-/</guid>
      <description>LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal Given preorder and inorder traversal of a tree, construct the binary tree. 解析：可以发现的规律是：中序遍历中根节点是左子树右子树的分割点。前序遍历的第一个节点为根节点。同</description>
    </item>
    
    <item>
      <title>二叉树的前序/中序/后序遍历</title>
      <link>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sun, 25 Jun 2017 02:26:40 +0000</pubDate>
      
      <guid>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>LeetCode 94. Binary Tree Inorder Traversal Given a binary tree, return the inorder traversal of its nodes’ values. 解析：递归太简单，直接上递推，用栈来模拟递归，找左孩子，保存路径，找不到就找右兄弟的左孩子。 1</description>
    </item>
    
    <item>
      <title>Binary Search Tree</title>
      <link>/post/binary-search-tree/</link>
      <pubDate>Sun, 25 Jun 2017 02:26:31 +0000</pubDate>
      
      <guid>/post/binary-search-tree/</guid>
      <description>LeetCode 230. Kth Smallest Element in a BST Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. 解析：中序遍历BST就可以得到一个有序数组，题目要找Kth，就直接中序遍历，在输出的字符串</description>
    </item>
    
    <item>
      <title>栈与队列的互相实现</title>
      <link>/post/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%92%E7%9B%B8%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sun, 25 Jun 2017 02:26:20 +0000</pubDate>
      
      <guid>/post/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%92%E7%9B%B8%E5%AE%9E%E7%8E%B0/</guid>
      <description>LeetCode 225. Implement Stack using Queues Implement the following operations of a stack using queues. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. empty() – Return whether the stack is empty. Notes: You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty</description>
    </item>
    
    <item>
      <title>在有序旋转数组中的查找</title>
      <link>/post/%E5%9C%A8%E6%9C%89%E5%BA%8F%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Sun, 25 Jun 2017 02:26:09 +0000</pubDate>
      
      <guid>/post/%E5%9C%A8%E6%9C%89%E5%BA%8F%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</guid>
      <description>LeetCode 153. Find Minimum in Rotated Sorted Array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. You may assume no duplicate exists in the array. Subscribe to see which companies asked this question. 解析： 二分法，旋</description>
    </item>
    
    <item>
      <title>斐波那契数列</title>
      <link>/post/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</link>
      <pubDate>Sun, 25 Jun 2017 02:25:49 +0000</pubDate>
      
      <guid>/post/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</guid>
      <description>LeetCode 70. Climbing Stairs You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. 解析：标准Fibonacci，也可看作DP。</description>
    </item>
    
    <item>
      <title>常见位运算问题</title>
      <link>/post/%E5%B8%B8%E8%A7%81%E4%BD%8D%E8%BF%90%E7%AE%97%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 25 Jun 2017 02:25:37 +0000</pubDate>
      
      <guid>/post/%E5%B8%B8%E8%A7%81%E4%BD%8D%E8%BF%90%E7%AE%97%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 191. Number of 1 Bits Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight). For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3. 解析：n=n&amp;amp;(n-1)可以取出</description>
    </item>
    
    <item>
      <title>求某个数是否为2/3/4的幂</title>
      <link>/post/%E6%B1%82%E6%9F%90%E4%B8%AA%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA234%E7%9A%84%E5%B9%82/</link>
      <pubDate>Sun, 25 Jun 2017 02:25:24 +0000</pubDate>
      
      <guid>/post/%E6%B1%82%E6%9F%90%E4%B8%AA%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA234%E7%9A%84%E5%B9%82/</guid>
      <description>LeetCode 231. Power of Two Given an integer, write a function to determine if it is a power of two. 解析：2的幂表示n的只有一个位是“1”，因此使用n&amp;amp;（n-1）== 0的技巧来判断是否是这种情</description>
    </item>
    
    <item>
      <title>求幂与开方</title>
      <link>/post/%E6%B1%82%E5%B9%82%E4%B8%8E%E5%BC%80%E6%96%B9/</link>
      <pubDate>Sun, 25 Jun 2017 02:25:15 +0000</pubDate>
      
      <guid>/post/%E6%B1%82%E5%B9%82%E4%B8%8E%E5%BC%80%E6%96%B9/</guid>
      <description>LeetCode 50. Pow(x, n) Implement pow(x, n). 解析：快速幂，此处需要判断边界值n，如果n为-2^31，那么需要另外设置一个long long变量存储其相反数。0x800000</description>
    </item>
    
    <item>
      <title>删除数组/链表的元素</title>
      <link>/post/%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%83%E7%B4%A0/</link>
      <pubDate>Sun, 25 Jun 2017 02:24:59 +0000</pubDate>
      
      <guid>/post/%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%83%E7%B4%A0/</guid>
      <description>LeetCode 27. Remove Element Given an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example: Given input array nums = [3,2,2,3],</description>
    </item>
    
    <item>
      <title>在单链表中删除倒数第N个节点</title>
      <link>/post/%E5%9C%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sun, 25 Jun 2017 02:24:48 +0000</pubDate>
      
      <guid>/post/%E5%9C%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</guid>
      <description>LeetCode 19. Remove Nth Node From End of List Given a linked list, remove the nth node from the end of list and return its head. For example, Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5. Note: Given n will always be valid. Try to do this in one pass. 解析： 根据题意</description>
    </item>
    
    <item>
      <title>链表有环和相交问题</title>
      <link>/post/%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF%E5%92%8C%E7%9B%B8%E4%BA%A4%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 25 Jun 2017 02:24:38 +0000</pubDate>
      
      <guid>/post/%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF%E5%92%8C%E7%9B%B8%E4%BA%A4%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 141. Linked List Cycle Given a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space? 解析： FLOYD判圈算法(判断是否有环): 如何检测一个链表是否有环，如果有，那么如何确</description>
    </item>
    
    <item>
      <title>数组、字符串、链表的旋转判定</title>
      <link>/post/%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE%E8%A1%A8%E7%9A%84%E6%97%8B%E8%BD%AC%E5%88%A4%E5%AE%9A/</link>
      <pubDate>Sun, 25 Jun 2017 02:24:25 +0000</pubDate>
      
      <guid>/post/%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE%E8%A1%A8%E7%9A%84%E6%97%8B%E8%BD%AC%E5%88%A4%E5%AE%9A/</guid>
      <description>LeetCode 189. Rotate Array Rotate an array of n elements to the right by k steps. For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. 解析： 循环移动数组k位：123</description>
    </item>
    
    <item>
      <title>反转链表</title>
      <link>/post/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 25 Jun 2017 02:24:14 +0000</pubDate>
      
      <guid>/post/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>LeetCode 24. Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head. For example, Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, you should return the list as 2-&amp;gt;1-&amp;gt;4-&amp;gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 解析：直接交换当前结点和其后继节点的</description>
    </item>
    
    <item>
      <title>合并有序链表/数组</title>
      <link>/post/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sun, 25 Jun 2017 02:23:16 +0000</pubDate>
      
      <guid>/post/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E6%95%B0%E7%BB%84/</guid>
      <description>LeetCode 88. Merge Sorted Array Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 解析： 合并两个数组（</description>
    </item>
    
    <item>
      <title>镜像二叉树</title>
      <link>/post/%E9%95%9C%E5%83%8F%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 25 Jun 2017 02:23:02 +0000</pubDate>
      
      <guid>/post/%E9%95%9C%E5%83%8F%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>LeetCode 226. Invert Binary Tree Invert a binary tree. 4 / \ 2 7 / \ / \ 1 3 6 9 to 4 / \ 7 2 / \ / \ 9 6 3 1 解析：二叉树的镜像就是在遍历树的同时交换非叶节点的左右子节点 1 2 3 4</description>
    </item>
    
    <item>
      <title>判断t1树是否包含t2树全部的拓扑结构</title>
      <link>/post/%E5%88%A4%E6%96%ADt1%E6%A0%91%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%ABt2%E6%A0%91%E5%85%A8%E9%83%A8%E7%9A%84%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 25 Jun 2017 02:22:50 +0000</pubDate>
      
      <guid>/post/%E5%88%A4%E6%96%ADt1%E6%A0%91%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%ABt2%E6%A0%91%E5%85%A8%E9%83%A8%E7%9A%84%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/</guid>
      <description>LeetCode 100.Same Tree Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. 解析：直接DFS，注意两个节点中任何一个为空要直接返回，算是递归终止</description>
    </item>
    
    <item>
      <title>转圈打印矩阵</title>
      <link>/post/%E8%BD%AC%E5%9C%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Sun, 25 Jun 2017 02:22:38 +0000</pubDate>
      
      <guid>/post/%E8%BD%AC%E5%9C%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</guid>
      <description>LeetCode 54. Spiral Matrix Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. For example, Given the following matrix: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] You should return [1,2,3,6,9,8,7,4,5]. 解析： 先找出矩阵的四个边界，然后将整</description>
    </item>
    
    <item>
      <title>除法的化简</title>
      <link>/post/%E9%99%A4%E6%B3%95%E7%9A%84%E5%8C%96%E7%AE%80/</link>
      <pubDate>Sun, 25 Jun 2017 02:22:24 +0000</pubDate>
      
      <guid>/post/%E9%99%A4%E6%B3%95%E7%9A%84%E5%8C%96%E7%AE%80/</guid>
      <description>LeetCode 399. Evaluate Division Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0. Example: Given a / b = 2.0, b / c = 3.0. queries are: a / c = ?, b / a =</description>
    </item>
    
    <item>
      <title>二叉树节点间的公共祖先</title>
      <link>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E9%97%B4%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Sun, 25 Jun 2017 02:22:13 +0000</pubDate>
      
      <guid>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E9%97%B4%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>LeetCode 235. Lowest Common Ancestor of a Binary Search Tree Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a</description>
    </item>
    
    <item>
      <title>设计一个有getMin功能的栈</title>
      <link>/post/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%9C%89getmin%E5%8A%9F%E8%83%BD%E7%9A%84%E6%A0%88/</link>
      <pubDate>Sun, 25 Jun 2017 02:21:54 +0000</pubDate>
      
      <guid>/post/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%9C%89getmin%E5%8A%9F%E8%83%BD%E7%9A%84%E6%A0%88/</guid>
      <description>LeetCode 155. Min Stack Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&amp;gt; Returns -3. minStack.pop(); minStack.top(); --&amp;gt; Returns 0.</description>
    </item>
    
    <item>
      <title>滑动窗口</title>
      <link>/post/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</link>
      <pubDate>Sun, 25 Jun 2017 02:21:40 +0000</pubDate>
      
      <guid>/post/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</guid>
      <description>LeetCode 209. Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. For example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint. 解析：用双指</description>
    </item>
    
    <item>
      <title>二叉树的按层打印与ZigZig打印</title>
      <link>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%B8%8Ezigzig%E6%89%93%E5%8D%B0/</link>
      <pubDate>Sun, 25 Jun 2017 02:21:28 +0000</pubDate>
      
      <guid>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%B8%8Ezigzig%E6%89%93%E5%8D%B0/</guid>
      <description>LeetCode102. Binary Tree Level Order Traversal Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its level order traversal as: [ [3], [9,20], [15,7] ] 解析：此题要求将二叉树层</description>
    </item>
    
    <item>
      <title>二叉树的深度</title>
      <link>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Sun, 25 Jun 2017 00:01:10 +0000</pubDate>
      
      <guid>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</guid>
      <description>LeetCode 104. Maximum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 解析：找二叉树的最大深度，不断dfs，只要能dfs到下一层，就增加</description>
    </item>
    
    <item>
      <title>在二叉树中找到累加和为指定值的最长路径长度</title>
      <link>/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E6%8C%87%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Sun, 25 Jun 2017 00:01:01 +0000</pubDate>
      
      <guid>/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E6%8C%87%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6/</guid>
      <description>LeetCode 112. Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. For example: Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2</description>
    </item>
    
    <item>
      <title>复制含有随机指针节点的链表</title>
      <link>/post/%E5%A4%8D%E5%88%B6%E5%90%AB%E6%9C%89%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E8%8A%82%E7%82%B9%E7%9A%84%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 25 Jun 2017 00:00:49 +0000</pubDate>
      
      <guid>/post/%E5%A4%8D%E5%88%B6%E5%90%AB%E6%9C%89%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E8%8A%82%E7%82%B9%E7%9A%84%E9%93%BE%E8%A1%A8/</guid>
      <description>LeetCode 138. Copy List with Random Pointer A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. 解析： 此题有两种方法，一种是按照原链表next的顺序依次创建节</description>
    </item>
    
    <item>
      <title>找到无序数组中某一频率的数</title>
      <link>/post/%E6%89%BE%E5%88%B0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%90%E4%B8%80%E9%A2%91%E7%8E%87%E7%9A%84%E6%95%B0/</link>
      <pubDate>Sun, 25 Jun 2017 00:00:19 +0000</pubDate>
      
      <guid>/post/%E6%89%BE%E5%88%B0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%90%E4%B8%80%E9%A2%91%E7%8E%87%E7%9A%84%E6%95%B0/</guid>
      <description>LeetCode 451. Sort Characters By Frequency Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input: “tree” Output: “eert” Explanation: ‘e’ appears twice while ‘r’ and ‘t’ both appear once. So ‘e’ must appear before both ‘r’ and ‘t’. Therefore</description>
    </item>
    
    <item>
      <title>子数组的最大累加和/累乘积</title>
      <link>/post/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E5%8A%A0%E5%92%8C%E7%B4%AF%E4%B9%98%E7%A7%AF/</link>
      <pubDate>Sun, 25 Jun 2017 00:00:10 +0000</pubDate>
      
      <guid>/post/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E5%8A%A0%E5%92%8C%E7%B4%AF%E4%B9%98%E7%A7%AF/</guid>
      <description>LeetCode 53. Maximum Subarray Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6. 解析：动态规划 每个元素有2种选择：加入之前的连续子序列；创建一个新</description>
    </item>
    
    <item>
      <title>与数字的某位相关问题</title>
      <link>/post/%E4%B8%8E%E6%95%B0%E5%AD%97%E7%9A%84%E6%9F%90%E4%BD%8D%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Jun 2017 23:59:57 +0000</pubDate>
      
      <guid>/post/%E4%B8%8E%E6%95%B0%E5%AD%97%E7%9A%84%E6%9F%90%E4%BD%8D%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 233. Number of Digit One Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n. For example: Given n = 13, Return 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13. 解析： 每10个数, 有一个个位是1, 每100</description>
    </item>
    
    <item>
      <title>丑数</title>
      <link>/post/%E4%B8%91%E6%95%B0/</link>
      <pubDate>Sat, 24 Jun 2017 23:59:47 +0000</pubDate>
      
      <guid>/post/%E4%B8%91%E6%95%B0/</guid>
      <description>LeetCode 263. Ugly Number Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note that 1 is typically treated as an ugly number. 解析： 我们将给定数除以2</description>
    </item>
    
    <item>
      <title>字符数组中的单独字符</title>
      <link>/post/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E7%8B%AC%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Sat, 24 Jun 2017 23:59:36 +0000</pubDate>
      
      <guid>/post/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E7%8B%AC%E5%AD%97%E7%AC%A6/</guid>
      <description>判断字符数组中是否所有的字符都只出现过一次 题目: 给定一个字符类型数组chas[]，判断chas中是否所有的字符都只出现过一次,在保证额外空间</description>
    </item>
    
    <item>
      <title>通过增删数位创建新的数字</title>
      <link>/post/%E9%80%9A%E8%BF%87%E5%A2%9E%E5%88%A0%E6%95%B0%E4%BD%8D%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Sat, 24 Jun 2017 23:59:18 +0000</pubDate>
      
      <guid>/post/%E9%80%9A%E8%BF%87%E5%A2%9E%E5%88%A0%E6%95%B0%E4%BD%8D%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>LeetCode 402. Remove K Digits Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible. Note: The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero. Example 1: Input: num = &amp;quot;1432219&amp;quot;, k = 3 Output: &amp;quot;1219&amp;quot; Explanation: Remove the three digits 4, 3,</description>
    </item>
    
    <item>
      <title>排列</title>
      <link>/post/%E6%8E%92%E5%88%97/</link>
      <pubDate>Sat, 24 Jun 2017 23:59:06 +0000</pubDate>
      
      <guid>/post/%E6%8E%92%E5%88%97/</guid>
      <description>LeetCode 46. Permutations Given a collection of distinct numbers, return all possible permutations. For example, [1,2,3] have the following permutations: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 解析： 此题可以直接用STL中的next_permutation()实现。利用回溯法暴</description>
    </item>
    
    <item>
      <title>查找单独/重复/丢失的元素</title>
      <link>/post/%E6%9F%A5%E6%89%BE%E5%8D%95%E7%8B%AC%E9%87%8D%E5%A4%8D%E4%B8%A2%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0/</link>
      <pubDate>Sat, 24 Jun 2017 23:58:53 +0000</pubDate>
      
      <guid>/post/%E6%9F%A5%E6%89%BE%E5%8D%95%E7%8B%AC%E9%87%8D%E5%A4%8D%E4%B8%A2%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0/</guid>
      <description>LeetCode 136. Single Number Given an array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 解析：利用异或运算规律，同一个数异或两次相当于没有异或。本题除了所</description>
    </item>
    
    <item>
      <title>删除有序数组/链表的重复值</title>
      <link>/post/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E5%80%BC/</link>
      <pubDate>Sat, 24 Jun 2017 23:58:39 +0000</pubDate>
      
      <guid>/post/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E5%80%BC/</guid>
      <description>LeetCode 26. Remove Duplicates from Sorted Array Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example, Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and</description>
    </item>
    
    <item>
      <title>格雷码</title>
      <link>/post/%E6%A0%BC%E9%9B%B7%E7%A0%81/</link>
      <pubDate>Sat, 24 Jun 2017 23:58:27 +0000</pubDate>
      
      <guid>/post/%E6%A0%BC%E9%9B%B7%E7%A0%81/</guid>
      <description>LeetCode 89. Gray Code The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. For example, given n = 2, return [0,1,3,2]. Its gray code sequence is: 00 - 0 01 - 1 11 -</description>
    </item>
    
    <item>
      <title>正则表达式匹配</title>
      <link>/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Sat, 24 Jun 2017 23:58:16 +0000</pubDate>
      
      <guid>/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description>LeetCode 44. Wildcard Matching Implement wildcard pattern matching with support for ‘?’ and ‘*’. ‘?’ Matches any single character. ‘*’ Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). The function prototype should be: bool isMatch(const char s, const char p) Some examples: isMatch(&amp;quot;aa&amp;quot;,&amp;quot;a&amp;quot;) → false isMatch(&amp;quot;aa&amp;quot;,&amp;quot;aa&amp;quot;) → true isMatch(&amp;quot;aaa&amp;quot;,&amp;quot;aa&amp;quot;) →</description>
    </item>
    
    <item>
      <title>查找数组中的重复项</title>
      <link>/post/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</link>
      <pubDate>Sat, 24 Jun 2017 23:58:05 +0000</pubDate>
      
      <guid>/post/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</guid>
      <description>LeetCode 217. Contains Duplicate Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. 解析：直接构建哈希表 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: bool containsDuplicate(vector&amp;lt;int&amp;gt;&amp;amp;</description>
    </item>
    
    <item>
      <title>容器的盛水量</title>
      <link>/post/%E5%AE%B9%E5%99%A8%E7%9A%84%E7%9B%9B%E6%B0%B4%E9%87%8F/</link>
      <pubDate>Sat, 24 Jun 2017 23:57:56 +0000</pubDate>
      
      <guid>/post/%E5%AE%B9%E5%99%A8%E7%9A%84%E7%9B%9B%E6%B0%B4%E9%87%8F/</guid>
      <description>LeetCode 11. Container With Most Water Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and</description>
    </item>
    
    <item>
      <title>最长公共前缀</title>
      <link>/post/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</link>
      <pubDate>Sat, 24 Jun 2017 22:12:20 +0000</pubDate>
      
      <guid>/post/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</guid>
      <description>LeetCode 14. Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings. 解析：求所有字符串的公共前缀，逐个字符比较，时间复杂度为O(N*L),N是字符串个数，L是最长前缀的</description>
    </item>
    
    <item>
      <title>数字翻译</title>
      <link>/post/%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91/</link>
      <pubDate>Sat, 24 Jun 2017 22:12:10 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91/</guid>
      <description>LeetCode 12. Integer to Roman Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 解析：先是做了一个表，根据各个位的数字查表，然后组合罗马数字成字符串 1 2 3 4 5 6 7 8 9 10</description>
    </item>
    
    <item>
      <title>括号匹配</title>
      <link>/post/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Sat, 24 Jun 2017 22:12:01 +0000</pubDate>
      
      <guid>/post/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/</guid>
      <description>括号字符的有效性 给定一个字符串str,判断是不是整体有效的括号字符串。 解析: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static boolean isValid(String str) { if (str == null || str.equals(&amp;#34;&amp;#34;))</description>
    </item>
    
    <item>
      <title>数组中的位置查找</title>
      <link>/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Sat, 24 Jun 2017 22:11:50 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE%E6%9F%A5%E6%89%BE/</guid>
      <description>LeetCode 35. Search Insert Position Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Here are few examples. [1,3,5,6], 5 → 2 [1,3,5,6], 2 → 1 [1,3,5,6], 7 → 4 [1,3,5,6], 0 → 0 解析：在有序</description>
    </item>
    
    <item>
      <title>根据大小猜数</title>
      <link>/post/%E6%A0%B9%E6%8D%AE%E5%A4%A7%E5%B0%8F%E7%8C%9C%E6%95%B0/</link>
      <pubDate>Sat, 24 Jun 2017 22:11:42 +0000</pubDate>
      
      <guid>/post/%E6%A0%B9%E6%8D%AE%E5%A4%A7%E5%B0%8F%E7%8C%9C%E6%95%B0/</guid>
      <description>LeetCode 374. Guess Number Higher or Lower We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I’ll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0): -1 :</description>
    </item>
    
    <item>
      <title>从石堆取石子的博弈问题</title>
      <link>/post/%E4%BB%8E%E7%9F%B3%E5%A0%86%E5%8F%96%E7%9F%B3%E5%AD%90%E7%9A%84%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Jun 2017 22:11:34 +0000</pubDate>
      
      <guid>/post/%E4%BB%8E%E7%9F%B3%E5%A0%86%E5%8F%96%E7%9F%B3%E5%AD%90%E7%9A%84%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 292. Nim Game You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game.</description>
    </item>
    
    <item>
      <title>引爆区间气球</title>
      <link>/post/%E5%BC%95%E7%88%86%E5%8C%BA%E9%97%B4%E6%B0%94%E7%90%83/</link>
      <pubDate>Sat, 24 Jun 2017 22:11:25 +0000</pubDate>
      
      <guid>/post/%E5%BC%95%E7%88%86%E5%8C%BA%E9%97%B4%E6%B0%94%E7%90%83/</guid>
      <description>LeetCode 312. Burst Balloons Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] nums[i] nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you</description>
    </item>
    
    <item>
      <title>数独</title>
      <link>/post/%E6%95%B0%E7%8B%AC/</link>
      <pubDate>Sat, 24 Jun 2017 22:11:15 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E7%8B%AC/</guid>
      <description>LeetCode 36. Valid Sudoku The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’. 解析：检查九宫格是否有效，只需要检查每行每列和每个子九宫格是否存在重复数字即可。创建三个map</description>
    </item>
    
    <item>
      <title>组合</title>
      <link>/post/%E7%BB%84%E5%90%88/</link>
      <pubDate>Sat, 24 Jun 2017 22:09:05 +0000</pubDate>
      
      <guid>/post/%E7%BB%84%E5%90%88/</guid>
      <description>LeetCode 39. Combination Sum Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example, given candidate set [2, 3, 6, 7]</description>
    </item>
    
    <item>
      <title>跳跃游戏</title>
      <link>/post/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Sat, 24 Jun 2017 22:08:56 +0000</pubDate>
      
      <guid>/post/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</guid>
      <description>LeetCode 55. Jump Game Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. For example: A = [2,3,1,1,4], return true. A = [3,2,1,0,4], return false. 解析：设最远距离为reach</description>
    </item>
    
    <item>
      <title>将正方形矩阵转动90度</title>
      <link>/post/%E5%B0%86%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9F%A9%E9%98%B5%E8%BD%AC%E5%8A%A890%E5%BA%A6/</link>
      <pubDate>Sat, 24 Jun 2017 22:08:46 +0000</pubDate>
      
      <guid>/post/%E5%B0%86%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9F%A9%E9%98%B5%E8%BD%AC%E5%8A%A890%E5%BA%A6/</guid>
      <description>LeetCode 48. Rotate Image You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Follow up: Could you do this in-place? 解析： 二维矩阵顺时针旋转90度，先转置，再把每一行翻转 二维矩阵逆时针旋转90度，</description>
    </item>
    
    <item>
      <title>判断变形字符串</title>
      <link>/post/%E5%88%A4%E6%96%AD%E5%8F%98%E5%BD%A2%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sat, 24 Jun 2017 22:08:38 +0000</pubDate>
      
      <guid>/post/%E5%88%A4%E6%96%AD%E5%8F%98%E5%BD%A2%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>LeetCode 383. Ransom Note Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false. Each letter in the magazine string can only be used once in your ransom note. Note: You may assume that both strings contain only lowercase letters. canConstruct(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;)</description>
    </item>
    
    <item>
      <title>N皇后问题</title>
      <link>/post/n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Jun 2017 22:08:30 +0000</pubDate>
      
      <guid>/post/n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 51. N-Queens The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen</description>
    </item>
    
    <item>
      <title>最后一个单词的长度</title>
      <link>/post/%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Sat, 24 Jun 2017 22:08:22 +0000</pubDate>
      
      <guid>/post/%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</guid>
      <description>LeetCode 58. Length of Last Word Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. For example, Given s = “Hello World”</description>
    </item>
    
    <item>
      <title>文本排版</title>
      <link>/post/%E6%96%87%E6%9C%AC%E6%8E%92%E7%89%88/</link>
      <pubDate>Sat, 24 Jun 2017 22:08:13 +0000</pubDate>
      
      <guid>/post/%E6%96%87%E6%9C%AC%E6%8E%92%E7%89%88/</guid>
      <description>LeetCode 68. Text Justification Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ‘ ‘ when necessary so that each line has exactly L characters. Extra spaces between</description>
    </item>
    
    <item>
      <title>路径问题</title>
      <link>/post/%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Jun 2017 22:08:03 +0000</pubDate>
      
      <guid>/post/%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 62. Unique Paths A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How</description>
    </item>
    
    <item>
      <title>区间问题</title>
      <link>/post/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Jun 2017 22:07:55 +0000</pubDate>
      
      <guid>/post/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 228. Summary Ranges Given a sorted integer array without duplicates, return the summary of its ranges. For example, given [0,1,2,4,5,7], return [“0-&amp;gt;2”,”4-&amp;gt;5”,”7”]. 解析： 将一组数划分成若干的区间，用双指针分别</description>
    </item>
    
    <item>
      <title>文件路径</title>
      <link>/post/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Sat, 24 Jun 2017 22:07:44 +0000</pubDate>
      
      <guid>/post/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/</guid>
      <description>LeetCode 71. Simplify Path Given an absolute path for a file (Unix-style), simplify it. For example, path = “/home/“, =&amp;gt; “/home” path = “/a/./b/../../c/“, =&amp;gt; “/c” 解析： 字符串处理，而</description>
    </item>
    
    <item>
      <title>字符串A编辑成字符串B</title>
      <link>/post/%E7%AC%A6%E4%B8%B2a%E7%BC%96%E8%BE%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2b/</link>
      <pubDate>Sat, 24 Jun 2017 20:32:14 +0000</pubDate>
      
      <guid>/post/%E7%AC%A6%E4%B8%B2a%E7%BC%96%E8%BE%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2b/</guid>
      <description>LeetCode 115. Distinct Subsequences Given a string S and a string T, count the number of distinct subsequences of T in S. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABC</description>
    </item>
    
    <item>
      <title>修改矩阵</title>
      <link>/post/%E4%BF%AE%E6%94%B9%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Sat, 24 Jun 2017 20:32:04 +0000</pubDate>
      
      <guid>/post/%E4%BF%AE%E6%94%B9%E7%9F%A9%E9%98%B5/</guid>
      <description>LeetCode 73. Set Matrix Zeroes Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place. 解析： 题目要求空间复杂度in place，即原地工作O(1),执行算法时所使用的额外空</description>
    </item>
    
    <item>
      <title>子集</title>
      <link>/post/%E5%AD%90%E9%9B%86/</link>
      <pubDate>Sat, 24 Jun 2017 20:31:54 +0000</pubDate>
      
      <guid>/post/%E5%AD%90%E9%9B%86/</guid>
      <description>LeetCode 78. Subsets Given a set of distinct integers, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. For example, If nums = [1,2,3], a solution is: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 解析：要求输出所有子集，且输出有序，而每个元素只有出现和</description>
    </item>
    
    <item>
      <title>字典树相关问题</title>
      <link>/post/%E5%AD%97%E5%85%B8%E6%A0%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Jun 2017 20:31:45 +0000</pubDate>
      
      <guid>/post/%E5%AD%97%E5%85%B8%E6%A0%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 79. Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example, Given board = [ [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;], [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;], [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;] ] word</description>
    </item>
    
    <item>
      <title>单链表排序总结</title>
      <link>/post/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 24 Jun 2017 20:31:28 +0000</pubDate>
      
      <guid>/post/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</guid>
      <description>插入排序 LeetCode 147. Insertion Sort List Sort a linked list using insertion sort. 解析： 链表排序最易理解的是插入排序。 插入排序的方法就是枚举数组中的每一个元素i，从头扫描数组，找到第一个比该</description>
    </item>
    
    <item>
      <title>划分数组/链表</title>
      <link>/post/%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 24 Jun 2017 20:31:14 +0000</pubDate>
      
      <guid>/post/%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/</guid>
      <description>LeetCode 75. Sort Colors Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library</description>
    </item>
    
    <item>
      <title>乱序字符串</title>
      <link>/post/%E4%B9%B1%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sat, 24 Jun 2017 20:29:19 +0000</pubDate>
      
      <guid>/post/%E4%B9%B1%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>LeetCode 87. Scramble String Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Below is one possible representation of s1 = “great”: great / \ gr eat / \ / \ g r e at / \ a t To scramble the string, we may choose any non-leaf node and swap its</description>
    </item>
    
    <item>
      <title>最大区域面积</title>
      <link>/post/%E6%9C%80%E5%A4%A7%E5%8C%BA%E5%9F%9F%E9%9D%A2%E7%A7%AF/</link>
      <pubDate>Sat, 24 Jun 2017 20:29:09 +0000</pubDate>
      
      <guid>/post/%E6%9C%80%E5%A4%A7%E5%8C%BA%E5%9F%9F%E9%9D%A2%E7%A7%AF/</guid>
      <description>LeetCode 84. Largest Rectangle in Histogram Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area =</description>
    </item>
    
    <item>
      <title>统计和生成所有不同的二叉树</title>
      <link>/post/%E7%BB%9F%E8%AE%A1%E5%92%8C%E7%94%9F%E6%88%90%E6%89%80%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sat, 24 Jun 2017 20:29:00 +0000</pubDate>
      
      <guid>/post/%E7%BB%9F%E8%AE%A1%E5%92%8C%E7%94%9F%E6%88%90%E6%89%80%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>LeetCode 96. Unique Binary Search Trees Given n, how many structurally unique BST’s (binary search trees) that store values 1…n? For example, Given n = 3, there are a total of 5 unique BST’s. 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2</description>
    </item>
    
    <item>
      <title>重建搜索二叉树</title>
      <link>/post/%E9%87%8D%E5%BB%BA%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sat, 24 Jun 2017 20:28:50 +0000</pubDate>
      
      <guid>/post/%E9%87%8D%E5%BB%BA%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>LeetCode 108. Convert Sorted Array to Binary Search Tree Given an array where elements are sorted in ascending order, convert it to a height balanced BST. 解析： 每次找到数组的中间位置，这个便是BST的 根节点。左右孩子也很好找，根节点左边区域的</description>
    </item>
    
    <item>
      <title>IP Address</title>
      <link>/post/ip-address/</link>
      <pubDate>Sat, 24 Jun 2017 20:28:40 +0000</pubDate>
      
      <guid>/post/ip-address/</guid>
      <description>LeetCode 93. Restore IP Addresses Given a string containing only digits, restore it by returning all possible valid IP address combinations. For example: Given “25525511135”, return [“255.255.11.135”, “255.255.111.</description>
    </item>
    
    <item>
      <title>添加括号或运算符进行计算</title>
      <link>/post/%E6%B7%BB%E5%8A%A0%E6%8B%AC%E5%8F%B7%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Sat, 24 Jun 2017 20:28:04 +0000</pubDate>
      
      <guid>/post/%E6%B7%BB%E5%8A%A0%E6%8B%AC%E5%8F%B7%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97/</guid>
      <description>LeetCode 494. Target Sum You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol. Find out how many ways to assign symbols to make sum of integers equal to target S. Example 1: Input: nums is [1, 1, 1, 1,</description>
    </item>
    
    <item>
      <title>Flatten Binary Tree to Linked List</title>
      <link>/post/flatten-binary-tree-to-linked-list/</link>
      <pubDate>Sat, 24 Jun 2017 20:27:52 +0000</pubDate>
      
      <guid>/post/flatten-binary-tree-to-linked-list/</guid>
      <description>LeetCode 114. Flatten Binary Tree to Linked List Given a binary tree, flatten it to a linked list in-place. For example, Given 1 / \ 2 5 / \ \ 3 4 6 The flattened tree should look like: 1 \ 2 \ 3 \ 4 \ 5 \ 6 解析： 可以看出变换后的树实际上是按照先序</description>
    </item>
    
    <item>
      <title>Pascal&#39;s Triangle</title>
      <link>/post/pascal-s-triangle/</link>
      <pubDate>Sat, 24 Jun 2017 20:27:41 +0000</pubDate>
      
      <guid>/post/pascal-s-triangle/</guid>
      <description>LeetCode 118. Pascal’s Triangle Given numRows, generate the first numRows of Pascal’s triangle. For example, given numRows = 5, Return [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] 解析： 杨辉三角形的构造方法：左右边界为1，中间num[i]</description>
    </item>
    
    <item>
      <title>在二叉树节点中添加新指针</title>
      <link>/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%8C%87%E9%92%88/</link>
      <pubDate>Sat, 24 Jun 2017 20:26:57 +0000</pubDate>
      
      <guid>/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%8C%87%E9%92%88/</guid>
      <description>LeetCode 116. Populating Next Right Pointers in Each Node Given a binary tree struct TreeLinkNode { TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space. You may assume that it</description>
    </item>
    
    <item>
      <title>购买股票问题</title>
      <link>/post/%E8%B4%AD%E4%B9%B0%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Jun 2017 20:26:45 +0000</pubDate>
      
      <guid>/post/%E8%B4%AD%E4%B9%B0%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 121. Best Time to Buy and Sell Stock Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1: Input: [7, 1, 5, 3, 6, 4] Output: 5 max.</description>
    </item>
    
    <item>
      <title>Word Ladder</title>
      <link>/post/word-ladder/</link>
      <pubDate>Sat, 24 Jun 2017 20:26:35 +0000</pubDate>
      
      <guid>/post/word-ladder/</guid>
      <description>LeetCode 127. Word Ladder Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. For example, Given: beginWord =</description>
    </item>
    
    <item>
      <title>最长上升子序列</title>
      <link>/post/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Sat, 24 Jun 2017 20:26:24 +0000</pubDate>
      
      <guid>/post/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>LeetCode 300. Longest Increasing Subsequence Given an unsorted array of integers, find the length of longest increasing subsequence. For example, Given [10, 9, 2, 5, 3, 7, 101, 18], The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity.</description>
    </item>
    
    <item>
      <title>Surrounded Regions</title>
      <link>/post/surrounded-regions/</link>
      <pubDate>Sat, 24 Jun 2017 20:26:12 +0000</pubDate>
      
      <guid>/post/surrounded-regions/</guid>
      <description>LeetCode 130. Surrounded Regions Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’. A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region. For example, X X X X X O O X X X O X X O X X After running your function,</description>
    </item>
    
    <item>
      <title>134. Gas Station</title>
      <link>/post/gas-station/</link>
      <pubDate>Sat, 24 Jun 2017 20:26:00 +0000</pubDate>
      
      <guid>/post/gas-station/</guid>
      <description>LeetCode 134. Gas Station There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas stat</description>
    </item>
    
    <item>
      <title>分糖果问题</title>
      <link>/post/%E5%88%86%E7%B3%96%E6%9E%9C%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Jun 2017 20:25:50 +0000</pubDate>
      
      <guid>/post/%E5%88%86%E7%B3%96%E6%9E%9C%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 135. Candy There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. What is the minimum candies you must give? 解析： 先引入爬坡和下坡的概</description>
    </item>
    
    <item>
      <title>数组排序之后相邻数的最大差值</title>
      <link>/post/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%90%8E%E7%9B%B8%E9%82%BB%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/</link>
      <pubDate>Sat, 24 Jun 2017 19:52:29 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%90%8E%E7%9B%B8%E9%82%BB%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/</guid>
      <description>LeetCode 164. Maximum Gap Given an unsorted array, find the maximum difference between the successive elements in its sorted form. Try to solve it in linear time/space. Return 0 if the array contains less than 2 elements. You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. 解析： 桶排序要求所有元素在一</description>
    </item>
    
    <item>
      <title>重复的DNA子序列</title>
      <link>/post/%E9%87%8D%E5%A4%8D%E7%9A%84dna%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Sat, 24 Jun 2017 19:52:16 +0000</pubDate>
      
      <guid>/post/%E9%87%8D%E5%A4%8D%E7%9A%84dna%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>LeetCode 187. Repeated DNA Sequences All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. For</description>
    </item>
    
    <item>
      <title>筛选素数</title>
      <link>/post/%E7%AD%9B%E9%80%89%E7%B4%A0%E6%95%B0/</link>
      <pubDate>Sat, 24 Jun 2017 19:52:07 +0000</pubDate>
      
      <guid>/post/%E7%AD%9B%E9%80%89%E7%B4%A0%E6%95%B0/</guid>
      <description>LeetCode 204. Count Primes Description: Count the number of prime numbers less than a non-negative number, n. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution {//埃拉托斯特尼尼素数筛法 public: int countPrimes(int n) { if (n&amp;lt;=2) return 0;//2以下没有</description>
    </item>
    
    <item>
      <title>特殊数</title>
      <link>/post/%E7%89%B9%E6%AE%8A%E6%95%B0/</link>
      <pubDate>Sat, 24 Jun 2017 19:51:48 +0000</pubDate>
      
      <guid>/post/%E7%89%B9%E6%AE%8A%E6%95%B0/</guid>
      <description>LeetCode 202. Happy Number Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which</description>
    </item>
    
    <item>
      <title>课程安排</title>
      <link>/post/%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92/</link>
      <pubDate>Sat, 24 Jun 2017 19:51:39 +0000</pubDate>
      
      <guid>/post/%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92/</guid>
      <description>LeetCode 207. Course Schedule There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? For example:</description>
    </item>
    
    <item>
      <title>求重叠矩形的面积</title>
      <link>/post/%E6%B1%82%E9%87%8D%E5%8F%A0%E7%9F%A9%E5%BD%A2%E7%9A%84%E9%9D%A2%E7%A7%AF/</link>
      <pubDate>Sat, 24 Jun 2017 19:51:32 +0000</pubDate>
      
      <guid>/post/%E6%B1%82%E9%87%8D%E5%8F%A0%E7%9F%A9%E5%BD%A2%E7%9A%84%E9%9D%A2%E7%A7%AF/</guid>
      <description>LeetCode 223. Rectangle Area Find the total area covered by two rectilinear rectangles in a 2D plane. Each rectangle is defined by its bottom left corner and top right corner as shown in the figure. 解析： 求出两个区域的面积, 然后减去overlapping的区域, 即为所</description>
    </item>
    
    <item>
      <title>天际线扫描</title>
      <link>/post/%E5%A4%A9%E9%99%85%E7%BA%BF%E6%89%AB%E6%8F%8F/</link>
      <pubDate>Sat, 24 Jun 2017 19:51:24 +0000</pubDate>
      
      <guid>/post/%E5%A4%A9%E9%99%85%E7%BA%BF%E6%89%AB%E6%8F%8F/</guid>
      <description>LeetCode 218. The Skyline Problem A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B). The geometric</description>
    </item>
    
    <item>
      <title>H-Index</title>
      <link>/post/h-index/</link>
      <pubDate>Sat, 24 Jun 2017 19:51:15 +0000</pubDate>
      
      <guid>/post/h-index/</guid>
      <description>LeetCode 274. H-Index Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index. According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have</description>
    </item>
    
    <item>
      <title>同构字符串</title>
      <link>/post/%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sat, 24 Jun 2017 19:51:07 +0000</pubDate>
      
      <guid>/post/%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>LeetCode 205. Isomorphic Strings Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. For example, Given “egg</description>
    </item>
    
    <item>
      <title>设计RandomPool结构</title>
      <link>/post/%E8%AE%BE%E8%AE%A1randompool%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sat, 24 Jun 2017 19:50:58 +0000</pubDate>
      
      <guid>/post/%E8%AE%BE%E8%AE%A1randompool%E7%BB%93%E6%9E%84/</guid>
      <description>LeetCode 380. Insert Delete GetRandom O(1) Design a data structure that supports all following operations in average O(1) time. insert(val): Inserts an item val to the set if not already present. remove(val): Removes an item val from the set if present. getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned. Example: 1 2 3 4 5 6 7 8</description>
    </item>
    
    <item>
      <title>查找一条直线上的最多点个数</title>
      <link>/post/%E6%9F%A5%E6%89%BE%E4%B8%80%E6%9D%A1%E7%9B%B4%E7%BA%BF%E4%B8%8A%E7%9A%84%E6%9C%80%E5%A4%9A%E7%82%B9%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Sat, 24 Jun 2017 19:50:25 +0000</pubDate>
      
      <guid>/post/%E6%9F%A5%E6%89%BE%E4%B8%80%E6%9D%A1%E7%9B%B4%E7%BA%BF%E4%B8%8A%E7%9A%84%E6%9C%80%E5%A4%9A%E7%82%B9%E4%B8%AA%E6%95%B0/</guid>
      <description>LeetCode 149. Max Points on a Line Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. 解析： 坑点1 如果直线是和y轴平行的，那么不能直接用(y1-y2)/(x1-x2)表示斜</description>
    </item>
    
    <item>
      <title>设计缓存结构</title>
      <link>/post/%E8%AE%BE%E8%AE%A1%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sat, 24 Jun 2017 19:50:14 +0000</pubDate>
      
      <guid>/post/%E8%AE%BE%E8%AE%A1%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84/</guid>
      <description>LeetCode 146. LRU Cache Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should</description>
    </item>
    
    <item>
      <title>查找区间最大值</title>
      <link>/post/%E6%9F%A5%E6%89%BE%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC/</link>
      <pubDate>Sat, 24 Jun 2017 19:49:49 +0000</pubDate>
      
      <guid>/post/%E6%9F%A5%E6%89%BE%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC/</guid>
      <description>LeetCode 162. Find Peak Element A peak element is an element that is greater than its neighbors. Given an input array where num[i] ≠ num[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that num[-1] = num[n] = -∞. For example, in array [1, 2,</description>
    </item>
    
    <item>
      <title>二叉树的序列化与反序列化</title>
      <link>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Sat, 24 Jun 2017 16:12:28 +0000</pubDate>
      
      <guid>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>LeetCode 297. Serialize and Deserialize Binary Tree Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your</description>
    </item>
    
    <item>
      <title>Bulls and Cows</title>
      <link>/post/bulls-and-cows/</link>
      <pubDate>Sat, 24 Jun 2017 16:12:15 +0000</pubDate>
      
      <guid>/post/bulls-and-cows/</guid>
      <description>LeetCode 299. Bulls and Cows You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”)</description>
    </item>
    
    <item>
      <title>随时找到数据流的中位数</title>
      <link>/post/%E9%9A%8F%E6%97%B6%E6%89%BE%E5%88%B0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Sat, 24 Jun 2017 16:12:04 +0000</pubDate>
      
      <guid>/post/%E9%9A%8F%E6%97%B6%E6%89%BE%E5%88%B0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid>
      <description>LeetCode 295. Find Median from Data Stream Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. Examples: [2,3,4] , the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void</description>
    </item>
    
    <item>
      <title>区间查询问题</title>
      <link>/post/%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Jun 2017 16:11:52 +0000</pubDate>
      
      <guid>/post/%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 303. Range Sum Query - Immutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -&amp;gt; 1 sumRange(2, 5) -&amp;gt; -1 sumRange(0, 5) -&amp;gt; -3 Note: You may assume that the array does not change. There are many calls to sumRange function. 解析： 数</description>
    </item>
    
    <item>
      <title>Queue Reconstruction by Height</title>
      <link>/post/queue-reconstruction-by-height/</link>
      <pubDate>Sat, 24 Jun 2017 16:11:38 +0000</pubDate>
      
      <guid>/post/queue-reconstruction-by-height/</guid>
      <description>LeetCode 406. Queue Reconstruction by Height Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue. Note: The number of</description>
    </item>
    
    <item>
      <title>开关灯</title>
      <link>/post/%E5%BC%80%E5%85%B3%E7%81%AF/</link>
      <pubDate>Sat, 24 Jun 2017 16:11:28 +0000</pubDate>
      
      <guid>/post/%E5%BC%80%E5%85%B3%E7%81%AF/</guid>
      <description>LeetCode 319. Bulb Switcher There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it’s off or turning off if it’s on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last</description>
    </item>
    
    <item>
      <title>换钱</title>
      <link>/post/%E6%8D%A2%E9%92%B1/</link>
      <pubDate>Sat, 24 Jun 2017 16:11:15 +0000</pubDate>
      
      <guid>/post/%E6%8D%A2%E9%92%B1/</guid>
      <description>LeetCode 322. Coin Change You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: coins = [1, 2, 5], amount = 11 return 3 (11 = 5 + 5</description>
    </item>
    
    <item>
      <title>Patching Array</title>
      <link>/post/patching-array/</link>
      <pubDate>Sat, 24 Jun 2017 16:11:04 +0000</pubDate>
      
      <guid>/post/patching-array/</guid>
      <description>LeetCode 330. Patching Array Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required. Example 1: nums = [1, 3], n = 6 Return 1. Combinations of nums are [1], [3], [1,3], which form possible sums</description>
    </item>
    
    <item>
      <title>Reconstruct Itinerary</title>
      <link>/post/reconstruct-itinerary/</link>
      <pubDate>Sat, 24 Jun 2017 16:10:53 +0000</pubDate>
      
      <guid>/post/reconstruct-itinerary/</guid>
      <description>LeetCode 332. Reconstruct Itinerary Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example,</description>
    </item>
    
    <item>
      <title>Self Crossing</title>
      <link>/post/self-crossing/</link>
      <pubDate>Sat, 24 Jun 2017 16:10:42 +0000</pubDate>
      
      <guid>/post/self-crossing/</guid>
      <description>LeetCode 335. Self Crossing You are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x[1] metres to the west, x[2] metres to the south, x[3] metres to the east and so on. In other words, after each move your direction changes counter-clockwise. Write a one-pass algorithm with O(1) extra space to determine, if your path crosses itself,</description>
    </item>
    
    <item>
      <title>Nested List</title>
      <link>/post/nested-list/</link>
      <pubDate>Sat, 24 Jun 2017 16:10:30 +0000</pubDate>
      
      <guid>/post/nested-list/</guid>
      <description>LeetCode 341. Flatten Nested List Iterator Given a nested list of integers, implement an iterator to flatten it. Each element is either an integer, or a list – whose elements may also be integers or other lists. Example 1: Given the list [[1,1],2,[1,1]], By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. Example 2: Given the list [1,[4,[6]]], By calling next</description>
    </item>
    
    <item>
      <title>翻转字符串</title>
      <link>/post/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sat, 24 Jun 2017 16:10:18 +0000</pubDate>
      
      <guid>/post/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>LeetCode 344. Reverse String Write a function that takes a string as input and returns the string reversed. Example: Given s = “hello”, return “olleh”. 解析：双指针，从两端向中间移动，并交换元素。 1 2 3 4 5 6 7 8 9</description>
    </item>
    
    <item>
      <title>设计Twitter</title>
      <link>/post/%E8%AE%BE%E8%AE%A1twitter/</link>
      <pubDate>Sat, 24 Jun 2017 16:09:40 +0000</pubDate>
      
      <guid>/post/%E8%AE%BE%E8%AE%A1twitter/</guid>
      <description>LeetCode 355. Design Twitter Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user’s news feed. Your design should support the following methods: postTweet(userId, tweetId): Compose a new tweet. getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user’s news feed. Each</description>
    </item>
    
    <item>
      <title>洗牌问题</title>
      <link>/post/%E6%B4%97%E7%89%8C%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Jun 2017 15:38:28 +0000</pubDate>
      
      <guid>/post/%E6%B4%97%E7%89%8C%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 384. Shuffle an Array Shuffle a set of numbers without duplicates. Example: 1 2 3 4 5 6 7 8 9 10 11 12 // Init an array with set 1, 2, and 3. int[] nums = {1,2,3}; Solution solution = new Solution(nums); // Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned. solution.shuffle(); // Resets the array back to</description>
    </item>
    
    <item>
      <title>字符串的统计形式</title>
      <link>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%BD%A2%E5%BC%8F/</link>
      <pubDate>Sat, 24 Jun 2017 15:38:19 +0000</pubDate>
      
      <guid>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%BD%A2%E5%BC%8F/</guid>
      <description>字符串的统计字符串 题目: 给定一个字符串str，返回str的统计字符串。例如，&amp;ldquo;aaabbadddffc&amp;quot;的统计字符串为</description>
    </item>
    
    <item>
      <title>树的叶子节点</title>
      <link>/post/%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sat, 24 Jun 2017 15:38:08 +0000</pubDate>
      
      <guid>/post/%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9/</guid>
      <description>LeetCode 404. Sum of Left Leaves Find the sum of all left leaves in a given binary tree. Example: 3 / 9 20 / 15 7 There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24. 解析： 判断一个节点是否为左叶子节点: 1.是父节点的左孩</description>
    </item>
    
    <item>
      <title>Fizz Buzz</title>
      <link>/post/fizz-buzz/</link>
      <pubDate>Sat, 24 Jun 2017 15:37:53 +0000</pubDate>
      
      <guid>/post/fizz-buzz/</guid>
      <description>412. Fizz Buzz Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”</description>
    </item>
    
    <item>
      <title>Arithmetic Slices</title>
      <link>/post/arithmetic-slices/</link>
      <pubDate>Sat, 24 Jun 2017 15:34:35 +0000</pubDate>
      
      <guid>/post/arithmetic-slices/</guid>
      <description>LeetCode 413. Arithmetic Slices Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the “Pacific ocean” touches the left and top edges of the matrix and the “Atlantic ocean” touches the right and bottom edges.</description>
    </item>
    
    <item>
      <title>Pacific Atlantic Water Flow</title>
      <link>/post/pacific-atlantic-water-flow/</link>
      <pubDate>Sat, 24 Jun 2017 15:34:21 +0000</pubDate>
      
      <guid>/post/pacific-atlantic-water-flow/</guid>
      <description>LeetCode 417. Pacific Atlantic Water Flow A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequence: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 The following sequence is not arithmetic. 1, 1, 2, 5, 7 A zero-indexed array A consisting of N</description>
    </item>
    
    <item>
      <title>密码检查器</title>
      <link>/post/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</link>
      <pubDate>Sat, 24 Jun 2017 15:32:59 +0000</pubDate>
      
      <guid>/post/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</guid>
      <description>LeetCode 420. Strong Password Checker A password is considered strong if below conditions are all met: It has at least 6 characters and at most 20 characters. It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit. It must NOT contain three repeating characters in a row (“…aaa…” is weak, but “…aa</description>
    </item>
    
    <item>
      <title>两个数组的相交数字</title>
      <link>/post/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E4%BA%A4%E6%95%B0%E5%AD%97/</link>
      <pubDate>Sat, 24 Jun 2017 15:31:24 +0000</pubDate>
      
      <guid>/post/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E4%BA%A4%E6%95%B0%E5%AD%97/</guid>
      <description>LeetCode 349. Intersection of Two Arrays Given two arrays, write a function to compute their intersection. Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2]. Note: Each element in the result must be unique. The result can be in any order. 解析： 因为要求结果元素不重复，所以采用unord</description>
    </item>
    
    <item>
      <title>多态实现机制详解</title>
      <link>/post/%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 24 Jun 2017 14:39:11 +0000</pubDate>
      
      <guid>/post/%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</guid>
      <description>数据成员指针、函数成员指针 1. 数据成员指针 对于普通指针变量来说，其值是它所指向的地址，0表示空指针。 而对于数据成员指针变量来说，其值是数据成员</description>
    </item>
    
    <item>
      <title>日常编程技巧</title>
      <link>/post/%E6%97%A5%E5%B8%B8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Sat, 24 Jun 2017 14:34:25 +0000</pubDate>
      
      <guid>/post/%E6%97%A5%E5%B8%B8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/</guid>
      <description>创建三维数组 vector法 vector&amp;lt;vector&amp;lt;vector&amp;gt; &amp;gt; f(N+1,vector&amp;lt;vector&amp;gt;(N,vector(N))); 第一维 第二维 第三维和类型 1维容量 2维数组正常构建方式:vector&amp;lt;vector&amp;gt;(N,vect</description>
    </item>
    
    <item>
      <title>不使用vector保存bool的理由</title>
      <link>/post/%E4%B8%8D%E4%BD%BF%E7%94%A8vector-bool-%E7%9A%84%E7%90%86%E7%94%B1/</link>
      <pubDate>Sat, 24 Jun 2017 14:32:28 +0000</pubDate>
      
      <guid>/post/%E4%B8%8D%E4%BD%BF%E7%94%A8vector-bool-%E7%9A%84%E7%90%86%E7%94%B1/</guid>
      <description>转载：http://blog.csdn.net/u013249689/article/details/25297657 vector不是容器，</description>
    </item>
    
    <item>
      <title>C&#43;&#43;编译不了的C程序</title>
      <link>/post/c-%E7%BC%96%E8%AF%91%E4%B8%8D%E4%BA%86%E7%9A%84c%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sat, 24 Jun 2017 14:07:24 +0000</pubDate>
      
      <guid>/post/c-%E7%BC%96%E8%AF%91%E4%B8%8D%E4%BA%86%E7%9A%84c%E7%A8%8B%E5%BA%8F/</guid>
      <description>有些C程序用C++编译器会报错，有如下几种情况： 函数声明在使用之后： 1 2 3 4 5 6 7 8 9 10 11 #include&amp;lt;stdio.h&amp;gt; int main() { foo(); // foo() is called before its declaration/definition } int foo() { printf(&amp;#34;Hello&amp;#34;); return 0; } 普通指针指</description>
    </item>
    
    <item>
      <title>new/delete用法详解</title>
      <link>/post/new-delete%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 24 Jun 2017 13:58:33 +0000</pubDate>
      
      <guid>/post/new-delete%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</guid>
      <description>new运算符 开辟单变量地址空间 使用new运算符时必须已知数据类型，new运算符会向系统堆区申请足够的存储空间，如果申请成功，就返回该内存块的</description>
    </item>
    
    <item>
      <title>assert()用法</title>
      <link>/post/assert-%E7%94%A8%E6%B3%95/</link>
      <pubDate>Sat, 24 Jun 2017 13:53:26 +0000</pubDate>
      
      <guid>/post/assert-%E7%94%A8%E6%B3%95/</guid>
      <description>定义 assert()的用法是一种“契约式编程”，在我的理解中，其表达的意思就是，程序在我的假设条件下，能够正常良好的运作，其实就相当于一个i</description>
    </item>
    
    <item>
      <title>STL中的Traits编程技法</title>
      <link>/post/stl%E4%B8%AD%E7%9A%84traits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95/</link>
      <pubDate>Sat, 24 Jun 2017 13:42:17 +0000</pubDate>
      
      <guid>/post/stl%E4%B8%AD%E7%9A%84traits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95/</guid>
      <description>在STL实现中，traits编程技术得到大量的运用，它利用了“内嵌类型”的编程技巧与C++的template参数推导功能，弥补了C++类型识</description>
    </item>
    
    <item>
      <title>strcpy、strncpy、memcpy和memmove浅析</title>
      <link>/post/strcpystrncpymemcpy%E5%92%8Cmemmove%E6%B5%85%E6%9E%90/</link>
      <pubDate>Sat, 24 Jun 2017 13:23:32 +0000</pubDate>
      
      <guid>/post/strcpystrncpymemcpy%E5%92%8Cmemmove%E6%B5%85%E6%9E%90/</guid>
      <description>前言 本文仅对函数本身进行分析，不考虑编译环境的差异。 例如关于strcpy，memcpy和memmove关于内存重叠的问题，各个编译器和库都对</description>
    </item>
    
    <item>
      <title>内存泄漏和内存溢出</title>
      <link>/post/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</link>
      <pubDate>Sat, 24 Jun 2017 13:21:42 +0000</pubDate>
      
      <guid>/post/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</guid>
      <description>内存溢出和内存泄漏的区别 内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个</description>
    </item>
    
    <item>
      <title>new和malloc的区别</title>
      <link>/post/new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 24 Jun 2017 13:15:15 +0000</pubDate>
      
      <guid>/post/new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>1. 申请的内存所在位置 new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区</description>
    </item>
    
    <item>
      <title>在1G内存的计算机中能否malloc(1.2G)</title>
      <link>/post/%E5%9C%A81g%E5%86%85%E5%AD%98%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E8%83%BD%E5%90%A6malloc-1-2g/</link>
      <pubDate>Sat, 24 Jun 2017 13:11:52 +0000</pubDate>
      
      <guid>/post/%E5%9C%A81g%E5%86%85%E5%AD%98%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E8%83%BD%E5%90%A6malloc-1-2g/</guid>
      <description>malloc能够申请的空间大小与物理内存的大小没有直接关系，仅与程序的虚拟地址空间相关。程序运行时，堆空间只是程序向操作系统申请划出来的一大</description>
    </item>
    
    <item>
      <title>指针和引用的区别</title>
      <link>/post/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 24 Jun 2017 12:18:41 +0000</pubDate>
      
      <guid>/post/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>转载：http://www.cnblogs.com/jiu0821/p/4127382.html 概念 指针是一块内存的地址值，而引用是一块内存</description>
    </item>
    
    <item>
      <title>C/C&#43;&#43;源代码到可执行程序的过程详解</title>
      <link>/post/c-c-%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 24 Jun 2017 11:55:03 +0000</pubDate>
      
      <guid>/post/c-c-%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</guid>
      <description>1.预处理 读取c源程序，对其中的伪指令（以#开头的指令）和特殊符号进行处理 伪指令主要包括以下四个方面: 宏定义指令，如#define Name Toke</description>
    </item>
    
    <item>
      <title>缓冲区溢出(Buffer Overflow)</title>
      <link>/post/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA-buffer-overflow/</link>
      <pubDate>Sat, 24 Jun 2017 11:44:54 +0000</pubDate>
      
      <guid>/post/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA-buffer-overflow/</guid>
      <description>堆栈溢出 堆栈溢出通常是所有的缓冲区溢出中最容易进行利用的。了解堆栈溢出之前，先了解以下几个概念： 缓冲区 简单说来是一块连续的计算机内存区域，可</description>
    </item>
    
    <item>
      <title>迭代器和指针的区别</title>
      <link>/post/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 24 Jun 2017 11:42:56 +0000</pubDate>
      
      <guid>/post/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>迭代器： 迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&amp;gt;,*,++ –等封装了指针，</description>
    </item>
    
    <item>
      <title>STL迭代器特性及失效问题</title>
      <link>/post/stl%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%89%B9%E6%80%A7%E5%8F%8A%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Jun 2017 11:21:22 +0000</pubDate>
      
      <guid>/post/stl%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%89%B9%E6%80%A7%E5%8F%8A%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</guid>
      <description>vector vector是一个顺序容器，在内存中是一块连续的内存。引起内存重新分配的插入运算使所有迭代器失效，插入也使得插入位置及其后位置的迭代器失效</description>
    </item>
    
    <item>
      <title>STL中的快速排序改进版——内省排序</title>
      <link>/post/stl%E4%B8%AD%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%94%B9%E8%BF%9B%E7%89%88%E5%86%85%E7%9C%81%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 24 Jun 2017 11:19:44 +0000</pubDate>
      
      <guid>/post/stl%E4%B8%AD%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%94%B9%E8%BF%9B%E7%89%88%E5%86%85%E7%9C%81%E6%8E%92%E5%BA%8F/</guid>
      <description>快速排序是一种很快的算法，它平均的时间复杂度WieO(nlgn)， 最坏时间复杂度为O(n^2)。但是快排有很多改良版，其中一种就是内省式的快</description>
    </item>
    
    <item>
      <title>拷贝构造函数详解</title>
      <link>/post/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 24 Jun 2017 11:00:59 +0000</pubDate>
      
      <guid>/post/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</guid>
      <description>什么是拷贝构造函数 首先对于普通类型的对象来说，它们之间的复制是很简单的，例如： int a = 100; int b = a; 而类对象与普通对象不同，类对象内部结构一般较为</description>
    </item>
    
    <item>
      <title>空类产生几个默认成员函数?</title>
      <link>/post/%E7%A9%BA%E7%B1%BB%E4%BA%A7%E7%94%9F%E5%87%A0%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 24 Jun 2017 10:46:36 +0000</pubDate>
      
      <guid>/post/%E7%A9%BA%E7%B1%BB%E4%BA%A7%E7%94%9F%E5%87%A0%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</guid>
      <description>空类声明时不会生成任何默认成员函数 对于空类，编译器不会生成任何默认成员函数，只会生成1个字节的占位符。 有时可能会以为编译器会为空类生成默认构</description>
    </item>
    
    <item>
      <title>解析“inline”</title>
      <link>/post/%E8%A7%A3%E6%9E%90inline/</link>
      <pubDate>Sat, 24 Jun 2017 10:34:27 +0000</pubDate>
      
      <guid>/post/%E8%A7%A3%E6%9E%90inline/</guid>
      <description>inline与宏定义 inline 关键字用来定义一个类的内联函数，引入它的主要原因是用它替代C中表达式形式的宏定义。为什么inline能很好地取代预定义</description>
    </item>
    
    <item>
      <title>性能杀手：”潜伏”的memset</title>
      <link>/post/%E6%80%A7%E8%83%BD%E6%9D%80%E6%89%8B%E6%BD%9C%E4%BC%8F%E7%9A%84memset/</link>
      <pubDate>Sat, 24 Jun 2017 10:27:08 +0000</pubDate>
      
      <guid>/post/%E6%80%A7%E8%83%BD%E6%9D%80%E6%89%8B%E6%BD%9C%E4%BC%8F%E7%9A%84memset/</guid>
      <description>memset性能陷阱 memset是大家常用的函数，而且一般的编程书籍都会谆谆告诫大家：申请内存后要初始化，防止使用未经初始化的内存导致不可预</description>
    </item>
    
    <item>
      <title>详解char类型</title>
      <link>/post/%E8%AF%A6%E8%A7%A3char%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 24 Jun 2017 10:24:21 +0000</pubDate>
      
      <guid>/post/%E8%AF%A6%E8%A7%A3char%E7%B1%BB%E5%9E%8B/</guid>
      <description>概述 char用来定义字符型变量，在内存中占1字节，范围是-128~127. 有以下两种存储方式： 将一个整型常量放到一个字符变量中，实际就是把以</description>
    </item>
    
    <item>
      <title>解析“mutable</title>
      <link>/post/%E8%A7%A3%E6%9E%90mutable/</link>
      <pubDate>Sat, 24 Jun 2017 09:58:38 +0000</pubDate>
      
      <guid>/post/%E8%A7%A3%E6%9E%90mutable/</guid>
      <description>在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中</description>
    </item>
    
    <item>
      <title>解析“volatile”</title>
      <link>/post/%E8%A7%A3%E6%9E%90volatile/</link>
      <pubDate>Sat, 24 Jun 2017 09:53:31 +0000</pubDate>
      
      <guid>/post/%E8%A7%A3%E6%9E%90volatile/</guid>
      <description>volatile概述 volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到</description>
    </item>
    
    <item>
      <title>C&#43;&#43;中的强制类型转换</title>
      <link>/post/c-%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Fri, 23 Jun 2017 21:33:06 +0000</pubDate>
      
      <guid>/post/c-%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description>C/C++是强类型语言,不同类型之间的相互转换是比较麻烦的.但是在编程实践中,不可避免的要用到类型转换.有2种类型转换:隐式类型转换和强制类</description>
    </item>
    
    <item>
      <title>字符串的输入输出</title>
      <link>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</link>
      <pubDate>Fri, 23 Jun 2017 21:10:17 +0000</pubDate>
      
      <guid>/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</guid>
      <description>scanf与printf scanf 原型：int scanf(char *format,&amp;hellip;]); 头文件：stdio.h 返回值：返回成功读入的数据项的个数，读到文件末尾或者出错时则返回EOF（0x</description>
    </item>
    
    <item>
      <title>printf()输出格式控制</title>
      <link>/post/printf-%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Fri, 23 Jun 2017 20:46:36 +0000</pubDate>
      
      <guid>/post/printf-%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6/</guid>
      <description>格式化 格式化字符串 格式化整型数值 格式化浮点值（普通计数法） 格式化浮点值（科学计数法） 补充：E是exponent,表示以10为底的指数 prin</description>
    </item>
    
    <item>
      <title>STL迭代器及辅助函数</title>
      <link>/post/stl%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8F%8A%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 23 Jun 2017 20:41:10 +0000</pubDate>
      
      <guid>/post/stl%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8F%8A%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/</guid>
      <description>迭代器类型 辅助函数 本文介绍了STL中的迭代器辅助函数的用法及注意事项，这些迭代器辅助函数包括：begin,end,advance, next (since C++11), prev (since</description>
    </item>
    
    <item>
      <title>作用域与{}</title>
      <link>/post/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E/</link>
      <pubDate>Fri, 23 Jun 2017 20:33:54 +0000</pubDate>
      
      <guid>/post/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E/</guid>
      <description>在C/C++中大括号指明了变量的作用域，在大括号内声明的局部变量其作用域自变量声明始，到大括号之后终结。我们应该善用它，使我们的程序更加清晰</description>
    </item>
    
    <item>
      <title>int32_t,int64_t</title>
      <link>/post/int32-t-int64-t/</link>
      <pubDate>Fri, 23 Jun 2017 20:27:13 +0000</pubDate>
      
      <guid>/post/int32-t-int64-t/</guid>
      <description>数据类型 数据类型特别是int相关的类型在不同位数机器的平台下长度不同。C99标准并不规定具体数据类型的长度大小，只规定级别。作下比较： 16位</description>
    </item>
    
    <item>
      <title>字符集和编码</title>
      <link>/post/%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E7%BC%96%E7%A0%81/</link>
      <pubDate>Fri, 23 Jun 2017 20:21:32 +0000</pubDate>
      
      <guid>/post/%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E7%BC%96%E7%A0%81/</guid>
      <description>1、字符集与字符编码 字符是各种文字和符号的总称，包括各个国家文字、标点符号、图形符号、数字等。字符集是多个字符的集合，字符集种类较多，每个字</description>
    </item>
    
    <item>
      <title>解析“const”</title>
      <link>/post/%E8%A7%A3%E6%9E%90const/</link>
      <pubDate>Fri, 23 Jun 2017 20:08:52 +0000</pubDate>
      
      <guid>/post/%E8%A7%A3%E6%9E%90const/</guid>
      <description>const的用法 修饰变量 修饰常量 与变量不同，有const修饰的量是常量，常量的值不可改变，在定义的时候必须初始化，使用未初始化的常量是错误的</description>
    </item>
    
    <item>
      <title>C&#43;&#43;的万能头文件</title>
      <link>/post/c-%E7%9A%84%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6/</link>
      <pubDate>Fri, 23 Jun 2017 20:06:44 +0000</pubDate>
      
      <guid>/post/c-%E7%9A%84%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6/</guid>
      <description>所谓的C++万能头文件，缺点是编译时间慢，优点无需多说。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include&amp;lt;bits/stdc++.h&amp;gt</description>
    </item>
    
    <item>
      <title>解析“extern”</title>
      <link>/post/%E8%A7%A3%E6%9E%90extern/</link>
      <pubDate>Fri, 23 Jun 2017 17:43:54 +0000</pubDate>
      
      <guid>/post/%E8%A7%A3%E6%9E%90extern/</guid>
      <description>基本解释 extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外e</description>
    </item>
    
    <item>
      <title>前向声明</title>
      <link>/post/%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E/</link>
      <pubDate>Fri, 23 Jun 2017 17:37:17 +0000</pubDate>
      
      <guid>/post/%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E/</guid>
      <description>定义 有些时候我们可以声明一些类但是并不去定义它，当然这个类的作用也很有限了。 比如class foo; 声明一个foo类，这个声明，有时候也叫做前向声明</description>
    </item>
    
    <item>
      <title>友元浅析</title>
      <link>/post/%E5%8F%8B%E5%85%83%E6%B5%85%E6%9E%90/</link>
      <pubDate>Fri, 23 Jun 2017 17:31:04 +0000</pubDate>
      
      <guid>/post/%E5%8F%8B%E5%85%83%E6%B5%85%E6%9E%90/</guid>
      <description>友元函数的简单介绍 为什么要使用友元函数 在实现类之间数据共享时，减少系统开销，提高效率。如果类A中的函数要访问类B中的成员（例如：智能指针类的</description>
    </item>
    
    <item>
      <title>访问控制与继承</title>
      <link>/post/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Fri, 23 Jun 2017 17:25:18 +0000</pubDate>
      
      <guid>/post/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/</guid>
      <description>成员的访问权限 public访问权限 一个类的public成员变量、成员函数，可以通过类的成员函数、类的实例变量进行访问 &amp;lt;实际上，类的成员</description>
    </item>
    
    <item>
      <title>编译错误和运行错误的区别</title>
      <link>/post/%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E5%92%8C%E8%BF%90%E8%A1%8C%E9%94%99%E8%AF%AF%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 23 Jun 2017 17:23:03 +0000</pubDate>
      
      <guid>/post/%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E5%92%8C%E8%BF%90%E8%A1%8C%E9%94%99%E8%AF%AF%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>（1） 编译错误： 就是编译器无法进行继续编译的错误，最基本的就是语法错误了，比如语句后面少了；或者 } 不匹配之类的，选择题一般是这样。编译错误可</description>
    </item>
    
    <item>
      <title>类内特殊成员变量的初始化</title>
      <link>/post/%E7%B1%BB%E5%86%85%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Fri, 23 Jun 2017 17:21:01 +0000</pubDate>
      
      <guid>/post/%E7%B1%BB%E5%86%85%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>有些成员变量的数据类型比较特别，它们的初始化方式也和普通数据类型的成员变量有所不同。这些特殊的类型的成员变量包括： a.引用 b.常量 c.静态 d</description>
    </item>
    
    <item>
      <title>仿函数和函数指针</title>
      <link>/post/%E4%BB%BF%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</link>
      <pubDate>Fri, 23 Jun 2017 17:11:28 +0000</pubDate>
      
      <guid>/post/%E4%BB%BF%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</guid>
      <description>函数指针 函数指针：是指向函数的指针变量，在C编译时，每一个函数都有一个入口地址，那么这个指向这个函数的函数指针便指向这个地址。 函数指针的用途</description>
    </item>
    
    <item>
      <title>Visual Studio中debug和release版本的区别</title>
      <link>/post/visual-studio%E4%B8%ADdebug%E5%92%8Crelease%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 23 Jun 2017 16:57:04 +0000</pubDate>
      
      <guid>/post/visual-studio%E4%B8%ADdebug%E5%92%8Crelease%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>本质区别 Debug 和 Release 并没有本质的区别，他们只是VC预定义提供的两组编译选项的集合，编译器只是按照预定的选项行动。如果我们愿意，我们完全可以把Deb</description>
    </item>
    
    <item>
      <title>C&#43;&#43;中临时对象及返回值优化</title>
      <link>/post/c-%E4%B8%AD%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/</link>
      <pubDate>Fri, 23 Jun 2017 16:30:48 +0000</pubDate>
      
      <guid>/post/c-%E4%B8%AD%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/</guid>
      <description>临时对象 C++中有这样一种对象：它在代码中看不到，但是确实存在。它就是临时对象—由编译器定义的一个没有命名的非堆对象（non-heap obj</description>
    </item>
    
    <item>
      <title>return语句的用法</title>
      <link>/post/return%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%94%A8%E6%B3%95/</link>
      <pubDate>Fri, 23 Jun 2017 16:21:57 +0000</pubDate>
      
      <guid>/post/return%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%94%A8%E6%B3%95/</guid>
      <description>含义 return 表示从被调函数返回到主调函数继续执行，返回时可附带一个返回值，返回值可以是一个常量，变量，或是表达式。 作用 结束正在运行的函数，并返回函</description>
    </item>
    
    <item>
      <title>C&#43;&#43;函数返回值问题</title>
      <link>/post/c-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 23 Jun 2017 16:16:12 +0000</pubDate>
      
      <guid>/post/c-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E9%97%AE%E9%A2%98/</guid>
      <description>调用函数的过程 栈空间是从高地址向低地址增长的。所以压栈即表示栈顶指针变小，而出栈则相反。 函数调用者维护了一个栈空间（stack），拥有栈底指</description>
    </item>
    
    <item>
      <title>string操作总结</title>
      <link>/post/string%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 23 Jun 2017 16:11:06 +0000</pubDate>
      
      <guid>/post/string%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
      <description>#构造函数 default (1) string(); copy (2) string (const string&amp;amp; str); substring (3) string (const string&amp;amp; str, size_t pos, size_t len = npos); from c-string (4) string (const char* s); from buffer (5) string (const char* s, size_t n); fill (6) string (size_t n, char c); range (7) template &amp;lt;class InputIterator&amp;gt; string (InputIterator first, InputIterator last); initializer list (8) string (initializer_list&amp;lt;char&amp;gt; il); move (9) string (string&amp;amp;&amp;amp; str)</description>
    </item>
    
    <item>
      <title>如何打印自身代码</title>
      <link>/post/%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B0%E8%87%AA%E8%BA%AB%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Fri, 23 Jun 2017 16:06:03 +0000</pubDate>
      
      <guid>/post/%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B0%E8%87%AA%E8%BA%AB%E4%BB%A3%E7%A0%81/</guid>
      <description>基本思想是： 在程序中生成字符串self; 加入把self改写成程序自身的算法编码; 输出self字符串。 1 2 3 #include &amp;lt;stdio.h&amp;gt;char* recurse=&amp;#34;#include &amp;lt;stdio.h&amp;gt;%cchar* recurse=%c%s%c;%cint main(){printf(recurse,10,34,recurse,34,10,10);}%c&amp;#34;; int main(){printf(recurse,10,34,recurse,34,10,10);} 解析： 引号里面的内</description>
    </item>
    
    <item>
      <title>位运算求绝对值</title>
      <link>/post/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%B1%82%E7%BB%9D%E5%AF%B9%E5%80%BC/</link>
      <pubDate>Fri, 23 Jun 2017 15:52:43 +0000</pubDate>
      
      <guid>/post/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%B1%82%E7%BB%9D%E5%AF%B9%E5%80%BC/</guid>
      <description>在对一个数进行位运算的时候，是在这个数的补码上进行的，对于补码我们知道，正数的补码是原码，负数的补码为原码除了最高位的符号位，取反，然后加1</description>
    </item>
    
    <item>
      <title>define详解</title>
      <link>/post/define%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 23 Jun 2017 15:45:27 +0000</pubDate>
      
      <guid>/post/define%E8%AF%A6%E8%A7%A3/</guid>
      <description>预处理 预处理也称为预编译，它为编译做预备工作，主要进行代码文本的替换工作，用于处理#开头的指令，其中预处理器产生编译器的输出。 经过预处理器处</description>
    </item>
    
    <item>
      <title>回调函数及其实现</title>
      <link>/post/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Fri, 23 Jun 2017 15:42:30 +0000</pubDate>
      
      <guid>/post/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</guid>
      <description>回调函数的定义 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数</description>
    </item>
    
    <item>
      <title>区别sizeof()和strlen()</title>
      <link>/post/%E5%8C%BA%E5%88%ABsizeof-%E5%92%8Cstrlen/</link>
      <pubDate>Fri, 23 Jun 2017 15:23:18 +0000</pubDate>
      
      <guid>/post/%E5%8C%BA%E5%88%ABsizeof-%E5%92%8Cstrlen/</guid>
      <description>区别 strlen执行的是一个计数器的工作，它从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，直到碰到</description>
    </item>
    
    <item>
      <title>结构体字节对齐详解</title>
      <link>/post/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 23 Jun 2017 15:00:13 +0000</pubDate>
      
      <guid>/post/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考：http://www.cnblogs.com/longlybits/articles/2385343.html 结构体中的字节对齐 在用s</description>
    </item>
    
    <item>
      <title>地址的类型转换和数学计算</title>
      <link>/post/%E5%9C%B0%E5%9D%80%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Fri, 23 Jun 2017 14:47:16 +0000</pubDate>
      
      <guid>/post/%E5%9C%B0%E5%9D%80%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97/</guid>
      <description>地址的类型转换 功能 对变量的值进行强制类型转换，是把值按照另外一种类型进行存储后读取，变量在内存中的存储形式发生变化. 对变量的地址进行强制类型</description>
    </item>
    
    <item>
      <title>C&#43;&#43;程序内存分配形式</title>
      <link>/post/c-%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%BD%A2%E5%BC%8F/</link>
      <pubDate>Fri, 23 Jun 2017 14:32:37 +0000</pubDate>
      
      <guid>/post/c-%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%BD%A2%E5%BC%8F/</guid>
      <description>程序中内存分配方式 (1) 正文段 (.text) 程序代码就存储在text 段，这是由C P U执行的机器指令部分。通常，正文段是可共享的，所以即使是经常执行的程序(如</description>
    </item>
    
  </channel>
</rss>