<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>基本原语panic和recover源码剖析 | Forz Blog</title>
<meta name="keywords" content="Go源码" />
<meta name="description" content="前言 本节将分析 Go 语言中两个经常成对出现的两个关键字 — panic 和 recover。这两个关键字与上一节提到的 defer 有紧密的联系，它们都是 Go 语言中的内置函数">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E8%AF%ADpanic%E5%92%8Crecover%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="基本原语panic和recover源码剖析" />
<meta property="og:description" content="前言 本节将分析 Go 语言中两个经常成对出现的两个关键字 — panic 和 recover。这两个关键字与上一节提到的 defer 有紧密的联系，它们都是 Go 语言中的内置函数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E8%AF%ADpanic%E5%92%8Crecover%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-06-20T20:28:45&#43;00:00" />
<meta property="article:modified_time" content="2021-06-20T20:28:45&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="基本原语panic和recover源码剖析"/>
<meta name="twitter:description" content="前言 本节将分析 Go 语言中两个经常成对出现的两个关键字 — panic 和 recover。这两个关键字与上一节提到的 defer 有紧密的联系，它们都是 Go 语言中的内置函数"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "基本原语panic和recover源码剖析",
      "item": "/post/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E8%AF%ADpanic%E5%92%8Crecover%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "基本原语panic和recover源码剖析",
  "name": "基本原语panic和recover源码剖析",
  "description": "前言 本节将分析 Go 语言中两个经常成对出现的两个关键字 — panic 和 recover。这两个关键字与上一节提到的 defer 有紧密的联系，它们都是 Go 语言中的内置函数",
  "keywords": [
    "Go源码"
  ],
  "articleBody": "前言 本节将分析 Go 语言中两个经常成对出现的两个关键字 — panic 和 recover。这两个关键字与上一节提到的 defer 有紧密的联系，它们都是 Go 语言中的内置函数，也提供了互补的功能。\n panic 能够改变程序的控制流，调用 panic 后会立刻停止执行当前函数的剩余代码，并在当前 Goroutine 中递归执行调用方的 defer； recover 可以中止 panic 造成的程序崩溃。它是一个只能在 defer 中发挥作用的函数，在其他作用域中调用不会发挥作用；  现象 我们先通过几个例子了解一下使用 panic 和 recover 关键字时遇到的现象，部分现象也与上一节分析的 defer 关键字有关：\n panic 只会触发当前 Goroutine 的 defer； recover 只有在 defer 中调用才会生效； panic 允许在 defer 中嵌套多次调用；  跨协程失效 首先要介绍的现象是 panic 只会触发当前 Goroutine 的延迟函数调用，我们可以通过如下所示的代码了解该现象：\n1 2 3 4 5 6 7 8 9  func main() { defer println(\"in main\") go func() { defer println(\"in goroutine\") panic(\"\") }() time.Sleep(1 * time.Second) }   1 2 3 4  $ go run main.go in goroutine panic: ...   当我们运行这段代码时会发现 main 函数中的 defer 语句并没有执行，执行的只有当前 Goroutine 中的 defer。\n前面我们曾经介绍过 defer 关键字对应的 runtime.deferproc 会将延迟调用函数与调用方所在 Goroutine 进行关联。所以当程序发生崩溃时只会调用当前 Goroutine 的延迟调用函数也是非常合理的。\n如上图所示，多个 Goroutine 之间没有太多的关联，一个 Goroutine 在 panic 时也不应该执行其他 Goroutine 的延迟函数。\n失效的崩溃恢复 初学 Go 语言的读者可能会写出下面的代码，在主程序中调用 recover 试图中止程序的崩溃，但是从运行的结果中我们也能看出，下面的程序没有正常退出。\n1 2 3 4 5 6 7 8  func main() { defer fmt.Println(\"in main\") if err := recover(); err != nil { fmt.Println(err) } panic(\"unknown err\") }   1 2 3 4 5 6 7 8  $ go run main.go in main panic: unknown err goroutine 1 [running]: main.main() ... exit status 2   仔细分析一下这个过程就能理解这种现象背后的原因，recover 只有在发生 panic 之后调用才会生效。然而在上面的控制流中，recover 是在 panic 之前调用的，并不满足生效的条件，所以我们需要在 defer 中使用 recover 关键字。\n嵌套崩溃 Go 语言中的 panic 是可以多次嵌套调用的。一些熟悉 Go 语言的读者很可能也不知道这个知识点，如下所示的代码就展示了如何在 defer 函数中多次调用 panic：\n1 2 3 4 5 6 7 8 9 10 11  func main() { defer fmt.Println(\"in main\") defer func() { defer func() { panic(\"panic again and again\") }() panic(\"panic again\") }() panic(\"panic once\") }   1 2 3 4 5 6 7 8 9  $ go run main.go in main panic: panic once panic: panic again panic: panic again and again goroutine 1 [running]: ... exit status 2   从上述程序输出的结果，我们可以确定程序多次调用 panic 也不会影响 defer 函数的正常执行，所以使用 defer 进行收尾工作一般来说都是安全的。\n汇编代码 最好的方式当然是了解编译器究竟做了什么事情：\n1 2 3 4 5 6 7 8  package main func main() { defer func() { recover() }() panic(nil) }   其汇编的形式为：\n1 2 3 4 5 6 7  TEXT main.main(SB) /Users/changkun/dev/go-under-the-hood/demo/7-lang/panic/main.go (...) main.go:7\t0x104e05b\t0f57c0\tXORPS X0, X0 main.go:7\t0x104e05e\t0f110424\tMOVUPS X0, 0(SP) main.go:7\t0x104e062\te8d935fdff\tCALL runtime.gopanic(SB) main.go:7\t0x104e067\t0f0b\tUD2 (...)   可以看到 panic 这个关键词本质上只是一个 runtime.gopanic 调用。\n而与之对应的 recover 则：\n1 2 3 4 5 6  TEXT main.main.func1(SB) /Users/changkun/dev/go-under-the-hood/demo/7-lang/panic/main.go (...) main.go:5\t0x104e09d\t488d442428\tLEAQ 0x28(SP), AX main.go:5\t0x104e0a2\t48890424\tMOVQ AX, 0(SP) main.go:5\t0x104e0a6\te8153bfdff\tCALL runtime.gorecover(SB) (...)   其实也只是一个 runtime.gorecover 调用。\n数据结构 panic 关键字在 Go 语言的源代码是由数据结构 runtime._panic 表示的。每当我们调用 panic 都会创建一个如下所示的数据结构存储相关信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  // A _panic holds information about an active panic. // // A _panic value must only ever live on the stack. // // The argp and link fields are stack pointers, but don't need special // handling during stack growth: because they are pointer-typed and // _panic values only live on the stack, regular stack pointer // adjustment takes care of them. // _panic 保存了一个活跃的 panic // // 这个标记了 go:notinheap 因为 _panic 的值必须位于栈上 // // argp 和 link 字段为栈指针，但在栈增长时不需要特殊处理：因为他们是指针类型且 // _panic 值只位于栈上，正常的栈指针调整会处理他们。 // //go:notinheap type _panic struct { // argp 是指向 defer 调用时参数的指针； \t// panic 期间 defer 调用参数的指针; 无法移动 - liblink 已知 \targp unsafe.Pointer // pointer to arguments of deferred call run during panic; cannot move - known to liblink \t// arg 是调用 panic 时传入的参数； \targ interface{} // argument to panic \t// link 指向了更早调用的 runtime._panic 结构； \t// link 链接到更早的 panic \tlink *_panic // link to earlier panic \tpc uintptr // where to return to in runtime if this panic is bypassed \tsp unsafe.Pointer // where to return to in runtime if this panic is bypassed \t// recovered 表示当前 runtime._panic 是否被 recover 恢复 \t// 表明 panic 是否结束 \trecovered bool // whether this panic is over \t// aborted 表示当前的 panic 是否被强行终止； \t// 表明 panic 是否忽略 \taborted bool // the panic was aborted \tgoexit bool }   从数据结构中的 link 字段我们就可以推测出以下的结论：panic 函数可以被连续多次调用，它们之间通过 link 可以组成链表。\n结构体中的 pc、sp 和 goexit 三个字段都是为了修复 runtime.Goexit 带来的问题引入的。runtime.Goexit 能够只结束调用该函数的 Goroutine 而不影响其他的 Goroutine，但是该函数会被 defer 中的 panic 和 recover 取消，引入这三个字段就是为了保证该函数的一定会生效。\npanic 这里先介绍分析 panic 函数是终止程序的实现原理。在处理 panic 期间，会先判断当前 panic 的类型，确定 panic 是否可恢复。编译器会将关键字 panic 转换成 runtime.gopanic，该函数的执行过程包含以下几个步骤：\n 创建新的 runtime._panic 并添加到所在 Goroutine 的_panic 链表的最前面； 在循环中不断从当前 Goroutine 的 _defer 中链表获取 runtime._defer 并调用 runtime.reflectcall 运行延迟调用函数； 如果recovered=true,执行程序的恢复; 调用 runtime.fatalpanic 中止整个程序；  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214  // The implementation of the predeclared function panic. func gopanic(e interface{}) { gp := getg() // 判断在系统栈上还是在用户栈上 \t// 如果执行在系统或信号栈时，getg() 会返回当前 m 的 g0 或 gsignal \t// 因此可以通过 gp.m.curg == gp 来判断所在栈 \t// 系统栈上的 panic 无法恢复 \tif gp.m.curg != gp { print(\"panic: \") // 打印 \tprintany(e) // 打印 \tprint(\"\\n\") // 继续打印，下同 \tthrow(\"panic on system stack\") } // 如果正在进行 malloc 时发生 panic 也无法恢复 \tif gp.m.mallocing != 0 { print(\"panic: \") printany(e) print(\"\\n\") throw(\"panic during malloc\") } // 在禁止抢占时发生 panic 也无法恢复 \tif gp.m.preemptoff != \"\" { print(\"panic: \") printany(e) print(\"\\n\") print(\"preempt off reason: \") print(gp.m.preemptoff) print(\"\\n\") throw(\"panic during preemptoff\") } // 在 g 锁在 m 上时发生 panic 也无法恢复 \tif gp.m.locks != 0 { print(\"panic: \") printany(e) print(\"\\n\") throw(\"panic holding locks\") } // 其他情况，panic 可以从运行时进行恢复，这时候会创建一个 _panic 实例。_panic 类型 定义了一个 _panic 链表 \tvar p _panic p.arg = e p.link = gp._panic gp._panic = (*_panic)(noescape(unsafe.Pointer(\u0026p))) atomic.Xadd(\u0026runningPanicDefers, 1) // By calculating getcallerpc/getcallersp here, we avoid scanning the \t// gopanic frame (stack scanning is slow...) \taddOneOpenDeferFrame(gp, getcallerpc(), unsafe.Pointer(getcallersp())) // 接下来开始逐一调用当前 goroutine 的 defer 方法， 检查用户态代码是否需要对 panic 进行恢复： \t// 首先，当 panic 发生时，如果错误是可恢复的错误，那么 会逐一遍历该 goroutine 对应 defer 链表中的 defer 函数链表，直到 defer 遍历完毕、 或者再次进入调度循环（recover 的 mcall 调用） 后才会停止。 \tfor { // 开始逐个取当前 goroutine 的 defer 调用 \td := gp._defer // 如果没有 defer 调用，则跳出循环 \tif d == nil { break } // If defer was started by earlier panic or Goexit (and, since we're back here, that triggered a new panic), \t// take defer off list. An earlier panic will not continue running, but we will make sure below that an \t// earlier Goexit does continue running. \t// 如果 defer 是由早期的 panic 或 Goexit 开始的（并且，因为我们回到这里，这引发了新的 panic）， \t// 则将 defer 带离链表。更早的 panic 或 Goexit 将无法继续运行。 \tif d.started { if d._panic != nil { d._panic.aborted = true } d._panic = nil if !d.openDefer { // For open-coded defers, we need to process the \t// defer again, in case there are any other defers \t// to call in the frame (not including the defer \t// call that caused the panic). \td.fn = nil gp._defer = d.link freedefer(d) continue } } // Mark defer as started, but keep on list, so that traceback \t// can find and update the defer's argument frame if stack growth \t// or a garbage collection happens before reflectcall starts executing d.fn. \t// 如果栈增长或者垃圾回收在 reflectcall 开始执行 d.fn 前发生 \t// 标记 defer 已经开始执行，但仍将其保存在列表中，从而 traceback 可以找到并更新这个 defer 的参数帧 \td.started = true // Record the panic that is running the defer. \t// If there is a new panic during the deferred call, that panic \t// will find d in the list and will mark d._panic (this panic) aborted. \t// 记录正在运行 defer 的 panic。如果在 defer 调用期间出现新的 panic，该 panic 将在列表中 \t// 找到 d 并标记 d._panic（该 panic）中止。 \td._panic = (*_panic)(noescape(unsafe.Pointer(\u0026p))) done := true if d.openDefer { done = runOpenDeferFrame(gp, d) if done \u0026\u0026 !d._panic.recovered { addOneOpenDeferFrame(gp, 0, nil) } } else { p.argp = unsafe.Pointer(getargp(0)) reflectcall(nil, unsafe.Pointer(d.fn), deferArgs(d), uint32(d.siz), uint32(d.siz)) } p.argp = nil // reflectcall did not panic. Remove d. \t// reflectcall 不会 panic. 移出 d. \tif gp._defer != d { throw(\"bad defer entry in panic\") } d._panic = nil // trigger shrinkage to test stack copy. See stack_test.go:TestStackPanic \t//GC()  pc := d.pc // 必须是指针，以便在栈复制期间进行调整 \tsp := unsafe.Pointer(d.sp) // must be pointer so it gets adjusted during stack copy \tif done { d.fn = nil gp._defer = d.link freedefer(d) } // 执行延迟调用函数，可能会设置 p.recovered = true \tif p.recovered { gp._panic = p.link if gp._panic != nil \u0026\u0026 gp._panic.goexit \u0026\u0026 gp._panic.aborted { // 从 runtime._defer 中取出了程序计数器 pc 和栈指针 sp 并调用 runtime.recovery 函数触发 Goroutine 的调度，调度之前会准备好 sp、pc 以及函数的返回值： \t// A normal recover would bypass/abort the Goexit. Instead, \t// we return to the processing loop of the Goexit. \tgp.sigcode0 = uintptr(gp._panic.sp) gp.sigcode1 = uintptr(gp._panic.pc) mcall(recovery) throw(\"bypassed recovery failed\") // mcall should not return \t} atomic.Xadd(\u0026runningPanicDefers, -1) // Remove any remaining non-started, open-coded \t// defer entries after a recover, since the \t// corresponding defers will be executed normally \t// (inline). Any such entry will become stale once \t// we run the corresponding defers inline and exit \t// the associated stack frame. \td := gp._defer var prev *_defer if !done { // Skip our current frame, if not done. It is \t// needed to complete any remaining defers in \t// deferreturn() \tprev = d d = d.link } for d != nil { if d.started { // This defer is started but we \t// are in the middle of a \t// defer-panic-recover inside of \t// it, so don't remove it or any \t// further defer entries \tbreak } if d.openDefer { if prev == nil { gp._defer = d.link } else { prev.link = d.link } newd := d.link freedefer(d) d = newd } else { prev = d d = d.link } } gp._panic = p.link // Aborted panics are marked but remain on the g.panic list. \t// Remove them from the list. \t// 忽略的 panic 会被标记，但仍然保留在 g.panic 列表中 \t// 这里将它们移出列表 \tfor gp._panic != nil \u0026\u0026 gp._panic.aborted { gp._panic = gp._panic.link } if gp._panic == nil { // must be done with signal\t// 必须由 signal 完成 \tgp.sig = 0 } // Pass information about recovering frame to recovery. \t// 传递关于恢复帧的信息 \tgp.sigcode0 = uintptr(sp) gp.sigcode1 = pc // 调用 recover，并重新进入调度循环，不再返回 \tmcall(recovery) // 如果无法重新进入调度循环，则无法恢复错误 \tthrow(\"recovery failed\") // mcall should not return \t} } // 当然如果所有的 defer 都没有指明显式的 recover，那么这时候则直接在运行时抛出 panic 信息： \t// 消耗完所有的 defer 调用，保守地进行 panic \t// 因为在冻结之后调用任意用户代码是不安全的，所以我们调用 preprintpanics 来调用 \t// 所有必要的 Error 和 String 方法来在 startpanic 之前准备 panic 字符串。 \t// ran out of deferred calls - old-school panic now \t// Because it is unsafe to call arbitrary user code after freezing \t// the world, we call preprintpanics to invoke all necessary Error \t// and String methods to prepare the panic strings before startpanic. \tpreprintpanics(gp._panic) fatalpanic(gp._panic) // should not return\t// 不应该返回 \t*(*int)(nil) = 0 // not reached\t// 无法触及 }   reflectcall defer 并非简单的遍历，每个在 panic 和 recover 之间的 defer 都会在这里通过 reflectcall 执行。\n1 2 3 4 5 6 7 8  // reflectcall 使用 arg 指向的 n 个参数字节的副本调用 fn。 // fn 返回后，reflectcall 在返回之前将 n-retoffset 结果字节复制回 arg+retoffset。 // 如果重新复制结果字节，则调用者应将参数帧类型作为 argtype 传递，以便该调用可以在复制期间执行适当的写障碍。 // reflect 包传递帧类型。在 runtime 包中，只有一个调用将结果复制回来，即 cgocallbackg1， // 并且它不传递帧类型，这意味着没有调用写障碍。参见该调用的页面了解相关理由。 // // 包 reflect 通过 linkname 访问此符号 func reflectcall(argtype *_type, fn, arg unsafe.Pointer, argsize uint32, retoffset uint32)   preprintpanics 至于 preprintpanics 和 fatalpanic 无非是一些错误输出，不再赘述：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // Call all Error and String methods before freezing the world. // Used when crashing with panicking. // 在停止前调用所有的 Error 和 String 方法 func preprintpanics(p *_panic) { defer func() { if recover() != nil { throw(\"panic while printing panic value\") } }() for p != nil { switch v := p.arg.(type) { case error: p.arg = v.Error() case stringer: p.arg = v.String() } p = p.link } }   至于 preprintpanics 和 fatalpanic 无非是一些错误输出，不再赘述：\nfatalpanic Go 语言在 1.14 通过 runtime: ensure that Goexit cannot be aborted by a recursive panic/recover 提交解决了递归 panic 和 recover 与 runtime.Goexit 的冲突。\nruntime.fatalpanic 实现了无法被恢复的程序崩溃，它在中止程序之前会通过 runtime.printpanics 打印出全部的 panic 消息以及调用时传入的参数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  // fatalpanic 实现了不可恢复的 panic。类似于 fatalthrow， // 要求如果 msgs != nil，则 fatalpanic 仍然能够打印 panic 的消息并在 main 在退出时候减少 runningPanicDefers。 // fatalpanic implements an unrecoverable panic. It is like fatalthrow, except // that if msgs != nil, fatalpanic also prints panic messages and decrements // runningPanicDefers once main is blocked from exiting. // //go:nosplit func fatalpanic(msgs *_panic) { pc := getcallerpc() sp := getcallersp() gp := getg() var docrash bool // Switch to the system stack to avoid any stack growth, which \t// may make things worse if the runtime is in a bad state. \t// 切换到系统栈来避免栈增长，如果运行时状态较差则可能导致更糟糕的事情 \tsystemstack(func() { if startpanic_m() \u0026\u0026 msgs != nil { // There were panic messages and startpanic_m \t// says it's okay to try to print them.  // startpanic_m set panicking, which will \t// block main from exiting, so now OK to \t// decrement runningPanicDefers. \t// 有 panic 消息和 startpanic_m 则可以尝试打印它们  // startpanic_m 设置 panic 会从阻止 main 的退出， \t// 因此现在可以开始减少 runningPanicDefers 了 \tatomic.Xadd(\u0026runningPanicDefers, -1) printpanics(msgs) } docrash = dopanic_m(gp, pc, sp) }) if docrash { // By crashing outside the above systemstack call, debuggers \t// will not be confused when generating a backtrace. \t// Function crash is marked nosplit to avoid stack growth. \t// 通过在上述 systemstack 调用之外崩溃，调试器在生成回溯时不会混淆。 \t// 函数崩溃标记为 nosplit 以避免堆栈增长。 \tcrash() } // 从系统栈退出 \tsystemstack(func() { exit(2) }) // 不可达 \t*(*int)(nil) = 0 // not reached }   打印崩溃消息后会调用 runtime.exit 退出当前程序并返回错误码 2，程序的正常退出也是通过 runtime.exit 实现的。\nrecovery 当 reflectcall 执行完毕后，这时如果一个 panic 是可恢复的，p.recovered 已经被标记为 true， 从而会通过 mcall 的方式来执行 recovery 函数来重新进入调度循环：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // 在发生 panic 后 defer 函数调用 recover 后展开栈。然后安排继续运行， // 就像 defer 函数的调用方正常返回一样。 func recovery(gp *g) { // 传递到 G 结构的 defer 信息 \tsp := gp.sigcode0 pc := gp.sigcode1 // 使 deferproc 为此 d 返回 \t// 这时候返回 1。调用函数将跳转到标准的返回尾声 \tgp.sched.sp = sp gp.sched.pc = pc gp.sched.lr = 0 gp.sched.ret = 1 gogo(\u0026gp.sched) }   当我们在调用 defer 关键字时，调用时的栈指针 sp 和程序计数器 pc 就已经存储到了 runtime._defer 结构体中，这里的 runtime.gogo 函数会跳回 defer 关键字调用的位置。\nruntime.recovery 在调度过程中会将函数的返回值设置成 1。从 runtime.deferproc 的注释中我们会发现，当 runtime.deferproc 函数的返回值是 1 时，编译器生成的代码会直接跳转到调用方函数返回之前并执行 runtime.deferreturn：\n1 2 3 4  func deferproc(siz int32, fn *funcval) { ... return0() }   跳转到 runtime.deferreturn 函数之后，程序就已经从 panic 中恢复了并执行正常的逻辑，而 runtime.gorecover 函数也能从 runtime._panic 结构中取出了调用 panic 时传入的 arg 参数并返回给调用方。\ngorecover 到这里我们已经掌握了 panic 退出程序的过程，接下来将分析 defer 中的 recover 是如何中止程序崩溃的。编译器会将关键字 recover 转换成 runtime.gorecover：\n如果reflectcall调起的某个defer函数包含了 recover 的调用（即 gorecover 调用）被执行，这时 _panic 实例 p.recovered 会被标记为 true：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // The implementation of the predeclared function recover. // Cannot split the stack because it needs to reliably // find the stack segment of its caller. // // TODO(rsc): Once we commit to CopyStackAlways, // this doesn't need to be nosplit. //go:nosplit func gorecover(argp uintptr) interface{} { // Must be in a function running as part of a deferred call during the panic. \t// Must be called from the topmost function of the call \t// (the function used in the defer statement). \t// p.argp is the argument pointer of that topmost deferred function call. \t// Compare against argp reported by caller. \t// If they match, the caller is the one who can recover. \t// 必须在 panic 期间作为 defer 调用的一部分在函数中运行。 \t// 必须从调用的最顶层函数（ defer 语句中使用的函数）调用。 \t// p.argp 是最顶层 defer 函数调用的参数指针。 \t// 比较调用方报告的 argp，如果匹配，则调用者可以恢复。 \tgp := getg() p := gp._panic if p != nil \u0026\u0026 !p.goexit \u0026\u0026 !p.recovered \u0026\u0026 argp == uintptr(p.argp) { p.recovered = true return p.arg } return nil }   同时 recover() 这个函数还会返回 panic 的保存相关信息 p.arg。 恢复的原则取决于 gorecover 这个方法调用方报告的 argp 是否与 p.argp 相同，仅当相同才可恢复。\n该函数的实现很简单，如果当前 Goroutine 没有调用 panic，那么该函数会直接返回 nil，这也是崩溃恢复在非 defer 中调用会失效的原因。在正常情况下，它会修改 runtime._panic 的 recovered 字段，runtime.gorecover 函数中并不包含恢复程序的逻辑，程序的恢复是由 runtime.gopanic 函数负责的\n小结 分析程序的崩溃和恢复过程比较棘手，代码不是特别容易理解。我们在本节的最后还是简单总结一下程序崩溃和恢复的过程：\n 编译器会负责做转换关键字的工作；  将 panic 和 recover 分别转换成 runtime.gopanic 和 runtime.gorecover； 将 defer 转换成 runtime.deferproc 函数； 在调用 defer 的函数末尾调用 runtime.deferreturn 函数；   在运行过程中遇到 runtime.gopanic 方法时，会从 Goroutine 的链表依次取出 runtime._defer 结构体并执行； 如果调用延迟执行函数时遇到了 runtime.gorecover 就会将_panic.recovered 标记成 true 并返回 panic 的参数；  在这次调用结束之后，runtime.gopanic 会从 runtime._defer 结构体中取出程序计数器 pc 和栈指针 sp 并调用 runtime.recovery 函数进行恢复程序； runtime.recovery 会根据传入的 pc 和 sp 跳转回 runtime.deferproc； 编译器自动生成的代码会发现 runtime.deferproc 的返回值不为 0，这时会跳回 runtime.deferreturn 并恢复到正常的执行流程；   如果没有遇到 runtime.gorecover 就会依次遍历所有的 runtime._defer，并在最后调用 runtime.fatalpanic 中止程序、打印 panic 的参数并返回错误码 2；  从 panic 和 recover 这对关键字的实现上可以看出，可恢复的 panic 必须要 recover 的配合。 而且，这个 recover 必须位于同一 goroutine 的直接调用链上（例如，如果 A 依次调用了 B 和 C，而 B 包含了 recover，而 C 发生了 panic，则这时 B 的 panic 无法恢复 C 的 panic； 又例如 A 调用了 B 而 B 又调用了 C，那么 C 发生 panic 时，如果 A 要求了 recover 则仍然可以恢复）， 否则无法对 panic 进行恢复。\n当一个 panic 被恢复后，调度并因此中断，会重新进入调度循环，进而继续执行 recover 后面的代码， 包括比 recover 更早的 defer（因为已经执行过得 defer 已经被释放， 而尚未执行的 defer 仍在 goroutine 的 defer 链表中），或者 recover 所在函数的调用方。\n参考 5.4 panic 和 recover\n9.3 恐慌与恢复内建函数\n",
  "wordCount" : "6274",
  "inLanguage": "zh-cn",
  "datePublished": "2021-06-20T20:28:45Z",
  "dateModified": "2021-06-20T20:28:45Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E8%AF%ADpanic%E5%92%8Crecover%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      基本原语panic和recover源码剖析
    </h1>
    <div class="post-meta">June 20, 2021
</div>
  </header> 
  <div class="post-content"><h2 id="前言">前言<a hidden class="anchor" aria-hidden="true" href="#前言">#</a></h2>
<p>本节将分析 Go 语言中两个经常成对出现的两个关键字 — panic 和 recover。这两个关键字与上一节提到的 defer 有紧密的联系，它们都是 Go 语言中的内置函数，也提供了互补的功能。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210620203725.png" alt=""  />
</p>
<ul>
<li>panic 能够改变程序的控制流，调用 panic 后会立刻停止执行当前函数的剩余代码，并在当前 Goroutine 中递归执行调用方的 defer；</li>
<li>recover 可以中止 panic 造成的程序崩溃。它是一个只能在 defer 中发挥作用的函数，在其他作用域中调用不会发挥作用；</li>
</ul>
<h2 id="现象">现象<a hidden class="anchor" aria-hidden="true" href="#现象">#</a></h2>
<p>我们先通过几个例子了解一下使用 panic 和 recover 关键字时遇到的现象，部分现象也与上一节分析的 defer 关键字有关：</p>
<ul>
<li>panic 只会触发当前 Goroutine 的 defer；</li>
<li>recover 只有在 defer 中调用才会生效；</li>
<li>panic 允许在 defer 中嵌套多次调用；</li>
</ul>
<h3 id="跨协程失效">跨协程失效<a hidden class="anchor" aria-hidden="true" href="#跨协程失效">#</a></h3>
<p>首先要介绍的现象是 panic 只会触发当前 Goroutine 的延迟函数调用，我们可以通过如下所示的代码了解该现象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nb">println</span><span class="p">(</span><span class="s">&#34;in main&#34;</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nb">println</span><span class="p">(</span><span class="s">&#34;in goroutine&#34;</span><span class="p">)</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">run</span> <span class="n">main.go</span>
<span class="n">in</span> <span class="n">goroutine</span>
<span class="n">panic</span><span class="o">:</span>
<span class="kc">...</span>
</code></pre></td></tr></table>
</div>
</div><p>当我们运行这段代码时会发现 main 函数中的 defer 语句并没有执行，执行的只有当前 Goroutine 中的 defer。</p>
<p>前面我们曾经介绍过 defer 关键字对应的 <code>runtime.deferproc</code> 会将延迟调用函数与调用方所在 Goroutine 进行关联。所以当程序发生崩溃时只会调用当前 Goroutine 的延迟调用函数也是非常合理的。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210621111653.png" alt=""  />
</p>
<p>如上图所示，多个 Goroutine 之间没有太多的关联，一个 Goroutine 在 panic 时也不应该执行其他 Goroutine 的延迟函数。</p>
<h3 id="失效的崩溃恢复">失效的崩溃恢复<a hidden class="anchor" aria-hidden="true" href="#失效的崩溃恢复">#</a></h3>
<p>初学 Go 语言的读者可能会写出下面的代码，在主程序中调用 recover 试图中止程序的崩溃，但是从运行的结果中我们也能看出，下面的程序没有正常退出。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;in main&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;unknown err&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">run</span> <span class="n">main.go</span>
<span class="n">in</span> <span class="n">main</span>
<span class="n">panic</span><span class="o">:</span> <span class="n">unknown</span> <span class="n">err</span>

<span class="n">goroutine</span> <span class="m">1</span> <span class="n">[running]</span><span class="o">:</span>
<span class="nf">main.main</span><span class="p">()</span>
	<span class="kc">...</span>
<span class="n">exit</span> <span class="n">status</span> <span class="m">2</span>
</code></pre></td></tr></table>
</div>
</div><p>仔细分析一下这个过程就能理解这种现象背后的原因，recover 只有在发生 panic 之后调用才会生效。然而在上面的控制流中，recover 是在 panic 之前调用的，并不满足生效的条件，所以我们需要在 defer 中使用 recover 关键字。</p>
<h3 id="嵌套崩溃">嵌套崩溃<a hidden class="anchor" aria-hidden="true" href="#嵌套崩溃">#</a></h3>
<p>Go 语言中的 panic 是可以多次嵌套调用的。一些熟悉 Go 语言的读者很可能也不知道这个知识点，如下所示的代码就展示了如何在 defer 函数中多次调用 panic：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;in main&#34;</span><span class="p">)</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;panic again and again&#34;</span><span class="p">)</span>
		<span class="p">}()</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;panic again&#34;</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;panic once&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">run</span> <span class="n">main.go</span>
<span class="n">in</span> <span class="n">main</span>
<span class="n">panic</span><span class="o">:</span> <span class="n">panic</span> <span class="n">once</span>
	<span class="n">panic</span><span class="o">:</span> <span class="n">panic</span> <span class="n">again</span>
	<span class="n">panic</span><span class="o">:</span> <span class="n">panic</span> <span class="n">again</span> <span class="n">and</span> <span class="n">again</span>

<span class="n">goroutine</span> <span class="m">1</span> <span class="n">[running]</span><span class="o">:</span>
<span class="kc">...</span>
<span class="n">exit</span> <span class="n">status</span> <span class="m">2</span>
</code></pre></td></tr></table>
</div>
</div><p>从上述程序输出的结果，我们可以确定程序多次调用 panic 也不会影响 defer 函数的正常执行，所以使用 defer 进行收尾工作一般来说都是安全的。</p>
<h2 id="汇编代码">汇编代码<a hidden class="anchor" aria-hidden="true" href="#汇编代码">#</a></h2>
<p>最好的方式当然是了解编译器究竟做了什么事情：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nb">recover</span><span class="p">()</span>
	<span class="p">}()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其汇编的形式为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">TEXT</span> <span class="nf">main.main</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span> <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">changkun</span><span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">go</span><span class="o">-</span><span class="n">under</span><span class="o">-</span><span class="n">the</span><span class="o">-</span><span class="n">hood</span><span class="o">/</span><span class="n">demo</span><span class="o">/</span><span class="m">7</span><span class="o">-</span><span class="n">lang</span><span class="o">/</span><span class="n">panic</span><span class="o">/</span><span class="nf">main.go
</span><span class="nf">  </span><span class="p">(</span><span class="kc">...</span><span class="p">)</span>
  <span class="n">main.go</span><span class="o">:</span><span class="m">7</span>		<span class="mh">0x104e05b</span>		<span class="m">0</span><span class="n">f57c0</span>			<span class="n">XORPS</span> <span class="n">X0</span><span class="p">,</span> <span class="n">X0</span>
  <span class="n">main.go</span><span class="o">:</span><span class="m">7</span>		<span class="mh">0x104e05e</span>		<span class="m">0</span><span class="n">f110424</span>		<span class="n">MOVUPS</span> <span class="n">X0</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
  <span class="n">main.go</span><span class="o">:</span><span class="m">7</span>		<span class="mh">0x104e062</span>		<span class="n">e8d935fdff</span>		<span class="n">CALL</span> <span class="nf">runtime.gopanic</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
  <span class="n">main.go</span><span class="o">:</span><span class="m">7</span>		<span class="mh">0x104e067</span>		<span class="m">0</span><span class="n">f0b</span>			<span class="nf">UD2
</span><span class="nf">  </span><span class="p">(</span><span class="kc">...</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到 panic 这个关键词本质上只是一个 runtime.gopanic 调用。</p>
<p>而与之对应的 recover 则：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">TEXT</span> <span class="nf">main.main.func1</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span> <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">changkun</span><span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">go</span><span class="o">-</span><span class="n">under</span><span class="o">-</span><span class="n">the</span><span class="o">-</span><span class="n">hood</span><span class="o">/</span><span class="n">demo</span><span class="o">/</span><span class="m">7</span><span class="o">-</span><span class="n">lang</span><span class="o">/</span><span class="n">panic</span><span class="o">/</span><span class="nf">main.go
</span><span class="nf">  </span><span class="p">(</span><span class="kc">...</span><span class="p">)</span>
  <span class="n">main.go</span><span class="o">:</span><span class="m">5</span>		<span class="mh">0x104e09d</span>		<span class="m">488</span><span class="n">d442428</span>		<span class="n">LEAQ</span> <span class="mh">0x28</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">AX</span>
  <span class="n">main.go</span><span class="o">:</span><span class="m">5</span>		<span class="mh">0x104e0a2</span>		<span class="m">48890424</span>		<span class="n">MOVQ</span> <span class="n">AX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
  <span class="n">main.go</span><span class="o">:</span><span class="m">5</span>		<span class="mh">0x104e0a6</span>		<span class="n">e8153bfdff</span>		<span class="n">CALL</span> <span class="nf">runtime.gorecover</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
  <span class="p">(</span><span class="kc">...</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>其实也只是一个 runtime.gorecover 调用。</p>
<h2 id="数据结构">数据结构<a hidden class="anchor" aria-hidden="true" href="#数据结构">#</a></h2>
<p>panic 关键字在 Go 语言的源代码是由数据结构 runtime._panic 表示的。每当我们调用 panic 都会创建一个如下所示的数据结构存储相关信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A _panic holds information about an active panic.
</span><span class="c1">//
</span><span class="c1">// A _panic value must only ever live on the stack.
</span><span class="c1">//
</span><span class="c1">// The argp and link fields are stack pointers, but don&#39;t need special
</span><span class="c1">// handling during stack growth: because they are pointer-typed and
</span><span class="c1">// _panic values only live on the stack, regular stack pointer
</span><span class="c1">// adjustment takes care of them.
</span><span class="c1">// _panic 保存了一个活跃的 panic
</span><span class="c1">//
</span><span class="c1">// 这个标记了 go:notinheap 因为 _panic 的值必须位于栈上
</span><span class="c1">//
</span><span class="c1">// argp 和 link 字段为栈指针，但在栈增长时不需要特殊处理：因为他们是指针类型且
</span><span class="c1">// _panic 值只位于栈上，正常的栈指针调整会处理他们。
</span><span class="c1">//
</span><span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">_panic</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// argp 是指向 defer 调用时参数的指针；
</span><span class="c1"></span>	<span class="c1">// panic 期间 defer 调用参数的指针; 无法移动 - liblink 已知
</span><span class="c1"></span>	<span class="nx">argp</span>      <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// pointer to arguments of deferred call run during panic; cannot move - known to liblink
</span><span class="c1"></span>	<span class="c1">// arg 是调用 panic 时传入的参数；
</span><span class="c1"></span>	<span class="nx">arg</span>       <span class="kd">interface</span><span class="p">{}</span>    <span class="c1">// argument to panic
</span><span class="c1"></span>	<span class="c1">// link 指向了更早调用的 runtime._panic 结构；
</span><span class="c1"></span>	<span class="c1">// link 链接到更早的 panic
</span><span class="c1"></span>	<span class="nx">link</span>      <span class="o">*</span><span class="nx">_panic</span>        <span class="c1">// link to earlier panic
</span><span class="c1"></span>	<span class="nx">pc</span>        <span class="kt">uintptr</span>        <span class="c1">// where to return to in runtime if this panic is bypassed
</span><span class="c1"></span>	<span class="nx">sp</span>        <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// where to return to in runtime if this panic is bypassed
</span><span class="c1"></span>	<span class="c1">// recovered 表示当前 runtime._panic 是否被 recover 恢复
</span><span class="c1"></span>	<span class="c1">// 表明 panic 是否结束
</span><span class="c1"></span>	<span class="nx">recovered</span> <span class="kt">bool</span>           <span class="c1">// whether this panic is over
</span><span class="c1"></span>	<span class="c1">// aborted 表示当前的 panic 是否被强行终止；
</span><span class="c1"></span>	<span class="c1">// 表明 panic 是否忽略
</span><span class="c1"></span>	<span class="nx">aborted</span>   <span class="kt">bool</span>           <span class="c1">// the panic was aborted
</span><span class="c1"></span>	<span class="nx">goexit</span>    <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从数据结构中的 link 字段我们就可以推测出以下的结论：panic 函数可以被连续多次调用，它们之间通过 link 可以组成链表。</p>
<p>结构体中的 pc、sp 和 goexit 三个字段都是为了修复 runtime.Goexit 带来的问题引入的。runtime.Goexit 能够只结束调用该函数的 Goroutine 而不影响其他的 Goroutine，但是该函数会被 defer 中的 panic 和 recover 取消，引入这三个字段就是为了保证该函数的一定会生效。</p>
<h2 id="panic">panic<a hidden class="anchor" aria-hidden="true" href="#panic">#</a></h2>
<p>这里先介绍分析 panic 函数是终止程序的实现原理。在处理 panic 期间，会先判断当前 panic 的类型，确定 panic 是否可恢复。编译器会将关键字 panic 转换成 runtime.gopanic，该函数的执行过程包含以下几个步骤：</p>
<ol>
<li>创建新的 runtime._panic 并添加到所在 Goroutine 的_panic 链表的最前面；</li>
<li>在循环中不断从当前 Goroutine 的 _defer 中链表获取 runtime._defer 并调用 runtime.reflectcall 运行延迟调用函数；</li>
<li>如果recovered=true,执行程序的恢复;</li>
<li>调用 runtime.fatalpanic 中止整个程序；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// The implementation of the predeclared function panic.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gopanic</span><span class="p">(</span><span class="nx">e</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="c1">// 判断在系统栈上还是在用户栈上
</span><span class="c1"></span>	<span class="c1">// 如果执行在系统或信号栈时，getg() 会返回当前 m 的 g0 或 gsignal
</span><span class="c1"></span>	<span class="c1">// 因此可以通过 gp.m.curg == gp 来判断所在栈
</span><span class="c1"></span>	<span class="c1">// 系统栈上的 panic 无法恢复
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="o">!=</span> <span class="nx">gp</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;panic: &#34;</span><span class="p">)</span> <span class="c1">// 打印
</span><span class="c1"></span>		<span class="nf">printany</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>      <span class="c1">// 打印
</span><span class="c1"></span>		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;\n&#34;</span><span class="p">)</span>      <span class="c1">// 继续打印，下同
</span><span class="c1"></span>		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;panic on system stack&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 如果正在进行 malloc 时发生 panic 也无法恢复
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mallocing</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;panic: &#34;</span><span class="p">)</span>
		<span class="nf">printany</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;panic during malloc&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 在禁止抢占时发生 panic 也无法恢复
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;panic: &#34;</span><span class="p">)</span>
		<span class="nf">printany</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;preempt off reason: &#34;</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptoff</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;panic during preemptoff&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 在 g 锁在 m 上时发生 panic 也无法恢复
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;panic: &#34;</span><span class="p">)</span>
		<span class="nf">printany</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;panic holding locks&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 其他情况，panic 可以从运行时进行恢复，这时候会创建一个 _panic 实例。_panic 类型 定义了一个 _panic 链表
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">p</span> <span class="nx">_panic</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">arg</span> <span class="p">=</span> <span class="nx">e</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">_panic</span><span class="p">)(</span><span class="nf">noescape</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">)))</span>

	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">runningPanicDefers</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

	<span class="c1">// By calculating getcallerpc/getcallersp here, we avoid scanning the
</span><span class="c1"></span>	<span class="c1">// gopanic frame (stack scanning is slow...)
</span><span class="c1"></span>	<span class="nf">addOneOpenDeferFrame</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nf">getcallerpc</span><span class="p">(),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nf">getcallersp</span><span class="p">()))</span>
	<span class="c1">// 接下来开始逐一调用当前 goroutine 的 defer 方法， 检查用户态代码是否需要对 panic 进行恢复：
</span><span class="c1"></span>	<span class="c1">// 首先，当 panic 发生时，如果错误是可恢复的错误，那么 会逐一遍历该 goroutine 对应 defer 链表中的 defer 函数链表，直到 defer 遍历完毕、 或者再次进入调度循环（recover 的 mcall 调用） 后才会停止。
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// 开始逐个取当前 goroutine 的 defer 调用
</span><span class="c1"></span>		<span class="nx">d</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span>
		<span class="c1">// 如果没有 defer 调用，则跳出循环
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">d</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>

		<span class="c1">// If defer was started by earlier panic or Goexit (and, since we&#39;re back here, that triggered a new panic),
</span><span class="c1"></span>		<span class="c1">// take defer off list. An earlier panic will not continue running, but we will make sure below that an
</span><span class="c1"></span>		<span class="c1">// earlier Goexit does continue running.
</span><span class="c1"></span>		<span class="c1">// 如果 defer 是由早期的 panic 或 Goexit 开始的（并且，因为我们回到这里，这引发了新的 panic），
</span><span class="c1"></span>		<span class="c1">// 则将 defer 带离链表。更早的 panic 或 Goexit 将无法继续运行。
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">started</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">_panic</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">d</span><span class="p">.</span><span class="nx">_panic</span><span class="p">.</span><span class="nx">aborted</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="p">}</span>
			<span class="nx">d</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">d</span><span class="p">.</span><span class="nx">openDefer</span> <span class="p">{</span>
				<span class="c1">// For open-coded defers, we need to process the
</span><span class="c1"></span>				<span class="c1">// defer again, in case there are any other defers
</span><span class="c1"></span>				<span class="c1">// to call in the frame (not including the defer
</span><span class="c1"></span>				<span class="c1">// call that caused the panic).
</span><span class="c1"></span>				<span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="p">=</span> <span class="kc">nil</span>
				<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>
				<span class="nf">freedefer</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
				<span class="k">continue</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// Mark defer as started, but keep on list, so that traceback
</span><span class="c1"></span>		<span class="c1">// can find and update the defer&#39;s argument frame if stack growth
</span><span class="c1"></span>		<span class="c1">// or a garbage collection happens before reflectcall starts executing d.fn.
</span><span class="c1"></span>		<span class="c1">// 如果栈增长或者垃圾回收在 reflectcall 开始执行 d.fn 前发生
</span><span class="c1"></span>		<span class="c1">// 标记 defer 已经开始执行，但仍将其保存在列表中，从而 traceback 可以找到并更新这个 defer 的参数帧
</span><span class="c1"></span>		<span class="nx">d</span><span class="p">.</span><span class="nx">started</span> <span class="p">=</span> <span class="kc">true</span>

		<span class="c1">// Record the panic that is running the defer.
</span><span class="c1"></span>		<span class="c1">// If there is a new panic during the deferred call, that panic
</span><span class="c1"></span>		<span class="c1">// will find d in the list and will mark d._panic (this panic) aborted.
</span><span class="c1"></span>		<span class="c1">// 记录正在运行 defer 的 panic。如果在 defer 调用期间出现新的 panic，该 panic 将在列表中
</span><span class="c1"></span>		<span class="c1">// 找到 d 并标记 d._panic（该 panic）中止。
</span><span class="c1"></span>		<span class="nx">d</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">_panic</span><span class="p">)(</span><span class="nf">noescape</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">)))</span>

		<span class="nx">done</span> <span class="o">:=</span> <span class="kc">true</span>
		<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">openDefer</span> <span class="p">{</span>
			<span class="nx">done</span> <span class="p">=</span> <span class="nf">runOpenDeferFrame</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">done</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">d</span><span class="p">.</span><span class="nx">_panic</span><span class="p">.</span><span class="nx">recovered</span> <span class="p">{</span>
				<span class="nf">addOneOpenDeferFrame</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">argp</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nf">getargp</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
			<span class="nf">reflectcall</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">fn</span><span class="p">),</span> <span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">siz</span><span class="p">),</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">siz</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">argp</span> <span class="p">=</span> <span class="kc">nil</span>

		<span class="c1">// reflectcall did not panic. Remove d.
</span><span class="c1"></span>		<span class="c1">// reflectcall 不会 panic. 移出 d.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="o">!=</span> <span class="nx">d</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad defer entry in panic&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">d</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="kc">nil</span>

		<span class="c1">// trigger shrinkage to test stack copy. See stack_test.go:TestStackPanic
</span><span class="c1"></span>		<span class="c1">//GC()
</span><span class="c1"></span>
		<span class="nx">pc</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">pc</span>
		<span class="c1">// 必须是指针，以便在栈复制期间进行调整
</span><span class="c1"></span>		<span class="nx">sp</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">sp</span><span class="p">)</span> <span class="c1">// must be pointer so it gets adjusted during stack copy
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">done</span> <span class="p">{</span>
			<span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>
			<span class="nf">freedefer</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 执行延迟调用函数，可能会设置 p.recovered = true
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">recovered</span> <span class="p">{</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">link</span>
			<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span><span class="p">.</span><span class="nx">goexit</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span><span class="p">.</span><span class="nx">aborted</span> <span class="p">{</span>
				<span class="c1">// 从 runtime._defer 中取出了程序计数器 pc 和栈指针 sp 并调用 runtime.recovery 函数触发 Goroutine 的调度，调度之前会准备好 sp、pc 以及函数的返回值：
</span><span class="c1"></span>				<span class="c1">// A normal recover would bypass/abort the Goexit.  Instead,
</span><span class="c1"></span>				<span class="c1">// we return to the processing loop of the Goexit.
</span><span class="c1"></span>				<span class="nx">gp</span><span class="p">.</span><span class="nx">sigcode0</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span><span class="p">.</span><span class="nx">sp</span><span class="p">)</span>
				<span class="nx">gp</span><span class="p">.</span><span class="nx">sigcode1</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span><span class="p">.</span><span class="nx">pc</span><span class="p">)</span>
				<span class="nf">mcall</span><span class="p">(</span><span class="nx">recovery</span><span class="p">)</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bypassed recovery failed&#34;</span><span class="p">)</span> <span class="c1">// mcall should not return
</span><span class="c1"></span>			<span class="p">}</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">runningPanicDefers</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

			<span class="c1">// Remove any remaining non-started, open-coded
</span><span class="c1"></span>			<span class="c1">// defer entries after a recover, since the
</span><span class="c1"></span>			<span class="c1">// corresponding defers will be executed normally
</span><span class="c1"></span>			<span class="c1">// (inline). Any such entry will become stale once
</span><span class="c1"></span>			<span class="c1">// we run the corresponding defers inline and exit
</span><span class="c1"></span>			<span class="c1">// the associated stack frame.
</span><span class="c1"></span>			<span class="nx">d</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span>
			<span class="kd">var</span> <span class="nx">prev</span> <span class="o">*</span><span class="nx">_defer</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">done</span> <span class="p">{</span>
				<span class="c1">// Skip our current frame, if not done. It is
</span><span class="c1"></span>				<span class="c1">// needed to complete any remaining defers in
</span><span class="c1"></span>				<span class="c1">// deferreturn()
</span><span class="c1"></span>				<span class="nx">prev</span> <span class="p">=</span> <span class="nx">d</span>
				<span class="nx">d</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>
			<span class="p">}</span>
			<span class="k">for</span> <span class="nx">d</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">started</span> <span class="p">{</span>
					<span class="c1">// This defer is started but we
</span><span class="c1"></span>					<span class="c1">// are in the middle of a
</span><span class="c1"></span>					<span class="c1">// defer-panic-recover inside of
</span><span class="c1"></span>					<span class="c1">// it, so don&#39;t remove it or any
</span><span class="c1"></span>					<span class="c1">// further defer entries
</span><span class="c1"></span>					<span class="k">break</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">openDefer</span> <span class="p">{</span>
					<span class="k">if</span> <span class="nx">prev</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
						<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="nx">prev</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>
					<span class="p">}</span>
					<span class="nx">newd</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>
					<span class="nf">freedefer</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
					<span class="nx">d</span> <span class="p">=</span> <span class="nx">newd</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nx">prev</span> <span class="p">=</span> <span class="nx">d</span>
					<span class="nx">d</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">link</span>
			<span class="c1">// Aborted panics are marked but remain on the g.panic list.
</span><span class="c1"></span>			<span class="c1">// Remove them from the list.
</span><span class="c1"></span>			<span class="c1">// 忽略的 panic 会被标记，但仍然保留在 g.panic 列表中
</span><span class="c1"></span>			<span class="c1">// 这里将它们移出列表
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span><span class="p">.</span><span class="nx">aborted</span> <span class="p">{</span>
				<span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span><span class="p">.</span><span class="nx">link</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// must be done with signal	// 必须由 signal 完成
</span><span class="c1"></span>				<span class="nx">gp</span><span class="p">.</span><span class="nx">sig</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="p">}</span>
			<span class="c1">// Pass information about recovering frame to recovery.
</span><span class="c1"></span>			<span class="c1">// 传递关于恢复帧的信息
</span><span class="c1"></span>			<span class="nx">gp</span><span class="p">.</span><span class="nx">sigcode0</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">sp</span><span class="p">)</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">sigcode1</span> <span class="p">=</span> <span class="nx">pc</span>
			<span class="c1">// 调用 recover，并重新进入调度循环，不再返回
</span><span class="c1"></span>			<span class="nf">mcall</span><span class="p">(</span><span class="nx">recovery</span><span class="p">)</span>
			<span class="c1">// 如果无法重新进入调度循环，则无法恢复错误
</span><span class="c1"></span>			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;recovery failed&#34;</span><span class="p">)</span> <span class="c1">// mcall should not return
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 当然如果所有的 defer 都没有指明显式的 recover，那么这时候则直接在运行时抛出 panic 信息：
</span><span class="c1"></span>	<span class="c1">// 消耗完所有的 defer 调用，保守地进行 panic
</span><span class="c1"></span>	<span class="c1">// 因为在冻结之后调用任意用户代码是不安全的，所以我们调用 preprintpanics 来调用
</span><span class="c1"></span>	<span class="c1">// 所有必要的 Error 和 String 方法来在 startpanic 之前准备 panic 字符串。
</span><span class="c1"></span>	<span class="c1">// ran out of deferred calls - old-school panic now
</span><span class="c1"></span>	<span class="c1">// Because it is unsafe to call arbitrary user code after freezing
</span><span class="c1"></span>	<span class="c1">// the world, we call preprintpanics to invoke all necessary Error
</span><span class="c1"></span>	<span class="c1">// and String methods to prepare the panic strings before startpanic.
</span><span class="c1"></span>	<span class="nf">preprintpanics</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span><span class="p">)</span>

	<span class="nf">fatalpanic</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span><span class="p">)</span> <span class="c1">// should not return	// 不应该返回
</span><span class="c1"></span>	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="kc">nil</span><span class="p">)</span> <span class="p">=</span> <span class="mi">0</span>      <span class="c1">// not reached	// 无法触及
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="reflectcall">reflectcall<a hidden class="anchor" aria-hidden="true" href="#reflectcall">#</a></h3>
<p>defer 并非简单的遍历，每个在 panic 和 recover 之间的 defer 都会在这里通过 reflectcall 执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// reflectcall 使用 arg 指向的 n 个参数字节的副本调用 fn。
</span><span class="c1">// fn 返回后，reflectcall 在返回之前将 n-retoffset 结果字节复制回 arg+retoffset。
</span><span class="c1">// 如果重新复制结果字节，则调用者应将参数帧类型作为 argtype 传递，以便该调用可以在复制期间执行适当的写障碍。
</span><span class="c1">// reflect 包传递帧类型。在 runtime 包中，只有一个调用将结果复制回来，即 cgocallbackg1，
</span><span class="c1">// 并且它不传递帧类型，这意味着没有调用写障碍。参见该调用的页面了解相关理由。
</span><span class="c1">//
</span><span class="c1">// 包 reflect 通过 linkname 访问此符号
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">reflectcall</span><span class="p">(</span><span class="nx">argtype</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">fn</span><span class="p">,</span> <span class="nx">arg</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">argsize</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">retoffset</span> <span class="kt">uint32</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="preprintpanics">preprintpanics<a hidden class="anchor" aria-hidden="true" href="#preprintpanics">#</a></h3>
<p>至于 preprintpanics 和 fatalpanic 无非是一些错误输出，不再赘述：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Call all Error and String methods before freezing the world.
</span><span class="c1">// Used when crashing with panicking.
</span><span class="c1">// 在停止前调用所有的 Error 和 String 方法
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">preprintpanics</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">_panic</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">recover</span><span class="p">()</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;panic while printing panic value&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="k">for</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="nx">v</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">arg</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="kt">error</span><span class="p">:</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">arg</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Error</span><span class="p">()</span>
		<span class="k">case</span> <span class="nx">stringer</span><span class="p">:</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">arg</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">link</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>至于 preprintpanics 和 fatalpanic 无非是一些错误输出，不再赘述：</p>
<h3 id="fatalpanic">fatalpanic<a hidden class="anchor" aria-hidden="true" href="#fatalpanic">#</a></h3>
<p>Go 语言在 1.14 通过 runtime: ensure that Goexit cannot be aborted by a recursive panic/recover 提交解决了递归 panic 和 recover 与 runtime.Goexit 的冲突。</p>
<p>runtime.fatalpanic 实现了无法被恢复的程序崩溃，它在中止程序之前会通过 runtime.printpanics 打印出全部的 panic 消息以及调用时传入的参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// fatalpanic 实现了不可恢复的 panic。类似于 fatalthrow，
</span><span class="c1">// 要求如果 msgs != nil，则 fatalpanic 仍然能够打印 panic 的消息并在 main 在退出时候减少 runningPanicDefers。
</span><span class="c1">// fatalpanic implements an unrecoverable panic. It is like fatalthrow, except
</span><span class="c1">// that if msgs != nil, fatalpanic also prints panic messages and decrements
</span><span class="c1">// runningPanicDefers once main is blocked from exiting.
</span><span class="c1">//
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">fatalpanic</span><span class="p">(</span><span class="nx">msgs</span> <span class="o">*</span><span class="nx">_panic</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">pc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
	<span class="nx">sp</span> <span class="o">:=</span> <span class="nf">getcallersp</span><span class="p">()</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="kd">var</span> <span class="nx">docrash</span> <span class="kt">bool</span>
	<span class="c1">// Switch to the system stack to avoid any stack growth, which
</span><span class="c1"></span>	<span class="c1">// may make things worse if the runtime is in a bad state.
</span><span class="c1"></span>	<span class="c1">// 切换到系统栈来避免栈增长，如果运行时状态较差则可能导致更糟糕的事情
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nf">startpanic_m</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">msgs</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// There were panic messages and startpanic_m
</span><span class="c1"></span>			<span class="c1">// says it&#39;s okay to try to print them.
</span><span class="c1"></span>
			<span class="c1">// startpanic_m set panicking, which will
</span><span class="c1"></span>			<span class="c1">// block main from exiting, so now OK to
</span><span class="c1"></span>			<span class="c1">// decrement runningPanicDefers.
</span><span class="c1"></span>			<span class="c1">// 有 panic 消息和 startpanic_m 则可以尝试打印它们
</span><span class="c1"></span>
			<span class="c1">// startpanic_m 设置 panic 会从阻止 main 的退出，
</span><span class="c1"></span>			<span class="c1">// 因此现在可以开始减少 runningPanicDefers 了
</span><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">runningPanicDefers</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

			<span class="nf">printpanics</span><span class="p">(</span><span class="nx">msgs</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nx">docrash</span> <span class="p">=</span> <span class="nf">dopanic_m</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="k">if</span> <span class="nx">docrash</span> <span class="p">{</span>
		<span class="c1">// By crashing outside the above systemstack call, debuggers
</span><span class="c1"></span>		<span class="c1">// will not be confused when generating a backtrace.
</span><span class="c1"></span>		<span class="c1">// Function crash is marked nosplit to avoid stack growth.
</span><span class="c1"></span>		<span class="c1">// 通过在上述 systemstack 调用之外崩溃，调试器在生成回溯时不会混淆。
</span><span class="c1"></span>		<span class="c1">// 函数崩溃标记为 nosplit 以避免堆栈增长。
</span><span class="c1"></span>		<span class="nf">crash</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 从系统栈退出
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="c1">// 不可达
</span><span class="c1"></span>	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="kc">nil</span><span class="p">)</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// not reached
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>打印崩溃消息后会调用 runtime.exit 退出当前程序并返回错误码 2，程序的正常退出也是通过 runtime.exit 实现的。</p>
<h3 id="recovery">recovery<a hidden class="anchor" aria-hidden="true" href="#recovery">#</a></h3>
<p>当 reflectcall 执行完毕后，这时如果一个 panic 是可恢复的，p.recovered 已经被标记为 true， 从而会通过 mcall 的方式来执行 recovery 函数来重新进入调度循环：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 在发生 panic 后 defer 函数调用 recover 后展开栈。然后安排继续运行，
</span><span class="c1">// 就像 defer 函数的调用方正常返回一样。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">recovery</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 传递到 G 结构的 defer 信息
</span><span class="c1"></span>	<span class="nx">sp</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sigcode0</span>
	<span class="nx">pc</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sigcode1</span>
	<span class="c1">// 使 deferproc 为此 d 返回
</span><span class="c1"></span>	<span class="c1">// 这时候返回 1。调用函数将跳转到标准的返回尾声
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nx">pc</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lr</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ret</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当我们在调用 defer 关键字时，调用时的栈指针 sp 和程序计数器 pc 就已经存储到了 <code>runtime._defer</code> 结构体中，这里的 <code>runtime.gogo</code> 函数会跳回 defer 关键字调用的位置。</p>
<p><code>runtime.recovery</code> 在调度过程中会将函数的返回值设置成 1。从 <code>runtime.deferproc</code> 的注释中我们会发现，当 <code>runtime.deferproc</code> 函数的返回值是 1 时，编译器生成的代码会直接跳转到调用方函数返回之前并执行 <code>runtime.deferreturn</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">deferproc</span><span class="p">(</span><span class="nx">siz</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nf">return0</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>跳转到 runtime.deferreturn 函数之后，程序就已经从 panic 中恢复了并执行正常的逻辑，而 runtime.gorecover 函数也能从 runtime._panic 结构中取出了调用 panic 时传入的 arg 参数并返回给调用方。</p>
<h2 id="gorecover">gorecover<a hidden class="anchor" aria-hidden="true" href="#gorecover">#</a></h2>
<p>到这里我们已经掌握了 panic 退出程序的过程，接下来将分析 defer 中的 recover 是如何中止程序崩溃的。编译器会将关键字 recover 转换成 <code>runtime.gorecover</code>：</p>
<p>如果reflectcall调起的某个defer函数包含了 recover 的调用（即 gorecover 调用）被执行，这时 _panic 实例 p.recovered 会被标记为 true：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// The implementation of the predeclared function recover.
</span><span class="c1">// Cannot split the stack because it needs to reliably
</span><span class="c1">// find the stack segment of its caller.
</span><span class="c1">//
</span><span class="c1">// TODO(rsc): Once we commit to CopyStackAlways,
</span><span class="c1">// this doesn&#39;t need to be nosplit.
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gorecover</span><span class="p">(</span><span class="nx">argp</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
	<span class="c1">// Must be in a function running as part of a deferred call during the panic.
</span><span class="c1"></span>	<span class="c1">// Must be called from the topmost function of the call
</span><span class="c1"></span>	<span class="c1">// (the function used in the defer statement).
</span><span class="c1"></span>	<span class="c1">// p.argp is the argument pointer of that topmost deferred function call.
</span><span class="c1"></span>	<span class="c1">// Compare against argp reported by caller.
</span><span class="c1"></span>	<span class="c1">// If they match, the caller is the one who can recover.
</span><span class="c1"></span>	<span class="c1">// 必须在 panic 期间作为 defer 调用的一部分在函数中运行。
</span><span class="c1"></span>	<span class="c1">// 必须从调用的最顶层函数（ defer 语句中使用的函数）调用。
</span><span class="c1"></span>	<span class="c1">// p.argp 是最顶层 defer 函数调用的参数指针。
</span><span class="c1"></span>	<span class="c1">// 比较调用方报告的 argp，如果匹配，则调用者可以恢复。
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span>
	<span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">p</span><span class="p">.</span><span class="nx">goexit</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">p</span><span class="p">.</span><span class="nx">recovered</span> <span class="o">&amp;&amp;</span> <span class="nx">argp</span> <span class="o">==</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">argp</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">recovered</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">arg</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>同时 recover() 这个函数还会返回 panic 的保存相关信息 p.arg。 恢复的原则取决于 gorecover 这个方法调用方报告的 argp 是否与 p.argp 相同，仅当相同才可恢复。</p>
<p>该函数的实现很简单，如果当前 Goroutine 没有调用 panic，那么该函数会直接返回 nil，这也是崩溃恢复在非 defer 中调用会失效的原因。在正常情况下，它会修改 runtime._panic 的 recovered 字段，runtime.gorecover 函数中并不包含恢复程序的逻辑，程序的恢复是由 runtime.gopanic 函数负责的</p>
<h2 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h2>
<p>分析程序的崩溃和恢复过程比较棘手，代码不是特别容易理解。我们在本节的最后还是简单总结一下程序崩溃和恢复的过程：</p>
<ol>
<li>编译器会负责做转换关键字的工作；
<ol>
<li>将 panic 和 recover 分别转换成 runtime.gopanic 和 runtime.gorecover；</li>
<li>将 defer 转换成 runtime.deferproc 函数；</li>
<li>在调用 defer 的函数末尾调用 runtime.deferreturn 函数；</li>
</ol>
</li>
<li>在运行过程中遇到 runtime.gopanic 方法时，会从 Goroutine 的链表依次取出 runtime._defer 结构体并执行；</li>
<li>如果调用延迟执行函数时遇到了 runtime.gorecover 就会将_panic.recovered 标记成 true 并返回 panic 的参数；
<ol>
<li>在这次调用结束之后，runtime.gopanic 会从 runtime._defer 结构体中取出程序计数器 pc 和栈指针 sp 并调用 runtime.recovery 函数进行恢复程序；</li>
<li>runtime.recovery 会根据传入的 pc 和 sp 跳转回 runtime.deferproc；</li>
<li>编译器自动生成的代码会发现 runtime.deferproc 的返回值不为 0，这时会跳回 runtime.deferreturn 并恢复到正常的执行流程；</li>
</ol>
</li>
<li>如果没有遇到 runtime.gorecover 就会依次遍历所有的 runtime._defer，并在最后调用 runtime.fatalpanic 中止程序、打印 panic 的参数并返回错误码 2；</li>
</ol>
<p>从 panic 和 recover 这对关键字的实现上可以看出，可恢复的 panic 必须要 recover 的配合。 而且，这个 recover 必须位于同一 goroutine 的直接调用链上（例如，如果 A 依次调用了 B 和 C，而 B 包含了 recover，而 C 发生了 panic，则这时 B 的 panic 无法恢复 C 的 panic； 又例如 A 调用了 B 而 B 又调用了 C，那么 C 发生 panic 时，如果 A 要求了 recover 则仍然可以恢复）， 否则无法对 panic 进行恢复。</p>
<p>当一个 panic 被恢复后，调度并因此中断，会重新进入调度循环，进而继续执行 recover 后面的代码， 包括比 recover 更早的 defer（因为已经执行过得 defer 已经被释放， 而尚未执行的 defer 仍在 goroutine 的 defer 链表中），或者 recover 所在函数的调用方。</p>
<h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<p><a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/">5.4 panic 和 recover</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch09lang/panic/">9.3 恐慌与恢复内建函数</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go%E6%BA%90%E7%A0%81/">Go源码</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
