<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>C&#43;&#43;中的强制类型转换 | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="C/C&#43;&#43;是强类型语言,不同类型之间的相互转换是比较麻烦的.但是在编程实践中,不可避免的要用到类型转换.有2种类型转换:隐式类型转换和强制类">
<meta name="author" content="">
<link rel="canonical" href="/post/c-%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="C&#43;&#43;中的强制类型转换" />
<meta property="og:description" content="C/C&#43;&#43;是强类型语言,不同类型之间的相互转换是比较麻烦的.但是在编程实践中,不可避免的要用到类型转换.有2种类型转换:隐式类型转换和强制类" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/c-%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-23T21:33:06&#43;00:00" />
<meta property="article:modified_time" content="2017-06-23T21:33:06&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43;中的强制类型转换"/>
<meta name="twitter:description" content="C/C&#43;&#43;是强类型语言,不同类型之间的相互转换是比较麻烦的.但是在编程实践中,不可避免的要用到类型转换.有2种类型转换:隐式类型转换和强制类"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "C++中的强制类型转换",
      "item": "/post/c-%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C++中的强制类型转换",
  "name": "C\u002b\u002b中的强制类型转换",
  "description": "C/C++是强类型语言,不同类型之间的相互转换是比较麻烦的.但是在编程实践中,不可避免的要用到类型转换.有2种类型转换:隐式类型转换和强制类",
  "keywords": [
    
  ],
  "articleBody": "C/C++是强类型语言,不同类型之间的相互转换是比较麻烦的.但是在编程实践中,不可避免的要用到类型转换.有2种类型转换:隐式类型转换和强制类型转换.\n隐式类型转换   提升精度,此种是编译器自动完成的,安全的.所以编译的时候不会有任何错误或者警告信息提示.\n short a=2000; int b; b=a;  short是两字节，int是四字节，由short型转成int型是宽化转换（bit位数增多），编译器没有warning.\n宽化转换（如char到int，int到long long，int到float，float到double，int到double等）构成隐式转换，编译器允许直接转换。\n  降低精度,也是有编译器自动完成,会造成精度丢失,所以编译时得到一个警告信息提示.\n double a=2000;\tshort b; b=a;  此时，是从8字节的double型转成2字节的short型变量，是窄化转换，编译器就会有warning了，提醒程序员可能丢失数据。不过需要注意的是，有些隐式转换，编译器可能并不给出warning，比如int到short，但数据溢出却依然会发生。\n  多态的上行转换。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include using namespace std; class A { // ...... }; class B : public A { // ...... }; int main() { B *pB = new B; A *pA = pB; // Safe and will succeed }   ``\n  任意类型指针到 void*, 都可以使用隐式类型转换，因为void*是通用指针。\n  非const对象转化为const对象，直接进行隐式转换。\n  注意:普通变量与指针不能隐式转换转换,比如int*和int不能发生隐式转换.\n隐式转换失败后会出现编译错误.\n显式类型转换 显式类型转换可以进行任何转换。\nC风格的强制转换(包括旧式C++风格的强制转换) 格式:\n类型(表达式); // 旧的C++风格 或者 (类型)表达式 // C风格 示例: int(dval) 或者 (int)dval  此种强制转换是比较粗暴直接的,有可能导致精度丢失(如从 double 转换为 int)或者一些莫名其妙的错误(如把 int 转换为 函数指针),一旦使用了强制转换,编译器将不提示任何警告.这也往往成为错误的源泉.而且这种错误非常难找.\nC++强制转换操作符 C++增加了4个关键字用于强制类型转换:\nstatic_cast, reinterpret_cast, const_cast 和 dynamic_cast.  static_cast(静态转换) static_cast的转换格式：static_cast (expression)\n将expression转换为type-id类型，比起强制类型转换提供了一定的安全性。在无关类的类指针之间转换上进行限制。主要用于非多态类型之间的转换，不提供运行时的检查来确保转换的安全性。\n静态转换的功能如下：\n  用于相关数据类型之间的转换，如基本数据类型中把int转换成char，把int转换成enum等等\n数值精度提高或者降低,包括把无符号型转换为带符号型(也是精度损失的一种),用 static_cast 可以消除编译器的警告信息。\n  静态转换能把void*指针转换成目标类型的指针，因为void*是通用指针，和其它指针有一定关系。\n  用于类层次结构中，基类和子类之间指针和引用的转换。但不推荐使用！\n当进行上行转换，也就是把子类的指针或引用转换成父类表示，这种转换是安全的；\n当进行下行转换，也就是把父类的指针或引用转换成子类表示，这种转换是不安全的，但编译可以通过，需要程序员来保证安全性；\n  注：static_cast不能转换掉expression的const、volatile和__unaligned属性。\ndynamic_cast（动态转换） dynamic_cast的转换格式：dynamic_cast (expression)\n动态转换确保类指针的转换是合适完整的，它有两个重要的约束条件:\n  要求type为指针或引用\n将expression转换为type-id类型，type-id必须是类的指针、类的引用或者是void *；如果type-id是指针类型，那么expression也必须是一个指针；如果type-id是一个引用，那么expression也必须是一个引用。\n  下行转换时要求基类是多态的（基类中包含至少一个虚函数）。\n  动态转换的功能如下：\n  在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。\n  在多重继承中的上行转换中，dynamic_cast可以实现同层基类的互相转换。\n  在类层次间进行上行转换时，隐式转换和dynamic_cast和static_cast的效果是一样的，不推荐使用！\n  将类的指针转换成void *指针，注意这也需要保证类A和B都有虚函数，不推荐使用！\n  下面我将分别在以下的几种场合下进行dynamic_cast的使用总结：\n  类之间的下行转换。\n如果expression是type-id的基类，使用dynamic_cast进行转换时，在运行时就会检查expression是否真正的指向一个type-id类型的对象，如果是，则能进行正确的转换，获得对应的值；否则返回NULL，如果是引用，则在运行时就会抛出异常；例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class B { virtual void f(){}; }; class D : public B { virtual void f(){}; }; void main() { B* pb = new D; // unclear but ok  B* pb2 = new B; D* pd = dynamic_castD*(pb); // ok: pb actually points to a D  D* pd2 = dynamic_castD*(pb2); // pb2 points to a B not a D, now pd2 is NULL }   ``\n但是，在类B中必须包含虚函数，为什么呢？因为类中存在虚函数，就说明它有想让基类指针或引用指向派生类对象的情况，此时转换才有意义；由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表。\n  可以将类的指针转换成void *指针，注意这也需要保证类A和B都有虚函数。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class A {\tpublic: virtual void f(){} // ...... }; class B { public: virtual void f(){} // ...... }; int main() { A *pA = new A; B *pB = new B; void *pV = dynamic_castvoid *(pA); // pV points to an object of A  pV = dynamic_castvoid *(pB); // pV points to an object of B }   ``\n  dynamic_cast可以实现同层基类的互相转换，这是static_cast无法实现的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Base { public: virtual ~Base(){} //donnt forget : at least one virtual function..... }; class A : public Base {}; class B : public Base {}; class AB : public A, public B {}; int main() { AB ab; B *b = \u0026ab; A * a = dynamic_castA*(b); return 0; }   ``\n  对于一些复杂的继承关系来说，使用dynamic_cast进行转换是存在一些陷阱的。\n讨论上行转换，（此处所有动态转换都可以用隐式转换替代）有如下的一个结构：\nD类型可以安全的转换成B和C类型，但是D类型要是直接转换成A类型呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class A { virtual void Func() = 0; }; class B : public A { void Func(){}; }; class C : public A { void Func(){}; }; class D : public B, public C { void Func(){} }; int main() { D *pD = new D; A *pA = dynamic_castA *(pD); // You will get a pA which is NULL }   如果进行上面的直接转，你将会得到一个NULL的pA指针；这是因为，B和C都继承了A，并且都实现了虚函数Func，导致在进行转换时，无法进行抉择应该向哪个A进行转换。正确的做法是：\n1 2 3 4 5 6  int main() { D *pD = new D; B *pB = dynamic_castB *(pD); A *pA = dynamic_castA *(pB); }   讨论下行转换，有如下结构：\n现在，你拥有一个A类型的指针，它指向E实例，如何获得B类型的指针，指向E实例呢？\n如果直接进行转的话，就会出现编译器出现分歧，不知道是走E-C-B，还是走E-D-B。对于这种情况，我们就必须先将A类型的指针选择正确的路线进行下行转换，获得E类型的指针，然后，在指定一条正确的路线进行上行转换。\nreinterpret_cast reinterpret_cast的转换格式：reinterpret_cast (expression)\nreinterpret_cast 常常被用作不同类型指针间的相互转换。\nstatic_cast 运算符完成相关类型之间的转换. 而 reinterpret_cast 处理互不相关的类型之间的转换.互不相关的类型”指的是两种完全不同的类型,如从整型到指针类型,或者从一个指针到另一个毫不相干的指针.\n对于static_cast操作符,如果需要截断,补齐或者指针偏移编译器都会自动完成.而对于reinterpret_cast,编译器不会做任何检查,截断,补齐的操作,只是把比特位拷贝过去.\n示例:\nint ival = 1; double *dptr = reinterpret_cast(ival);  或者\nint *iptr = NULL; double *dptr = reinterpret_cast(iptr);  上面这个示例也说明了 reinterpret_cast 的意思:.\nreinterpret_cast的功能如下：\n  不同类型指针间的相互转换,因为所有类型的指针的长度都是一致的(32位系统上都是4字节),按比特位拷贝后不会损失数据.\n  void 到任意类型指针的转换, 用 static_cast 和 reinterpret_cast 都可以,这是由 void 是通用指针这个语义决定的.\n  它还可用于将一种数据类型按比特位从一种类型转换为另一种类型。常用的是int 型和指针类型间的相互转换，但是这种转换在系统底层的操作，有极强的平台依赖性，移植性不好。\n  注意：考虑到C++对象模型的内存分布可能引起的指针偏移问题,绝对不能在多态情况下用 reinterpret_cast.\n写代码的时候经常这样做: new 一个 struct,然后把指针返回给外部函数作为一个”句柄”,我不希望外部函数知道这是一个指针,只需要外部函数在调用相关函数时把这个”句柄”重新传回来.这时,就可以把指针转换为一个 int 型返回. 这是 reinterpret_cast 存在的绝佳理由.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  struct car { int doors; int height; int length; float weight; }; int create_car() { car *c = new car; return reinterpret_castint(c); } int get_car_doors(int car_id) { car *c = reinterpret_castcar*(car_id); return c-doors; } void destroy_car(int car_id) { car *c = reinterpret_castcar*(car_id); delete c; }   const_cast const_cast的转换格式：const_cast (expression)\n该运算符用来修改类型的const属性。.有以下功能：\n  常量指针和非常量指针的相互转换，并且仍然指向原来的对象；要求type—id和expression都为指针\n  常量引用和非常量引用的相互转换，并且仍然指向原来的对象； 要求type-id为引用，expression可以是指向对象的引用，也可以是对象本身的名字。\n  常量对象和非常量对象的相互转换，两者之间毫无关系。要求type-id为引用。\n  type_id 必须为指针或引用，const_cast转换符不该用在对象数据上，因为这样的转换得到的两个变量/对象并没有相关性。只有用指针或者引用，让变量指向同一个地址才是解决方案.\nconst_cast通常用于常量转换为非常量，因为非常量转换为常量可以直接用隐式转换完成。\n1 2 3 4 5 6 7 8 9 10 11 12  int main(int argc, char ** argv_) { int i = 100; int *j = \u0026i; //const int *k = const_cast(j);  const int *m = j; //使用隐式转换即可。  //指的地址都一样 \tcout i\",\"iendl; //100, 0012FF78 \tcout j\",\"jendl; //100, 0012FF78  *j = 200; return 0; }   下面给出一些例子来进行解析，类B的结构如下：\n1 2 3 4 5 6 7  class B { public: int m_iNum; B() : m_iNum(50) { } };     指针的转换\n1 2 3 4 5  const B *b1 = new B(); B *b2 = const_castB*(b1);//指针之间的转换，两者指向同一地址 b2-m_iNum = 200; cout\"b1: \" b1-m_iNum endl; //200 cout\"b2: \" b2-m_iNum endl; //200   ``\n  引用的转换\n1 2 3 4 5 6  const B b5; // 左侧一定要用引用类型，否则b6和b5无关，不指向同一地址。 B \u0026b6 = const_castB\u0026(b5); b6.m_iNum = 200; cout\"b5: \"b5.m_iNum endl; cout\"b6: \"b6.m_iNum endl;     对象的转换\n1 2 3 4 5  const B b3; B b4 = const_castB\u0026(b3); //注意type-id是引用类型 b4.m_iNum = 200; cout\"b3: \"b3.m_iNum endl;\t//50 cout\"b4: \"b4.m_iNum endl; //200   ``\n  const_cast与编译器优化 因为编译器的优化，会出现取消了const属性的const变量却不能修改其值的情况。\n1 2 3 4 5  const int xx = 50; int* yy = const_castint * (\u0026xx); // 同样的地址，但是内容是不一样的 *yy = 200; cout  \"xx: \"xx\" address: \"xxendl; //50 cout  \"*yy: \"yy\" address: \"yyendl; //200   究其原因，在于const值初始化的内容：如果是以字面值初始化的话，编译器在编译的时候就把const的值用字面值取代了，而不是从const对应的地址进行取值。\n解决方案就是不让const以字面值初始化，如下：\n1 2 3 4 5 6  int xxx = 50;//注意不能是const,否则xx仍是以字面值初始化。 const int xx = xxx;//将xxx隐式转换为const，然后初始化。 int* yy = const_castint * (\u0026xx); // 同样的地址，内容也相同。 *yy = 200; cout  \"xx: \"xx\" address: \"xxendl; //50 cout  \"*yy: \"yy\" address: \"yyendl; //200   还有一种方法就是使用valatile关键字。\nvs(Release)和g++都会执行编译器优化。\n",
  "wordCount" : "4533",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-23T21:33:06Z",
  "dateModified": "2017-06-23T21:33:06Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/c-%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      C&#43;&#43;中的强制类型转换
    </h1>
    <div class="post-meta">June 23, 2017
</div>
  </header> 
  <div class="post-content"><p>C/C++是强类型语言,不同类型之间的相互转换是比较麻烦的.但是在编程实践中,不可避免的要用到类型转换.有2种类型转换:隐式类型转换和强制类型转换.</p>
<h1 id="隐式类型转换">隐式类型转换<a hidden class="anchor" aria-hidden="true" href="#隐式类型转换">#</a></h1>
<ol>
<li>
<p>提升精度,此种是编译器自动完成的,安全的.所以编译的时候不会有任何错误或者警告信息提示.</p>
<pre><code> short a=2000;
 int b;
 b=a;
</code></pre>
<p>short是两字节，int是四字节，由short型转成int型是宽化转换（bit位数增多），编译器没有warning.</p>
<p>宽化转换（如char到int，int到long long，int到float，float到double，int到double等）构成隐式转换，编译器允许直接转换。</p>
</li>
<li>
<p>降低精度,也是有编译器自动完成,会造成精度丢失,所以编译时得到一个警告信息提示.</p>
<pre><code> double a=2000;	
 short b;
 b=a;
</code></pre>
<p>此时，是从8字节的double型转成2字节的short型变量，是窄化转换，编译器就会有warning了，提醒程序员可能丢失数据。不过需要注意的是，有些隐式转换，编译器可能并不给出warning，比如int到short，但数据溢出却依然会发生。</p>
</li>
<li>
<p>多态的上行转换。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="n">class</span> <span class="n">A</span>
<span class="p">{</span>
     <span class="c1">// ......
</span><span class="c1"></span><span class="p">};</span>
<span class="n">class</span> <span class="nl">B</span> <span class="p">:</span> <span class="n">public</span> <span class="n">A</span>
<span class="p">{</span>
     <span class="c1">// ......
</span><span class="c1"></span><span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
     <span class="n">B</span> <span class="o">*</span><span class="n">pB</span> <span class="o">=</span> <span class="n">new</span> <span class="n">B</span><span class="p">;</span>
     <span class="n">A</span> <span class="o">*</span><span class="n">pA</span> <span class="o">=</span> <span class="n">pB</span><span class="p">;</span> <span class="c1">// Safe and will succeed
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>``</p>
</li>
<li>
<p>任意类型指针到 void*, 都可以使用隐式类型转换，因为void*是通用指针。</p>
</li>
<li>
<p>非const对象转化为const对象，直接进行隐式转换。</p>
</li>
</ol>
<p><strong>注意:普通变量与指针不能隐式转换转换,比如int*和int不能发生隐式转换.</strong></p>
<p><strong>隐式转换失败后会出现编译错误.</strong></p>
<h1 id="显式类型转换">显式类型转换<a hidden class="anchor" aria-hidden="true" href="#显式类型转换">#</a></h1>
<p>显式类型转换可以进行任何转换。</p>
<h2 id="c风格的强制转换包括旧式c风格的强制转换">C风格的强制转换(包括旧式C++风格的强制转换)<a hidden class="anchor" aria-hidden="true" href="#c风格的强制转换包括旧式c风格的强制转换">#</a></h2>
<p>格式:</p>
<pre><code>类型(表达式); // 旧的C++风格
或者 
(类型)表达式 // C风格

示例: int(dval) 或者 (int)dval
</code></pre>
<p>此种强制转换是比较粗暴直接的,有可能导致精度丢失(如从 double 转换为 int)或者一些莫名其妙的错误(如把 int 转换为 函数指针),一旦使用了强制转换,编译器将不提示任何警告.这也往往成为错误的源泉.而且这种错误非常难找.</p>
<h2 id="c强制转换操作符">C++强制转换操作符<a hidden class="anchor" aria-hidden="true" href="#c强制转换操作符">#</a></h2>
<p>C++增加了4个关键字用于强制类型转换:</p>
<pre><code>static_cast, reinterpret_cast, const_cast 和 dynamic_cast.
</code></pre>
<h2 id="static_cast静态转换">static_cast(静态转换)<a hidden class="anchor" aria-hidden="true" href="#static_cast静态转换">#</a></h2>
<p>static_cast的转换格式：static_cast (expression)</p>
<p>将expression转换为type-id类型，比起强制类型转换提供了一定的安全性。在无关类的类指针之间转换上进行限制。主要用于非多态类型之间的转换，不提供运行时的检查来确保转换的安全性。</p>
<p>静态转换的功能如下：</p>
<ol>
<li>
<p>用于相关数据类型之间的转换，如基本数据类型中把int转换成char，把int转换成enum等等</p>
<p>数值精度提高或者降低,包括把无符号型转换为带符号型(也是精度损失的一种),用 static_cast 可以消除编译器的警告信息。</p>
</li>
<li>
<p>静态转换能把void*指针转换成目标类型的指针，因为void*是通用指针，和其它指针有一定关系。</p>
</li>
<li>
<p>用于类层次结构中，基类和子类之间指针和引用的转换。但不推荐使用！</p>
<p>当进行上行转换，也就是把子类的指针或引用转换成父类表示，这种转换是安全的；</p>
<p>当进行下行转换，也就是把父类的指针或引用转换成子类表示，这种转换是不安全的，但编译可以通过，需要程序员来保证安全性；</p>
</li>
</ol>
<p>注：static_cast不能转换掉expression的const、volatile和__unaligned属性。</p>
<h2 id="dynamic_cast动态转换">dynamic_cast（动态转换）<a hidden class="anchor" aria-hidden="true" href="#dynamic_cast动态转换">#</a></h2>
<p>dynamic_cast的转换格式：dynamic_cast (expression)</p>
<p>动态转换确保类指针的转换是合适完整的，它有两个重要的约束条件:</p>
<ol>
<li>
<p>要求type为指针或引用</p>
<p>将expression转换为type-id类型，type-id必须是类的指针、类的引用或者是void *；如果type-id是指针类型，那么expression也必须是一个指针；如果type-id是一个引用，那么expression也必须是一个引用。</p>
</li>
<li>
<p>下行转换时要求基类是多态的（基类中包含至少一个虚函数）。</p>
</li>
</ol>
<p>动态转换的功能如下：</p>
<ol>
<li>
<p>在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。</p>
</li>
<li>
<p>在多重继承中的上行转换中，dynamic_cast可以实现同层基类的互相转换。</p>
</li>
<li>
<p>在类层次间进行上行转换时，隐式转换和dynamic_cast和static_cast的效果是一样的，不推荐使用！</p>
</li>
<li>
<p>将类的指针转换成void *指针，注意这也需要保证类A和B都有虚函数，不推荐使用！</p>
</li>
</ol>
<p>下面我将分别在以下的几种场合下进行dynamic_cast的使用总结：</p>
<ol>
<li>
<p>类之间的下行转换。</p>
<p>如果expression是type-id的基类，使用dynamic_cast进行转换时，在运行时就会检查expression是否真正的指向一个type-id类型的对象，如果是，则能进行正确的转换，获得对应的值；否则返回NULL，如果是引用，则在运行时就会抛出异常；例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">B</span>
<span class="p">{</span>
     <span class="n">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(){};</span>
<span class="p">};</span>
<span class="n">class</span> <span class="nl">D</span> <span class="p">:</span> <span class="n">public</span> <span class="n">B</span>
<span class="p">{</span>
     <span class="n">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(){};</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
     <span class="n">B</span><span class="o">*</span> <span class="n">pb</span> <span class="o">=</span> <span class="n">new</span> <span class="n">D</span><span class="p">;</span>   <span class="c1">// unclear but ok
</span><span class="c1"></span>     <span class="n">B</span><span class="o">*</span> <span class="n">pb2</span> <span class="o">=</span> <span class="n">new</span> <span class="n">B</span><span class="p">;</span>
     <span class="n">D</span><span class="o">*</span> <span class="n">pd</span> <span class="o">=</span> <span class="n">dynamic_cast</span><span class="o">&lt;</span><span class="n">D</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">pb</span><span class="p">);</span>   <span class="c1">// ok: pb actually points to a D
</span><span class="c1"></span>     <span class="n">D</span><span class="o">*</span> <span class="n">pd2</span> <span class="o">=</span> <span class="n">dynamic_cast</span><span class="o">&lt;</span><span class="n">D</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">pb2</span><span class="p">);</span>   <span class="c1">// pb2 points to a B not a D, now pd2 is NULL
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>``</p>
<p>但是，在类B中必须包含虚函数，为什么呢？因为类中存在虚函数，就说明它有想让基类指针或引用指向派生类对象的情况，此时转换才有意义；由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表。</p>
</li>
<li>
<p>可以将类的指针转换成void *指针，注意这也需要保证类A和B都有虚函数。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">A</span>
<span class="p">{</span>	
<span class="nl">public</span><span class="p">:</span>
     <span class="n">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(){}</span>
     <span class="c1">// ......
</span><span class="c1"></span><span class="p">};</span>
<span class="n">class</span> <span class="n">B</span>
<span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
     <span class="n">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(){}</span>
     <span class="c1">// ......
</span><span class="c1"></span><span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
     <span class="n">A</span> <span class="o">*</span><span class="n">pA</span> <span class="o">=</span> <span class="n">new</span> <span class="n">A</span><span class="p">;</span>
     <span class="n">B</span> <span class="o">*</span><span class="n">pB</span> <span class="o">=</span> <span class="n">new</span> <span class="n">B</span><span class="p">;</span>
     <span class="kt">void</span> <span class="o">*</span><span class="n">pV</span> <span class="o">=</span> <span class="n">dynamic_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">pA</span><span class="p">);</span> <span class="c1">// pV points to an object of A
</span><span class="c1"></span>     <span class="n">pV</span> <span class="o">=</span> <span class="n">dynamic_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">pB</span><span class="p">);</span> <span class="c1">// pV points to an object of B
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>``</p>
</li>
<li>
<p>dynamic_cast可以实现同层基类的互相转换，这是static_cast无法实现的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span>   <span class="n">Base</span>   
<span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="n">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">(){}</span> <span class="c1">//donnt forget : at least one virtual function.....
</span><span class="c1"></span><span class="p">};</span>   
<span class="n">class</span>   <span class="nl">A</span>   <span class="p">:</span>   <span class="n">public</span>   <span class="n">Base</span>   <span class="p">{};</span>   
<span class="n">class</span>   <span class="nl">B</span>   <span class="p">:</span>   <span class="n">public</span>   <span class="n">Base</span>   <span class="p">{};</span>   
<span class="n">class</span>   <span class="nl">AB</span>   <span class="p">:</span>   <span class="n">public</span>   <span class="n">A</span><span class="p">,</span>   <span class="n">public</span>   <span class="n">B</span>   <span class="p">{};</span>   
<span class="kt">int</span>     <span class="nf">main</span><span class="p">()</span>   
<span class="p">{</span>   
    <span class="n">AB</span>   <span class="n">ab</span><span class="p">;</span>   
    <span class="n">B</span>   <span class="o">*</span><span class="n">b</span>   <span class="o">=</span>   <span class="o">&amp;</span><span class="n">ab</span><span class="p">;</span>   
    <span class="n">A</span> <span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="n">dynamic_cast</span><span class="o">&lt;</span><span class="n">A</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="k">return</span>   <span class="mi">0</span><span class="p">;</span>   
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>``</p>
</li>
</ol>
<p>对于一些复杂的继承关系来说，使用dynamic_cast进行转换是存在一些陷阱的。</p>
<p>讨论上行转换，（此处所有动态转换都可以用隐式转换替代）有如下的一个结构：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/jellythinkcast1.png" alt=""  />
</p>
<p>D类型可以安全的转换成B和C类型，但是D类型要是直接转换成A类型呢？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">A</span>
<span class="p">{</span>
     <span class="n">virtual</span> <span class="kt">void</span> <span class="n">Func</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">class</span> <span class="nl">B</span> <span class="p">:</span> <span class="n">public</span> <span class="n">A</span>
<span class="p">{</span>
     <span class="kt">void</span> <span class="n">Func</span><span class="p">(){};</span>
<span class="p">};</span>
<span class="n">class</span> <span class="nl">C</span> <span class="p">:</span> <span class="n">public</span> <span class="n">A</span>
<span class="p">{</span>
     <span class="kt">void</span> <span class="n">Func</span><span class="p">(){};</span>
<span class="p">};</span>
<span class="n">class</span> <span class="nl">D</span> <span class="p">:</span> <span class="n">public</span> <span class="n">B</span><span class="p">,</span> <span class="n">public</span> <span class="n">C</span>
<span class="p">{</span>
     <span class="kt">void</span> <span class="n">Func</span><span class="p">(){}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
     <span class="n">D</span> <span class="o">*</span><span class="n">pD</span> <span class="o">=</span> <span class="n">new</span> <span class="n">D</span><span class="p">;</span>
     <span class="n">A</span> <span class="o">*</span><span class="n">pA</span> <span class="o">=</span> <span class="n">dynamic_cast</span><span class="o">&lt;</span><span class="n">A</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">pD</span><span class="p">);</span> <span class="c1">// You will get a pA which is NULL
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果进行上面的直接转，你将会得到一个NULL的pA指针；这是因为，B和C都继承了A，并且都实现了虚函数Func，导致在进行转换时，无法进行抉择应该向哪个A进行转换。正确的做法是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
     <span class="n">D</span> <span class="o">*</span><span class="n">pD</span> <span class="o">=</span> <span class="n">new</span> <span class="n">D</span><span class="p">;</span>
     <span class="n">B</span> <span class="o">*</span><span class="n">pB</span> <span class="o">=</span> <span class="n">dynamic_cast</span><span class="o">&lt;</span><span class="n">B</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">pD</span><span class="p">);</span>
     <span class="n">A</span> <span class="o">*</span><span class="n">pA</span> <span class="o">=</span> <span class="n">dynamic_cast</span><span class="o">&lt;</span><span class="n">A</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">pB</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>讨论下行转换，有如下结构：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/jellythinkcast2.png" alt=""  />
</p>
<p>现在，你拥有一个A类型的指针，它指向E实例，如何获得B类型的指针，指向E实例呢？</p>
<p>如果直接进行转的话，就会出现编译器出现分歧，不知道是走E-&gt;C-&gt;B，还是走E-&gt;D-&gt;B。对于这种情况，我们就必须先将A类型的指针选择正确的路线进行下行转换，获得E类型的指针，然后，在指定一条正确的路线进行上行转换。</p>
<h2 id="reinterpret_cast">reinterpret_cast<a hidden class="anchor" aria-hidden="true" href="#reinterpret_cast">#</a></h2>
<p>reinterpret_cast的转换格式：reinterpret_cast (expression)</p>
<p>reinterpret_cast 常常被用作不同类型指针间的相互转换。</p>
<p>static_cast 运算符完成相关类型之间的转换. 而 reinterpret_cast 处理互不相关的类型之间的转换.互不相关的类型”指的是两种完全不同的类型,如从整型到指针类型,或者从一个指针到另一个毫不相干的指针.</p>
<p>对于static_cast操作符,如果需要截断,补齐或者指针偏移编译器都会自动完成.而对于reinterpret_cast,编译器不会做任何检查,截断,补齐的操作,只是把比特位拷贝过去.</p>
<p>示例:</p>
<pre><code>int ival = 1;
double *dptr = reinterpret_cast&lt;double*&gt;(ival);
</code></pre>
<p>或者</p>
<pre><code>int *iptr = NULL;
double *dptr = reinterpret_cast&lt;double*&gt;(iptr);
</code></pre>
<p>上面这个示例也说明了 reinterpret_cast 的意思:.</p>
<p>reinterpret_cast的功能如下：</p>
<ol>
<li>
<p>不同类型指针间的相互转换,因为所有类型的指针的长度都是一致的(32位系统上都是4字节),按比特位拷贝后不会损失数据.</p>
</li>
<li>
<p>void 到任意类型指针的转换, 用 static_cast 和 reinterpret_cast 都可以,这是由 void 是通用指针这个语义决定的.</p>
</li>
<li>
<p>它还可用于将一种数据类型按比特位从一种类型转换为另一种类型。常用的是int 型和指针类型间的相互转换，但是这种转换在系统底层的操作，有极强的平台依赖性，移植性不好。</p>
</li>
</ol>
<p>注意：考虑到C++对象模型的内存分布可能引起的指针偏移问题,绝对不能在多态情况下用 reinterpret_cast.</p>
<p>写代码的时候经常这样做: new 一个 struct,然后把指针返回给外部函数作为一个”句柄”,我不希望外部函数知道这是一个指针,只需要外部函数在调用相关函数时把这个”句柄”重新传回来.这时,就可以把指针转换为一个 int 型返回. 这是 reinterpret_cast 存在的绝佳理由.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">car</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">doors</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">weight</span><span class="p">;</span> 
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">create_car</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">car</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">new</span> <span class="n">car</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">get_car_doors</span><span class="p">(</span><span class="kt">int</span> <span class="n">car_id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">car</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="n">car</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">car_id</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">doors</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">destroy_car</span><span class="p">(</span><span class="kt">int</span> <span class="n">car_id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">car</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="n">car</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">car_id</span><span class="p">);</span>
    <span class="n">delete</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="const_cast">const_cast<a hidden class="anchor" aria-hidden="true" href="#const_cast">#</a></h2>
<p>const_cast的转换格式：const_cast (expression)</p>
<p>该运算符用来修改类型的const属性。.有以下功能：</p>
<ol>
<li>
<p>常量指针和非常量指针的相互转换，并且仍然指向原来的对象；要求type—id和expression都为指针</p>
</li>
<li>
<p>常量引用和非常量引用的相互转换，并且仍然指向原来的对象； 要求type-id为引用，expression可以是指向对象的引用，也可以是对象本身的名字。</p>
</li>
<li>
<p>常量对象和非常量对象的相互转换，两者之间毫无关系。要求type-id为引用。</p>
</li>
</ol>
<p>type_id 必须为指针或引用，const_cast转换符不该用在对象数据上，因为这样的转换得到的两个变量/对象并没有相关性。只有用指针或者引用，让变量指向同一个地址才是解决方案.</p>
<p>const_cast通常用于常量转换为非常量，因为非常量转换为常量可以直接用隐式转换完成。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span> <span class="n">argv_</span><span class="p">)</span>   
<span class="p">{</span>  
	 <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>  
	 <span class="kt">int</span> <span class="o">*</span><span class="n">j</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>  
	 <span class="c1">//const int *k = const_cast&lt;const int*&gt;(j);  
</span><span class="c1"></span> 	 <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="c1">//使用隐式转换即可。  
</span><span class="c1"></span> 	 <span class="c1">//指的地址都一样  
</span><span class="c1"></span>	 <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="s">&#34;,&#34;</span><span class="o">&lt;&lt;&amp;</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//100, 0012FF78  
</span><span class="c1"></span>	 <span class="n">cout</span> <span class="o">&lt;&lt;*</span><span class="n">j</span><span class="o">&lt;&lt;</span><span class="s">&#34;,&#34;</span><span class="o">&lt;&lt;</span><span class="n">j</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//100, 0012FF78  
</span><span class="c1"></span>     <span class="o">*</span><span class="n">j</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>  
     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>下面给出一些例子来进行解析，类B的结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">class B  
{  
    public:  
    int m_iNum;  
    B() : m_iNum(50)  
    {   }  
}; 
</code></pre></td></tr></table>
</div>
</div><ol>
<li>
<p>指针的转换</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">const</span> <span class="n">B</span> <span class="o">*</span><span class="n">b1</span> <span class="o">=</span> <span class="n">new</span> <span class="n">B</span><span class="p">();</span>  
<span class="n">B</span> <span class="o">*</span><span class="n">b2</span> <span class="o">=</span> <span class="n">const_cast</span><span class="o">&lt;</span><span class="n">B</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">b1</span><span class="p">);</span><span class="c1">//指针之间的转换，两者指向同一地址
</span><span class="c1"></span><span class="n">b2</span><span class="o">-&gt;</span><span class="n">m_iNum</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>  
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;b1: &#34;</span><span class="o">&lt;&lt;</span> <span class="n">b1</span><span class="o">-&gt;</span><span class="n">m_iNum</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">//200
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;b2: &#34;</span><span class="o">&lt;&lt;</span> <span class="n">b2</span><span class="o">-&gt;</span><span class="n">m_iNum</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">//200
</span></code></pre></td></tr></table>
</div>
</div><p>``</p>
</li>
<li>
<p>引用的转换</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">const</span> <span class="n">B</span> <span class="n">b5</span><span class="p">;</span>  
<span class="c1">// 左侧一定要用引用类型，否则b6和b5无关，不指向同一地址。
</span><span class="c1"></span><span class="n">B</span> <span class="o">&amp;</span><span class="n">b6</span> <span class="o">=</span> <span class="n">const_cast</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">b5</span><span class="p">);</span>  
<span class="n">b6</span><span class="p">.</span><span class="n">m_iNum</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>  
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;b5: &#34;</span><span class="o">&lt;&lt;</span><span class="n">b5</span><span class="p">.</span><span class="n">m_iNum</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>  
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;b6: &#34;</span><span class="o">&lt;&lt;</span><span class="n">b6</span><span class="p">.</span><span class="n">m_iNum</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>对象的转换</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">const</span> <span class="n">B</span> <span class="n">b3</span><span class="p">;</span>   
<span class="n">B</span> <span class="n">b4</span> <span class="o">=</span> <span class="n">const_cast</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">b3</span><span class="p">);</span>          <span class="c1">//注意type-id是引用类型
</span><span class="c1"></span><span class="n">b4</span><span class="p">.</span><span class="n">m_iNum</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>  
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;b3: &#34;</span><span class="o">&lt;&lt;</span><span class="n">b3</span><span class="p">.</span><span class="n">m_iNum</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>	<span class="c1">//50   
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;b4: &#34;</span><span class="o">&lt;&lt;</span><span class="n">b4</span><span class="p">.</span><span class="n">m_iNum</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//200
</span></code></pre></td></tr></table>
</div>
</div><p>``</p>
</li>
</ol>
<h2 id="const_cast与编译器优化">const_cast与编译器优化<a hidden class="anchor" aria-hidden="true" href="#const_cast与编译器优化">#</a></h2>
<p>因为编译器的优化，会出现取消了const属性的const变量却不能修改其值的情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">const</span> <span class="kt">int</span> <span class="n">xx</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>  
<span class="kt">int</span><span class="o">*</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">const_cast</span><span class="o">&lt;</span><span class="kt">int</span> <span class="o">*&gt;</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">xx</span><span class="p">);</span>     <span class="c1">// 同样的地址，但是内容是不一样的  
</span><span class="c1"></span><span class="o">*</span><span class="n">yy</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>  
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;xx: &#34;</span><span class="o">&lt;&lt;</span><span class="n">xx</span><span class="o">&lt;&lt;</span><span class="s">&#34; address: &#34;</span><span class="o">&lt;&lt;&amp;</span><span class="n">xx</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">//50
</span><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;*yy: &#34;</span><span class="o">&lt;&lt;*</span><span class="n">yy</span><span class="o">&lt;&lt;</span><span class="s">&#34; address: &#34;</span><span class="o">&lt;&lt;</span><span class="n">yy</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//200
</span></code></pre></td></tr></table>
</div>
</div><p>究其原因，在于const值初始化的内容：如果是以字面值初始化的话，编译器在编译的时候就把const的值用字面值取代了，而不是从const对应的地址进行取值。</p>
<p>解决方案就是不让const以字面值初始化，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">xxx</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span><span class="c1">//注意不能是const,否则xx仍是以字面值初始化。
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">xx</span> <span class="o">=</span> <span class="n">xxx</span><span class="p">;</span><span class="c1">//将xxx隐式转换为const，然后初始化。  
</span><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">const_cast</span><span class="o">&lt;</span><span class="kt">int</span> <span class="o">*&gt;</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">xx</span><span class="p">);</span>     <span class="c1">// 同样的地址，内容也相同。
</span><span class="c1"></span><span class="o">*</span><span class="n">yy</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>  
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;xx: &#34;</span><span class="o">&lt;&lt;</span><span class="n">xx</span><span class="o">&lt;&lt;</span><span class="s">&#34; address: &#34;</span><span class="o">&lt;&lt;&amp;</span><span class="n">xx</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">//50
</span><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;*yy: &#34;</span><span class="o">&lt;&lt;*</span><span class="n">yy</span><span class="o">&lt;&lt;</span><span class="s">&#34; address: &#34;</span><span class="o">&lt;&lt;</span><span class="n">yy</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//200
</span></code></pre></td></tr></table>
</div>
</div><p>还有一种方法就是使用valatile关键字。</p>
<p>vs(Release)和g++都会执行编译器优化。</p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
