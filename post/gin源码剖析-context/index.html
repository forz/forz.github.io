<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Gin源码剖析:context | Forz Blog</title>
<meta name="keywords" content="Gin" />
<meta name="description" content="1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70">
<meta name="author" content="">
<link rel="canonical" href="/post/gin%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-context/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Gin源码剖析:context" />
<meta property="og:description" content="1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/gin%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-context/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2018-11-15T18:20:19&#43;00:00" />
<meta property="article:modified_time" content="2018-11-15T18:20:19&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Gin源码剖析:context"/>
<meta name="twitter:description" content="1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Gin源码剖析:context",
      "item": "/post/gin%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-context/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Gin源码剖析:context",
  "name": "Gin源码剖析:context",
  "description": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70",
  "keywords": [
    "Gin"
  ],
  "articleBody": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956  // Copyright 2014 Manu Martinez-Almeida. All rights reserved. // Use of this source code is governed by a MIT style // license that can be found in the LICENSE file.  package gin import ( \"errors\" \"io\" \"io/ioutil\" \"math\" \"mime/multipart\" \"net\" \"net/http\" \"net/url\" \"os\" \"strings\" \"time\" \"github.com/gin-contrib/sse\" \"github.com/gin-gonic/gin/binding\" \"github.com/gin-gonic/gin/render\" ) // Content-Type MIME of the most common data formats. const ( MIMEJSON = binding.MIMEJSON MIMEHTML = binding.MIMEHTML MIMEXML = binding.MIMEXML MIMEXML2 = binding.MIMEXML2 MIMEPlain = binding.MIMEPlain MIMEPOSTForm = binding.MIMEPOSTForm MIMEMultipartPOSTForm = binding.MIMEMultipartPOSTForm BodyBytesKey = \"_gin-gonic/gin/bodybyteskey\" ) const abortIndex int8 = math.MaxInt8 / 2 // Context is the most important part of gin. It allows us to pass variables between middleware, // manage the flow, validate the JSON of a request and render a JSON response for example. // Context是gin当中最为重要的一部分 // 它用于在中间件当中传递变量，管理流程。例如接受json请求，并返回json type Context struct { writermem responseWriter Request *http.Request Writer ResponseWriter Params Params handlers HandlersChain index int8 engine *Engine // Keys is a key/value pair exclusively for the context of each request. \tKeys map[string]interface{} // Errors is a list of errors attached to all the handlers/middlewares who used this context. \tErrors errorMsgs // Accepted defines a list of manually accepted formats for content negotiation. \tAccepted []string } /************************************/ /********** CONTEXT CREATION ********/ /************************************/ func (c *Context) reset() { c.Writer = \u0026c.writermem c.Params = c.Params[0:0] c.handlers = nil c.index = -1 c.Keys = nil c.Errors = c.Errors[0:0] c.Accepted = nil } // Copy returns a copy of the current context that can be safely used outside the request's scope. // This has to be used when the context has to be passed to a goroutine. func (c *Context) Copy() *Context { var cp = *c cp.writermem.ResponseWriter = nil cp.Writer = \u0026cp.writermem cp.index = abortIndex cp.handlers = nil return \u0026cp } // HandlerName returns the main handler's name. For example if the handler is \"handleGetUsers()\", // this function will return \"main.handleGetUsers\". func (c *Context) HandlerName() string { return nameOfFunction(c.handlers.Last()) } // Handler returns the main handler. func (c *Context) Handler() HandlerFunc { return c.handlers.Last() } /************************************/ /*********** FLOW CONTROL ***********/ /************************************/ // Next should be used only inside middleware. // It executes the pending handlers in the chain inside the calling handler. // See example in GitHub. func (c *Context) Next() { c.index++ for s := int8(len(c.handlers)); c.index  s; c.index++ { c.handlers[c.index](c) } } // IsAborted returns true if the current context was aborted. func (c *Context) IsAborted() bool { return c.index = abortIndex } // Abort prevents pending handlers from being called. Note that this will not stop the current handler. // Let's say you have an authorization middleware that validates that the current request is authorized. // If the authorization fails (ex: the password does not match), call Abort to ensure the remaining handlers // for this request are not called. func (c *Context) Abort() { c.index = abortIndex } // AbortWithStatus calls `Abort()` and writes the headers with the specified status code. // For example, a failed attempt to authenticate a request could use: context.AbortWithStatus(401). func (c *Context) AbortWithStatus(code int) { c.Status(code) c.Writer.WriteHeaderNow() c.Abort() } // AbortWithStatusJSON calls `Abort()` and then `JSON` internally. // This method stops the chain, writes the status code and return a JSON body. // It also sets the Content-Type as \"application/json\". func (c *Context) AbortWithStatusJSON(code int, jsonObj interface{}) { c.Abort() c.JSON(code, jsonObj) } // AbortWithError calls `AbortWithStatus()` and `Error()` internally. // This method stops the chain, writes the status code and pushes the specified error to `c.Errors`. // See Context.Error() for more details. func (c *Context) AbortWithError(code int, err error) *Error { c.AbortWithStatus(code) return c.Error(err) } /************************************/ /********* ERROR MANAGEMENT *********/ /************************************/ // Error attaches an error to the current context. The error is pushed to a list of errors. // It's a good idea to call Error for each error that occurred during the resolution of a request. // A middleware can be used to collect all the errors and push them to a database together, // print a log, or append it in the HTTP response. // Error will panic if err is nil. func (c *Context) Error(err error) *Error { if err == nil { panic(\"err is nil\") } parsedError, ok := err.(*Error) if !ok { parsedError = \u0026Error{ Err: err, Type: ErrorTypePrivate, } } c.Errors = append(c.Errors, parsedError) return parsedError } /************************************/ /******** METADATA MANAGEMENT********/ /************************************/ // Set is used to store a new key/value pair exclusively for this context. // It also lazy initializes c.Keys if it was not used previously. func (c *Context) Set(key string, value interface{}) { if c.Keys == nil { c.Keys = make(map[string]interface{}) } c.Keys[key] = value } // Get returns the value for the given key, ie: (value, true). // If the value does not exists it returns (nil, false) func (c *Context) Get(key string) (value interface{}, exists bool) { value, exists = c.Keys[key] return } // MustGet returns the value for the given key if it exists, otherwise it panics. func (c *Context) MustGet(key string) interface{} { if value, exists := c.Get(key); exists { return value } panic(\"Key \\\"\" + key + \"\\\" does not exist\") } // GetString returns the value associated with the key as a string. func (c *Context) GetString(key string) (s string) { if val, ok := c.Get(key); ok \u0026\u0026 val != nil { s, _ = val.(string) } return } // GetBool returns the value associated with the key as a boolean. func (c *Context) GetBool(key string) (b bool) { if val, ok := c.Get(key); ok \u0026\u0026 val != nil { b, _ = val.(bool) } return } // GetInt returns the value associated with the key as an integer. func (c *Context) GetInt(key string) (i int) { if val, ok := c.Get(key); ok \u0026\u0026 val != nil { i, _ = val.(int) } return } // GetInt64 returns the value associated with the key as an integer. func (c *Context) GetInt64(key string) (i64 int64) { if val, ok := c.Get(key); ok \u0026\u0026 val != nil { i64, _ = val.(int64) } return } // GetFloat64 returns the value associated with the key as a float64. func (c *Context) GetFloat64(key string) (f64 float64) { if val, ok := c.Get(key); ok \u0026\u0026 val != nil { f64, _ = val.(float64) } return } // GetTime returns the value associated with the key as time. func (c *Context) GetTime(key string) (t time.Time) { if val, ok := c.Get(key); ok \u0026\u0026 val != nil { t, _ = val.(time.Time) } return } // GetDuration returns the value associated with the key as a duration. func (c *Context) GetDuration(key string) (d time.Duration) { if val, ok := c.Get(key); ok \u0026\u0026 val != nil { d, _ = val.(time.Duration) } return } // GetStringSlice returns the value associated with the key as a slice of strings. func (c *Context) GetStringSlice(key string) (ss []string) { if val, ok := c.Get(key); ok \u0026\u0026 val != nil { ss, _ = val.([]string) } return } // GetStringMap returns the value associated with the key as a map of interfaces. func (c *Context) GetStringMap(key string) (sm map[string]interface{}) { if val, ok := c.Get(key); ok \u0026\u0026 val != nil { sm, _ = val.(map[string]interface{}) } return } // GetStringMapString returns the value associated with the key as a map of strings. func (c *Context) GetStringMapString(key string) (sms map[string]string) { if val, ok := c.Get(key); ok \u0026\u0026 val != nil { sms, _ = val.(map[string]string) } return } // GetStringMapStringSlice returns the value associated with the key as a map to a slice of strings. func (c *Context) GetStringMapStringSlice(key string) (smss map[string][]string) { if val, ok := c.Get(key); ok \u0026\u0026 val != nil { smss, _ = val.(map[string][]string) } return } /************************************/ /************ INPUT DATA ************/ /************************************/ // Param returns the value of the URL param. // It is a shortcut for c.Params.ByName(key) // router.GET(\"/user/:id\", func(c *gin.Context) { // // a GET request to /user/john // id := c.Param(\"id\") // id == \"john\" // }) func (c *Context) Param(key string) string { return c.Params.ByName(key) } // Query returns the keyed url query value if it exists, // otherwise it returns an empty string `(\"\")`. // It is shortcut for `c.Request.URL.Query().Get(key)` // GET /path?id=1234\u0026name=Manu\u0026value= // c.Query(\"id\") == \"1234\" // c.Query(\"name\") == \"Manu\" // c.Query(\"value\") == \"\" // c.Query(\"wtf\") == \"\" func (c *Context) Query(key string) string { value, _ := c.GetQuery(key) return value } // DefaultQuery returns the keyed url query value if it exists, // otherwise it returns the specified defaultValue string. // See: Query() and GetQuery() for further information. // GET /?name=Manu\u0026lastname= // c.DefaultQuery(\"name\", \"unknown\") == \"Manu\" // c.DefaultQuery(\"id\", \"none\") == \"none\" // c.DefaultQuery(\"lastname\", \"none\") == \"\" func (c *Context) DefaultQuery(key, defaultValue string) string { if value, ok := c.GetQuery(key); ok { return value } return defaultValue } // GetQuery is like Query(), it returns the keyed url query value // if it exists `(value, true)` (even when the value is an empty string), // otherwise it returns `(\"\", false)`. // It is shortcut for `c.Request.URL.Query().Get(key)` // GET /?name=Manu\u0026lastname= // (\"Manu\", true) == c.GetQuery(\"name\") // (\"\", false) == c.GetQuery(\"id\") // (\"\", true) == c.GetQuery(\"lastname\") func (c *Context) GetQuery(key string) (string, bool) { if values, ok := c.GetQueryArray(key); ok { return values[0], ok } return \"\", false } // QueryArray returns a slice of strings for a given query key. // The length of the slice depends on the number of params with the given key. func (c *Context) QueryArray(key string) []string { values, _ := c.GetQueryArray(key) return values } // GetQueryArray returns a slice of strings for a given query key, plus // a boolean value whether at least one value exists for the given key. func (c *Context) GetQueryArray(key string) ([]string, bool) { if values, ok := c.Request.URL.Query()[key]; ok \u0026\u0026 len(values)  0 { return values, true } return []string{}, false } // QueryMap returns a map for a given query key. func (c *Context) QueryMap(key string) map[string]string { dicts, _ := c.GetQueryMap(key) return dicts } // GetQueryMap returns a map for a given query key, plus a boolean value // whether at least one value exists for the given key. func (c *Context) GetQueryMap(key string) (map[string]string, bool) { return c.get(c.Request.URL.Query(), key) } // PostForm returns the specified key from a POST urlencoded form or multipart form // when it exists, otherwise it returns an empty string `(\"\")`. func (c *Context) PostForm(key string) string { value, _ := c.GetPostForm(key) return value } // DefaultPostForm returns the specified key from a POST urlencoded form or multipart form // when it exists, otherwise it returns the specified defaultValue string. // See: PostForm() and GetPostForm() for further information. func (c *Context) DefaultPostForm(key, defaultValue string) string { if value, ok := c.GetPostForm(key); ok { return value } return defaultValue } // GetPostForm is like PostForm(key). It returns the specified key from a POST urlencoded // form or multipart form when it exists `(value, true)` (even when the value is an empty string), // otherwise it returns (\"\", false). // For example, during a PATCH request to update the user's email: // email=mail@example.com -- (\"mail@example.com\", true) := GetPostForm(\"email\") // set email to \"mail@example.com\" // email= -- (\"\", true) := GetPostForm(\"email\") // set email to \"\" // -- (\"\", false) := GetPostForm(\"email\") // do nothing with email func (c *Context) GetPostForm(key string) (string, bool) { if values, ok := c.GetPostFormArray(key); ok { return values[0], ok } return \"\", false } // PostFormArray returns a slice of strings for a given form key. // The length of the slice depends on the number of params with the given key. func (c *Context) PostFormArray(key string) []string { values, _ := c.GetPostFormArray(key) return values } // GetPostFormArray returns a slice of strings for a given form key, plus // a boolean value whether at least one value exists for the given key. func (c *Context) GetPostFormArray(key string) ([]string, bool) { req := c.Request req.ParseForm() req.ParseMultipartForm(c.engine.MaxMultipartMemory) if values := req.PostForm[key]; len(values)  0 { return values, true } if req.MultipartForm != nil \u0026\u0026 req.MultipartForm.File != nil { if values := req.MultipartForm.Value[key]; len(values)  0 { return values, true } } return []string{}, false } // PostFormMap returns a map for a given form key. func (c *Context) PostFormMap(key string) map[string]string { dicts, _ := c.GetPostFormMap(key) return dicts } // GetPostFormMap returns a map for a given form key, plus a boolean value // whether at least one value exists for the given key. func (c *Context) GetPostFormMap(key string) (map[string]string, bool) { req := c.Request req.ParseForm() req.ParseMultipartForm(c.engine.MaxMultipartMemory) dicts, exist := c.get(req.PostForm, key) if !exist \u0026\u0026 req.MultipartForm != nil \u0026\u0026 req.MultipartForm.File != nil { dicts, exist = c.get(req.MultipartForm.Value, key) } return dicts, exist } // get is an internal method and returns a map which satisfy conditions. func (c *Context) get(m map[string][]string, key string) (map[string]string, bool) { dicts := make(map[string]string) exist := false for k, v := range m { if i := strings.IndexByte(k, '['); i = 1 \u0026\u0026 k[0:i] == key { if j := strings.IndexByte(k[i+1:], ']'); j = 1 { exist = true dicts[k[i+1:][:j]] = v[0] } } } return dicts, exist } // FormFile returns the first file for the provided form key. func (c *Context) FormFile(name string) (*multipart.FileHeader, error) { _, fh, err := c.Request.FormFile(name) return fh, err } // MultipartForm is the parsed multipart form, including file uploads. func (c *Context) MultipartForm() (*multipart.Form, error) { err := c.Request.ParseMultipartForm(c.engine.MaxMultipartMemory) return c.Request.MultipartForm, err } // SaveUploadedFile uploads the form file to specific dst. func (c *Context) SaveUploadedFile(file *multipart.FileHeader, dst string) error { src, err := file.Open() if err != nil { return err } defer src.Close() out, err := os.Create(dst) if err != nil { return err } defer out.Close() io.Copy(out, src) return nil } // Bind checks the Content-Type to select a binding engine automatically, // Depending the \"Content-Type\" header different bindings are used: // \"application/json\" -- JSON binding // \"application/xml\" -- XML binding // otherwise -- returns an error. // It parses the request's body as JSON if Content-Type == \"application/json\" using JSON or XML as a JSON input. // It decodes the json payload into the struct specified as a pointer. // It writes a 400 error and sets Content-Type header \"text/plain\" in the response if input is not valid. func (c *Context) Bind(obj interface{}) error { b := binding.Default(c.Request.Method, c.ContentType()) return c.MustBindWith(obj, b) } // BindJSON is a shortcut for c.MustBindWith(obj, binding.JSON). func (c *Context) BindJSON(obj interface{}) error { return c.MustBindWith(obj, binding.JSON) } // BindXML is a shortcut for c.MustBindWith(obj, binding.BindXML). func (c *Context) BindXML(obj interface{}) error { return c.MustBindWith(obj, binding.XML) } // BindQuery is a shortcut for c.MustBindWith(obj, binding.Query). func (c *Context) BindQuery(obj interface{}) error { return c.MustBindWith(obj, binding.Query) } // MustBindWith binds the passed struct pointer using the specified binding engine. // It will abort the request with HTTP 400 if any error ocurrs. // See the binding package. func (c *Context) MustBindWith(obj interface{}, b binding.Binding) (err error) { if err = c.ShouldBindWith(obj, b); err != nil { c.AbortWithError(http.StatusBadRequest, err).SetType(ErrorTypeBind) } return } // ShouldBind checks the Content-Type to select a binding engine automatically, // Depending the \"Content-Type\" header different bindings are used: // \"application/json\" -- JSON binding // \"application/xml\" -- XML binding // otherwise -- returns an error // It parses the request's body as JSON if Content-Type == \"application/json\" using JSON or XML as a JSON input. // It decodes the json payload into the struct specified as a pointer. // Like c.Bind() but this method does not set the response status code to 400 and abort if the json is not valid. func (c *Context) ShouldBind(obj interface{}) error { b := binding.Default(c.Request.Method, c.ContentType()) return c.ShouldBindWith(obj, b) } // ShouldBindJSON is a shortcut for c.ShouldBindWith(obj, binding.JSON). func (c *Context) ShouldBindJSON(obj interface{}) error { return c.ShouldBindWith(obj, binding.JSON) } // ShouldBindXML is a shortcut for c.ShouldBindWith(obj, binding.XML). func (c *Context) ShouldBindXML(obj interface{}) error { return c.ShouldBindWith(obj, binding.XML) } // ShouldBindQuery is a shortcut for c.ShouldBindWith(obj, binding.Query). func (c *Context) ShouldBindQuery(obj interface{}) error { return c.ShouldBindWith(obj, binding.Query) } // ShouldBindWith binds the passed struct pointer using the specified binding engine. // See the binding package. func (c *Context) ShouldBindWith(obj interface{}, b binding.Binding) error { return b.Bind(c.Request, obj) } // ShouldBindBodyWith is similar with ShouldBindWith, but it stores the request // body into the context, and reuse when it is called again. // // NOTE: This method reads the body before binding. So you should use // ShouldBindWith for better performance if you need to call only once. func (c *Context) ShouldBindBodyWith( obj interface{}, bb binding.BindingBody, ) (err error) { var body []byte if cb, ok := c.Get(BodyBytesKey); ok { if cbb, ok := cb.([]byte); ok { body = cbb } } if body == nil { body, err = ioutil.ReadAll(c.Request.Body) if err != nil { return err } c.Set(BodyBytesKey, body) } return bb.BindBody(body, obj) } // ClientIP implements a best effort algorithm to return the real client IP, it parses // X-Real-IP and X-Forwarded-For in order to work properly with reverse-proxies such us: nginx or haproxy. // Use X-Forwarded-For before X-Real-Ip as nginx uses X-Real-Ip with the proxy's IP. func (c *Context) ClientIP() string { if c.engine.ForwardedByClientIP { clientIP := c.requestHeader(\"X-Forwarded-For\") clientIP = strings.TrimSpace(strings.Split(clientIP, \",\")[0]) if clientIP == \"\" { clientIP = strings.TrimSpace(c.requestHeader(\"X-Real-Ip\")) } if clientIP != \"\" { return clientIP } } if c.engine.AppEngine { if addr := c.requestHeader(\"X-Appengine-Remote-Addr\"); addr != \"\" { return addr } } if ip, _, err := net.SplitHostPort(strings.TrimSpace(c.Request.RemoteAddr)); err == nil { return ip } return \"\" } // ContentType returns the Content-Type header of the request. func (c *Context) ContentType() string { return filterFlags(c.requestHeader(\"Content-Type\")) } // IsWebsocket returns true if the request headers indicate that a websocket // handshake is being initiated by the client. func (c *Context) IsWebsocket() bool { if strings.Contains(strings.ToLower(c.requestHeader(\"Connection\")), \"upgrade\") \u0026\u0026 strings.ToLower(c.requestHeader(\"Upgrade\")) == \"websocket\" { return true } return false } func (c *Context) requestHeader(key string) string { return c.Request.Header.Get(key) } /************************************/ /******** RESPONSE RENDERING ********/ /************************************/ // bodyAllowedForStatus is a copy of http.bodyAllowedForStatus non-exported function. func bodyAllowedForStatus(status int) bool { switch { case status = 100 \u0026\u0026 status  199: return false case status == http.StatusNoContent: return false case status == http.StatusNotModified: return false } return true } // Status sets the HTTP response code. func (c *Context) Status(code int) { c.writermem.WriteHeader(code) } // Header is a intelligent shortcut for c.Writer.Header().Set(key, value). // It writes a header in the response. // If value == \"\", this method removes the header `c.Writer.Header().Del(key)` func (c *Context) Header(key, value string) { if value == \"\" { c.Writer.Header().Del(key) return } c.Writer.Header().Set(key, value) } // GetHeader returns value from request headers. func (c *Context) GetHeader(key string) string { return c.requestHeader(key) } // GetRawData return stream data. func (c *Context) GetRawData() ([]byte, error) { return ioutil.ReadAll(c.Request.Body) } // SetCookie adds a Set-Cookie header to the ResponseWriter's headers. // The provided cookie must have a valid Name. Invalid cookies may be // silently dropped. func (c *Context) SetCookie(name, value string, maxAge int, path, domain string, secure, httpOnly bool) { if path == \"\" { path = \"/\" } http.SetCookie(c.Writer, \u0026http.Cookie{ Name: name, Value: url.QueryEscape(value), MaxAge: maxAge, Path: path, Domain: domain, Secure: secure, HttpOnly: httpOnly, }) } // Cookie returns the named cookie provided in the request or // ErrNoCookie if not found. And return the named cookie is unescaped. // If multiple cookies match the given name, only one cookie will // be returned. func (c *Context) Cookie(name string) (string, error) { cookie, err := c.Request.Cookie(name) if err != nil { return \"\", err } val, _ := url.QueryUnescape(cookie.Value) return val, nil } // Render writes the response headers and calls render.Render to render data. func (c *Context) Render(code int, r render.Render) { c.Status(code) if !bodyAllowedForStatus(code) { r.WriteContentType(c.Writer) c.Writer.WriteHeaderNow() return } if err := r.Render(c.Writer); err != nil { panic(err) } } // HTML renders the HTTP template specified by its file name. // It also updates the HTTP code and sets the Content-Type as \"text/html\". // See http://golang.org/doc/articles/wiki/ func (c *Context) HTML(code int, name string, obj interface{}) { instance := c.engine.HTMLRender.Instance(name, obj) c.Render(code, instance) } // IndentedJSON serializes the given struct as pretty JSON (indented + endlines) into the response body. // It also sets the Content-Type as \"application/json\". // WARNING: we recommend to use this only for development purposes since printing pretty JSON is // more CPU and bandwidth consuming. Use Context.JSON() instead. func (c *Context) IndentedJSON(code int, obj interface{}) { c.Render(code, render.IndentedJSON{Data: obj}) } // SecureJSON serializes the given struct as Secure JSON into the response body. // Default prepends \"while(1),\" to response body if the given struct is array values. // It also sets the Content-Type as \"application/json\". func (c *Context) SecureJSON(code int, obj interface{}) { c.Render(code, render.SecureJSON{Prefix: c.engine.secureJsonPrefix, Data: obj}) } // JSONP serializes the given struct as JSON into the response body. // It add padding to response body to request data from a server residing in a different domain than the client. // It also sets the Content-Type as \"application/javascript\". func (c *Context) JSONP(code int, obj interface{}) { callback := c.DefaultQuery(\"callback\", \"\") if callback == \"\" { c.Render(code, render.JSON{Data: obj}) return } c.Render(code, render.JsonpJSON{Callback: callback, Data: obj}) } // JSON serializes the given struct as JSON into the response body. // It also sets the Content-Type as \"application/json\". func (c *Context) JSON(code int, obj interface{}) { c.Render(code, render.JSON{Data: obj}) } // AsciiJSON serializes the given struct as JSON into the response body with unicode to ASCII string. // It also sets the Content-Type as \"application/json\". func (c *Context) AsciiJSON(code int, obj interface{}) { c.Render(code, render.AsciiJSON{Data: obj}) } // XML serializes the given struct as XML into the response body. // It also sets the Content-Type as \"application/xml\". func (c *Context) XML(code int, obj interface{}) { c.Render(code, render.XML{Data: obj}) } // YAML serializes the given struct as YAML into the response body. func (c *Context) YAML(code int, obj interface{}) { c.Render(code, render.YAML{Data: obj}) } // ProtoBuf serializes the given struct as ProtoBuf into the response body. func (c *Context) ProtoBuf(code int, obj interface{}) { c.Render(code, render.ProtoBuf{Data: obj}) } // String writes the given string into the response body. func (c *Context) String(code int, format string, values ...interface{}) { c.Render(code, render.String{Format: format, Data: values}) } // Redirect returns a HTTP redirect to the specific location. func (c *Context) Redirect(code int, location string) { c.Render(-1, render.Redirect{ Code: code, Location: location, Request: c.Request, }) } // Data writes some data into the body stream and updates the HTTP code. func (c *Context) Data(code int, contentType string, data []byte) { c.Render(code, render.Data{ ContentType: contentType, Data: data, }) } // DataFromReader writes the specified reader into the body stream and updates the HTTP code. func (c *Context) DataFromReader(code int, contentLength int64, contentType string, reader io.Reader, extraHeaders map[string]string) { c.Render(code, render.Reader{ Headers: extraHeaders, ContentType: contentType, ContentLength: contentLength, Reader: reader, }) } // File writes the specified file into the body stream in a efficient way. func (c *Context) File(filepath string) { http.ServeFile(c.Writer, c.Request, filepath) } // SSEvent writes a Server-Sent Event into the body stream. func (c *Context) SSEvent(name string, message interface{}) { c.Render(-1, sse.Event{ Event: name, Data: message, }) } // Stream sends a streaming response. func (c *Context) Stream(step func(w io.Writer) bool) { w := c.Writer clientGone := w.CloseNotify() for { select { case clientGone: return default: keepOpen := step(w) w.Flush() if !keepOpen { return } } } } /************************************/ /******** CONTENT NEGOTIATION *******/ /************************************/ // Negotiate contains all negotiations data. type Negotiate struct { Offered []string HTMLName string HTMLData interface{} JSONData interface{} XMLData interface{} Data interface{} } // Negotiate calls different Render according acceptable Accept format. func (c *Context) Negotiate(code int, config Negotiate) { switch c.NegotiateFormat(config.Offered...) { case binding.MIMEJSON: data := chooseData(config.JSONData, config.Data) c.JSON(code, data) case binding.MIMEHTML: data := chooseData(config.HTMLData, config.Data) c.HTML(code, config.HTMLName, data) case binding.MIMEXML: data := chooseData(config.XMLData, config.Data) c.XML(code, data) default: c.AbortWithError(http.StatusNotAcceptable, errors.New(\"the accepted formats are not offered by the server\")) } } // NegotiateFormat returns an acceptable Accept format. func (c *Context) NegotiateFormat(offered ...string) string { assert1(len(offered)  0, \"you must provide at least one offer\") if c.Accepted == nil { c.Accepted = parseAccept(c.requestHeader(\"Accept\")) } if len(c.Accepted) == 0 { return offered[0] } for _, accepted := range c.Accepted { for _, offert := range offered { if accepted == offert { return offert } } } return \"\" } // SetAccepted sets Accept header data. func (c *Context) SetAccepted(formats ...string) { c.Accepted = formats } /************************************/ /***** GOLANG.ORG/X/NET/CONTEXT *****/ /************************************/ // Deadline returns the time when work done on behalf of this context // should be canceled. Deadline returns ok==false when no deadline is // set. Successive calls to Deadline return the same results. func (c *Context) Deadline() (deadline time.Time, ok bool) { return } // Done returns a channel that's closed when work done on behalf of this // context should be canceled. Done may return nil if this context can // never be canceled. Successive calls to Done return the same value. func (c *Context) Done() chan struct{} { return nil } // Err returns a non-nil error value after Done is closed, // successive calls to Err return the same error. // If Done is not yet closed, Err returns nil. // If Done is closed, Err returns a non-nil error explaining why: // Canceled if the context was canceled // or DeadlineExceeded if the context's deadline passed. func (c *Context) Err() error { return nil } // Value returns the value associated with this context for key, or nil // if no value is associated with key. Successive calls to Value with // the same key returns the same result. func (c *Context) Value(key interface{}) interface{} { if key == 0 { return c.Request } if keyAsString, ok := key.(string); ok { val, _ := c.Get(keyAsString) return val } return nil }   ",
  "wordCount" : "5279",
  "inLanguage": "zh-cn",
  "datePublished": "2018-11-15T18:20:19Z",
  "dateModified": "2018-11-15T18:20:19Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/gin%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-context/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Gin源码剖析:context
    </h1>
    <div class="post-meta">November 15, 2018
</div>
  </header> 
  <div class="post-content"><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span><span class="lnt">319
</span><span class="lnt">320
</span><span class="lnt">321
</span><span class="lnt">322
</span><span class="lnt">323
</span><span class="lnt">324
</span><span class="lnt">325
</span><span class="lnt">326
</span><span class="lnt">327
</span><span class="lnt">328
</span><span class="lnt">329
</span><span class="lnt">330
</span><span class="lnt">331
</span><span class="lnt">332
</span><span class="lnt">333
</span><span class="lnt">334
</span><span class="lnt">335
</span><span class="lnt">336
</span><span class="lnt">337
</span><span class="lnt">338
</span><span class="lnt">339
</span><span class="lnt">340
</span><span class="lnt">341
</span><span class="lnt">342
</span><span class="lnt">343
</span><span class="lnt">344
</span><span class="lnt">345
</span><span class="lnt">346
</span><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span><span class="lnt">351
</span><span class="lnt">352
</span><span class="lnt">353
</span><span class="lnt">354
</span><span class="lnt">355
</span><span class="lnt">356
</span><span class="lnt">357
</span><span class="lnt">358
</span><span class="lnt">359
</span><span class="lnt">360
</span><span class="lnt">361
</span><span class="lnt">362
</span><span class="lnt">363
</span><span class="lnt">364
</span><span class="lnt">365
</span><span class="lnt">366
</span><span class="lnt">367
</span><span class="lnt">368
</span><span class="lnt">369
</span><span class="lnt">370
</span><span class="lnt">371
</span><span class="lnt">372
</span><span class="lnt">373
</span><span class="lnt">374
</span><span class="lnt">375
</span><span class="lnt">376
</span><span class="lnt">377
</span><span class="lnt">378
</span><span class="lnt">379
</span><span class="lnt">380
</span><span class="lnt">381
</span><span class="lnt">382
</span><span class="lnt">383
</span><span class="lnt">384
</span><span class="lnt">385
</span><span class="lnt">386
</span><span class="lnt">387
</span><span class="lnt">388
</span><span class="lnt">389
</span><span class="lnt">390
</span><span class="lnt">391
</span><span class="lnt">392
</span><span class="lnt">393
</span><span class="lnt">394
</span><span class="lnt">395
</span><span class="lnt">396
</span><span class="lnt">397
</span><span class="lnt">398
</span><span class="lnt">399
</span><span class="lnt">400
</span><span class="lnt">401
</span><span class="lnt">402
</span><span class="lnt">403
</span><span class="lnt">404
</span><span class="lnt">405
</span><span class="lnt">406
</span><span class="lnt">407
</span><span class="lnt">408
</span><span class="lnt">409
</span><span class="lnt">410
</span><span class="lnt">411
</span><span class="lnt">412
</span><span class="lnt">413
</span><span class="lnt">414
</span><span class="lnt">415
</span><span class="lnt">416
</span><span class="lnt">417
</span><span class="lnt">418
</span><span class="lnt">419
</span><span class="lnt">420
</span><span class="lnt">421
</span><span class="lnt">422
</span><span class="lnt">423
</span><span class="lnt">424
</span><span class="lnt">425
</span><span class="lnt">426
</span><span class="lnt">427
</span><span class="lnt">428
</span><span class="lnt">429
</span><span class="lnt">430
</span><span class="lnt">431
</span><span class="lnt">432
</span><span class="lnt">433
</span><span class="lnt">434
</span><span class="lnt">435
</span><span class="lnt">436
</span><span class="lnt">437
</span><span class="lnt">438
</span><span class="lnt">439
</span><span class="lnt">440
</span><span class="lnt">441
</span><span class="lnt">442
</span><span class="lnt">443
</span><span class="lnt">444
</span><span class="lnt">445
</span><span class="lnt">446
</span><span class="lnt">447
</span><span class="lnt">448
</span><span class="lnt">449
</span><span class="lnt">450
</span><span class="lnt">451
</span><span class="lnt">452
</span><span class="lnt">453
</span><span class="lnt">454
</span><span class="lnt">455
</span><span class="lnt">456
</span><span class="lnt">457
</span><span class="lnt">458
</span><span class="lnt">459
</span><span class="lnt">460
</span><span class="lnt">461
</span><span class="lnt">462
</span><span class="lnt">463
</span><span class="lnt">464
</span><span class="lnt">465
</span><span class="lnt">466
</span><span class="lnt">467
</span><span class="lnt">468
</span><span class="lnt">469
</span><span class="lnt">470
</span><span class="lnt">471
</span><span class="lnt">472
</span><span class="lnt">473
</span><span class="lnt">474
</span><span class="lnt">475
</span><span class="lnt">476
</span><span class="lnt">477
</span><span class="lnt">478
</span><span class="lnt">479
</span><span class="lnt">480
</span><span class="lnt">481
</span><span class="lnt">482
</span><span class="lnt">483
</span><span class="lnt">484
</span><span class="lnt">485
</span><span class="lnt">486
</span><span class="lnt">487
</span><span class="lnt">488
</span><span class="lnt">489
</span><span class="lnt">490
</span><span class="lnt">491
</span><span class="lnt">492
</span><span class="lnt">493
</span><span class="lnt">494
</span><span class="lnt">495
</span><span class="lnt">496
</span><span class="lnt">497
</span><span class="lnt">498
</span><span class="lnt">499
</span><span class="lnt">500
</span><span class="lnt">501
</span><span class="lnt">502
</span><span class="lnt">503
</span><span class="lnt">504
</span><span class="lnt">505
</span><span class="lnt">506
</span><span class="lnt">507
</span><span class="lnt">508
</span><span class="lnt">509
</span><span class="lnt">510
</span><span class="lnt">511
</span><span class="lnt">512
</span><span class="lnt">513
</span><span class="lnt">514
</span><span class="lnt">515
</span><span class="lnt">516
</span><span class="lnt">517
</span><span class="lnt">518
</span><span class="lnt">519
</span><span class="lnt">520
</span><span class="lnt">521
</span><span class="lnt">522
</span><span class="lnt">523
</span><span class="lnt">524
</span><span class="lnt">525
</span><span class="lnt">526
</span><span class="lnt">527
</span><span class="lnt">528
</span><span class="lnt">529
</span><span class="lnt">530
</span><span class="lnt">531
</span><span class="lnt">532
</span><span class="lnt">533
</span><span class="lnt">534
</span><span class="lnt">535
</span><span class="lnt">536
</span><span class="lnt">537
</span><span class="lnt">538
</span><span class="lnt">539
</span><span class="lnt">540
</span><span class="lnt">541
</span><span class="lnt">542
</span><span class="lnt">543
</span><span class="lnt">544
</span><span class="lnt">545
</span><span class="lnt">546
</span><span class="lnt">547
</span><span class="lnt">548
</span><span class="lnt">549
</span><span class="lnt">550
</span><span class="lnt">551
</span><span class="lnt">552
</span><span class="lnt">553
</span><span class="lnt">554
</span><span class="lnt">555
</span><span class="lnt">556
</span><span class="lnt">557
</span><span class="lnt">558
</span><span class="lnt">559
</span><span class="lnt">560
</span><span class="lnt">561
</span><span class="lnt">562
</span><span class="lnt">563
</span><span class="lnt">564
</span><span class="lnt">565
</span><span class="lnt">566
</span><span class="lnt">567
</span><span class="lnt">568
</span><span class="lnt">569
</span><span class="lnt">570
</span><span class="lnt">571
</span><span class="lnt">572
</span><span class="lnt">573
</span><span class="lnt">574
</span><span class="lnt">575
</span><span class="lnt">576
</span><span class="lnt">577
</span><span class="lnt">578
</span><span class="lnt">579
</span><span class="lnt">580
</span><span class="lnt">581
</span><span class="lnt">582
</span><span class="lnt">583
</span><span class="lnt">584
</span><span class="lnt">585
</span><span class="lnt">586
</span><span class="lnt">587
</span><span class="lnt">588
</span><span class="lnt">589
</span><span class="lnt">590
</span><span class="lnt">591
</span><span class="lnt">592
</span><span class="lnt">593
</span><span class="lnt">594
</span><span class="lnt">595
</span><span class="lnt">596
</span><span class="lnt">597
</span><span class="lnt">598
</span><span class="lnt">599
</span><span class="lnt">600
</span><span class="lnt">601
</span><span class="lnt">602
</span><span class="lnt">603
</span><span class="lnt">604
</span><span class="lnt">605
</span><span class="lnt">606
</span><span class="lnt">607
</span><span class="lnt">608
</span><span class="lnt">609
</span><span class="lnt">610
</span><span class="lnt">611
</span><span class="lnt">612
</span><span class="lnt">613
</span><span class="lnt">614
</span><span class="lnt">615
</span><span class="lnt">616
</span><span class="lnt">617
</span><span class="lnt">618
</span><span class="lnt">619
</span><span class="lnt">620
</span><span class="lnt">621
</span><span class="lnt">622
</span><span class="lnt">623
</span><span class="lnt">624
</span><span class="lnt">625
</span><span class="lnt">626
</span><span class="lnt">627
</span><span class="lnt">628
</span><span class="lnt">629
</span><span class="lnt">630
</span><span class="lnt">631
</span><span class="lnt">632
</span><span class="lnt">633
</span><span class="lnt">634
</span><span class="lnt">635
</span><span class="lnt">636
</span><span class="lnt">637
</span><span class="lnt">638
</span><span class="lnt">639
</span><span class="lnt">640
</span><span class="lnt">641
</span><span class="lnt">642
</span><span class="lnt">643
</span><span class="lnt">644
</span><span class="lnt">645
</span><span class="lnt">646
</span><span class="lnt">647
</span><span class="lnt">648
</span><span class="lnt">649
</span><span class="lnt">650
</span><span class="lnt">651
</span><span class="lnt">652
</span><span class="lnt">653
</span><span class="lnt">654
</span><span class="lnt">655
</span><span class="lnt">656
</span><span class="lnt">657
</span><span class="lnt">658
</span><span class="lnt">659
</span><span class="lnt">660
</span><span class="lnt">661
</span><span class="lnt">662
</span><span class="lnt">663
</span><span class="lnt">664
</span><span class="lnt">665
</span><span class="lnt">666
</span><span class="lnt">667
</span><span class="lnt">668
</span><span class="lnt">669
</span><span class="lnt">670
</span><span class="lnt">671
</span><span class="lnt">672
</span><span class="lnt">673
</span><span class="lnt">674
</span><span class="lnt">675
</span><span class="lnt">676
</span><span class="lnt">677
</span><span class="lnt">678
</span><span class="lnt">679
</span><span class="lnt">680
</span><span class="lnt">681
</span><span class="lnt">682
</span><span class="lnt">683
</span><span class="lnt">684
</span><span class="lnt">685
</span><span class="lnt">686
</span><span class="lnt">687
</span><span class="lnt">688
</span><span class="lnt">689
</span><span class="lnt">690
</span><span class="lnt">691
</span><span class="lnt">692
</span><span class="lnt">693
</span><span class="lnt">694
</span><span class="lnt">695
</span><span class="lnt">696
</span><span class="lnt">697
</span><span class="lnt">698
</span><span class="lnt">699
</span><span class="lnt">700
</span><span class="lnt">701
</span><span class="lnt">702
</span><span class="lnt">703
</span><span class="lnt">704
</span><span class="lnt">705
</span><span class="lnt">706
</span><span class="lnt">707
</span><span class="lnt">708
</span><span class="lnt">709
</span><span class="lnt">710
</span><span class="lnt">711
</span><span class="lnt">712
</span><span class="lnt">713
</span><span class="lnt">714
</span><span class="lnt">715
</span><span class="lnt">716
</span><span class="lnt">717
</span><span class="lnt">718
</span><span class="lnt">719
</span><span class="lnt">720
</span><span class="lnt">721
</span><span class="lnt">722
</span><span class="lnt">723
</span><span class="lnt">724
</span><span class="lnt">725
</span><span class="lnt">726
</span><span class="lnt">727
</span><span class="lnt">728
</span><span class="lnt">729
</span><span class="lnt">730
</span><span class="lnt">731
</span><span class="lnt">732
</span><span class="lnt">733
</span><span class="lnt">734
</span><span class="lnt">735
</span><span class="lnt">736
</span><span class="lnt">737
</span><span class="lnt">738
</span><span class="lnt">739
</span><span class="lnt">740
</span><span class="lnt">741
</span><span class="lnt">742
</span><span class="lnt">743
</span><span class="lnt">744
</span><span class="lnt">745
</span><span class="lnt">746
</span><span class="lnt">747
</span><span class="lnt">748
</span><span class="lnt">749
</span><span class="lnt">750
</span><span class="lnt">751
</span><span class="lnt">752
</span><span class="lnt">753
</span><span class="lnt">754
</span><span class="lnt">755
</span><span class="lnt">756
</span><span class="lnt">757
</span><span class="lnt">758
</span><span class="lnt">759
</span><span class="lnt">760
</span><span class="lnt">761
</span><span class="lnt">762
</span><span class="lnt">763
</span><span class="lnt">764
</span><span class="lnt">765
</span><span class="lnt">766
</span><span class="lnt">767
</span><span class="lnt">768
</span><span class="lnt">769
</span><span class="lnt">770
</span><span class="lnt">771
</span><span class="lnt">772
</span><span class="lnt">773
</span><span class="lnt">774
</span><span class="lnt">775
</span><span class="lnt">776
</span><span class="lnt">777
</span><span class="lnt">778
</span><span class="lnt">779
</span><span class="lnt">780
</span><span class="lnt">781
</span><span class="lnt">782
</span><span class="lnt">783
</span><span class="lnt">784
</span><span class="lnt">785
</span><span class="lnt">786
</span><span class="lnt">787
</span><span class="lnt">788
</span><span class="lnt">789
</span><span class="lnt">790
</span><span class="lnt">791
</span><span class="lnt">792
</span><span class="lnt">793
</span><span class="lnt">794
</span><span class="lnt">795
</span><span class="lnt">796
</span><span class="lnt">797
</span><span class="lnt">798
</span><span class="lnt">799
</span><span class="lnt">800
</span><span class="lnt">801
</span><span class="lnt">802
</span><span class="lnt">803
</span><span class="lnt">804
</span><span class="lnt">805
</span><span class="lnt">806
</span><span class="lnt">807
</span><span class="lnt">808
</span><span class="lnt">809
</span><span class="lnt">810
</span><span class="lnt">811
</span><span class="lnt">812
</span><span class="lnt">813
</span><span class="lnt">814
</span><span class="lnt">815
</span><span class="lnt">816
</span><span class="lnt">817
</span><span class="lnt">818
</span><span class="lnt">819
</span><span class="lnt">820
</span><span class="lnt">821
</span><span class="lnt">822
</span><span class="lnt">823
</span><span class="lnt">824
</span><span class="lnt">825
</span><span class="lnt">826
</span><span class="lnt">827
</span><span class="lnt">828
</span><span class="lnt">829
</span><span class="lnt">830
</span><span class="lnt">831
</span><span class="lnt">832
</span><span class="lnt">833
</span><span class="lnt">834
</span><span class="lnt">835
</span><span class="lnt">836
</span><span class="lnt">837
</span><span class="lnt">838
</span><span class="lnt">839
</span><span class="lnt">840
</span><span class="lnt">841
</span><span class="lnt">842
</span><span class="lnt">843
</span><span class="lnt">844
</span><span class="lnt">845
</span><span class="lnt">846
</span><span class="lnt">847
</span><span class="lnt">848
</span><span class="lnt">849
</span><span class="lnt">850
</span><span class="lnt">851
</span><span class="lnt">852
</span><span class="lnt">853
</span><span class="lnt">854
</span><span class="lnt">855
</span><span class="lnt">856
</span><span class="lnt">857
</span><span class="lnt">858
</span><span class="lnt">859
</span><span class="lnt">860
</span><span class="lnt">861
</span><span class="lnt">862
</span><span class="lnt">863
</span><span class="lnt">864
</span><span class="lnt">865
</span><span class="lnt">866
</span><span class="lnt">867
</span><span class="lnt">868
</span><span class="lnt">869
</span><span class="lnt">870
</span><span class="lnt">871
</span><span class="lnt">872
</span><span class="lnt">873
</span><span class="lnt">874
</span><span class="lnt">875
</span><span class="lnt">876
</span><span class="lnt">877
</span><span class="lnt">878
</span><span class="lnt">879
</span><span class="lnt">880
</span><span class="lnt">881
</span><span class="lnt">882
</span><span class="lnt">883
</span><span class="lnt">884
</span><span class="lnt">885
</span><span class="lnt">886
</span><span class="lnt">887
</span><span class="lnt">888
</span><span class="lnt">889
</span><span class="lnt">890
</span><span class="lnt">891
</span><span class="lnt">892
</span><span class="lnt">893
</span><span class="lnt">894
</span><span class="lnt">895
</span><span class="lnt">896
</span><span class="lnt">897
</span><span class="lnt">898
</span><span class="lnt">899
</span><span class="lnt">900
</span><span class="lnt">901
</span><span class="lnt">902
</span><span class="lnt">903
</span><span class="lnt">904
</span><span class="lnt">905
</span><span class="lnt">906
</span><span class="lnt">907
</span><span class="lnt">908
</span><span class="lnt">909
</span><span class="lnt">910
</span><span class="lnt">911
</span><span class="lnt">912
</span><span class="lnt">913
</span><span class="lnt">914
</span><span class="lnt">915
</span><span class="lnt">916
</span><span class="lnt">917
</span><span class="lnt">918
</span><span class="lnt">919
</span><span class="lnt">920
</span><span class="lnt">921
</span><span class="lnt">922
</span><span class="lnt">923
</span><span class="lnt">924
</span><span class="lnt">925
</span><span class="lnt">926
</span><span class="lnt">927
</span><span class="lnt">928
</span><span class="lnt">929
</span><span class="lnt">930
</span><span class="lnt">931
</span><span class="lnt">932
</span><span class="lnt">933
</span><span class="lnt">934
</span><span class="lnt">935
</span><span class="lnt">936
</span><span class="lnt">937
</span><span class="lnt">938
</span><span class="lnt">939
</span><span class="lnt">940
</span><span class="lnt">941
</span><span class="lnt">942
</span><span class="lnt">943
</span><span class="lnt">944
</span><span class="lnt">945
</span><span class="lnt">946
</span><span class="lnt">947
</span><span class="lnt">948
</span><span class="lnt">949
</span><span class="lnt">950
</span><span class="lnt">951
</span><span class="lnt">952
</span><span class="lnt">953
</span><span class="lnt">954
</span><span class="lnt">955
</span><span class="lnt">956
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
</span><span class="c1">// Use of this source code is governed by a MIT style
</span><span class="c1">// license that can be found in the LICENSE file.
</span><span class="c1"></span>
<span class="kn">package</span> <span class="nx">gin</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;errors&#34;</span>
	<span class="s">&#34;io&#34;</span>
	<span class="s">&#34;io/ioutil&#34;</span>
	<span class="s">&#34;math&#34;</span>
	<span class="s">&#34;mime/multipart&#34;</span>
	<span class="s">&#34;net&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;net/url&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;strings&#34;</span>
	<span class="s">&#34;time&#34;</span>

	<span class="s">&#34;github.com/gin-contrib/sse&#34;</span>
	<span class="s">&#34;github.com/gin-gonic/gin/binding&#34;</span>
	<span class="s">&#34;github.com/gin-gonic/gin/render&#34;</span>
<span class="p">)</span>

<span class="c1">// Content-Type MIME of the most common data formats.
</span><span class="c1"></span><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">MIMEJSON</span>              <span class="p">=</span> <span class="nx">binding</span><span class="p">.</span><span class="nx">MIMEJSON</span>
	<span class="nx">MIMEHTML</span>              <span class="p">=</span> <span class="nx">binding</span><span class="p">.</span><span class="nx">MIMEHTML</span>
	<span class="nx">MIMEXML</span>               <span class="p">=</span> <span class="nx">binding</span><span class="p">.</span><span class="nx">MIMEXML</span>
	<span class="nx">MIMEXML2</span>              <span class="p">=</span> <span class="nx">binding</span><span class="p">.</span><span class="nx">MIMEXML2</span>
	<span class="nx">MIMEPlain</span>             <span class="p">=</span> <span class="nx">binding</span><span class="p">.</span><span class="nx">MIMEPlain</span>
	<span class="nx">MIMEPOSTForm</span>          <span class="p">=</span> <span class="nx">binding</span><span class="p">.</span><span class="nx">MIMEPOSTForm</span>
	<span class="nx">MIMEMultipartPOSTForm</span> <span class="p">=</span> <span class="nx">binding</span><span class="p">.</span><span class="nx">MIMEMultipartPOSTForm</span>
	<span class="nx">BodyBytesKey</span>          <span class="p">=</span> <span class="s">&#34;_gin-gonic/gin/bodybyteskey&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">abortIndex</span> <span class="kt">int8</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt8</span> <span class="o">/</span> <span class="mi">2</span>

<span class="c1">// Context is the most important part of gin. It allows us to pass variables between middleware,
</span><span class="c1">// manage the flow, validate the JSON of a request and render a JSON response for example.
</span><span class="c1">// Context是gin当中最为重要的一部分
</span><span class="c1">// 它用于在中间件当中传递变量，管理流程。例如接受json请求，并返回json
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Context</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">writermem</span> <span class="nx">responseWriter</span>
	<span class="nx">Request</span>   <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span>
	<span class="nx">Writer</span>    <span class="nx">ResponseWriter</span>

	<span class="nx">Params</span>   <span class="nx">Params</span>
	<span class="nx">handlers</span> <span class="nx">HandlersChain</span>
	<span class="nx">index</span>    <span class="kt">int8</span>

	<span class="nx">engine</span> <span class="o">*</span><span class="nx">Engine</span>

	<span class="c1">// Keys is a key/value pair exclusively for the context of each request.
</span><span class="c1"></span>	<span class="nx">Keys</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>

	<span class="c1">// Errors is a list of errors attached to all the handlers/middlewares who used this context.
</span><span class="c1"></span>	<span class="nx">Errors</span> <span class="nx">errorMsgs</span>

	<span class="c1">// Accepted defines a list of manually accepted formats for content negotiation.
</span><span class="c1"></span>	<span class="nx">Accepted</span> <span class="p">[]</span><span class="kt">string</span>
<span class="p">}</span>

<span class="cm">/************************************/</span>
<span class="cm">/********** CONTEXT CREATION ********/</span>
<span class="cm">/************************************/</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">reset</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">Writer</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">writermem</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">Params</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Params</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">handlers</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">index</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">Keys</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">Errors</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Errors</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">Accepted</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// Copy returns a copy of the current context that can be safely used outside the request&#39;s scope.
</span><span class="c1">// This has to be used when the context has to be passed to a goroutine.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Copy</span><span class="p">()</span> <span class="o">*</span><span class="nx">Context</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">cp</span> <span class="p">=</span> <span class="o">*</span><span class="nx">c</span>
	<span class="nx">cp</span><span class="p">.</span><span class="nx">writermem</span><span class="p">.</span><span class="nx">ResponseWriter</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">cp</span><span class="p">.</span><span class="nx">Writer</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">cp</span><span class="p">.</span><span class="nx">writermem</span>
	<span class="nx">cp</span><span class="p">.</span><span class="nx">index</span> <span class="p">=</span> <span class="nx">abortIndex</span>
	<span class="nx">cp</span><span class="p">.</span><span class="nx">handlers</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">cp</span>
<span class="p">}</span>

<span class="c1">// HandlerName returns the main handler&#39;s name. For example if the handler is &#34;handleGetUsers()&#34;,
</span><span class="c1">// this function will return &#34;main.handleGetUsers&#34;.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">HandlerName</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">nameOfFunction</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">handlers</span><span class="p">.</span><span class="nf">Last</span><span class="p">())</span>
<span class="p">}</span>

<span class="c1">// Handler returns the main handler.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Handler</span><span class="p">()</span> <span class="nx">HandlerFunc</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">handlers</span><span class="p">.</span><span class="nf">Last</span><span class="p">()</span>
<span class="p">}</span>

<span class="cm">/************************************/</span>
<span class="cm">/*********** FLOW CONTROL ***********/</span>
<span class="cm">/************************************/</span>

<span class="c1">// Next should be used only inside middleware.
</span><span class="c1">// It executes the pending handlers in the chain inside the calling handler.
</span><span class="c1">// See example in GitHub.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">index</span><span class="o">++</span>
	<span class="k">for</span> <span class="nx">s</span> <span class="o">:=</span> <span class="nb">int8</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">handlers</span><span class="p">));</span> <span class="nx">c</span><span class="p">.</span><span class="nx">index</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">index</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">handlers</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">index</span><span class="p">](</span><span class="nx">c</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// IsAborted returns true if the current context was aborted.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">IsAborted</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">abortIndex</span>
<span class="p">}</span>

<span class="c1">// Abort prevents pending handlers from being called. Note that this will not stop the current handler.
</span><span class="c1">// Let&#39;s say you have an authorization middleware that validates that the current request is authorized.
</span><span class="c1">// If the authorization fails (ex: the password does not match), call Abort to ensure the remaining handlers
</span><span class="c1">// for this request are not called.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Abort</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">index</span> <span class="p">=</span> <span class="nx">abortIndex</span>
<span class="p">}</span>

<span class="c1">// AbortWithStatus calls `Abort()` and writes the headers with the specified status code.
</span><span class="c1">// For example, a failed attempt to authenticate a request could use: context.AbortWithStatus(401).
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">AbortWithStatus</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Status</span><span class="p">(</span><span class="nx">code</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">Writer</span><span class="p">.</span><span class="nf">WriteHeaderNow</span><span class="p">()</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Abort</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// AbortWithStatusJSON calls `Abort()` and then `JSON` internally.
</span><span class="c1">// This method stops the chain, writes the status code and return a JSON body.
</span><span class="c1">// It also sets the Content-Type as &#34;application/json&#34;.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">AbortWithStatusJSON</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">jsonObj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Abort</span><span class="p">()</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">jsonObj</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// AbortWithError calls `AbortWithStatus()` and `Error()` internally.
</span><span class="c1">// This method stops the chain, writes the status code and pushes the specified error to `c.Errors`.
</span><span class="c1">// See Context.Error() for more details.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">AbortWithError</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="o">*</span><span class="nx">Error</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">AbortWithStatus</span><span class="p">(</span><span class="nx">code</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="cm">/************************************/</span>
<span class="cm">/********* ERROR MANAGEMENT *********/</span>
<span class="cm">/************************************/</span>

<span class="c1">// Error attaches an error to the current context. The error is pushed to a list of errors.
</span><span class="c1">// It&#39;s a good idea to call Error for each error that occurred during the resolution of a request.
</span><span class="c1">// A middleware can be used to collect all the errors and push them to a database together,
</span><span class="c1">// print a log, or append it in the HTTP response.
</span><span class="c1">// Error will panic if err is nil.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Error</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="o">*</span><span class="nx">Error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;err is nil&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">parsedError</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">Error</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">parsedError</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Error</span><span class="p">{</span>
			<span class="nx">Err</span><span class="p">:</span>  <span class="nx">err</span><span class="p">,</span>
			<span class="nx">Type</span><span class="p">:</span> <span class="nx">ErrorTypePrivate</span><span class="p">,</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">c</span><span class="p">.</span><span class="nx">Errors</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Errors</span><span class="p">,</span> <span class="nx">parsedError</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">parsedError</span>
<span class="p">}</span>

<span class="cm">/************************************/</span>
<span class="cm">/******** METADATA MANAGEMENT********/</span>
<span class="cm">/************************************/</span>

<span class="c1">// Set is used to store a new key/value pair exclusively for this context.
</span><span class="c1">// It also lazy initializes  c.Keys if it was not used previously.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Set</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Keys</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">Keys</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">Keys</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
<span class="p">}</span>

<span class="c1">// Get returns the value for the given key, ie: (value, true).
</span><span class="c1">// If the value does not exists it returns (nil, false)
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">value</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">exists</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">value</span><span class="p">,</span> <span class="nx">exists</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Keys</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// MustGet returns the value for the given key if it exists, otherwise it panics.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">MustGet</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">exists</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="nx">exists</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">value</span>
	<span class="p">}</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Key \&#34;&#34;</span> <span class="o">+</span> <span class="nx">key</span> <span class="o">+</span> <span class="s">&#34;\&#34; does not exist&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// GetString returns the value associated with the key as a string.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">GetString</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">val</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">val</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// GetBool returns the value associated with the key as a boolean.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">GetBool</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">b</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">val</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">b</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">val</span><span class="p">.(</span><span class="kt">bool</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// GetInt returns the value associated with the key as an integer.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">GetInt</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">val</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">val</span><span class="p">.(</span><span class="kt">int</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// GetInt64 returns the value associated with the key as an integer.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">GetInt64</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">i64</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">val</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">i64</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">val</span><span class="p">.(</span><span class="kt">int64</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// GetFloat64 returns the value associated with the key as a float64.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">GetFloat64</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">f64</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">val</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">f64</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">val</span><span class="p">.(</span><span class="kt">float64</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// GetTime returns the value associated with the key as time.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">GetTime</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">val</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">val</span><span class="p">.(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// GetDuration returns the value associated with the key as a duration.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">GetDuration</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">val</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">d</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">val</span><span class="p">.(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// GetStringSlice returns the value associated with the key as a slice of strings.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">GetStringSlice</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">ss</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">val</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">ss</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">val</span><span class="p">.([]</span><span class="kt">string</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// GetStringMap returns the value associated with the key as a map of interfaces.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">GetStringMap</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">sm</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">val</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">sm</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">val</span><span class="p">.(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// GetStringMapString returns the value associated with the key as a map of strings.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">GetStringMapString</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">sms</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">val</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">sms</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">val</span><span class="p">.(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// GetStringMapStringSlice returns the value associated with the key as a map to a slice of strings.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">GetStringMapStringSlice</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">smss</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">val</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">smss</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">val</span><span class="p">.(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="cm">/************************************/</span>
<span class="cm">/************ INPUT DATA ************/</span>
<span class="cm">/************************************/</span>

<span class="c1">// Param returns the value of the URL param.
</span><span class="c1">// It is a shortcut for c.Params.ByName(key)
</span><span class="c1">//     router.GET(&#34;/user/:id&#34;, func(c *gin.Context) {
</span><span class="c1">//         // a GET request to /user/john
</span><span class="c1">//         id := c.Param(&#34;id&#34;) // id == &#34;john&#34;
</span><span class="c1">//     })
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Param</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Params</span><span class="p">.</span><span class="nf">ByName</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Query returns the keyed url query value if it exists,
</span><span class="c1">// otherwise it returns an empty string `(&#34;&#34;)`.
</span><span class="c1">// It is shortcut for `c.Request.URL.Query().Get(key)`
</span><span class="c1">//     GET /path?id=1234&amp;name=Manu&amp;value=
</span><span class="c1">// 	   c.Query(&#34;id&#34;) == &#34;1234&#34;
</span><span class="c1">// 	   c.Query(&#34;name&#34;) == &#34;Manu&#34;
</span><span class="c1">// 	   c.Query(&#34;value&#34;) == &#34;&#34;
</span><span class="c1">// 	   c.Query(&#34;wtf&#34;) == &#34;&#34;
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Query</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">value</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">GetQuery</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">value</span>
<span class="p">}</span>

<span class="c1">// DefaultQuery returns the keyed url query value if it exists,
</span><span class="c1">// otherwise it returns the specified defaultValue string.
</span><span class="c1">// See: Query() and GetQuery() for further information.
</span><span class="c1">//     GET /?name=Manu&amp;lastname=
</span><span class="c1">//     c.DefaultQuery(&#34;name&#34;, &#34;unknown&#34;) == &#34;Manu&#34;
</span><span class="c1">//     c.DefaultQuery(&#34;id&#34;, &#34;none&#34;) == &#34;none&#34;
</span><span class="c1">//     c.DefaultQuery(&#34;lastname&#34;, &#34;none&#34;) == &#34;&#34;
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">DefaultQuery</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">defaultValue</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">GetQuery</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">value</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">defaultValue</span>
<span class="p">}</span>

<span class="c1">// GetQuery is like Query(), it returns the keyed url query value
</span><span class="c1">// if it exists `(value, true)` (even when the value is an empty string),
</span><span class="c1">// otherwise it returns `(&#34;&#34;, false)`.
</span><span class="c1">// It is shortcut for `c.Request.URL.Query().Get(key)`
</span><span class="c1">//     GET /?name=Manu&amp;lastname=
</span><span class="c1">//     (&#34;Manu&#34;, true) == c.GetQuery(&#34;name&#34;)
</span><span class="c1">//     (&#34;&#34;, false) == c.GetQuery(&#34;id&#34;)
</span><span class="c1">//     (&#34;&#34;, true) == c.GetQuery(&#34;lastname&#34;)
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">GetQuery</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">values</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">GetQueryArray</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">ok</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="c1">// QueryArray returns a slice of strings for a given query key.
</span><span class="c1">// The length of the slice depends on the number of params with the given key.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">QueryArray</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="nx">values</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">GetQueryArray</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">values</span>
<span class="p">}</span>

<span class="c1">// GetQueryArray returns a slice of strings for a given query key, plus
</span><span class="c1">// a boolean value whether at least one value exists for the given key.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">GetQueryArray</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">values</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nf">Query</span><span class="p">()[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">values</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">values</span><span class="p">,</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{},</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="c1">// QueryMap returns a map for a given query key.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">QueryMap</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="nx">dicts</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">GetQueryMap</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">dicts</span>
<span class="p">}</span>

<span class="c1">// GetQueryMap returns a map for a given query key, plus a boolean value
</span><span class="c1">// whether at least one value exists for the given key.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">GetQueryMap</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nf">Query</span><span class="p">(),</span> <span class="nx">key</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// PostForm returns the specified key from a POST urlencoded form or multipart form
</span><span class="c1">// when it exists, otherwise it returns an empty string `(&#34;&#34;)`.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">PostForm</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">value</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">GetPostForm</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">value</span>
<span class="p">}</span>

<span class="c1">// DefaultPostForm returns the specified key from a POST urlencoded form or multipart form
</span><span class="c1">// when it exists, otherwise it returns the specified defaultValue string.
</span><span class="c1">// See: PostForm() and GetPostForm() for further information.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">DefaultPostForm</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">defaultValue</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">GetPostForm</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">value</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">defaultValue</span>
<span class="p">}</span>

<span class="c1">// GetPostForm is like PostForm(key). It returns the specified key from a POST urlencoded
</span><span class="c1">// form or multipart form when it exists `(value, true)` (even when the value is an empty string),
</span><span class="c1">// otherwise it returns (&#34;&#34;, false).
</span><span class="c1">// For example, during a PATCH request to update the user&#39;s email:
</span><span class="c1">//     email=mail@example.com  --&gt;  (&#34;mail@example.com&#34;, true) := GetPostForm(&#34;email&#34;) // set email to &#34;mail@example.com&#34;
</span><span class="c1">// 	   email=                  --&gt;  (&#34;&#34;, true) := GetPostForm(&#34;email&#34;) // set email to &#34;&#34;
</span><span class="c1">//                             --&gt;  (&#34;&#34;, false) := GetPostForm(&#34;email&#34;) // do nothing with email
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">GetPostForm</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">values</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">GetPostFormArray</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">ok</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="c1">// PostFormArray returns a slice of strings for a given form key.
</span><span class="c1">// The length of the slice depends on the number of params with the given key.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">PostFormArray</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="nx">values</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">GetPostFormArray</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">values</span>
<span class="p">}</span>

<span class="c1">// GetPostFormArray returns a slice of strings for a given form key, plus
</span><span class="c1">// a boolean value whether at least one value exists for the given key.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">GetPostFormArray</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">req</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span>
	<span class="nx">req</span><span class="p">.</span><span class="nf">ParseForm</span><span class="p">()</span>
	<span class="nx">req</span><span class="p">.</span><span class="nf">ParseMultipartForm</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">engine</span><span class="p">.</span><span class="nx">MaxMultipartMemory</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">values</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">PostForm</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nb">len</span><span class="p">(</span><span class="nx">values</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">values</span><span class="p">,</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">MultipartForm</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">req</span><span class="p">.</span><span class="nx">MultipartForm</span><span class="p">.</span><span class="nx">File</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">values</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">MultipartForm</span><span class="p">.</span><span class="nx">Value</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nb">len</span><span class="p">(</span><span class="nx">values</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">values</span><span class="p">,</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{},</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="c1">// PostFormMap returns a map for a given form key.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">PostFormMap</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="nx">dicts</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">GetPostFormMap</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">dicts</span>
<span class="p">}</span>

<span class="c1">// GetPostFormMap returns a map for a given form key, plus a boolean value
</span><span class="c1">// whether at least one value exists for the given key.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">GetPostFormMap</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">req</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span>
	<span class="nx">req</span><span class="p">.</span><span class="nf">ParseForm</span><span class="p">()</span>
	<span class="nx">req</span><span class="p">.</span><span class="nf">ParseMultipartForm</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">engine</span><span class="p">.</span><span class="nx">MaxMultipartMemory</span><span class="p">)</span>
	<span class="nx">dicts</span><span class="p">,</span> <span class="nx">exist</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">PostForm</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">exist</span> <span class="o">&amp;&amp;</span> <span class="nx">req</span><span class="p">.</span><span class="nx">MultipartForm</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">req</span><span class="p">.</span><span class="nx">MultipartForm</span><span class="p">.</span><span class="nx">File</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">dicts</span><span class="p">,</span> <span class="nx">exist</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">MultipartForm</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">dicts</span><span class="p">,</span> <span class="nx">exist</span>
<span class="p">}</span>

<span class="c1">// get is an internal method and returns a map which satisfy conditions.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">get</span><span class="p">(</span><span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">dicts</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
	<span class="nx">exist</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">IndexByte</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="sc">&#39;[&#39;</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">k</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">key</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">IndexByte</span><span class="p">(</span><span class="nx">k</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="sc">&#39;]&#39;</span><span class="p">);</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="p">{</span>
				<span class="nx">exist</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="nx">dicts</span><span class="p">[</span><span class="nx">k</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:][:</span><span class="nx">j</span><span class="p">]]</span> <span class="p">=</span> <span class="nx">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">dicts</span><span class="p">,</span> <span class="nx">exist</span>
<span class="p">}</span>

<span class="c1">// FormFile returns the first file for the provided form key.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">FormFile</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">multipart</span><span class="p">.</span><span class="nx">FileHeader</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">fh</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nf">FormFile</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">fh</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="c1">// MultipartForm is the parsed multipart form, including file uploads.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">MultipartForm</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">multipart</span><span class="p">.</span><span class="nx">Form</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nf">ParseMultipartForm</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">engine</span><span class="p">.</span><span class="nx">MaxMultipartMemory</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">MultipartForm</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="c1">// SaveUploadedFile uploads the form file to specific dst.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">SaveUploadedFile</span><span class="p">(</span><span class="nx">file</span> <span class="o">*</span><span class="nx">multipart</span><span class="p">.</span><span class="nx">FileHeader</span><span class="p">,</span> <span class="nx">dst</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">src</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Open</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">src</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="nx">out</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="nx">dst</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">out</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">src</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// Bind checks the Content-Type to select a binding engine automatically,
</span><span class="c1">// Depending the &#34;Content-Type&#34; header different bindings are used:
</span><span class="c1">//     &#34;application/json&#34; --&gt; JSON binding
</span><span class="c1">//     &#34;application/xml&#34;  --&gt; XML binding
</span><span class="c1">// otherwise --&gt; returns an error.
</span><span class="c1">// It parses the request&#39;s body as JSON if Content-Type == &#34;application/json&#34; using JSON or XML as a JSON input.
</span><span class="c1">// It decodes the json payload into the struct specified as a pointer.
</span><span class="c1">// It writes a 400 error and sets Content-Type header &#34;text/plain&#34; in the response if input is not valid.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Bind</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="nx">binding</span><span class="p">.</span><span class="nf">Default</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ContentType</span><span class="p">())</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">MustBindWith</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// BindJSON is a shortcut for c.MustBindWith(obj, binding.JSON).
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">BindJSON</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">MustBindWith</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">binding</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// BindXML is a shortcut for c.MustBindWith(obj, binding.BindXML).
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">BindXML</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">MustBindWith</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">binding</span><span class="p">.</span><span class="nx">XML</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// BindQuery is a shortcut for c.MustBindWith(obj, binding.Query).
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">BindQuery</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">MustBindWith</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">binding</span><span class="p">.</span><span class="nx">Query</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// MustBindWith binds the passed struct pointer using the specified binding engine.
</span><span class="c1">// It will abort the request with HTTP 400 if any error ocurrs.
</span><span class="c1">// See the binding package.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">MustBindWith</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">b</span> <span class="nx">binding</span><span class="p">.</span><span class="nx">Binding</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ShouldBindWith</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">AbortWithError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">err</span><span class="p">).</span><span class="nf">SetType</span><span class="p">(</span><span class="nx">ErrorTypeBind</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// ShouldBind checks the Content-Type to select a binding engine automatically,
</span><span class="c1">// Depending the &#34;Content-Type&#34; header different bindings are used:
</span><span class="c1">//     &#34;application/json&#34; --&gt; JSON binding
</span><span class="c1">//     &#34;application/xml&#34;  --&gt; XML binding
</span><span class="c1">// otherwise --&gt; returns an error
</span><span class="c1">// It parses the request&#39;s body as JSON if Content-Type == &#34;application/json&#34; using JSON or XML as a JSON input.
</span><span class="c1">// It decodes the json payload into the struct specified as a pointer.
</span><span class="c1">// Like c.Bind() but this method does not set the response status code to 400 and abort if the json is not valid.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">ShouldBind</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="nx">binding</span><span class="p">.</span><span class="nf">Default</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ContentType</span><span class="p">())</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ShouldBindWith</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ShouldBindJSON is a shortcut for c.ShouldBindWith(obj, binding.JSON).
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">ShouldBindJSON</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ShouldBindWith</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">binding</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ShouldBindXML is a shortcut for c.ShouldBindWith(obj, binding.XML).
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">ShouldBindXML</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ShouldBindWith</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">binding</span><span class="p">.</span><span class="nx">XML</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ShouldBindQuery is a shortcut for c.ShouldBindWith(obj, binding.Query).
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">ShouldBindQuery</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ShouldBindWith</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">binding</span><span class="p">.</span><span class="nx">Query</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ShouldBindWith binds the passed struct pointer using the specified binding engine.
</span><span class="c1">// See the binding package.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">ShouldBindWith</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">b</span> <span class="nx">binding</span><span class="p">.</span><span class="nx">Binding</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Bind</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">obj</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ShouldBindBodyWith is similar with ShouldBindWith, but it stores the request
</span><span class="c1">// body into the context, and reuse when it is called again.
</span><span class="c1">//
</span><span class="c1">// NOTE: This method reads the body before binding. So you should use
</span><span class="c1">// ShouldBindWith for better performance if you need to call only once.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">ShouldBindBodyWith</span><span class="p">(</span>
	<span class="nx">obj</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">bb</span> <span class="nx">binding</span><span class="p">.</span><span class="nx">BindingBody</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">body</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="k">if</span> <span class="nx">cb</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">BodyBytesKey</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">cbb</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">cb</span><span class="p">.([]</span><span class="kt">byte</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">body</span> <span class="p">=</span> <span class="nx">cbb</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">body</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">body</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">BodyBytesKey</span><span class="p">,</span> <span class="nx">body</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">bb</span><span class="p">.</span><span class="nf">BindBody</span><span class="p">(</span><span class="nx">body</span><span class="p">,</span> <span class="nx">obj</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ClientIP implements a best effort algorithm to return the real client IP, it parses
</span><span class="c1">// X-Real-IP and X-Forwarded-For in order to work properly with reverse-proxies such us: nginx or haproxy.
</span><span class="c1">// Use X-Forwarded-For before X-Real-Ip as nginx uses X-Real-Ip with the proxy&#39;s IP.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">ClientIP</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">engine</span><span class="p">.</span><span class="nx">ForwardedByClientIP</span> <span class="p">{</span>
		<span class="nx">clientIP</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">requestHeader</span><span class="p">(</span><span class="s">&#34;X-Forwarded-For&#34;</span><span class="p">)</span>
		<span class="nx">clientIP</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">TrimSpace</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nx">clientIP</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">if</span> <span class="nx">clientIP</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="nx">clientIP</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">TrimSpace</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">requestHeader</span><span class="p">(</span><span class="s">&#34;X-Real-Ip&#34;</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">clientIP</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">clientIP</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">engine</span><span class="p">.</span><span class="nx">AppEngine</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">addr</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">requestHeader</span><span class="p">(</span><span class="s">&#34;X-Appengine-Remote-Addr&#34;</span><span class="p">);</span> <span class="nx">addr</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">addr</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">ip</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">SplitHostPort</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">TrimSpace</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">RemoteAddr</span><span class="p">));</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ip</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>

<span class="c1">// ContentType returns the Content-Type header of the request.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">ContentType</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">filterFlags</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">requestHeader</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// IsWebsocket returns true if the request headers indicate that a websocket
</span><span class="c1">// handshake is being initiated by the client.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">IsWebsocket</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">ToLower</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">requestHeader</span><span class="p">(</span><span class="s">&#34;Connection&#34;</span><span class="p">)),</span> <span class="s">&#34;upgrade&#34;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="nx">strings</span><span class="p">.</span><span class="nf">ToLower</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">requestHeader</span><span class="p">(</span><span class="s">&#34;Upgrade&#34;</span><span class="p">))</span> <span class="o">==</span> <span class="s">&#34;websocket&#34;</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">requestHeader</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="p">}</span>

<span class="cm">/************************************/</span>
<span class="cm">/******** RESPONSE RENDERING ********/</span>
<span class="cm">/************************************/</span>

<span class="c1">// bodyAllowedForStatus is a copy of http.bodyAllowedForStatus non-exported function.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">bodyAllowedForStatus</span><span class="p">(</span><span class="nx">status</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">status</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="o">&amp;&amp;</span> <span class="nx">status</span> <span class="o">&lt;=</span> <span class="mi">199</span><span class="p">:</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="k">case</span> <span class="nx">status</span> <span class="o">==</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusNoContent</span><span class="p">:</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="k">case</span> <span class="nx">status</span> <span class="o">==</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusNotModified</span><span class="p">:</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="c1">// Status sets the HTTP response code.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Status</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">writermem</span><span class="p">.</span><span class="nf">WriteHeader</span><span class="p">(</span><span class="nx">code</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Header is a intelligent shortcut for c.Writer.Header().Set(key, value).
</span><span class="c1">// It writes a header in the response.
</span><span class="c1">// If value == &#34;&#34;, this method removes the header `c.Writer.Header().Del(key)`
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Header</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">value</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">Writer</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Del</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">Writer</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// GetHeader returns value from request headers.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">GetHeader</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">requestHeader</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// GetRawData return stream data.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">GetRawData</span><span class="p">()</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// SetCookie adds a Set-Cookie header to the ResponseWriter&#39;s headers.
</span><span class="c1">// The provided cookie must have a valid Name. Invalid cookies may be
</span><span class="c1">// silently dropped.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">SetCookie</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">maxAge</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">domain</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">secure</span><span class="p">,</span> <span class="nx">httpOnly</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">path</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">path</span> <span class="p">=</span> <span class="s">&#34;/&#34;</span>
	<span class="p">}</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">SetCookie</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Cookie</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>     <span class="nx">name</span><span class="p">,</span>
		<span class="nx">Value</span><span class="p">:</span>    <span class="nx">url</span><span class="p">.</span><span class="nf">QueryEscape</span><span class="p">(</span><span class="nx">value</span><span class="p">),</span>
		<span class="nx">MaxAge</span><span class="p">:</span>   <span class="nx">maxAge</span><span class="p">,</span>
		<span class="nx">Path</span><span class="p">:</span>     <span class="nx">path</span><span class="p">,</span>
		<span class="nx">Domain</span><span class="p">:</span>   <span class="nx">domain</span><span class="p">,</span>
		<span class="nx">Secure</span><span class="p">:</span>   <span class="nx">secure</span><span class="p">,</span>
		<span class="nx">HttpOnly</span><span class="p">:</span> <span class="nx">httpOnly</span><span class="p">,</span>
	<span class="p">})</span>
<span class="p">}</span>

<span class="c1">// Cookie returns the named cookie provided in the request or
</span><span class="c1">// ErrNoCookie if not found. And return the named cookie is unescaped.
</span><span class="c1">// If multiple cookies match the given name, only one cookie will
</span><span class="c1">// be returned.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Cookie</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">cookie</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nf">Cookie</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">val</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nf">QueryUnescape</span><span class="p">(</span><span class="nx">cookie</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">val</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// Render writes the response headers and calls render.Render to render data.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Render</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">r</span> <span class="nx">render</span><span class="p">.</span><span class="nx">Render</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Status</span><span class="p">(</span><span class="nx">code</span><span class="p">)</span>

	<span class="k">if</span> <span class="p">!</span><span class="nf">bodyAllowedForStatus</span><span class="p">(</span><span class="nx">code</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">.</span><span class="nf">WriteContentType</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">Writer</span><span class="p">.</span><span class="nf">WriteHeaderNow</span><span class="p">()</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Writer</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// HTML renders the HTTP template specified by its file name.
</span><span class="c1">// It also updates the HTTP code and sets the Content-Type as &#34;text/html&#34;.
</span><span class="c1">// See http://golang.org/doc/articles/wiki/
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">HTML</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">instance</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">engine</span><span class="p">.</span><span class="nx">HTMLRender</span><span class="p">.</span><span class="nf">Instance</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">obj</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">instance</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// IndentedJSON serializes the given struct as pretty JSON (indented + endlines) into the response body.
</span><span class="c1">// It also sets the Content-Type as &#34;application/json&#34;.
</span><span class="c1">// WARNING: we recommend to use this only for development purposes since printing pretty JSON is
</span><span class="c1">// more CPU and bandwidth consuming. Use Context.JSON() instead.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">IndentedJSON</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">render</span><span class="p">.</span><span class="nx">IndentedJSON</span><span class="p">{</span><span class="nx">Data</span><span class="p">:</span> <span class="nx">obj</span><span class="p">})</span>
<span class="p">}</span>

<span class="c1">// SecureJSON serializes the given struct as Secure JSON into the response body.
</span><span class="c1">// Default prepends &#34;while(1),&#34; to response body if the given struct is array values.
</span><span class="c1">// It also sets the Content-Type as &#34;application/json&#34;.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">SecureJSON</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">render</span><span class="p">.</span><span class="nx">SecureJSON</span><span class="p">{</span><span class="nx">Prefix</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">engine</span><span class="p">.</span><span class="nx">secureJsonPrefix</span><span class="p">,</span> <span class="nx">Data</span><span class="p">:</span> <span class="nx">obj</span><span class="p">})</span>
<span class="p">}</span>

<span class="c1">// JSONP serializes the given struct as JSON into the response body.
</span><span class="c1">// It add padding to response body to request data from a server residing in a different domain than the client.
</span><span class="c1">// It also sets the Content-Type as &#34;application/javascript&#34;.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">JSONP</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">callback</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">DefaultQuery</span><span class="p">(</span><span class="s">&#34;callback&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">callback</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">render</span><span class="p">.</span><span class="nx">JSON</span><span class="p">{</span><span class="nx">Data</span><span class="p">:</span> <span class="nx">obj</span><span class="p">})</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">render</span><span class="p">.</span><span class="nx">JsonpJSON</span><span class="p">{</span><span class="nx">Callback</span><span class="p">:</span> <span class="nx">callback</span><span class="p">,</span> <span class="nx">Data</span><span class="p">:</span> <span class="nx">obj</span><span class="p">})</span>
<span class="p">}</span>

<span class="c1">// JSON serializes the given struct as JSON into the response body.
</span><span class="c1">// It also sets the Content-Type as &#34;application/json&#34;.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">JSON</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">render</span><span class="p">.</span><span class="nx">JSON</span><span class="p">{</span><span class="nx">Data</span><span class="p">:</span> <span class="nx">obj</span><span class="p">})</span>
<span class="p">}</span>

<span class="c1">// AsciiJSON serializes the given struct as JSON into the response body with unicode to ASCII string.
</span><span class="c1">// It also sets the Content-Type as &#34;application/json&#34;.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">AsciiJSON</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">render</span><span class="p">.</span><span class="nx">AsciiJSON</span><span class="p">{</span><span class="nx">Data</span><span class="p">:</span> <span class="nx">obj</span><span class="p">})</span>
<span class="p">}</span>

<span class="c1">// XML serializes the given struct as XML into the response body.
</span><span class="c1">// It also sets the Content-Type as &#34;application/xml&#34;.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">XML</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">render</span><span class="p">.</span><span class="nx">XML</span><span class="p">{</span><span class="nx">Data</span><span class="p">:</span> <span class="nx">obj</span><span class="p">})</span>
<span class="p">}</span>

<span class="c1">// YAML serializes the given struct as YAML into the response body.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">YAML</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">render</span><span class="p">.</span><span class="nx">YAML</span><span class="p">{</span><span class="nx">Data</span><span class="p">:</span> <span class="nx">obj</span><span class="p">})</span>
<span class="p">}</span>

<span class="c1">// ProtoBuf serializes the given struct as ProtoBuf into the response body.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">ProtoBuf</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">render</span><span class="p">.</span><span class="nx">ProtoBuf</span><span class="p">{</span><span class="nx">Data</span><span class="p">:</span> <span class="nx">obj</span><span class="p">})</span>
<span class="p">}</span>

<span class="c1">// String writes the given string into the response body.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">String</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">values</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">render</span><span class="p">.</span><span class="nx">String</span><span class="p">{</span><span class="nx">Format</span><span class="p">:</span> <span class="nx">format</span><span class="p">,</span> <span class="nx">Data</span><span class="p">:</span> <span class="nx">values</span><span class="p">})</span>
<span class="p">}</span>

<span class="c1">// Redirect returns a HTTP redirect to the specific location.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Redirect</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">location</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">render</span><span class="p">.</span><span class="nx">Redirect</span><span class="p">{</span>
		<span class="nx">Code</span><span class="p">:</span>     <span class="nx">code</span><span class="p">,</span>
		<span class="nx">Location</span><span class="p">:</span> <span class="nx">location</span><span class="p">,</span>
		<span class="nx">Request</span><span class="p">:</span>  <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span>
	<span class="p">})</span>
<span class="p">}</span>

<span class="c1">// Data writes some data into the body stream and updates the HTTP code.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Data</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">contentType</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">render</span><span class="p">.</span><span class="nx">Data</span><span class="p">{</span>
		<span class="nx">ContentType</span><span class="p">:</span> <span class="nx">contentType</span><span class="p">,</span>
		<span class="nx">Data</span><span class="p">:</span>        <span class="nx">data</span><span class="p">,</span>
	<span class="p">})</span>
<span class="p">}</span>

<span class="c1">// DataFromReader writes the specified reader into the body stream and updates the HTTP code.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">DataFromReader</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">contentLength</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">contentType</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">reader</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">,</span> <span class="nx">extraHeaders</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">render</span><span class="p">.</span><span class="nx">Reader</span><span class="p">{</span>
		<span class="nx">Headers</span><span class="p">:</span>       <span class="nx">extraHeaders</span><span class="p">,</span>
		<span class="nx">ContentType</span><span class="p">:</span>   <span class="nx">contentType</span><span class="p">,</span>
		<span class="nx">ContentLength</span><span class="p">:</span> <span class="nx">contentLength</span><span class="p">,</span>
		<span class="nx">Reader</span><span class="p">:</span>        <span class="nx">reader</span><span class="p">,</span>
	<span class="p">})</span>
<span class="p">}</span>

<span class="c1">// File writes the specified file into the body stream in a efficient way.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">File</span><span class="p">(</span><span class="nx">filepath</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">ServeFile</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">filepath</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// SSEvent writes a Server-Sent Event into the body stream.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">SSEvent</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">message</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">sse</span><span class="p">.</span><span class="nx">Event</span><span class="p">{</span>
		<span class="nx">Event</span><span class="p">:</span> <span class="nx">name</span><span class="p">,</span>
		<span class="nx">Data</span><span class="p">:</span>  <span class="nx">message</span><span class="p">,</span>
	<span class="p">})</span>
<span class="p">}</span>

<span class="c1">// Stream sends a streaming response.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Stream</span><span class="p">(</span><span class="nx">step</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">w</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Writer</span>
	<span class="nx">clientGone</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nf">CloseNotify</span><span class="p">()</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">clientGone</span><span class="p">:</span>
			<span class="k">return</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nx">keepOpen</span> <span class="o">:=</span> <span class="nf">step</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
			<span class="nx">w</span><span class="p">.</span><span class="nf">Flush</span><span class="p">()</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">keepOpen</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/************************************/</span>
<span class="cm">/******** CONTENT NEGOTIATION *******/</span>
<span class="cm">/************************************/</span>

<span class="c1">// Negotiate contains all negotiations data.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Negotiate</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Offered</span>  <span class="p">[]</span><span class="kt">string</span>
	<span class="nx">HTMLName</span> <span class="kt">string</span>
	<span class="nx">HTMLData</span> <span class="kd">interface</span><span class="p">{}</span>
	<span class="nx">JSONData</span> <span class="kd">interface</span><span class="p">{}</span>
	<span class="nx">XMLData</span>  <span class="kd">interface</span><span class="p">{}</span>
	<span class="nx">Data</span>     <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// Negotiate calls different Render according acceptable Accept format.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Negotiate</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">config</span> <span class="nx">Negotiate</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">c</span><span class="p">.</span><span class="nf">NegotiateFormat</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">Offered</span><span class="o">...</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">binding</span><span class="p">.</span><span class="nx">MIMEJSON</span><span class="p">:</span>
		<span class="nx">data</span> <span class="o">:=</span> <span class="nf">chooseData</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">JSONData</span><span class="p">,</span> <span class="nx">config</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>

	<span class="k">case</span> <span class="nx">binding</span><span class="p">.</span><span class="nx">MIMEHTML</span><span class="p">:</span>
		<span class="nx">data</span> <span class="o">:=</span> <span class="nf">chooseData</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">HTMLData</span><span class="p">,</span> <span class="nx">config</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">HTML</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">config</span><span class="p">.</span><span class="nx">HTMLName</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>

	<span class="k">case</span> <span class="nx">binding</span><span class="p">.</span><span class="nx">MIMEXML</span><span class="p">:</span>
		<span class="nx">data</span> <span class="o">:=</span> <span class="nf">chooseData</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">XMLData</span><span class="p">,</span> <span class="nx">config</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">XML</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>

	<span class="k">default</span><span class="p">:</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">AbortWithError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusNotAcceptable</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;the accepted formats are not offered by the server&#34;</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// NegotiateFormat returns an acceptable Accept format.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">NegotiateFormat</span><span class="p">(</span><span class="nx">offered</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nf">assert1</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">offered</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;you must provide at least one offer&#34;</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Accepted</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">Accepted</span> <span class="p">=</span> <span class="nf">parseAccept</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">requestHeader</span><span class="p">(</span><span class="s">&#34;Accept&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Accepted</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">offered</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">accepted</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Accepted</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">offert</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">offered</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">accepted</span> <span class="o">==</span> <span class="nx">offert</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">offert</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>

<span class="c1">// SetAccepted sets Accept header data.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">SetAccepted</span><span class="p">(</span><span class="nx">formats</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">Accepted</span> <span class="p">=</span> <span class="nx">formats</span>
<span class="p">}</span>

<span class="cm">/************************************/</span>
<span class="cm">/***** GOLANG.ORG/X/NET/CONTEXT *****/</span>
<span class="cm">/************************************/</span>

<span class="c1">// Deadline returns the time when work done on behalf of this context
</span><span class="c1">// should be canceled. Deadline returns ok==false when no deadline is
</span><span class="c1">// set. Successive calls to Deadline return the same results.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Deadline</span><span class="p">()</span> <span class="p">(</span><span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// Done returns a channel that&#39;s closed when work done on behalf of this
</span><span class="c1">// context should be canceled. Done may return nil if this context can
</span><span class="c1">// never be canceled. Successive calls to Done return the same value.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// Err returns a non-nil error value after Done is closed,
</span><span class="c1">// successive calls to Err return the same error.
</span><span class="c1">// If Done is not yet closed, Err returns nil.
</span><span class="c1">// If Done is closed, Err returns a non-nil error explaining why:
</span><span class="c1">// Canceled if the context was canceled
</span><span class="c1">// or DeadlineExceeded if the context&#39;s deadline passed.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Err</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// Value returns the value associated with this context for key, or nil
</span><span class="c1">// if no value is associated with key. Successive calls to Value with
</span><span class="c1">// the same key returns the same result.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Value</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">keyAsString</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">key</span><span class="p">.(</span><span class="kt">string</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">val</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">keyAsString</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">val</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/gin/">Gin</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
