<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>operator=的正确写法 | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="返回一个 reference to *this。 关于赋值，有趣的是你可以把它们写成连锁形式： int x, y, z; x = y - z = 15; //赋值连锁形式 同样有趣的是，赋值采用右结合律，所">
<meta name="author" content="">
<link rel="canonical" href="/post/operator-%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="operator=的正确写法" />
<meta property="og:description" content="返回一个 reference to *this。 关于赋值，有趣的是你可以把它们写成连锁形式： int x, y, z; x = y - z = 15; //赋值连锁形式 同样有趣的是，赋值采用右结合律，所" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/operator-%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-08-31T12:10:49&#43;00:00" />
<meta property="article:modified_time" content="2017-08-31T12:10:49&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="operator=的正确写法"/>
<meta name="twitter:description" content="返回一个 reference to *this。 关于赋值，有趣的是你可以把它们写成连锁形式： int x, y, z; x = y - z = 15; //赋值连锁形式 同样有趣的是，赋值采用右结合律，所"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "operator=的正确写法",
      "item": "/post/operator-%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "operator=的正确写法",
  "name": "operator=的正确写法",
  "description": "返回一个 reference to *this。 关于赋值，有趣的是你可以把它们写成连锁形式： int x, y, z; x = y - z = 15; //赋值连锁形式 同样有趣的是，赋值采用右结合律，所",
  "keywords": [
    
  ],
  "articleBody": "返回一个 reference to *this。 关于赋值，有趣的是你可以把它们写成连锁形式：\nint x, y, z;\rx = y - z = 15;\t//赋值连锁形式\r 同样有趣的是，赋值采用右结合律，所以上述连锁赋值被解析为：\nx = (y = (z = 15));\r 这里15先被赋值给z,然后其结果（更新后的z)再被赋值给y,然后其结果（更新后的y)再被赋值给X。\n为了实现“连锁赋值”，赋值操作符必须返回一个reference指向操作符的左侧实参。这是你为classes实现赋值操作符时应该遵循的协议：\nclass Widget {\rpublic:\rWidget \u0026 operator=(const Widget\u0026 rhs)\t{\r...\rreturn *this;\r}\r};\r 这个协议不仅适用于以上的标准赋值形式，也适用于所有赋值相关运算，例如\"+=,-=,*=,等等。\n使operator=具有异常安全性 假设你建立一个class用来保存一个指针指向一块动态分配的位图（bitmap):\nclass Bitmap { ... };\rclass Widget {\rprivate:\rBitmap* pb;\t//指针，指向一个从heap分配而得的对象\r}；\r 下面是operator实现代码，表面上看起来合理，但自我赋值出现时并不安全,也不具备异常安全性。\n这里的自我赋值问题是，operator函数内的*this (赋值的目的端）和rhs有可能是同一个对象。果真如此delete就不只是销毁当前对象的bitmap,它也销毁rhs的bitmap。\n欲阻止这种错误，传统做法是藉由operator=最前面的一个“证同测试（identitytest) ”达到“自我赋值”的检验.\n这个新版本仍然存在异常方面的麻烦。更明确地说，如果”new Bitmap\"导致异常（不论是因为分配时内存不足或因为Bitnap的copy构造函数抛出异常），Widget最终会持有一个指针指向一块被删除的Bitmap。这样的指针有害。你无法安全地删除它们，甚至无法安全地读取它们。\n令人高兴的是，让operator具备“异常安全性”往往自动获得“自我赋值安全”的回报。因此愈来愈多人对“自我赋值”的处理态度是倾向不去管它，把焦点放在实现“异常安全性”（exception safety)上。\n使用所谓的copy and swap技术.\n提供一个特化的swap函数 所谓swap (置换）两对象值，意思是将两对象的值彼此赋予对方。缺省情况下动作可由标准程序库提供的swap算法完成。其典型实现完全如你所预期：\nnamespace std {\rtemplate//std:: swap 的典型实现；\rvoid swap( T\u0026 a, T\u0026 b)\t//置换 a 和 b 的值.\r{\rT temp(a);\ra = b;\rb = temp;\r}\r}\r 这缺省的swap实现版本十分平淡，无法刺激你的肾上腺。它涉及三个对象的复制:a复制到temp, b复制到a,以及temp复制到b。但是对某些类型而言，这些复制动作无一必要；对它们而言swap缺省行为等于是把高速铁路铺设在慢速小巷弄内。\n其中最主要的就是“以指针指向一个对象，内含真正数据”那种类型。这种设计的常见表现形式是所谓“pimpl手法”（pimpl是\"pointer to implementation\"的缩写。如果以这种手法设计Widget class,看起来会像这样：\n以操作符复合形式(op=)取代其独身形式(op) 确保 operator 的赋值形式(assignment version)(例如 operator+=)与一个operator 的单独形式(stand-alone)(例如 operator+ )之间存在正常的关系，一种好方法是后者(指 operator+ 译者注)根据前者(指operator+= 译者注)来实现\n这很容易:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Rational { public: ... Rational\u0026 operator+=(const Rational\u0026 rhs); Rational\u0026 operator-=(const Rational\u0026 rhs); }; // operator+ 根据 operator+=实现;  operator+(const Rational\u0026 lhs, const Rational\u0026 rhs) { return Rational(lhs) += rhs; } // operator- 根据 operator -= 来实现  const Rational operator-(const Rational\u0026 lhs, const Rational\u0026 rhs) { return Rational(lhs) -= rhs; }   在这个例子里，从零开始实现 operator+=和-=，而 operator+ 和 operator- 则是通过调用前述的函数来提供自己的功能。使用这种设计方法，只用维护 operator 的赋值形式就行了。而且如果假设 operator 赋值形式在类的 public 接口里，这就不用让 operator 的单独形式成为类的友元.\n如果你不介意把所有的 operator 的单独形式放在全局域里，那就可以使用模板来替代 单独形式的函数的编写:\ntemplateconst T operator+(const T\u0026 lhs, const T\u0026 rhs)\r{\rreturn T(lhs) += rhs; // 参见下面的讨论\r}\rtemplateconst T operator-(const T\u0026 lhs, const T\u0026 rhs) {\rreturn T(lhs) -= rhs; // 参见下面的讨论 }\r...\r 使用这些模板，只要为 operator 赋值形式定义某种类型，一旦需要，其对应的operator独身形式就会被自动生成。\n在这里值得指出的是三个效率方面的问题。\n  总的来说 operator 的复合形式比其单独形式效率更高，因为单独形式要返回一个新对象，从而在临时对象的构造和释放上有一些开销。operator 的赋值形式把 结果写到左边的参数里，因此不需要生成临时对象来容纳 operator 的返回值。\n  提供 operator 的复合形式的同时也要提供其标准形式，允许类的客户端在便利 与效率上做出折衷选择。也就是说，客户端可以决定是这样编写:\n Rational a, b, c, d, result;\r...\rresult = a + b + c + d;\r 还是这样编写:\n result = a;\rresult += b;\rresult += c;\rresult += d;\r 前者比较容易编写、debug 和维护，并且在 80%的时间里它的性能是可以被接受的。后者具有更高的效率，估计这对于汇编语言程序员来说会更直观一些。通过 提供两种方案，你可以让客户端开发人员用更容易阅读的单独形式的 operator 来开发和 debug 代码，同时保留用效率更高的 operator 赋值形式替代单独形式的权力。而且根据 operator 的赋值形式实现其单独形式，这样你能确保当客户端从一种形式切换到另一种形 式时，操作的语义可以保持不变。\n  涉及到 operator 单独形式的实现。再看看 operator+ 的实现:\n templateconst T operator+(const T\u0026 lhs, const T\u0026 rhs)\r{ return T(lhs) += rhs; }\r 表达式 T(lhs)调用了 T 的拷贝构造函数。它建立一个临时对象，其值与 lhs 一样。这 个临时对象用来与 rhs 一起调用 operator+= ，操作的结果被从 operator+返回。这个代码 好像不用写得这么隐密。这样写不是更好么?\n templateconst T operator+(const T\u0026 lhs, const T\u0026 rhs) {\rT result(lhs); // 拷贝 lhs 到 result 中\rreturn result += rhs; // rhs 与它相加并返回结果 }\r 这个模板几乎与前面的程序相同，但是它们之间还是存在重要的差别。第二个模板包含 一个命名对象，result。这个命名对象意味着不能在 operator+ 里使用返回值优化。第一种实现方法总可以使用返回值优化，所以编译器为其生成优化代码的可能 就会更大。\n  现在,必须指出\nreturn T(lhs) += rhs;  比大多数编译器希望进行的返回值优化更复杂。上面第一个函数实现也有这样的临时对象开销，就象你为使用命名对象 result 而耗费的开销一样。然而匿名对象在比命名对象更容易清除，因此当我们面对在命名对象和临时对象间进行选择时，用临时对象更好一些。它使你耗费的开销不会比命名的对象还多，特别是使用老编译器时，它的耗费会更少。\n这里谈论的命名对象、未命名对象和编译优化是很有趣的，但是主要的一点是 operator 的复合形式(operator+=)比独身形式(operator+)效率更高。做为一个库程序设计者，应该两者都提供，作为一个应用程序的开发者，在优先考虑性能时你应该考虑考虑用operator 复合形式代替独身形式。\n复制对象时勿忘其每一个成分 当你编写一个函数，请确保（1)复制所有local成员变量，（2)调用所有base classes内的适当的copying 函数。\n",
  "wordCount" : "2761",
  "inLanguage": "zh-cn",
  "datePublished": "2017-08-31T12:10:49Z",
  "dateModified": "2017-08-31T12:10:49Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/operator-%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      operator=的正确写法
    </h1>
    <div class="post-meta">August 31, 2017
</div>
  </header> 
  <div class="post-content"><h2 id="返回一个-reference-to-this">返回一个 reference to *this。<a hidden class="anchor" aria-hidden="true" href="#返回一个-reference-to-this">#</a></h2>
<p>关于赋值，有趣的是你可以把它们写成连锁形式：</p>
<pre><code>int x, y, z;
x = y - z = 15;	//赋值连锁形式
</code></pre>
<p>同样有趣的是，赋值采用右结合律，所以上述连锁赋值被解析为：</p>
<pre><code>x = (y = (z = 15));
</code></pre>
<p>这里15先被赋值给z,然后其结果（更新后的z)再被赋值给y,然后其结果（更新后的y)再被赋值给X。</p>
<p>为了实现“连锁赋值”，赋值操作符必须返回一个reference指向操作符的左侧实参。这是你为classes实现赋值操作符时应该遵循的协议：</p>
<pre><code>class Widget {
public:
Widget &amp; operator=(const Widget&amp; rhs)	{
	...
	return *this;
}
};
</code></pre>
<p>这个协议不仅适用于以上的标准赋值形式，也适用于所有赋值相关运算，例如&quot;+=,-=,*=,等等。</p>
<h2 id="使operator具有异常安全性">使operator=具有异常安全性<a hidden class="anchor" aria-hidden="true" href="#使operator具有异常安全性">#</a></h2>
<p>假设你建立一个class用来保存一个指针指向一块动态分配的位图（bitmap):</p>
<pre><code>class Bitmap { ... };
class Widget {
private:
Bitmap* pb;	//指针，指向一个从heap分配而得的对象
}；
</code></pre>
<p>下面是operator实现代码，表面上看起来合理，但自我赋值出现时并不安全,也不具备异常安全性。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170831-125450@2x.png" alt=""  />
</p>
<p>这里的自我赋值问题是，operator函数内的*this (赋值的目的端）和rhs有可能是同一个对象。果真如此delete就不只是销毁当前对象的bitmap,它也销毁rhs的bitmap。</p>
<p>欲阻止这种错误，传统做法是藉由operator=最前面的一个“证同测试（identitytest) ”达到“自我赋值”的检验.</p>
<p>这个新版本仍然存在异常方面的麻烦。更明确地说，如果”new Bitmap&quot;导致异常（不论是因为分配时内存不足或因为Bitnap的copy构造函数抛出异常），Widget最终会持有一个指针指向一块被删除的Bitmap。这样的指针有害。你无法安全地删除它们，甚至无法安全地读取它们。</p>
<p>令人高兴的是，让operator具备“异常安全性”往往自动获得“自我赋值安全”的回报。因此愈来愈多人对“自我赋值”的处理态度是倾向不去管它，把焦点放在实现“异常安全性”（exception safety)上。</p>
<p>使用所谓的copy and swap技术.</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170831-130544@2x.png" alt=""  />
</p>
<h2 id="提供一个特化的swap函数">提供一个特化的swap函数<a hidden class="anchor" aria-hidden="true" href="#提供一个特化的swap函数">#</a></h2>
<p>所谓swap (置换）两对象值，意思是将两对象的值彼此赋予对方。缺省情况下动作可由标准程序库提供的swap算法完成。其典型实现完全如你所预期：</p>
<pre><code>namespace std {
	template&lt;typename T&gt;	//std:: swap 的典型实现；
	void swap( T&amp; a, T&amp; b)	//置换 a 和 b 的值.
	{
        T temp(a);
        a = b;
        b = temp;
	}
}
</code></pre>
<p>这缺省的swap实现版本十分平淡，无法刺激你的肾上腺。它涉及三个对象的复制:a复制到temp, b复制到a,以及temp复制到b。但是对某些类型而言，这些复制动作无一必要；对它们而言swap缺省行为等于是把高速铁路铺设在慢速小巷弄内。</p>
<p>其中最主要的就是“以指针指向一个对象，内含真正数据”那种类型。这种设计的常见表现形式是所谓“pimpl手法”（pimpl是&quot;pointer to implementation&quot;的缩写。如果以这种手法设计Widget class,看起来会像这样：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170831-154920@2x.png" alt=""  />

<img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170831-155754@2x.png" alt=""  />

<img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170831-155840@2x.png" alt=""  />

<img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170831-160100@2x.png" alt=""  />

<img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170831-160533@2x.png" alt=""  />

<img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170831-160603@2x.png" alt=""  />

<img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170831-160706@2x.png" alt=""  />

<img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170831-160739@2x.png" alt=""  />

<img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170831-160739@2x.png" alt=""  />

<img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170831-160914@2x.png" alt=""  />

<img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170831-160944@2x.png" alt=""  />
</p>
<h2 id="以操作符复合形式op取代其独身形式op">以操作符复合形式(op=)取代其独身形式(op)<a hidden class="anchor" aria-hidden="true" href="#以操作符复合形式op取代其独身形式op">#</a></h2>
<p>确保 operator 的赋值形式(assignment version)(例如 operator+=)与一个operator 的单独形式(stand-alone)(例如 operator+ )之间存在正常的关系，一种好方法是后者(指 operator+ 译者注)根据前者(指operator+= 译者注)来实现</p>
<p>这很容易:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Rational</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="p">...</span>
<span class="n">Rational</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span> 
<span class="n">Rational</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">-=</span><span class="p">(</span><span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// operator+ 根据 operator+=实现;
</span><span class="c1"></span>
<span class="n">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">Rational</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// operator- 根据 operator -= 来实现
</span><span class="c1"></span>
<span class="k">const</span> <span class="n">Rational</span> <span class="n">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">Rational</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">-=</span> <span class="n">rhs</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这个例子里，从零开始实现 operator+=和-=，而 operator+ 和 operator- 则是通过调用前述的函数来提供自己的功能。使用这种设计方法，只用维护 operator 的赋值形式就行了。而且如果假设 operator 赋值形式在类的 public 接口里，这就不用让 operator 的单独形式成为类的友元.</p>
<p>如果你不介意把所有的 operator 的单独形式放在全局域里，那就可以使用模板来替代 单独形式的函数的编写:</p>
<pre><code>template&lt;class T&gt;
const T operator+(const T&amp; lhs, const T&amp; rhs)
{
return T(lhs) += rhs; // 参见下面的讨论
}
template&lt;class T&gt;
const T operator-(const T&amp; lhs, const T&amp; rhs) {
return T(lhs) -= rhs; // 参见下面的讨论 }
...
</code></pre>
<p>使用这些模板，只要为 operator 赋值形式定义某种类型，一旦需要，其对应的operator独身形式就会被自动生成。</p>
<p>在这里值得指出的是三个效率方面的问题。</p>
<ol>
<li>
<p>总的来说 operator 的复合形式比其单独形式效率更高，因为单独形式要返回一个新对象，从而在临时对象的构造和释放上有一些开销。operator 的赋值形式把 结果写到左边的参数里，因此不需要生成临时对象来容纳 operator 的返回值。</p>
</li>
<li>
<p>提供 operator 的复合形式的同时也要提供其标准形式，允许类的客户端在便利
与效率上做出折衷选择。也就是说，客户端可以决定是这样编写:</p>
<pre><code> Rational a, b, c, d, result;
 ...
 result = a + b + c + d;
</code></pre>
<p>还是这样编写:</p>
<pre><code> result = a;
 result += b;
 result += c;
 result += d;
</code></pre>
<p>前者比较容易编写、debug 和维护，并且在 80%的时间里它的性能是可以被接受的。后者具有更高的效率，估计这对于汇编语言程序员来说会更直观一些。通过 提供两种方案，你可以让客户端开发人员用更容易阅读的单独形式的 operator 来开发和 debug 代码，同时保留用效率更高的 operator 赋值形式替代单独形式的权力。而且根据 operator 的赋值形式实现其单独形式，这样你能确保当客户端从一种形式切换到另一种形 式时，操作的语义可以保持不变。</p>
</li>
<li>
<p>涉及到 operator 单独形式的实现。再看看 operator+ 的实现:</p>
<pre><code> template&lt;class T&gt;
 const T operator+(const T&amp; lhs, const T&amp; rhs)
 { return T(lhs) += rhs; }
</code></pre>
<p>表达式 T(lhs)调用了 T 的拷贝构造函数。它建立一个临时对象，其值与 lhs 一样。这 个临时对象用来与 rhs 一起调用 operator+= ，操作的结果被从 operator+返回。这个代码 好像不用写得这么隐密。这样写不是更好么?</p>
<pre><code> template&lt;class T&gt;
 const T operator+(const T&amp; lhs, const T&amp; rhs) {
 T result(lhs); // 拷贝 lhs 到 result 中
 return result += rhs; // rhs 与它相加并返回结果 }
</code></pre>
<p>这个模板几乎与前面的程序相同，但是它们之间还是存在重要的差别。第二个模板包含 一个命名对象，result。这个命名对象意味着不能在 operator+ 里使用返回值优化。第一种实现方法总可以使用返回值优化，所以编译器为其生成优化代码的可能 就会更大。</p>
</li>
</ol>
<p>现在,必须指出</p>
<pre><code>return T(lhs) += rhs; 
</code></pre>
<p>比大多数编译器希望进行的返回值优化更复杂。上面第一个函数实现也有这样的临时对象开销，就象你为使用命名对象 result 而耗费的开销一样。然而匿名对象在比命名对象更容易清除，因此当我们面对在命名对象和临时对象间进行选择时，用临时对象更好一些。它使你耗费的开销不会比命名的对象还多，特别是使用老编译器时，它的耗费会更少。</p>
<p>这里谈论的命名对象、未命名对象和编译优化是很有趣的，但是主要的一点是 operator 的复合形式(operator+=)比独身形式(operator+)效率更高。做为一个库程序设计者，应该两者都提供，作为一个应用程序的开发者，在优先考虑性能时你应该考虑考虑用operator 复合形式代替独身形式。</p>
<h2 id="复制对象时勿忘其每一个成分">复制对象时勿忘其每一个成分<a hidden class="anchor" aria-hidden="true" href="#复制对象时勿忘其每一个成分">#</a></h2>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170831-130955@2x.png" alt=""  />
</p>
<p>当你编写一个函数，请确保（1)复制所有local成员变量，（2)调用所有base classes内的适当的copying 函数。</p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
