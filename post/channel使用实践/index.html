<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Channel使用实践 | Forz Blog</title>
<meta name="keywords" content="Go" />
<meta name="description" content="应用场景 Channel 的应用场景分为五种类型。 数据交流: 当作并发的 buffer 或者 queue,解决生产者 - 消费者问题。多个 goroutine 可以并发当作生产者(Producer)">
<meta name="author" content="">
<link rel="canonical" href="/post/channel%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Channel使用实践" />
<meta property="og:description" content="应用场景 Channel 的应用场景分为五种类型。 数据交流: 当作并发的 buffer 或者 queue,解决生产者 - 消费者问题。多个 goroutine 可以并发当作生产者(Producer)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/channel%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-05-21T14:58:45&#43;00:00" />
<meta property="article:modified_time" content="2021-05-21T14:58:45&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Channel使用实践"/>
<meta name="twitter:description" content="应用场景 Channel 的应用场景分为五种类型。 数据交流: 当作并发的 buffer 或者 queue,解决生产者 - 消费者问题。多个 goroutine 可以并发当作生产者(Producer)"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Channel使用实践",
      "item": "/post/channel%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Channel使用实践",
  "name": "Channel使用实践",
  "description": "应用场景 Channel 的应用场景分为五种类型。 数据交流: 当作并发的 buffer 或者 queue,解决生产者 - 消费者问题。多个 goroutine 可以并发当作生产者(Producer)",
  "keywords": [
    "Go"
  ],
  "articleBody": "应用场景 Channel 的应用场景分为五种类型。\n 数据交流: 当作并发的 buffer 或者 queue,解决生产者 - 消费者问题。多个 goroutine 可以并发当作生产者(Producer)和消费者(Consumer)。 数据传递:一个 goroutine 将数据交给另一个 goroutine,相当于把数据的拥有权 (引用) 托付出去。 信号通知:一个 goroutine 可以将信号 (closing、closed、data ready 等) 传递给另一个或者另一组 goroutine 。 任务编排:可以让一组 goroutine 按照一定的顺序并发或者串行的执行,这就是编排的功能。 锁:利用 Channel 也可以实现互斥锁的机制。  Go 的开发者极力推荐使用 Channel,不过,这两年,大家意识到,Channel 并不是处理并发问题的“银弹”,有时候使用并发原语更简单,而且不容易出错。所以,我给你提供一套选择的方法:\n 共享资源的并发访问使用传统并发原语; 复杂的任务编排和消息传递使用 Channel; 消息通知机制使用 Channel,除非只想 signal 一个 goroutine,才使用 Cond; 简单等待所有任务的完成用 WaitGroup,也有 Channel 的推崇者用 Channel,都可以; 需要和 Select 语句结合,使用 Channel; 需要和超时配合时,使用 Channel 和 Context。  操作结果 chan 的值和状态有多种情况,而不同的操作(send、recv、close)又可能得到不同的结果,这是使用 chan 类型时经常让人困惑的地方。\n为了帮助你快速地了解不同状态下各种操作的结果,我总结了一个表格,你一定要特别关注下那些 panic 的情况,另外还要掌握那些会 block 的场景,它们是导致死锁或者 goroutine 泄露的罪魁祸首。\n还有一个值得注意的点是,只要一个 chan 还有未读的数据,即使把它 close 掉,你还是可以继续把这些未读的数据消费完,之后才是读取零值数据。\n使用反射操作 Channel 通过反射的方式执行 select 语句,在处理很多的 case clause,尤其是不定长的 case clause 的时候,非常有用。\nselect 语句可以处理 chan 的 send 和 recv,send 和 recv 都可以作为 case clause。如果我们同时处理两个 chan,就可以写成下面的样子:\n1 2 3 4 5 6  select { case v := ch1: fmt.Println(v) case v := ch2: fmt.Println(v) }   如果需要处理三个 chan,你就可以再添加一个 case clause,用它来处理第三个 chan。可是,如果要处理 100 个 chan 呢?一万个 chan 呢? 或者是,chan 的数量在编译的时候是不定的,在运行的时候需要处理一个 slice of chan, 这个时候,也没有办法在编译前写成字面意义的 select。那该怎么办? 这个时候,就要“祭”出我们的反射大法了。\n通过 reflect.Select 函数,你可以将一组运行时的 case clause 传入,当作参数执行。Go 的 select 是伪随机的,它可以在执行的 case 中随机选择一个 case,并把选择的这个 case 的索引(chosen)返回,如果没有可用的 case 返回,会返回一个 bool 类型的返回值, 这个返回值用来表示是否有 case 成功被选择。如果是 recv case,还会返回接收的元素。\nSelect 的方法签名如下:\n1  func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)   下面,我来借助一个例子,来演示一下,动态处理两个 chan 的情形。因为这样的方式可以动态处理 case 数据,所以,你可以传入几百几千几万的 chan,这就解决了不能动态处理 n 个 chan 的问题。\n首先,createCases 函数分别为每个 chan 生成了 recv case 和 send case,并返回一个 reflect.SelectCase 数组。\n然后,通过一个循环 10 次的 for 循环执行 reflect.Select,这个方法会从 cases 中选择一个 case 执行。第一次肯定是 send case,因为此时 chan 还没有元素,recv 还不可用。等 chan 中有了数据以后,recv case 就可以被选择了。这样,你就可以处理不定数量的 chan 了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  package main import ( \"fmt\" \"reflect\" ) func main() { ch1 := make(chan int, 10) ch2 := make(chan int, 10) // 创建SelectCase \tcases := createCases(ch1, ch2) // 执行10次select \tfor i := 0; i  10; i++ { chosen, recv, ok := reflect.Select(cases) if recv.IsValid() { // recv case \tfmt.Println(\"recv:\", cases[chosen].Dir, recv, ok) } else { // send case \tfmt.Println(\"send:\", cases[chosen].Dir, ok) } } } func createCases(chs ...chan int) []reflect.SelectCase { var cases []reflect.SelectCase // 创建recv case \tfor _, ch := range chs { cases = append(cases, reflect.SelectCase{ Dir: reflect.SelectRecv, Chan: reflect.ValueOf(ch), }) } // 创建send case \tfor i, ch := range chs { v := reflect.ValueOf(i) cases = append(cases, reflect.SelectCase{ Dir: reflect.SelectSend, Chan: reflect.ValueOf(ch), Send: v, }) } return cases }   消息交流 从 chan 的内部实现看,它是以一个循环队列的方式存放数据,所以,它有时候也会被当成线程安全的队列和 buffer 使用。一个 goroutine 可以安全地往 Channel 中塞数据,另外一个 goroutine 可以安全地从 Channel 中读取数据,goroutine 就可以安全地实现信息交流了。\n我们来看几个例子。\n第一个例子是 worker 池的例子。Marcio Castilho 在 使用 Go 每分钟处理百万请求 这篇文章中,就介绍了他们应对大并发请求的设计。他们将用户的请求放在一个 chan Job 中,这个 chan Job 就相当于一个待处理任务队列。除此之外,还有一个 chan chan Job 队列,用来存放可以处理任务的 worker 的缓存队列。\ndispatcher 会把待处理任务队列中的任务放到一个可用的缓存队列中,worker 会一直处理它的缓存队列。通过使用 Channel,实现了一个 worker 池的任务处理中心,并且解耦了前端 HTTP 请求处理和后端任务处理的逻辑。 我在讲 Pool 的时候,提到了一些第三方实现的 worker 池,它们全部都是通过 Channel 实现的,这是 Channel 的一个常见的应用场景。worker 池的生产者和消费者的消息交流都是通过 Channel 实现的。\n第二个例子是 etcd 中的 node 节点的实现,包含大量的 chan 字段,比如 recvc 是消息处理的 chan,待处理的 protobuf 消息都扔到这个 chan 中,node 有一个专门的 run goroutine 处理这些消息。\n数据传递 “击鼓传花”的游戏很多人都玩过,花从一个人手中传给另外一个人,就有点类似流水线的操作。这个花就是数据,花在游戏者之间流转,这就类似编程中的数据传递。\n下面是一道任务编排的题吗,其实它就可以用数据传递的方式实现。\n有 4 个 goroutine,编号为 1、2、3、4。每秒钟会有一个 goroutine 打印出它自己的编号,要求你编写程序,让输出的编号总是按照 1、2、3、4、1、2、3、4……这个顺序打印出来。\n为了实现顺序的数据传递,我们可以定义一个令牌的变量,谁得到令牌,谁就可以打印一次自己的编号,同时将令牌传递给下一个 goroutine,我们尝试使用 chan 来实现,可以看下下面的代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  package main import ( \"fmt\" \"time\" ) type Token struct{} func newWorker(id int, ch chan Token, nextCh chan Token) { for { token := ch // 取得令牌 \tfmt.Println((id + 1)) // id从1开始 \ttime.Sleep(time.Second) nextCh  token } } func main() { chs := []chan Token{make(chan Token), make(chan Token), make(chan Token)} // 创建4个worker \tfor i := 0; i  4; i++ { go newWorker(i, chs[i], chs[(i+1)%4]) } // 首先把令牌交给第一个worker \tchs[0]  struct{}{} select {} }   我来给你具体解释下这个实现方式。\n首先,我们定义一个令牌类型(Token),接着定义一个创建 worker 的方法,这个方法会从它自己的 chan 中读取令牌。哪个 goroutine 取得了令牌,就可以打印出自己编号, 因为需要每秒打印一次数据,所以,我们让它休眠 1 秒后,再把令牌交给它的下家。\n接着,在第 16 行启动每个 worker 的 goroutine,并在第 20 行将令牌先交给第一个 worker。\n如果你运行这个程序,就会在命令行中看到每一秒就会输出一个编号,而且编号是以 1、2、3、4 这样的顺序输出的。\n这类场景有一个特点,就是当前持有数据的 goroutine 都有一个信箱,信箱使用 chan 实现,goroutine 只需要关注自己的信箱中的数据,处理完毕后,就把结果发送到下一家的信箱中。\n信号通知 chan 类型有这样一个特点:chan 如果为空,那么,receiver 接收数据的时候就会阻塞等待,直到 chan 被关闭或者有新的数据到来。利用这个机制,我们可以实现 wait/notify 的设计模式。\n传统的并发原语 Cond 也能实现这个功能,但是,Cond 使用起来比较复杂,容易出错, 而使用 chan 实现 wait/notify 模式就方便很多了。\n除了正常的业务处理时的 wait/notify,我们经常碰到的一个场景,就是程序关闭的时候, 我们需要在退出之前做一些清理(doCleanup 方法)的动作。这个时候,我们经常要使用 chan。\n比如,使用 chan 实现程序的 graceful shutdown,在退出之前执行一些连接关闭、文件 close、缓存落盘等一些动作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  package main import ( \"fmt\" \"os\" \"os/signal\" \"syscall\" ) func main() { go func() { // 执行业务处理 \t}() // 处理CTRL+C等中断信号 \ttermChan := make(chan os.Signal) signal.Notify(termChan, syscall.SIGINT, syscall.SIGTERM) termChan // 执行退出之前的清理动作 \tdoCleanup() fmt.Println(\"优雅退出\") }   有时候,doCleanup 可能是一个很耗时的操作,比如十几分钟才能完成,如果程序退出需要等待这么长时间,用户是不能接受的,所以,在实践中,我们需要设置一个最长的等待时间。只要超过了这个时间,程序就不再等待,可以直接退出。所以,退出的时候分为两个阶段:\n closing,代表程序退出,但是清理工作还没做; closed,代表清理工作已经做完。  所以,上面的例子可以改写如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  package example import ( \"fmt\" \"os\" \"os/signal\" \"syscall\" \"time\" ) func main() { closing := make(chan struct{}) closed := make(chan struct{}) go func() { // 模拟业务处理 \tfor { select { case closing: return default: // ....... 业务计算 \ttime.Sleep(100 * time.Millisecond) } } }() // 处理CTRL+C等中断信号 \ttermChan := make(chan os.Signal) signal.Notify(termChan, syscall.SIGINT, syscall.SIGTERM) termChan close(closing) // 执行退出之前的清理动作 \tgo doCleanup(closed) select { case closed: case time.After(time.Second): fmt.Println(\"清理超时,不等了\") } fmt.Println(\"优雅退出\") } func doCleanup(closed chan struct{}) { time.Sleep((time.Minute)) close(closed) }   锁 使用 chan 也可以实现互斥锁。\n在 chan 的内部实现中,就有一把互斥锁保护着它的所有字段。从外在表现上,chan 的发送和接收之间也存在着 happens-before 的关系,保证元素放进去之后,receiver 才能读取到(关于 happends-before 的关系,是指事件发生的先后顺序关系)。\n要想使用 chan 实现互斥锁,至少有两种方式。一种方式是先初始化一个 capacity 等于 1 的 Channel,然后再放入一个元素。这个元素就代表锁,谁取得了这个元素,就相当于获取了这把锁。另一种方式是,先初始化一个 capacity 等于 1 的 Channel,它的“空槽”代表锁,谁能成功地把元素发送到这个 Channel,谁就获取了这把锁。\n这是使用 Channel 实现锁的两种不同实现方式,我重点介绍下第一种。理解了这种实现方式,第二种方式也就很容易掌握了,我就不多说了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  package example import ( \"fmt\" \"time\" ) // 使用chan实现互斥锁 type Mutex struct { ch chan struct{} } // 使用锁需要初始化 func NewMutex() *Mutex { mu := \u0026Mutex{make(chan struct{}, 1)} mu.ch  struct{}{} return mu } // 请求锁,直到获取到 func (m *Mutex) Lock() { m.ch } // 解锁 func (m *Mutex) Unlock() { select { case m.ch  struct{}{}: default: panic(\"unlock of unlocked mutex\") } } // 尝试获取锁 func (m *Mutex) TryLock() bool { select { case m.ch: return true default: } return false } // 加入一个超时的设置 func (m *Mutex) LockTimeout(timeout time.Duration) bool { timer := time.NewTimer(timeout) select { case m.ch: timer.Stop() return true case timer.C: } return false } // 锁是否已被持有 func (m *Mutex) IsLocked() bool { return len(m.ch) == 0 } func main() { m := NewMutex() ok := m.TryLock() fmt.Printf(\"locked v %v\\n\", ok) ok = m.TryLock() fmt.Printf(\"locked %v\\n\", ok) }   你可以用 buffer 等于 1 的 chan 实现互斥锁,在初始化这个锁的时候往 Channel 中先塞入一个元素,谁把这个元素取走,谁就获取了这把锁,把元素放回去,就是释放了锁。元素在放回到 chan 之前,不会有 goroutine 能从 chan 中取出元素的,这就保证了互斥性。\n在这段代码中,还有一点需要我们注意下:利用 select+chan 的方式,很容易实现 TryLock、Timeout 的功能。具体来说就是,在 select 语句中,我们可以使用 default 实现 TryLock,使用一个 Timer 来实现 Timeout 的功能。\n任务编排 这里的编排既指安排 goroutine 按照指定的顺序执行,也指多个 chan 按照指定的方式组合处理的方式。goroutine 的编排类似“击鼓传花”的例子,我们通过编排数据在 chan 之间的流转,就可以控制 goroutine 的执行。接下来,我来重点介绍下多个 chan 的编排方式,总共 5 种,分别是 Or-Done 模式、扇入模式、扇出模式、Stream 和 MapReduce。\nOr-Done 模式 首先来看 Or-Done 模式。Or-Done 模式是信号通知模式中更宽泛的一种模式。这里提到了“信号通知模式”,我先来解释一下。\n我们会使用“信号通知”实现某个任务执行完成后的通知机制,在实现时,我们为这个任务定义一个类型为 chan struct{}类型的 done 变量,等任务结束后,我们就可以 close 这个变量,然后,其它 receiver 就会收到这个通知。\n这是有一个任务的情况,如果有多个任务,只要有任意一个任务执行完,我们就想获得这个信号,这就是 Or-Done 模式。\n比如,你发送同一个请求到多个微服务节点,只要任意一个微服务节点返回结果,就算成功,这个时候,就可以参考下面的实现:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  package example func or(channels ...chan interface{}) chan interface{} { // 特殊情况,只有零个或者1个chan \tswitch len(channels) { case 0: return nil case 1: return channels[0] } orDone := make(chan interface{}) go func() { defer close(orDone) switch len(channels) { case 2: // 2个也是一种特殊情况 \tselect { case channels[0]: case channels[1]: } default: // 超过两个,二分法递归处理 \tm := len(channels) / 2 select { case or(channels[:m]...): case or(channels[m:]...): } } }() return orDone }   我们可以写一个测试程序测试它:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  func sig(after time.Duration) chan interface{} { c := make(chan interface{}) go func() { defer close(c) time.Sleep(after) }() return c } func main() { start := time.Now() or( sig(10*time.Second), sig(20*time.Second), sig(30*time.Second), sig(40*time.Second), sig(50*time.Second), sig(01*time.Minute), ) fmt.Printf(\"done after %v\", time.Since(start)) }   这里的实现使用了一个巧妙的方式,当 chan 的数量大于 2 时,使用递归的方式等待信号。\n在 chan 数量比较多的情况下,递归并不是一个很好的解决方式,根据这一讲最开始介绍的反射的方法,我们也可以实现 Or-Done 模式:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  func or(channels ...chan interface{}) chan interface{} { //特殊情况，只有0个或者1个  switch len(channels) { case 0: return nil case 1: return channels[0] } orDone := make(chan interface{}) go func() { defer close(orDone) // 利用反射构建SelectCase  var cases []reflect.SelectCase for _, c := range channels { cases = append(cases, reflect.SelectCase{ Dir: reflect.SelectRecv, Chan: reflect.ValueOf(c), }) } // 随机选择一个可用的case  reflect.Select(cases) }() return orDone }   这是递归和反射两种方法实现 Or-Done 模式的代码。反射方式避免了深层递归的情况,可以处理有大量 chan 的情况。其实最笨的一种方法就是为每一个 Channel 启动一个 goroutine,不过这会启动非常多的 goroutine,太多的 goroutine 会影响性能,所以不太常用。你只要知道这种用法就行了,不用重点掌握。\n扇入模式 扇入借鉴了数字电路的概念,它定义了单个逻辑门能够接受的数字信号输入最大量的术语。一个逻辑门可以有多个输入,一个输出。\n在软件工程中,模块的扇入是指有多少个上级模块调用它。而对于我们这里的 Channel 扇入模式来说,就是指有多个源 Channel 输入、一个目的 Channel 输出的情况。扇入比就是源 Channel 数量比 1。\n每个源 Channel 的元素都会发送给目标 Channel,相当于目标 Channel 的 receiver 只需要监听目标 Channel,就可以接收所有发送给源 Channel 的数据。\n扇入模式也可以使用反射、递归,或者是用最笨的每个 goroutine 处理一个 Channel 的方式来实现。\n这里我列举下递归和反射的方式,帮你加深一下对这个技巧的理解。\n反射的代码比较简短,易于理解,主要就是构造出 SelectCase slice,然后传递给 reflect.Select 语句。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  func fanInReflect(chans ...chan interface{}) chan interface{} { out := make(chan interface{}) go func() { defer close(out) // 构造SelectCase slice  var cases []reflect.SelectCase for _, c := range chans { cases = append(cases, reflect.SelectCase{ Dir: reflect.SelectRecv, Chan: reflect.ValueOf(c), }) } // 循环，从cases中选择一个可用的  for len(cases)  0 { i, v, ok := reflect.Select(cases) if !ok { // 此channel已经close  cases = append(cases[:i], cases[i+1:]...) continue } out  v.Interface() } }() return out }   递归模式也是在 Channel 大于 2 时,采用二分法递归 merge。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func fanInRec(chans ...chan interface{}) chan interface{} { switch len(chans) { case 0: c := make(chan interface{}) close(c) return c case 1: return chans[0] case 2: return mergeTwo(chans[0], chans[1]) default: m := len(chans) / 2 return mergeTwo( fanInRec(chans[:m]...), fanInRec(chans[m:]...)) } }   这里有一个 mergeTwo 的方法,是将两个 Channel 合并成一个 Channel,是扇入形式的一种特例(只处理两个 Channel)。 下面我来借助一段代码帮你理解下这个方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func mergeTwo(a, b chan interface{}) chan interface{} { c := make(chan interface{}) go func() { defer close(c) for a != nil || b != nil { //只要还有可读的chan  select { case v, ok := a: if !ok { // a 已关闭，设置为nil  a = nil continue } c  v case v, ok := b: if !ok { // b 已关闭，设置为nil  b = nil continue } c  v } } }() return c }   扇出模式 有扇入模式，就有扇出模式，扇出模式是和扇入模式相反的。\n扇出模式只有一个输入源 Channel，有多个目标 Channel，扇出比就是 1 比目标 Channel 数的值，经常用在设计模式中的观察者模式中（观察者设计模式定义了对象间的一种一对多的组合关系。这样一来，一个对象的状态发生变化时，所有依赖于它的对象都会得到通知并自动刷新）。在观察者模式中，数据变动后，多个观察者都会收到这个变更信号。\n下面是一个扇出模式的实现。从源 Channel 取出一个数据后，依次发送给目标 Channel。在发送给目标 Channel 的时候，可以同步发送，也可以异步发送：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  func fanOut(ch chan interface{}, out []chan interface{}, async bool) { go func() { defer func() { //退出时关闭所有的输出chan  for i := 0; i  len(out); i++ { close(out[i]) } }() for v := range ch { // 从输入chan中读取数据  v := v for i := 0; i  len(out); i++ { i := i if async { //异步  go func() { out[i]  v // 放入到输出chan中,异步方式  }() } else { out[i]  v // 放入到输出chan中，同步方式  } } } }() }   Stream 这里我来介绍一种把 Channel 当作流式管道使用的方式,也就是把 Channel 看作流(Stream),提供跳过几个元素,或者是只取其中的几个元素等方法。\n首先,我们提供创建流的方法。这个方法把一个数据 slice 转换成流:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  func asStream(done chan struct{}, values ...interface{}) chan interface{} { s := make(chan interface{}) //创建一个unbuffered的channel  go func() { // 启动一个goroutine，往s中塞数据  defer close(s) // 退出时关闭chan  for _, v := range values { // 遍历数组  select { case done: return case s  v: // 将数组元素塞入到chan中  } } }() return s }   流创建好以后，该咋处理呢？下面我再给你介绍下实现流的方法。\n takeN：只取流中的前 n 个数据； takeFn：筛选流中的数据，只保留满足条件的数据； takeWhile：只取前面满足条件的数据，一旦不满足条件，就不再取； skipN：跳过流中前几个数据； skipFn：跳过满足条件的数据； skipWhile：跳过前面满足条件的数据，一旦不满足条件，当前这个元素和以后的元素都会输出给 Channel 的 receiver。  这些方法的实现很类似，我们以 takeN 为例来具体解释一下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  func takeN(done chan struct{}, valueStream chan interface{}, num int) chan interface{} { takeStream := make(chan interface{}) // 创建输出流  go func() { defer close(takeStream) for i := 0; i  num; i++ { // 只读取前num个元素  select { case done: return case takeStream  valueStream: //从输入流中读取元素  } } }() return takeStream }   Map-Reduce map-reduce 是一种处理数据的方式,最早是由 Google 公司研究提出的一种面向大规模数据处理的并行计算模型和方法,开源的版本是 hadoop,前几年比较火。\n不过,我要讲的并不是分布式的 map-reduce,而是单机单进程的 map-reduce 方法。\nmap-reduce 分为两个步骤,第一步是映射(map),处理队列中的数据,第二步是规约(reduce),把列表中的每一个元素按照一定的处理方式处理成结果,放入到结果队列中。\n就像做汉堡一样,map 就是单独处理每一种食材,reduce 就是从每一份食材中取一部分,做成一个汉堡。\n我们先来看下 map 函数的处理逻辑:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func mapChan(in chan interface{}, fn func(interface{}) interface{}) chan interface{} { out := make(chan interface{}) //创建一个输出chan  if in == nil { // 异常检查  close(out) return out } go func() { // 启动一个goroutine,实现map的主要逻辑  defer close(out) for v := range in { // 从输入chan读取数据，执行业务操作，也就是map操作  out  fn(v) } }() return out }   reduce 函数的处理逻辑如下:\n1 2 3 4 5 6 7 8 9 10 11 12  func reduce(in chan interface{}, fn func(r, v interface{}) interface{}) interface{} { if in == nil { // 异常检查  return nil } out := in // 先读取第一个元素  for v := range in { // 实现reduce的主要逻辑  out = fn(out, v) } return out }   我们可以写一个程序,这个程序使用 map-reduce 模式处理一组整数,map 函数就是为每个整数乘以 10,reduce 函数就是把 map 处理的结果累加起来:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // 生成一个数据流 func asStream(done chan struct{}) chan interface{} { s := make(chan interface{}) values := []int{1, 2, 3, 4, 5} go func() { defer close(s) for _, v := range values { // 从数组生成  select { case done: return case s  v: } } }() return s } func main() { in := asStream(nil) // map操作: 乘以10  mapFn := func(v interface{}) interface{} { return v.(int) * 10 } // reduce操作: 对map的结果进行累加  reduceFn := func(r, v interface{}) interface{} { return r.(int) + v.(int) } sum := reduce(mapChan(in, mapFn), reduceFn) //返回累加结果  fmt.Println(sum) }   ",
  "wordCount" : "7645",
  "inLanguage": "zh-cn",
  "datePublished": "2021-05-21T14:58:45Z",
  "dateModified": "2021-05-21T14:58:45Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/channel%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Channel使用实践
    </h1>
    <div class="post-meta">May 21, 2021
</div>
  </header> 
  <div class="post-content"><h2 id="应用场景">应用场景<a hidden class="anchor" aria-hidden="true" href="#应用场景">#</a></h2>
<p>Channel 的应用场景分为五种类型。</p>
<ol>
<li>数据交流: 当作并发的 buffer 或者 queue,解决生产者 - 消费者问题。多个 goroutine 可以并发当作生产者(Producer)和消费者(Consumer)。</li>
<li>数据传递:一个 goroutine 将数据交给另一个 goroutine,相当于把数据的拥有权 (引用) 托付出去。</li>
<li>信号通知:一个 goroutine 可以将信号 (closing、closed、data ready 等) 传递给另一个或者另一组 goroutine 。</li>
<li>任务编排:可以让一组 goroutine 按照一定的顺序并发或者串行的执行,这就是编排的功能。</li>
<li>锁:利用 Channel 也可以实现互斥锁的机制。</li>
</ol>
<p>Go 的开发者极力推荐使用 Channel,不过,这两年,大家意识到,Channel 并不是处理并发问题的“银弹”,有时候使用并发原语更简单,而且不容易出错。所以,我给你提供一套选择的方法:</p>
<ol>
<li>共享资源的并发访问使用传统并发原语;</li>
<li>复杂的任务编排和消息传递使用 Channel;</li>
<li>消息通知机制使用 Channel,除非只想 signal 一个 goroutine,才使用 Cond;</li>
<li>简单等待所有任务的完成用 WaitGroup,也有 Channel 的推崇者用 Channel,都可以;</li>
<li>需要和 Select 语句结合,使用 Channel;</li>
<li>需要和超时配合时,使用 Channel 和 Context。</li>
</ol>
<h2 id="操作结果">操作结果<a hidden class="anchor" aria-hidden="true" href="#操作结果">#</a></h2>
<p>chan 的值和状态有多种情况,而不同的操作(send、recv、close)又可能得到不同的结果,这是使用 chan 类型时经常让人困惑的地方。</p>
<p>为了帮助你快速地了解不同状态下各种操作的结果,我总结了一个表格,你一定要特别关注下那些 panic 的情况,另外还要掌握那些会 block 的场景,它们是导致死锁或者 goroutine 泄露的罪魁祸首。</p>
<p>还有一个值得注意的点是,只要一个 chan 还有未读的数据,即使把它 close 掉,你还是可以继续把这些未读的数据消费完,之后才是读取零值数据。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210521174613.png" alt=""  />
</p>
<h2 id="使用反射操作-channel">使用反射操作 Channel<a hidden class="anchor" aria-hidden="true" href="#使用反射操作-channel">#</a></h2>
<p>通过反射的方式执行 select 语句,在处理很多的 case clause,尤其是不定长的 case clause 的时候,非常有用。</p>
<p>select 语句可以处理 chan 的 send 和 recv,send 和 recv 都可以作为 case clause。如果我们同时处理两个 chan,就可以写成下面的样子:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">v</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch1</span><span class="p">:</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">v</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch2</span><span class="p">:</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果需要处理三个 chan,你就可以再添加一个 case clause,用它来处理第三个 chan。可是,如果要处理 100 个 chan 呢?一万个 chan 呢? 或者是,chan 的数量在编译的时候是不定的,在运行的时候需要处理一个 slice of chan, 这个时候,也没有办法在编译前写成字面意义的 select。那该怎么办? 这个时候,就要“祭”出我们的反射大法了。</p>
<p>通过 reflect.Select 函数,你可以将一组运行时的 case clause 传入,当作参数执行。Go 的 select 是伪随机的,它可以在执行的 case 中随机选择一个 case,并把选择的这个 case 的索引(chosen)返回,如果没有可用的 case 返回,会返回一个 bool 类型的返回值, 这个返回值用来表示是否有 case 成功被选择。如果是 recv case,还会返回接收的元素。</p>
<p>Select 的方法签名如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Select</span><span class="p">(</span><span class="nx">cases</span> <span class="p">[]</span><span class="nx">SelectCase</span><span class="p">)</span> <span class="p">(</span><span class="nx">chosen</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">recv</span> <span class="nx">Value</span><span class="p">,</span> <span class="nx">recvOK</span> <span class="kt">bool</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>下面,我来借助一个例子,来演示一下,动态处理两个 chan 的情形。因为这样的方式可以动态处理 case 数据,所以,你可以传入几百几千几万的 chan,这就解决了不能动态处理 n 个 chan 的问题。</p>
<p>首先,createCases 函数分别为每个 chan 生成了 recv case 和 send case,并返回一个 reflect.SelectCase 数组。</p>
<p>然后,通过一个循环 10 次的 for 循环执行 reflect.Select,这个方法会从 cases 中选择一个 case 执行。第一次肯定是 send case,因为此时 chan 还没有元素,recv 还不可用。等 chan 中有了数据以后,recv case 就可以被选择了。这样,你就可以处理不定数量的 chan 了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;reflect&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ch1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
	<span class="nx">ch2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
	<span class="c1">// 创建SelectCase
</span><span class="c1"></span>	<span class="nx">cases</span> <span class="o">:=</span> <span class="nf">createCases</span><span class="p">(</span><span class="nx">ch1</span><span class="p">,</span> <span class="nx">ch2</span><span class="p">)</span>
	<span class="c1">// 执行10次select
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">chosen</span><span class="p">,</span> <span class="nx">recv</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="nx">cases</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">recv</span><span class="p">.</span><span class="nf">IsValid</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// recv case
</span><span class="c1"></span>			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;recv:&#34;</span><span class="p">,</span> <span class="nx">cases</span><span class="p">[</span><span class="nx">chosen</span><span class="p">].</span><span class="nx">Dir</span><span class="p">,</span> <span class="nx">recv</span><span class="p">,</span> <span class="nx">ok</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// send case
</span><span class="c1"></span>			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;send:&#34;</span><span class="p">,</span> <span class="nx">cases</span><span class="p">[</span><span class="nx">chosen</span><span class="p">].</span><span class="nx">Dir</span><span class="p">,</span> <span class="nx">ok</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">createCases</span><span class="p">(</span><span class="nx">chs</span> <span class="o">...</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">SelectCase</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">cases</span> <span class="p">[]</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">SelectCase</span>
	<span class="c1">// 创建recv case
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ch</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">chs</span> <span class="p">{</span>
		<span class="nx">cases</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cases</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">SelectCase</span><span class="p">{</span>
			<span class="nx">Dir</span><span class="p">:</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">SelectRecv</span><span class="p">,</span>
			<span class="nx">Chan</span><span class="p">:</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">ch</span><span class="p">),</span>
		<span class="p">})</span>
	<span class="p">}</span>
	<span class="c1">// 创建send case
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">ch</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">chs</span> <span class="p">{</span>
		<span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
		<span class="nx">cases</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cases</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">SelectCase</span><span class="p">{</span>
			<span class="nx">Dir</span><span class="p">:</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">SelectSend</span><span class="p">,</span>
			<span class="nx">Chan</span><span class="p">:</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">ch</span><span class="p">),</span>
			<span class="nx">Send</span><span class="p">:</span> <span class="nx">v</span><span class="p">,</span>
		<span class="p">})</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">cases</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="消息交流">消息交流<a hidden class="anchor" aria-hidden="true" href="#消息交流">#</a></h2>
<p>从 chan 的内部实现看,它是以一个循环队列的方式存放数据,所以,它有时候也会被当成线程安全的队列和 buffer 使用。一个 goroutine 可以安全地往 Channel 中塞数据,另外一个 goroutine 可以安全地从 Channel 中读取数据,goroutine 就可以安全地实现信息交流了。</p>
<p>我们来看几个例子。</p>
<p>第一个例子是 worker 池的例子。Marcio Castilho 在 使用 Go 每分钟处理百万请求  这篇文章中,就介绍了他们应对大并发请求的设计。他们将用户的请求放在一个 chan Job 中,这个 chan Job 就相当于一个待处理任务队列。除此之外,还有一个 chan chan Job 队列,用来存放可以处理任务的 worker 的缓存队列。</p>
<p>dispatcher 会把待处理任务队列中的任务放到一个可用的缓存队列中,worker 会一直处理它的缓存队列。通过使用 Channel,实现了一个 worker 池的任务处理中心,并且解耦了前端 HTTP 请求处理和后端任务处理的逻辑。
我在讲 Pool 的时候,提到了一些第三方实现的 worker 池,它们全部都是通过 Channel 实现的,这是 Channel 的一个常见的应用场景。worker 池的生产者和消费者的消息交流都是通过 Channel 实现的。</p>
<p>第二个例子是 etcd 中的 node 节点的实现,包含大量的 chan 字段,比如 recvc 是消息处理的 chan,待处理的 protobuf 消息都扔到这个 chan 中,node 有一个专门的 run goroutine 处理这些消息。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210521172503.png" alt=""  />
</p>
<h2 id="数据传递">数据传递<a hidden class="anchor" aria-hidden="true" href="#数据传递">#</a></h2>
<p>“击鼓传花”的游戏很多人都玩过,花从一个人手中传给另外一个人,就有点类似流水线的操作。这个花就是数据,花在游戏者之间流转,这就类似编程中的数据传递。</p>
<p>下面是一道任务编排的题吗,其实它就可以用数据传递的方式实现。</p>
<p>有 4 个 goroutine,编号为 1、2、3、4。每秒钟会有一个 goroutine 打印出它自己的编号,要求你编写程序,让输出的编号总是按照 1、2、3、4、1、2、3、4……这个顺序打印出来。</p>
<p>为了实现顺序的数据传递,我们可以定义一个令牌的变量,谁得到令牌,谁就可以打印一次自己的编号,同时将令牌传递给下一个 goroutine,我们尝试使用 chan 来实现,可以看下下面的代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Token</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="nf">newWorker</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">ch</span> <span class="kd">chan</span> <span class="nx">Token</span><span class="p">,</span> <span class="nx">nextCh</span> <span class="kd">chan</span> <span class="nx">Token</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">token</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
		<span class="c1">// 取得令牌
</span><span class="c1"></span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">((</span><span class="nx">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">// id从1开始
</span><span class="c1"></span>		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="nx">nextCh</span> <span class="o">&lt;-</span> <span class="nx">token</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">chs</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">chan</span> <span class="nx">Token</span><span class="p">{</span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Token</span><span class="p">),</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Token</span><span class="p">),</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Token</span><span class="p">)}</span>
	<span class="c1">// 创建4个worker
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="nf">newWorker</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">chs</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">chs</span><span class="p">[(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">4</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="c1">// 首先把令牌交给第一个worker
</span><span class="c1"></span>	<span class="nx">chs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
	<span class="k">select</span> <span class="p">{}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>我来给你具体解释下这个实现方式。</p>
<p>首先,我们定义一个令牌类型(Token),接着定义一个创建 worker 的方法,这个方法会从它自己的 chan 中读取令牌。哪个 goroutine 取得了令牌,就可以打印出自己编号, 因为需要每秒打印一次数据,所以,我们让它休眠 1 秒后,再把令牌交给它的下家。</p>
<p>接着,在第 16 行启动每个 worker 的 goroutine,并在第 20 行将令牌先交给第一个 worker。</p>
<p>如果你运行这个程序,就会在命令行中看到每一秒就会输出一个编号,而且编号是以 1、2、3、4 这样的顺序输出的。</p>
<p>这类场景有一个特点,就是当前持有数据的 goroutine 都有一个信箱,信箱使用 chan 实现,goroutine 只需要关注自己的信箱中的数据,处理完毕后,就把结果发送到下一家的信箱中。</p>
<h2 id="信号通知">信号通知<a hidden class="anchor" aria-hidden="true" href="#信号通知">#</a></h2>
<p>chan 类型有这样一个特点:chan 如果为空,那么,receiver 接收数据的时候就会阻塞等待,直到 chan 被关闭或者有新的数据到来。利用这个机制,我们可以实现 wait/notify 的设计模式。</p>
<p>传统的并发原语 Cond 也能实现这个功能,但是,Cond 使用起来比较复杂,容易出错, 而使用 chan 实现 wait/notify 模式就方便很多了。</p>
<p>除了正常的业务处理时的 wait/notify,我们经常碰到的一个场景,就是程序关闭的时候, 我们需要在退出之前做一些清理(doCleanup 方法)的动作。这个时候,我们经常要使用 chan。</p>
<p>比如,使用 chan 实现程序的 graceful shutdown,在退出之前执行一些连接关闭、文件 close、缓存落盘等一些动作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;os/signal&#34;</span>
	<span class="s">&#34;syscall&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// 执行业务处理
</span><span class="c1"></span>	<span class="p">}()</span>
	<span class="c1">// 处理CTRL+C等中断信号
</span><span class="c1"></span>	<span class="nx">termChan</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Signal</span><span class="p">)</span>
	<span class="nx">signal</span><span class="p">.</span><span class="nf">Notify</span><span class="p">(</span><span class="nx">termChan</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SIGINT</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SIGTERM</span><span class="p">)</span>
	<span class="o">&lt;-</span><span class="nx">termChan</span>
	<span class="c1">// 执行退出之前的清理动作
</span><span class="c1"></span>	<span class="nf">doCleanup</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;优雅退出&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>有时候,doCleanup 可能是一个很耗时的操作,比如十几分钟才能完成,如果程序退出需要等待这么长时间,用户是不能接受的,所以,在实践中,我们需要设置一个最长的等待时间。只要超过了这个时间,程序就不再等待,可以直接退出。所以,退出的时候分为两个阶段:</p>
<ol>
<li>closing,代表程序退出,但是清理工作还没做;</li>
<li>closed,代表清理工作已经做完。</li>
</ol>
<p>所以,上面的例子可以改写如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">example</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;os/signal&#34;</span>
	<span class="s">&#34;syscall&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">closing</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
	<span class="nx">closed</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// 模拟业务处理
</span><span class="c1"></span>		<span class="k">for</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">closing</span><span class="p">:</span>
				<span class="k">return</span>
			<span class="k">default</span><span class="p">:</span>
				<span class="c1">// ....... 业务计算
</span><span class="c1"></span>				<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="c1">// 处理CTRL+C等中断信号
</span><span class="c1"></span>	<span class="nx">termChan</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Signal</span><span class="p">)</span>
	<span class="nx">signal</span><span class="p">.</span><span class="nf">Notify</span><span class="p">(</span><span class="nx">termChan</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SIGINT</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SIGTERM</span><span class="p">)</span>
	<span class="o">&lt;-</span><span class="nx">termChan</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">closing</span><span class="p">)</span>
	<span class="c1">// 执行退出之前的清理动作
</span><span class="c1"></span>	<span class="k">go</span> <span class="nf">doCleanup</span><span class="p">(</span><span class="nx">closed</span><span class="p">)</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">closed</span><span class="p">:</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">):</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;清理超时,不等了&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;优雅退出&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">doCleanup</span><span class="p">(</span><span class="nx">closed</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">((</span><span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span><span class="p">))</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">closed</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="锁">锁<a hidden class="anchor" aria-hidden="true" href="#锁">#</a></h2>
<p>使用 chan 也可以实现互斥锁。</p>
<p>在 chan 的内部实现中,就有一把互斥锁保护着它的所有字段。从外在表现上,chan 的发送和接收之间也存在着 happens-before 的关系,保证元素放进去之后,receiver 才能读取到(关于 happends-before 的关系,是指事件发生的先后顺序关系)。</p>
<p>要想使用 chan 实现互斥锁,至少有两种方式。一种方式是先初始化一个 capacity 等于 1 的 Channel,然后再放入一个元素。这个元素就代表锁,谁取得了这个元素,就相当于获取了这把锁。另一种方式是,先初始化一个 capacity 等于 1 的 Channel,它的“空槽”代表锁,谁能成功地把元素发送到这个 Channel,谁就获取了这把锁。</p>
<p>这是使用 Channel 实现锁的两种不同实现方式,我重点介绍下第一种。理解了这种实现方式,第二种方式也就很容易掌握了,我就不多说了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">example</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="c1">// 使用chan实现互斥锁
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Mutex</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ch</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// 使用锁需要初始化
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewMutex</span><span class="p">()</span> <span class="o">*</span><span class="nx">Mutex</span> <span class="p">{</span>
	<span class="nx">mu</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Mutex</span><span class="p">{</span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">1</span><span class="p">)}</span>
	<span class="nx">mu</span><span class="p">.</span><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
	<span class="k">return</span> <span class="nx">mu</span>
<span class="p">}</span>

<span class="c1">// 请求锁,直到获取到
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">Lock</span><span class="p">()</span> <span class="p">{</span>
	<span class="o">&lt;-</span><span class="nx">m</span><span class="p">.</span><span class="nx">ch</span>
<span class="p">}</span>

<span class="c1">// 解锁
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">Unlock</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">m</span><span class="p">.</span><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}:</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;unlock of unlocked mutex&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 尝试获取锁
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">TryLock</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">m</span><span class="p">.</span><span class="nx">ch</span><span class="p">:</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="k">default</span><span class="p">:</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="c1">// 加入一个超时的设置
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">LockTimeout</span><span class="p">(</span><span class="nx">timeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">timeout</span><span class="p">)</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">m</span><span class="p">.</span><span class="nx">ch</span><span class="p">:</span>
		<span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="c1">// 锁是否已被持有
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">IsLocked</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">ch</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nf">NewMutex</span><span class="p">()</span>
	<span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">TryLock</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;locked v %v\n&#34;</span><span class="p">,</span> <span class="nx">ok</span><span class="p">)</span>
	<span class="nx">ok</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">TryLock</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;locked %v\n&#34;</span><span class="p">,</span> <span class="nx">ok</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>你可以用 buffer 等于 1 的 chan 实现互斥锁,在初始化这个锁的时候往 Channel 中先塞入一个元素,谁把这个元素取走,谁就获取了这把锁,把元素放回去,就是释放了锁。元素在放回到 chan 之前,不会有 goroutine 能从 chan 中取出元素的,这就保证了互斥性。</p>
<p>在这段代码中,还有一点需要我们注意下:利用 select+chan 的方式,很容易实现 TryLock、Timeout 的功能。具体来说就是,在 select 语句中,我们可以使用 default 实现 TryLock,使用一个 Timer 来实现 Timeout 的功能。</p>
<h2 id="任务编排">任务编排<a hidden class="anchor" aria-hidden="true" href="#任务编排">#</a></h2>
<p>这里的编排既指安排 goroutine 按照指定的顺序执行,也指多个 chan 按照指定的方式组合处理的方式。goroutine 的编排类似“击鼓传花”的例子,我们通过编排数据在 chan 之间的流转,就可以控制 goroutine 的执行。接下来,我来重点介绍下多个 chan 的编排方式,总共 5 种,分别是 Or-Done 模式、扇入模式、扇出模式、Stream 和 MapReduce。</p>
<h3 id="or-done-模式">Or-Done 模式<a hidden class="anchor" aria-hidden="true" href="#or-done-模式">#</a></h3>
<p>首先来看 Or-Done 模式。Or-Done 模式是信号通知模式中更宽泛的一种模式。这里提到了“信号通知模式”,我先来解释一下。</p>
<p>我们会使用“信号通知”实现某个任务执行完成后的通知机制,在实现时,我们为这个任务定义一个类型为 <code>chan struct{}</code>类型的 done 变量,等任务结束后,我们就可以 close 这个变量,然后,其它 receiver 就会收到这个通知。</p>
<p>这是有一个任务的情况,如果有多个任务,只要有任意一个任务执行完,我们就想获得这个信号,这就是 Or-Done 模式。</p>
<p>比如,你发送同一个请求到多个微服务节点,只要任意一个微服务节点返回结果,就算成功,这个时候,就可以参考下面的实现:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">example</span>

<span class="kd">func</span> <span class="nf">or</span><span class="p">(</span><span class="nx">channels</span> <span class="o">...&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
	<span class="c1">// 特殊情况,只有零个或者1个chan
</span><span class="c1"></span>	<span class="k">switch</span> <span class="nb">len</span><span class="p">(</span><span class="nx">channels</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nx">orDone</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">orDone</span><span class="p">)</span>
		<span class="k">switch</span> <span class="nb">len</span><span class="p">(</span><span class="nx">channels</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="c1">// 2个也是一种特殊情况
</span><span class="c1"></span>			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">channels</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
			<span class="p">}</span>
		<span class="k">default</span><span class="p">:</span> <span class="c1">// 超过两个,二分法递归处理
</span><span class="c1"></span>			<span class="nx">m</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">channels</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nf">or</span><span class="p">(</span><span class="nx">channels</span><span class="p">[:</span><span class="nx">m</span><span class="p">]</span><span class="o">...</span><span class="p">):</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nf">or</span><span class="p">(</span><span class="nx">channels</span><span class="p">[</span><span class="nx">m</span><span class="p">:]</span><span class="o">...</span><span class="p">):</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="k">return</span> <span class="nx">orDone</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们可以写一个测试程序测试它:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">sig</span><span class="p">(</span><span class="nx">after</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">after</span><span class="p">)</span>
    <span class="p">}()</span>
    <span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>

    <span class="o">&lt;-</span><span class="nf">or</span><span class="p">(</span>
        <span class="nf">sig</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">),</span>
        <span class="nf">sig</span><span class="p">(</span><span class="mi">20</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">),</span>
        <span class="nf">sig</span><span class="p">(</span><span class="mi">30</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">),</span>
        <span class="nf">sig</span><span class="p">(</span><span class="mi">40</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">),</span>
        <span class="nf">sig</span><span class="p">(</span><span class="mi">50</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">),</span>
        <span class="nf">sig</span><span class="p">(</span><span class="mo">01</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;done after %v&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">start</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里的实现使用了一个巧妙的方式,当 chan 的数量大于 2 时,使用递归的方式等待信号。</p>
<p>在 chan 数量比较多的情况下,递归并不是一个很好的解决方式,根据这一讲最开始介绍的反射的方法,我们也可以实现 Or-Done 模式:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">or</span><span class="p">(</span><span class="nx">channels</span> <span class="o">...&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
    <span class="c1">//特殊情况，只有0个或者1个
</span><span class="c1"></span>    <span class="k">switch</span> <span class="nb">len</span><span class="p">(</span><span class="nx">channels</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="nx">orDone</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">orDone</span><span class="p">)</span>
        <span class="c1">// 利用反射构建SelectCase
</span><span class="c1"></span>        <span class="kd">var</span> <span class="nx">cases</span> <span class="p">[]</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">SelectCase</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">channels</span> <span class="p">{</span>
            <span class="nx">cases</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cases</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">SelectCase</span><span class="p">{</span>
                <span class="nx">Dir</span><span class="p">:</span>  <span class="nx">reflect</span><span class="p">.</span><span class="nx">SelectRecv</span><span class="p">,</span>
                <span class="nx">Chan</span><span class="p">:</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span>
            <span class="p">})</span>
        <span class="p">}</span>

        <span class="c1">// 随机选择一个可用的case
</span><span class="c1"></span>        <span class="nx">reflect</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="nx">cases</span><span class="p">)</span>
    <span class="p">}()</span>


    <span class="k">return</span> <span class="nx">orDone</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这是递归和反射两种方法实现 Or-Done 模式的代码。反射方式避免了深层递归的情况,可以处理有大量 chan 的情况。其实最笨的一种方法就是为每一个 Channel 启动一个 goroutine,不过这会启动非常多的 goroutine,太多的 goroutine 会影响性能,所以不太常用。你只要知道这种用法就行了,不用重点掌握。</p>
<h3 id="扇入模式">扇入模式<a hidden class="anchor" aria-hidden="true" href="#扇入模式">#</a></h3>
<p>扇入借鉴了数字电路的概念,它定义了单个逻辑门能够接受的数字信号输入最大量的术语。一个逻辑门可以有多个输入,一个输出。</p>
<p>在软件工程中,模块的扇入是指有多少个上级模块调用它。而对于我们这里的 Channel 扇入模式来说,就是指有多个源 Channel 输入、一个目的 Channel 输出的情况。扇入比就是源 Channel 数量比 1。</p>
<p>每个源 Channel 的元素都会发送给目标 Channel,相当于目标 Channel 的 receiver 只需要监听目标 Channel,就可以接收所有发送给源 Channel 的数据。</p>
<p>扇入模式也可以使用反射、递归,或者是用最笨的每个 goroutine 处理一个 Channel 的方式来实现。</p>
<p>这里我列举下递归和反射的方式,帮你加深一下对这个技巧的理解。</p>
<p>反射的代码比较简短,易于理解,主要就是构造出 SelectCase slice,然后传递给 reflect.Select 语句。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">fanInReflect</span><span class="p">(</span><span class="nx">chans</span> <span class="o">...&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
    <span class="nx">out</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span>
        <span class="c1">// 构造SelectCase slice
</span><span class="c1"></span>        <span class="kd">var</span> <span class="nx">cases</span> <span class="p">[]</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">SelectCase</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">chans</span> <span class="p">{</span>
            <span class="nx">cases</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cases</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">SelectCase</span><span class="p">{</span>
                <span class="nx">Dir</span><span class="p">:</span>  <span class="nx">reflect</span><span class="p">.</span><span class="nx">SelectRecv</span><span class="p">,</span>
                <span class="nx">Chan</span><span class="p">:</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span>
            <span class="p">})</span>
        <span class="p">}</span>

        <span class="c1">// 循环，从cases中选择一个可用的
</span><span class="c1"></span>        <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">cases</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="nx">cases</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span> <span class="c1">// 此channel已经close
</span><span class="c1"></span>                <span class="nx">cases</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cases</span><span class="p">[:</span><span class="nx">i</span><span class="p">],</span> <span class="nx">cases</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="p">}</span>
            <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Interface</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}()</span>
    <span class="k">return</span> <span class="nx">out</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>递归模式也是在 Channel 大于 2 时,采用二分法递归 merge。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">fanInRec</span><span class="p">(</span><span class="nx">chans</span> <span class="o">...&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="nb">len</span><span class="p">(</span><span class="nx">chans</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span>
        <span class="nb">close</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
        <span class="k">return</span> <span class="nx">c</span>
    <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">chans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">mergeTwo</span><span class="p">(</span><span class="nx">chans</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">chans</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">default</span><span class="p">:</span>
        <span class="nx">m</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">chans</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="nf">mergeTwo</span><span class="p">(</span>
            <span class="nf">fanInRec</span><span class="p">(</span><span class="nx">chans</span><span class="p">[:</span><span class="nx">m</span><span class="p">]</span><span class="o">...</span><span class="p">),</span>
            <span class="nf">fanInRec</span><span class="p">(</span><span class="nx">chans</span><span class="p">[</span><span class="nx">m</span><span class="p">:]</span><span class="o">...</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里有一个 mergeTwo 的方法,是将两个 Channel 合并成一个 Channel,是扇入形式的一种特例(只处理两个 Channel)。 下面我来借助一段代码帮你理解下这个方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mergeTwo</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
        <span class="k">for</span> <span class="nx">a</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">//只要还有可读的chan
</span><span class="c1"></span>            <span class="k">select</span> <span class="p">{</span>
            <span class="k">case</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">a</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span> <span class="c1">// a 已关闭，设置为nil
</span><span class="c1"></span>                    <span class="nx">a</span> <span class="p">=</span> <span class="kc">nil</span>
                    <span class="k">continue</span>
                <span class="p">}</span>
                <span class="nx">c</span> <span class="o">&lt;-</span> <span class="nx">v</span>
            <span class="k">case</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">b</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span> <span class="c1">// b 已关闭，设置为nil
</span><span class="c1"></span>                    <span class="nx">b</span> <span class="p">=</span> <span class="kc">nil</span>
                    <span class="k">continue</span>
                <span class="p">}</span>
                <span class="nx">c</span> <span class="o">&lt;-</span> <span class="nx">v</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}()</span>
    <span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="扇出模式">扇出模式<a hidden class="anchor" aria-hidden="true" href="#扇出模式">#</a></h3>
<p>有扇入模式，就有扇出模式，扇出模式是和扇入模式相反的。</p>
<p>扇出模式只有一个输入源 Channel，有多个目标 Channel，扇出比就是 1 比目标 Channel 数的值，经常用在设计模式中的观察者模式中（观察者设计模式定义了对象间的一种一对多的组合关系。这样一来，一个对象的状态发生变化时，所有依赖于它的对象都会得到通知并自动刷新）。在观察者模式中，数据变动后，多个观察者都会收到这个变更信号。</p>
<p>下面是一个扇出模式的实现。从源 Channel 取出一个数据后，依次发送给目标 Channel。在发送给目标 Channel 的时候，可以同步发送，也可以异步发送：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">fanOut</span><span class="p">(</span><span class="nx">ch</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">out</span> <span class="p">[]</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">async</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="c1">//退出时关闭所有的输出chan
</span><span class="c1"></span>            <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">out</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
                <span class="nb">close</span><span class="p">(</span><span class="nx">out</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
            <span class="p">}</span>
        <span class="p">}()</span>

        <span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ch</span> <span class="p">{</span> <span class="c1">// 从输入chan中读取数据
</span><span class="c1"></span>            <span class="nx">v</span> <span class="o">:=</span> <span class="nx">v</span>
            <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">out</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
                <span class="nx">i</span> <span class="o">:=</span> <span class="nx">i</span>
                <span class="k">if</span> <span class="nx">async</span> <span class="p">{</span> <span class="c1">//异步
</span><span class="c1"></span>                    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nx">out</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="nx">v</span> <span class="c1">// 放入到输出chan中,异步方式
</span><span class="c1"></span>                    <span class="p">}()</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nx">out</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="nx">v</span> <span class="c1">// 放入到输出chan中，同步方式
</span><span class="c1"></span>                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="stream">Stream<a hidden class="anchor" aria-hidden="true" href="#stream">#</a></h3>
<p>这里我来介绍一种把 Channel 当作流式管道使用的方式,也就是把 Channel 看作流(Stream),提供跳过几个元素,或者是只取其中的几个元素等方法。</p>
<p>首先,我们提供创建流的方法。这个方法把一个数据 slice 转换成流:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">asStream</span><span class="p">(</span><span class="nx">done</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="nx">values</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span> <span class="c1">//创建一个unbuffered的channel
</span><span class="c1"></span>    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 启动一个goroutine，往s中塞数据
</span><span class="c1"></span>        <span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// 退出时关闭chan
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">values</span> <span class="p">{</span> <span class="c1">// 遍历数组
</span><span class="c1"></span>            <span class="k">select</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">case</span> <span class="nx">s</span> <span class="o">&lt;-</span> <span class="nx">v</span><span class="p">:</span> <span class="c1">// 将数组元素塞入到chan中
</span><span class="c1"></span>            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}()</span>
    <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>流创建好以后，该咋处理呢？下面我再给你介绍下实现流的方法。</p>
<ol>
<li>takeN：只取流中的前 n 个数据；</li>
<li>takeFn：筛选流中的数据，只保留满足条件的数据；</li>
<li>takeWhile：只取前面满足条件的数据，一旦不满足条件，就不再取；</li>
<li>skipN：跳过流中前几个数据；</li>
<li>skipFn：跳过满足条件的数据；</li>
<li>skipWhile：跳过前面满足条件的数据，一旦不满足条件，当前这个元素和以后的元素都会输出给 Channel 的 receiver。</li>
</ol>
<p>这些方法的实现很类似，我们以 takeN 为例来具体解释一下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">takeN</span><span class="p">(</span><span class="nx">done</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="nx">valueStream</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">num</span> <span class="kt">int</span><span class="p">)</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
    <span class="nx">takeStream</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span> <span class="c1">// 创建输出流
</span><span class="c1"></span>    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">takeStream</span><span class="p">)</span>
        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span> <span class="c1">// 只读取前num个元素
</span><span class="c1"></span>            <span class="k">select</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">case</span> <span class="nx">takeStream</span> <span class="o">&lt;-</span> <span class="o">&lt;-</span><span class="nx">valueStream</span><span class="p">:</span> <span class="c1">//从输入流中读取元素
</span><span class="c1"></span>            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}()</span>
    <span class="k">return</span> <span class="nx">takeStream</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="map-reduce">Map-Reduce<a hidden class="anchor" aria-hidden="true" href="#map-reduce">#</a></h3>
<p>map-reduce 是一种处理数据的方式,最早是由 Google 公司研究提出的一种面向大规模数据处理的并行计算模型和方法,开源的版本是 hadoop,前几年比较火。</p>
<p>不过,我要讲的并不是分布式的 map-reduce,而是单机单进程的 map-reduce 方法。</p>
<p>map-reduce 分为两个步骤,第一步是映射(map),处理队列中的数据,第二步是规约(reduce),把列表中的每一个元素按照一定的处理方式处理成结果,放入到结果队列中。</p>
<p>就像做汉堡一样,map 就是单独处理每一种食材,reduce 就是从每一份食材中取一部分,做成一个汉堡。</p>
<p>我们先来看下 map 函数的处理逻辑:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">mapChan</span><span class="p">(</span><span class="nx">in</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">fn</span> <span class="kd">func</span><span class="p">(</span><span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{})</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
    <span class="nx">out</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span> <span class="c1">//创建一个输出chan
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">in</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// 异常检查
</span><span class="c1"></span>        <span class="nb">close</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="nx">out</span>
    <span class="p">}</span>

    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 启动一个goroutine,实现map的主要逻辑
</span><span class="c1"></span>        <span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span>
        <span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span> <span class="c1">// 从输入chan读取数据，执行业务操作，也就是map操作
</span><span class="c1"></span>            <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nf">fn</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="k">return</span> <span class="nx">out</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>reduce 函数的处理逻辑如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">reduce</span><span class="p">(</span><span class="nx">in</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">fn</span> <span class="kd">func</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">in</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// 异常检查
</span><span class="c1"></span>        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>

    <span class="nx">out</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">in</span> <span class="c1">// 先读取第一个元素
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span> <span class="c1">// 实现reduce的主要逻辑
</span><span class="c1"></span>        <span class="nx">out</span> <span class="p">=</span> <span class="nf">fn</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">out</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们可以写一个程序,这个程序使用 map-reduce 模式处理一组整数,map 函数就是为每个整数乘以 10,reduce 函数就是把 map 处理的结果累加起来:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 生成一个数据流
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">asStream</span><span class="p">(</span><span class="nx">done</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span>
    <span class="nx">values</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">values</span> <span class="p">{</span> <span class="c1">// 从数组生成
</span><span class="c1"></span>            <span class="k">select</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">case</span> <span class="nx">s</span> <span class="o">&lt;-</span> <span class="nx">v</span><span class="p">:</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}()</span>
    <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">in</span> <span class="o">:=</span> <span class="nf">asStream</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>

    <span class="c1">// map操作: 乘以10
</span><span class="c1"></span>    <span class="nx">mapFn</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">v</span><span class="p">.(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span>
    <span class="p">}</span>

    <span class="c1">// reduce操作: 对map的结果进行累加
</span><span class="c1"></span>    <span class="nx">reduceFn</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">r</span><span class="p">.(</span><span class="kt">int</span><span class="p">)</span> <span class="o">+</span> <span class="nx">v</span><span class="p">.(</span><span class="kt">int</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">sum</span> <span class="o">:=</span> <span class="nf">reduce</span><span class="p">(</span><span class="nf">mapChan</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span> <span class="nx">mapFn</span><span class="p">),</span> <span class="nx">reduceFn</span><span class="p">)</span> <span class="c1">//返回累加结果
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">sum</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go/">Go</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
