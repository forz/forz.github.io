<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>常见的端口扫描类型及原理 | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="常见的扫描类型有以下几种： 秘密扫描是一种不被审计工具所检测的扫描技术。 它通常用于在通过普通的防火墙或路由器的筛选（filtering）时隐藏">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%8E%9F%E7%90%86/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="常见的端口扫描类型及原理" />
<meta property="og:description" content="常见的扫描类型有以下几种： 秘密扫描是一种不被审计工具所检测的扫描技术。 它通常用于在通过普通的防火墙或路由器的筛选（filtering）时隐藏" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%8E%9F%E7%90%86/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-25T14:21:58&#43;00:00" />
<meta property="article:modified_time" content="2017-06-25T14:21:58&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="常见的端口扫描类型及原理"/>
<meta name="twitter:description" content="常见的扫描类型有以下几种： 秘密扫描是一种不被审计工具所检测的扫描技术。 它通常用于在通过普通的防火墙或路由器的筛选（filtering）时隐藏"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "常见的端口扫描类型及原理",
      "item": "/post/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%8E%9F%E7%90%86/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "常见的端口扫描类型及原理",
  "name": "常见的端口扫描类型及原理",
  "description": "常见的扫描类型有以下几种： 秘密扫描是一种不被审计工具所检测的扫描技术。 它通常用于在通过普通的防火墙或路由器的筛选（filtering）时隐藏",
  "keywords": [
    
  ],
  "articleBody": "常见的扫描类型有以下几种：\n秘密扫描是一种不被审计工具所检测的扫描技术。\n它通常用于在通过普通的防火墙或路由器的筛选（filtering）时隐藏自己。\n秘密扫描能躲避IDS、防火墙、包过滤器和日志审计，从而获取目标端口的开放或关闭的信息。由于没有包含TCP 3次握手协议的任何部分，所以无法被记录下来，比半连接扫描更为隐蔽。\n但是这种扫描的缺点是扫描结果的不可靠性会增加，而且扫描主机也需要自己构造IP包。现有的秘密扫描有TCP FIN扫描、TCP ACK扫描、NULL扫描、XMAS扫描和SYN/ACK扫描等。\nTCP connect()扫描 此扫描试图与每一个TCP端口进行“三次握手”通信。如果能够成功建立连接，则证明端口开放，否则为关闭。准确度很高，但是最容易被防火墙和IDS检测到，并且在目标主机的日志中会记录大量的连接请求以及错误信息。\nTCP connect端口扫描服务端与客户端建立连接成功（目标端口开放）的过程：\n Client端发送SYN； Server端返回SYN/ACK，表明端口开放； Client端返回ACK，表明连接已建立； Client端主动断开连接。  建立连接成功（目标端口开放）如图所示\nTCP connect端口扫描服务端与客户端未建立连接成功（目标端口关闭）过程：\n  Client端发送SYN；\n  Server端返回RST/ACK，表明端口未开放。\n  优点：\n  实现简单，不需要任何权限，系统中的任何用户都有权利使用这个调用。\n  扫描速度快。如果对每个目标端口以线性的方式，使用单独的“connect()”函数调用，那么将会花费相当长的时间，用户可以同时打开多个套接字，从而加速扫描。使用非阻塞I/O允许用户设置一个低的 时间以用尽周期，并同时观察多个套接字。\n  缺点：\n是会在目标主机的日志记录中留下痕迹，易被发现，并且数据包会被过滤掉。目标主机的logs文件会显示一连串的连接和连接出错的服务信息，并且能很快地使它关闭。\nTCP SYN扫描： 扫描器向目标主机的一个端口发送请求连接的SYN包，扫描器在收到SYN/ACK后，不是发送的ACK应答而是发送RST包请求断开连接。这样，三次握手就没有完成，无法建立正常的TCP连接，因此，这次扫描就不会被记录到系统日志中。这种扫描技术一般不会在目标主机上留下扫描痕迹。但是，这种扫描需要有root权限。\n端口开放：\n Client发送SYN Server端发送SYN/ACK Client发送RST断开（只需要前两步就可以判断端口开放）  端口关闭：\n Client发送SYN Server端回复RST（表示端口关闭）  优点：SYN扫描要比TCP Connect()扫描隐蔽一些，SYN仅仅需要发送初始的SYN数据包给目标主机。\n缺点：\n 需要系统管理员的权限 不适合使用多线程技术。因为在实现过程中需要自己完成对应答数据报的查找、分析，使用多线程容易发生数据报的串位现象，也就是原来应该这个线程接收的数据报被另 一个线程接收，接收后，这个数据报就会被丢弃，而等待线程只好在超时之后再发送一个SYN数据报，等待应答。这样，所用的时间反而会增加。  TCP FIN扫描 这种扫描方式不依赖于TCP的3次握手过程，而是TCP连接的“FIN”（结束）位标志。原理在于TCP连接结束时，会向TCP端口发送一个设置了FIN 位的连接终止数据报，关闭的端口会回应一个设置了RST的连接复位数据报；而开放的端口则会对这种可疑的数据报不加理睬，将它丢弃。可以根据是否收到 RST数据报来判断对方的端口是否开放。\n优点：此扫描方式的优点比前两种都要隐秘，不容易被发现。\n该方案有两个缺点：\n  要判断对方端口是否开放必须等待超时，增加了探测时间，而且容易得出错误的结论；\n  windows系统不能使用，windows系统一旦收到这样的数据报，无论端口是否开放都会回应一个 RST连接复位数据报。\n  UDP扫描 在UDP扫描中，是往目标端口发送一个UDP分组。如果目标端口是以一个“ICMP port Unreachable”（ICMP端口不可到达）消息来作为响应的，那么该端口是关闭的。\n相反，如果没有收到这个消息那就可以推断该端口打开着。还有就 是一些特殊的UDP回馈，比如SQL Server服务器，对其1434号端口发送“x02”或者“x03”就能够探测得到其连接端口。\n优点：linux windows都能用\n缺点：\n  由于UDP是无连接的不可靠协议，因此这种技巧的准确性 很大程度上取决于与网络及系统资源的使用率相关的多个因素。\n  当试图扫描一个大量应用分组过滤功能的设备时，UDP扫描将是一个非常缓慢的过程。如果要在互联网上执行UDP扫描，那么结果就是不可靠的。\n  ",
  "wordCount" : "1875",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-25T14:21:58Z",
  "dateModified": "2017-06-25T14:21:58Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%8E%9F%E7%90%86/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      常见的端口扫描类型及原理
    </h1>
    <div class="post-meta">June 25, 2017
</div>
  </header> 
  <div class="post-content"><p>常见的扫描类型有以下几种：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20170521102509.png" alt=""  />
</p>
<p>秘密扫描是一种不被审计工具所检测的扫描技术。</p>
<p>它通常用于在通过普通的防火墙或路由器的筛选（filtering）时隐藏自己。</p>
<p>秘密扫描能躲避IDS、防火墙、包过滤器和日志审计，从而获取目标端口的开放或关闭的信息。由于没有包含TCP 3次握手协议的任何部分，所以无法被记录下来，比半连接扫描更为隐蔽。</p>
<p>但是这种扫描的缺点是扫描结果的不可靠性会增加，而且扫描主机也需要自己构造IP包。现有的秘密扫描有TCP FIN扫描、TCP ACK扫描、NULL扫描、XMAS扫描和SYN/ACK扫描等。</p>
<h1 id="tcp-connect扫描">TCP connect()扫描<a hidden class="anchor" aria-hidden="true" href="#tcp-connect扫描">#</a></h1>
<p>此扫描试图与每一个TCP端口进行“三次握手”通信。如果能够成功建立连接，则证明端口开放，否则为关闭。准确度很高，但是最容易被防火墙和IDS检测到，并且在目标主机的日志中会记录大量的连接请求以及错误信息。</p>
<p>TCP connect端口扫描服务端与客户端建立连接成功（目标端口开放）的过程：</p>
<ol>
<li>Client端发送SYN；</li>
<li>Server端返回SYN/ACK，表明端口开放；</li>
<li>Client端返回ACK，表明连接已建立；</li>
<li>Client端主动断开连接。</li>
</ol>
<p>建立连接成功（目标端口开放）如图所示</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20170521103004.png" alt=""  />
</p>
<p>TCP connect端口扫描服务端与客户端未建立连接成功（目标端口关闭）过程：</p>
<ol>
<li>
<p>Client端发送SYN；</p>
</li>
<li>
<p>Server端返回RST/ACK，表明端口未开放。</p>
</li>
</ol>
<p>优点：</p>
<ol>
<li>
<p>实现简单，不需要任何权限，系统中的任何用户都有权利使用这个调用。</p>
</li>
<li>
<p>扫描速度快。如果对每个目标端口以线性的方式，使用单独的“connect()”函数调用，那么将会花费相当长的时间，用户可以同时打开多个套接字，从而加速扫描。使用非阻塞I/O允许用户设置一个低的 时间以用尽周期，并同时观察多个套接字。</p>
</li>
</ol>
<p>缺点：</p>
<p>是会在目标主机的日志记录中留下痕迹，易被发现，并且数据包会被过滤掉。目标主机的logs文件会显示一连串的连接和连接出错的服务信息，并且能很快地使它关闭。</p>
<h1 id="tcp-syn扫描">TCP SYN扫描：<a hidden class="anchor" aria-hidden="true" href="#tcp-syn扫描">#</a></h1>
<p>扫描器向目标主机的一个端口发送请求连接的SYN包，扫描器在收到SYN/ACK后，不是发送的ACK应答而是发送RST包请求断开连接。这样，三次握手就没有完成，无法建立正常的TCP连接，因此，这次扫描就不会被记录到系统日志中。这种扫描技术一般不会在目标主机上留下扫描痕迹。但是，这种扫描需要有root权限。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20170521103159.png" alt=""  />
</p>
<p>端口开放：</p>
<ol>
<li>Client发送SYN</li>
<li>Server端发送SYN/ACK</li>
<li>Client发送RST断开（只需要前两步就可以判断端口开放）</li>
</ol>
<p>端口关闭：</p>
<ol>
<li>Client发送SYN</li>
<li>Server端回复RST（表示端口关闭）</li>
</ol>
<p>优点：SYN扫描要比TCP Connect()扫描隐蔽一些，SYN仅仅需要发送初始的SYN数据包给目标主机。</p>
<p>缺点：</p>
<ol>
<li>需要系统管理员的权限</li>
<li>不适合使用多线程技术。因为在实现过程中需要自己完成对应答数据报的查找、分析，使用多线程容易发生数据报的串位现象，也就是原来应该这个线程接收的数据报被另 一个线程接收，接收后，这个数据报就会被丢弃，而等待线程只好在超时之后再发送一个SYN数据报，等待应答。这样，所用的时间反而会增加。</li>
</ol>
<h1 id="tcp-fin扫描">TCP FIN扫描<a hidden class="anchor" aria-hidden="true" href="#tcp-fin扫描">#</a></h1>
<p>这种扫描方式不依赖于TCP的3次握手过程，而是TCP连接的“FIN”（结束）位标志。原理在于TCP连接结束时，会向TCP端口发送一个设置了FIN 位的连接终止数据报，关闭的端口会回应一个设置了RST的连接复位数据报；而开放的端口则会对这种可疑的数据报不加理睬，将它丢弃。可以根据是否收到 RST数据报来判断对方的端口是否开放。</p>
<p>优点：此扫描方式的优点比前两种都要隐秘，不容易被发现。</p>
<p>该方案有两个缺点：</p>
<ol>
<li>
<p>要判断对方端口是否开放必须等待超时，增加了探测时间，而且容易得出错误的结论；</p>
</li>
<li>
<p>windows系统不能使用，windows系统一旦收到这样的数据报，无论端口是否开放都会回应一个 RST连接复位数据报。</p>
</li>
</ol>
<h1 id="udp扫描">UDP扫描<a hidden class="anchor" aria-hidden="true" href="#udp扫描">#</a></h1>
<p>在UDP扫描中，是往目标端口发送一个UDP分组。如果目标端口是以一个“ICMP port Unreachable”（ICMP端口不可到达）消息来作为响应的，那么该端口是关闭的。</p>
<p>相反，如果没有收到这个消息那就可以推断该端口打开着。还有就 是一些特殊的UDP回馈，比如SQL Server服务器，对其1434号端口发送“x02”或者“x03”就能够探测得到其连接端口。</p>
<p>优点：linux windows都能用</p>
<p>缺点：</p>
<ol>
<li>
<p>由于UDP是无连接的不可靠协议，因此这种技巧的准确性 很大程度上取决于与网络及系统资源的使用率相关的多个因素。</p>
</li>
<li>
<p>当试图扫描一个大量应用分组过滤功能的设备时，UDP扫描将是一个非常缓慢的过程。如果要在互联网上执行UDP扫描，那么结果就是不可靠的。</p>
</li>
</ol>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
