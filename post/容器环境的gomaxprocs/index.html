<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>容器环境的GOMAXPROCS | Forz Blog</title>
<meta name="keywords" content="k8s" />
<meta name="description" content="CPU Affinity 熟系 Linux 后台开发的朋友都知道 CPU 亲和性（CPU Affinity）。CPU Affinity 是一种调度属性，它可以将单个进程绑定到一个或一组 CPU 上。 在 SMP（S">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84gomaxprocs/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="容器环境的GOMAXPROCS" />
<meta property="og:description" content="CPU Affinity 熟系 Linux 后台开发的朋友都知道 CPU 亲和性（CPU Affinity）。CPU Affinity 是一种调度属性，它可以将单个进程绑定到一个或一组 CPU 上。 在 SMP（S" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84gomaxprocs/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-05-08T18:06:58&#43;00:00" />
<meta property="article:modified_time" content="2021-05-08T18:06:58&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="容器环境的GOMAXPROCS"/>
<meta name="twitter:description" content="CPU Affinity 熟系 Linux 后台开发的朋友都知道 CPU 亲和性（CPU Affinity）。CPU Affinity 是一种调度属性，它可以将单个进程绑定到一个或一组 CPU 上。 在 SMP（S"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "容器环境的GOMAXPROCS",
      "item": "/post/%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84gomaxprocs/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "容器环境的GOMAXPROCS",
  "name": "容器环境的GOMAXPROCS",
  "description": "CPU Affinity 熟系 Linux 后台开发的朋友都知道 CPU 亲和性（CPU Affinity）。CPU Affinity 是一种调度属性，它可以将单个进程绑定到一个或一组 CPU 上。 在 SMP（S",
  "keywords": [
    "k8s"
  ],
  "articleBody": "CPU Affinity 熟系 Linux 后台开发的朋友都知道 CPU 亲和性（CPU Affinity）。CPU Affinity 是一种调度属性，它可以将单个进程绑定到一个或一组 CPU 上。\n在 SMP（Symmetric Multi-Processing 对称多处理）架构下，Linux 调度器（Scheduler）会根据 CPU affinity 的设置让指定的进程运行在绑定的 CPU 上，而不会在别的 CPU 上运行。 CPU Affinity 就是进程要在某个给定的 CPU 上尽量长时间地运行而不被迁移到其他处理器的倾向性。Linux 内核进程调度器天生就具有被称为软 CPU Affinity 的特性，这意味着进程通常不会在处理器之间频繁迁移。合理的设置 CPU Affinity（进程独占 CPU Core）可以提高程序处理性能。\n再看 M-P-G 模型 Golang 的调度器模型：经典的 M-P-G 模型，在 Go Scheduler 模型中：\n G 代表 goroutine，即用户创建的 goroutines P 代表 Logical processor，是类似于 CPU 核心的概念，其用来控制并发的 M 数量 M 是操作系统线程。在绝大多数时候，P 的数量和 M 的数量是相等的。每创建一个 P, 就会创建一个对应的 M  当 M 需要执行 G 的时候，它需要寻找到一个空闲的 P，只有跟一个 P 绑定后，M 才能被执行。通过这样的方式，Go Scheduler 保证了在同一时间内，最多只有 P 个系统线程在真正地执行。P 的数量在默认情况下，会被设定为 CPU 的数量。而 M 虽然需要跟 P 绑定执行，但数量上并不与 P 相等。这是因为 M 会因为系统调用或者其他事情被阻塞，因此随着程序的执行，M 的数量可能增长，而 P 在没有用户干预的情况下，则会保持不变。\nGolang 的 Runtime 包中获取和设置 GOMAXPROCS 的 代码如下，也就是 Go Scheduler 确定 P 数量的逻辑。在 Linux 上，它会利用系统调用 sched_getaffinity 来获得系统的 CPU 核数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  // The bootstrap sequence is: // // call osinit // call schedinit // make \u0026 queue new G // call runtime·mstart // // The new G calls runtime·main. func schedinit() { //...... \tprocs := ncpu if n, ok := atoi32(gogetenv(\"GOMAXPROCS\")); ok \u0026\u0026 n  0 { procs = n } if procresize(procs) != nil { throw(\"unknown runnable goroutine during bootstrap\") } //...... } // runtime/os_linux.go func osinit() { ncpu = getproccount() } // runtime/os_linux.go func getproccount() int32 { // This buffer is huge (8 kB) but we are on the system stack \t// and there should be plenty of space (64 kB). \t// Also this is a leaf, so we're not holding up the memory for long. \t// See golang.org/issue/11823. \t// The suggested behavior here is to keep trying with ever-larger \t// buffers, but we don't have a dynamic memory allocator at the \t// moment, so that's a bit tricky and seems like overkill. \tconst maxCPUs = 64 * 1024 var buf [maxCPUs / 8]byte r := sched_getaffinity(0, unsafe.Sizeof(buf), \u0026buf[0]) if r  0 { return 1 } n := int32(0) for _, v := range buf[:r] { for v != 0 { n += int32(v \u0026 1) v = 1 } } if n == 0 { n = 1 } return n }   调多processor的影响 runtime processor多了会出现什么问题？\n一个runtime findrunnable时产生的损耗，另一个是线程引起的上下文切换。\nruntime的findrunnable方法是解决m找可用的协程的函数，当从绑定p本地runq上找不到可执行的goroutine后，尝试从全局链表中拿，再拿不到从netpoll和事件池里拿，最后会从别的p里偷任务。全局runq是有锁操作，其他偷任务使用了atomic原子操作来规避futex竞争下陷入切换等待问题，但lock free在竞争下也会有忙轮询的状态，比如不断的尝试。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 全局 runq  if sched.runqsize != 0 { lock(\u0026sched.lock) gp := globrunqget(_p_, 0) unlock(\u0026sched.lock) if gp != nil { return gp, false } } ... // 尝试4次从别的p偷任务  for i := 0; i  4; i++ { for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() { if sched.gcwaiting != 0 { goto top } stealRunNextG := i  2 // first look for ready queues with more than 1 g  if gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != nil { return gp, false } } } ...   通过godebug可以看到全局队列及各个p的runq里等待调度的任务量。有不少p是空的，那么势必会引起steal偷任务。另外，runqueue的大小远超其他p的总和，说明大部分任务在全局里，全局又是把大锁。\n随着调多runtime processor数量，相关的m线程自然也就跟着多了起来。linux内核为了保证可执行的线程在调度上雨露均沾，按照内核调度算法来切换就绪状态的线程，切换又引起上下文切换。上下文切换也是性能的一大杀手。findrunnable的某些锁竞争也会触发上下文切换。\n下面是我这边一个行情推送服务压测下的vmstat监控数据。首先把容器的的cpu core限制为8，再先后测试processor为8和48的情况。图的上面是processor为8的情况，下面为processor为48的情况。看图可以直观的发现当processor调大后，上下文切换明显多起来，另外等待调度的线程也多了。\n另外从qps的指标上也可以反映多processor带来的性能损耗。通过下图可以看到当runtime.GOMAXPROCS为固定的cpu core数时，性能最理想。后面随着processor数量的增长，qps指标有所下降。\n通过golang tool trace可以分析出协程调度等待时间越来越长了。\nGOMAXPROCS 及取值 可以通过 runtime.GOMAXPROCS() 来设定 P 的值，当前 Go 版本的 GOMAXPROCS 默认值已经设置为 CPU 的（逻辑核）核数， 这允许我们的 Go 程序充分使用机器的每一个 CPU, 最大程度的提高我们程序的并发性能。不过从实践经验中来看，IO 密集型的应用，可以稍微调高 P 的个数；而本文讨论的 Affinity 设置更适合 CPU 密集型的应用。\n物理机 \u0026\u0026 虚拟机 在物理机及一般的 CVM 中，runtime.GOMAXPROCS() 的值就是 CPU 的逻辑核数。比如在笔者的机器上，runtime.GOMAXPROCS() 获取的值就是 8image\nDocker-Container docker 官方文档中指出：\nBy default, each container’s access to the host machine’s CPU cycles is unlimited. You can set various constraints to limit a given container’s access to the host machine’s CPU cycles. Most users use and configure the default CFS scheduler. In Docker 1.13 and higher, you can also configure the realtime scheduler.\n小结下：\n 默认容器会使用宿主机 CPU 是不受限制的 要限制容器使用 CPU，可以通过参数设置 CPU 的使用，又细分为两种策略：  将容器设置为普通进程，通过完全公平调度算法（CFS，Completely Fair Scheduler）调度类实现对容器 CPU 的限制 – 默认方案 将容器设置为实时进程，通过实时调度类进行限制    我们这里仅考虑默认方案，即通过 CFS 调度类实现对容器 CPU 的限制。（我们下面的分析默认了进程只进行 CPU 操作，没有睡眠、IO 等操作，换句话说，进程的生命周期中一直在就绪队列中排队，要么在用 CPU，要么在等 CPU）\ndocker（docker run）配置 CPU 使用量的参数主要下面几个，这些参数主要是通过配置在容器对应 cgroup 中，由 cgroup 进行实际的 CPU 管控。其对应的路径可以从 cgroup 中查看到\n1 2 3 4  --cpu-shares CPU shares (relative weight) --cpu-period Limit CPU CFS (Completely Fair Scheduler) period --cpu-quota Limit CPU CFS (Completely Fair Scheduler) quota --cpuset-cpus CPUs in which to allow execution (0-3, 0,1)   在 Docker-container 中，runtime.GOMAXPROCS() 依赖/proc/cpuinfo信息,获取的是 宿主机的 CPU 核数 。P 值设置过大，导致生成线程过多，会增加上线文切换的负担，导致严重的上下文切换，浪费 CPU。 所以，在 Docker-container 中, Golang 设置的 GOMAXPROCS 并不准确。\nKubernetes kubernetes 对容器可以设置两个关于 CPU 的值：limits 和 requests，即 spec.containers[].resources.limits.cpu 和 spec.containers[].resources.requests.cpu，对应了上面的配置选项，如下面的配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  image: --------- imagePullPolicy: IfNotPresent name: pandaychen-test-app1 resources: limits: cpu: \"2\" memory: 4196Mi requests: cpu: \"1\" memory: 1Gi securityContext: privileged: false procMount: Default terminationMessagePath: /dev/termination-log terminationMessagePolicy: File   关于 limits 和 requests 则两个值：\n  limits：该（单）pod 使用的最大的 CPU 核数 limits=cfs_quota_us/cfs_period_us 的值。比如 limits.cpu=3（核），则 cfs_quota_us=300000，cfs_period_us 值一般都使用默认的 100000\n  requests：该（单）pod 使用的最小的 CPU 核数，为 pod 调度提供计算依据\n 一方面则体现在容器设置 --cpu-shares 上，比如 requests.cpu=3，–cpu-shares=1024，则 cpushare=1024*3=3072。 另一方面，比较重要的一点，用来计算 Node 的 CPU 的已经分配的量就是通过计算所有容器的 requests 的和得到的，那么该 Node 还可以分配的量就是该 Node 的 CPU 核数减去前面这个值。当创建一个 Pod 时，Kubernetes 调度程序将为 Pod 选择一个 Node。每个 Node 具有每种资源类型的最大容量：可为 Pods 提供的 CPU 和内存量。调度程序确保对于每种资源类型，调度的容器的资源请求的总和小于 Node 的容量。尽管 Node 上的实际内存或 CPU 资源使用量非常低，但如果容量检查失败，则调度程序仍然拒绝在节点上放置 Pod。    Kubernetes Pod 中的结果同 Docker，在 Kubernetes 集群中，如果采用如此设置，会导致 Node（宿主机）中的线程数过多。在笔者的 Kubernetes 集群中，有 3 个 Node 节点，总核数约 36 核：\n1 2  CPU: 8.95/35.97 核 内存: 18.56/63.95GB   创建的 Pod 参数中，限制 Pod 的 CPU 核数是 1（limits），采用了 GOMAXPROCS 设置后，发现 Pod 容器中的线程数量超过 36，集群中的线程总数也远超过预期。\n1 2 3 4 5 6 7  resources:limits:cpu:\"1\"memory:6Girequests:cpu:500mmemory:1Gi  小结下，在 Docker-container 和 Kubernetes 集群中，存在 GOMAXPROCS 会错误识别容器 cpu 核心数的问题。此外，在 Kubernetes 集群中，为每个应用 Pod 分配的 CPU 及 CPU limits 不一定相同，所以通过配置指定 GOMAXPROCS 线程数来匹配 CPU 核心个数的方法，不太靠谱，同时这种 Fixed 的方式也与 Kubernetes 的（自动）扩缩容理念不符。\n解决 让我们回到 GOMAXPROCS 的问题，一般在部署容器应用时，通常会对 CPU 资源做限制，例如上面 yaml 文件的，上限是 2 个核。而实际应用的 pod 中，通过 lscpu 命令 ，我们仍然能看到宿主机的所有 CPU 核心，如下面是笔者的一个 Kubernetes 集群中的 Pod 信息：\n这会导致 Golang 服务默认会拿宿主机的 CPU 核心数来调用 runtime.GOMAXPROCS()，导致 P 数量远远大于可用的 CPU 核心，引起频繁上下文切换，影响高负载情况下的服务性能。而 Uber-Automaxprocs 这个库 能够正确识别容器允许使用的核心数，合理的设置 processor 数目，避免高并发下的切换问题。\n它的使用方式也是非常简单：\n1 2 3 4 5  import _ \"go.uber.org/automaxprocs\" func main() { // Your application logic here }   automaxprocs 我们知道，docker使用cgroup来限制容器CPU使用, 使用该容器配置的cpu.cfsquotaus/cpu.cfsperiodus即可获得CPU配额. 所以关键是找到容器的这两个值.\ninit 通过 Readme.md 中的 import 方式，\n1  import _ \"go.uber.org/automaxprocs\"   大概可以猜到，该包的 init 方法 是 package 级别的。导入即生效。\ninit 方法：\n1 2 3 4  func init() { // 入口，核心方法 \tmaxprocs.Set(maxprocs.Logger(log.Printf)) }   maxprocs.Set() 核心函数就是 maxpROCs.Set()；这个函数会从当前的 cgroups 里获取设置的 CPU quota，然后转换为合适的 GOMAXPROCS。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  func Set(opts ...Option) (func(), error) { cfg := \u0026config{ procs: iruntime.CPUQuotaToGOMAXPROCS, minGOMAXPROCS: 1, } for _, o := range opts { o.apply(cfg) } undoNoop := func() { cfg.log(\"maxprocs: No GOMAXPROCS change to reset\") } // Honor the GOMAXPROCS environment variable if present. Otherwise, amend \t// `runtime.GOMAXPROCS()` with the current process' CPU quota if the OS is \t// Linux, and guarantee a minimum value of 1. The minimum guaranteed value \t// can be overriden using `maxprocs.Min()`. \tif max, exists := os.LookupEnv(_maxProcsKey); exists { cfg.log(\"maxprocs: Honoring GOMAXPROCS=%q as set in environment\", max) return undoNoop, nil } // 核心函数，调用 iruntime.CPUQuotaToGOMAXPROCS 得到最终的 maxProcs \tmaxProcs, status, err := cfg.procs(cfg.minGOMAXPROCS) if err != nil { return undoNoop, err } if status == iruntime.CPUQuotaUndefined { cfg.log(\"maxprocs: Leaving GOMAXPROCS=%v: CPU quota undefined\", currentMaxProcs()) return undoNoop, nil } prev := currentMaxProcs() undo := func() { cfg.log(\"maxprocs: Resetting GOMAXPROCS to %v\", prev) runtime.GOMAXPROCS(prev) } switch status { case iruntime.CPUQuotaMinUsed: cfg.log(\"maxprocs: Updating GOMAXPROCS=%v: using minimum allowed GOMAXPROCS\", maxProcs) case iruntime.CPUQuotaUsed: cfg.log(\"maxprocs: Updating GOMAXPROCS=%v: determined from CPU quota\", maxProcs) } // 调用系统的 runtime 完成功能 \truntime.GOMAXPROCS(maxProcs) return undo, nil }   可以看出主要的工作都在 iruntime.CPUQuotaToGOMAXPROCS() 里完成。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // CPUQuotaToGOMAXPROCS converts the CPU quota applied to the calling process // to a valid GOMAXPROCS value. // minValue 避免外部 cpu quota 设置的过小。 func CPUQuotaToGOMAXPROCS(minValue int) (int, CPUQuotaStatus, error) { cgroups, err := cg.NewCGroupsForCurrentProcess() if err != nil { return -1, CPUQuotaUndefined, err } quota, defined, err := cgroups.CPUQuota() if !defined || err != nil { return -1, CPUQuotaUndefined, err } maxProcs := int(math.Floor(quota)) if minValue  0 \u0026\u0026 maxProcs  minValue { return minValue, CPUQuotaMinUsed, nil } return maxProcs, CPUQuotaUsed, nil }   1 2 3 4 5  // NewCGroupsForCurrentProcess returns a new *CGroups instance for the current // process. func NewCGroupsForCurrentProcess() (CGroups, error) { return NewCGroups(_procPathMountInfo, _procPathCGroup) }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  // NewCGroups returns a new *CGroups from given `mountinfo` and `cgroup` files // under for some process under `/proc` file system (see also proc(5) for more // information). func NewCGroups(procPathMountInfo, procPathCGroup string) (CGroups, error) { cgroupSubsystems, err := parseCGroupSubsystems(procPathCGroup) if err != nil { return nil, err } cgroups := make(CGroups) newMountPoint := func(mp *MountPoint) error { if mp.FSType != _cgroupFSType { return nil } for _, opt := range mp.SuperOptions { subsys, exists := cgroupSubsystems[opt] if !exists { continue } cgroupPath, err := mp.Translate(subsys.Name) if err != nil { return err } cgroups[opt] = NewCGroup(cgroupPath) } return nil } if err := parseMountInfo(procPathMountInfo, newMountPoint); err != nil { return nil, err } return cgroups, nil }   parseCGroupSubsystems 核心函数之一的 parseCGroupSubsystems() 可以通过解析 /pROC/$pid/cgroup 文件，返回这个进程的 cgroup subsystem table，对应的数据结构是：\n1 2 3 4 5 6 7  // CGroupSubsys represents the data structure for entities in // `/proc/$PID/cgroup`. See also proc(5) for more information. type CGroupSubsys struct { ID int Subsystems []string Name string }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // parseCGroupSubsystems parses procPathCGroup (usually at `/proc/$PID/cgroup`) // and returns a new map[string]*CGroupSubsys. func parseCGroupSubsystems(procPathCGroup string) (map[string]*CGroupSubsys, error) { cgroupFile, err := os.Open(procPathCGroup) if err != nil { return nil, err } defer cgroupFile.Close() scanner := bufio.NewScanner(cgroupFile) subsystems := make(map[string]*CGroupSubsys) for scanner.Scan() { //解析文本 \tcgroup, err := NewCGroupSubsysFromLine(scanner.Text()) if err != nil { return nil, err } for _, subsys := range cgroup.Subsystems { subsystems[subsys] = cgroup } } if err := scanner.Err(); err != nil { return nil, err } return subsystems, nil }   这里看一下 /pROC/$pid/cgroup 的样子\n每行都是一条记录，记录的每个 field 之间用 : 分割，从左至右分别是：\n id subsystems，多个 subsystem 之间用 , 分隔 pathname  这里的目标是包含 cpu 这个 subsystem 的这条记录；其他的记录其实无关紧要。\n同时注意一下 pathname 这个字段，代表进程所属的 cgroup hierarchy 的路径，并且一个相对于 cgroup hierarchy 的 mount point 的一个相对路径。\n这里能看到一条记录可能有多个 subsystem，所以前面的 table 最后会出现多个 subsystem key 指向的其实是同一个 CGroupSubsys 实例。\nparseMountInfo 类似的，核心函数 parseMountInfo() 会打开进程的 mountinfo 文件，然后将每一行记录解析成对应的 MountInfo 结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // MountPoint is the data structure for the mount points in // `/proc/$PID/mountinfo`. See also proc(5) for more information. type MountPoint struct { MountID int ParentID int DeviceID string Root string MountPoint string Options []string OptionalFields []string FSType string MountSource string SuperOptions []string }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // parseMountInfo parses procPathMountInfo (usually at `/proc/$PID/mountinfo`) // and yields parsed *MountPoint into newMountPoint. func parseMountInfo(procPathMountInfo string, newMountPoint func(*MountPoint) error) error { mountInfoFile, err := os.Open(procPathMountInfo) if err != nil { return err } defer mountInfoFile.Close() scanner := bufio.NewScanner(mountInfoFile) for scanner.Scan() { mountPoint, err := NewMountPointFromLine(scanner.Text()) if err != nil { return err } if err := newMountPoint(mountPoint); err != nil { return err } } return scanner.Err() }   看一下一个示例 mountinfo 文件内容\n每条记录的字段用空格分隔，字段 - 表示后面都是 options\n共有三个字段需要我们关心：\n 索引为3的字段；组成当前挂载点根路径的文件系统的路径，对应 MountInfo.Root 索引为4的字段；当前挂载点相对于进程根目录的路径，对应 MountInfo.MountPoint - 字段之后的第一个字段，代表 filesystem type，对应 MountInfo.FsType；我们其实只需要 cgroup。 上面 fstype 字段之后的第二个字段，是 subsystems，subsystem之间用,分割；这里我们其实需要的是包含 cpu 的这个 subsystem  找到目标 cgroup path 有了前两步之后，就可以找到进程对应的 cpu 这个 subsystem 的 CGroup path。\n1 2 3 4  // CGroup represents the data structure for a Linux control group. type CGroup struct { path string }   这部分操作在 lambda 函数 newMountPoint() 中。\n总结起来就是：\n 在 mountinfo 文件中找到 fstype = cgroup \u0026\u0026 subsystems.contains(cpu) 的记录，分离出 root 和 mount-point。 在 cgroup 文件中找到 subsystems.contains(cpu) 的记录，分理出 pathname cgroupPath = Join(mount_point, relative(root, pathname)) relative() 函数返回 pathname 相对于 root 的相对路径  实践中发现 root 和 pathname 基本一致，这样返回的相对路径就是 .；最后组合的最终路径都是 /sys/fs/cgroup/cpu\n不过考虑到不同发行版甚至不同版本的 docker / k8s 行为可能存在不一致，所以最具有移植性还是上面的做法。\n计算 cpu 配额 有了前面的目录路径之后，该目录下的：\n cfs.cpu_period_us 文件记录了调度周期，单位是 us；默认值一般是 100'000，即 100 ms cfs.cpu_quota_us 记录了每个调度周期进程允许使用 cpu 的量，单位也是 us。值为 -1 表示无限制；对于 4C 的容器，这个值一般是 400'000  这两个值限制的是进程使用 cpu 的时间。 上述设置下表示：每 100ms 的调度周期内，该进程可以使用 400ms 的 cpu 时间，所以看起来的效果是可以使用4个CPU核心\n更详细的内容请参考 Linux kernel 的文档：CFS Bandwidth Control\nquota 和 period 的比值就是 docker 为容器设置的 CPU 核数配置。 这个值也是 automaxpROCs 为 runtime.GOMAXPROCS() 设置的值。 这部分逻辑对应库函数：CGoups.CPUQuota()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // CPUQuota returns the CPU quota applied with the CPU cgroup controller. // It is a result of `cpu.cfs_quota_us / cpu.cfs_period_us`. If the value of // `cpu.cfs_quota_us` was not set (-1), the method returns `(-1, nil)`. func (cg CGroups) CPUQuota() (float64, bool, error) { cpuCGroup, exists := cg[_cgroupSubsysCPU] if !exists { return -1, false, nil } cfsQuotaUs, err := cpuCGroup.readInt(_cgroupCPUCFSQuotaUsParam) if defined := cfsQuotaUs  0; err != nil || !defined { return -1, defined, err } cfsPeriodUs, err := cpuCGroup.readInt(_cgroupCPUCFSPeriodUsParam) if err != nil { return -1, false, err } return float64(cfsQuotaUs) / float64(cfsPeriodUs), true, nil }   总结 流程图:\n容器技术（docker）通过 Linux kernel 提供的 cgroups 机制来实现资源隔离和限制，但是这种限制有时候会出现反直觉的结果。\n上面的分析过程看，虽然这个库做的事情比较简单，但是要注意的是，我们是通过逆向工程（由果推因）来分析的这个问题。\n如果需要从正面解决（执因索果），那么就需要对 1）容器实现细节 2）linux 内核中 cgroups 的实现细节 有很深的了解。\n这恐怕也是过了一年多才找到解决方案，而且最后还是直接使用别人的solution的原因。\nautomaxprocs的限制 事实上，automaxpROCs 仅针对于使用 CFS 调度策略的实例。\nCFS 调度测类只限制进程的运行配额，不设置 processor affinity。所以在 4C 的限制下，理论上 G-P-M 调度模型下的 M 可以运行在任意物理核心上\n查看 /sys/fs/cgroup/cpuset/cpuset.cpus 这个文件可以发现没有做任何物理核心上的限制。\ndocker 创建容器时可以使用 –cpus=x 来实现。\n对于只使用 cpuset 策略的容器来说，其实没必要使用这个库。\n因为 cpuset 直接设置了容器的 processor affinity，然后神奇的是，golang 的 runtime.NumCores() 获取的核心数是考虑过 processor affinity 的。\n参考 GOMAXPROCS 的坑\nUber-Automaxprocs 分析\nuber automaxprocs 源码分析\ngolang gomaxprocs调高引起调度性能损耗\n",
  "wordCount" : "6340",
  "inLanguage": "zh-cn",
  "datePublished": "2021-05-08T18:06:58Z",
  "dateModified": "2021-05-08T18:06:58Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84gomaxprocs/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      容器环境的GOMAXPROCS
    </h1>
    <div class="post-meta">May 8, 2021
</div>
  </header> 
  <div class="post-content"><h2 id="cpu-affinity">CPU Affinity<a hidden class="anchor" aria-hidden="true" href="#cpu-affinity">#</a></h2>
<p>熟系 Linux 后台开发的朋友都知道 CPU 亲和性（CPU Affinity）。CPU Affinity 是一种调度属性，它可以将单个进程绑定到一个或一组 CPU 上。</p>
<p>在 SMP（Symmetric Multi-Processing 对称多处理）架构下，Linux 调度器（Scheduler）会根据 CPU affinity 的设置让指定的进程运行在绑定的 CPU 上，而不会在别的 CPU 上运行。 CPU Affinity 就是进程要在某个给定的 CPU 上尽量长时间地运行而不被迁移到其他处理器的倾向性。Linux 内核进程调度器天生就具有被称为软 CPU Affinity 的特性，这意味着进程通常不会在处理器之间频繁迁移。合理的设置 CPU Affinity（进程独占 CPU Core）可以提高程序处理性能。</p>
<h2 id="再看-m-p-g-模型">再看 M-P-G 模型<a hidden class="anchor" aria-hidden="true" href="#再看-m-p-g-模型">#</a></h2>
<p>Golang 的调度器模型：经典的 M-P-G 模型，在 Go Scheduler 模型中：</p>
<ul>
<li>G 代表 goroutine，即用户创建的 goroutines</li>
<li>P 代表 Logical processor，是类似于 CPU 核心的概念，其用来控制并发的 M 数量</li>
<li>M 是操作系统线程。在绝大多数时候，P 的数量和 M 的数量是相等的。每创建一个 P, 就会创建一个对应的 M</li>
</ul>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210508180932.png" alt=""  />
</p>
<p>当 M 需要执行 G 的时候，它需要寻找到一个空闲的 P，只有跟一个 P 绑定后，M 才能被执行。通过这样的方式，Go Scheduler 保证了在同一时间内，最多只有 P 个系统线程在真正地执行。P 的数量在默认情况下，会被设定为 CPU 的数量。而 M 虽然需要跟 P 绑定执行，但数量上并不与 P 相等。这是因为 M 会因为系统调用或者其他事情被阻塞，因此随着程序的执行，M 的数量可能增长，而 P 在没有用户干预的情况下，则会保持不变。</p>
<p>Golang 的 Runtime 包中获取和设置 GOMAXPROCS 的 代码如下，也就是 Go Scheduler 确定 P 数量的逻辑。在 Linux 上，它会利用系统调用 sched_getaffinity 来获得系统的 CPU 核数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// The bootstrap sequence is:
</span><span class="c1">//
</span><span class="c1">// call osinit
</span><span class="c1">// call schedinit
</span><span class="c1">// make &amp; queue new G
</span><span class="c1">// call runtime·mstart
</span><span class="c1">//
</span><span class="c1">// The new G calls runtime·main.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">schedinit</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//......
</span><span class="c1"></span>	<span class="nx">procs</span> <span class="o">:=</span> <span class="nx">ncpu</span>
	<span class="k">if</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">atoi32</span><span class="p">(</span><span class="nf">gogetenv</span><span class="p">(</span><span class="s">&#34;GOMAXPROCS&#34;</span><span class="p">));</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">procs</span> <span class="p">=</span> <span class="nx">n</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nf">procresize</span><span class="p">(</span><span class="nx">procs</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unknown runnable goroutine during bootstrap&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">//......
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// runtime/os_linux.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">osinit</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ncpu</span> <span class="p">=</span> <span class="nf">getproccount</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// runtime/os_linux.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getproccount</span><span class="p">()</span> <span class="kt">int32</span> <span class="p">{</span>
	<span class="c1">// This buffer is huge (8 kB) but we are on the system stack
</span><span class="c1"></span>	<span class="c1">// and there should be plenty of space (64 kB).
</span><span class="c1"></span>	<span class="c1">// Also this is a leaf, so we&#39;re not holding up the memory for long.
</span><span class="c1"></span>	<span class="c1">// See golang.org/issue/11823.
</span><span class="c1"></span>	<span class="c1">// The suggested behavior here is to keep trying with ever-larger
</span><span class="c1"></span>	<span class="c1">// buffers, but we don&#39;t have a dynamic memory allocator at the
</span><span class="c1"></span>	<span class="c1">// moment, so that&#39;s a bit tricky and seems like overkill.
</span><span class="c1"></span>	<span class="kd">const</span> <span class="nx">maxCPUs</span> <span class="p">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span>
	<span class="kd">var</span> <span class="nx">buf</span> <span class="p">[</span><span class="nx">maxCPUs</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span><span class="kt">byte</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nf">sched_getaffinity</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">buf</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="k">if</span> <span class="nx">r</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">buf</span><span class="p">[:</span><span class="nx">r</span><span class="p">]</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">v</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">n</span> <span class="o">+=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">v</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="nx">v</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="调多processor的影响">调多processor的影响<a hidden class="anchor" aria-hidden="true" href="#调多processor的影响">#</a></h2>
<p>runtime processor多了会出现什么问题？</p>
<p>一个runtime findrunnable时产生的损耗，另一个是线程引起的上下文切换。</p>
<p>runtime的findrunnable方法是解决m找可用的协程的函数，当从绑定p本地runq上找不到可执行的goroutine后，尝试从全局链表中拿，再拿不到从netpoll和事件池里拿，最后会从别的p里偷任务。全局runq是有锁操作，其他偷任务使用了atomic原子操作来规避futex竞争下陷入切换等待问题，但lock free在竞争下也会有忙轮询的状态，比如不断的尝试。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">    <span class="c1">// 全局 runq
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="o">...</span>
    <span class="c1">// 尝试4次从别的p偷任务
</span><span class="c1"></span>     <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">enum</span> <span class="o">:=</span> <span class="nx">stealOrder</span><span class="p">.</span><span class="nf">start</span><span class="p">(</span><span class="nf">fastrand</span><span class="p">());</span> <span class="p">!</span><span class="nx">enum</span><span class="p">.</span><span class="nf">done</span><span class="p">();</span> <span class="nx">enum</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">goto</span> <span class="nx">top</span>
            <span class="p">}</span>
            <span class="nx">stealRunNextG</span> <span class="o">:=</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">2</span> <span class="c1">// first look for ready queues with more than 1 g
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">runqsteal</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">enum</span><span class="p">.</span><span class="nf">position</span><span class="p">()],</span> <span class="nx">stealRunNextG</span><span class="p">);</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div><p>通过godebug可以看到全局队列及各个p的runq里等待调度的任务量。有不少p是空的，那么势必会引起steal偷任务。另外，runqueue的大小远超其他p的总和，说明大部分任务在全局里，全局又是把大锁。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210510134249.png" alt=""  />
</p>
<p>随着调多runtime processor数量，相关的m线程自然也就跟着多了起来。linux内核为了保证可执行的线程在调度上雨露均沾，按照内核调度算法来切换就绪状态的线程，切换又引起上下文切换。上下文切换也是性能的一大杀手。findrunnable的某些锁竞争也会触发上下文切换。</p>
<p>下面是我这边一个行情推送服务压测下的vmstat监控数据。首先把容器的的cpu core限制为8，再先后测试processor为8和48的情况。图的上面是processor为8的情况，下面为processor为48的情况。看图可以直观的发现当processor调大后，上下文切换明显多起来，另外等待调度的线程也多了。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210510134330.png" alt=""  />
</p>
<p>另外从qps的指标上也可以反映多processor带来的性能损耗。通过下图可以看到当runtime.GOMAXPROCS为固定的cpu core数时，性能最理想。后面随着processor数量的增长，qps指标有所下降。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210510134344.png" alt=""  />
</p>
<p>通过golang tool trace可以分析出协程调度等待时间越来越长了。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210510134354.png" alt=""  />
</p>
<h2 id="gomaxprocs-及取值">GOMAXPROCS 及取值<a hidden class="anchor" aria-hidden="true" href="#gomaxprocs-及取值">#</a></h2>
<p>可以通过 runtime.GOMAXPROCS() 来设定 P 的值，当前 Go 版本的 GOMAXPROCS 默认值已经设置为 CPU 的（逻辑核）核数， 这允许我们的 Go 程序充分使用机器的每一个 CPU, 最大程度的提高我们程序的并发性能。不过从实践经验中来看，IO 密集型的应用，可以稍微调高 P 的个数；而本文讨论的 Affinity 设置更适合 CPU 密集型的应用。</p>
<h3 id="物理机--虚拟机">物理机 &amp;&amp; 虚拟机<a hidden class="anchor" aria-hidden="true" href="#物理机--虚拟机">#</a></h3>
<p>在物理机及一般的 CVM 中，runtime.GOMAXPROCS() 的值就是 CPU 的逻辑核数。比如在笔者的机器上，runtime.GOMAXPROCS() 获取的值就是 8image</p>
<h3 id="docker-container">Docker-Container<a hidden class="anchor" aria-hidden="true" href="#docker-container">#</a></h3>
<p>docker 官方文档中指出：</p>
<p>By default, each container’s access to the host machine’s CPU cycles is unlimited. You can set various constraints to limit a given container’s access to the host machine’s CPU cycles. Most users use and configure the default CFS scheduler. In Docker 1.13 and higher, you can also configure the realtime scheduler.</p>
<p>小结下：</p>
<ul>
<li>默认容器会使用宿主机 CPU 是不受限制的</li>
<li>要限制容器使用 CPU，可以通过参数设置 CPU 的使用，又细分为两种策略：
<ul>
<li>将容器设置为普通进程，通过完全公平调度算法（CFS，Completely Fair Scheduler）调度类实现对容器 CPU 的限制 – 默认方案</li>
<li>将容器设置为实时进程，通过实时调度类进行限制</li>
</ul>
</li>
</ul>
<p>我们这里仅考虑默认方案，即通过 CFS 调度类实现对容器 CPU 的限制。（我们下面的分析默认了进程只进行 CPU 操作，没有睡眠、IO 等操作，换句话说，进程的生命周期中一直在就绪队列中排队，要么在用 CPU，要么在等 CPU）</p>
<p>docker（docker run）配置 CPU 使用量的参数主要下面几个，这些参数主要是通过配置在容器对应 cgroup 中，由 cgroup 进行实际的 CPU 管控。其对应的路径可以从 cgroup 中查看到</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s">  <span class="o">--</span><span class="n">cpu</span><span class="o">-</span><span class="n">shares</span>                    <span class="n">CPU</span> <span class="nf">shares </span><span class="p">(</span><span class="n">relative</span> <span class="n">weight</span><span class="p">)</span>
  <span class="o">--</span><span class="n">cpu</span><span class="o">-</span><span class="n">period</span>                    <span class="n">Limit</span> <span class="n">CPU</span> <span class="nf">CFS </span><span class="p">(</span><span class="n">Completely</span> <span class="n">Fair</span> <span class="n">Scheduler</span><span class="p">)</span> <span class="n">period</span>
  <span class="o">--</span><span class="n">cpu</span><span class="o">-</span><span class="n">quota</span>                     <span class="n">Limit</span> <span class="n">CPU</span> <span class="nf">CFS </span><span class="p">(</span><span class="n">Completely</span> <span class="n">Fair</span> <span class="n">Scheduler</span><span class="p">)</span> <span class="n">quota</span>
  <span class="o">--</span><span class="n">cpuset</span><span class="o">-</span><span class="n">cpus</span>                   <span class="n">CPUs</span> <span class="n">in</span> <span class="n">which</span> <span class="n">to</span> <span class="n">allow</span> <span class="nf">execution </span><span class="p">(</span><span class="m">0-3</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>在 Docker-container 中，runtime.GOMAXPROCS() 依赖/proc/cpuinfo信息,获取的是 宿主机的 CPU 核数 。P 值设置过大，导致生成线程过多，会增加上线文切换的负担，导致严重的上下文切换，浪费 CPU。 所以，在 Docker-container 中, Golang 设置的 GOMAXPROCS 并不准确。</p>
<h3 id="kubernetes">Kubernetes<a hidden class="anchor" aria-hidden="true" href="#kubernetes">#</a></h3>
<p>kubernetes 对容器可以设置两个关于 CPU 的值：limits 和 requests，即 <code>spec.containers[].resources.limits.cpu</code> 和 <code>spec.containers[].resources.requests.cpu</code>，对应了上面的配置选项，如下面的配置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">image</span><span class="o">:</span> <span class="o">---------</span>
        <span class="n">imagePullPolicy</span><span class="o">:</span> <span class="n">IfNotPresent</span>
        <span class="n">name</span><span class="o">:</span> <span class="n">pandaychen</span><span class="o">-</span><span class="n">test</span><span class="o">-</span><span class="n">app1</span>
        <span class="n">resources</span><span class="o">:</span>
          <span class="n">limits</span><span class="o">:</span>
            <span class="n">cpu</span><span class="o">:</span> <span class="s">&#34;2&#34;</span>
            <span class="n">memory</span><span class="o">:</span> <span class="m">4196</span><span class="n">Mi</span>
          <span class="n">requests</span><span class="o">:</span>
            <span class="n">cpu</span><span class="o">:</span> <span class="s">&#34;1&#34;</span>
            <span class="n">memory</span><span class="o">:</span> <span class="m">1</span><span class="n">Gi</span>
        <span class="n">securityContext</span><span class="o">:</span>
          <span class="n">privileged</span><span class="o">:</span> <span class="n">false</span>
          <span class="n">procMount</span><span class="o">:</span> <span class="n">Default</span>
        <span class="n">terminationMessagePath</span><span class="o">:</span> <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">termination</span><span class="o">-</span><span class="n">log</span>
        <span class="n">terminationMessagePolicy</span><span class="o">:</span> <span class="n">File</span>
</code></pre></td></tr></table>
</div>
</div><p>关于 limits 和 requests 则两个值：</p>
<ul>
<li>
<p>limits：该（单）pod 使用的最大的 CPU 核数 <code>limits=cfs_quota_us/cfs_period_us</code> 的值。比如 limits.cpu=3（核），则 cfs_quota_us=300000，cfs_period_us 值一般都使用默认的 100000</p>
</li>
<li>
<p>requests：该（单）pod 使用的最小的 CPU 核数，为 pod 调度提供计算依据</p>
<ul>
<li>一方面则体现在容器设置 <code>--cpu-shares</code> 上，比如 <code>requests.cpu=3</code>，<code>–cpu-shares=1024</code>，则 <code>cpushare=1024*3=3072</code>。</li>
<li>另一方面，比较重要的一点，用来计算 Node 的 CPU 的已经分配的量就是通过计算所有容器的 requests 的和得到的，那么该 Node 还可以分配的量就是该 Node 的 CPU 核数减去前面这个值。当创建一个 Pod 时，Kubernetes 调度程序将为 Pod 选择一个 Node。每个 Node 具有每种资源类型的最大容量：可为 Pods 提供的 CPU 和内存量。调度程序确保对于每种资源类型，调度的容器的资源请求的总和小于 Node 的容量。尽管 Node 上的实际内存或 CPU 资源使用量非常低，但如果容量检查失败，则调度程序仍然拒绝在节点上放置 Pod。</li>
</ul>
</li>
</ul>
<p>Kubernetes Pod 中的结果同 Docker，在 Kubernetes 集群中，如果采用如此设置，会导致 Node（宿主机）中的线程数过多。在笔者的 Kubernetes 集群中，有 3 个 Node 节点，总核数约 36 核：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">CPU</span><span class="o">:</span> <span class="m">8.95</span><span class="o">/</span><span class="m">35.97</span> 核
内存<span class="o">:</span> <span class="m">18.56</span><span class="o">/</span><span class="m">63.95</span><span class="n">GB</span>
</code></pre></td></tr></table>
</div>
</div><p>创建的 Pod 参数中，限制 Pod 的 CPU 核数是 1（limits），采用了 GOMAXPROCS 设置后，发现 Pod 容器中的线程数量超过 36，集群中的线程总数也远超过预期。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">resources</span><span class="p">:</span><span class="w">
</span><span class="w">	</span><span class="nt">limits</span><span class="p">:</span><span class="w">
</span><span class="w">		</span><span class="nt">cpu</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;1&#34;</span><span class="w">
</span><span class="w">		</span><span class="nt">memory</span><span class="p">:</span><span class="w"> </span><span class="l">6Gi</span><span class="w">
</span><span class="w">	</span><span class="nt">requests</span><span class="p">:</span><span class="w">
</span><span class="w">		</span><span class="nt">cpu</span><span class="p">:</span><span class="w"> </span><span class="l">500m</span><span class="w">
</span><span class="w">		</span><span class="nt">memory</span><span class="p">:</span><span class="w"> </span><span class="l">1Gi</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>小结下，在 Docker-container 和 Kubernetes 集群中，存在 GOMAXPROCS 会错误识别容器 cpu 核心数的问题。此外，在 Kubernetes 集群中，为每个应用 Pod 分配的 CPU 及 CPU limits 不一定相同，所以通过配置指定 GOMAXPROCS 线程数来匹配 CPU 核心个数的方法，不太靠谱，同时这种 Fixed 的方式也与 Kubernetes 的（自动）扩缩容理念不符。</p>
<h2 id="解决">解决<a hidden class="anchor" aria-hidden="true" href="#解决">#</a></h2>
<p>让我们回到 GOMAXPROCS 的问题，一般在部署容器应用时，通常会对 CPU 资源做限制，例如上面 yaml 文件的，上限是 2 个核。而实际应用的 pod 中，通过 lscpu 命令 ，我们仍然能看到宿主机的所有 CPU 核心，如下面是笔者的一个 Kubernetes 集群中的 Pod 信息：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210510113014.png" alt=""  />
</p>
<p>这会导致 Golang 服务默认会拿宿主机的 CPU 核心数来调用 runtime.GOMAXPROCS()，导致 P 数量远远大于可用的 CPU 核心，引起频繁上下文切换，影响高负载情况下的服务性能。而 Uber-Automaxprocs 这个库 能够正确识别容器允许使用的核心数，合理的设置 processor 数目，避免高并发下的切换问题。</p>
<p>它的使用方式也是非常简单：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">_</span> <span class="s">&#34;go.uber.org/automaxprocs&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Your application logic here
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="automaxprocs">automaxprocs<a hidden class="anchor" aria-hidden="true" href="#automaxprocs">#</a></h2>
<p>我们知道，docker使用cgroup来限制容器CPU使用, 使用该容器配置的cpu.cfsquotaus/cpu.cfsperiodus即可获得CPU配额. 所以关键是找到容器的这两个值.</p>
<h3 id="init">init<a hidden class="anchor" aria-hidden="true" href="#init">#</a></h3>
<p>通过 Readme.md 中的 import 方式，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">_</span> <span class="s">&#34;go.uber.org/automaxprocs&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>大概可以猜到，该包的 init 方法 是 package 级别的。导入即生效。</p>
<p>init 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 入口，核心方法
</span><span class="c1"></span>	<span class="nx">maxprocs</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">maxprocs</span><span class="p">.</span><span class="nf">Logger</span><span class="p">(</span><span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="maxprocsset">maxprocs.Set()<a hidden class="anchor" aria-hidden="true" href="#maxprocsset">#</a></h3>
<p>核心函数就是 maxpROCs.Set()；这个函数会从当前的 cgroups 里获取设置的 CPU quota，然后转换为合适的 GOMAXPROCS。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Set</span><span class="p">(</span><span class="nx">opts</span> <span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="p">(</span><span class="kd">func</span><span class="p">(),</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">cfg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">config</span><span class="p">{</span>
		<span class="nx">procs</span><span class="p">:</span>         <span class="nx">iruntime</span><span class="p">.</span><span class="nx">CPUQuotaToGOMAXPROCS</span><span class="p">,</span>
		<span class="nx">minGOMAXPROCS</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">o</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
		<span class="nx">o</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="nx">cfg</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">undoNoop</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">cfg</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s">&#34;maxprocs: No GOMAXPROCS change to reset&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Honor the GOMAXPROCS environment variable if present. Otherwise, amend
</span><span class="c1"></span>	<span class="c1">// `runtime.GOMAXPROCS()` with the current process&#39; CPU quota if the OS is
</span><span class="c1"></span>	<span class="c1">// Linux, and guarantee a minimum value of 1. The minimum guaranteed value
</span><span class="c1"></span>	<span class="c1">// can be overriden using `maxprocs.Min()`.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">max</span><span class="p">,</span> <span class="nx">exists</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">LookupEnv</span><span class="p">(</span><span class="nx">_maxProcsKey</span><span class="p">);</span> <span class="nx">exists</span> <span class="p">{</span>
		<span class="nx">cfg</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s">&#34;maxprocs: Honoring GOMAXPROCS=%q as set in environment&#34;</span><span class="p">,</span> <span class="nx">max</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">undoNoop</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="c1">// 核心函数，调用 iruntime.CPUQuotaToGOMAXPROCS 得到最终的 maxProcs
</span><span class="c1"></span>	<span class="nx">maxProcs</span><span class="p">,</span> <span class="nx">status</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cfg</span><span class="p">.</span><span class="nf">procs</span><span class="p">(</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">minGOMAXPROCS</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">undoNoop</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">status</span> <span class="o">==</span> <span class="nx">iruntime</span><span class="p">.</span><span class="nx">CPUQuotaUndefined</span> <span class="p">{</span>
		<span class="nx">cfg</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s">&#34;maxprocs: Leaving GOMAXPROCS=%v: CPU quota undefined&#34;</span><span class="p">,</span> <span class="nf">currentMaxProcs</span><span class="p">())</span>
		<span class="k">return</span> <span class="nx">undoNoop</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="nx">prev</span> <span class="o">:=</span> <span class="nf">currentMaxProcs</span><span class="p">()</span>
	<span class="nx">undo</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">cfg</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s">&#34;maxprocs: Resetting GOMAXPROCS to %v&#34;</span><span class="p">,</span> <span class="nx">prev</span><span class="p">)</span>
		<span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="nx">prev</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="nx">status</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">iruntime</span><span class="p">.</span><span class="nx">CPUQuotaMinUsed</span><span class="p">:</span>
		<span class="nx">cfg</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s">&#34;maxprocs: Updating GOMAXPROCS=%v: using minimum allowed GOMAXPROCS&#34;</span><span class="p">,</span> <span class="nx">maxProcs</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">iruntime</span><span class="p">.</span><span class="nx">CPUQuotaUsed</span><span class="p">:</span>
		<span class="nx">cfg</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s">&#34;maxprocs: Updating GOMAXPROCS=%v: determined from CPU quota&#34;</span><span class="p">,</span> <span class="nx">maxProcs</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 调用系统的 runtime 完成功能
</span><span class="c1"></span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="nx">maxProcs</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">undo</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看出主要的工作都在 iruntime.CPUQuotaToGOMAXPROCS() 里完成。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// CPUQuotaToGOMAXPROCS converts the CPU quota applied to the calling process
</span><span class="c1">// to a valid GOMAXPROCS value.
</span><span class="c1">// minValue 避免外部 cpu quota 设置的过小。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">CPUQuotaToGOMAXPROCS</span><span class="p">(</span><span class="nx">minValue</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="nx">CPUQuotaStatus</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">cgroups</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cg</span><span class="p">.</span><span class="nf">NewCGroupsForCurrentProcess</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">CPUQuotaUndefined</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">quota</span><span class="p">,</span> <span class="nx">defined</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cgroups</span><span class="p">.</span><span class="nf">CPUQuota</span><span class="p">()</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">defined</span> <span class="o">||</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">CPUQuotaUndefined</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">maxProcs</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="nx">quota</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">minValue</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">maxProcs</span> <span class="p">&lt;</span> <span class="nx">minValue</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">minValue</span><span class="p">,</span> <span class="nx">CPUQuotaMinUsed</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">maxProcs</span><span class="p">,</span> <span class="nx">CPUQuotaUsed</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NewCGroupsForCurrentProcess returns a new *CGroups instance for the current
</span><span class="c1">// process.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewCGroupsForCurrentProcess</span><span class="p">()</span> <span class="p">(</span><span class="nx">CGroups</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">NewCGroups</span><span class="p">(</span><span class="nx">_procPathMountInfo</span><span class="p">,</span> <span class="nx">_procPathCGroup</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NewCGroups returns a new *CGroups from given `mountinfo` and `cgroup` files
</span><span class="c1">// under for some process under `/proc` file system (see also proc(5) for more
</span><span class="c1">// information).
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewCGroups</span><span class="p">(</span><span class="nx">procPathMountInfo</span><span class="p">,</span> <span class="nx">procPathCGroup</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">CGroups</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">cgroupSubsystems</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">parseCGroupSubsystems</span><span class="p">(</span><span class="nx">procPathCGroup</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">cgroups</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">CGroups</span><span class="p">)</span>
	<span class="nx">newMountPoint</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">MountPoint</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">FSType</span> <span class="o">!=</span> <span class="nx">_cgroupFSType</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">opt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">SuperOptions</span> <span class="p">{</span>
			<span class="nx">subsys</span><span class="p">,</span> <span class="nx">exists</span> <span class="o">:=</span> <span class="nx">cgroupSubsystems</span><span class="p">[</span><span class="nx">opt</span><span class="p">]</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">exists</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>

			<span class="nx">cgroupPath</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">mp</span><span class="p">.</span><span class="nf">Translate</span><span class="p">(</span><span class="nx">subsys</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">err</span>
			<span class="p">}</span>
			<span class="nx">cgroups</span><span class="p">[</span><span class="nx">opt</span><span class="p">]</span> <span class="p">=</span> <span class="nf">NewCGroup</span><span class="p">(</span><span class="nx">cgroupPath</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">parseMountInfo</span><span class="p">(</span><span class="nx">procPathMountInfo</span><span class="p">,</span> <span class="nx">newMountPoint</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">cgroups</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="parsecgroupsubsystems">parseCGroupSubsystems<a hidden class="anchor" aria-hidden="true" href="#parsecgroupsubsystems">#</a></h3>
<p>核心函数之一的 <code>parseCGroupSubsystems()</code> 可以通过解析 <code>/pROC/$pid/cgroup</code> 文件，返回这个进程的 cgroup subsystem table，对应的数据结构是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// CGroupSubsys represents the data structure for entities in
</span><span class="c1">// `/proc/$PID/cgroup`. See also proc(5) for more information.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">CGroupSubsys</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ID</span>         <span class="kt">int</span>
	<span class="nx">Subsystems</span> <span class="p">[]</span><span class="kt">string</span>
	<span class="nx">Name</span>       <span class="kt">string</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// parseCGroupSubsystems parses procPathCGroup (usually at `/proc/$PID/cgroup`)
</span><span class="c1">// and returns a new map[string]*CGroupSubsys.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">parseCGroupSubsystems</span><span class="p">(</span><span class="nx">procPathCGroup</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">CGroupSubsys</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">cgroupFile</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">procPathCGroup</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">cgroupFile</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="nx">scanner</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewScanner</span><span class="p">(</span><span class="nx">cgroupFile</span><span class="p">)</span>
	<span class="nx">subsystems</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">CGroupSubsys</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">scanner</span><span class="p">.</span><span class="nf">Scan</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">//解析文本
</span><span class="c1"></span>		<span class="nx">cgroup</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">NewCGroupSubsysFromLine</span><span class="p">(</span><span class="nx">scanner</span><span class="p">.</span><span class="nf">Text</span><span class="p">())</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">subsys</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">cgroup</span><span class="p">.</span><span class="nx">Subsystems</span> <span class="p">{</span>
			<span class="nx">subsystems</span><span class="p">[</span><span class="nx">subsys</span><span class="p">]</span> <span class="p">=</span> <span class="nx">cgroup</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">scanner</span><span class="p">.</span><span class="nf">Err</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">subsystems</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里看一下 /pROC/$pid/cgroup 的样子</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210510125824.png" alt=""  />
</p>
<p>每行都是一条记录，记录的每个 field 之间用 : 分割，从左至右分别是：</p>
<ul>
<li>id</li>
<li>subsystems，多个 subsystem 之间用 , 分隔</li>
<li>pathname</li>
</ul>
<p>这里的目标是包含 cpu 这个 subsystem 的这条记录；其他的记录其实无关紧要。</p>
<p>同时注意一下 pathname 这个字段，代表进程所属的 cgroup hierarchy 的路径，并且一个相对于 cgroup hierarchy 的 mount point 的一个相对路径。</p>
<p>这里能看到一条记录可能有多个 subsystem，所以前面的 table 最后会出现多个 subsystem key 指向的其实是同一个 CGroupSubsys 实例。</p>
<h3 id="parsemountinfo">parseMountInfo<a hidden class="anchor" aria-hidden="true" href="#parsemountinfo">#</a></h3>
<p>类似的，核心函数 parseMountInfo() 会打开进程的 mountinfo 文件，然后将每一行记录解析成对应的 MountInfo 结构</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// MountPoint is the data structure for the mount points in
</span><span class="c1">// `/proc/$PID/mountinfo`. See also proc(5) for more information.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">MountPoint</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">MountID</span>        <span class="kt">int</span>
	<span class="nx">ParentID</span>       <span class="kt">int</span>
	<span class="nx">DeviceID</span>       <span class="kt">string</span>
	<span class="nx">Root</span>           <span class="kt">string</span>
	<span class="nx">MountPoint</span>     <span class="kt">string</span>
	<span class="nx">Options</span>        <span class="p">[]</span><span class="kt">string</span>
	<span class="nx">OptionalFields</span> <span class="p">[]</span><span class="kt">string</span>
	<span class="nx">FSType</span>         <span class="kt">string</span>
	<span class="nx">MountSource</span>    <span class="kt">string</span>
	<span class="nx">SuperOptions</span>   <span class="p">[]</span><span class="kt">string</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// parseMountInfo parses procPathMountInfo (usually at `/proc/$PID/mountinfo`)
</span><span class="c1">// and yields parsed *MountPoint into newMountPoint.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">parseMountInfo</span><span class="p">(</span><span class="nx">procPathMountInfo</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">newMountPoint</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">MountPoint</span><span class="p">)</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">mountInfoFile</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">procPathMountInfo</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">mountInfoFile</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="nx">scanner</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewScanner</span><span class="p">(</span><span class="nx">mountInfoFile</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">scanner</span><span class="p">.</span><span class="nf">Scan</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">mountPoint</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">NewMountPointFromLine</span><span class="p">(</span><span class="nx">scanner</span><span class="p">.</span><span class="nf">Text</span><span class="p">())</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">newMountPoint</span><span class="p">(</span><span class="nx">mountPoint</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">scanner</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>看一下一个示例 mountinfo 文件内容</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210510130036.png" alt=""  />
</p>
<p>每条记录的字段用空格分隔，字段 - 表示后面都是 options</p>
<p>共有三个字段需要我们关心：</p>
<ul>
<li>索引为3的字段；组成当前挂载点根路径的文件系统的路径，对应 MountInfo.Root</li>
<li>索引为4的字段；当前挂载点相对于进程根目录的路径，对应 MountInfo.MountPoint</li>
<li>- 字段之后的第一个字段，代表 filesystem type，对应 MountInfo.FsType；我们其实只需要 cgroup。</li>
<li>上面 fstype 字段之后的第二个字段，是 subsystems，subsystem之间用,分割；这里我们其实需要的是包含 cpu 的这个 subsystem</li>
</ul>
<h3 id="找到目标-cgroup-path">找到目标 cgroup path<a hidden class="anchor" aria-hidden="true" href="#找到目标-cgroup-path">#</a></h3>
<p>有了前两步之后，就可以找到进程对应的 cpu 这个 subsystem 的 CGroup path。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// CGroup represents the data structure for a Linux control group.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">CGroup</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">path</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这部分操作在 lambda 函数 newMountPoint() 中。</p>
<p>总结起来就是：</p>
<ol>
<li>在 mountinfo 文件中找到 fstype = cgroup &amp;&amp; subsystems.contains(cpu) 的记录，分离出 root 和 mount-point。</li>
<li>在 cgroup 文件中找到 subsystems.contains(cpu) 的记录，分理出 pathname</li>
<li>cgroupPath = Join(mount_point, relative(root, pathname))
relative() 函数返回 pathname 相对于 root 的相对路径</li>
</ol>
<p>实践中发现 root 和 pathname 基本一致，这样返回的相对路径就是 .；最后组合的最终路径都是 /sys/fs/cgroup/cpu</p>
<p>不过考虑到不同发行版甚至不同版本的 docker / k8s 行为可能存在不一致，所以最具有移植性还是上面的做法。</p>
<h3 id="计算-cpu-配额">计算 cpu 配额<a hidden class="anchor" aria-hidden="true" href="#计算-cpu-配额">#</a></h3>
<p>有了前面的目录路径之后，该目录下的：</p>
<ul>
<li>cfs.cpu_period_us 文件记录了调度周期，单位是 us；默认值一般是 100'000，即 100 ms</li>
<li>cfs.cpu_quota_us 记录了每个调度周期进程允许使用 cpu 的量，单位也是 us。值为 -1 表示无限制；对于 4C 的容器，这个值一般是 400'000</li>
</ul>
<p>这两个值限制的是进程使用 cpu 的时间。
上述设置下表示：每 100ms 的调度周期内，该进程可以使用 400ms 的 cpu 时间，所以看起来的效果是可以使用4个CPU核心</p>
<p>更详细的内容请参考 Linux kernel 的文档：CFS Bandwidth Control</p>
<p>quota 和 period 的比值就是 docker 为容器设置的 CPU 核数配置。
这个值也是 automaxpROCs 为 runtime.GOMAXPROCS() 设置的值。
这部分逻辑对应库函数：CGoups.CPUQuota()</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// CPUQuota returns the CPU quota applied with the CPU cgroup controller.
</span><span class="c1">// It is a result of `cpu.cfs_quota_us / cpu.cfs_period_us`. If the value of
</span><span class="c1">// `cpu.cfs_quota_us` was not set (-1), the method returns `(-1, nil)`.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cg</span> <span class="nx">CGroups</span><span class="p">)</span> <span class="nf">CPUQuota</span><span class="p">()</span> <span class="p">(</span><span class="kt">float64</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">cpuCGroup</span><span class="p">,</span> <span class="nx">exists</span> <span class="o">:=</span> <span class="nx">cg</span><span class="p">[</span><span class="nx">_cgroupSubsysCPU</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">exists</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="nx">cfsQuotaUs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cpuCGroup</span><span class="p">.</span><span class="nf">readInt</span><span class="p">(</span><span class="nx">_cgroupCPUCFSQuotaUsParam</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">defined</span> <span class="o">:=</span> <span class="nx">cfsQuotaUs</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="p">!</span><span class="nx">defined</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">defined</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">cfsPeriodUs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cpuCGroup</span><span class="p">.</span><span class="nf">readInt</span><span class="p">(</span><span class="nx">_cgroupCPUCFSPeriodUsParam</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">cfsQuotaUs</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">cfsPeriodUs</span><span class="p">),</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h3 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h3>
<p>流程图:</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210510130630.png" alt=""  />
</p>
<p>容器技术（docker）通过 Linux kernel 提供的 cgroups 机制来实现资源隔离和限制，但是这种限制有时候会出现反直觉的结果。</p>
<p>上面的分析过程看，虽然这个库做的事情比较简单，但是要注意的是，我们是通过逆向工程（由果推因）来分析的这个问题。</p>
<p>如果需要从正面解决（执因索果），那么就需要对 1）容器实现细节 2）linux 内核中 cgroups 的实现细节 有很深的了解。</p>
<p>这恐怕也是过了一年多才找到解决方案，而且最后还是直接使用别人的solution的原因。</p>
<h2 id="automaxprocs的限制">automaxprocs的限制<a hidden class="anchor" aria-hidden="true" href="#automaxprocs的限制">#</a></h2>
<p>事实上，automaxpROCs 仅针对于使用 CFS 调度策略的实例。</p>
<p>CFS 调度测类只限制进程的运行配额，不设置 processor affinity。所以在 4C 的限制下，理论上 G-P-M 调度模型下的 M 可以运行在任意物理核心上</p>
<p>查看 <code>/sys/fs/cgroup/cpuset/cpuset.cpus</code> 这个文件可以发现没有做任何物理核心上的限制。</p>
<p>docker 创建容器时可以使用 &ndash;cpus=x 来实现。</p>
<p>对于只使用 cpuset 策略的容器来说，其实没必要使用这个库。</p>
<p>因为 cpuset 直接设置了容器的 processor affinity，然后神奇的是，golang 的 runtime.NumCores() 获取的核心数是考虑过 processor affinity 的。</p>
<h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<p><a href="https://pandaychen.github.io/2020/02/28/GOMAXPROCS-POT/">GOMAXPROCS 的坑</a></p>
<p><a href="https://pandaychen.github.io/2020/02/29/AUTOMAXPROCS-ANALYSIS/">Uber-Automaxprocs 分析</a></p>
<p><a href="https://www.bilibili.com/read/cv8081272">uber automaxprocs 源码分析</a></p>
<p><a href="http://xiaorui.cc/archives/6334">golang gomaxprocs调高引起调度性能损耗</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/k8s/">k8s</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
