<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>shell脚本中的函数使用 | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="基本的脚本函数 函数是一个脚本代码块，你可以为其命名并在代码中任何位置重 用。要在脚本中使用该代码块时，只要使用所起的函数名就行了(这个过程称为">
<meta name="author" content="">
<link rel="canonical" href="/post/shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="shell脚本中的函数使用" />
<meta property="og:description" content="基本的脚本函数 函数是一个脚本代码块，你可以为其命名并在代码中任何位置重 用。要在脚本中使用该代码块时，只要使用所起的函数名就行了(这个过程称为" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-08-11T10:26:30&#43;00:00" />
<meta property="article:modified_time" content="2017-08-11T10:26:30&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="shell脚本中的函数使用"/>
<meta name="twitter:description" content="基本的脚本函数 函数是一个脚本代码块，你可以为其命名并在代码中任何位置重 用。要在脚本中使用该代码块时，只要使用所起的函数名就行了(这个过程称为"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "shell脚本中的函数使用",
      "item": "/post/shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "shell脚本中的函数使用",
  "name": "shell脚本中的函数使用",
  "description": "基本的脚本函数 函数是一个脚本代码块，你可以为其命名并在代码中任何位置重 用。要在脚本中使用该代码块时，只要使用所起的函数名就行了(这个过程称为",
  "keywords": [
    
  ],
  "articleBody": "基本的脚本函数 函数是一个脚本代码块，你可以为其命名并在代码中任何位置重 用。要在脚本中使用该代码块时，只要使用所起的函数名就行了(这个过程称为调用函数)。\n创建函数 有两种格式可以用来在bash shell脚本中创建函数。第一种格式采用关键字function，后跟 分配给该代码块的函数名。\nfunction name { commands }  name属性定义了赋予函数的唯一名称。脚本中定义的每个函数都必须有一个唯一的名称。\ncommands是构成函数的一条或多条bash shell命令。在调用该函数时，bash shell会按命令在 函数中出现的顺序依次执行，就像在普通脚本中一样。\n在bash shell脚本中定义函数的第二种格式更接近于其他编程语言中定义函数的方式。\nname() { commands }  函数名后的空括号表明正在定义的是一个函数。这种格式的命名规则和之前定义shell脚本函数的格式一样。\n使用函数 要在脚本中使用函数，只需要像其他shell命令一样，在行中指定函数名就行了。\nfunction func1 { echo \"This is an example of a function\" } count=1 while [ $count -le 5 ] do func1 count=$[ $count + 1 ] done  记住，函数名必须是唯一的，否则也会有问题。如果你重定义了函数， 新定义会覆盖原来函数的定义，这一切不会产生任何错误消息。\n返回值 bash shell会把函数当作一个小型脚本，运行结束时会返回一个退出状态码\n默认退出状态码 默认情况下,函数的退出状态码是函数中最后一条命令返回的退出状态码.但你无法知道函数中其他命令中是否成功运行。在函数执行结束后,可以用标准变量$?来确定函数的退出状态码.\n使用return命令 bash shell使用return命令来退出函数并返回特定的退出状态码。return命令允许指定一个整数值来定义函数的退出状态码，从而提供了一种简单的途径来编程设定函数退出状态码。\nfunction dbl { read -p \"Enter a value: \" value echo \"doubling the value\" return $[ $value * 2 ] dbl echo \"The new value is $?\" $  dbl函数会将$value变量中用户输入的值翻倍，然后用return命令返回结果。脚本用$?变 量显示了该值。\n但当用这种方法从函数中返回值时，要小心了。记住下面两条技巧来避免问题:\n 记住，函数一结束就取返回值; 记住，退出状态码必须是0~255。  如果在用$?变量提取函数返回值之前执行了其他命令，函数的返回值就会丢失。记住，$? 变量会返回执行的最后一条命令的退出状态码。\n要返回较大的整数值或者字符串值的话，你就不能用这种返回值的方法了。\n使用函数输出 正如可以将命令的输出保存到shell变量中一样，你也可以对函数的输出采用同样的处理办法。可以用这种技术来获得任何类型的函数输出，并将其保存到变量中:\nfunction dbl { read -p \"Enter a value: \" value echo $[ $value * 2 ] result='dbl'  这个命令会将dbl函数的输出赋给$result变量。新函数会用echo语句来显示计算的结果。该脚本会获取dbl函数的输出，而不是查看退出状 态码。\nread命令输出了一条简短的消息来向用户询问输入值。bash shell脚本非常聪明，并不将其作为STDOUT 输出的一部分，并且忽略掉它。如果你用echo语句生成这条消息来向用户查询，那么它会与输 出值一起被读进shell变量中。\n在函数中使用变量 向函数传递参数 bash shell会将函数当作小型脚本来对待。这意味着你可以像普通脚本那样向函数传递参数.函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。\n例如，函数名会在$0 变量中定义，函数命令行上的任何参数都会通过$1、$2等定义。也可以用特殊变量$#来判断传 给函数的参数数目。\n在脚本中指定函数时，必须将参数和函数放在同一行，像这样:\nfunc1 $value1 10  然后函数可以用参数环境变量来获得参数值。**函数无法直接获取脚本在命令行中的参数值。**这里有个使用此方法向函数传值的例子。\nfunction addem { if [ $# -eq 0 ] || [ $# -gt 2 ] then echo -1 elif [ $# -eq 1 ] then echo $[ $1 + $1 ] else echo $[ $1 + $2 ] fi } value=$(addem 10 15)  在函数中处理变量 给shell脚本程序员带来麻烦的原因之一就是变量的作用域。作用域是变量可见的区域。函数 中定义的变量与普通变量的作用域不同。也就是说，对脚本的其他部分而言，它们是隐藏的。\n函数使用两种类型的变量:\n 全局变量 局部变量  1. 全局变量 全局变量是在shell脚本中任何地方都有效的变量。如果你在脚本的主体部分定义了一个全局 变量，那么可以在函数内读取它的值。类似地，如果你在函数内定义了一个全局变量，可以在脚 本的主体部分读取它的值。\n默认情况下，你在脚本中定义的任何变量都是全局变量。在函数外定义的变量可在函数内正常访问。\n$ cat test8 #!/bin/bash # using a global variable to pass a value function dbl { value=$[ $value * 2 ] } read -p \"Enter a value: \" value dbl echo \"The new value is: $value\" $ $ ./test8 Enter a value: 450 The new value is: 900 $  $value变量在函数外定义并被赋值。当dbl函数被调用时，该变量及其值在函数中都依然有 效。如果变量在函数内被赋予了新值，那么在脚本中引用该变量时，新值也依然有效。\n2. 局部变量 无需在函数中使用全局变量，函数内部使用的任何变量都可以被声明成局部变量。要实现这 一点，只要在变量声明的前面加上local关键字就可以了。\nlocal temp  local关键字保证了变量只局限在该函数中。如果脚本中在该函数之外有同样名字的变量， 那么shell将会保持这两个变量的值是分离的。现在你就能很轻松地将函数变量和脚本变量隔离开 了，只共享需要共享的变量。\n数组变量和函数 向函数传数组参数 将数组变量当作单个参数传递的话，它不会起作用。\n$ cat badtest3 #!/bin/bash # trying to pass an array variable function testit { echo \"The parameters are: $@\" thisarray=$1 echo \"The received array is $\t{thisarray[*]}\" } myarray=(1 2 3 4 5) echo \"The original array is: ${myarray[*]}\" testit $myarray  如果你试图将该数组变量作为函数参数，函数只会取数组变量的第一个值。\n要解决这个问题，你必须将该数组变量的值分解成单个的值，然后将这些值作为函数参数使 用。在函数内部，可以将所有的参数重新组合成一个新的变量。\ntestit ${myarray[*]}  用$myarray变量来保存所有的数组元素，然后将它们都放在函数的命令行上。该函 数随后从命令行参数中重建数组变量。在函数内部，数组仍然可以像其他数组一样使用。\n从函数返回数组 从函数里向shell脚本传回数组变量也用类似的方法。函数用echo语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中。\n#!/bin/bash # returning an array value function arraydblr { local origarray local newarray local elements local i origarray=($(echo \"$@\")) newarray=($(echo \"$@\")) elements=$[ $# - 1 ] for (( i = 0; i  该脚本用$arg1变量将数组值传给arraydblr函数。\narraydblr函数将该数组重组到新的数 组变量中，生成该输出数组变量的一个副本。然后对数据元素进行遍历，将每个元素值翻倍并 将结果存入函数中该数组变量的副本。\n函数递归 局部函数变量的一个特性是自成体系。除了从脚本命令行处获得的变量，自成体系的函数不 需要使用任何外部资源。\n这个特性使得函数可以递归地调用，也就是说，函数可以调用自己来得到结果。通常递归函 数都有一个最终可以迭代到的基准值。许多高级数学算法用递归对复杂的方程进行逐级规约，直到基准值定义的那级。\n递归算法的经典例子是计算阶乘。一个数的阶乘是该数之前的所有数乘以该数的值。\nfunction factorial { if [ $1 -eq 1 ] then echo 1 else local temp=$[ $1 - 1 ] local result='factorial $temp' echo $[ $result * $1 ] fi }  创建库 使用函数可以在脚本中省去一些输入工作，这一点是显而易见的。但如果你碰巧要在多个脚 本中使用同一段代码呢?显然，为了使用一次而在每个脚本中都定义同样的函数太过麻烦。\n有个方法能解决这个问题!bash shell允许创建函数库文件，然后在多个脚本中引用该库文件。\n这个过程的第一步是创建一个包含脚本中所需函数的公用库文件。这里有个叫作myfuncs的 库文件.\n下一步是在用到这些函数的脚本文件中包含myfuncs库文件。从这里开始，事情就变复杂了。\n问题出在shell函数的作用域上。和环境变量一样，shell函数仅在定义它的shell会话内有效。 如果你在shell命令行界面的提示符下运行myfuncs shell脚本，shell会创建一个新的shell并在其中 运行这个脚本。它会为那个新shell定义这三个函数，但当你运行另外一个要用到这些函数的脚本 时，它们是无法使用的。\n这同样适用于脚本。如果你尝试像普通脚本文件那样运行库文件，函数并不会出现在脚本中。\n$ cat badtest4 #!/bin/bash # using a library file the wrong way ./myfuncs result=$(addem 10 15) echo \"The result is $result\" $ $ ./badtest4 ./badtest4: addem: command not found The result is $  使用函数库的关键在于source命令。source命令会在当前shell上下文中执行命令，而不是 创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库 中的函数了。\nsource命令有个快捷的别名，称作点操作符(dot operator)。要在shell脚本中运行myfuncs 库文件，只需添加下面这行:\n. ./myfuncs  这个例子假定myfuncs库文件和shell脚本位于同一目录。如果不是，你需要使用相应路径访问该文件。\n在命令行上使用函数 和在shell脚本中将脚本函数当命令使用一样，在命令行界面中你也可以这样做。这个功能很不错，因为一旦在shell中定义了函数，你就可以在整个系统中使用它了，无需担心脚本是不是在PATH环境变量里。重点在于让shell能够识别这些函数。\n在命令行上创建函数 因为shell会解释用户输入的命令，所以可以在命令行上直接定义一个函数。有两种方法。\n一种方法是采用单行方式定义函数。\n$functiondivem{echo$[$1/$2]; } $ divem 100 5 20 $  当在命令行上定义函数时，你必须记得在每个命令后面加个分号，这样shell就能知道在哪里 是命令的起止了。\n另一种方法是采用多行方式来定义函数。在定义时，bash shell会使用次提示符来提示输入更 多命令。用这种方法，你不用在每条命令的末尾放一个分号，只要按下回车键就行。\n$ function multem {  echo $[ $1 * $2 ] } $ multem 2 5 10 $  在函数的尾部使用花括号，shell就会知道你已经完成了函数的定义。\n在命令行上创建函数时要特别小心。如果你给函数起了个跟内建命令或另一个命令相同的名字，函数将会覆盖原来的命令。\n在.bashrc文件中定义函数 在命令行上直接定义shell函数的明显缺点是退出shell时，函数就消失了。对于复杂的函数来 说，这可是个麻烦事。\n一个非常简单的方法是将函数定义在一个特定的位置，这个位置在每次启动一个新shell的时 候，都会由shell重新载入。\n最佳地点就是.bashrc文件。bash shell在每次启动时都会在主目录下查找这个文件，不管是交互式shell还是从现有shell中启动的新shell。\n1. 直接定义函数 可以直接在主目录下的.bashrc文件中定义函数。把你写的函数放在文件末尾就行了。\n该函数会在下次启动新bash shell时生效。随后你就能在系统上任意地方使用这个函数了。\n2. 读取函数文件 只要是在shell脚本中，都可以用source命令(或者它的别名点操作符)将库文件中的函数添加到你的.bashrc脚本中。\n$ cat .bashrc # .bashrc # Source global definitions if [ -r /etc/bashrc ]; then . /etc/bashrc fi . /home/rich/libraries/myfuncs $  要确保库文件的路径名正确，以便bash shell能够找到该文件。下次启动shell时，库中的所有 函数都可在命令行界面下使用了。\n更好的是，shell还会将定义好的函数传给子shell进程，这样一来，这些函数就自动能够用于该shell会话中的任何shell脚本了。甚至都不用对库文件使用source，这些函数就可以完美地运行在shell脚本中。\n",
  "wordCount" : "4493",
  "inLanguage": "zh-cn",
  "datePublished": "2017-08-11T10:26:30Z",
  "dateModified": "2017-08-11T10:26:30Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      shell脚本中的函数使用
    </h1>
    <div class="post-meta">August 11, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="基本的脚本函数">基本的脚本函数<a hidden class="anchor" aria-hidden="true" href="#基本的脚本函数">#</a></h1>
<p>函数是一个脚本代码块，你可以为其命名并在代码中任何位置重 用。要在脚本中使用该代码块时，只要使用所起的函数名就行了(这个过程称为调用函数)。</p>
<h2 id="创建函数">创建函数<a hidden class="anchor" aria-hidden="true" href="#创建函数">#</a></h2>
<p>有两种格式可以用来在bash shell脚本中创建函数。第一种格式采用关键字function，后跟
分配给该代码块的函数名。</p>
<pre><code>function name { 
	commands
}
</code></pre>
<p>name属性定义了赋予函数的唯一名称。脚本中定义的每个函数都必须有一个唯一的名称。</p>
<p>commands是构成函数的一条或多条bash shell命令。在调用该函数时，bash shell会按命令在 函数中出现的顺序依次执行，就像在普通脚本中一样。</p>
<p>在bash shell脚本中定义函数的第二种格式更接近于其他编程语言中定义函数的方式。</p>
<pre><code>name() 
{ 
	commands 
}
</code></pre>
<p>函数名后的空括号表明正在定义的是一个函数。这种格式的命名规则和之前定义shell脚本函数的格式一样。</p>
<h2 id="使用函数">使用函数<a hidden class="anchor" aria-hidden="true" href="#使用函数">#</a></h2>
<p>要在脚本中使用函数，只需要像其他shell命令一样，在行中指定函数名就行了。</p>
<pre><code>function func1 {
       echo &quot;This is an example of a 	function&quot;
}
    count=1
    while [ $count -le 5 ]
    do
        func1
       count=$[ $count + 1 ]
    done
</code></pre>
<p>记住，函数名必须是唯一的，否则也会有问题。如果你重定义了函数， 新定义会覆盖原来函数的定义，这一切不会产生任何错误消息。</p>
<h1 id="返回值">返回值<a hidden class="anchor" aria-hidden="true" href="#返回值">#</a></h1>
<p>bash shell会把函数当作一个小型脚本，运行结束时会返回一个退出状态码</p>
<h2 id="默认退出状态码">默认退出状态码<a hidden class="anchor" aria-hidden="true" href="#默认退出状态码">#</a></h2>
<p>默认情况下,函数的退出状态码是函数中最后一条命令返回的退出状态码.但你无法知道函数中其他命令中是否成功运行。在函数执行结束后,可以用标准变量$?来确定函数的退出状态码.</p>
<h2 id="使用return命令">使用return命令<a hidden class="anchor" aria-hidden="true" href="#使用return命令">#</a></h2>
<p>bash shell使用return命令来退出函数并返回特定的退出状态码。return命令允许指定一个整数值来定义函数的退出状态码，从而提供了一种简单的途径来编程设定函数退出状态码。</p>
<pre><code>function dbl {
       read -p &quot;Enter a value: &quot; value
       echo &quot;doubling the value&quot;
       return $[ $value * 2 ]
dbl
echo &quot;The new value is $?&quot;
$
</code></pre>
<p>dbl函数会将$value变量中用户输入的值翻倍，然后用return命令返回结果。脚本用$?变 量显示了该值。</p>
<p>但当用这种方法从函数中返回值时，要小心了。记住下面两条技巧来避免问题:</p>
<ol>
<li>记住，函数一结束就取返回值;</li>
<li>记住，退出状态码必须是0~255。</li>
</ol>
<p>如果在用$?变量提取函数返回值之前执行了其他命令，函数的返回值就会丢失。记住，$? 变量会返回执行的最后一条命令的退出状态码。</p>
<p>要返回较大的整数值或者字符串值的话，你就不能用这种返回值的方法了。</p>
<h2 id="使用函数输出">使用函数输出<a hidden class="anchor" aria-hidden="true" href="#使用函数输出">#</a></h2>
<p>正如可以将命令的输出保存到shell变量中一样，你也可以对函数的输出采用同样的处理办法。可以用这种技术来获得任何类型的函数输出，并将其保存到变量中:</p>
<pre><code>function dbl {
   read -p &quot;Enter a value: &quot; value
   echo $[ $value * 2 ]
result='dbl'
</code></pre>
<p>这个命令会将dbl函数的输出赋给$result变量。新函数会用echo语句来显示计算的结果。该脚本会获取dbl函数的输出，而不是查看退出状 态码。</p>
<p>read命令输出了一条简短的消息来向用户询问输入值。bash shell脚本非常聪明，并不将其作为STDOUT 输出的一部分，并且忽略掉它。如果你用echo语句生成这条消息来向用户查询，那么它会与输 出值一起被读进shell变量中。</p>
<h1 id="在函数中使用变量">在函数中使用变量<a hidden class="anchor" aria-hidden="true" href="#在函数中使用变量">#</a></h1>
<h2 id="向函数传递参数">向函数传递参数<a hidden class="anchor" aria-hidden="true" href="#向函数传递参数">#</a></h2>
<p>bash shell会将函数当作小型脚本来对待。这意味着你可以像普通脚本那样向函数传递参数.函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。</p>
<p>例如，函数名会在$0 变量中定义，函数命令行上的任何参数都会通过$1、$2等定义。也可以用特殊变量$#来判断传 给函数的参数数目。</p>
<p>在脚本中指定函数时，必须将参数和函数放在同一行，像这样:</p>
<pre><code>func1 $value1 10
</code></pre>
<p>然后函数可以用参数环境变量来获得参数值。**函数无法直接获取脚本在命令行中的参数值。**这里有个使用此方法向函数传值的例子。</p>
<pre><code>function addem {
       if [ $# -eq 0 ] || [ $# -gt 2 ]
       then
          echo -1
       elif [ $# -eq 1 ]
       then
          echo $[ $1 + $1 ]
       else
          echo $[ $1 + $2 ]
       fi
}
value=$(addem 10 15)
</code></pre>
<h2 id="在函数中处理变量">在函数中处理变量<a hidden class="anchor" aria-hidden="true" href="#在函数中处理变量">#</a></h2>
<p>给shell脚本程序员带来麻烦的原因之一就是变量的作用域。作用域是变量可见的区域。函数 中定义的变量与普通变量的作用域不同。也就是说，对脚本的其他部分而言，它们是隐藏的。</p>
<p>函数使用两种类型的变量:</p>
<ol>
<li>全局变量</li>
<li>局部变量</li>
</ol>
<h3 id="1-全局变量">1. 全局变量<a hidden class="anchor" aria-hidden="true" href="#1-全局变量">#</a></h3>
<p>全局变量是在shell脚本中任何地方都有效的变量。如果你在脚本的主体部分定义了一个全局 变量，那么可以在函数内读取它的值。类似地，如果你在函数内定义了一个全局变量，可以在脚 本的主体部分读取它的值。</p>
<p>默认情况下，你在脚本中定义的任何变量都是全局变量。在函数外定义的变量可在函数内正常访问。</p>
<pre><code>$ cat test8
    #!/bin/bash
    # using a global variable to pass a value
    function dbl {
   value=$[ $value * 2 ]
}
read -p &quot;Enter a value: &quot; value
dbl
echo &quot;The new value is: $value&quot;
$
$ ./test8
Enter a value: 450
The new value is: 900
$
</code></pre>
<p>$value变量在函数外定义并被赋值。当dbl函数被调用时，该变量及其值在函数中都依然有 效。如果变量在函数内被赋予了新值，那么在脚本中引用该变量时，新值也依然有效。</p>
<h3 id="2-局部变量">2. 局部变量<a hidden class="anchor" aria-hidden="true" href="#2-局部变量">#</a></h3>
<p>无需在函数中使用全局变量，函数内部使用的任何变量都可以被声明成局部变量。要实现这 一点，只要在变量声明的前面加上local关键字就可以了。</p>
<pre><code>local temp
</code></pre>
<p>local关键字保证了变量只局限在该函数中。如果脚本中在该函数之外有同样名字的变量， 那么shell将会保持这两个变量的值是分离的。现在你就能很轻松地将函数变量和脚本变量隔离开 了，只共享需要共享的变量。</p>
<h1 id="数组变量和函数">数组变量和函数<a hidden class="anchor" aria-hidden="true" href="#数组变量和函数">#</a></h1>
<h2 id="向函数传数组参数">向函数传数组参数<a hidden class="anchor" aria-hidden="true" href="#向函数传数组参数">#</a></h2>
<p>将数组变量当作单个参数传递的话，它不会起作用。</p>
<pre><code>$ cat badtest3
#!/bin/bash
# trying to pass an array variable
function testit {
   echo &quot;The parameters are: $@&quot;
   thisarray=$1
   echo &quot;The received array is $	{thisarray[*]}&quot;
}
myarray=(1 2 3 4 5)
echo &quot;The original array is: ${myarray[*]}&quot;
testit $myarray
</code></pre>
<p>如果你试图将该数组变量作为函数参数，函数只会取数组变量的第一个值。</p>
<p>要解决这个问题，你必须将该数组变量的值分解成单个的值，然后将这些值作为函数参数使 用。在函数内部，可以将所有的参数重新组合成一个新的变量。</p>
<pre><code>testit ${myarray[*]}
</code></pre>
<p>用$myarray变量来保存所有的数组元素，然后将它们都放在函数的命令行上。该函 数随后从命令行参数中重建数组变量。在函数内部，数组仍然可以像其他数组一样使用。</p>
<h2 id="从函数返回数组">从函数返回数组<a hidden class="anchor" aria-hidden="true" href="#从函数返回数组">#</a></h2>
<p>从函数里向shell脚本传回数组变量也用类似的方法。函数用echo语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中。</p>
<pre><code>#!/bin/bash
# returning an array value
function arraydblr {
   local origarray
   local newarray
   local elements
   local i
   origarray=($(echo &quot;$@&quot;))
   newarray=($(echo &quot;$@&quot;))
   elements=$[ $# - 1 ]
   for (( i = 0; i &lt;= $elements; i++ ))
   {
      newarray[$i]=$[ ${origarray[$i]} * 2 ]
   }
   echo ${newarray[*]}
}
myarray=(1 2 3 4 5)
echo &quot;The original array is: ${myarray[*]}&quot;
arg1=$(echo ${myarray[*]})
result=($(arraydblr $arg1))
echo &quot;The new array is: ${result[*]}&quot;
$
</code></pre>
<p>该脚本用$arg1变量将数组值传给arraydblr函数。</p>
<p>arraydblr函数将该数组重组到新的数 组变量中，生成该输出数组变量的一个副本。然后对数据元素进行遍历，将每个元素值翻倍并 将结果存入函数中该数组变量的副本。</p>
<h1 id="函数递归">函数递归<a hidden class="anchor" aria-hidden="true" href="#函数递归">#</a></h1>
<p>局部函数变量的一个特性是自成体系。除了从脚本命令行处获得的变量，自成体系的函数不 需要使用任何外部资源。</p>
<p>这个特性使得函数可以递归地调用，也就是说，函数可以调用自己来得到结果。通常递归函 数都有一个最终可以迭代到的基准值。许多高级数学算法用递归对复杂的方程进行逐级规约，直到基准值定义的那级。</p>
<p>递归算法的经典例子是计算阶乘。一个数的阶乘是该数之前的所有数乘以该数的值。</p>
<pre><code>function factorial { 
	if [ $1 -eq 1 ]
	then
	echo 1
	else 
      local temp=$[ $1 - 1 ]
      local result='factorial $temp'
      echo $[ $result * $1 ]
  fi 
}
</code></pre>
<h1 id="创建库">创建库<a hidden class="anchor" aria-hidden="true" href="#创建库">#</a></h1>
<p>使用函数可以在脚本中省去一些输入工作，这一点是显而易见的。但如果你碰巧要在多个脚 本中使用同一段代码呢?显然，为了使用一次而在每个脚本中都定义同样的函数太过麻烦。</p>
<p>有个方法能解决这个问题!bash shell允许创建函数库文件，然后在多个脚本中引用该库文件。</p>
<p>这个过程的第一步是创建一个包含脚本中所需函数的公用库文件。这里有个叫作myfuncs的 库文件.</p>
<p>下一步是在用到这些函数的脚本文件中包含myfuncs库文件。从这里开始，事情就变复杂了。</p>
<p>问题出在shell函数的作用域上。和环境变量一样，shell函数仅在定义它的shell会话内有效。 如果你在shell命令行界面的提示符下运行myfuncs shell脚本，shell会创建一个新的shell并在其中 运行这个脚本。它会为那个新shell定义这三个函数，但当你运行另外一个要用到这些函数的脚本 时，它们是无法使用的。</p>
<p>这同样适用于脚本。如果你尝试像普通脚本文件那样运行库文件，函数并不会出现在脚本中。</p>
<pre><code>$ cat badtest4
#!/bin/bash
# using a library file the wrong way
./myfuncs
result=$(addem 10 15)
echo &quot;The result is $result&quot;
$
$ ./badtest4
./badtest4: addem: command not found
The result is
$
</code></pre>
<p>使用函数库的关键在于source命令。source命令会在当前shell上下文中执行命令，而不是 创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库 中的函数了。</p>
<p>source命令有个快捷的别名，称作点操作符(dot operator)。要在shell脚本中运行myfuncs 库文件，只需添加下面这行:</p>
<pre><code>. ./myfuncs
</code></pre>
<p>这个例子假定myfuncs库文件和shell脚本位于同一目录。如果不是，你需要使用相应路径访问该文件。</p>
<h1 id="在命令行上使用函数">在命令行上使用函数<a hidden class="anchor" aria-hidden="true" href="#在命令行上使用函数">#</a></h1>
<p>和在shell脚本中将脚本函数当命令使用一样，在命令行界面中你也可以这样做。这个功能很不错，因为一旦在shell中定义了函数，你就可以在整个系统中使用它了，无需担心脚本是不是在PATH环境变量里。重点在于让shell能够识别这些函数。</p>
<h2 id="在命令行上创建函数">在命令行上创建函数<a hidden class="anchor" aria-hidden="true" href="#在命令行上创建函数">#</a></h2>
<p>因为shell会解释用户输入的命令，所以可以在命令行上直接定义一个函数。有两种方法。</p>
<p>一种方法是采用单行方式定义函数。</p>
<pre><code>$functiondivem{echo$[$1/$2]; } 
$ divem 100 5
20
$
</code></pre>
<p>当在命令行上定义函数时，你必须记得在每个命令后面加个分号，这样shell就能知道在哪里 是命令的起止了。</p>
<p>另一种方法是采用多行方式来定义函数。在定义时，bash shell会使用次提示符来提示输入更 多命令。用这种方法，你不用在每条命令的末尾放一个分号，只要按下回车键就行。</p>
<pre><code>$ function multem { 
&gt; echo $[ $1 * $2 ] 
&gt;}
$ multem 2 5
10 
$
</code></pre>
<p>在函数的尾部使用花括号，shell就会知道你已经完成了函数的定义。</p>
<p>在命令行上创建函数时要特别小心。如果你给函数起了个跟内建命令或另一个命令相同的名字，函数将会覆盖原来的命令。</p>
<h2 id="在bashrc文件中定义函数">在.bashrc文件中定义函数<a hidden class="anchor" aria-hidden="true" href="#在bashrc文件中定义函数">#</a></h2>
<p>在命令行上直接定义shell函数的明显缺点是退出shell时，函数就消失了。对于复杂的函数来 说，这可是个麻烦事。</p>
<p>一个非常简单的方法是将函数定义在一个特定的位置，这个位置在每次启动一个新shell的时 候，都会由shell重新载入。</p>
<p>最佳地点就是.bashrc文件。bash shell在每次启动时都会在主目录下查找这个文件，不管是交互式shell还是从现有shell中启动的新shell。</p>
<h3 id="1-直接定义函数">1. 直接定义函数<a hidden class="anchor" aria-hidden="true" href="#1-直接定义函数">#</a></h3>
<p>可以直接在主目录下的.bashrc文件中定义函数。把你写的函数放在文件末尾就行了。</p>
<p>该函数会在下次启动新bash shell时生效。随后你就能在系统上任意地方使用这个函数了。</p>
<h3 id="2-读取函数文件">2. 读取函数文件<a hidden class="anchor" aria-hidden="true" href="#2-读取函数文件">#</a></h3>
<p>只要是在shell脚本中，都可以用source命令(或者它的别名点操作符)将库文件中的函数添加到你的.bashrc脚本中。</p>
<pre><code>$ cat .bashrc
# .bashrc
# Source global definitions
if [ -r /etc/bashrc ]; then
        . /etc/bashrc
fi
. /home/rich/libraries/myfuncs
$
</code></pre>
<p>要确保库文件的路径名正确，以便bash shell能够找到该文件。下次启动shell时，库中的所有 函数都可在命令行界面下使用了。</p>
<p>更好的是，shell还会将定义好的函数传给子shell进程，这样一来，这些函数就自动能够用于该shell会话中的任何shell脚本了。甚至都不用对库文件使用source，这些函数就可以完美地运行在shell脚本中。</p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
