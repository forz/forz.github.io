<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>如何用Go实现分布式限流 | Forz Blog</title>
<meta name="keywords" content="Go" />
<meta name="description" content="Why Redis &amp;&amp; Lua 分布式限流本质上是一个集群并发问题，Redis &#43; Lua 的方案非常适合此场景： Redis 单线程特性，适合解决分布式集群的并发问题 Redis 本身支持 Lua 脚本执">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%A6%82%E4%BD%95%E7%94%A8go%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="如何用Go实现分布式限流" />
<meta property="og:description" content="Why Redis &amp;&amp; Lua 分布式限流本质上是一个集群并发问题，Redis &#43; Lua 的方案非常适合此场景： Redis 单线程特性，适合解决分布式集群的并发问题 Redis 本身支持 Lua 脚本执" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%A6%82%E4%BD%95%E7%94%A8go%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-05-21T15:32:09&#43;00:00" />
<meta property="article:modified_time" content="2021-05-21T15:32:09&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="如何用Go实现分布式限流"/>
<meta name="twitter:description" content="Why Redis &amp;&amp; Lua 分布式限流本质上是一个集群并发问题，Redis &#43; Lua 的方案非常适合此场景： Redis 单线程特性，适合解决分布式集群的并发问题 Redis 本身支持 Lua 脚本执"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "如何用Go实现分布式限流",
      "item": "/post/%E5%A6%82%E4%BD%95%E7%94%A8go%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "如何用Go实现分布式限流",
  "name": "如何用Go实现分布式限流",
  "description": "Why Redis \u0026amp;\u0026amp; Lua 分布式限流本质上是一个集群并发问题，Redis + Lua 的方案非常适合此场景： Redis 单线程特性，适合解决分布式集群的并发问题 Redis 本身支持 Lua 脚本执",
  "keywords": [
    "Go"
  ],
  "articleBody": "Why Redis \u0026\u0026 Lua 分布式限流本质上是一个集群并发问题，Redis + Lua 的方案非常适合此场景：\n Redis 单线程特性，适合解决分布式集群的并发问题 Redis 本身支持 Lua 脚本执行，可以实现原子执行的效果  Redis 执行 Lua 脚本会以原子性方式进行，在执行脚本时不会再执行其他脚本或命令。并且，Redis 只要开始执行 Lua 脚本，就会一直执行完该脚本再进行其他操作，所以 Lua 脚本中 不能进行耗时操作 ，Redis + Lua 的应用场景非常多，如分布式锁，限流，秒杀等等。\n使用 Redis + Lua 方案有如下注意事项：\n 使用 Lua 脚本实现原子性操作的 CAS，避免不同客户端先读 Redis 数据，经过计算后再写数据造成的并发问题 前后多次请求的结果有依赖关系时，最好使用 Lua 脚本将多个请求整合为一个；但请求前后无依赖时，使用 pipeline 方式，比 Lua 脚本方便 为了保证安全性，在 Lua 脚本中不要定义自己的全局变量，以免污染 Redis 内嵌的 Lua 环境。因为 Lua 脚本中你会使用一些预制的全局变量，比如说 redis.call() 注意 Lua 脚本的时间复杂度，Redis 的单线程同样会阻塞在 Lua 脚本的执行中，Lua 脚本不要进行高耗时操作 Redis 要求单个 Lua 脚本操作的 key 必须在同一个 Redis 节点上，因此 Redis Cluster 方式需要设置 HashTag  常用方法 本小节介绍下常用的分布式限流方案。\n计数器 计数器限流的核心是 INCRBY 和 EXPIRE 指令，测试用例 在此，通常，计数器算法容易出现不平滑的情况，瞬间的 qps 有可能超过系统的承载。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  -- 获取调用脚本时传入的第一个 key 值（用作限流的 key） local key = KEYS[1] -- 获取调用脚本时传入的第一个参数值（限流大小） local limit = tonumber(ARGV[1]) -- 获取计数器的限速区间 TTL local ttl = tonumber(ARGV[2]) -- 获取当前流量大小 local curentLimit = tonumber(redis.call('get', key) or \"0\") -- 是否超出限流 if curentLimit + 1  limit then -- 返回 (拒绝) return 0 else -- 没有超出 value + 1 redis.call('INCRBY', key, 1) -- 如果 key 中保存的并发计数为 0，说明当前是一个新的时间窗口，它的过期时间设置为窗口的过期时间 if (current_permits == 0) then redis.call('EXPIRE', key, ttl) end -- 返回 (放行) return 1 end   此段 Lua 脚本的逻辑很直观：\n 通过 KEYS[1] 获取传入的 key 参数，为某个限流指标的 key 通过 ARGV[1] 获取传入的 limit 参数，为限流值 通过 ARGV[2] 获取限流区间 ttl 通过 redis.call，拿到 key 对应的值（默认为 0），接着与 limit 判断，如果超出表示该被限流；否则，使用 INCRBY 增加 1，未限流（需要处理初始化的情况，设置 TTL）  不过上面代码是有问题的，如果 key 之前存在且未设置 TTL，那么限速逻辑就会永远生效了（触发 limit 值之后），使用时需要注意.\n令牌桶算法 令牌桶算法也是 Guava 中使用的算法，同样采用计算的方式，将时间和 Token 数目联系起来：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  -- key local key = KEYS[1] -- 最大存储的令牌数 local max_permits = tonumber(KEYS[2]) -- 每秒钟产生的令牌数 local permits_per_second = tonumber(KEYS[3]) -- 请求的令牌数 local required_permits = tonumber(ARGV[1]) -- 下次请求可以获取令牌的起始时间 local next_free_ticket_micros = tonumber(redis.call('hget', key, 'next_free_ticket_micros') or 0) -- 当前时间 local time = redis.call('time') -- time[1] 返回的为秒，time[2] 为 ms local now_micros = tonumber(time[1]) * 1000000 + tonumber(time[2]) -- 查询获取令牌是否超时（传入参数，单位为 微秒） if (ARGV[2] ~= nil) then -- 获取令牌的超时时间 local timeout_micros = tonumber(ARGV[2]) local micros_to_wait = next_free_ticket_micros - now_micros if (micros_to_wait timeout_micros) then return micros_to_wait end end -- 当前存储的令牌数 local stored_permits = tonumber(redis.call('hget', key, 'stored_permits') or 0) -- 添加令牌的时间间隔（1000000ms 为 1s） -- 计算生产 1 个令牌需要多少微秒 local stable_interval_micros = 1000000 / permits_per_second -- 补充令牌 if (now_micros next_free_ticket_micros) then local new_permits = (now_micros - next_free_ticket_micros) / stable_interval_micros stored_permits = math.min(max_permits, stored_permits + new_permits) -- 补充后，更新下次可以获取令牌的时间 next_free_ticket_micros = now_micros end -- 消耗令牌 local moment_available = next_free_ticket_micros -- 两种情况：required_permitsstored_permits 或者 required_permitsstored_permits local stored_permits_to_spend = math.min(required_permits, stored_permits) local fresh_permits = required_permits - stored_permits_to_spend; -- 如果 fresh_permits0，说明令牌桶的剩余数目不够了，需要等待一段时间 local wait_micros = fresh_permits * stable_interval_micros -- Redis 提供了 redis.replicate_commands() 函数来实现这一功能，把发生数据变更的命令以事务的方式做持久化和主从复制，从而允许在 Lua 脚本内进行随机写入 redis.replicate_commands() -- 存储剩余的令牌数：桶中剩余的数目 - 本次申请的数目 redis.call('hset', key, 'stored_permits', stored_permits - stored_permits_to_spend) redis.call('hset', key, 'next_free_ticket_micros', next_free_ticket_micros + wait_micros) redis.call('expire', key, 10) -- 返回需要等待的时间长度 -- 返回为 0（moment_available==now_micros）表示桶中剩余的令牌足够，不需要等待 return moment_available - now_micros   简单分析上上述代码，传入参数为：\n key：限流 key max_permits：最大存储的令牌数 permits_per_second：每秒钟产生的令牌数 required_permits：请求的令牌数 timeout_micros：获取令牌的超时时间（非必须）  整个代码的运行流程如下：\n固定窗口 此算法来自于 go-redis/redis_rate:v7 版本提供的实现，使用 示例在此，主要的限速逻辑代码见下：\n在此算法中，使用 redisPrefix:name-slot 做固定窗口的标识 key（allowName 方法），其中 slot 为当前时间戳（秒）除以窗口时延区间值 udur；在 AllowN 方法实现中，delay 的计算出的值是在一个 dur 范围内浮动的（由 utime 决定）；最终使用 INCRBY 指令 统计窗口（即 key：redisPrefix:name-slot）已使用流量 count，并且同时设置 redisPrefix:name-slot 在此窗口结束后自动过期\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  func (l *Limiter) AllowN( name string, maxn int64, dur time.Duration, n int64, ) (count int64, delay time.Duration, allow bool) { udur := int64(dur / time.Second) // 注意，将 duration 转为整数，不可以小于 1s \tutime := time.Now().Unix() slot := utime / udur // 这里的除法有溢出风险 \tdelay = time.Duration((slot+1)*udur-utime) * time.Second if l.Fallback != nil { allow = l.Fallback.Allow() } name = allowName(name, slot) count, err := l.incr(name, dur, n) if err == nil { allow = count  maxn } return count, delay, allow } //allowName 使用 name+slot 作为 redis 的 key func allowName(name string, slot int64) string { return fmt.Sprintf(\"%s:%s-%d\", redisPrefix, name, slot) } //IncrBy+expire 操作合并执行 func (l *Limiter) incr(name string, period time.Duration, n int64) (int64, error) { var incr*redis.IntCmd // 使用 pipeline 批量操作 \t_, err := l.redis.Pipelined(func(pipe redis.Pipeliner) error { incr = pipe.IncrBy(name, n) pipe.Expire(name, period+30*time.Second) return nil }) rate, _ := incr.Result() return rate, err }   Go-Redis 提供的分布式限流库 go-redis 官方提供了一个分布式限频库：Rate limiting for go-redis：redis_rate\n使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func main() { ctx := context.Background() rdb := redis.NewClient(\u0026redis.Options{ Addr: \"localhost:6379\", }) _ = rdb.FlushDB(ctx).Err() limiter := redis_rate.NewLimiter(rdb) for { res, err := limiter.Allow(ctx, \"project:123\", redis_rate.PerSecond(5)) if err != nil { panic(err) } fmt.Println(\"allowed\", res.Allowed, \"remaining\", res.Remaining) time.Sleep(10 * time.Millisecond) } }   限流脚本 redis-rate 提供的 Lua 脚本实现 在此\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114  package redis_rate import \"github.com/go-redis/redis/v8\" // Copyright (c) 2017 Pavel Pravosud // https://github.com/rwz/redis-gcra/blob/master/vendor/perform_gcra_ratelimit.lua var allowN = redis.NewScript(` -- this script has side-effects, so it requires replicate commands mode redis.replicate_commands() local rate_limit_key = KEYS[1] local burst = ARGV[1] local rate = ARGV[2] local period = ARGV[3] local cost = tonumber(ARGV[4]) local emission_interval = period / rate local increment = emission_interval * cost local burst_offset = emission_interval * burst -- redis returns time as an array containing two integers: seconds of the epoch -- time (10 digits) and microseconds (6 digits). for convenience we need to -- convert them to a floating point number. the resulting number is 16 digits, -- bordering on the limits of a 64-bit double-precision floating point number. -- adjust the epoch to be relative to Jan 1, 2017 00:00:00 GMT to avoid floating -- point problems. this approach is good until \"now\" is 2,483,228,799 (Wed, 09 -- Sep 2048 01:46:39 GMT), when the adjusted value is 16 digits. local jan_1_2017 = 1483228800 local now = redis.call(\"TIME\") now = (now[1] - jan_1_2017) + (now[2] / 1000000) local tat = redis.call(\"GET\", rate_limit_key) if not tat then tat = now else tat = tonumber(tat) end tat = math.max(tat, now) local new_tat = tat + increment local allow_at = new_tat - burst_offset local diff = now - allow_at local remaining = diff / emission_interval if remaining local reset_after = tat - now local retry_after = diff * -1 return { 0, -- allowed 0, -- remaining tostring(retry_after), tostring(reset_after), } end local reset_after = new_tat - now if reset_after  0 then redis.call(\"SET\", rate_limit_key, new_tat, \"EX\", math.ceil(reset_after)) end local retry_after = -1 return {cost, remaining, tostring(retry_after), tostring(reset_after)} `) var allowAtMost = redis.NewScript(` -- this script has side-effects, so it requires replicate commands mode redis.replicate_commands() local rate_limit_key = KEYS[1] local burst = ARGV[1] local rate = ARGV[2] local period = ARGV[3] local cost = tonumber(ARGV[4]) local emission_interval = period / rate local burst_offset = emission_interval * burst -- redis returns time as an array containing two integers: seconds of the epoch -- time (10 digits) and microseconds (6 digits). for convenience we need to -- convert them to a floating point number. the resulting number is 16 digits, -- bordering on the limits of a 64-bit double-precision floating point number. -- adjust the epoch to be relative to Jan 1, 2017 00:00:00 GMT to avoid floating -- point problems. this approach is good until \"now\" is 2,483,228,799 (Wed, 09 -- Sep 2048 01:46:39 GMT), when the adjusted value is 16 digits. local jan_1_2017 = 1483228800 local now = redis.call(\"TIME\") now = (now[1] - jan_1_2017) + (now[2] / 1000000) local tat = redis.call(\"GET\", rate_limit_key) if not tat then tat = now else tat = tonumber(tat) end tat = math.max(tat, now) local diff = now - (tat - burst_offset) local remaining = diff / emission_interval if remaining local reset_after = tat - now local retry_after = emission_interval - diff return { 0, -- allowed 0, -- remaining tostring(retry_after), tostring(reset_after), } end if remaining cost = remaining remaining = 0 else remaining = remaining - cost end local increment = emission_interval * cost local new_tat = tat + increment local reset_after = new_tat - now if reset_after  0 then redis.call(\"SET\", rate_limit_key, new_tat, \"EX\", math.ceil(reset_after)) end return { cost, remaining, tostring(-1), tostring(reset_after), } `)   ",
  "wordCount" : "2936",
  "inLanguage": "zh-cn",
  "datePublished": "2021-05-21T15:32:09Z",
  "dateModified": "2021-05-21T15:32:09Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%A6%82%E4%BD%95%E7%94%A8go%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      如何用Go实现分布式限流
    </h1>
    <div class="post-meta">May 21, 2021
</div>
  </header> 
  <div class="post-content"><h2 id="why-redis--lua">Why Redis &amp;&amp; Lua<a hidden class="anchor" aria-hidden="true" href="#why-redis--lua">#</a></h2>
<p>分布式限流本质上是一个集群并发问题，Redis + Lua 的方案非常适合此场景：</p>
<ul>
<li>Redis 单线程特性，适合解决分布式集群的并发问题</li>
<li>Redis 本身支持 Lua 脚本执行，可以实现原子执行的效果</li>
</ul>
<p>Redis 执行 Lua 脚本会以原子性方式进行，在执行脚本时不会再执行其他脚本或命令。并且，Redis 只要开始执行 Lua 脚本，就会一直执行完该脚本再进行其他操作，所以 Lua 脚本中 不能进行耗时操作 ，Redis + Lua 的应用场景非常多，如分布式锁，限流，秒杀等等。</p>
<p>使用 Redis + Lua 方案有如下注意事项：</p>
<ol>
<li>使用 Lua 脚本实现原子性操作的 CAS，避免不同客户端先读 Redis 数据，经过计算后再写数据造成的并发问题</li>
<li>前后多次请求的结果有依赖关系时，最好使用 Lua 脚本将多个请求整合为一个；但请求前后无依赖时，使用 pipeline 方式，比 Lua 脚本方便</li>
<li>为了保证安全性，在 Lua 脚本中不要定义自己的全局变量，以免污染 Redis 内嵌的 Lua 环境。因为 Lua 脚本中你会使用一些预制的全局变量，比如说 redis.call()</li>
<li>注意 Lua 脚本的时间复杂度，Redis 的单线程同样会阻塞在 Lua 脚本的执行中，Lua 脚本不要进行高耗时操作</li>
<li>Redis 要求单个 Lua 脚本操作的 key 必须在同一个 Redis 节点上，因此 Redis Cluster 方式需要设置 HashTag</li>
</ol>
<h2 id="常用方法">常用方法<a hidden class="anchor" aria-hidden="true" href="#常用方法">#</a></h2>
<p>本小节介绍下常用的分布式限流方案。</p>
<h3 id="计数器">计数器<a hidden class="anchor" aria-hidden="true" href="#计数器">#</a></h3>
<p>计数器限流的核心是 INCRBY 和 EXPIRE 指令，测试用例 在此，通常，计数器算法容易出现不平滑的情况，瞬间的 qps 有可能超过系统的承载。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">--</span> 获取调用脚本时传入的第一个 <span class="n">key</span> 值（用作限流的 <span class="n">key</span>）
<span class="n">local</span> <span class="n">key</span> <span class="o">=</span> <span class="n">KEYS[1]</span>
<span class="o">--</span> 获取调用脚本时传入的第一个参数值（限流大小）
<span class="n">local</span> <span class="n">limit</span> <span class="o">=</span> <span class="nf">tonumber</span><span class="p">(</span><span class="n">ARGV[1]</span><span class="p">)</span>
<span class="o">--</span> 获取计数器的限速区间 <span class="n">TTL</span>
<span class="n">local</span> <span class="n">ttl</span> <span class="o">=</span> <span class="nf">tonumber</span><span class="p">(</span><span class="n">ARGV[2]</span><span class="p">)</span>

<span class="o">--</span> 获取当前流量大小
<span class="n">local</span> <span class="n">curentLimit</span> <span class="o">=</span> <span class="nf">tonumber</span><span class="p">(</span><span class="nf">redis.call</span><span class="p">(</span><span class="s">&#39;get&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="n">or</span> <span class="s">&#34;0&#34;</span><span class="p">)</span>

<span class="o">--</span> 是否超出限流
<span class="n">if</span> <span class="n">curentLimit</span> <span class="o">+</span> <span class="m">1</span> <span class="o">&gt;</span> <span class="n">limit</span> <span class="n">then</span>
    <span class="o">--</span> 返回 <span class="p">(</span>拒绝<span class="p">)</span>
    <span class="n">return</span> <span class="m">0</span>
<span class="n">else</span>
    <span class="o">--</span> 没有超出 <span class="n">value</span> <span class="o">+</span> <span class="m">1</span>
    <span class="nf">redis.call</span><span class="p">(</span><span class="s">&#39;INCRBY&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
    <span class="o">--</span> 如果 <span class="n">key</span> 中保存的并发计数为 <span class="m">0</span>，说明当前是一个新的时间窗口，它的过期时间设置为窗口的过期时间
    <span class="nf">if </span><span class="p">(</span><span class="n">current_permits</span> <span class="o">==</span> <span class="m">0</span><span class="p">)</span> <span class="n">then</span>
	      <span class="nf">redis.call</span><span class="p">(</span><span class="s">&#39;EXPIRE&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">ttl</span><span class="p">)</span>
	  <span class="n">end</span>
    <span class="o">--</span> 返回 <span class="p">(</span>放行<span class="p">)</span>
    <span class="n">return</span> <span class="m">1</span>
<span class="n">end</span>
</code></pre></td></tr></table>
</div>
</div><p>此段 Lua 脚本的逻辑很直观：</p>
<ol>
<li>通过 KEYS[1] 获取传入的 key 参数，为某个限流指标的 key</li>
<li>通过 ARGV[1] 获取传入的 limit 参数，为限流值</li>
<li>通过 ARGV[2] 获取限流区间 ttl</li>
<li>通过 redis.call，拿到 key 对应的值（默认为 0），接着与 limit 判断，如果超出表示该被限流；否则，使用 INCRBY 增加 1，未限流（需要处理初始化的情况，设置 TTL）</li>
</ol>
<p>不过上面代码是有问题的，如果 key 之前存在且未设置 TTL，那么限速逻辑就会永远生效了（触发 limit 值之后），使用时需要注意.</p>
<h3 id="令牌桶算法">令牌桶算法<a hidden class="anchor" aria-hidden="true" href="#令牌桶算法">#</a></h3>
<p>令牌桶算法也是 Guava 中使用的算法，同样采用计算的方式，将时间和 Token 数目联系起来：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">--</span> <span class="n">key</span>
<span class="n">local</span> <span class="n">key</span> <span class="o">=</span> <span class="n">KEYS[1]</span>
<span class="o">--</span> 最大存储的令牌数
<span class="n">local</span> <span class="n">max_permits</span> <span class="o">=</span> <span class="nf">tonumber</span><span class="p">(</span><span class="n">KEYS[2]</span><span class="p">)</span>
<span class="o">--</span> 每秒钟产生的令牌数
<span class="n">local</span> <span class="n">permits_per_second</span> <span class="o">=</span> <span class="nf">tonumber</span><span class="p">(</span><span class="n">KEYS[3]</span><span class="p">)</span>
<span class="o">--</span> 请求的令牌数
<span class="n">local</span> <span class="n">required_permits</span> <span class="o">=</span> <span class="nf">tonumber</span><span class="p">(</span><span class="n">ARGV[1]</span><span class="p">)</span>

<span class="o">--</span> 下次请求可以获取令牌的起始时间
<span class="n">local</span> <span class="n">next_free_ticket_micros</span> <span class="o">=</span> <span class="nf">tonumber</span><span class="p">(</span><span class="nf">redis.call</span><span class="p">(</span><span class="s">&#39;hget&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="s">&#39;next_free_ticket_micros&#39;</span><span class="p">)</span> <span class="n">or</span> <span class="m">0</span><span class="p">)</span>

<span class="o">--</span> 当前时间
<span class="n">local</span> <span class="n">time</span> <span class="o">=</span> <span class="nf">redis.call</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">)</span>
<span class="o">--</span> <span class="n">time[1]</span> 返回的为秒，<span class="n">time[2]</span> 为 <span class="n">ms</span>
<span class="n">local</span> <span class="n">now_micros</span> <span class="o">=</span> <span class="nf">tonumber</span><span class="p">(</span><span class="n">time[1]</span><span class="p">)</span> <span class="o">*</span> <span class="m">1000000</span> <span class="o">+</span> <span class="nf">tonumber</span><span class="p">(</span><span class="n">time[2]</span><span class="p">)</span>

<span class="o">--</span> 查询获取令牌是否超时（传入参数，单位为 微秒）
<span class="nf">if </span><span class="p">(</span><span class="n">ARGV[2]</span> <span class="o">~=</span> <span class="n">nil</span><span class="p">)</span> <span class="n">then</span>
    <span class="o">--</span> 获取令牌的超时时间
    <span class="n">local</span> <span class="n">timeout_micros</span> <span class="o">=</span> <span class="nf">tonumber</span><span class="p">(</span><span class="n">ARGV[2]</span><span class="p">)</span>
    <span class="n">local</span> <span class="n">micros_to_wait</span> <span class="o">=</span> <span class="n">next_free_ticket_micros</span> <span class="o">-</span> <span class="n">now_micros</span>
    <span class="nf">if </span><span class="p">(</span><span class="n">micros_to_wait</span><span class="o">&gt;</span> <span class="n">timeout_micros</span><span class="p">)</span> <span class="n">then</span>
        <span class="n">return</span> <span class="n">micros_to_wait</span>
    <span class="n">end</span>
<span class="n">end</span>

<span class="o">--</span> 当前存储的令牌数
<span class="n">local</span> <span class="n">stored_permits</span> <span class="o">=</span> <span class="nf">tonumber</span><span class="p">(</span><span class="nf">redis.call</span><span class="p">(</span><span class="s">&#39;hget&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="s">&#39;stored_permits&#39;</span><span class="p">)</span> <span class="n">or</span> <span class="m">0</span><span class="p">)</span>
<span class="o">--</span> 添加令牌的时间间隔（<span class="m">1000000</span><span class="n">ms</span> 为 <span class="m">1</span><span class="n">s</span>）
<span class="o">--</span> 计算生产 <span class="m">1</span> 个令牌需要多少微秒
<span class="n">local</span> <span class="n">stable_interval_micros</span> <span class="o">=</span> <span class="m">1000000</span> <span class="o">/</span> <span class="n">permits_per_second</span>

<span class="o">--</span> 补充令牌
<span class="nf">if </span><span class="p">(</span><span class="n">now_micros</span><span class="o">&gt;</span> <span class="n">next_free_ticket_micros</span><span class="p">)</span> <span class="n">then</span>
    <span class="n">local</span> <span class="n">new_permits</span> <span class="o">=</span> <span class="p">(</span><span class="n">now_micros</span> <span class="o">-</span> <span class="n">next_free_ticket_micros</span><span class="p">)</span> <span class="o">/</span> <span class="n">stable_interval_micros</span>
    <span class="n">stored_permits</span> <span class="o">=</span> <span class="nf">math.min</span><span class="p">(</span><span class="n">max_permits</span><span class="p">,</span> <span class="n">stored_permits</span> <span class="o">+</span> <span class="n">new_permits</span><span class="p">)</span>
    <span class="o">--</span> 补充后，更新下次可以获取令牌的时间
    <span class="n">next_free_ticket_micros</span> <span class="o">=</span> <span class="n">now_micros</span>
<span class="n">end</span>

<span class="o">--</span> 消耗令牌
<span class="n">local</span> <span class="n">moment_available</span> <span class="o">=</span> <span class="n">next_free_ticket_micros</span>
<span class="o">--</span> 两种情况：<span class="n">required_permits</span><span class="o">&lt;=</span><span class="n">stored_permits</span> 或者 <span class="n">required_permits</span><span class="o">&gt;</span><span class="n">stored_permits</span>
<span class="n">local</span> <span class="n">stored_permits_to_spend</span> <span class="o">=</span> <span class="nf">math.min</span><span class="p">(</span><span class="n">required_permits</span><span class="p">,</span> <span class="n">stored_permits</span><span class="p">)</span>
<span class="n">local</span> <span class="n">fresh_permits</span> <span class="o">=</span> <span class="n">required_permits</span> <span class="o">-</span> <span class="n">stored_permits_to_spend</span><span class="p">;</span>
<span class="o">--</span> 如果 <span class="n">fresh_permits</span><span class="o">&gt;</span><span class="m">0</span>，说明令牌桶的剩余数目不够了，需要等待一段时间
<span class="n">local</span> <span class="n">wait_micros</span> <span class="o">=</span> <span class="n">fresh_permits</span> <span class="o">*</span> <span class="n">stable_interval_micros</span>

<span class="o">--</span> <span class="n">Redis</span> 提供了 <span class="nf">redis.replicate_commands</span><span class="p">()</span> 函数来实现这一功能，把发生数据变更的命令以事务的方式做持久化和主从复制，从而允许在 <span class="n">Lua</span> 脚本内进行随机写入
<span class="nf">redis.replicate_commands</span><span class="p">()</span>
<span class="o">--</span> 存储剩余的令牌数：桶中剩余的数目 <span class="o">-</span> 本次申请的数目
<span class="nf">redis.call</span><span class="p">(</span><span class="s">&#39;hset&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="s">&#39;stored_permits&#39;</span><span class="p">,</span> <span class="n">stored_permits</span> <span class="o">-</span> <span class="n">stored_permits_to_spend</span><span class="p">)</span>
<span class="nf">redis.call</span><span class="p">(</span><span class="s">&#39;hset&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="s">&#39;next_free_ticket_micros&#39;</span><span class="p">,</span> <span class="n">next_free_ticket_micros</span> <span class="o">+</span> <span class="n">wait_micros</span><span class="p">)</span>
<span class="nf">redis.call</span><span class="p">(</span><span class="s">&#39;expire&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>

<span class="o">--</span> 返回需要等待的时间长度
<span class="o">--</span> 返回为 <span class="m">0</span>（<span class="n">moment_available</span><span class="o">==</span><span class="n">now_micros</span>）表示桶中剩余的令牌足够，不需要等待
<span class="n">return</span> <span class="n">moment_available</span> <span class="o">-</span> <span class="n">now_micros</span>
</code></pre></td></tr></table>
</div>
</div><p>简单分析上上述代码，传入参数为：</p>
<ul>
<li>key：限流 key</li>
<li>max_permits：最大存储的令牌数</li>
<li>permits_per_second：每秒钟产生的令牌数</li>
<li>required_permits：请求的令牌数</li>
<li>timeout_micros：获取令牌的超时时间（非必须）</li>
</ul>
<p>整个代码的运行流程如下：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210521154017.png" alt=""  />
</p>
<h3 id="固定窗口">固定窗口<a hidden class="anchor" aria-hidden="true" href="#固定窗口">#</a></h3>
<p>此算法来自于 go-redis/redis_rate:v7 版本提供的实现，使用 示例在此，主要的限速逻辑代码见下：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210521154040.png" alt=""  />
</p>
<p>在此算法中，使用 redisPrefix:name-slot 做固定窗口的标识 key（allowName 方法），其中 slot 为当前时间戳（秒）除以窗口时延区间值 udur；在 AllowN 方法实现中，delay 的计算出的值是在一个 dur 范围内浮动的（由 utime 决定）；最终使用 INCRBY 指令 统计窗口（即 key：redisPrefix:name-slot）已使用流量 count，并且同时设置 redisPrefix:name-slot 在此窗口结束后自动过期</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">AllowN</span><span class="p">(</span>
	<span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">maxn</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">dur</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int64</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">count</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">delay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span> <span class="nx">allow</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">udur</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">dur</span> <span class="o">/</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>        <span class="c1">// 注意，将 duration 转为整数，不可以小于 1s
</span><span class="c1"></span>	<span class="nx">utime</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">()</span>
	<span class="nx">slot</span> <span class="o">:=</span> <span class="nx">utime</span> <span class="o">/</span> <span class="nx">udur</span>    <span class="c1">// 这里的除法有溢出风险
</span><span class="c1"></span>	<span class="nx">delay</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">((</span><span class="nx">slot</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nx">udur</span><span class="o">-</span><span class="nx">utime</span><span class="p">)</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span>
	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">Fallback</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">allow</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">Fallback</span><span class="p">.</span><span class="nf">Allow</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">name</span> <span class="p">=</span> <span class="nf">allowName</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">slot</span><span class="p">)</span>
	<span class="nx">count</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">incr</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">dur</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">allow</span> <span class="p">=</span> <span class="nx">count</span> <span class="o">&lt;=</span> <span class="nx">maxn</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">count</span><span class="p">,</span> <span class="nx">delay</span><span class="p">,</span> <span class="nx">allow</span>
<span class="p">}</span>

<span class="c1">//allowName 使用 name+slot 作为 redis 的 key
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">allowName</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">slot</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s:%s-%d&#34;</span><span class="p">,</span> <span class="nx">redisPrefix</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">slot</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//IncrBy+expire 操作合并执行
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Limiter</span><span class="p">)</span> <span class="nf">incr</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">period</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
<span class="kd">var</span> <span class="nx">incr</span><span class="o">*</span><span class="nx">redis</span><span class="p">.</span><span class="nx">IntCmd</span>
    <span class="c1">// 使用 pipeline 批量操作
</span><span class="c1"></span>	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">redis</span><span class="p">.</span><span class="nf">Pipelined</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">pipe</span> <span class="nx">redis</span><span class="p">.</span><span class="nx">Pipeliner</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="nx">incr</span> <span class="p">=</span> <span class="nx">pipe</span><span class="p">.</span><span class="nf">IncrBy</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
		<span class="nx">pipe</span><span class="p">.</span><span class="nf">Expire</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">period</span><span class="o">+</span><span class="mi">30</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">})</span>

	<span class="nx">rate</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">incr</span><span class="p">.</span><span class="nf">Result</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">rate</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="go-redis-提供的分布式限流库">Go-Redis 提供的分布式限流库<a hidden class="anchor" aria-hidden="true" href="#go-redis-提供的分布式限流库">#</a></h1>
<p>go-redis 官方提供了一个分布式限频库：Rate limiting for go-redis：redis_rate</p>
<h2 id="使用">使用<a hidden class="anchor" aria-hidden="true" href="#使用">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">()</span>
        <span class="nx">rdb</span> <span class="o">:=</span> <span class="nx">redis</span><span class="p">.</span><span class="nf">NewClient</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Options</span><span class="p">{</span>
                <span class="nx">Addr</span><span class="p">:</span> <span class="s">&#34;localhost:6379&#34;</span><span class="p">,</span>
        <span class="p">})</span>
        <span class="nx">_</span> <span class="p">=</span> <span class="nx">rdb</span><span class="p">.</span><span class="nf">FlushDB</span><span class="p">(</span><span class="nx">ctx</span><span class="p">).</span><span class="nf">Err</span><span class="p">()</span>

        <span class="nx">limiter</span> <span class="o">:=</span> <span class="nx">redis_rate</span><span class="p">.</span><span class="nf">NewLimiter</span><span class="p">(</span><span class="nx">rdb</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">{</span>
                <span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">limiter</span><span class="p">.</span><span class="nf">Allow</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;project:123&#34;</span><span class="p">,</span> <span class="nx">redis_rate</span><span class="p">.</span><span class="nf">PerSecond</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
                <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;allowed&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">Allowed</span><span class="p">,</span> <span class="s">&#34;remaining&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">Remaining</span><span class="p">)</span>
                <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="限流脚本">限流脚本<a hidden class="anchor" aria-hidden="true" href="#限流脚本">#</a></h2>
<p>redis-rate 提供的 Lua 脚本实现 在此</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">redis_rate</span>

<span class="kn">import</span> <span class="s">&#34;github.com/go-redis/redis/v8&#34;</span>

<span class="c1">// Copyright (c) 2017 Pavel Pravosud
</span><span class="c1">// https://github.com/rwz/redis-gcra/blob/master/vendor/perform_gcra_ratelimit.lua
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">allowN</span> <span class="p">=</span> <span class="nx">redis</span><span class="p">.</span><span class="nf">NewScript</span><span class="p">(</span><span class="s">`
</span><span class="s">-- this script has side-effects, so it requires replicate commands mode
</span><span class="s">redis.replicate_commands()
</span><span class="s">local rate_limit_key = KEYS[1]
</span><span class="s">local burst = ARGV[1]
</span><span class="s">local rate = ARGV[2]
</span><span class="s">local period = ARGV[3]
</span><span class="s">local cost = tonumber(ARGV[4])
</span><span class="s">local emission_interval = period / rate
</span><span class="s">local increment = emission_interval * cost
</span><span class="s">local burst_offset = emission_interval * burst
</span><span class="s">-- redis returns time as an array containing two integers: seconds of the epoch
</span><span class="s">-- time (10 digits) and microseconds (6 digits). for convenience we need to
</span><span class="s">-- convert them to a floating point number. the resulting number is 16 digits,
</span><span class="s">-- bordering on the limits of a 64-bit double-precision floating point number.
</span><span class="s">-- adjust the epoch to be relative to Jan 1, 2017 00:00:00 GMT to avoid floating
</span><span class="s">-- point problems. this approach is good until &#34;now&#34; is 2,483,228,799 (Wed, 09
</span><span class="s">-- Sep 2048 01:46:39 GMT), when the adjusted value is 16 digits.
</span><span class="s">local jan_1_2017 = 1483228800
</span><span class="s">local now = redis.call(&#34;TIME&#34;)
</span><span class="s">now = (now[1] - jan_1_2017) + (now[2] / 1000000)
</span><span class="s">local tat = redis.call(&#34;GET&#34;, rate_limit_key)
</span><span class="s">if not tat then
</span><span class="s">  tat = now
</span><span class="s">else
</span><span class="s">  tat = tonumber(tat)
</span><span class="s">end
</span><span class="s">tat = math.max(tat, now)
</span><span class="s">local new_tat = tat + increment
</span><span class="s">local allow_at = new_tat - burst_offset
</span><span class="s">local diff = now - allow_at
</span><span class="s">local remaining = diff / emission_interval
</span><span class="s">if remaining &lt; 0 then
</span><span class="s">  local reset_after = tat - now
</span><span class="s">  local retry_after = diff * -1
</span><span class="s">  return {
</span><span class="s">    0, -- allowed
</span><span class="s">    0, -- remaining
</span><span class="s">    tostring(retry_after),
</span><span class="s">    tostring(reset_after),
</span><span class="s">  }
</span><span class="s">end
</span><span class="s">local reset_after = new_tat - now
</span><span class="s">if reset_after &gt; 0 then
</span><span class="s">  redis.call(&#34;SET&#34;, rate_limit_key, new_tat, &#34;EX&#34;, math.ceil(reset_after))
</span><span class="s">end
</span><span class="s">local retry_after = -1
</span><span class="s">return {cost, remaining, tostring(retry_after), tostring(reset_after)}
</span><span class="s">`</span><span class="p">)</span>

<span class="kd">var</span> <span class="nx">allowAtMost</span> <span class="p">=</span> <span class="nx">redis</span><span class="p">.</span><span class="nf">NewScript</span><span class="p">(</span><span class="s">`
</span><span class="s">-- this script has side-effects, so it requires replicate commands mode
</span><span class="s">redis.replicate_commands()
</span><span class="s">local rate_limit_key = KEYS[1]
</span><span class="s">local burst = ARGV[1]
</span><span class="s">local rate = ARGV[2]
</span><span class="s">local period = ARGV[3]
</span><span class="s">local cost = tonumber(ARGV[4])
</span><span class="s">local emission_interval = period / rate
</span><span class="s">local burst_offset = emission_interval * burst
</span><span class="s">-- redis returns time as an array containing two integers: seconds of the epoch
</span><span class="s">-- time (10 digits) and microseconds (6 digits). for convenience we need to
</span><span class="s">-- convert them to a floating point number. the resulting number is 16 digits,
</span><span class="s">-- bordering on the limits of a 64-bit double-precision floating point number.
</span><span class="s">-- adjust the epoch to be relative to Jan 1, 2017 00:00:00 GMT to avoid floating
</span><span class="s">-- point problems. this approach is good until &#34;now&#34; is 2,483,228,799 (Wed, 09
</span><span class="s">-- Sep 2048 01:46:39 GMT), when the adjusted value is 16 digits.
</span><span class="s">local jan_1_2017 = 1483228800
</span><span class="s">local now = redis.call(&#34;TIME&#34;)
</span><span class="s">now = (now[1] - jan_1_2017) + (now[2] / 1000000)
</span><span class="s">local tat = redis.call(&#34;GET&#34;, rate_limit_key)
</span><span class="s">if not tat then
</span><span class="s">  tat = now
</span><span class="s">else
</span><span class="s">  tat = tonumber(tat)
</span><span class="s">end
</span><span class="s">tat = math.max(tat, now)
</span><span class="s">local diff = now - (tat - burst_offset)
</span><span class="s">local remaining = diff / emission_interval
</span><span class="s">if remaining &lt; 1 then
</span><span class="s">  local reset_after = tat - now
</span><span class="s">  local retry_after = emission_interval - diff
</span><span class="s">  return {
</span><span class="s">    0, -- allowed
</span><span class="s">    0, -- remaining
</span><span class="s">    tostring(retry_after),
</span><span class="s">    tostring(reset_after),
</span><span class="s">  }
</span><span class="s">end
</span><span class="s">if remaining &lt; cost then
</span><span class="s">  cost = remaining
</span><span class="s">  remaining = 0
</span><span class="s">else
</span><span class="s">  remaining = remaining - cost
</span><span class="s">end
</span><span class="s">local increment = emission_interval * cost
</span><span class="s">local new_tat = tat + increment
</span><span class="s">local reset_after = new_tat - now
</span><span class="s">if reset_after &gt; 0 then
</span><span class="s">  redis.call(&#34;SET&#34;, rate_limit_key, new_tat, &#34;EX&#34;, math.ceil(reset_after))
</span><span class="s">end
</span><span class="s">return {
</span><span class="s">  cost,
</span><span class="s">  remaining,
</span><span class="s">  tostring(-1),
</span><span class="s">  tostring(reset_after),
</span><span class="s">}
</span><span class="s">`</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go/">Go</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
