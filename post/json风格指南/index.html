<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>JSON风格指南 | Forz Blog</title>
<meta name="keywords" content="JSON" />
<meta name="description" content="JSON风格指南 版本：0.9 英文版：https://google.github.io/styleguide/jsoncstyleguide.">
<meta name="author" content="">
<link rel="canonical" href="/post/json%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="JSON风格指南" />
<meta property="og:description" content="JSON风格指南 版本：0.9 英文版：https://google.github.io/styleguide/jsoncstyleguide." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/json%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-04-29T16:17:43&#43;00:00" />
<meta property="article:modified_time" content="2020-04-29T16:17:43&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JSON风格指南"/>
<meta name="twitter:description" content="JSON风格指南 版本：0.9 英文版：https://google.github.io/styleguide/jsoncstyleguide."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "JSON风格指南",
      "item": "/post/json%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JSON风格指南",
  "name": "JSON风格指南",
  "description": "JSON风格指南 版本：0.9 英文版：https://google.github.io/styleguide/jsoncstyleguide.",
  "keywords": [
    "JSON"
  ],
  "articleBody": "JSON风格指南 版本：0.9\n英文版：https://google.github.io/styleguide/jsoncstyleguide.xml\n翻译：Darcy Liu\n译文状态：草稿\n简介 该风格指南是对在Google创建JSON APIs而提供的指导性准则和建议。总体来讲，JSON APIs应遵循JSON.org上的规范。这份风格指南澄清和标准化了特定情况，从而使Google的JSON APIs有一种标准的外观和感觉。这些指南适用于基于RPC和基于REST风格的API的JSON请求和响应。\n定义 为了更好地实现这份风格指南的目的，下面几项需要说明：\n 属性(property) - JSON对象内的键值对(name/value pair) 属性名(property name) - 属性的名称(或键) 属性值(property value) - 分配给属性的值  示例：\n{ // 一组键值对称作一个 \"属性\". \"propertyName\": \"propertyValue\" }  Javascript的数字(number)包含所有的浮点数,这是一个宽泛的指定。在这份指南中，数字(number)指代Javascript中的数字(number)类型，而整型(integer)则指代整型。\n一般准则 注释 JSON对象中不包含注释。\nJSON对象中不应该包含注释。该指南中的某些示例含有注释。但这仅仅是为了说明示例。\n{ // 你可能在下面的示例中看到注释, // 但不要在你的JSON数据中加入注释. \"propertyName\": \"propertyValue\" }  双引号 使用双引号\n如果（某个）属性需要引号，则必须使用双引号。所有的属性名必须在双引号内。字符类型的属性值必须使用双引号。其它类型值（如布尔或数字）不应该使用双引号。\n扁平化数据 VS 结构层次 不能为了方便而将数据任意分组\nJSON中的数据元素应以扁平化方式呈现。不能为了方便而将数据任意分组。\n在某些情况下，比如描述单一结构的一批属性，因为它被用来保持结构层次，因而是有意义的。但是遇到这些情况还是应当慎重考虑，记住只有语义上有意义的时候才使用它。例如，一个地址可以有表示两种方式，但结构化的方式对开发人员来讲可能更有意义：\n扁平化地址:\n{ \"company\": \"Google\", \"website\": \"http://www.google.com/\", \"addressLine1\": \"111 8th Ave\", \"addressLine2\": \"4th Floor\", \"state\": \"NY\", \"city\": \"New York\", \"zip\": \"10011\" }  结构化地址：\n{ \"company\": \"Google\", \"website\": \"http://www.google.com/\", \"address\": { \"line1\": \"111 8th Ave\", \"line2\": \"4th Floor\", \"state\": \"NY\", \"city\": \"New York\", \"zip\": \"10011\" } }  属性名准则 属性名格式 选择有意义的属性名\n属性名必须遵循以下准则:\n 属性名应该是具有定义语义的有意义的名称。 属性名必须是驼峰式的，ASCII码字符串。 首字符必须是字母，下划线(_)或美元符号($)。 随后的其他字符可以是字母，数字，下划线(_)或美元符号($)。 应该避免使用Javascript中的保留关键字(下文附有Javascript保留字清单)  这些准则反映JavaScript标识符命名的指导方针。使JavaScript的客户端可以使用点符号来访问属性。(例如, result.thisIsAnInstanceVariable).\n下面是一个对象的一个属性的例子：\n{ \"thisPropertyIsAnIdentifier\": \"identifier value\" }  JSON Map中的键名 在JSON Map中键名可以使用任意Unicode字符\n当JSON对象作为Map(映射)使用时，属性的名称命名规则并不适用。Map（也称作关联数组）是一个具有任意键/值对的数据类型，这些键/值对通过特定的键来访问相应的值。JSON对象和JSON Map在运行时看起来是一样的；这个特性与API设计相关。当JSON对象被当作map使用时，API文件应当做出说明。\nMap的键名不一定要遵循属性名称的命名准则。键名可以包含任意的Unicode字符。客户端可使用maps熟悉的方括号来访问这些属性。（例如result.thumbnails[\"72\"]）\n{ // \"address\" 属性是一个子对象 // 包含地址的各部分. \"address\": { \"addressLine1\": \"123 Anystreet\", \"city\": \"Anytown\", \"state\": \"XX\", \"zip\": \"00000\" }, // \"address\" 是一个映射 // 含有响应规格所对应的URL，用来映射thumbnail url的像素规格 \"thumbnails\": { \"72\": \"http://url.to.72px.thumbnail\", \"144\": \"http://url.to.144px.thumbnail\" } }  保留的属性名称 某些属性名称会被保留以便能在多个服务间相容使用\n保留属性名称的详细信息，连同完整的列表，可在本指南后面的内容中找到。服务应按照被定义的语义来使用属性名称。\n单数属性名 VS 复数属性名 数组类型应该是复数属性名。其它属性名都应该是单数。\n数组通常包含多个条目，复数属性名就反映了这点。在下面这个保留名称中可以看到例子。属性名items是复数因为它描述的是一组对象。大多数的其它字段是单数。\n当然也有例外，尤其是涉及到数字的属性值的时候。例如，在保留属性名中，totalItems 比 totalItem更合理。然后，从技术上讲，这并不违反风格指南，因为 totalItems 可以被看作 totalOfItems, 其中 total 是单数（依照风格指南），OfItems 用来限定总数。字段名也可被改为 itemCount，这样看起来更象单数.\n{ // 单数 \"author\": \"lisa\", // 一组同胞, 复数 \"siblings\": [ \"bart\", \"maggie\"], // \"totalItem\" 看起来并不对 \"totalItems\": 10, // 但 \"itemCount\" 要好些 \"itemCount\": 10 }  命名冲突 通过选择新的属性名或将API版本化来避免命名冲突\n新的属性可在将来被添加进保留列表中。JSON中不存在命名空间。如果存在命名冲突，可通过选择新的属性名或者版本化来解决这个问题。例如，假设我们由下面的JSON对象开始：\n{ \"apiVersion\": \"1.0\", \"data\": { \"recipeName\": \"pizza\", \"ingredients\": [\"tomatoes\", \"cheese\", \"sausage\"] } }  如果我们希望将来把ingredients列为保留字，我们可以通过下面两件事情来达成:\n1.选一个不同的名字\n{ \"apiVersion\": \"1.0\", \"data\": { \"recipeName\": \"pizza\", \"ingredientsData\": \"Some new property\", \"ingredients\": [\"tomatoes\", \"cheese\", \"sausage\"] } }  2.在主版本上重新命名属性\n{ \"apiVersion\": \"2.0\", \"data\": { \"recipeName\": \"pizza\", \"ingredients\": \"Some new property\", \"recipeIngredients\": [\"tomatos\", \"cheese\", \"sausage\"] } }  属性值准则 属性值格式 属性值必须是Unicode 的 booleans（布尔）, 数字(numbers), 字符串(strings), 对象(objects), 数组(arrays), 或 null.\nJSON.org上的标准准确地说明了哪些类型的数据可以作为属性值。这包含Unicode的布尔(booleans), 数字(numbers), 字符串(strings), 对象(objects), 数组(arrays), 或 null。JavaScript表达式是不被接受的。APIs应该支持该准则，并为某个特定的属性选择最合适的数据类型（比如，用numbers代表numbers等）。\n好的例子：\n{ \"canPigsFly\": null, // null \"areWeThereYet\": false, // boolean \"answerToLife\": 42, // number \"name\": \"Bart\", // string \"moreData\": {}, // object \"things\": [] // array }  不好的例子：\n{ \"aVariableName\": aVariableName, // Bad - JavaScript 标识符 \"functionFoo\": function() { return 1; } // Bad - JavaScript 函数 }  空或Null 属性值 考虑移除空或null值\n如果一个属性是可选的或者包含空值或null值，考虑从JSON中去掉该属性，除非它的存在有很强的语义原因。\n{ \"volume\": 10, // 即使 \"balance\" 属性值是零, 它也应当被保留, // 因为 \"0\" 表示 \"均衡\" // \"-1\" 表示左倾斜和\"＋1\" 表示右倾斜 \"balance\": 0, // \"currentlyPlaying\" 是null的时候可被移除 // \"currentlyPlaying\": null }  枚举值 枚举值应当以字符串的形式呈现\n随着APIs的发展，枚举值可能被添加，移除或者改变。将枚举值当作字符串可以使下游用户优雅地处理枚举值的变更。\nJava代码：\npublic enum Color { WHITE, BLACK, RED, YELLOW, BLUE }  JSON对象：\n{ \"color\": \"WHITE\" }  属性值数据类型 上面提到，属性值必须是布尔(booleans), 数字(numbers), 字符串(strings), 对象(objects), 数组(arrays), 或 null. 然而在处理某些值时，定义一组标准的数据类型是非常有用的。这些数据类型必须始终是字符串，但是为了便于解析，它们也会以特定的方式被格式化。\n日期属性值 日期应该使用RFC3339建议的格式\n日期应该是RFC 3339所建议的字符串格式。\n{ \"lastUpdate\": \"2007-11-06T16:34:41.000Z\" }  时间间隔属性值 时间间隔应该使用ISO 8601建议的格式\n时间间隔应该是ISO 8601所建议的字符串格式。\n{ // 三年, 6个月, 4天, 12小时, // 三十分钟, 5秒 \"duration\": \"P3Y6M4DT12H30M5S\" }  纬度/经度属性值 纬度/经度应该使用ISO 6709建议的格式\n纬度/经度应该是ISO 6709所建议的字符串格式。 而且, 它应该更偏好使用 e Â±DD.DDDDÂ±DDD.DDDD 角度格式.\n{ // 自由女神像的纬度/经度位置. \"statueOfLiberty\": \"+40.6894-074.0447\" }  JSON结构和保留属性名 为了使APIs保持一致的接口，JSON对象应当使用以下的结构。该结构适用于JSON的请求和响应。在这个结构中，某些属性名将被保留用作特殊用途。这些属性并不是必需的，也就是说，每个保留的属性可能出现零次或一次。但是如果服务需要这些属性，建议遵循该命名条约。下面是一份JSON结构语义表，以Orderly格式呈现(现在已经被纳入 JSONSchema)。你可以在该指南的最后找到关于JSON结构的例子。\nobject { string apiVersion?; string context?; string id?; string method?; object { string id? }* params?; object { string kind?; string fields?; string etag?; string id?; string lang?; string updated?; # date formatted RFC 3339 boolean deleted?; integer currentItemCount?; integer itemsPerPage?; integer startIndex?; integer totalItems?; integer pageIndex?; integer totalPages?; string pageLinkTemplate /^https?:/ ?; object {}* next?; string nextLink?; object {}* previous?; string previousLink?; object {}* self?; string selfLink?; object {}* edit?; string editLink?; array [ object {}*; ] items?; }* data?; object { integer code?; string message?; array [ object { string domain?; string reason?; string message?; string location?; string locationType?; string extendedHelp?; string sendReport?; }*; ] errors?; }* error?; }*;  JSON对象有一些顶级属性，然后是data对象或error对象，这两者不会同时出现。下面是这些属性的解释。\n顶级保留属性名称 顶级的JSON对象可能包含下面这些属性\napiVersion 属性值类型: 字符串(string) 父节点: -  呈现请求中服务API期望的版本，以及在响应中保存的服务API版本。应随时提供apiVersion。这与数据的版本无关。将数据版本化应该通过其他的机制来处理，如etag。\n示例：\n{ \"apiVersion\": \"2.1\" }  context 属性值类型: 字符串(string) 父节点: -  客户端设置这个值，服务器通过数据作出回应。这在JSON-P和批处理中很有用，用户可以使用context将响应与请求关联起来。该属性是顶级属性，因为不管响应是成功还是有错误，context总应当被呈现出来。context不同于id在于context由用户提供而id由服务分配。\n示例：\n请求 #1:\nhttp://www.google.com/myapi?context=bart  请求 #2:\nhttp://www.google.com/myapi?context=lisa  响应 #1:\n{ \"context\": \"bart\", \"data\": { \"items\": [] } }  响应 #2:\n{ \"context\": \"lisa\", \"data\": { \"items\": [] } }  公共的JavaScript处理器通过编码同时处理以下两个响应：\nfunction handleResponse(response) { if (response.result.context == \"bart\") { // 更新页面中的 \"Bart\" 部分。 } else if (response.result.context == \"lisa\") { // 更新页面中的 \"Lisa\" 部分。 } }  id 属性值类型: 字符串(string) 父节点: -  服务提供用于识别响应的标识(无论请求是成功还是有错误)。这对于将服务日志和单独收到的响应对应起来很有用。\n示例：\n{ \"id\": \"1\" }  method 属性值类型: 字符串(string) 父节点: -  表示对数据即将执行，或已被执行的操作。在JSON请求的情况下，method属性可以用来指明对数据进行何种操作。在JSON响应的情况下，method属性表明对数据进行了何种操作。\n一个JSON-RPC请求的例子，其中method属性表示要在params上执行的操作：\n{ \"method\": \"people.get\", \"params\": { \"userId\": \"@me\", \"groupId\": \"@self\" } }  params 属性值类型: 对象(object) 父节点: -  这个对象作为输入参数的映射发送给RPC请求。它可以和method属性一起用来执行RPC功能。若RPC方法不需要参数，则可以省略该属性。\n示例：\n{ \"method\": \"people.get\", \"params\": { \"userId\": \"@me\", \"groupId\": \"@self\" } }  data 属性值类型: 对象(object) 父节点: -  包含响应的所有数据。该属性本身拥有许多保留属性名，下面会有相应的说明。服务可以自由地将自己的数据添加到这个对象。一个JSON响应要么应当包含一个data对象，要么应当包含error对象，但不能两者都包含。如果data和error同时出现，则error对象优先。\nerror 属性值类型: 对象(object) 父节点: -  表明错误发生，提供错误的详细信息。错误的格式支持从服务返回一个或多个错误。一个JSON响应可以有一个data对象或者一个error对象，但不能两者都包含。如果data和error都出现，error对象优先。\n示例：\n{ \"apiVersion\": \"2.0\", \"error\": { \"code\": 404, \"message\": \"File Not Found\", \"errors\": [{ \"domain\": \"Calendar\", \"reason\": \"ResourceNotFoundException\", \"message\": \"File Not Found }] } }  data对象的保留属性名 JSON对象的data属性可能包含以下属性。\ndata.kind 属性值类型: 字符串(sting) 父节点: data  kind属性是对某个特定的对象存储何种类型的信息的指南。可以把它放在data层次，或items的层次，或其它任何有助于区分各类对象的对象中。如果kind对象被提供，它应该是对象的第一个属性（详见下面的_属性顺序_部分）。\n示例：\n// \"Kind\" indicates an \"album\" in the Picasa API. {\"data\": {\"kind\": \"album\"}}  data.fields 属性值类型: 字符串(string) 父节点: data  表示做了部分GET之后响应中出现的字段，或做了部分PATCH之后出现在请求中的字段。该属性仅在做了部分GET请求/批处理时存在，且不能为空。\n示例：\n{ \"data\": { \"kind\": \"user\", \"fields\": \"author,id\", \"id\": \"bart\", \"author\": \"Bart\" } }\t data.etag 属性值类型: 字符串(string) 父节点: data  响应时提供etag。关于GData APIs中的ETags详情可以在这里找到：http://code.google.com/apis/gdata/docs/2.0/reference.html#ResourceVersioning\n示例：\n{\"data\": {\"etag\": \"W/\"C0QBRXcycSp7ImA9WxRVFUk.\"\"}}  data.id 属性值类型: 字符串(string) 父节点: data  一个全局唯一标识符用于引用该对象。id属性的具体细节都留给了服务。\n示例：\n{\"data\": {\"id\": \"12345\"}}  data.lang 属性值类型: 字符串(string)(格式由BCP 47指定) 父节点: data (或任何子元素)  表示该对象内其他属性的语言。该属性模拟HTML的lang属性和XML的xml:lang属性。值应该是BCP 47中定义的一种语言值。如果一个单一的JSON对象包含的数据有多种语言，服务负责制定和标明lang属性的适当位置。\n示例：\n{\"data\": { \"items\": [ { \"lang\": \"en\", \"title\": \"Hello world!\" }, { \"lang\": \"fr\", \"title\": \"Bonjour monde!\" } ]} }  data.updated 属性值类型: 字符串(string)(格式由RFC 3339指定) 父节点: data  指明条目更新的最后日期/时间(RFC 3339)，由服务规定。\n示例：\n{\"data\": {\"updated\": \"2007-11-06T16:34:41.000Z\"}}  data.deleted 属性值类型: 布尔(boolean) 父节点: data (或任何子元素)  一个标记元素，当出现时，表示包含的条目已被删除。如果提供了删除属性，它的值必须为true;为false会导致混乱，应该避免。\n示例：\n{\"data\": { \"items\": [ { \"title\": \"A deleted entry\", \"deleted\": true } ]} }  data.items 属性值类型: 数组(array) 父节点: data  属性名items被保留用作表示一组条目(例如,Picasa中的图片，YouTube中的视频)。这种结构的目的是给与当前结果相关的集合提供一个标准位置。例如，知道页面上的items是数组，JSON输出便可能插入一个通用的分页系统。如果items存在，它应该是data对象的最后一个属性。（详见下面的_属性顺序_部分）。\n示例：\n{ \"data\": { \"items\": [ { /* Object #1 */ }, { /* Object #2 */ }, ... ] } }  用于分页的保留属性名 下面的属性位于data对象中，用来给一列数据分页。一些语言和概念是从OpenSearch规范中借鉴过来的。\n下面的分页数据允许各种风格的分页，包括：\n 上一页/下一页 - 允许用户在列表中前进和后退，一次一页。nextLink 和previousLink属性 (下面的\"链接保留属性名\"部分有描述) 用于这种风格的分页。 基于索引的分页 - 允许用户直接跳到条目列表的某个条目位置。例如，要从第200个条目开始载入10个新的条目，开发者可以给用户提供一个URL的查询字符串*?startIndex=200*。 基于页面的分页 - 允许用户直接跳到条目内的具体页。这跟基于索引的分页很类似,但节省了开发者额外的步骤，不需再为新一页的条目计算条目索引。例如，开发人员可以直接跳到第20页，而不是跳到第200条条目。基于页面分页的网址，可以使用查询字符串*?page=1*或*?page=20*。*pageIndex*和 *totalPages* 属性用作这种风格的分页.  在这份指南的最后可以找到如何使用这些属性来实现分页的例子。\ndata.currentItemCount 属性值类型: 整数(integer) 父节点: data  结果集中的条目数目。应该与items.length相等，并作为一个便利属性提供。例如，假设开发者请求一组搜索条目，并且要求每页10条。查询集共有14条。第一个条目页将会有10个条目，因此itemsPerPage和currentItemCount都应该等于10。下一页的条目还剩下4条；itemsPerPage仍然是10,但是currentItemCount是4.\n示例：\n{ \"data\": { // \"itemsPerPage\" 不需要与 \"currentItemCount\" 匹配 \"itemsPerPage\": 10, \"currentItemCount\": 4 } }  data.itemsPerPage 属性值类型: 整数(integer) 父节点: data  items结果的数目。未必是data.items数组的大小；如果我们查看的是最后一页，data.items的大小可能小于itemsPerPage。但是，data.items的大小不应超过itemsPerPage。\n示例：\n{ \"data\": { \"itemsPerPage\": 10 } }  data.startIndex 属性值类型: 整数(integer) 父节点: data  data.items中第一个条目的索引。为了一致，startIndex应从1开始。例如，第一组items中第一条的startIndex应该是1。如果用户请求下一组数据，startIndex可能是10。\n示例：\n{ \"data\": { \"startIndex\": 1 } }  data.totalItems 属性值类型: 整数(integer) 父节点: data  当前集合中可用的总条目数。例如，如果用户有100篇博客文章，响应可能只包含10篇，但是totalItems应该是100。\n示例：\n{ \"data\": { \"totalItems\": 100 } }  data.pagingLinkTemplate 属性值类型: 字符串(string) 父节点: data  URL模板指出用户可以如何计算随后的分页链接。URL模板中也包含一些保留变量名：表示要载入的条目的*{index}*，和要载入的页面的*{pageIndex}*。\n示例：\n{ \"data\": { \"pagingLinkTemplate\": \"http://www.google.com/search/hl=en\u0026q=chicago+style+pizza\u0026start={index}\u0026sa=N\" } }  data.pageIndex 属性值类型: 整数(integer) 父节点: data  条目的当前页索引。为了一致，pageIndex应从1开始。例如，第一页的pageIndex是1。pageIndex也可以通过基于条目的分页而计算出来pageIndex = floor(startIndex / itemsPerPage) + 1。\n示例：\n{ \"data\": { \"pageIndex\": 1 } }  data.totalPages 属性值类型: 整数(integer) 父节点: data  当前结果集中的总页数。totalPages也可以通过上面基于条目的分页属性计算出来: totalPages = ceiling(totalItems / itemsPerPage).。\n示例：\n{ \"data\": { \"totalPages\": 50 } }  用于链接的保留属性名 下面的属性位于data对象中，用来表示对其他资源的引用。有两种形式的链接属性：1）对象，它可以包含任何种类的引用（比如JSON-RPC对象），2)URL字符串，表示资源的URIs(后缀总为’Link')。\ndata.self / data.selfLink 属性值类型: 对象(object)/字符串(string) 父节点: data  自身链接可以用于取回条目数据。比如，在用户的Picasa相册中，条目中的每个相册对象都会包含一个selfLink用于检索这个相册的相关数据。\n示例：\n{ \"data\": { \"self\": { }, \"selfLink\": \"http://www.google.com/feeds/album/1234\" } }  data.edit / data.editLink 属性值类型: 对象(object)/字符串(string) 父节点: data  编辑链接表明用户可以发送更新或删除请求。这对于REST风格的APIs很有用。该链接仅在用户能够更新和删除该条目时提供。\n示例：\n{ \"data\": { \"edit\": { }, \"editLink\": \"http://www.google.com/feeds/album/1234/edit\" } }  data.next / data.nextLink 属性值类型: 对象(object)/字符串(string) 父节点: data  该下一页链接标明如何取得更多数据。它指明载入下一组数据的位置。它可以同itemsPerPage，startIndex 和 totalItems\t属性一起使用用于分页数据。\n示例：\n{ \"data\": { \"next\": { }, \"nextLink\": \"http://www.google.com/feeds/album/1234/next\" } }  data.previous / data.previousLink 属性值类型: 对象(object)/字符串(string) 父节点: data  该上一页链接标明如何取得更多数据。它指明载入上一组数据的位置。它可以连同itemsPerPage，startIndex 和 totalItems\t属性用于分页数据。\n示例：\n{ \"data\": { \"previous\": { }, \"previousLink\": \"http://www.google.com/feeds/album/1234/next\" } }  错误对象中的保留属性名 JSON对象的error属性应包含以下属性。\nerror.code 属性值类型: 整数(integer) 父节点: error  表示该错误的编号。这个属性通常表示HTTP响应码。如果存在多个错误，code应为第一个出错的错误码。\n示例：\n{ \"error\":{ \"code\": 404 } }  error.message 属性值类型: 字符串(string) 父节点: error  一个人类可读的信息，提供有关错误的详细信息。如果存在多个错误，message应为第一个错误的错误信息。\n示例：\n{ \"error\":{ \"message\": \"File Not Found\" } }\t error.errors 属性值类型: 数组(array) 父节点: error  包含关于错误的附加信息。如果服务返回多个错误。errors数组中的每个元素表示一个不同的错误。\n示例：\n{ \"error\": { \"errors\": [] } }\t error.errors[].domain 属性值类型: 字符串(string) 父节点: error.errors  服务抛出该错误的唯一识别符。它帮助区分服务的从普通协议错误(如,找不到文件)中区分出具体错误(例如，给日历插入事件的错误)。\n示例：\n{ \"error\":{ \"errors\": [{\"domain\": \"Calendar\"}] } }  error.errors[].reason 属性值类型: 字符串(string) 父节点: error.errors  该错误的唯一识别符。不同于error.code属性，它不是HTTP响应码。\n示例：\n{ \"error\":{ \"errors\": [{\"reason\": \"ResourceNotFoundException\"}] } }  error.errors[].message 属性值类型: 字符串(string) 父节点: error.errors  一个人类可读的信息，提供有关错误的更多细节。如果只有一个错误，该字段应该与error.message匹配。\n示例：\n{ \"error\":{ \"code\": 404 \"message\": \"File Not Found\", \"errors\": [{\"message\": \"File Not Found\"}] } }\t error.errors[].location 属性值类型: 字符串(string) 父节点: error.errors  错误发生的位置（根据locationType字段解释该值）。\n示例：\n{ \"error\":{ \"errors\": [{\"location\": \"\"}] } }  error.errors[].locationType 属性值类型: 字符串(string) 父节点: error.errors  标明如何解释location属性。\n示例：\n{ \"error\":{ \"errors\": [{\"locationType\": \"\"}] } }  error.errors[].extendedHelp 属性值类型: 字符串(string) 父节点: error.errors  help text的URI，使错误更易于理解。\n示例：（注：原示例这里有笔误，中文版这里做了校正）\n{ \"error\":{ \"errors\": [{\"extendedHelp\": \"http://url.to.more.details.example.com/\"}] } }  error.errors[].sendReport 属性值类型: 字符串(string) 父节点: error.errors  report form的URI，服务用它来收集错误状态的数据。该URL会预先载入描述请求的参数\n示例：\n{ \"error\":{ \"errors\": [{\"sendReport\": \"http://report.example.com/\"}] } }  属性顺序 在JSON对象中属性可有任意顺序。然而，在某些情况下，有序的属性可以帮助分析器快速解释数据，并带来更好的性能。在移动环境下的解析器就是个例子，在这种情况下，性能和内存是至关重要的，不必要的解析也应尽量避免。\nKind属性 Kind属性应为第一属性\n假设一个解析器负责将一个原始JSON流解析成一个特定的对象。kind属性会引导解析器将适合的对象实例化。因而它应该是JSON对象的第一个属性。这仅适用于对象有一个kind属性的情况(通常可以在data和items属性中找到)。\nItems属性 _items_应该是_data_对象的最后一个属性\n这使得阅读每一个具体条目前前已读所有的集合属性。在有很多条目的情况下，这样就避免了开发人员只需要从数据的字段时不必要的解析这些条目。\n这让阅读所有集合属性先于阅读单个条目。如遇多个条目的情况，当开发者仅需要数据中的字段时，这就可避免解析不必要的条目。\n属性顺序示例：\n// \"kind\" 属性区分 \"album\" 和 \"photo\". // \"Kind\" 始终是它父对象的第一个属性. // \"items\" 属性是 \"data\" 对象的最后一个属性. { \"data\": { \"kind\": \"album\", \"title\": \"My Photo Album\", \"description\": \"An album in the user's account\", \"items\": [ { \"kind\": \"photo\", \"title\": \"My First Photo\" } ] } }  示例 YouTube JSON API 这是YouTube JSON API响应对象的示例。你可以从中学到更多关于YouTube JSON API的内容：http://code.google.com/apis/youtube/2.0/developers_guide_jsonc.html\n{ \"apiVersion\": \"2.0\", \"data\": { \"updated\": \"2010-02-04T19:29:54.001Z\", \"totalItems\": 6741, \"startIndex\": 1, \"itemsPerPage\": 1, \"items\": [ { \"id\": \"BGODurRfVv4\", \"uploaded\": \"2009-11-17T20:10:06.000Z\", \"updated\": \"2010-02-04T06:25:57.000Z\", \"uploader\": \"docchat\", \"category\": \"Animals\", \"title\": \"From service dog to SURFice dog\", \"description\": \"Surf dog Ricochets inspirational video ...\", \"tags\": [ \"Surf dog\", \"dog surfing\", \"dog\", \"golden retriever\", ], \"thumbnail\": { \"default\": \"http://i.ytimg.com/vi/BGODurRfVv4/default.jpg\", \"hqDefault\": \"http://i.ytimg.com/vi/BGODurRfVv4/hqdefault.jpg\" }, \"player\": { \"default\": \"http://www.youtube.com/watch?v=BGODurRfVv4\u0026feature=youtube_gdata\", \"mobile\": \"http://m.youtube.com/details?v=BGODurRfVv4\" }, \"content\": { \"1\": \"rtsp://v5.cache6.c.youtube.com/CiILENy73wIaGQn-Vl-0uoNjBBMYDSANFEgGUgZ2aWRlb3MM/0/0/0/video.3gp\", \"5\": \"http://www.youtube.com/v/BGODurRfVv4?f=videos\u0026app=youtube_gdata\", \"6\": \"rtsp://v7.cache7.c.youtube.com/CiILENy73wIaGQn-Vl-0uoNjBBMYESARFEgGUgZ2aWRlb3MM/0/0/0/video.3gp\" }, \"duration\": 315, \"rating\": 4.96, \"ratingCount\": 2043, \"viewCount\": 1781691, \"favoriteCount\": 3363, \"commentCount\": 1007, \"commentsAllowed\": true } ] } }  分页示例 如何将Google搜索条目作为JSON对象展现出来，对分页变量也有特别关注。\n这个示例仅用作说明。下面的API实际上并不存在。\n这是Google搜索结果页面的示例： 这是该页面JSON形式的呈现：\n{ \"apiVersion\": \"2.1\", \"id\": \"1\", \"data\": { \"query\": \"chicago style pizza\", \"time\": \"0.1\", \"currentItemCount\": 10, \"itemsPerPage\": 10, \"startIndex\": 11, \"totalItems\": 2700000, \"nextLink\": \"http://www.google.com/search?hl=en\u0026q=chicago+style+pizza\u0026start=20\u0026sa=N\" \"previousLink\": \"http://www.google.com/search?hl=en\u0026q=chicago+style+pizza\u0026start=0\u0026sa=N\", \"pagingLinkTemplate\": \"http://www.google.com/search/hl=en\u0026q=chicago+style+pizza\u0026start={index}\u0026sa=N\", \"items\": [ { \"title\": \"Pizz'a Chicago Home Page\" // More fields for the search results } // More search results ] } }  这是如何展现屏幕截图中的色块的例子（背景颜色对应下图中的颜色）\n Results 11- 20 of about 2,700,000 = startIndex Results 11 - 20of about 2,700,000 = startIndex + currentItemCount - 1 Results 11 - 20 of about 2,700,000= totalItems Search results= items (formatted appropriately) Previous/Next= previousLink / nextLink Numbered links in “Gooooooooooogle”= Derived from “pageLinkTemplate”. The developer is responsible for calculating the values for {index} and substituting those values into the “pageLinkTemplate”. The pageLinkTemplate’s {index} variable is calculated as follows:  Index #1 = 0 * itemsPerPage = 0 Index #2 = 2 * itemsPerPage = 10 Index #3 = 3 * itemsPerPage = 20 Index #N = N * itemsPerPage    附录 附录A:JavaScript中的保留字 下列JavaScript保留字应该避免在属性名中使用\n下面的清单是JavaScript中的保留字，并不能通过点访问符访问。这份清单集合了当前最新的关键字，该清单可能会根据具体的执行环境而有所变更。\n来自ECMAScript 语言规范第五版\nabstract boolean break byte case catch char class const continue debugger default delete do double else enum export extends false final finally float for function goto if implements import in instanceof int interface let long native new null package private protected public return short static super switch synchronized this throw throws transient true try typeof var volatile void while with yield  除了特别说明，该页面的内容均由共同创作协议(CC BY 3.0)授权许可，示例代码均由Apache 2.0许可证授权许可）\n－EOF-\n",
  "wordCount" : "9561",
  "inLanguage": "zh-cn",
  "datePublished": "2020-04-29T16:17:43Z",
  "dateModified": "2020-04-29T16:17:43Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/json%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      JSON风格指南
    </h1>
    <div class="post-meta">April 29, 2020
</div>
  </header> 
  <div class="post-content"><h1 id="json风格指南">JSON风格指南<a hidden class="anchor" aria-hidden="true" href="#json风格指南">#</a></h1>
<p>版本：0.9</p>
<p>英文版：<a href="https://google.github.io/styleguide/jsoncstyleguide.xml">https://google.github.io/styleguide/jsoncstyleguide.xml</a></p>
<p>翻译：Darcy Liu</p>
<p>译文状态：草稿</p>
<h2 id="简介">简介<a hidden class="anchor" aria-hidden="true" href="#简介">#</a></h2>
<p>该风格指南是对在Google创建JSON APIs而提供的指导性准则和建议。总体来讲，JSON APIs应遵循JSON.org上的规范。这份风格指南澄清和标准化了特定情况，从而使Google的JSON APIs有一种标准的外观和感觉。这些指南适用于基于RPC和基于REST风格的API的JSON请求和响应。</p>
<h2 id="定义">定义<a hidden class="anchor" aria-hidden="true" href="#定义">#</a></h2>
<p>为了更好地实现这份风格指南的目的，下面几项需要说明：</p>
<ul>
<li>属性(property) - JSON对象内的键值对(name/value pair)</li>
<li>属性名(property name) - 属性的名称(或键)</li>
<li>属性值(property value) - 分配给属性的值</li>
</ul>
<p>示例：</p>
<pre><code>{
  // 一组键值对称作一个 &quot;属性&quot;.
  &quot;propertyName&quot;: &quot;propertyValue&quot;
}
</code></pre>
<p>Javascript的数字(<em>number</em>)包含所有的浮点数,这是一个宽泛的指定。在这份指南中，数字(<em>number</em>)指代Javascript中的数字(<em>number</em>)类型，而整型(<em>integer</em>)则指代整型。</p>
<h2 id="一般准则">一般准则<a hidden class="anchor" aria-hidden="true" href="#一般准则">#</a></h2>
<h3 id="注释">注释<a hidden class="anchor" aria-hidden="true" href="#注释">#</a></h3>
<p><strong>JSON对象中不包含注释。</strong></p>
<p>JSON对象中不应该包含注释。该指南中的某些示例含有注释。但这仅仅是为了说明示例。</p>
<pre><code>{
  // 你可能在下面的示例中看到注释,
  // 但不要在你的JSON数据中加入注释.
  &quot;propertyName&quot;: &quot;propertyValue&quot;
}
</code></pre>
<h3 id="双引号">双引号<a hidden class="anchor" aria-hidden="true" href="#双引号">#</a></h3>
<p><strong>使用双引号</strong></p>
<p>如果（某个）属性需要引号，则必须使用双引号。所有的属性名必须在双引号内。字符类型的属性值必须使用双引号。其它类型值（如布尔或数字）不应该使用双引号。</p>
<h3 id="扁平化数据-vs-结构层次">扁平化数据 VS 结构层次<a hidden class="anchor" aria-hidden="true" href="#扁平化数据-vs-结构层次">#</a></h3>
<p><strong>不能为了方便而将数据任意分组</strong></p>
<p>JSON中的数据元素应以<em>扁平化</em>方式呈现。不能为了方便而将数据任意分组。</p>
<p>在某些情况下，比如描述单一结构的一批属性，因为它被用来保持结构层次，因而是有意义的。但是遇到这些情况还是应当慎重考虑，记住只有语义上有意义的时候才使用它。例如，一个地址可以有表示两种方式，但结构化的方式对开发人员来讲可能更有意义：</p>
<p>扁平化地址:</p>
<pre><code>{
  &quot;company&quot;: &quot;Google&quot;,
  &quot;website&quot;: &quot;http://www.google.com/&quot;,
  &quot;addressLine1&quot;: &quot;111 8th Ave&quot;,
  &quot;addressLine2&quot;: &quot;4th Floor&quot;,
  &quot;state&quot;: &quot;NY&quot;,
  &quot;city&quot;: &quot;New York&quot;,
  &quot;zip&quot;: &quot;10011&quot;
}
</code></pre>
<p>结构化地址：</p>
<pre><code>{
  &quot;company&quot;: &quot;Google&quot;,
  &quot;website&quot;: &quot;http://www.google.com/&quot;,
  &quot;address&quot;: {
    &quot;line1&quot;: &quot;111 8th Ave&quot;,
    &quot;line2&quot;: &quot;4th Floor&quot;,
    &quot;state&quot;: &quot;NY&quot;,
    &quot;city&quot;: &quot;New York&quot;,
    &quot;zip&quot;: &quot;10011&quot;
  }
}
</code></pre>
<h2 id="属性名准则">属性名准则<a hidden class="anchor" aria-hidden="true" href="#属性名准则">#</a></h2>
<h3 id="属性名格式">属性名格式<a hidden class="anchor" aria-hidden="true" href="#属性名格式">#</a></h3>
<p><strong>选择有意义的属性名</strong></p>
<p>属性名必须遵循以下准则:</p>
<ul>
<li>属性名应该是具有定义语义的有意义的名称。</li>
<li>属性名必须是驼峰式的，ASCII码字符串。</li>
<li>首字符必须是字母，下划线(<em>_</em>)或美元符号(<em>$</em>)。</li>
<li>随后的其他字符可以是字母，数字，下划线(<em>_</em>)或美元符号(<em>$</em>)。</li>
<li>应该避免使用Javascript中的保留关键字(下文附有Javascript保留字清单)</li>
</ul>
<p>这些准则反映JavaScript标识符命名的指导方针。使JavaScript的客户端可以使用点符号来访问属性。(例如, <code>result.thisIsAnInstanceVariable</code>).</p>
<p>下面是一个对象的一个属性的例子：</p>
<pre><code>{
  &quot;thisPropertyIsAnIdentifier&quot;: &quot;identifier value&quot;
}
</code></pre>
<h3 id="json-map中的键名">JSON Map中的键名<a hidden class="anchor" aria-hidden="true" href="#json-map中的键名">#</a></h3>
<p><strong>在JSON Map中键名可以使用任意Unicode字符</strong></p>
<p>当JSON对象作为Map(映射)使用时，属性的名称命名规则并不适用。Map（也称作关联数组）是一个具有任意键/值对的数据类型，这些键/值对通过特定的键来访问相应的值。JSON对象和JSON Map在运行时看起来是一样的；这个特性与API设计相关。当JSON对象被当作map使用时，API文件应当做出说明。</p>
<p>Map的键名不一定要遵循属性名称的命名准则。键名可以包含任意的Unicode字符。客户端可使用maps熟悉的方括号来访问这些属性。（例如<code>result.thumbnails[&quot;72&quot;]</code>）</p>
<pre><code>{
  // &quot;address&quot; 属性是一个子对象
  // 包含地址的各部分.
  &quot;address&quot;: {
    &quot;addressLine1&quot;: &quot;123 Anystreet&quot;,
    &quot;city&quot;: &quot;Anytown&quot;,
    &quot;state&quot;: &quot;XX&quot;,
    &quot;zip&quot;: &quot;00000&quot;
  },
  // &quot;address&quot; 是一个映射
  // 含有响应规格所对应的URL，用来映射thumbnail url的像素规格
  &quot;thumbnails&quot;: {
    &quot;72&quot;: &quot;http://url.to.72px.thumbnail&quot;,
    &quot;144&quot;: &quot;http://url.to.144px.thumbnail&quot;
  }
}
</code></pre>
<h3 id="保留的属性名称">保留的属性名称<a hidden class="anchor" aria-hidden="true" href="#保留的属性名称">#</a></h3>
<p><strong>某些属性名称会被保留以便能在多个服务间相容使用</strong></p>
<p>保留属性名称的详细信息，连同完整的列表，可在本指南后面的内容中找到。服务应按照被定义的语义来使用属性名称。</p>
<h3 id="单数属性名-vs-复数属性名">单数属性名 VS 复数属性名<a hidden class="anchor" aria-hidden="true" href="#单数属性名-vs-复数属性名">#</a></h3>
<p><strong>数组类型应该是复数属性名。其它属性名都应该是单数。</strong></p>
<p>数组通常包含多个条目，复数属性名就反映了这点。在下面这个保留名称中可以看到例子。属性名<em>items</em>是复数因为它描述的是一组对象。大多数的其它字段是单数。</p>
<p>当然也有例外，尤其是涉及到数字的属性值的时候。例如，在保留属性名中，<em>totalItems</em> 比 <em>totalItem</em>更合理。然后，从技术上讲，这并不违反风格指南，因为 <em>totalItems</em> 可以被看作 <em>totalOfItems</em>, 其中 <em>total</em> 是单数（依照风格指南），<em>OfItems</em> 用来限定总数。字段名也可被改为 <em>itemCount</em>，这样看起来更象单数.</p>
<pre><code>{
  // 单数
  &quot;author&quot;: &quot;lisa&quot;,
  // 一组同胞, 复数
  &quot;siblings&quot;: [ &quot;bart&quot;, &quot;maggie&quot;],
  // &quot;totalItem&quot; 看起来并不对
  &quot;totalItems&quot;: 10,
  // 但 &quot;itemCount&quot; 要好些
  &quot;itemCount&quot;: 10
}
</code></pre>
<h3 id="命名冲突">命名冲突<a hidden class="anchor" aria-hidden="true" href="#命名冲突">#</a></h3>
<p><strong>通过选择新的属性名或将API版本化来避免命名冲突</strong></p>
<p>新的属性可在将来被添加进保留列表中。JSON中不存在命名空间。如果存在命名冲突，可通过选择新的属性名或者版本化来解决这个问题。例如，假设我们由下面的JSON对象开始：</p>
<pre><code>{
  &quot;apiVersion&quot;: &quot;1.0&quot;,
  &quot;data&quot;: {
    &quot;recipeName&quot;: &quot;pizza&quot;,
    &quot;ingredients&quot;: [&quot;tomatoes&quot;, &quot;cheese&quot;, &quot;sausage&quot;]
  }
}
</code></pre>
<p>如果我们希望将来把<em>ingredients</em>列为保留字，我们可以通过下面两件事情来达成:</p>
<p>1.选一个不同的名字</p>
<pre><code>{
  &quot;apiVersion&quot;: &quot;1.0&quot;,
  &quot;data&quot;: {
    &quot;recipeName&quot;: &quot;pizza&quot;,
    &quot;ingredientsData&quot;: &quot;Some new property&quot;,
    &quot;ingredients&quot;: [&quot;tomatoes&quot;, &quot;cheese&quot;, &quot;sausage&quot;]
  }
}
</code></pre>
<p>2.在主版本上重新命名属性</p>
<pre><code>{
  &quot;apiVersion&quot;: &quot;2.0&quot;,
  &quot;data&quot;: {
    &quot;recipeName&quot;: &quot;pizza&quot;,
    &quot;ingredients&quot;: &quot;Some new property&quot;,
    &quot;recipeIngredients&quot;: [&quot;tomatos&quot;, &quot;cheese&quot;, &quot;sausage&quot;]
  }
}
</code></pre>
<h2 id="属性值准则">属性值准则<a hidden class="anchor" aria-hidden="true" href="#属性值准则">#</a></h2>
<h3 id="属性值格式">属性值格式<a hidden class="anchor" aria-hidden="true" href="#属性值格式">#</a></h3>
<p><strong>属性值必须是Unicode 的 booleans（布尔）, 数字(numbers), 字符串(strings), 对象(objects), 数组(arrays), 或 null.</strong></p>
<p>JSON.org上的标准准确地说明了哪些类型的数据可以作为属性值。这包含Unicode的布尔(booleans), 数字(numbers), 字符串(strings), 对象(objects), 数组(arrays), 或 null。JavaScript表达式是不被接受的。APIs应该支持该准则，并为某个特定的属性选择最合适的数据类型（比如，用numbers代表numbers等）。</p>
<p>好的例子：</p>
<pre><code>{
  &quot;canPigsFly&quot;: null,     // null
  &quot;areWeThereYet&quot;: false, // boolean
  &quot;answerToLife&quot;: 42,     // number
  &quot;name&quot;: &quot;Bart&quot;,         // string
  &quot;moreData&quot;: {},         // object
  &quot;things&quot;: []            // array
}
</code></pre>
<p>不好的例子：</p>
<pre><code>{
  &quot;aVariableName&quot;: aVariableName,         // Bad - JavaScript 标识符
  &quot;functionFoo&quot;: function() { return 1; } // Bad - JavaScript 函数
}
</code></pre>
<h3 id="空或null-属性值">空或Null 属性值<a hidden class="anchor" aria-hidden="true" href="#空或null-属性值">#</a></h3>
<p><strong>考虑移除空或null值</strong></p>
<p>如果一个属性是可选的或者包含空值或<em>null</em>值，考虑从JSON中去掉该属性，除非它的存在有很强的语义原因。</p>
<pre><code>{
  &quot;volume&quot;: 10,

  // 即使 &quot;balance&quot; 属性值是零, 它也应当被保留,
  // 因为 &quot;0&quot; 表示 &quot;均衡&quot; 
  // &quot;-1&quot; 表示左倾斜和&quot;＋1&quot; 表示右倾斜
  &quot;balance&quot;: 0,

  // &quot;currentlyPlaying&quot; 是null的时候可被移除
  // &quot;currentlyPlaying&quot;: null
}
</code></pre>
<h3 id="枚举值">枚举值<a hidden class="anchor" aria-hidden="true" href="#枚举值">#</a></h3>
<p><strong>枚举值应当以字符串的形式呈现</strong></p>
<p>随着APIs的发展，枚举值可能被添加，移除或者改变。将枚举值当作字符串可以使下游用户优雅地处理枚举值的变更。</p>
<p>Java代码：</p>
<pre><code>public enum Color {
  WHITE,
  BLACK,
  RED,
  YELLOW,
  BLUE
}
</code></pre>
<p>JSON对象：</p>
<pre><code>{
  &quot;color&quot;: &quot;WHITE&quot;
}
</code></pre>
<h2 id="属性值数据类型">属性值数据类型<a hidden class="anchor" aria-hidden="true" href="#属性值数据类型">#</a></h2>
<p>上面提到，属性值必须是布尔(booleans), 数字(numbers), 字符串(strings), 对象(objects), 数组(arrays), 或 null. 然而在处理某些值时，定义一组标准的数据类型是非常有用的。这些数据类型必须始终是字符串，但是为了便于解析，它们也会以特定的方式被格式化。</p>
<h3 id="日期属性值">日期属性值<a hidden class="anchor" aria-hidden="true" href="#日期属性值">#</a></h3>
<p><strong>日期应该使用RFC3339建议的格式</strong></p>
<p>日期应该是RFC 3339所建议的字符串格式。</p>
<pre><code>{
  &quot;lastUpdate&quot;: &quot;2007-11-06T16:34:41.000Z&quot;
}
</code></pre>
<h3 id="时间间隔属性值">时间间隔属性值<a hidden class="anchor" aria-hidden="true" href="#时间间隔属性值">#</a></h3>
<p><strong>时间间隔应该使用ISO 8601建议的格式</strong></p>
<p>时间间隔应该是ISO 8601所建议的字符串格式。</p>
<pre><code>{
  // 三年, 6个月, 4天, 12小时,
  // 三十分钟, 5秒
  &quot;duration&quot;: &quot;P3Y6M4DT12H30M5S&quot;
}
</code></pre>
<h3 id="纬度经度属性值">纬度/经度属性值<a hidden class="anchor" aria-hidden="true" href="#纬度经度属性值">#</a></h3>
<p><strong>纬度/经度应该使用ISO 6709建议的格式</strong></p>
<p>纬度/经度应该是ISO 6709所建议的字符串格式。
而且, 它应该更偏好使用 e Â±DD.DDDDÂ±DDD.DDDD 角度格式.</p>
<pre><code>{
  // 自由女神像的纬度/经度位置.
  &quot;statueOfLiberty&quot;: &quot;+40.6894-074.0447&quot;
}
</code></pre>
<h2 id="json结构和保留属性名">JSON结构和保留属性名<a hidden class="anchor" aria-hidden="true" href="#json结构和保留属性名">#</a></h2>
<p>为了使APIs保持一致的接口，JSON对象应当使用以下的结构。该结构适用于JSON的请求和响应。在这个结构中，某些属性名将被保留用作特殊用途。这些属性并不是必需的，也就是说，每个保留的属性可能出现零次或一次。但是如果服务需要这些属性，建议遵循该命名条约。下面是一份JSON结构语义表，以Orderly格式呈现(现在已经被纳入 JSONSchema)。你可以在该指南的最后找到关于JSON结构的例子。</p>
<pre><code>object {
  string apiVersion?;
  string context?;
  string id?;
  string method?;
  object {
    string id?
  }* params?;
  object {
    string kind?;
    string fields?;
    string etag?;
    string id?;
    string lang?;
    string updated?; # date formatted RFC 3339
    boolean deleted?;
    integer currentItemCount?;
    integer itemsPerPage?;
    integer startIndex?;
    integer totalItems?;
    integer pageIndex?;
    integer totalPages?;
    string pageLinkTemplate /^https?:/ ?;
    object {}* next?;
    string nextLink?;
    object {}* previous?;
    string previousLink?;
    object {}* self?;
    string selfLink?;
    object {}* edit?;
    string editLink?;
    array [
      object {}*;
    ] items?;
  }* data?;
  object {
    integer code?;
    string message?;
    array [
      object {
        string domain?;
        string reason?;
        string message?;
        string location?;
        string locationType?;
        string extendedHelp?;
        string sendReport?;
      }*;
    ] errors?;
  }* error?;
}*;
</code></pre>
<p>JSON对象有一些顶级属性，然后是<em>data</em>对象或<em>error</em>对象，这两者不会同时出现。下面是这些属性的解释。</p>
<h2 id="顶级保留属性名称">顶级保留属性名称<a hidden class="anchor" aria-hidden="true" href="#顶级保留属性名称">#</a></h2>
<p><strong>顶级的JSON对象可能包含下面这些属性</strong></p>
<h3 id="apiversion">apiVersion<a hidden class="anchor" aria-hidden="true" href="#apiversion">#</a></h3>
<pre><code>属性值类型: 字符串(string)
父节点: -
</code></pre>
<p>呈现请求中服务API期望的版本，以及在响应中保存的服务API版本。应随时提供<em>apiVersion</em>。这与数据的版本无关。将数据版本化应该通过其他的机制来处理，如etag。</p>
<p>示例：</p>
<pre><code>{ &quot;apiVersion&quot;: &quot;2.1&quot; }
</code></pre>
<h3 id="context">context<a hidden class="anchor" aria-hidden="true" href="#context">#</a></h3>
<pre><code>属性值类型: 字符串(string)
父节点: -
</code></pre>
<p>客户端设置这个值，服务器通过数据作出回应。这在JSON-P和批处理中很有用，用户可以使用<em>context</em>将响应与请求关联起来。该属性是顶级属性，因为不管响应是成功还是有错误，<em>context</em>总应当被呈现出来。<em>context</em>不同于<em>id</em>在于<em>context</em>由用户提供而<em>id</em>由服务分配。</p>
<p>示例：</p>
<p>请求 #1:</p>
<pre><code>http://www.google.com/myapi?context=bart
</code></pre>
<p>请求 #2:</p>
<pre><code>http://www.google.com/myapi?context=lisa
</code></pre>
<p>响应 #1:</p>
<pre><code>{
  &quot;context&quot;: &quot;bart&quot;,
  &quot;data&quot;: {
    &quot;items&quot;: []
  }
}
</code></pre>
<p>响应 #2:</p>
<pre><code>{
  &quot;context&quot;: &quot;lisa&quot;,
  &quot;data&quot;: {
    &quot;items&quot;: []
  }
}
</code></pre>
<p>公共的JavaScript处理器通过编码同时处理以下两个响应：</p>
<pre><code>function handleResponse(response) {
  if (response.result.context == &quot;bart&quot;) {
    // 更新页面中的 &quot;Bart&quot; 部分。
  } else if (response.result.context == &quot;lisa&quot;) {
    // 更新页面中的 &quot;Lisa&quot; 部分。
  }
}
</code></pre>
<h3 id="id">id<a hidden class="anchor" aria-hidden="true" href="#id">#</a></h3>
<pre><code>属性值类型: 字符串(string)
父节点: -
</code></pre>
<p>服务提供用于识别响应的标识(无论请求是成功还是有错误)。这对于将服务日志和单独收到的响应对应起来很有用。</p>
<p>示例：</p>
<pre><code>{ &quot;id&quot;: &quot;1&quot; }
</code></pre>
<h3 id="method">method<a hidden class="anchor" aria-hidden="true" href="#method">#</a></h3>
<pre><code>属性值类型: 字符串(string)
父节点: -
</code></pre>
<p>表示对数据即将执行，或已被执行的操作。在JSON请求的情况下，<em>method</em>属性可以用来指明对数据进行何种操作。在JSON响应的情况下，<em>method</em>属性表明对数据进行了何种操作。</p>
<p>一个JSON-RPC请求的例子，其中<em>method</em>属性表示要在<em>params</em>上执行的操作：</p>
<pre><code>{
  &quot;method&quot;: &quot;people.get&quot;,
  &quot;params&quot;: {
    &quot;userId&quot;: &quot;@me&quot;,
    &quot;groupId&quot;: &quot;@self&quot;
  }
}
</code></pre>
<h3 id="params">params<a hidden class="anchor" aria-hidden="true" href="#params">#</a></h3>
<pre><code>属性值类型: 对象(object)
父节点: -
</code></pre>
<p>这个对象作为输入参数的映射发送给RPC请求。它可以和<em>method</em>属性一起用来执行RPC功能。若RPC方法不需要参数，则可以省略该属性。</p>
<p>示例：</p>
<pre><code>{
  &quot;method&quot;: &quot;people.get&quot;,
  &quot;params&quot;: {
    &quot;userId&quot;: &quot;@me&quot;,
    &quot;groupId&quot;: &quot;@self&quot;
  }
}
</code></pre>
<h3 id="data">data<a hidden class="anchor" aria-hidden="true" href="#data">#</a></h3>
<pre><code>属性值类型: 对象(object)
父节点: -
</code></pre>
<p>包含响应的所有数据。该属性本身拥有许多保留属性名，下面会有相应的说明。服务可以自由地将自己的数据添加到这个对象。一个JSON响应要么应当包含一个<em>data</em>对象，要么应当包含<em>error</em>对象，但不能两者都包含。如果<em>data</em>和<em>error</em>同时出现，则<em>error</em>对象优先。</p>
<h3 id="error">error<a hidden class="anchor" aria-hidden="true" href="#error">#</a></h3>
<pre><code>属性值类型: 对象(object)
父节点: -
</code></pre>
<p>表明错误发生，提供错误的详细信息。错误的格式支持从服务返回一个或多个错误。一个JSON响应可以有一个<em>data</em>对象或者一个<em>error</em>对象，但不能两者都包含。如果<em>data</em>和<em>error</em>都出现，<em>error</em>对象优先。</p>
<p>示例：</p>
<pre><code>{
  &quot;apiVersion&quot;: &quot;2.0&quot;,
  &quot;error&quot;: {
    &quot;code&quot;: 404,
    &quot;message&quot;: &quot;File Not Found&quot;,
    &quot;errors&quot;: [{
      &quot;domain&quot;: &quot;Calendar&quot;,
      &quot;reason&quot;: &quot;ResourceNotFoundException&quot;,
      &quot;message&quot;: &quot;File Not Found
    }]
  }
}
</code></pre>
<h2 id="data对象的保留属性名">data对象的保留属性名<a hidden class="anchor" aria-hidden="true" href="#data对象的保留属性名">#</a></h2>
<p>JSON对象的<em>data</em>属性可能包含以下属性。</p>
<h3 id="datakind">data.kind<a hidden class="anchor" aria-hidden="true" href="#datakind">#</a></h3>
<pre><code>属性值类型: 字符串(sting)
父节点: data
</code></pre>
<p><em>kind</em>属性是对某个特定的对象存储何种类型的信息的指南。可以把它放在<em>data</em>层次，或<em>items</em>的层次，或其它任何有助于区分各类对象的对象中。如果<em>kind</em>对象被提供，它应该是对象的第一个属性（详见下面的_属性顺序_部分）。</p>
<p>示例：</p>
<pre><code>// &quot;Kind&quot; indicates an &quot;album&quot; in the Picasa API.
{&quot;data&quot;: {&quot;kind&quot;: &quot;album&quot;}}
</code></pre>
<h3 id="datafields">data.fields<a hidden class="anchor" aria-hidden="true" href="#datafields">#</a></h3>
<pre><code>属性值类型: 字符串(string)
父节点: data
</code></pre>
<p>表示做了部分GET之后响应中出现的字段，或做了部分PATCH之后出现在请求中的字段。该属性仅在做了部分GET请求/批处理时存在，且不能为空。</p>
<p>示例：</p>
<pre><code>{
  &quot;data&quot;: {
    &quot;kind&quot;: &quot;user&quot;,
    &quot;fields&quot;: &quot;author,id&quot;,
    &quot;id&quot;: &quot;bart&quot;,
    &quot;author&quot;: &quot;Bart&quot;
  }
}	
</code></pre>
<h3 id="dataetag">data.etag<a hidden class="anchor" aria-hidden="true" href="#dataetag">#</a></h3>
<pre><code>属性值类型: 字符串(string)
父节点: data
</code></pre>
<p>响应时提供etag。关于GData APIs中的ETags详情可以在这里找到：<a href="http://code.google.com/apis/gdata/docs/2.0/reference.html#ResourceVersioning">http://code.google.com/apis/gdata/docs/2.0/reference.html#ResourceVersioning</a></p>
<p>示例：</p>
<pre><code>{&quot;data&quot;: {&quot;etag&quot;: &quot;W/&quot;C0QBRXcycSp7ImA9WxRVFUk.&quot;&quot;}}
</code></pre>
<h3 id="dataid">data.id<a hidden class="anchor" aria-hidden="true" href="#dataid">#</a></h3>
<pre><code>属性值类型: 字符串(string)
父节点: data
</code></pre>
<p>一个全局唯一标识符用于引用该对象。<em>id</em>属性的具体细节都留给了服务。</p>
<p>示例：</p>
<pre><code>{&quot;data&quot;: {&quot;id&quot;: &quot;12345&quot;}}
</code></pre>
<h3 id="datalang">data.lang<a hidden class="anchor" aria-hidden="true" href="#datalang">#</a></h3>
<pre><code>属性值类型: 字符串(string)(格式由BCP 47指定)
父节点: data (或任何子元素)
</code></pre>
<p>表示该对象内其他属性的语言。该属性模拟HTML的<em>lang</em>属性和XML的<em>xml:lang</em>属性。值应该是<a href="http://www.rfc-editor.org/rfc/bcp/bcp47.txt">BCP 47</a>中定义的一种语言值。如果一个单一的JSON对象包含的数据有多种语言，服务负责制定和标明lang属性的适当位置。</p>
<p>示例：</p>
<pre><code>{&quot;data&quot;: {
  &quot;items&quot;: [
    { &quot;lang&quot;: &quot;en&quot;,
      &quot;title&quot;: &quot;Hello world!&quot; },
    { &quot;lang&quot;: &quot;fr&quot;,
      &quot;title&quot;: &quot;Bonjour monde!&quot; }
  ]}
}
</code></pre>
<h3 id="dataupdated">data.updated<a hidden class="anchor" aria-hidden="true" href="#dataupdated">#</a></h3>
<pre><code>属性值类型: 字符串(string)(格式由RFC 3339指定)
父节点: data
</code></pre>
<p>指明条目更新的最后日期/时间(<a href="http://www.ietf.org/rfc/rfc3339.txt">RFC 3339</a>)，由服务规定。</p>
<p>示例：</p>
<pre><code>{&quot;data&quot;: {&quot;updated&quot;: &quot;2007-11-06T16:34:41.000Z&quot;}}
</code></pre>
<h3 id="datadeleted">data.deleted<a hidden class="anchor" aria-hidden="true" href="#datadeleted">#</a></h3>
<pre><code>属性值类型: 布尔(boolean)
父节点: data (或任何子元素)
</code></pre>
<p>一个标记元素，当出现时，表示包含的条目已被删除。如果提供了删除属性，它的值必须为<em>true</em>;为<em>false</em>会导致混乱，应该避免。</p>
<p>示例：</p>
<pre><code>{&quot;data&quot;: {
  &quot;items&quot;: [
    { &quot;title&quot;: &quot;A deleted entry&quot;,
      &quot;deleted&quot;: true
    }
  ]}
}
</code></pre>
<h3 id="dataitems">data.items<a hidden class="anchor" aria-hidden="true" href="#dataitems">#</a></h3>
<pre><code>属性值类型: 数组(array)
父节点: data
</code></pre>
<p>属性名<em>items</em>被保留用作表示一组条目(例如,Picasa中的图片，YouTube中的视频)。这种结构的目的是给与当前结果相关的集合提供一个标准位置。例如，知道页面上的<em>items</em>是数组，JSON输出便可能插入一个通用的分页系统。如果<em>items</em>存在，它应该是<em>data</em>对象的最后一个属性。（详见下面的_属性顺序_部分）。</p>
<p>示例：</p>
<pre><code>{
  &quot;data&quot;: {
    &quot;items&quot;: [
      { /* Object #1 */ },
      { /* Object #2 */ },
      ...
    ]
  }
}
</code></pre>
<h2 id="用于分页的保留属性名">用于分页的保留属性名<a hidden class="anchor" aria-hidden="true" href="#用于分页的保留属性名">#</a></h2>
<p>下面的属性位于<em>data</em>对象中，用来给一列数据分页。一些语言和概念是从OpenSearch规范中借鉴过来的。</p>
<p>下面的分页数据允许各种风格的分页，包括：</p>
<ul>
<li>上一页/下一页 - 允许用户在列表中前进和后退，一次一页。<em>nextLink</em> 和<em>previousLink</em>属性 (下面的&quot;链接保留属性名&quot;部分有描述) 用于这种风格的分页。</li>
<li>基于索引的分页 - 允许用户直接跳到条目列表的某个条目位置。例如，要从第200个条目开始载入10个新的条目，开发者可以给用户提供一个URL的查询字符串*?startIndex=200*。</li>
<li>基于页面的分页 - 允许用户直接跳到条目内的具体页。这跟基于索引的分页很类似,但节省了开发者额外的步骤，不需再为新一页的条目计算条目索引。例如，开发人员可以直接跳到第20页，而不是跳到第200条条目。基于页面分页的网址，可以使用查询字符串*?page=1*或*?page=20*。*pageIndex*和 *totalPages* 属性用作这种风格的分页.</li>
</ul>
<p>在这份指南的最后可以找到如何使用这些属性来实现分页的例子。</p>
<h3 id="datacurrentitemcount">data.currentItemCount<a hidden class="anchor" aria-hidden="true" href="#datacurrentitemcount">#</a></h3>
<pre><code>属性值类型: 整数(integer)
父节点: data
</code></pre>
<p>结果集中的条目数目。应该与items.length相等，并作为一个便利属性提供。例如，假设开发者请求一组搜索条目，并且要求每页10条。查询集共有14条。第一个条目页将会有10个条目，因此<em>itemsPerPage</em>和<em>currentItemCount</em>都应该等于10。下一页的条目还剩下4条；<em>itemsPerPage</em>仍然是10,但是<em>currentItemCount</em>是4.</p>
<p>示例：</p>
<pre><code>{
  &quot;data&quot;: {
    // &quot;itemsPerPage&quot; 不需要与 &quot;currentItemCount&quot; 匹配
    &quot;itemsPerPage&quot;: 10,
    &quot;currentItemCount&quot;: 4
  }
}
</code></pre>
<h3 id="dataitemsperpage">data.itemsPerPage<a hidden class="anchor" aria-hidden="true" href="#dataitemsperpage">#</a></h3>
<pre><code>属性值类型: 整数(integer)
父节点: data
</code></pre>
<p>items结果的数目。未必是data.items数组的大小；如果我们查看的是最后一页，data.items的大小可能小于<em>itemsPerPage</em>。但是，data.items的大小不应超过<em>itemsPerPage</em>。</p>
<p>示例：</p>
<pre><code>{
  &quot;data&quot;: {
    &quot;itemsPerPage&quot;: 10
  }
}
</code></pre>
<h3 id="datastartindex">data.startIndex<a hidden class="anchor" aria-hidden="true" href="#datastartindex">#</a></h3>
<pre><code>属性值类型: 整数(integer)
父节点: data
</code></pre>
<p>data.items中第一个条目的索引。为了一致，<em>startIndex</em>应从1开始。例如，第一组items中第一条的<em>startIndex</em>应该是1。如果用户请求下一组数据，<em>startIndex</em>可能是10。</p>
<p>示例：</p>
<pre><code>{
  &quot;data&quot;: {
    &quot;startIndex&quot;: 1
  }
}
</code></pre>
<h3 id="datatotalitems">data.totalItems<a hidden class="anchor" aria-hidden="true" href="#datatotalitems">#</a></h3>
<pre><code>属性值类型: 整数(integer)
父节点: data
</code></pre>
<p>当前集合中可用的总条目数。例如，如果用户有100篇博客文章，响应可能只包含10篇，但是<em>totalItems</em>应该是100。</p>
<p>示例：</p>
<pre><code>{
  &quot;data&quot;: {
    &quot;totalItems&quot;: 100
  }
}
</code></pre>
<h3 id="datapaginglinktemplate">data.pagingLinkTemplate<a hidden class="anchor" aria-hidden="true" href="#datapaginglinktemplate">#</a></h3>
<pre><code>属性值类型: 字符串(string)
父节点: data
</code></pre>
<p>URL模板指出用户可以如何计算随后的分页链接。URL模板中也包含一些保留变量名：表示要载入的条目的*{index}*，和要载入的页面的*{pageIndex}*。</p>
<p>示例：</p>
<pre><code>{
  &quot;data&quot;: {
    &quot;pagingLinkTemplate&quot;: &quot;http://www.google.com/search/hl=en&amp;q=chicago+style+pizza&amp;start={index}&amp;sa=N&quot;
  }
}
</code></pre>
<h3 id="datapageindex">data.pageIndex<a hidden class="anchor" aria-hidden="true" href="#datapageindex">#</a></h3>
<pre><code>属性值类型: 整数(integer)
父节点: data
</code></pre>
<p>条目的当前页索引。为了一致，<em>pageIndex</em>应从1开始。例如，第一页的<em>pageIndex</em>是1。<em>pageIndex</em>也可以通过基于条目的分页而计算出来<em>pageIndex = floor(startIndex / itemsPerPage) + 1</em>。</p>
<p>示例：</p>
<pre><code>{
  &quot;data&quot;: {
    &quot;pageIndex&quot;: 1
  }
}
</code></pre>
<h3 id="datatotalpages">data.totalPages<a hidden class="anchor" aria-hidden="true" href="#datatotalpages">#</a></h3>
<pre><code>属性值类型: 整数(integer)
父节点: data
</code></pre>
<p>当前结果集中的总页数。<em>totalPages</em>也可以通过上面基于条目的分页属性计算出来: <em>totalPages = ceiling(totalItems / itemsPerPage).</em>。</p>
<p>示例：</p>
<pre><code>{
  &quot;data&quot;: {
    &quot;totalPages&quot;: 50
  }
}
</code></pre>
<h2 id="用于链接的保留属性名">用于链接的保留属性名<a hidden class="anchor" aria-hidden="true" href="#用于链接的保留属性名">#</a></h2>
<p>下面的属性位于<em>data</em>对象中，用来表示对其他资源的引用。有两种形式的链接属性：1）对象，它可以包含任何种类的引用（比如JSON-RPC对象），2)URL字符串，表示资源的URIs(后缀总为&rsquo;Link')。</p>
<h3 id="dataself--dataselflink">data.self / data.selfLink<a hidden class="anchor" aria-hidden="true" href="#dataself--dataselflink">#</a></h3>
<pre><code>属性值类型: 对象(object)/字符串(string)
父节点: data
</code></pre>
<p>自身链接可以用于取回条目数据。比如，在用户的Picasa相册中，条目中的每个相册对象都会包含一个<em>selfLink</em>用于检索这个相册的相关数据。</p>
<p>示例：</p>
<pre><code>{
  &quot;data&quot;: {
    &quot;self&quot;: { },
    &quot;selfLink&quot;: &quot;http://www.google.com/feeds/album/1234&quot;
  }
}
</code></pre>
<h3 id="dataedit--dataeditlink">data.edit / data.editLink<a hidden class="anchor" aria-hidden="true" href="#dataedit--dataeditlink">#</a></h3>
<pre><code>属性值类型: 对象(object)/字符串(string)
父节点: data
</code></pre>
<p>编辑链接表明用户可以发送更新或删除请求。这对于REST风格的APIs很有用。该链接仅在用户能够更新和删除该条目时提供。</p>
<p>示例：</p>
<pre><code>{
  &quot;data&quot;: {
    &quot;edit&quot;: { },
    &quot;editLink&quot;: &quot;http://www.google.com/feeds/album/1234/edit&quot;
  }
}
</code></pre>
<h3 id="datanext--datanextlink">data.next / data.nextLink<a hidden class="anchor" aria-hidden="true" href="#datanext--datanextlink">#</a></h3>
<pre><code>属性值类型: 对象(object)/字符串(string)
父节点: data
</code></pre>
<p>该下一页链接标明如何取得更多数据。它指明载入下一组数据的位置。它可以同<em>itemsPerPage</em>，<em>startIndex</em> 和 <em>totalItems</em>	属性一起使用用于分页数据。</p>
<p>示例：</p>
<pre><code>{
  &quot;data&quot;: {
    &quot;next&quot;: { },
    &quot;nextLink&quot;: &quot;http://www.google.com/feeds/album/1234/next&quot;
  }
}
</code></pre>
<h3 id="dataprevious--datapreviouslink">data.previous / data.previousLink<a hidden class="anchor" aria-hidden="true" href="#dataprevious--datapreviouslink">#</a></h3>
<pre><code>属性值类型: 对象(object)/字符串(string)
父节点: data
</code></pre>
<p>该上一页链接标明如何取得更多数据。它指明载入上一组数据的位置。它可以连同<em>itemsPerPage</em>，<em>startIndex</em> 和 <em>totalItems</em>	属性用于分页数据。</p>
<p>示例：</p>
<pre><code>{
  &quot;data&quot;: {
    &quot;previous&quot;: { },
    &quot;previousLink&quot;: &quot;http://www.google.com/feeds/album/1234/next&quot;
  }
}
</code></pre>
<h2 id="错误对象中的保留属性名">错误对象中的保留属性名<a hidden class="anchor" aria-hidden="true" href="#错误对象中的保留属性名">#</a></h2>
<p>JSON对象的<em>error</em>属性应包含以下属性。</p>
<h3 id="errorcode">error.code<a hidden class="anchor" aria-hidden="true" href="#errorcode">#</a></h3>
<pre><code>属性值类型: 整数(integer)
父节点: error
</code></pre>
<p>表示该错误的编号。这个属性通常表示HTTP响应码。如果存在多个错误，<em>code</em>应为第一个出错的错误码。</p>
<p>示例：</p>
<pre><code>{
  &quot;error&quot;:{
    &quot;code&quot;: 404
  }
}
</code></pre>
<h3 id="errormessage">error.message<a hidden class="anchor" aria-hidden="true" href="#errormessage">#</a></h3>
<pre><code>属性值类型: 字符串(string)
父节点: error
</code></pre>
<p>一个人类可读的信息，提供有关错误的详细信息。如果存在多个错误，<em>message</em>应为第一个错误的错误信息。</p>
<p>示例：</p>
<pre><code>{
  &quot;error&quot;:{
    &quot;message&quot;: &quot;File Not Found&quot;
  }
}	
</code></pre>
<h3 id="errorerrors">error.errors<a hidden class="anchor" aria-hidden="true" href="#errorerrors">#</a></h3>
<pre><code>属性值类型: 数组(array)
父节点: error
</code></pre>
<p>包含关于错误的附加信息。如果服务返回多个错误。<em>errors</em>数组中的每个元素表示一个不同的错误。</p>
<p>示例：</p>
<pre><code>{ &quot;error&quot;: { &quot;errors&quot;: [] } }	
</code></pre>
<h3 id="errorerrorsdomain">error.errors[].domain<a hidden class="anchor" aria-hidden="true" href="#errorerrorsdomain">#</a></h3>
<pre><code>属性值类型: 字符串(string)
父节点: error.errors
</code></pre>
<p>服务抛出该错误的唯一识别符。它帮助区分服务的从普通协议错误(如,找不到文件)中区分出具体错误(例如，给日历插入事件的错误)。</p>
<p>示例：</p>
<pre><code>{
  &quot;error&quot;:{
    &quot;errors&quot;: [{&quot;domain&quot;: &quot;Calendar&quot;}]
  }
}
</code></pre>
<h3 id="errorerrorsreason">error.errors[].reason<a hidden class="anchor" aria-hidden="true" href="#errorerrorsreason">#</a></h3>
<pre><code>属性值类型: 字符串(string)
父节点: error.errors
</code></pre>
<p>该错误的唯一识别符。不同于<em>error.code</em>属性，它不是HTTP响应码。</p>
<p>示例：</p>
<pre><code>{
  &quot;error&quot;:{
    &quot;errors&quot;: [{&quot;reason&quot;: &quot;ResourceNotFoundException&quot;}]
  }
}
</code></pre>
<h3 id="errorerrorsmessage">error.errors[].message<a hidden class="anchor" aria-hidden="true" href="#errorerrorsmessage">#</a></h3>
<pre><code>属性值类型: 字符串(string)
父节点: error.errors
</code></pre>
<p>一个人类可读的信息，提供有关错误的更多细节。如果只有一个错误，该字段应该与<em>error.message</em>匹配。</p>
<p>示例：</p>
<pre><code>{
  &quot;error&quot;:{
    &quot;code&quot;: 404
    &quot;message&quot;: &quot;File Not Found&quot;,
    &quot;errors&quot;: [{&quot;message&quot;: &quot;File Not Found&quot;}]
  }
}		
</code></pre>
<h3 id="errorerrorslocation">error.errors[].location<a hidden class="anchor" aria-hidden="true" href="#errorerrorslocation">#</a></h3>
<pre><code>属性值类型: 字符串(string)
父节点: error.errors
</code></pre>
<p>错误发生的位置（根据<em>locationType</em>字段解释该值）。</p>
<p>示例：</p>
<pre><code>{
  &quot;error&quot;:{
    &quot;errors&quot;: [{&quot;location&quot;: &quot;&quot;}]
  }
}
</code></pre>
<h3 id="errorerrorslocationtype">error.errors[].locationType<a hidden class="anchor" aria-hidden="true" href="#errorerrorslocationtype">#</a></h3>
<pre><code>属性值类型: 字符串(string)
父节点: error.errors
</code></pre>
<p>标明如何解释<em>location</em>属性。</p>
<p>示例：</p>
<pre><code>{
  &quot;error&quot;:{
    &quot;errors&quot;: [{&quot;locationType&quot;: &quot;&quot;}]
  }
}
</code></pre>
<h3 id="errorerrorsextendedhelp">error.errors[].extendedHelp<a hidden class="anchor" aria-hidden="true" href="#errorerrorsextendedhelp">#</a></h3>
<pre><code>属性值类型: 字符串(string)
父节点: error.errors
</code></pre>
<p>help text的URI，使错误更易于理解。</p>
<p>示例：（注：原示例这里有笔误，中文版这里做了校正）</p>
<pre><code>{
  &quot;error&quot;:{
    &quot;errors&quot;: [{&quot;extendedHelp&quot;: &quot;http://url.to.more.details.example.com/&quot;}]
  }
}
</code></pre>
<h3 id="errorerrorssendreport">error.errors[].sendReport<a hidden class="anchor" aria-hidden="true" href="#errorerrorssendreport">#</a></h3>
<pre><code>属性值类型: 字符串(string)
父节点: error.errors
</code></pre>
<p>report form的URI，服务用它来收集错误状态的数据。该URL会预先载入描述请求的参数</p>
<p>示例：</p>
<pre><code>{
  &quot;error&quot;:{
    &quot;errors&quot;: [{&quot;sendReport&quot;: &quot;http://report.example.com/&quot;}]
  }
}
</code></pre>
<h2 id="属性顺序">属性顺序<a hidden class="anchor" aria-hidden="true" href="#属性顺序">#</a></h2>
<p>在JSON对象中属性可有任意顺序。然而，在某些情况下，有序的属性可以帮助分析器快速解释数据，并带来更好的性能。在移动环境下的解析器就是个例子，在这种情况下，性能和内存是至关重要的，不必要的解析也应尽量避免。</p>
<h3 id="kind属性">Kind属性<a hidden class="anchor" aria-hidden="true" href="#kind属性">#</a></h3>
<p><strong>Kind属性应为第一属性</strong></p>
<p>假设一个解析器负责将一个原始JSON流解析成一个特定的对象。<em>kind</em>属性会引导解析器将适合的对象实例化。因而它应该是JSON对象的第一个属性。这仅适用于对象有一个kind属性的情况(通常可以在<em>data</em>和<em>items</em>属性中找到)。</p>
<h3 id="items属性">Items属性<a hidden class="anchor" aria-hidden="true" href="#items属性">#</a></h3>
<p><strong>_items_应该是_data_对象的最后一个属性</strong></p>
<p>这使得阅读每一个具体条目前前已读所有的集合属性。在有很多条目的情况下，这样就避免了开发人员只需要从数据的字段时不必要的解析这些条目。</p>
<p>这让阅读所有集合属性先于阅读单个条目。如遇多个条目的情况，当开发者仅需要数据中的字段时，这就可避免解析不必要的条目。</p>
<p>属性顺序示例：</p>
<pre><code>// &quot;kind&quot; 属性区分 &quot;album&quot; 和 &quot;photo&quot;.
// &quot;Kind&quot; 始终是它父对象的第一个属性.
// &quot;items&quot; 属性是 &quot;data&quot; 对象的最后一个属性.
{
  &quot;data&quot;: {
    &quot;kind&quot;: &quot;album&quot;,
    &quot;title&quot;: &quot;My Photo Album&quot;,
    &quot;description&quot;: &quot;An album in the user's account&quot;,
    &quot;items&quot;: [
      {
        &quot;kind&quot;: &quot;photo&quot;,
        &quot;title&quot;: &quot;My First Photo&quot;
      }
    ]
  }
}
</code></pre>
<h2 id="示例">示例<a hidden class="anchor" aria-hidden="true" href="#示例">#</a></h2>
<h3 id="youtube-json-api">YouTube JSON API<a hidden class="anchor" aria-hidden="true" href="#youtube-json-api">#</a></h3>
<p>这是YouTube JSON API响应对象的示例。你可以从中学到更多关于YouTube JSON API的内容：<a href="http://code.google.com/apis/youtube/2.0/developers_guide_jsonc.html">http://code.google.com/apis/youtube/2.0/developers_guide_jsonc.html</a></p>
<pre><code>{
  &quot;apiVersion&quot;: &quot;2.0&quot;,
  &quot;data&quot;: {
    &quot;updated&quot;: &quot;2010-02-04T19:29:54.001Z&quot;,
    &quot;totalItems&quot;: 6741,
    &quot;startIndex&quot;: 1,
    &quot;itemsPerPage&quot;: 1,
    &quot;items&quot;: [
      {
        &quot;id&quot;: &quot;BGODurRfVv4&quot;,
        &quot;uploaded&quot;: &quot;2009-11-17T20:10:06.000Z&quot;,
        &quot;updated&quot;: &quot;2010-02-04T06:25:57.000Z&quot;,
        &quot;uploader&quot;: &quot;docchat&quot;,
        &quot;category&quot;: &quot;Animals&quot;,
        &quot;title&quot;: &quot;From service dog to SURFice dog&quot;,
        &quot;description&quot;: &quot;Surf dog Ricochets inspirational video ...&quot;,
        &quot;tags&quot;: [
          &quot;Surf dog&quot;,
          &quot;dog surfing&quot;,
          &quot;dog&quot;,
          &quot;golden retriever&quot;,
        ],
        &quot;thumbnail&quot;: {
          &quot;default&quot;: &quot;http://i.ytimg.com/vi/BGODurRfVv4/default.jpg&quot;,
          &quot;hqDefault&quot;: &quot;http://i.ytimg.com/vi/BGODurRfVv4/hqdefault.jpg&quot;
        },
        &quot;player&quot;: {
          &quot;default&quot;: &quot;http://www.youtube.com/watch?v=BGODurRfVv4&amp;feature=youtube_gdata&quot;,
          &quot;mobile&quot;: &quot;http://m.youtube.com/details?v=BGODurRfVv4&quot;
        },
        &quot;content&quot;: {
          &quot;1&quot;: &quot;rtsp://v5.cache6.c.youtube.com/CiILENy73wIaGQn-Vl-0uoNjBBMYDSANFEgGUgZ2aWRlb3MM/0/0/0/video.3gp&quot;,
          &quot;5&quot;: &quot;http://www.youtube.com/v/BGODurRfVv4?f=videos&amp;app=youtube_gdata&quot;,
          &quot;6&quot;: &quot;rtsp://v7.cache7.c.youtube.com/CiILENy73wIaGQn-Vl-0uoNjBBMYESARFEgGUgZ2aWRlb3MM/0/0/0/video.3gp&quot;
        },
        &quot;duration&quot;: 315,
        &quot;rating&quot;: 4.96,
        &quot;ratingCount&quot;: 2043,
        &quot;viewCount&quot;: 1781691,
        &quot;favoriteCount&quot;: 3363,
        &quot;commentCount&quot;: 1007,
        &quot;commentsAllowed&quot;: true
      }
    ]
  }
}
</code></pre>
<h3 id="分页示例">分页示例<a hidden class="anchor" aria-hidden="true" href="#分页示例">#</a></h3>
<p>如何将Google搜索条目作为JSON对象展现出来，对分页变量也有特别关注。</p>
<p>这个示例仅用作说明。下面的API实际上并不存在。</p>
<p>这是Google搜索结果页面的示例：
<img loading="lazy" src="http://google-styleguide.googlecode.com/svn/trunk/jsoncstyleguide_example_01.png" alt="image"  />
</p>
<p><img loading="lazy" src="http://google-styleguide.googlecode.com/svn/trunk/jsoncstyleguide_example_02.png" alt="image"  />
</p>
<p>这是该页面JSON形式的呈现：</p>
<pre><code>{
  &quot;apiVersion&quot;: &quot;2.1&quot;,
  &quot;id&quot;: &quot;1&quot;,
  &quot;data&quot;: {
    &quot;query&quot;: &quot;chicago style pizza&quot;,
    &quot;time&quot;: &quot;0.1&quot;,
    &quot;currentItemCount&quot;: 10,
    &quot;itemsPerPage&quot;: 10,
    &quot;startIndex&quot;: 11,
    &quot;totalItems&quot;: 2700000,
    &quot;nextLink&quot;: &quot;http://www.google.com/search?hl=en&amp;q=chicago+style+pizza&amp;start=20&amp;sa=N&quot;
    &quot;previousLink&quot;: &quot;http://www.google.com/search?hl=en&amp;q=chicago+style+pizza&amp;start=0&amp;sa=N&quot;,
    &quot;pagingLinkTemplate&quot;: &quot;http://www.google.com/search/hl=en&amp;q=chicago+style+pizza&amp;start={index}&amp;sa=N&quot;,
    &quot;items&quot;: [
      {
        &quot;title&quot;: &quot;Pizz'a Chicago Home Page&quot;
        // More fields for the search results
      }
      // More search results
    ]
  }
}
</code></pre>
<p>这是如何展现屏幕截图中的色块的例子（背景颜色对应下图中的颜色）</p>
<ul>
<li>Results <!-- raw HTML omitted -->11<!-- raw HTML omitted --> - 20 of about 2,700,000 = startIndex</li>
<li>Results 11 - <!-- raw HTML omitted -->20<!-- raw HTML omitted --> of about 2,700,000 = startIndex + currentItemCount - 1</li>
<li>Results 11 - 20 of about <!-- raw HTML omitted -->2,700,000<!-- raw HTML omitted --> = totalItems</li>
<li><!-- raw HTML omitted -->Search results<!-- raw HTML omitted --> = items (formatted appropriately)</li>
<li><!-- raw HTML omitted -->Previous/Next<!-- raw HTML omitted --> = previousLink / nextLink</li>
<li><!-- raw HTML omitted -->Numbered links in &ldquo;Gooooooooooogle&rdquo;<!-- raw HTML omitted --> = Derived from &ldquo;pageLinkTemplate&rdquo;. The developer is responsible for calculating the values for {index} and substituting those values into the &ldquo;pageLinkTemplate&rdquo;. The pageLinkTemplate&rsquo;s {index} variable is calculated as follows:
<ul>
<li>Index #1 = 0 * itemsPerPage = 0</li>
<li>Index #2 = 2 * itemsPerPage = 10</li>
<li>Index #3 = 3 * itemsPerPage = 20</li>
<li>Index #N = N * itemsPerPage</li>
</ul>
</li>
</ul>
<h2 id="附录">附录<a hidden class="anchor" aria-hidden="true" href="#附录">#</a></h2>
<h3 id="附录ajavascript中的保留字">附录A:JavaScript中的保留字<a hidden class="anchor" aria-hidden="true" href="#附录ajavascript中的保留字">#</a></h3>
<p><strong>下列JavaScript保留字应该避免在属性名中使用</strong></p>
<p>下面的清单是JavaScript中的保留字，并不能通过点访问符访问。这份清单集合了当前最新的关键字，该清单可能会根据具体的执行环境而有所变更。</p>
<p>来自<a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMAScript 语言规范第五版</a></p>
<pre><code>abstract
boolean break byte
case catch char class const continue
debugger default delete do double
else enum export extends
false final finally float for function
goto
if implements import in instanceof int interface
let long
native new null
package private protected public
return
short static super switch synchronized
this throw throws transient true try typeof
var volatile void
while with
yield
</code></pre>
<p>除了特别<a href="http://code.google.com/policies.html">说明</a>，该页面的内容均由<a href="http://creativecommons.org/licenses/by/3.0/">共同创作协议</a>(CC BY 3.0)授权许可，示例代码均由<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a>许可证授权许可）</p>
<p>－EOF-</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/json/">Json</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
