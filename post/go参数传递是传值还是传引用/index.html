<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go参数传递是传值还是传引用 | Forz Blog</title>
<meta name="keywords" content="Go" />
<meta name="description" content="前言 对于了解一门语言来说，会关心我们在函数调用的时候，参数到底是传的值，还是引用？ 其实对于传值和传引用，是一个比较古老的话题，做研发的都有这">
<meta name="author" content="">
<link rel="canonical" href="/post/go%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%98%AF%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E4%BC%A0%E5%BC%95%E7%94%A8/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Go参数传递是传值还是传引用" />
<meta property="og:description" content="前言 对于了解一门语言来说，会关心我们在函数调用的时候，参数到底是传的值，还是引用？ 其实对于传值和传引用，是一个比较古老的话题，做研发的都有这" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%98%AF%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E4%BC%A0%E5%BC%95%E7%94%A8/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-07-20T20:17:20&#43;00:00" />
<meta property="article:modified_time" content="2021-07-20T20:17:20&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go参数传递是传值还是传引用"/>
<meta name="twitter:description" content="前言 对于了解一门语言来说，会关心我们在函数调用的时候，参数到底是传的值，还是引用？ 其实对于传值和传引用，是一个比较古老的话题，做研发的都有这"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Go参数传递是传值还是传引用",
      "item": "/post/go%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%98%AF%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E4%BC%A0%E5%BC%95%E7%94%A8/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go参数传递是传值还是传引用",
  "name": "Go参数传递是传值还是传引用",
  "description": "前言 对于了解一门语言来说，会关心我们在函数调用的时候，参数到底是传的值，还是引用？ 其实对于传值和传引用，是一个比较古老的话题，做研发的都有这",
  "keywords": [
    "Go"
  ],
  "articleBody": "前言 对于了解一门语言来说，会关心我们在函数调用的时候，参数到底是传的值，还是引用？\n其实对于传值和传引用，是一个比较古老的话题，做研发的都有这个概念，但是可能不是非常清楚。对于我们做Go语言开发的来说，也想知道到底是什么传递。\n那么我们先来看看什么是值传递，什么是引用传递。\n什么是传值（值传递） 传值的意思是：函数传递的总是原来这个东西的一个副本，一副拷贝。比如我们传递一个int类型的参数，传递的其实是这个参数的一个副本；传递一个指针类型的参数，其实传递的是这个该指针的一份拷贝，而不是这个指针指向的值。\n对于int这类基础类型我们可以很好的理解，它们就是一个拷贝，但是指针呢？我们觉得可以通过它修改原来的值，怎么会是一个拷贝呢？下面我们看个例子。\n1 2 3 4 5 6 7 8 9 10 11 12  func main() { i:=10 ip:=\u0026i fmt.Printf(\"原始指针的内存地址是：%p\\n\",\u0026ip) modify(ip) fmt.Println(\"int值被修改了，新值为:\",i) } func modify(ip *int){ fmt.Printf(\"函数里接收到的指针的内存地址是：%p\\n\",\u0026ip) *ip=1 }   我们运行，可以看到输入结果如下：\n1 2 3  原始指针的内存地址是：0xc42000c028 函数里接收到的指针的内存地址是：0xc42000c038 int值被修改了，新值为: 1   首先我们要知道，任何存放在内存里的东西都有自己的地址，指针也不例外，它虽然指向别的数据，但是也有存放该指针的内存。\n所以通过输出我们可以看到，这是一个指针的拷贝，因为存放这两个指针的内存地址是不同的，虽然指针的值相同，但是是两个不同的指针。\n通过上面的图，可以更好的理解。 首先我们看到，我们声明了一个变量i,值为10,它的内存存放地址是0xc420018070,通过这个内存地址，我们可以找到变量i,这个内存地址也就是变量i的指针ip。\n指针ip也是一个指针类型的变量，它也需要内存存放它，它的内存地址是多少呢？是0xc42000c028。 在我们传递指针变量ip给modify函数的时候，是该指针变量的拷贝,所以新拷贝的指针变量ip，它的内存地址已经变了，是新的0xc42000c038。\n不管是0xc42000c028还是0xc42000c038，我们都可以称之为指针的指针，他们指向同一个指针0xc420018070，这个0xc420018070又指向变量i,这也就是为什么我们可以修改变量i的值。\n什么是传引用(引用传递) Go语言(Golang)是没有引用传递的，这里我不能使用Go举例子，但是可以通过说明描述。\n以上面的例子为例，如果在modify函数里打印出来的内存地址是不变的，也是0xc42000c028，那么就是引用传递。\n普通类型 如果参数是一个普通类型的指针,我们可以直接修改该指针指向的类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  package main import ( \"fmt\" ) func main() { a := ArgType{ A: \"aa\", b: 1, } modifyPointerArg4(\u0026a) fmt.Println(a) } type ArgType struct { A string b int } func modifyPointerArg4(arg *ArgType) { arg.A = \"bb\" }   如何在函数内部修改一个指针（参数或接收者）指向，使其值的改变能反映在函数外部？\n直接上代码，这样可以么？\n1 2 3 4 5 6 7 8 9  type ArgType struct { A string b int } func modifyPointerArg1(arg *ArgType) { arg = \u0026ArgType{\"arg1\", 1} fmt.Println(\"inside modifyPointerArg1:\", arg) }   答案是【不可以】\n等会分析，再看一个，这个呢？\n1 2 3 4  func modifyPointerArg2(arg *ArgType) { *arg = ArgType{\"arg2\", 2} fmt.Println(\"inside modifyPointerArg2:\", arg) }   答案是【可以】\n仔细看下，你应该就明白了。\n第一个替换的是arg指针本身,因为Go的参数传递是传值,函数返回后，并不影响指针arg所指向的值\n至于modifyPointerArg2则是对指针解引用，修改了其指向的值\n这样的方式其实还有很多，比如这个：\n1 2 3 4 5 6 7  func modifyPointerArg3(arg *ArgType) { val := reflect.ValueOf(arg) val.Elem().FieldByName(\"A\").SetString(\"arg3\") fmt.Println(\"inside modifyPointerArg3:\", arg) // val.Elem().FieldByName(\"b\").SetInt(3)  // panic: reflect: reflect.flag.mustBeAssignable using value obtained using unexported field }   实际是利用反射的Elem()获取val的值\n 如果其为空接口（empty interface），则获取其内部值（空接口值字段的类型是指针） 如果其为指针（pointer），则获取其指向的值  获取到的结构如下\n1 2 3 4 5 6 7 8  type Value struct { // 类型  typ *rtype // 值指针  ptr unsafe.Pointer // 标志位  flag }   然后对应类型修改时, 实际就是对指针解引用修改其指向的值\n1 2 3 4 5 6  func (v Value) SetString(x string) { v.mustBeAssignable() v.mustBe(String) // 这里  *(*string)(v.ptr) = x }   这里注意一点，不导出的字段（结构体内小写的字段）不能用此类方法修改，会 panic！\n再如：\n1 2 3 4  func modifyPointerArg4(arg *ArgType) { jsonStr := `{\"A\":\"arg4\",\"b\":4}` json.Unmarshal([]byte(jsonStr), arg) }   内部实际也是用了反射修改指针指向的值\n另外，把上边几个测试函数由指针参数换为指针接受者，也是一样的\n比如：\n1 2 3 4  func (arg *ArgType) modifyPointerReceiver4() { jsonStr := `{\"A\":\"arg4\",\"b\":4}` json.Unmarshal([]byte(jsonStr), arg) }   Map 了解清楚了传值和传引用，但是对于Map类型来说，可能觉得还是迷惑，一来我们可以通过方法修改它的内容，二来它没有明显的指针。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func main() { persons:=make(map[string]int) persons[\"张三\"]=19 mp:=\u0026persons fmt.Printf(\"原始map的内存地址是：%p\\n\",mp) modify(persons) fmt.Println(\"map值被修改了，新值为:\",persons) } func modify(p map[string]int){ fmt.Printf(\"函数里接收到map的内存地址是：%p\\n\",\u0026p) p[\"张三\"]=20 }   运行打印输出：\n1 2 3  原始map的内存地址是：0xc42000c028 函数里接收到map的内存地址是：0xc42000c038 map值被修改了，新值为: map[张三:20]   两个内存地址是不一样的，所以这又是一个值传递（值的拷贝），那么为什么我们可以修改Map的内容呢？先不急，我们先看一个自己实现的struct。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func main() { p:=Person{\"张三\"} fmt.Printf(\"原始Person的内存地址是：%p\\n\",\u0026p) modify(p) fmt.Println(p) } type Person struct { Name string } func modify(p Person) { fmt.Printf(\"函数里接收到Person的内存地址是：%p\\n\",\u0026p) p.Name = \"李四\" }   运行打印输出：\n1 2 3  原始Person的内存地址是：0xc4200721b0 函数里接收到Person的内存地址是：0xc4200721c0 {张三}   我们发现，我们自己定义的Person类型，在函数传参的时候也是值传递，但是它的值(Name字段)并没有被修改，我们想改成李四，发现最后的结果还是张三。\n这也就是说，map类型和我们自己定义的struct类型是不一样的。我们尝试把modify函数的接收参数改为Person的指针。\n1 2 3 4 5 6 7 8 9 10 11 12 13  func main() { p:=Person{\"张三\"} modify(\u0026p) fmt.Println(p) } type Person struct { Name string } func modify(p *Person) { p.Name = \"李四\" }   在运行查看输出，我们发现，这次被修改了。我们这里省略了内存地址的打印，因为我们上面int类型的例子已经证明了指针类型的参数也是值传递的。 指针类型可以修改，非指针类型不行，那么我们可以大胆的猜测，我们使用make函数创建的map是不是一个指针类型呢？看一下源代码:\n1 2 3 4 5 6 7 8  // makemap implements a Go map creation make(map[k]v, hint) // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h. // If bucket != nil, bucket can be used as the first bucket. func makemap(t *maptype, hint int64, h*hmap, bucket unsafe.Pointer) *hmap { //省略无关代码 }   通过查看src/runtime/hashmap.go源代码发现，的确和我们猜测的一样，make函数返回的是一个hmap类型的指针*hmap。也就是说map===*hmap。 现在看func modify(p map)这样的函数，其实就等于func modify(p*hmap)，和我们前面第一节什么是值传递里举的func modify(ip *int)的例子一样，可以参考分析。\n所以在这里，Go语言通过make函数，字面量的包装，为我们省去了指针的操作，让我们可以更容易的使用map。这里的map可以理解为引用类型，但是记住引用类型不是传引用。\nchan类型 chan类型本质上和map类型是一样的，这里不做过多的介绍，参考下源代码:\n1 2 3  func makechan(t *chantype, size int64)*hchan { //省略无关代码 }   chan也是一个引用类型，和map相差无几，make返回的是一个*hchan。\nslice slice和map、chan都不太一样的，一样的是，它也是引用类型，它也可以在函数中修改对应的内容。\n1 2 3 4 5 6 7 8 9 10 11  func main() { ages:=[]int{6,6,6} fmt.Printf(\"原始slice的内存地址是%p\\n\",ages) modify(ages) fmt.Println(ages) } func modify(ages []int){ fmt.Printf(\"函数里接收到slice的内存地址是%p\\n\",ages) ages[0]=1 }   运行打印结果，发现的确是被修改了，而且我们这里打印slice的内存地址是可以直接通过%p打印的,不用使用\u0026取地址符转换。\n这就可以证明make的slice也是一个指针了吗？不一定，也可能fmt.Printf把slice特殊处理了。\n1 2 3 4 5 6 7 8 9 10 11  func (p *pp) fmtPointer(value reflect.Value, verb rune) { var u uintptr switch value.Kind() { case reflect.Chan, reflect.Func, reflect.Map, reflect.Ptr, reflect.Slice, reflect.UnsafePointer: u = value.Pointer() default: p.badVerb(verb) return } //省略部分代码 }   通过源代码发现，对于chan、map、slice等被当成指针处理，通过value.Pointer()获取对应的值的指针。\n1 2 3 4 5 6 7 8 9 10 11 12  // If v's Kind is Slice, the returned pointer is to the first // element of the slice. If the slice is nil the returned value // is 0. If the slice is empty but non-nil the return value is non-zero. func (v Value) Pointer() uintptr { // TODO: deprecate \tk := v.kind() switch k { //省略无关代码 \tcase Slice: return (*SliceHeader)(v.ptr).Data } }   很明显了，当是slice类型的时候，返回是slice这个结构体里，字段Data第一个元素的地址。\n1 2 3 4 5 6 7 8 9 10 11  type SliceHeader struct { Data uintptr Len int Cap int } type slice struct { array unsafe.Pointer len int cap int }   所以我们通过%p打印的slice变量ages的地址其实就是内部存储数组元素的地址，slice是一种结构体+元素指针的混合类型，通过元素array(Data)的指针，可以达到修改slice里存储元素的目的。\n所以修改类型的内容的办法有很多种，类型本身作为指针可以，类型里有指针类型的字段也可以。\n单纯的从slice这个结构体看，我们可以通过modify修改存储元素的内容，但是永远修改不了len和cap，因为他们只是一个拷贝，如果要修改，那就要传递*slice作为参数才可以。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  func main() { i:=19 p:=Person{name:\"张三\",age:\u0026i} fmt.Println(p) modify(p) fmt.Println(p) } type Person struct { name string age *int } func (p Person) String() string{ return \"姓名为：\" + p.name + \",年龄为：\"+ strconv.Itoa(*p.age) } func modify(p Person){ p.name = \"李四\" *p.age = 20 }   运行打印输出结果为：\n1 2  姓名为：张三,年龄为：19 姓名为：张三,年龄为：20   通过这个Person和slice对比，就更好理解了，Person的name字段就类似于slice的len和cap字段，age字段类似于array字段。在传参为非指针类型的情况下，只能修改age字段，name字段无法修改。要修改name字段，就要把传参改为指针，比如：\n1 2 3 4 5  modify(\u0026p) func modify(p *Person){ p.name = \"李四\" *p.age = 20 }   这样name和age字段双双都被修改了。\n所以slice类型也是引用类型。\n小结 最终我们可以确认的是Go语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。\n是否可以修改原内容数据，和传值、传引用没有必然的关系。在C++中，传引用肯定是可以修改原内容数据的，在Go语言里，虽然只有传值，但是我们也可以修改原内容数据，因为参数是引用类型。\n这里也要记住，引用类型和传引用是两个概念。\n再记住，Go里只有传值（值传递）。\n转载 Go语言参数传递是传值还是传引用\nDig101-Go 之如何在函数内修改指针指向\n",
  "wordCount" : "4693",
  "inLanguage": "zh-cn",
  "datePublished": "2021-07-20T20:17:20Z",
  "dateModified": "2021-07-20T20:17:20Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/go%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%98%AF%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E4%BC%A0%E5%BC%95%E7%94%A8/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Go参数传递是传值还是传引用
    </h1>
    <div class="post-meta">July 20, 2021
</div>
  </header> 
  <div class="post-content"><h2 id="前言">前言<a hidden class="anchor" aria-hidden="true" href="#前言">#</a></h2>
<p>对于了解一门语言来说，会关心我们在函数调用的时候，参数到底是传的值，还是引用？</p>
<p>其实对于传值和传引用，是一个比较古老的话题，做研发的都有这个概念，但是可能不是非常清楚。对于我们做Go语言开发的来说，也想知道到底是什么传递。</p>
<p>那么我们先来看看什么是值传递，什么是引用传递。</p>
<h2 id="什么是传值值传递">什么是传值（值传递）<a hidden class="anchor" aria-hidden="true" href="#什么是传值值传递">#</a></h2>
<p>传值的意思是：函数传递的总是原来这个东西的一个副本，一副拷贝。比如我们传递一个int类型的参数，传递的其实是这个参数的一个副本；传递一个指针类型的参数，其实传递的是这个该指针的一份拷贝，而不是这个指针指向的值。</p>
<p>对于int这类基础类型我们可以很好的理解，它们就是一个拷贝，但是指针呢？我们觉得可以通过它修改原来的值，怎么会是一个拷贝呢？下面我们看个例子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">i</span><span class="o">:=</span><span class="mi">10</span>
	<span class="nx">ip</span><span class="o">:=&amp;</span><span class="nx">i</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;原始指针的内存地址是：%p\n&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">ip</span><span class="p">)</span>
	<span class="nf">modify</span><span class="p">(</span><span class="nx">ip</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;int值被修改了，新值为:&#34;</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">ip</span> <span class="o">*</span><span class="kt">int</span><span class="p">){</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;函数里接收到的指针的内存地址是：%p\n&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">ip</span><span class="p">)</span>
 	<span class="o">*</span><span class="nx">ip</span><span class="p">=</span><span class="mi">1</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们运行，可以看到输入结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s">原始指针的内存地址是：<span class="mh">0xc42000c028</span>
函数里接收到的指针的内存地址是：<span class="mh">0xc42000c038</span>
<span class="n">int值被修改了</span>，新值为<span class="o">:</span> <span class="m">1</span>
</code></pre></td></tr></table>
</div>
</div><p>首先我们要知道，任何存放在内存里的东西都有自己的地址，指针也不例外，它虽然指向别的数据，但是也有存放该指针的内存。</p>
<p>所以通过输出我们可以看到，这是一个指针的拷贝，因为存放这两个指针的内存地址是不同的，虽然指针的值相同，但是是两个不同的指针。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210720152309.png" alt=""  />
</p>
<p>通过上面的图，可以更好的理解。 首先我们看到，我们声明了一个变量i,值为10,它的内存存放地址是0xc420018070,通过这个内存地址，我们可以找到变量i,这个内存地址也就是变量i的指针ip。</p>
<p>指针ip也是一个指针类型的变量，它也需要内存存放它，它的内存地址是多少呢？是0xc42000c028。 在我们传递指针变量ip给modify函数的时候，是该指针变量的拷贝,所以新拷贝的指针变量ip，它的内存地址已经变了，是新的0xc42000c038。</p>
<p>不管是0xc42000c028还是0xc42000c038，我们都可以称之为指针的指针，他们指向同一个指针0xc420018070，这个0xc420018070又指向变量i,这也就是为什么我们可以修改变量i的值。</p>
<h2 id="什么是传引用引用传递">什么是传引用(引用传递)<a hidden class="anchor" aria-hidden="true" href="#什么是传引用引用传递">#</a></h2>
<p>Go语言(Golang)是没有引用传递的，这里我不能使用Go举例子，但是可以通过说明描述。</p>
<p>以上面的例子为例，如果在modify函数里打印出来的内存地址是不变的，也是0xc42000c028，那么就是引用传递。</p>
<h2 id="普通类型">普通类型<a hidden class="anchor" aria-hidden="true" href="#普通类型">#</a></h2>
<p>如果参数是一个普通类型的指针,我们可以直接修改该指针指向的类型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="nx">ArgType</span><span class="p">{</span>
		<span class="nx">A</span><span class="p">:</span> <span class="s">&#34;aa&#34;</span><span class="p">,</span>
		<span class="nx">b</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nf">modifyPointerArg4</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">a</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ArgType</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">A</span> <span class="kt">string</span>
	<span class="nx">b</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">modifyPointerArg4</span><span class="p">(</span><span class="nx">arg</span> <span class="o">*</span><span class="nx">ArgType</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">arg</span><span class="p">.</span><span class="nx">A</span> <span class="p">=</span> <span class="s">&#34;bb&#34;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如何在函数内部修改一个指针（参数或接收者）指向，使其值的改变能反映在函数外部？</p>
<p>直接上代码，这样可以么？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ArgType</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">A</span> <span class="kt">string</span>
  <span class="nx">b</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">modifyPointerArg1</span><span class="p">(</span><span class="nx">arg</span> <span class="o">*</span><span class="nx">ArgType</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">arg</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ArgType</span><span class="p">{</span><span class="s">&#34;arg1&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;inside modifyPointerArg1:&#34;</span><span class="p">,</span> <span class="nx">arg</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>答案是【不可以】</p>
<p>等会分析，再看一个，这个呢？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">modifyPointerArg2</span><span class="p">(</span><span class="nx">arg</span> <span class="o">*</span><span class="nx">ArgType</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">*</span><span class="nx">arg</span> <span class="p">=</span> <span class="nx">ArgType</span><span class="p">{</span><span class="s">&#34;arg2&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;inside modifyPointerArg2:&#34;</span><span class="p">,</span> <span class="nx">arg</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>答案是【可以】</p>
<p>仔细看下，你应该就明白了。</p>
<p>第一个替换的是arg指针本身,因为Go的参数传递是传值,函数返回后，并不影响指针arg所指向的值</p>
<p>至于modifyPointerArg2则是对指针解引用，修改了其指向的值</p>
<p>这样的方式其实还有很多，比如这个：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">modifyPointerArg3</span><span class="p">(</span><span class="nx">arg</span> <span class="o">*</span><span class="nx">ArgType</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">val</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span>
  <span class="nx">val</span><span class="p">.</span><span class="nf">Elem</span><span class="p">().</span><span class="nf">FieldByName</span><span class="p">(</span><span class="s">&#34;A&#34;</span><span class="p">).</span><span class="nf">SetString</span><span class="p">(</span><span class="s">&#34;arg3&#34;</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;inside modifyPointerArg3:&#34;</span><span class="p">,</span> <span class="nx">arg</span><span class="p">)</span>
  <span class="c1">// val.Elem().FieldByName(&#34;b&#34;).SetInt(3)
</span><span class="c1"></span>  <span class="c1">// panic: reflect: reflect.flag.mustBeAssignable using value obtained using unexported field
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>实际是利用反射的Elem()获取val的值</p>
<ul>
<li>如果其为空接口（empty interface），则获取其内部值（空接口值字段的类型是指针）</li>
<li>如果其为指针（pointer），则获取其指向的值</li>
</ul>
<p>获取到的结构如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Value</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 类型
</span><span class="c1"></span>    <span class="nx">typ</span> <span class="o">*</span><span class="nx">rtype</span>
    <span class="c1">// 值指针
</span><span class="c1"></span>    <span class="nx">ptr</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
    <span class="c1">// 标志位
</span><span class="c1"></span>  <span class="nx">flag</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>然后对应类型修改时, 实际就是对指针解引用修改其指向的值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Value</span><span class="p">)</span> <span class="nf">SetString</span><span class="p">(</span><span class="nx">x</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">v</span><span class="p">.</span><span class="nf">mustBeAssignable</span><span class="p">()</span>
  <span class="nx">v</span><span class="p">.</span><span class="nf">mustBe</span><span class="p">(</span><span class="nx">String</span><span class="p">)</span>
  <span class="c1">// 这里
</span><span class="c1"></span>  <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">)(</span><span class="nx">v</span><span class="p">.</span><span class="nx">ptr</span><span class="p">)</span> <span class="p">=</span> <span class="nx">x</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里注意一点，不导出的字段（结构体内小写的字段）不能用此类方法修改，会 panic！</p>
<p>再如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">modifyPointerArg4</span><span class="p">(</span><span class="nx">arg</span> <span class="o">*</span><span class="nx">ArgType</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">jsonStr</span> <span class="o">:=</span> <span class="s">`{&#34;A&#34;:&#34;arg4&#34;,&#34;b&#34;:4}`</span>
  <span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">jsonStr</span><span class="p">),</span> <span class="nx">arg</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>内部实际也是用了反射修改指针指向的值</p>
<p>另外，把上边几个测试函数由指针参数换为指针接受者，也是一样的</p>
<p>比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">arg</span> <span class="o">*</span><span class="nx">ArgType</span><span class="p">)</span> <span class="nf">modifyPointerReceiver4</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">jsonStr</span> <span class="o">:=</span> <span class="s">`{&#34;A&#34;:&#34;arg4&#34;,&#34;b&#34;:4}`</span>
  <span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">jsonStr</span><span class="p">),</span> <span class="nx">arg</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="map">Map<a hidden class="anchor" aria-hidden="true" href="#map">#</a></h2>
<p>了解清楚了传值和传引用，但是对于Map类型来说，可能觉得还是迷惑，一来我们可以通过方法修改它的内容，二来它没有明显的指针。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">persons</span><span class="o">:=</span><span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="nx">persons</span><span class="p">[</span><span class="s">&#34;张三&#34;</span><span class="p">]=</span><span class="mi">19</span>

	<span class="nx">mp</span><span class="o">:=&amp;</span><span class="nx">persons</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;原始map的内存地址是：%p\n&#34;</span><span class="p">,</span><span class="nx">mp</span><span class="p">)</span>
	<span class="nf">modify</span><span class="p">(</span><span class="nx">persons</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;map值被修改了，新值为:&#34;</span><span class="p">,</span><span class="nx">persons</span><span class="p">)</span>
<span class="p">}</span>

 <span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">p</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">){</span>
	 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;函数里接收到map的内存地址是：%p\n&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">)</span>
	 <span class="nx">p</span><span class="p">[</span><span class="s">&#34;张三&#34;</span><span class="p">]=</span><span class="mi">20</span>
 <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行打印输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s">原始<span class="n">map的内存地址是</span>：<span class="mh">0xc42000c028</span>
函数里接收到<span class="n">map的内存地址是</span>：<span class="mh">0xc42000c038</span>
<span class="n">map值被修改了</span>，新值为<span class="o">:</span> <span class="n">map[张三</span><span class="o">:</span><span class="m">20</span><span class="n">]</span>
</code></pre></td></tr></table>
</div>
</div><p>两个内存地址是不一样的，所以这又是一个值传递（值的拷贝），那么为什么我们可以修改Map的内容呢？先不急，我们先看一个自己实现的struct。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">p</span><span class="o">:=</span><span class="nx">Person</span><span class="p">{</span><span class="s">&#34;张三&#34;</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;原始Person的内存地址是：%p\n&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">)</span>
	<span class="nf">modify</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span>
<span class="p">}</span>

 <span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Person</span><span class="p">)</span> <span class="p">{</span>
	 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;函数里接收到Person的内存地址是：%p\n&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">)</span>
	 <span class="nx">p</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="s">&#34;李四&#34;</span>
 <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行打印输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s">原始<span class="n">Person的内存地址是</span>：<span class="mh">0xc4200721b0</span>
函数里接收到<span class="n">Person的内存地址是</span>：<span class="mh">0xc4200721c0</span>
<span class="p">{</span>张三<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们发现，我们自己定义的Person类型，在函数传参的时候也是值传递，但是它的值(Name字段)并没有被修改，我们想改成李四，发现最后的结果还是张三。</p>
<p>这也就是说，map类型和我们自己定义的struct类型是不一样的。我们尝试把modify函数的接收参数改为Person的指针。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">p</span><span class="o">:=</span><span class="nx">Person</span><span class="p">{</span><span class="s">&#34;张三&#34;</span><span class="p">}</span>
	<span class="nf">modify</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Person</span><span class="p">)</span> <span class="p">{</span>
	 <span class="nx">p</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="s">&#34;李四&#34;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在运行查看输出，我们发现，这次被修改了。我们这里省略了内存地址的打印，因为我们上面int类型的例子已经证明了指针类型的参数也是值传递的。 指针类型可以修改，非指针类型不行，那么我们可以大胆的猜测，我们使用make函数创建的map是不是一个指针类型呢？看一下源代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// makemap implements a Go map creation make(map[k]v, hint)
</span><span class="c1">// If the compiler has determined that the map or the first bucket
</span><span class="c1">// can be created on the stack, h and/or bucket may be non-nil.
</span><span class="c1">// If h != nil, the map can be created directly in h.
</span><span class="c1">// If bucket != nil, bucket can be used as the first bucket.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">makemap</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">hint</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">h</span><span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">bucket</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="o">*</span><span class="nx">hmap</span> <span class="p">{</span>
    <span class="c1">//省略无关代码
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>通过查看<code>src/runtime/hashmap.go</code>源代码发现，的确和我们猜测的一样，make函数返回的是一个hmap类型的指针<code>*hmap</code>。也就是说<code>map===*hmap</code>。 现在看<code>func modify(p map)</code>这样的函数，其实就等于<code>func modify(p*hmap)</code>，和我们前面第一节什么是值传递里举的<code>func modify(ip *int)</code>的例子一样，可以参考分析。</p>
<p>所以在这里，Go语言通过make函数，字面量的包装，为我们省去了指针的操作，让我们可以更容易的使用map。这里的map可以理解为引用类型，但是记住引用类型不是传引用。</p>
<h2 id="chan类型">chan类型<a hidden class="anchor" aria-hidden="true" href="#chan类型">#</a></h2>
<p>chan类型本质上和map类型是一样的，这里不做过多的介绍，参考下源代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makechan</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">chantype</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int64</span><span class="p">)</span><span class="o">*</span><span class="nx">hchan</span> <span class="p">{</span>
    <span class="c1">//省略无关代码
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>chan也是一个引用类型，和map相差无几，make返回的是一个*hchan。</p>
<h2 id="slice">slice<a hidden class="anchor" aria-hidden="true" href="#slice">#</a></h2>
<p>slice和map、chan都不太一样的，一样的是，它也是引用类型，它也可以在函数中修改对应的内容。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ages</span><span class="o">:=</span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;原始slice的内存地址是%p\n&#34;</span><span class="p">,</span><span class="nx">ages</span><span class="p">)</span>
	<span class="nf">modify</span><span class="p">(</span><span class="nx">ages</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ages</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">ages</span> <span class="p">[]</span><span class="kt">int</span><span class="p">){</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;函数里接收到slice的内存地址是%p\n&#34;</span><span class="p">,</span><span class="nx">ages</span><span class="p">)</span>
	<span class="nx">ages</span><span class="p">[</span><span class="mi">0</span><span class="p">]=</span><span class="mi">1</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行打印结果，发现的确是被修改了，而且我们这里打印slice的内存地址是可以直接通过<code>%p</code>打印的,不用使用<code>&amp;</code>取地址符转换。</p>
<p>这就可以证明make的slice也是一个指针了吗？不一定，也可能<code>fmt.Printf</code>把slice特殊处理了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">pp</span><span class="p">)</span> <span class="nf">fmtPointer</span><span class="p">(</span><span class="nx">value</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">u</span> <span class="kt">uintptr</span>
	<span class="k">switch</span> <span class="nx">value</span><span class="p">.</span><span class="nf">Kind</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Chan</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Func</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Map</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Ptr</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Slice</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">UnsafePointer</span><span class="p">:</span>
		<span class="nx">u</span> <span class="p">=</span> <span class="nx">value</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">()</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nx">p</span><span class="p">.</span><span class="nf">badVerb</span><span class="p">(</span><span class="nx">verb</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">//省略部分代码
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>通过源代码发现，对于chan、map、slice等被当成指针处理，通过value.Pointer()获取对应的值的指针。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// If v&#39;s Kind is Slice, the returned pointer is to the first
</span><span class="c1">// element of the slice. If the slice is nil the returned value
</span><span class="c1">// is 0.  If the slice is empty but non-nil the return value is non-zero.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Value</span><span class="p">)</span> <span class="nf">Pointer</span><span class="p">()</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="c1">// TODO: deprecate
</span><span class="c1"></span>	<span class="nx">k</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">kind</span><span class="p">()</span>
	<span class="k">switch</span> <span class="nx">k</span> <span class="p">{</span>
	<span class="c1">//省略无关代码
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">Slice</span><span class="p">:</span>
		<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">SliceHeader</span><span class="p">)(</span><span class="nx">v</span><span class="p">.</span><span class="nx">ptr</span><span class="p">).</span><span class="nx">Data</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>很明显了，当是slice类型的时候，返回是slice这个结构体里，字段Data第一个元素的地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SliceHeader</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Data</span> <span class="kt">uintptr</span>
	<span class="nx">Len</span>  <span class="kt">int</span>
	<span class="nx">Cap</span>  <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">slice</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">array</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="nx">len</span>   <span class="kt">int</span>
	<span class="nx">cap</span>   <span class="kt">int</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>所以我们通过<code>%p</code>打印的slice变量ages的地址其实就是内部存储数组元素的地址，slice是一种结构体+元素指针的混合类型，通过元素<code>array(Data)</code>的指针，可以达到修改slice里存储元素的目的。</p>
<p>所以修改类型的内容的办法有很多种，类型本身作为指针可以，类型里有指针类型的字段也可以。</p>
<p>单纯的从slice这个结构体看，我们可以通过modify修改存储元素的内容，但是永远修改不了len和cap，因为他们只是一个拷贝，如果要修改，那就要传递<code>*slice</code>作为参数才可以。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">i</span><span class="o">:=</span><span class="mi">19</span>
	<span class="nx">p</span><span class="o">:=</span><span class="nx">Person</span><span class="p">{</span><span class="nx">name</span><span class="p">:</span><span class="s">&#34;张三&#34;</span><span class="p">,</span><span class="nx">age</span><span class="p">:</span><span class="o">&amp;</span><span class="nx">i</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
	<span class="nf">modify</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span> <span class="kt">string</span>
	<span class="nx">age</span>  <span class="o">*</span><span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Person</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span><span class="p">{</span>
	<span class="k">return</span> <span class="s">&#34;姓名为：&#34;</span> <span class="o">+</span> <span class="nx">p</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s">&#34;,年龄为：&#34;</span><span class="o">+</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">.</span><span class="nx">age</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Person</span><span class="p">){</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="s">&#34;李四&#34;</span>
	<span class="o">*</span><span class="nx">p</span><span class="p">.</span><span class="nx">age</span> <span class="p">=</span> <span class="mi">20</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行打印输出结果为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s">姓名为：张三<span class="p">,</span>年龄为：<span class="m">19</span>
姓名为：张三<span class="p">,</span>年龄为：<span class="m">20</span>
</code></pre></td></tr></table>
</div>
</div><p>通过这个Person和slice对比，就更好理解了，Person的name字段就类似于slice的len和cap字段，age字段类似于array字段。在传参为非指针类型的情况下，只能修改age字段，name字段无法修改。要修改name字段，就要把传参改为指针，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">modify</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">)</span>
<span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Person</span><span class="p">){</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="s">&#34;李四&#34;</span>
	<span class="o">*</span><span class="nx">p</span><span class="p">.</span><span class="nx">age</span> <span class="p">=</span> <span class="mi">20</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这样name和age字段双双都被修改了。</p>
<p>所以slice类型也是引用类型。</p>
<h2 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h2>
<p>最终我们可以确认的是Go语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。</p>
<p>是否可以修改原内容数据，和传值、传引用没有必然的关系。在C++中，传引用肯定是可以修改原内容数据的，在Go语言里，虽然只有传值，但是我们也可以修改原内容数据，因为参数是引用类型。</p>
<p>这里也要记住，引用类型和传引用是两个概念。</p>
<p>再记住，Go里只有传值（值传递）。</p>
<h2 id="转载">转载<a hidden class="anchor" aria-hidden="true" href="#转载">#</a></h2>
<p><a href="https://www.flysnow.org/2018/02/24/golang-function-parameters-passed-by-value.html">Go语言参数传递是传值还是传引用</a></p>
<p><a href="https://gocn.vip/topics/10455">Dig101-Go 之如何在函数内修改指针指向</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go/">Go</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
