<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>RESTful API设计规范 | Forz Blog</title>
<meta name="keywords" content="REST" />
<meta name="description" content="理解架构 名称 REST，即Representational State Transfer的缩写。我对这个词组的翻译是&quot;表现层状态转化&quot;">
<meta name="author" content="">
<link rel="canonical" href="/post/restful-api%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="RESTful API设计规范" />
<meta property="og:description" content="理解架构 名称 REST，即Representational State Transfer的缩写。我对这个词组的翻译是&quot;表现层状态转化&quot;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/restful-api%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-04-28T16:13:14&#43;00:00" />
<meta property="article:modified_time" content="2020-04-28T16:13:14&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="RESTful API设计规范"/>
<meta name="twitter:description" content="理解架构 名称 REST，即Representational State Transfer的缩写。我对这个词组的翻译是&quot;表现层状态转化&quot;"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "RESTful API设计规范",
      "item": "/post/restful-api%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "RESTful API设计规范",
  "name": "RESTful API设计规范",
  "description": "理解架构 名称 REST，即Representational State Transfer的缩写。我对这个词组的翻译是\u0026quot;表现层状态转化\u0026quot;",
  "keywords": [
    "REST"
  ],
  "articleBody": "理解架构 名称 REST，即Representational State Transfer的缩写。我对这个词组的翻译是\"表现层状态转化\"。\n如果一个架构符合REST原则，就称它为RESTful架构。\n要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。\n资源（Resources） REST的名称\"表现层状态转化\"中，省略了主语。“表现层\"其实指的是\"资源”（Resources）的\"表现层\"。\n所谓\"资源\"，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。\n所谓\"上网\"，就是与互联网上一系列的\"资源\"互动，调用它的URI。\n表现层（Representation） “资源\"是一种信息实体，它可以有多种外在表现形式。我们把\"资源\"具体呈现出来的形式，叫做它的\"表现层”（Representation）。\n比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。\nURI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的\".html\"后缀名是不必要的，因为这个后缀名表示格式，属于\"表现层\"范畴，而URI应该只代表\"资源\"的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对\"表现层\"的描述。\n状态转化（State Transfer） 访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。\n互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生\"状态转化\"（State Transfer）。而这种转化是建立在表现层之上的，所以就是\"表现层状态转化\"。\n客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，主要有四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。\n综述 综合上面的解释，我们总结一下什么是RESTful架构：\n 每一个URI代表一种资源； 客户端和服务器之间，传递这种资源的某种表现层； 客户端通过四个HTTP动词，对服务器端资源进行操作，实现\"表现层状态转化\"。  设计规范 RESTful API 设计规范 该仓库整理了目前比较流行的 RESTful api 设计规范，为了方便讨论规范带来的问题及争议，现把该文档托管于 Github，欢迎大家补充！！\nTable of Contents  RESTful API 设计规范 关于「能愿动词」的使用 Protocol API Root URL Versioning  在 URL 中嵌入版本编号 通过媒体类型来指定版本信息   Endpoints HTTP 动词 Filtering Authentication Response  200 ok 201 Created 202 Accepted 204 No Content 3xx 重定向 400 Bad Request 401 Unauthorized 403 Forbidden 404 Not Found 405 Method Not Allowd 406 Not Acceptable 408 Request Timeout 409 Gonfilct 410 Gone 413 Request Entity Too Large 414 Request-URI Too Long 415 Unsupported Media Type 429 Too Many Request 500 Internal Server Error 503 Service Unavailable   版权声明 建议参考 LICENSE  关于「能愿动词」的使用 为了避免歧义，文档大量使用了「能愿动词」，对应的解释如下：\n 必须 (MUST)：绝对，严格遵循，请照做，无条件遵守； 一定不可 (MUST NOT)：禁令，严令禁止； 应该 (SHOULD) ：强烈建议这样做，但是不强求； 不该 (SHOULD NOT)：强烈不建议这样做，但是不强求； 可以 (MAY) 和 可选 (OPTIONAL) ：选择性高一点，在这个文档内，此词语使用较少；   参见：RFC 2119\n Protocol 客户端在通过 API 与后端服务通信的过程中，应该 使用 HTTPS 协议。\nAPI Root URL API 的根入口点应尽可能保持足够简单，这里有两个常见的 URL 根例子：\n api.example.com/* example.com/api/*   如果你的应用很庞大或者你预计它将会变的很庞大，那 应该 将 API 放到子域下（api.example.com）。这种做法可以保持某些规模化上的灵活性。\n Versioning 所有的 API 必须保持向后兼容，你 必须 在引入新版本 API 的同时确保旧版本 API 仍然可用。所以 应该 为其提供版本支持。\n目前比较常见的两种版本号形式：\n在 URL 中嵌入版本编号 1  api.example.com/v1/*   这种做法是版本号直观、易于调试；另一种做法是，将版本号放在 HTTP Header 头中：\n通过媒体类型来指定版本信息 1  Accept: application/vnd.example.com.v1+json   其中 vnd 表示 Standards Tree 标准树类型，有三个不同的树: x，prs 和 vnd。你使用的标准树需要取决于你开发的项目\n 未注册的树（x）主要表示本地和私有环境 私有树（prs）主要表示没有商业发布的项目 供应商树（vnd）主要表示公开发布的项目   后面几个参数依次为应用名称（一般为应用域名）、版本号、期望的返回格式。\n 至于具体把版本号放在什么地方，这个问题一直存在很大的争议，但由于我们大多数时间都在使用 Laravel 开发，应该 使用 dingo/api 来快速构建应用，它采用第二种方式来管理 API 版本，并且已集成了标准的 HTTP Response。\nEndpoints 端点就是指向特定资源或资源集合的 URL。在端点的设计中，你 必须 遵守下列约定：\n URL 的命名 必须 全部小写 URL 中资源（resource）的命名 必须 是名词，并且 必须 是复数形式 必须 优先使用 Restful 类型的 URL URL 必须 是易读的 URL 一定不可 暴露服务器架构   至于 URL 是否必须使用连字符（-） 或下划线（_），不做硬性规定，但 必须 根据团队情况统一一种风格。\n 来看一个反例\n https://api.example.com/getUserInfo?userid=1 https://api.example.com/getusers https://api.example.com/sv/u https://api.example.com/cgi-bin/users/get_user.php?userid=1  再来看一个正列\n https://api.example.com/zoos https://api.example.com/animals https://api.example.com/zoos/{zoo}/animals https://api.example.com/animal_types https://api.example.com/employees  HTTP 动词 对于资源的具体操作类型，由 HTTP 动词表示。常用的 HTTP 动词有下面五个（括号里是对应的 SQL 命令）。\n GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。  其中\n1 删除资源 必须 用 DELETE 方法 2 创建新的资源 必须 使用 POST 方法 3 更新资源 应该 使用 PUT 方法 4 获取资源信息 必须 使用 GET 方法\n针对每一个端点来说，下面列出所有可行的 HTTP 动词和端点的组合\n   请求方法 URL 描述     GET /zoos 列出所有的动物园(ID和名称，不要太详细)   POST /zoos 新增一个新的动物园   GET /zoos/{zoo} 获取指定动物园详情   PUT /zoos/{zoo} 更新指定动物园(整个对象)   PATCH /zoos/{zoo} 更新动物园(部分对象)   DELETE /zoos/{zoo} 删除指定动物园   GET /zoos/{zoo}/animals 检索指定动物园下的动物列表(ID和名称，不要太详细)   GET /animals 列出所有动物(ID和名称)。   POST /animals 新增新的动物   GET /animals/{animal} 获取指定的动物详情   PUT /animals/{animal} 更新指定的动物(整个对象)   PATCH /animals/{animal} 更新指定的动物(部分对象)   GET /animal_types 获取所有动物类型(ID和名称，不要太详细)   GET /animal_types/{type} 获取指定的动物类型详情   GET /employees 检索整个雇员列表   GET /employees/{employee} 检索指定特定的员工   GET /zoos/{zoo}/employees 检索在这个动物园工作的雇员的名单(身份证和姓名)   POST /employees 新增指定新员工   POST /zoos/{zoo}/employees 在特定的动物园雇佣一名员工   DELETE /zoos/{zoo}/employees/{employee} 从某个动物园解雇一名员工     超出 Restful 端点的，应该 模仿上表的方式来定义端点。\n Filtering  如果记录数量很多，服务器不可能都将它们返回给用户。API 应该 提供参数，过滤返回结果。下面是一些常见的参数。\n  ?limit=10：指定返回记录的数量 ?offset=10：指定返回记录的开始位置。 ?page=2\u0026per_page=100：指定第几页，以及每页的记录数。 ?sortby=name\u0026order=asc：指定返回结果按照哪个属性排序，以及排序顺序。 ?animal_type_id=1：指定筛选条件  所有 URL 参数 必须 是全小写，必须 使用下划线类型的参数形式。\n 分页参数 必须 固定为 page、per_page\n 经常使用的、复杂的查询 应该 标签化，降低维护成本。如\n1 2 3 4  GET /trades?status=closed\u0026sort=sortby=name\u0026order=asc # 可为其定制快捷方式 GET /trades/recently_closed   Authentication 应该 使用 OAuth2.0 的方式为 API 调用者提供登录认证。必须 先通过登录接口获取 Access Token 后再通过该 token 调用需要身份认证的 API。\nOauth 的端点设计示列\n RFC 6749 /token Twitter /oauth2/token Fackbook /oauth/access_token Google /o/oauth2/token Github /login/oauth/access_token Instagram /oauth/authorize  客户端在获得 access token 的同时 必须 在响应中包含一个名为 expires_in 的数据，它表示当前获得的 token 会在多少 秒 后失效。\n1 2 3 4 5  { \"access_token\": \"token....\", \"token_type\": \"Bearer\", \"expires_in\": 3600 }   客户端在请求需要认证的 API 时，必须 在请求头 Authorization 中带上 access_token。\n1  Authorization: Bearer token...   当超过指定的秒数后，access token 就会过期，再次用过期/或无效的 token 访问时，服务端 应该 返回 invalid_token 的错误或 401 错误码。\n1 2 3 4 5 6 7 8  HTTP/1.1 401 Unauthorized Content-Type: application/json Cache-Control: no-store Pragma: no-cache { \"error\": \"invalid_token\" }    Laravel 开发中，应该 使用 JWT 来为管理你的 Token，并且 一定不可 在 api 中间件中开启请求 session。\n Response 所有的 API 响应，必须 遵守 HTTP 设计规范，必须 选择合适的 HTTP 状态码。一定不可 所有接口都返回状态码为 200 的 HTTP 响应，如：\n1 2 3 4 5 6 7 8 9 10 11  HTTP/1.1 200 ok Content-Type: application/json Server: example.com { \"code\": 0, \"msg\": \"success\", \"data\": { \"username\": \"username\" } }   或\n1 2 3 4 5 6 7 8  HTTP/1.1 200 ok Content-Type: application/json Server: example.com { \"code\": -1, \"msg\": \"该活动不存在\", }   下表列举了常见的 HTTP 状态码\n   状态码 描述     1xx 代表请求已被接受，需要继续处理   2xx 请求已成功，请求所希望的响应头或数据体将随此响应返回   3xx 重定向   4xx 客户端原因引起的错误   5xx 服务端原因引起的错误     只有来自客户端的请求被正确的处理后才能返回 2xx 的响应，所以当 API 返回 2xx 类型的状态码时，前端 必须 认定该请求已处理成功。\n 必须强调的是，所有 API 一定不可 返回 1xx 类型的状态码。当 API 发生错误时，必须 返回出错时的详细信息。目前常见返回错误信息的方法有两种：\n1、将错误详细放入 HTTP 响应首部；\n1 2 3  X-MYNAME-ERROR-CODE: 4001 X-MYNAME-ERROR-MESSAGE: Bad authentication token X-MYNAME-ERROR-INFO: http://docs.example.com/api/v1/authentication   2、直接放入响应实体中；\n1 2 3 4 5 6 7 8 9  HTTP/1.1 401 Unauthorized Server: nginx/1.11.9 Content-Type: application/json Transfer-Encoding: chunked Cache-Control: no-cache, private Date: Sun, 24 Jun 2018 10:02:59 GMT Connection: keep-alive {\"error_code\":40100,\"message\":\"Unauthorized\"}   考虑到易读性和客户端的易处理性，我们 必须 把错误信息直接放到响应实体中，并且错误格式 应该 满足如下格式：\n1 2 3 4  { \"message\": \"您查找的资源不存在\", \"error_code\": 404001 }   其中错误码（error_code）必须 和 HTTP 状态码对应，也方便错误码归类，如：\n1 2 3 4 5 6 7 8 9  HTTP/1.1 429 Too Many Requests Server: nginx/1.11.9 Content-Type: application/json Transfer-Encoding: chunked Cache-Control: no-cache, private Date: Sun, 24 Jun 2018 10:15:52 GMT Connection: keep-alive {\"error_code\":429001,\"message\":\"你操作太频繁了\"}   1 2 3 4 5 6 7 8 9  HTTP/1.1 403 Forbidden Server: nginx/1.11.9 Content-Type: application/json Transfer-Encoding: chunked Cache-Control: no-cache, private Date: Sun, 24 Jun 2018 10:19:27 GMT Connection: keep-alive {\"error_code\":403002,\"message\":\"用户已禁用\"}   应该 在返回的错误信息中，同时包含面向开发者和面向用户的提示信息，前者可方便开发人员调试，后者可直接展示给终端用户查看如：\n1 2 3 4 5 6 7 8  { \"message\": \"直接展示给终端用户的错误信息\", \"error_code\": \"业务错误码\", \"error\": \"供开发者查看的错误信息\", \"debug\": [ \"错误堆栈，必须开启 debug 才存在\" ] }   下面详细列举了各种情况 API 的返回说明。\n200 ok 200 状态码是最常见的 HTTP 状态码，在所有 成功 的 GET 请求中，必须 返回此状态码。HTTP 响应实体部分 必须 直接就是数据，不要做多余的包装。\n错误示例：\n1 2 3 4 5 6 7 8 9 10 11  HTTP/1.1 200 ok Content-Type: application/json Server: example.com { \"user\": { \"id\":1, \"nickname\":\"fwest\", \"username\": \"example\" } }   正确示例：\n1、获取单个资源详情\n1 2 3 4 5  { \"id\": 1, \"username\": \"godruoyi\", \"age\": 88, }   2、获取资源集合\n1 2 3 4 5 6 7 8 9 10 11 12  [ { \"id\": 1, \"username\": \"godruoyi\", \"age\": 88, }, { \"id\": 2, \"username\": \"foo\", \"age\": 88, } ]   3、额外的媒体信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  { \"data\": [ { \"id\": 1, \"avatar\": \"https://lorempixel.com/640/480/?32556\", \"nickname\": \"fwest\", \"last_logined_time\": \"2018-05-29 04:56:43\", \"has_registed\": true }, { \"id\": 2, \"avatar\": \"https://lorempixel.com/640/480/?86144\", \"nickname\": \"zschowalter\", \"last_logined_time\": \"2018-06-16 15:18:34\", \"has_registed\": true } ], \"meta\": { \"pagination\": { \"total\": 101, \"count\": 2, \"per_page\": 2, \"current_page\": 1, \"total_pages\": 51, \"links\": { \"next\": \"http://api.example.com?page=2\" } } } }    其中，分页和其他额外的媒体信息，必须放到 meta 字段中。\n 201 Created 当服务器创建数据成功时，应该 返回此状态码。常见的应用场景是使用 POST 提交用户信息，如：\n 添加了新用户 上传了图片 创建了新活动  等，都可以返回 201 状态码。需要注意的是，你可以选择在用户创建成功后返回新用户的数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  HTTP/1.1 201 Created Server: nginx/1.11.9 Content-Type: application/json Transfer-Encoding: chunked Date: Sun, 24 Jun 2018 09:13:40 GMT Connection: keep-alive { \"id\": 1, \"avatar\": \"https:\\/\\/lorempixel.com\\/640\\/480\\/?32556\", \"nickname\": \"fwest\", \"last_logined_time\": \"2018-05-29 04:56:43\", \"created_at\": \"2018-06-16 17:55:55\", \"updated_at\": \"2018-06-16 17:55:55\" }   也可以返回一个响应实体为空的 HTTP Response 如：\n1 2 3 4 5 6  HTTP/1.1 201 Created Server: nginx/1.11.9 Content-Type: text/html; charset=UTF-8 Transfer-Encoding: chunked Date: Sun, 24 Jun 2018 09:12:20 GMT Connection: keep-alive    这里我们 应该 采用第二种方式，因为大多数情况下，客户端只需要知道该请求操作成功与否，并不需要返回新资源的信息。\n 202 Accepted 该状态码表示服务器已经接受到了来自客户端的请求，但还未开始处理。常用短信发送、邮件通知、模板消息推送等这类很耗时需要队列支持的场景中；\n 返回该状态码时，响应实体 必须 为空。\n 1 2 3 4 5 6  HTTP/1.1 202 Accepted Server: nginx/1.11.9 Content-Type: text/html; charset=UTF-8 Transfer-Encoding: chunked Date: Sun, 24 Jun 2018 09:25:15 GMT Connection: keep-alive   204 No Content 该状态码表示响应实体不包含任何数据，其中：\n 在使用 DELETE 方法删除资源 成功 时，必须 返回该状态码 使用 PUT、PATCH 方法更新数据 成功 时，也 应该 返回此状态码  1 2 3 4  HTTP/1.1 204 No Content Server: nginx/1.11.9 Date: Sun, 24 Jun 2018 09:29:12 GMT Connection: keep-alive   3xx 重定向 所有 API 不该 返回 3xx 类型的状态码。因为 3xx 类型的响应格式一般为下列格式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  HTTP/1.1 302 Found Server: nginx/1.11.9 Content-Type: text/html; charset=UTF-8 Transfer-Encoding: chunked Cache-Control: no-cache, private Date: Sun, 24 Jun 2018 09:41:50 GMT Location: https://example.com Connection: keep-alive  html head meta charset=\"UTF-8\" / meta http-equiv=\"refresh\" content=\"0;url=https://example.com\" / titleRedirecting to https://example.comtitle head body Redirecting to a href=\"https://example.com\"https://example.coma. body html   所有 API 一定不可 返回纯 HTML 结构的响应；若一定要使用重定向功能，可以 返回一个响应实体为空的 3xx 响应，并在响应头中加上 Location 字段:\n1 2 3 4 5 6 7  HTTP/1.1 302 Found Server: nginx/1.11.9 Content-Type: text/html; charset=UTF-8 Transfer-Encoding: chunked Date: Sun, 24 Jun 2018 09:52:50 GMT Location: https://godruoyi.com Connection: keep-alive   400 Bad Request 由于明显的客户端错误（例如，请求语法格式错误、无效的请求、无效的签名等），服务器 应该 放弃该请求。\n 当服务器无法从其他 4xx 类型的状态码中找出合适的来表示错误类型时，都 必须 返回该状态码。\n 1 2 3 4 5 6 7 8 9  HTTP/1.1 400 Bad Request Server: nginx/1.11.9 Content-Type: application/json Transfer-Encoding: chunked Cache-Control: no-cache, private Date: Sun, 24 Jun 2018 13:22:36 GMT Connection: keep-alive {\"error_code\":40000,\"message\":\"无效的签名\"}   401 Unauthorized 该状态码表示当前请求需要身份认证，以下情况都 必须 返回该状态码。\n 未认证用户访问需要认证的 API access_token 无效/过期   客户端在收到 401 响应后，都 应该 提示用户进行下一步的登录操作。\n 1 2 3 4 5 6 7 8 9 10  HTTP/1.1 401 Unauthorized Server: nginx/1.11.9 Content-Type: application/json Transfer-Encoding: chunked WWW-Authenticate: JWTAuth Cache-Control: no-cache, private Date: Sun, 24 Jun 2018 13:17:02 GMT Connection: keep-alive {\"message\":\"Token Signature could not be verified.\",\"error_code\": \"40100\"}   403 Forbidden 该状态码可以简单的理解为没有权限访问该请求，服务器收到请求但拒绝提供服务。\n如当普通用户请求操作管理员用户时，必须 返回该状态码。\n1 2 3 4 5 6 7 8 9  HTTP/1.1 403 Forbidden Server: nginx/1.11.9 Content-Type: application/json Transfer-Encoding: chunked Cache-Control: no-cache, private Date: Sun, 24 Jun 2018 13:05:34 GMT Connection: keep-alive {\"error_code\":40301,\"message\":\"权限不足\"}   404 Not Found 该状态码表示用户请求的资源不存在，如\n 获取不存在的用户信息 （get /users/9999999） 访问不存在的端点  都 必须 返回该状态码，若该资源已永久不存在，则 应该 返回 410 响应。\n405 Method Not Allowed 当客户端使用的 HTTP 请求方法不被服务器允许时，必须 返回该状态码。\n 如客户端调用了 POST 方法来访问只支持 GET 方法的 API\n 该响应 必须 返回一个 Allow 头信息用以表示出当前资源能够接受的请求方法的列表。\n1 2 3 4 5 6 7 8 9 10  HTTP/1.1 405 Method Not Allowed Server: nginx/1.11.9 Content-Type: application/json Transfer-Encoding: chunked Allow: GET, HEAD Cache-Control: no-cache, private Date: Sun, 24 Jun 2018 12:30:57 GMT Connection: keep-alive {\"message\":\"405 Method Not Allowed\",\"error_code\": 40500}   406 Not Acceptable API 在不支持客户端指定的数据格式时，应该返回此状态码。如支持 JSON 和 XML 输出的 API 被指定返回 YAML 格式的数据时。\n Http 协议一般通过请求首部的 Accept 来指定数据格式\n 408 Request Timeout 客户端请求超时时 必须 返回该状态码，需要注意的时，该状态码表示 客户端请求超时，在涉及第三方 API 调用超时时，一定不可 返回该状态码。\n409 Confilct 该状态码表示因为请求存在冲突无法处理。如通过手机号码提供注册功能的 API，当用户提交的手机号已存在时，必须 返回此状态码。\n1 2 3 4 5 6 7 8 9  HTTP/1.1 409 Conflict Server: nginx/1.11.9 Content-Type: application/json Transfer-Encoding: chunked Cache-Control: no-cache, private Date: Sun, 24 Jun 2018 12:19:04 GMT Connection: keep-alive {\"error_code\":40900,\"message\":\"手机号已存在\"}   410 Gone 和 404 类似，该状态码也表示请求的资源不存在，只是 410 状态码进一步表示所请求的资源已不存在，并且未来也不会存在。在收到 410 状态码后，客户端 应该 停止再次请求该资源。\n413 Request Entity Too Large 该状态码表示服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。\n 此种情况下，服务器可以关闭连接以免客户端继续发送此请求。\n 如果这个状况是临时的，服务器 应该 返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。\n414 Request-URI Too Long 该状态码表示请求的 URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。\n415 Unsupported Media Type 通常表示服务器不支持客户端请求首部 Content-Type 指定的数据格式。如在只接受 JSON 格式的 API 中放入 XML 类型的数据并向服务器发送，都 应该 返回该状态码。\n该状态码也可用于如：只允许上传图片格式的文件，但是客户端提交媒体文件非法或不是图片类型，这时 应该 返回该状态码：\n1 2 3 4 5 6 7 8 9  HTTP/1.1 415 Unsupported Media Type Server: nginx/1.11.9 Content-Type: application/json Transfer-Encoding: chunked Cache-Control: no-cache, private Date: Sun, 24 Jun 2018 12:09:40 GMT Connection: keep-alive {\"error_code\":41500,\"message\":\"不允许上传的图片格式\"}   429 Too Many Requests 该状态码表示用户请求次数超过允许范围。如 API 设定为 60次/分钟，当用户在一分钟内请求次数超过 60 次后，都 应该 返回该状态码。并且也 应该 在响应首部中加上下列头部：\n1 2 3 4  X-RateLimit-Limit: 10 请求速率（由应用设定，其单位一般为小时/分钟等，这里是 10次/5分钟） X-RateLimit-Remaining: 0 当前剩余的请求数量 X-RateLimit-Reset: 1529839462 重置时间 Retry-After: 120 下一次访问应该等待的时间（秒）   列子\n1 2 3 4 5 6 7 8 9 10 11 12 13  HTTP/1.1 429 Too Many Requests Server: nginx/1.11.9 Content-Type: application/json Transfer-Encoding: chunked X-RateLimit-Limit: 10 X-RateLimit-Remaining: 0 X-RateLimit-Reset: 1529839462 Retry-After: 290 Cache-Control: no-cache, private Date: Sun, 24 Jun 2018 11:19:32 GMT Connection: keep-alive {\"message\":\"You have exceeded your rate limit.\",\"error_code\":42900}   必须 为所有的 API 设置 Rate Limit 支持。\n500 Internal Server Error 该状态码 必须 在服务器出错时抛出，对于所有的 500 错误，都 应该 提供完整的错误信息支持，也方便跟踪调试。\n503 Service Unavailable 该状态码表示服务器暂时处理不可用状态，当服务器需要维护或第三方 API 请求超时/不可达时，都 应该 返回该状态码，其中若是主动关闭 API 服务，应该 在返回的响应首部加上 Retry-After 头部，表示多少秒后可以再次访问。\n1 2 3 4 5 6 7 8 9 10  HTTP/1.1 503 Service Unavailable Server: nginx/1.11.9 Content-Type: application/json Transfer-Encoding: chunked Cache-Control: no-cache, private Date: Sun, 24 Jun 2018 10:56:20 GMT Retry-After: 60 Connection: keep-alive {\"error_code\":50300,\"message\":\"服务维护中\"}   其他 HTTP 状态码请参考 HTTP 状态码- 维基百科。\n版权声明  版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）\n 建议参考 restful-api-design-references\nPrinciples of good RESTful API Design（译）\n理解 RESTful 架构\nRESTful API 设计指南\nHTTP 状态码- 维基百科\n",
  "wordCount" : "7424",
  "inLanguage": "zh-cn",
  "datePublished": "2020-04-28T16:13:14Z",
  "dateModified": "2020-04-28T16:13:14Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/restful-api%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      RESTful API设计规范
    </h1>
    <div class="post-meta">April 28, 2020
</div>
  </header> 
  <div class="post-content"><h1 id="理解架构">理解架构<a hidden class="anchor" aria-hidden="true" href="#理解架构">#</a></h1>
<h2 id="名称">名称<a hidden class="anchor" aria-hidden="true" href="#名称">#</a></h2>
<p>REST，即Representational State Transfer的缩写。我对这个词组的翻译是&quot;表现层状态转化&quot;。</p>
<p>如果一个架构符合REST原则，就称它为RESTful架构。</p>
<p>要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。</p>
<h2 id="资源resources">资源（Resources）<a hidden class="anchor" aria-hidden="true" href="#资源resources">#</a></h2>
<p>REST的名称&quot;表现层状态转化&quot;中，省略了主语。&ldquo;表现层&quot;其实指的是&quot;资源&rdquo;（Resources）的&quot;表现层&quot;。</p>
<p>所谓&quot;资源&quot;，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p>
<p>所谓&quot;上网&quot;，就是与互联网上一系列的&quot;资源&quot;互动，调用它的URI。</p>
<h2 id="表现层representation">表现层（Representation）<a hidden class="anchor" aria-hidden="true" href="#表现层representation">#</a></h2>
<p>&ldquo;资源&quot;是一种信息实体，它可以有多种外在表现形式。我们把&quot;资源&quot;具体呈现出来的形式，叫做它的&quot;表现层&rdquo;（Representation）。</p>
<p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>
<p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的&quot;.html&quot;后缀名是不必要的，因为这个后缀名表示格式，属于&quot;表现层&quot;范畴，而URI应该只代表&quot;资源&quot;的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对&quot;表现层&quot;的描述。</p>
<h2 id="状态转化state-transfer">状态转化（State Transfer）<a hidden class="anchor" aria-hidden="true" href="#状态转化state-transfer">#</a></h2>
<p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>
<p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生&quot;状态转化&quot;（State Transfer）。而这种转化是建立在表现层之上的，所以就是&quot;表现层状态转化&quot;。</p>
<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，主要有四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p>
<h2 id="综述">综述<a hidden class="anchor" aria-hidden="true" href="#综述">#</a></h2>
<p>综合上面的解释，我们总结一下什么是RESTful架构：</p>
<ol>
<li>每一个URI代表一种资源；</li>
<li>客户端和服务器之间，传递这种资源的某种表现层；</li>
<li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现&quot;表现层状态转化&quot;。</li>
</ol>
<h1 id="设计规范">设计规范<a hidden class="anchor" aria-hidden="true" href="#设计规范">#</a></h1>
<h2 id="restful-api-设计规范">RESTful API 设计规范<a hidden class="anchor" aria-hidden="true" href="#restful-api-设计规范">#</a></h2>
<p>该仓库整理了目前比较流行的 <code>RESTful api</code> 设计规范，为了方便讨论规范带来的问题及争议，现把该文档托管于 <code>Github</code>，欢迎大家补充！！</p>
<h2 id="table-of-contents">Table of Contents<a hidden class="anchor" aria-hidden="true" href="#table-of-contents">#</a></h2>
<ul>
<li><a href="#restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83">RESTful API 设计规范</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E8%83%BD%E6%84%BF%E5%8A%A8%E8%AF%8D%E7%9A%84%E4%BD%BF%E7%94%A8">关于「能愿动词」的使用</a></li>
<li><a href="#protocol">Protocol</a></li>
<li><a href="#api-root-url">API Root URL</a></li>
<li><a href="#versioning">Versioning</a>
<ul>
<li><a href="#%E5%9C%A8-url-%E4%B8%AD%E5%B5%8C%E5%85%A5%E7%89%88%E6%9C%AC%E7%BC%96%E5%8F%B7">在 URL 中嵌入版本编号</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B%E6%9D%A5%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF">通过媒体类型来指定版本信息</a></li>
</ul>
</li>
<li><a href="#endpoints">Endpoints</a></li>
<li><a href="#http-%E5%8A%A8%E8%AF%8D">HTTP 动词</a></li>
<li><a href="#filtering">Filtering</a></li>
<li><a href="#authentication">Authentication</a></li>
<li><a href="#response">Response</a>
<ul>
<li><a href="#200-ok">200 ok</a></li>
<li><a href="#201-created">201 Created</a></li>
<li><a href="#202-accepted">202 Accepted</a></li>
<li><a href="#204-no-content">204 No Content</a></li>
<li><a href="#3xx-%E9%87%8D%E5%AE%9A%E5%90%91">3xx 重定向</a></li>
<li><a href="#400-bad-request">400 Bad Request</a></li>
<li><a href="#401-unauthorized">401 Unauthorized</a></li>
<li><a href="#403-forbidden">403 Forbidden</a></li>
<li><a href="#404-not-found">404 Not Found</a></li>
<li><a href="#405-method-not-allowd">405 Method Not Allowd</a></li>
<li><a href="#406-not-acceptable">406 Not Acceptable</a></li>
<li><a href="#408-request-timeout">408 Request Timeout</a></li>
<li><a href="#409-gonfilct">409 Gonfilct</a></li>
<li><a href="#410-gone">410 Gone</a></li>
<li><a href="#413-request-entity-too-large">413 Request Entity Too Large</a></li>
<li><a href="#414-request-uri-too-long">414 Request-URI Too Long</a></li>
<li><a href="#415-unsupported-media-type">415 Unsupported Media Type</a></li>
<li><a href="#429-too-many-request">429 Too Many Request</a></li>
<li><a href="#500-internal-server-error">500 Internal Server Error</a></li>
<li><a href="#503-service-unavailable">503 Service Unavailable</a></li>
</ul>
</li>
<li><a href="#%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E">版权声明</a></li>
<li><a href="#%E5%BB%BA%E8%AE%AE%E5%8F%82%E8%80%83">建议参考</a></li>
<li><a href="#license">LICENSE</a></li>
</ul>
<h2 id="关于能愿动词的使用">关于「能愿动词」的使用<a hidden class="anchor" aria-hidden="true" href="#关于能愿动词的使用">#</a></h2>
<p>为了避免歧义，文档大量使用了「能愿动词」，对应的解释如下：</p>
<ul>
<li><code>必须 (MUST)</code>：绝对，严格遵循，请照做，无条件遵守；</li>
<li><code>一定不可 (MUST NOT)</code>：禁令，严令禁止；</li>
<li><code>应该 (SHOULD)</code> ：强烈建议这样做，但是不强求；</li>
<li><code>不该 (SHOULD NOT)</code>：强烈不建议这样做，但是不强求；</li>
<li><code>可以 (MAY)</code> 和 <code>可选 (OPTIONAL)</code> ：选择性高一点，在这个文档内，此词语使用较少；</li>
</ul>
<blockquote>
<p>参见：<a href="http://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a></p>
</blockquote>
<h2 id="protocol">Protocol<a hidden class="anchor" aria-hidden="true" href="#protocol">#</a></h2>
<p>客户端在通过 <code>API</code> 与后端服务通信的过程中，<code>应该</code> 使用 <code>HTTPS</code> 协议。</p>
<h2 id="api-root-url">API Root URL<a hidden class="anchor" aria-hidden="true" href="#api-root-url">#</a></h2>
<p><code>API</code> 的根入口点应尽可能保持足够简单，这里有两个常见的 <code>URL</code> 根例子：</p>
<ul>
<li>api.example.com/*</li>
<li>example.com/api/*</li>
</ul>
<blockquote>
<p>如果你的应用很庞大或者你预计它将会变的很庞大，那 <code>应该</code> 将 <code>API</code> 放到子域下（<code>api.example.com</code>）。这种做法可以保持某些规模化上的灵活性。</p>
</blockquote>
<h2 id="versioning">Versioning<a hidden class="anchor" aria-hidden="true" href="#versioning">#</a></h2>
<p>所有的 <code>API</code> 必须保持向后兼容，你 <code>必须</code> 在引入新版本 <code>API</code> 的同时确保旧版本 <code>API</code> 仍然可用。所以 <code>应该</code> 为其提供版本支持。</p>
<p>目前比较常见的两种版本号形式：</p>
<h3 id="在-url-中嵌入版本编号">在 URL 中嵌入版本编号<a hidden class="anchor" aria-hidden="true" href="#在-url-中嵌入版本编号">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">api.example.com/v1/*
</code></pre></td></tr></table>
</div>
</div><p>这种做法是版本号直观、易于调试；另一种做法是，将版本号放在 <code>HTTP Header</code> 头中：</p>
<h3 id="通过媒体类型来指定版本信息">通过媒体类型来指定版本信息<a hidden class="anchor" aria-hidden="true" href="#通过媒体类型来指定版本信息">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">Accept: application/vnd.example.com.v1+json
</code></pre></td></tr></table>
</div>
</div><p>其中 <code>vnd</code> 表示 <code>Standards Tree</code> 标准树类型，有三个不同的树: <code>x</code>，<code>prs</code> 和 <code>vnd</code>。你使用的标准树需要取决于你开发的项目</p>
<ul>
<li>未注册的树（<code>x</code>）主要表示本地和私有环境</li>
<li>私有树（<code>prs</code>）主要表示没有商业发布的项目</li>
<li>供应商树（<code>vnd</code>）主要表示公开发布的项目</li>
</ul>
<blockquote>
<p>后面几个参数依次为应用名称（一般为应用域名）、版本号、期望的返回格式。</p>
</blockquote>
<p>至于具体把版本号放在什么地方，这个问题一直存在很大的争议，但由于我们大多数时间都在使用 <code>Laravel</code> 开发，<code>应该</code> 使用 <a href="https://github.com/dingo/api">dingo/api</a> 来快速构建应用，它采用第二种方式来管理 <code>API</code> 版本，并且已集成了标准的 <code>HTTP Response</code>。</p>
<h2 id="endpoints">Endpoints<a hidden class="anchor" aria-hidden="true" href="#endpoints">#</a></h2>
<p>端点就是指向特定资源或资源集合的 <code>URL</code>。在端点的设计中，你 <code>必须</code> 遵守下列约定：</p>
<ul>
<li>URL 的命名 <code>必须</code> 全部小写</li>
<li>URL 中资源（<code>resource</code>）的命名 <code>必须</code> 是名词，并且 <code>必须</code> 是复数形式</li>
<li><code>必须</code> 优先使用 <code>Restful</code> 类型的 URL</li>
<li>URL <code>必须</code> 是易读的</li>
<li>URL <code>一定不可</code> 暴露服务器架构</li>
</ul>
<blockquote>
<p>至于 URL 是否必须使用连字符（<code>-</code>） 或下划线（<code>_</code>），不做硬性规定，但 <code>必须</code> 根据团队情况统一一种风格。</p>
</blockquote>
<p>来看一个反例</p>
<ul>
<li><a href="https://api.example.com/getUserInfo?userid=1">https://api.example.com/getUserInfo?userid=1</a></li>
<li><a href="https://api.example.com/getusers">https://api.example.com/getusers</a></li>
<li><a href="https://api.example.com/sv/u">https://api.example.com/sv/u</a></li>
<li><a href="https://api.example.com/cgi-bin/users/get_user.php?userid=1">https://api.example.com/cgi-bin/users/get_user.php?userid=1</a></li>
</ul>
<p>再来看一个正列</p>
<ul>
<li><a href="https://api.example.com/zoos">https://api.example.com/zoos</a></li>
<li><a href="https://api.example.com/animals">https://api.example.com/animals</a></li>
<li><a href="https://api.example.com/zoos/%7Bzoo%7D/animals">https://api.example.com/zoos/{zoo}/animals</a></li>
<li><a href="https://api.example.com/animal_types">https://api.example.com/animal_types</a></li>
<li><a href="https://api.example.com/employees">https://api.example.com/employees</a></li>
</ul>
<h2 id="http-动词">HTTP 动词<a hidden class="anchor" aria-hidden="true" href="#http-动词">#</a></h2>
<p>对于资源的具体操作类型，由 <code>HTTP</code> 动词表示。常用的 <code>HTTP</code> 动词有下面五个（括号里是对应的 <code>SQL</code> 命令）。</p>
<ul>
<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>
<li>POST（CREATE）：在服务器新建一个资源。</li>
<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>
<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>
<li>DELETE（DELETE）：从服务器删除资源。</li>
</ul>
<p>其中</p>
<p>1 删除资源 <code>必须</code> 用 <code>DELETE</code> 方法
2 创建新的资源 <code>必须</code> 使用 <code>POST</code> 方法
3 更新资源 <code>应该</code> 使用 <code>PUT</code> 方法
4 获取资源信息 <code>必须</code> 使用 <code>GET</code> 方法</p>
<p>针对每一个端点来说，下面列出所有可行的 <code>HTTP</code> 动词和端点的组合</p>
<table>
<thead>
<tr>
<th>请求方法</th>
<th>URL</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>/zoos</td>
<td>列出所有的动物园(ID和名称，不要太详细)</td>
</tr>
<tr>
<td>POST</td>
<td>/zoos</td>
<td>新增一个新的动物园</td>
</tr>
<tr>
<td>GET</td>
<td>/zoos/{zoo}</td>
<td>获取指定动物园详情</td>
</tr>
<tr>
<td>PUT</td>
<td>/zoos/{zoo}</td>
<td>更新指定动物园(整个对象)</td>
</tr>
<tr>
<td>PATCH</td>
<td>/zoos/{zoo}</td>
<td>更新动物园(部分对象)</td>
</tr>
<tr>
<td>DELETE</td>
<td>/zoos/{zoo}</td>
<td>删除指定动物园</td>
</tr>
<tr>
<td>GET</td>
<td>/zoos/{zoo}/animals</td>
<td>检索指定动物园下的动物列表(ID和名称，不要太详细)</td>
</tr>
<tr>
<td>GET</td>
<td>/animals</td>
<td>列出所有动物(ID和名称)。</td>
</tr>
<tr>
<td>POST</td>
<td>/animals</td>
<td>新增新的动物</td>
</tr>
<tr>
<td>GET</td>
<td>/animals/{animal}</td>
<td>获取指定的动物详情</td>
</tr>
<tr>
<td>PUT</td>
<td>/animals/{animal}</td>
<td>更新指定的动物(整个对象)</td>
</tr>
<tr>
<td>PATCH</td>
<td>/animals/{animal}</td>
<td>更新指定的动物(部分对象)</td>
</tr>
<tr>
<td>GET</td>
<td>/animal_types</td>
<td>获取所有动物类型(ID和名称，不要太详细)</td>
</tr>
<tr>
<td>GET</td>
<td>/animal_types/{type}</td>
<td>获取指定的动物类型详情</td>
</tr>
<tr>
<td>GET</td>
<td>/employees</td>
<td>检索整个雇员列表</td>
</tr>
<tr>
<td>GET</td>
<td>/employees/{employee}</td>
<td>检索指定特定的员工</td>
</tr>
<tr>
<td>GET</td>
<td>/zoos/{zoo}/employees</td>
<td>检索在这个动物园工作的雇员的名单(身份证和姓名)</td>
</tr>
<tr>
<td>POST</td>
<td>/employees</td>
<td>新增指定新员工</td>
</tr>
<tr>
<td>POST</td>
<td>/zoos/{zoo}/employees</td>
<td>在特定的动物园雇佣一名员工</td>
</tr>
<tr>
<td>DELETE</td>
<td>/zoos/{zoo}/employees/{employee}</td>
<td>从某个动物园解雇一名员工</td>
</tr>
</tbody>
</table>
<blockquote>
<p>超出 <code>Restful</code> 端点的，<code>应该</code> 模仿上表的方式来定义端点。</p>
</blockquote>
<h2 id="filtering">Filtering<a hidden class="anchor" aria-hidden="true" href="#filtering">#</a></h2>
<blockquote>
<p>如果记录数量很多，服务器不可能都将它们返回给用户。API <code>应该</code> 提供参数，过滤返回结果。下面是一些常见的参数。</p>
</blockquote>
<ul>
<li>?limit=10：指定返回记录的数量</li>
<li>?offset=10：指定返回记录的开始位置。</li>
<li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li>
<li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li>
<li>?animal_type_id=1：指定筛选条件</li>
</ul>
<p>所有 <code>URL</code> 参数 <code>必须</code> 是全小写，<code>必须</code> 使用下划线类型的参数形式。</p>
<blockquote>
<p>分页参数 <code>必须</code> 固定为 <code>page</code>、<code>per_page</code></p>
</blockquote>
<p>经常使用的、复杂的查询 <code>应该</code> 标签化，降低维护成本。如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">GET /trades?status<span class="o">=</span>closed<span class="p">&amp;</span><span class="nv">sort</span><span class="o">=</span><span class="nv">sortby</span><span class="o">=</span>name<span class="p">&amp;</span><span class="nv">order</span><span class="o">=</span>asc

<span class="c1"># 可为其定制快捷方式</span>
GET /trades/recently_closed
</code></pre></td></tr></table>
</div>
</div><h2 id="authentication">Authentication<a hidden class="anchor" aria-hidden="true" href="#authentication">#</a></h2>
<p><code>应该</code> 使用 <code>OAuth2.0</code> 的方式为 API 调用者提供登录认证。<code>必须</code> 先通过登录接口获取 <code>Access Token</code> 后再通过该 <code>token</code> 调用需要身份认证的 <code>API</code>。</p>
<p>Oauth 的端点设计示列</p>
<ul>
<li>RFC 6749   /token</li>
<li>Twitter    /oauth2/token</li>
<li>Fackbook   /oauth/access_token</li>
<li>Google     /o/oauth2/token</li>
<li>Github     /login/oauth/access_token</li>
<li>Instagram  /oauth/authorize</li>
</ul>
<p>客户端在获得 <code>access token</code> 的同时 <code>必须</code> 在响应中包含一个名为 <code>expires_in</code> 的数据，它表示当前获得的 <code>token</code> 会在多少 <code>秒</code> 后失效。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;access_token&#34;</span><span class="p">:</span> <span class="s2">&#34;token....&#34;</span><span class="p">,</span>
    <span class="nt">&#34;token_type&#34;</span><span class="p">:</span> <span class="s2">&#34;Bearer&#34;</span><span class="p">,</span>
    <span class="nt">&#34;expires_in&#34;</span><span class="p">:</span> <span class="mi">3600</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>客户端在请求需要认证的 <code>API</code> 时，<code>必须</code> 在请求头 <code>Authorization</code> 中带上 <code>access_token</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">Authorization: Bearer token...
</code></pre></td></tr></table>
</div>
</div><p>当超过指定的秒数后，<code>access token</code> 就会过期，再次用过期/或无效的 <code>token</code> 访问时，服务端 <code>应该</code> 返回 <code>invalid_token</code> 的错误或 <code>401</code> 错误码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">401</span> <span class="ne">Unauthorized</span>
<span class="n">Content-Type</span><span class="o">:</span> <span class="l">application/json</span>
<span class="n">Cache-Control</span><span class="o">:</span> <span class="l">no-store</span>
<span class="n">Pragma</span><span class="o">:</span> <span class="l">no-cache</span>

<span class="p">{</span>
    <span class="nt">&#34;error&#34;</span><span class="p">:</span> <span class="s2">&#34;invalid_token&#34;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>Laravel 开发中，<code>应该</code> 使用 <a href="https://github.com/tymondesigns/jwt-auth">JWT</a> 来为管理你的 Token，并且 <code>一定不可</code> 在 <code>api</code> 中间件中开启请求 <code>session</code>。</p>
</blockquote>
<h2 id="response">Response<a hidden class="anchor" aria-hidden="true" href="#response">#</a></h2>
<p>所有的 <code>API</code> 响应，<code>必须</code> 遵守 <code>HTTP</code> 设计规范，<code>必须</code> 选择合适的 <code>HTTP</code> 状态码。<code>一定不可</code> 所有接口都返回状态码为 <code>200</code> 的 <code>HTTP</code> 响应，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">200</span> <span class="ne">ok</span>
<span class="n">Content-Type</span><span class="o">:</span> <span class="l">application/json</span>
<span class="n">Server</span><span class="o">:</span> <span class="l">example.com</span>

<span class="p">{</span>
    <span class="nt">&#34;code&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nt">&#34;msg&#34;</span><span class="p">:</span> <span class="s2">&#34;success&#34;</span><span class="p">,</span>
    <span class="nt">&#34;data&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;username&#34;</span><span class="p">:</span> <span class="s2">&#34;username&#34;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>或</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">200</span> <span class="ne">ok</span>
<span class="n">Content-Type</span><span class="o">:</span> <span class="l">application/json</span>
<span class="n">Server</span><span class="o">:</span> <span class="l">example.com</span>

<span class="p">{</span>
    <span class="nt">&#34;code&#34;</span><span class="p">:</span> <span class="mi">-1</span><span class="p">,</span>
    <span class="nt">&#34;msg&#34;</span><span class="p">:</span> <span class="s2">&#34;该活动不存在&#34;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>下表列举了常见的 <code>HTTP</code> 状态码</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1xx</td>
<td>代表请求已被接受，需要继续处理</td>
</tr>
<tr>
<td>2xx</td>
<td>请求已成功，请求所希望的响应头或数据体将随此响应返回</td>
</tr>
<tr>
<td>3xx</td>
<td>重定向</td>
</tr>
<tr>
<td>4xx</td>
<td>客户端原因引起的错误</td>
</tr>
<tr>
<td>5xx</td>
<td>服务端原因引起的错误</td>
</tr>
</tbody>
</table>
<blockquote>
<p>只有来自客户端的请求被正确的处理后才能返回 <code>2xx</code> 的响应，所以当 API 返回 <code>2xx</code> 类型的状态码时，前端 <code>必须</code> 认定该请求已处理成功。</p>
</blockquote>
<p>必须强调的是，所有 <code>API</code> <code>一定不可</code> 返回 <code>1xx</code> 类型的状态码。当 <code>API</code> 发生错误时，<code>必须</code> 返回出错时的详细信息。目前常见返回错误信息的方法有两种：</p>
<p>1、将错误详细放入 <code>HTTP</code> 响应首部；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="err">X-MYNAME-ERROR-CODE: 4001
</span><span class="err">X-MYNAME-ERROR-MESSAGE: Bad authentication token
</span><span class="err">X-MYNAME-ERROR-INFO: http://docs.example.com/api/v1/authentication
</span></code></pre></td></tr></table>
</div>
</div><p>2、直接放入响应实体中；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">401</span> <span class="ne">Unauthorized</span>
<span class="n">Server</span><span class="o">:</span> <span class="l">nginx/1.11.9</span>
<span class="n">Content-Type</span><span class="o">:</span> <span class="l">application/json</span>
<span class="n">Transfer-Encoding</span><span class="o">:</span> <span class="l">chunked</span>
<span class="n">Cache-Control</span><span class="o">:</span> <span class="l">no-cache, private</span>
<span class="n">Date</span><span class="o">:</span> <span class="l">Sun, 24 Jun 2018 10:02:59 GMT</span>
<span class="n">Connection</span><span class="o">:</span> <span class="l">keep-alive</span>

<span class="p">{</span><span class="nt">&#34;error_code&#34;</span><span class="p">:</span><span class="mi">40100</span><span class="p">,</span><span class="nt">&#34;message&#34;</span><span class="p">:</span><span class="s2">&#34;Unauthorized&#34;</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>考虑到易读性和客户端的易处理性，我们 <code>必须</code> 把错误信息直接放到响应实体中，并且错误格式 <code>应该</code> 满足如下格式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;message&#34;</span><span class="p">:</span> <span class="s2">&#34;您查找的资源不存在&#34;</span><span class="p">,</span>
    <span class="nt">&#34;error_code&#34;</span><span class="p">:</span> <span class="mi">404001</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中错误码（<code>error_code</code>）<code>必须</code> 和 <code>HTTP</code> 状态码对应，也方便错误码归类，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">429</span> <span class="ne">Too Many Requests</span>
<span class="n">Server</span><span class="o">:</span> <span class="l">nginx/1.11.9</span>
<span class="n">Content-Type</span><span class="o">:</span> <span class="l">application/json</span>
<span class="n">Transfer-Encoding</span><span class="o">:</span> <span class="l">chunked</span>
<span class="n">Cache-Control</span><span class="o">:</span> <span class="l">no-cache, private</span>
<span class="n">Date</span><span class="o">:</span> <span class="l">Sun, 24 Jun 2018 10:15:52 GMT</span>
<span class="n">Connection</span><span class="o">:</span> <span class="l">keep-alive</span>

<span class="p">{</span><span class="nt">&#34;error_code&#34;</span><span class="p">:</span><span class="mi">429001</span><span class="p">,</span><span class="nt">&#34;message&#34;</span><span class="p">:</span><span class="s2">&#34;你操作太频繁了&#34;</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">403</span> <span class="ne">Forbidden</span>
<span class="n">Server</span><span class="o">:</span> <span class="l">nginx/1.11.9</span>
<span class="n">Content-Type</span><span class="o">:</span> <span class="l">application/json</span>
<span class="n">Transfer-Encoding</span><span class="o">:</span> <span class="l">chunked</span>
<span class="n">Cache-Control</span><span class="o">:</span> <span class="l">no-cache, private</span>
<span class="n">Date</span><span class="o">:</span> <span class="l">Sun, 24 Jun 2018 10:19:27 GMT</span>
<span class="n">Connection</span><span class="o">:</span> <span class="l">keep-alive</span>

<span class="p">{</span><span class="nt">&#34;error_code&#34;</span><span class="p">:</span><span class="mi">403002</span><span class="p">,</span><span class="nt">&#34;message&#34;</span><span class="p">:</span><span class="s2">&#34;用户已禁用&#34;</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>应该</code> 在返回的错误信息中，同时包含面向开发者和面向用户的提示信息，前者可方便开发人员调试，后者可直接展示给终端用户查看如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;message&#34;</span><span class="p">:</span> <span class="s2">&#34;直接展示给终端用户的错误信息&#34;</span><span class="p">,</span>
    <span class="nt">&#34;error_code&#34;</span><span class="p">:</span> <span class="s2">&#34;业务错误码&#34;</span><span class="p">,</span>
    <span class="nt">&#34;error&#34;</span><span class="p">:</span> <span class="s2">&#34;供开发者查看的错误信息&#34;</span><span class="p">,</span>
    <span class="nt">&#34;debug&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&#34;错误堆栈，必须开启 debug 才存在&#34;</span>
    <span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>下面详细列举了各种情况 API 的返回说明。</p>
<h3 id="200-ok">200 ok<a hidden class="anchor" aria-hidden="true" href="#200-ok">#</a></h3>
<p><code>200</code> 状态码是最常见的 <code>HTTP</code> 状态码，在所有 <strong>成功</strong> 的 <code>GET</code> 请求中，<code>必须</code> 返回此状态码。<code>HTTP</code> 响应实体部分 <code>必须</code> 直接就是数据，不要做多余的包装。</p>
<p>错误示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">200</span> <span class="ne">ok</span>
<span class="n">Content-Type</span><span class="o">:</span> <span class="l">application/json</span>
<span class="n">Server</span><span class="o">:</span> <span class="l">example.com</span>

<span class="p">{</span>
    <span class="nt">&#34;user&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;id&#34;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="nt">&#34;nickname&#34;</span><span class="p">:</span><span class="s2">&#34;fwest&#34;</span><span class="p">,</span>
        <span class="nt">&#34;username&#34;</span><span class="p">:</span> <span class="s2">&#34;example&#34;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>正确示例：</p>
<p>1、获取单个资源详情</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nt">&#34;username&#34;</span><span class="p">:</span> <span class="s2">&#34;godruoyi&#34;</span><span class="p">,</span>
    <span class="nt">&#34;age&#34;</span><span class="p">:</span> <span class="mi">88</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>2、获取资源集合</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">[</span>
    <span class="p">{</span>
        <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nt">&#34;username&#34;</span><span class="p">:</span> <span class="s2">&#34;godruoyi&#34;</span><span class="p">,</span>
        <span class="nt">&#34;age&#34;</span><span class="p">:</span> <span class="mi">88</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="nt">&#34;username&#34;</span><span class="p">:</span> <span class="s2">&#34;foo&#34;</span><span class="p">,</span>
        <span class="nt">&#34;age&#34;</span><span class="p">:</span> <span class="mi">88</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>3、额外的媒体信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;data&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="nt">&#34;avatar&#34;</span><span class="p">:</span> <span class="s2">&#34;https://lorempixel.com/640/480/?32556&#34;</span><span class="p">,</span>
            <span class="nt">&#34;nickname&#34;</span><span class="p">:</span> <span class="s2">&#34;fwest&#34;</span><span class="p">,</span>
            <span class="nt">&#34;last_logined_time&#34;</span><span class="p">:</span> <span class="s2">&#34;2018-05-29 04:56:43&#34;</span><span class="p">,</span>
            <span class="nt">&#34;has_registed&#34;</span><span class="p">:</span> <span class="kc">true</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="nt">&#34;avatar&#34;</span><span class="p">:</span> <span class="s2">&#34;https://lorempixel.com/640/480/?86144&#34;</span><span class="p">,</span>
            <span class="nt">&#34;nickname&#34;</span><span class="p">:</span> <span class="s2">&#34;zschowalter&#34;</span><span class="p">,</span>
            <span class="nt">&#34;last_logined_time&#34;</span><span class="p">:</span> <span class="s2">&#34;2018-06-16 15:18:34&#34;</span><span class="p">,</span>
            <span class="nt">&#34;has_registed&#34;</span><span class="p">:</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">],</span>
    <span class="nt">&#34;meta&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;pagination&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;total&#34;</span><span class="p">:</span> <span class="mi">101</span><span class="p">,</span>
            <span class="nt">&#34;count&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="nt">&#34;per_page&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="nt">&#34;current_page&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="nt">&#34;total_pages&#34;</span><span class="p">:</span> <span class="mi">51</span><span class="p">,</span>
            <span class="nt">&#34;links&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;next&#34;</span><span class="p">:</span> <span class="s2">&#34;http://api.example.com?page=2&#34;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>其中，分页和其他额外的媒体信息，必须放到 <code>meta</code> 字段中。</p>
</blockquote>
<h3 id="201-created">201 Created<a hidden class="anchor" aria-hidden="true" href="#201-created">#</a></h3>
<p>当服务器创建数据成功时，<code>应该</code> 返回此状态码。常见的应用场景是使用 <code>POST</code> 提交用户信息，如：</p>
<ul>
<li>添加了新用户</li>
<li>上传了图片</li>
<li>创建了新活动</li>
</ul>
<p>等，都可以返回 <code>201</code> 状态码。需要注意的是，你可以选择在用户创建成功后返回新用户的数据</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">201</span> <span class="ne">Created</span>
<span class="n">Server</span><span class="o">:</span> <span class="l">nginx/1.11.9</span>
<span class="n">Content-Type</span><span class="o">:</span> <span class="l">application/json</span>
<span class="n">Transfer-Encoding</span><span class="o">:</span> <span class="l">chunked</span>
<span class="n">Date</span><span class="o">:</span> <span class="l">Sun, 24 Jun 2018 09:13:40 GMT</span>
<span class="n">Connection</span><span class="o">:</span> <span class="l">keep-alive</span>

<span class="p">{</span>
    <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nt">&#34;avatar&#34;</span><span class="p">:</span> <span class="s2">&#34;https:\/\/lorempixel.com\/640\/480\/?32556&#34;</span><span class="p">,</span>
    <span class="nt">&#34;nickname&#34;</span><span class="p">:</span> <span class="s2">&#34;fwest&#34;</span><span class="p">,</span>
    <span class="nt">&#34;last_logined_time&#34;</span><span class="p">:</span> <span class="s2">&#34;2018-05-29 04:56:43&#34;</span><span class="p">,</span>
    <span class="nt">&#34;created_at&#34;</span><span class="p">:</span> <span class="s2">&#34;2018-06-16 17:55:55&#34;</span><span class="p">,</span>
    <span class="nt">&#34;updated_at&#34;</span><span class="p">:</span> <span class="s2">&#34;2018-06-16 17:55:55&#34;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>也可以返回一个响应实体为空的 <code>HTTP Response</code> 如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">201</span> <span class="ne">Created</span>
<span class="n">Server</span><span class="o">:</span> <span class="l">nginx/1.11.9</span>
<span class="n">Content-Type</span><span class="o">:</span> <span class="l">text/html; charset=UTF-8</span>
<span class="n">Transfer-Encoding</span><span class="o">:</span> <span class="l">chunked</span>
<span class="n">Date</span><span class="o">:</span> <span class="l">Sun, 24 Jun 2018 09:12:20 GMT</span>
<span class="n">Connection</span><span class="o">:</span> <span class="l">keep-alive</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>这里我们 <code>应该</code> 采用第二种方式，因为大多数情况下，客户端只需要知道该请求操作成功与否，并不需要返回新资源的信息。</p>
</blockquote>
<h3 id="202-accepted">202 Accepted<a hidden class="anchor" aria-hidden="true" href="#202-accepted">#</a></h3>
<p>该状态码表示服务器已经接受到了来自客户端的请求，但还未开始处理。常用短信发送、邮件通知、模板消息推送等这类很耗时需要队列支持的场景中；</p>
<blockquote>
<p>返回该状态码时，响应实体 <code>必须</code> 为空。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html">HTTP/1.1 202 Accepted
Server: nginx/1.11.9
Content-Type: text/html; charset=UTF-8
Transfer-Encoding: chunked
Date: Sun, 24 Jun 2018 09:25:15 GMT
Connection: keep-alive
</code></pre></td></tr></table>
</div>
</div><h3 id="204-no-content">204 No Content<a hidden class="anchor" aria-hidden="true" href="#204-no-content">#</a></h3>
<p>该状态码表示响应实体不包含任何数据，其中：</p>
<ul>
<li>在使用 <code>DELETE</code> 方法删除资源 <strong>成功</strong> 时，<code>必须</code> 返回该状态码</li>
<li>使用 <code>PUT</code>、<code>PATCH</code> 方法更新数据 <strong>成功</strong> 时，也 <code>应该</code> 返回此状态码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">204</span> <span class="ne">No Content</span>
<span class="n">Server</span><span class="o">:</span> <span class="l">nginx/1.11.9</span>
<span class="n">Date</span><span class="o">:</span> <span class="l">Sun, 24 Jun 2018 09:29:12 GMT</span>
<span class="n">Connection</span><span class="o">:</span> <span class="l">keep-alive</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="3xx-重定向">3xx 重定向<a hidden class="anchor" aria-hidden="true" href="#3xx-重定向">#</a></h3>
<p>所有 <code>API</code> <code>不该</code> 返回 <code>3xx</code> 类型的状态码。因为 <code>3xx</code> 类型的响应格式一般为下列格式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html">HTTP/1.1 302 Found
Server: nginx/1.11.9
Content-Type: text/html; charset=UTF-8
Transfer-Encoding: chunked
Cache-Control: no-cache, private
Date: Sun, 24 Jun 2018 09:41:50 GMT
Location: https://example.com
Connection: keep-alive

<span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&#34;UTF-8&#34;</span> <span class="p">/&gt;</span>
        <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">http-equiv</span><span class="o">=</span><span class="s">&#34;refresh&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;0;url=https://example.com&#34;</span> <span class="p">/&gt;</span>

        <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Redirecting to https://example.com<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
        Redirecting to <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://example.com&#34;</span><span class="p">&gt;</span>https://example.com<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>.
    <span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>所有 <code>API</code> <code>一定不可</code> 返回纯 <code>HTML</code> 结构的响应；若一定要使用重定向功能，<code>可以</code> 返回一个响应实体为空的 <code>3xx</code> 响应，并在响应头中加上 <code>Location</code> 字段:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">302</span> <span class="ne">Found</span>
<span class="n">Server</span><span class="o">:</span> <span class="l">nginx/1.11.9</span>
<span class="n">Content-Type</span><span class="o">:</span> <span class="l">text/html; charset=UTF-8</span>
<span class="n">Transfer-Encoding</span><span class="o">:</span> <span class="l">chunked</span>
<span class="n">Date</span><span class="o">:</span> <span class="l">Sun, 24 Jun 2018 09:52:50 GMT</span>
<span class="n">Location</span><span class="o">:</span> <span class="l">https://godruoyi.com</span>
<span class="n">Connection</span><span class="o">:</span> <span class="l">keep-alive</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="400-bad-request">400 Bad Request<a hidden class="anchor" aria-hidden="true" href="#400-bad-request">#</a></h3>
<p>由于明显的客户端错误（例如，请求语法格式错误、无效的请求、无效的签名等），服务器 <code>应该</code> 放弃该请求。</p>
<blockquote>
<p>当服务器无法从其他 4xx 类型的状态码中找出合适的来表示错误类型时，都 <code>必须</code> 返回该状态码。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">400</span> <span class="ne">Bad Request</span>
<span class="n">Server</span><span class="o">:</span> <span class="l">nginx/1.11.9</span>
<span class="n">Content-Type</span><span class="o">:</span> <span class="l">application/json</span>
<span class="n">Transfer-Encoding</span><span class="o">:</span> <span class="l">chunked</span>
<span class="n">Cache-Control</span><span class="o">:</span> <span class="l">no-cache, private</span>
<span class="n">Date</span><span class="o">:</span> <span class="l">Sun, 24 Jun 2018 13:22:36 GMT</span>
<span class="n">Connection</span><span class="o">:</span> <span class="l">keep-alive</span>

<span class="p">{</span><span class="nt">&#34;error_code&#34;</span><span class="p">:</span><span class="mi">40000</span><span class="p">,</span><span class="nt">&#34;message&#34;</span><span class="p">:</span><span class="s2">&#34;无效的签名&#34;</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="401-unauthorized">401 Unauthorized<a hidden class="anchor" aria-hidden="true" href="#401-unauthorized">#</a></h3>
<p>该状态码表示当前请求需要身份认证，以下情况都 <code>必须</code> 返回该状态码。</p>
<ul>
<li>未认证用户访问需要认证的 API</li>
<li>access_token 无效/过期</li>
</ul>
<blockquote>
<p>客户端在收到 <code>401</code> 响应后，都 <code>应该</code> 提示用户进行下一步的登录操作。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">401</span> <span class="ne">Unauthorized</span>
<span class="n">Server</span><span class="o">:</span> <span class="l">nginx/1.11.9</span>
<span class="n">Content-Type</span><span class="o">:</span> <span class="l">application/json</span>
<span class="n">Transfer-Encoding</span><span class="o">:</span> <span class="l">chunked</span>
<span class="n">WWW-Authenticate</span><span class="o">:</span> <span class="l">JWTAuth</span>
<span class="n">Cache-Control</span><span class="o">:</span> <span class="l">no-cache, private</span>
<span class="n">Date</span><span class="o">:</span> <span class="l">Sun, 24 Jun 2018 13:17:02 GMT</span>
<span class="n">Connection</span><span class="o">:</span> <span class="l">keep-alive</span>

<span class="p">{</span><span class="nt">&#34;message&#34;</span><span class="p">:</span><span class="s2">&#34;Token Signature could not be verified.&#34;</span><span class="p">,</span><span class="nt">&#34;error_code&#34;</span><span class="p">:</span> <span class="s2">&#34;40100&#34;</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="403-forbidden">403 Forbidden<a hidden class="anchor" aria-hidden="true" href="#403-forbidden">#</a></h3>
<p>该状态码可以简单的理解为没有权限访问该请求，服务器收到请求但拒绝提供服务。</p>
<p>如当普通用户请求操作管理员用户时，<code>必须</code> 返回该状态码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">403</span> <span class="ne">Forbidden</span>
<span class="n">Server</span><span class="o">:</span> <span class="l">nginx/1.11.9</span>
<span class="n">Content-Type</span><span class="o">:</span> <span class="l">application/json</span>
<span class="n">Transfer-Encoding</span><span class="o">:</span> <span class="l">chunked</span>
<span class="n">Cache-Control</span><span class="o">:</span> <span class="l">no-cache, private</span>
<span class="n">Date</span><span class="o">:</span> <span class="l">Sun, 24 Jun 2018 13:05:34 GMT</span>
<span class="n">Connection</span><span class="o">:</span> <span class="l">keep-alive</span>

<span class="p">{</span><span class="nt">&#34;error_code&#34;</span><span class="p">:</span><span class="mi">40301</span><span class="p">,</span><span class="nt">&#34;message&#34;</span><span class="p">:</span><span class="s2">&#34;权限不足&#34;</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="404-not-found">404 Not Found<a hidden class="anchor" aria-hidden="true" href="#404-not-found">#</a></h3>
<p>该状态码表示用户请求的资源不存在，如</p>
<ul>
<li>获取不存在的用户信息 （get /users/9999999）</li>
<li>访问不存在的端点</li>
</ul>
<p>都 <code>必须</code> 返回该状态码，若该资源已永久不存在，则 <code>应该</code> 返回 <code>410</code> 响应。</p>
<h3 id="405-method-not-allowed">405 Method Not Allowed<a hidden class="anchor" aria-hidden="true" href="#405-method-not-allowed">#</a></h3>
<p>当客户端使用的 <code>HTTP</code> 请求方法不被服务器允许时，<code>必须</code> 返回该状态码。</p>
<blockquote>
<p>如客户端调用了 <code>POST</code> 方法来访问只支持 GET 方法的 API</p>
</blockquote>
<p>该响应 <code>必须</code> 返回一个 <code>Allow</code> 头信息用以表示出当前资源能够接受的请求方法的列表。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">405</span> <span class="ne">Method Not Allowed</span>
<span class="n">Server</span><span class="o">:</span> <span class="l">nginx/1.11.9</span>
<span class="n">Content-Type</span><span class="o">:</span> <span class="l">application/json</span>
<span class="n">Transfer-Encoding</span><span class="o">:</span> <span class="l">chunked</span>
<span class="n">Allow</span><span class="o">:</span> <span class="l">GET, HEAD</span>
<span class="n">Cache-Control</span><span class="o">:</span> <span class="l">no-cache, private</span>
<span class="n">Date</span><span class="o">:</span> <span class="l">Sun, 24 Jun 2018 12:30:57 GMT</span>
<span class="n">Connection</span><span class="o">:</span> <span class="l">keep-alive</span>

<span class="p">{</span><span class="nt">&#34;message&#34;</span><span class="p">:</span><span class="s2">&#34;405 Method Not Allowed&#34;</span><span class="p">,</span><span class="nt">&#34;error_code&#34;</span><span class="p">:</span> <span class="mi">40500</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="406-not-acceptable">406 Not Acceptable<a hidden class="anchor" aria-hidden="true" href="#406-not-acceptable">#</a></h3>
<p><code>API</code> 在不支持客户端指定的数据格式时，应该返回此状态码。如支持 <code>JSON</code> 和 <code>XML</code> 输出的 <code>API</code> 被指定返回 <code>YAML</code> 格式的数据时。</p>
<blockquote>
<p>Http 协议一般通过请求首部的 Accept 来指定数据格式</p>
</blockquote>
<h3 id="408-request-timeout">408 Request Timeout<a hidden class="anchor" aria-hidden="true" href="#408-request-timeout">#</a></h3>
<p>客户端请求超时时 <code>必须</code> 返回该状态码，需要注意的时，该状态码表示 <strong>客户端请求超时</strong>，在涉及第三方 <code>API</code> 调用超时时，<code>一定不可</code> 返回该状态码。</p>
<h3 id="409-confilct">409 Confilct<a hidden class="anchor" aria-hidden="true" href="#409-confilct">#</a></h3>
<p>该状态码表示因为请求存在冲突无法处理。如通过手机号码提供注册功能的 <code>API</code>，当用户提交的手机号已存在时，<code>必须</code> 返回此状态码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">409</span> <span class="ne">Conflict</span>
<span class="n">Server</span><span class="o">:</span> <span class="l">nginx/1.11.9</span>
<span class="n">Content-Type</span><span class="o">:</span> <span class="l">application/json</span>
<span class="n">Transfer-Encoding</span><span class="o">:</span> <span class="l">chunked</span>
<span class="n">Cache-Control</span><span class="o">:</span> <span class="l">no-cache, private</span>
<span class="n">Date</span><span class="o">:</span> <span class="l">Sun, 24 Jun 2018 12:19:04 GMT</span>
<span class="n">Connection</span><span class="o">:</span> <span class="l">keep-alive</span>

<span class="p">{</span><span class="nt">&#34;error_code&#34;</span><span class="p">:</span><span class="mi">40900</span><span class="p">,</span><span class="nt">&#34;message&#34;</span><span class="p">:</span><span class="s2">&#34;手机号已存在&#34;</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="410-gone">410 Gone<a hidden class="anchor" aria-hidden="true" href="#410-gone">#</a></h3>
<p>和 <code>404</code> 类似，该状态码也表示请求的资源不存在，只是 <code>410</code> 状态码进一步表示所请求的资源已不存在，并且未来也不会存在。在收到 <code>410</code> 状态码后，客户端 <code>应该</code> 停止再次请求该资源。</p>
<h3 id="413-request-entity-too-large">413 Request Entity Too Large<a hidden class="anchor" aria-hidden="true" href="#413-request-entity-too-large">#</a></h3>
<p>该状态码表示服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。</p>
<blockquote>
<p>此种情况下，服务器可以关闭连接以免客户端继续发送此请求。</p>
</blockquote>
<p>如果这个状况是临时的，服务器 <code>应该</code> 返回一个 <code>Retry-After</code> 的响应头，以告知客户端可以在多少时间以后重新尝试。</p>
<h3 id="414-request-uri-too-long">414 Request-URI Too Long<a hidden class="anchor" aria-hidden="true" href="#414-request-uri-too-long">#</a></h3>
<p>该状态码表示请求的 <code>URI</code> 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。</p>
<h3 id="415-unsupported-media-type">415 Unsupported Media Type<a hidden class="anchor" aria-hidden="true" href="#415-unsupported-media-type">#</a></h3>
<p>通常表示服务器不支持客户端请求首部 <code>Content-Type</code> 指定的数据格式。如在只接受 <code>JSON</code> 格式的 <code>API</code> 中放入 <code>XML</code> 类型的数据并向服务器发送，都 <code>应该</code> 返回该状态码。</p>
<p>该状态码也可用于如：只允许上传图片格式的文件，但是客户端提交媒体文件非法或不是图片类型，这时 <code>应该</code> 返回该状态码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">415</span> <span class="ne">Unsupported Media Type</span>
<span class="n">Server</span><span class="o">:</span> <span class="l">nginx/1.11.9</span>
<span class="n">Content-Type</span><span class="o">:</span> <span class="l">application/json</span>
<span class="n">Transfer-Encoding</span><span class="o">:</span> <span class="l">chunked</span>
<span class="n">Cache-Control</span><span class="o">:</span> <span class="l">no-cache, private</span>
<span class="n">Date</span><span class="o">:</span> <span class="l">Sun, 24 Jun 2018 12:09:40 GMT</span>
<span class="n">Connection</span><span class="o">:</span> <span class="l">keep-alive</span>

<span class="p">{</span><span class="nt">&#34;error_code&#34;</span><span class="p">:</span><span class="mi">41500</span><span class="p">,</span><span class="nt">&#34;message&#34;</span><span class="p">:</span><span class="s2">&#34;不允许上传的图片格式&#34;</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="429-too-many-requests">429 Too Many Requests<a hidden class="anchor" aria-hidden="true" href="#429-too-many-requests">#</a></h3>
<p>该状态码表示用户请求次数超过允许范围。如 <code>API</code> 设定为 <code>60次/分钟</code>，当用户在一分钟内请求次数超过 60 次后，都 <code>应该</code> 返回该状态码。并且也 <code>应该</code> 在响应首部中加上下列头部：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">X-RateLimit-Limit: <span class="m">10</span> 请求速率（由应用设定，其单位一般为小时/分钟等，这里是 10次/5分钟）
X-RateLimit-Remaining: <span class="m">0</span> 当前剩余的请求数量
X-RateLimit-Reset: <span class="m">1529839462</span> 重置时间
Retry-After: <span class="m">120</span> 下一次访问应该等待的时间（秒）
</code></pre></td></tr></table>
</div>
</div><p>列子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">429</span> <span class="ne">Too Many Requests</span>
<span class="n">Server</span><span class="o">:</span> <span class="l">nginx/1.11.9</span>
<span class="n">Content-Type</span><span class="o">:</span> <span class="l">application/json</span>
<span class="n">Transfer-Encoding</span><span class="o">:</span> <span class="l">chunked</span>
<span class="n">X-RateLimit-Limit</span><span class="o">:</span> <span class="l">10</span>
<span class="n">X-RateLimit-Remaining</span><span class="o">:</span> <span class="l">0</span>
<span class="n">X-RateLimit-Reset</span><span class="o">:</span> <span class="l">1529839462</span>
<span class="n">Retry-After</span><span class="o">:</span> <span class="l">290</span>
<span class="n">Cache-Control</span><span class="o">:</span> <span class="l">no-cache, private</span>
<span class="n">Date</span><span class="o">:</span> <span class="l">Sun, 24 Jun 2018 11:19:32 GMT</span>
<span class="n">Connection</span><span class="o">:</span> <span class="l">keep-alive</span>

<span class="p">{</span><span class="nt">&#34;message&#34;</span><span class="p">:</span><span class="s2">&#34;You have exceeded your rate limit.&#34;</span><span class="p">,</span><span class="nt">&#34;error_code&#34;</span><span class="p">:</span><span class="mi">42900</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>必须</code> 为所有的 API 设置 Rate Limit 支持。</p>
<h3 id="500-internal-server-error">500 Internal Server Error<a hidden class="anchor" aria-hidden="true" href="#500-internal-server-error">#</a></h3>
<p>该状态码 <code>必须</code> 在服务器出错时抛出，对于所有的 <code>500</code> 错误，都 <code>应该</code> 提供完整的错误信息支持，也方便跟踪调试。</p>
<h3 id="503-service-unavailable">503 Service Unavailable<a hidden class="anchor" aria-hidden="true" href="#503-service-unavailable">#</a></h3>
<p>该状态码表示服务器暂时处理不可用状态，当服务器需要维护或第三方 <code>API</code> 请求超时/不可达时，都 <code>应该</code> 返回该状态码，其中若是主动关闭 API 服务，<code>应该 </code>在返回的响应首部加上 <code>Retry-After</code> 头部，表示多少秒后可以再次访问。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">503</span> <span class="ne">Service Unavailable</span>
<span class="n">Server</span><span class="o">:</span> <span class="l">nginx/1.11.9</span>
<span class="n">Content-Type</span><span class="o">:</span> <span class="l">application/json</span>
<span class="n">Transfer-Encoding</span><span class="o">:</span> <span class="l">chunked</span>
<span class="n">Cache-Control</span><span class="o">:</span> <span class="l">no-cache, private</span>
<span class="n">Date</span><span class="o">:</span> <span class="l">Sun, 24 Jun 2018 10:56:20 GMT</span>
<span class="n">Retry-After</span><span class="o">:</span> <span class="l">60</span>
<span class="n">Connection</span><span class="o">:</span> <span class="l">keep-alive</span>

<span class="p">{</span><span class="nt">&#34;error_code&#34;</span><span class="p">:</span><span class="mi">50300</span><span class="p">,</span><span class="nt">&#34;message&#34;</span><span class="p">:</span><span class="s2">&#34;服务维护中&#34;</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其他 <code>HTTP</code> 状态码请参考 <a href="https://zh.wikipedia.org/zh-hans/HTTP%E7%8A%B6%E6%80%81%E7%A0%81">HTTP 状态码- 维基百科</a>。</p>
<h2 id="版权声明">版权声明<a hidden class="anchor" aria-hidden="true" href="#版权声明">#</a></h2>
<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名（<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>）</p>
</blockquote>
<h2 id="建议参考">建议参考<a hidden class="anchor" aria-hidden="true" href="#建议参考">#</a></h2>
<p><a href="https://github.com/aisuhua/restful-api-design-references">restful-api-design-references</a></p>
<p><a href="http://www.cnblogs.com/moonz-wu/p/4211626.html">Principles of good RESTful API Design（译）</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html">理解 RESTful 架构</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html">RESTful API 设计指南</a></p>
<p><a href="https://zh.wikipedia.org/zh-hans/HTTP%E7%8A%B6%E6%80%81%E7%A0%81">HTTP 状态码- 维基百科</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/rest/">REST</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
