<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>设置用户ID位，保存设置用户ID，有效用户ID，实际用户ID | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="基本概念 实际用户ID（RUID） 用于标识一个系统中用户是谁，一般是在登录之后，就被唯一确定的，就是登陆的用户的uid 有效用户ID（EUID）">
<meta name="author" content="">
<link rel="canonical" href="/post/%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7id%E4%BD%8D%E4%BF%9D%E5%AD%98%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7id%E6%9C%89%E6%95%88%E7%94%A8%E6%88%B7id%E5%AE%9E%E9%99%85%E7%94%A8%E6%88%B7id/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="设置用户ID位，保存设置用户ID，有效用户ID，实际用户ID" />
<meta property="og:description" content="基本概念 实际用户ID（RUID） 用于标识一个系统中用户是谁，一般是在登录之后，就被唯一确定的，就是登陆的用户的uid 有效用户ID（EUID）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7id%E4%BD%8D%E4%BF%9D%E5%AD%98%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7id%E6%9C%89%E6%95%88%E7%94%A8%E6%88%B7id%E5%AE%9E%E9%99%85%E7%94%A8%E6%88%B7id/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-25T14:23:56&#43;00:00" />
<meta property="article:modified_time" content="2017-06-25T14:23:56&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="设置用户ID位，保存设置用户ID，有效用户ID，实际用户ID"/>
<meta name="twitter:description" content="基本概念 实际用户ID（RUID） 用于标识一个系统中用户是谁，一般是在登录之后，就被唯一确定的，就是登陆的用户的uid 有效用户ID（EUID）"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "设置用户ID位，保存设置用户ID，有效用户ID，实际用户ID",
      "item": "/post/%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7id%E4%BD%8D%E4%BF%9D%E5%AD%98%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7id%E6%9C%89%E6%95%88%E7%94%A8%E6%88%B7id%E5%AE%9E%E9%99%85%E7%94%A8%E6%88%B7id/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "设置用户ID位，保存设置用户ID，有效用户ID，实际用户ID",
  "name": "设置用户ID位，保存设置用户ID，有效用户ID，实际用户ID",
  "description": "基本概念 实际用户ID（RUID） 用于标识一个系统中用户是谁，一般是在登录之后，就被唯一确定的，就是登陆的用户的uid 有效用户ID（EUID）",
  "keywords": [
    
  ],
  "articleBody": "基本概念 实际用户ID（RUID） 用于标识一个系统中用户是谁，一般是在登录之后，就被唯一确定的，就是登陆的用户的uid\n有效用户ID（EUID） 用于系统决定用户对系统资源的权限。也就是说当用户做任何一个操作时，最终看它有没有权限，都是在判断有效用户ID是否有权限，如果有，则OK，否则报错不能执行。在正常情况下，一个用户登录之后（我们假设是A用户），A用户的有效用户ID和实际用户ID是相同的，但是如果A用户在某些场景中想要执行一些特权操作，而上面我们说到用户的任何操作，Linux内核都是通过检验有效用户ID来判断当前执行这个操作的用户是否具有权限，显然是特权操作，A用户没有权限，所以A用户就只能通过一定的手段来修改当前的有效用户ID使其具有执行特权操作的权限。这里说明了下面为什么我们需要修改有效用户ID，就是想再某一时刻能够执行一些特权操作。下面在举例说明。\n设置用户ID位 用于对外的权限的开发，它的作用是我们如何去修改有效用户ID，在后面的例子中在展开。\n保存设置用户ID（SUID） 是有效用户ID副本，既然有效用户ID是副本，那么它的作用肯定是为了以后恢复有效用户ID用的。\n改变三个用户ID的方法 下面这幅图给出了改变实际用户ID，有效用户ID和保存设置用户ID的方法\n设置用户ID位的作用 我们知道用户的密码都是存放在/etc/shadow文件下，我们看下这个文件的权限\nroot@debian:~# ls -l /etc/shadow -rw-r----- 1 root shadow 8013 Sep 8 14:58 /etc/shadow  假如我是一个普通用户，显然我是可以修改我的密码的，通过passwd命令，无可厚非。自己修改自己的密码肯定是被允许的。\n但是仔细想想你会发现不对啊，我作为一个普通用户登录后，我的实际用户ID和有效用户ID都是我自己的UID。从上面可以看出，显然我不具有修改/etc/shadow文件的权限，那我执行passwd命令时怎么改我的密码的呢？\n在基本概念中我们知道决定我们权限的是执行操作时的有效用户ID，所有我们在执行passwd命令时，我们的有效用户ID肯定被修改了。OK，我们看下面：\nroot@debian:~# ls -l /usr/bin/passwd -rwsr-xr-x 1 root root 43280 Feb 16 2011 /usr/bin/passwd  我们看到了一个s，对的，它就是我们的保存设置用户ID位，上面我们说过这个位的作用就是修改有效用户ID，那我们来看看他是如何修改执行passwd命令时的有效用户ID的。\n首先我们看下命令执行的过程，当普通用户执行passwd命令时，shell会fork出一个子进程，此时进程有效用户ID还是普通用户ID，然后exec程序执行/usr/bin/passwd。通过上面的表我们会知道，exec发现/usr/bin/passwd有SUID位，于是会把进程的有效用户ID设成设置成文件用户ID，显然就是root, 此时这个进程都获得了root权限, 得到了读写/etc/shadow文件的权限, 从而普通用户可完成密码的修改。exec进程退出后会恢复普通用户的EUID为普通用户ID.这样就不会使普通用户一直拥有root权限。\n这就是我们设置用户ID位的作用，它的存在就是为了普通用户在某些需要特权权限时，去临时的改变有效用户ID而获得特权权限。\n但是你可能有疑问，为什么我们不用setuid()直接修改呢？何苦绕这么大的弯子。但是如果可以使用setuid()来直接修改有效用户ID来获得特权权限，那么我们的特权权限就会不可控了。这违背了最小权限模型。\n所以我们Linux特意将setuid设置成在非特权用户下，有效用户ID只能设置成为实际用户ID和保存设置用户ID，而保存设置用户ID又是来自于有效用户ID的复制，而有效用户ID只能是实际用户ID或者文件所有者ID（在你设置了保存设置用户ID情况下才可以）。\n这样你就没法将有效用户ID设置成随意值，所以对普通用户创建的任何文件如果没有得到超级用户的授权，那么无论他怎么编写代码来设置自己的有效用户ID，或者设置保存用户ID位，由于你这个可执行文件是你自己编写的，所有你的权限更本没有得到实质性的改变。这里也就是说只有root自己创建的文件才具有这样的特权权限。这样是不是很好的保护了操作系统对权限的控制呢？\n保存设置用户ID的作用 那么保存设置用户ID的作用又是什么呢？既然保存用户ID是有效用户ID的副本，那么肯定是为在某个时刻用于恢复我们的有效用户ID。这样就可能实现我们的用户权限的切换。\n例如：man（这是AUP上面的例子，当然实际linux上好像不是这样实现，不过为了便于说明，还是直接使用了这个例子）\nman程序的实际用户ID是man，有效用户ID也是man\n  首先我们的进程要执行man命令，所以exec发现/usr/bin/man已经设置了用户ID位，于是进程的有效用户ID给改了/usr/bin/man的拥有者，即改成man了，并且复制了man给保存设置用户ID，然后我们就可以顺利执行man命令了。\n此时我们进程的ID：\n实际用户ID = 我们的用户ID\n有效用户ID = man（为了执行man命令）\n保存的设置用户ID = man（exec设置的）\nman程序访问需要配置文件和手册页，这些文件时名为man的用户所有的，因为有效用户ID是man,所有我们的操作得以顺利的被执行了。\n  我们的进程要求man执行其他命令（这里不仅我们要执行man命令，我们还会让man代表我们执行一些命令），但是现在我们的有效ID是man，所以需要更改有效ID为我们进程的实际ID，调用setuid（getuid（））函数,由于我不是超级用户，所以，\n实际用户ID = 我们的用户ID\n有效用户ID = 我们的用户ID（setuid改的）\n保存的设置用户ID = man\n现在man进程是以我们的用户ID而运行的，这就意味着能访问的只有我们通常可以访问的，而没有额外的权限，\n  当man完成代替我们执行的命令后，我们当然要回到我们之前有效用户ID，也就是man,此时我们的保存设置用户ID这个副本就开始发挥它的作用了，我们只需要setuid(geteuid());即可，\n通过了这个有效用户ID的副本保存设置用户ID，我们的有效用户ID才能在man-uid-man这样的切换。如果没有保存设置用户ID这个副本，显然，我们是没有办法在man程序代替我们执行完命令之后，在将有效用户ID设置成man的。\n  参考：http://blog.csdn.net/demiaowu/article/details/39370355\n",
  "wordCount" : "2596",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-25T14:23:56Z",
  "dateModified": "2017-06-25T14:23:56Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7id%E4%BD%8D%E4%BF%9D%E5%AD%98%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7id%E6%9C%89%E6%95%88%E7%94%A8%E6%88%B7id%E5%AE%9E%E9%99%85%E7%94%A8%E6%88%B7id/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      设置用户ID位，保存设置用户ID，有效用户ID，实际用户ID
    </h1>
    <div class="post-meta">June 25, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="基本概念">基本概念<a hidden class="anchor" aria-hidden="true" href="#基本概念">#</a></h1>
<h2 id="实际用户idruid">实际用户ID（RUID）<a hidden class="anchor" aria-hidden="true" href="#实际用户idruid">#</a></h2>
<p>用于标识一个系统中用户是谁，一般是在登录之后，就被唯一确定的，就是登陆的用户的uid</p>
<h2 id="有效用户ideuid">有效用户ID（EUID）<a hidden class="anchor" aria-hidden="true" href="#有效用户ideuid">#</a></h2>
<p>用于系统决定用户对系统资源的权限。也就是说当用户做任何一个操作时，最终看它有没有权限，都是在判断有效用户ID是否有权限，如果有，则OK，否则报错不能执行。在正常情况下，一个用户登录之后（我们假设是A用户），A用户的有效用户ID和实际用户ID是相同的，但是如果A用户在某些场景中想要执行一些特权操作，而上面我们说到用户的任何操作，Linux内核都是通过检验有效用户ID来判断当前执行这个操作的用户是否具有权限，显然是特权操作，A用户没有权限，所以A用户就只能通过一定的手段来修改当前的有效用户ID使其具有执行特权操作的权限。这里说明了下面为什么我们需要修改有效用户ID，就是想再某一时刻能够执行一些特权操作。下面在举例说明。</p>
<h2 id="设置用户id位">设置用户ID位<a hidden class="anchor" aria-hidden="true" href="#设置用户id位">#</a></h2>
<p>用于对外的权限的开发，它的作用是我们如何去修改有效用户ID，在后面的例子中在展开。</p>
<h2 id="保存设置用户idsuid">保存设置用户ID（SUID）<a hidden class="anchor" aria-hidden="true" href="#保存设置用户idsuid">#</a></h2>
<p>是有效用户ID副本，既然有效用户ID是副本，那么它的作用肯定是为了以后恢复有效用户ID用的。</p>
<h1 id="改变三个用户id的方法">改变三个用户ID的方法<a hidden class="anchor" aria-hidden="true" href="#改变三个用户id的方法">#</a></h1>
<p>下面这幅图给出了改变实际用户ID，有效用户ID和保存设置用户ID的方法</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20170405151308.png" alt=""  />
</p>
<h1 id="设置用户id位的作用">设置用户ID位的作用<a hidden class="anchor" aria-hidden="true" href="#设置用户id位的作用">#</a></h1>
<p>我们知道用户的密码都是存放在/etc/shadow文件下，我们看下这个文件的权限</p>
<pre><code>root@debian:~# ls -l /etc/shadow

-rw-r----- 1 root shadow 8013 Sep  8 14:58 /etc/shadow  
</code></pre>
<p>假如我是一个普通用户，显然我是可以修改我的密码的，通过passwd命令，无可厚非。自己修改自己的密码肯定是被允许的。</p>
<p>但是仔细想想你会发现不对啊，我作为一个普通用户登录后，我的实际用户ID和有效用户ID都是我自己的UID。从上面可以看出，显然我不具有修改/etc/shadow文件的权限，那我执行passwd命令时怎么改我的密码的呢？</p>
<p>在基本概念中我们知道决定我们权限的是执行操作时的有效用户ID，所有我们在执行passwd命令时，我们的有效用户ID肯定被修改了。OK，我们看下面：</p>
<pre><code>root@debian:~# ls -l /usr/bin/passwd 

-rwsr-xr-x 1 root root 43280 Feb 16  2011 /usr/bin/passwd
</code></pre>
<p>我们看到了一个s，对的，它就是我们的保存设置用户ID位，上面我们说过这个位的作用就是修改有效用户ID，那我们来看看他是如何修改执行passwd命令时的有效用户ID的。</p>
<p>首先我们看下命令执行的过程，当普通用户执行passwd命令时，shell会fork出一个子进程，此时进程有效用户ID还是普通用户ID，然后exec程序执行/usr/bin/passwd。通过上面的表我们会知道，exec发现/usr/bin/passwd有SUID位，于是会把进程的有效用户ID设成设置成文件用户ID，显然就是root, 此时这个进程都获得了root权限, 得到了读写/etc/shadow文件的权限, 从而普通用户可完成密码的修改。exec进程退出后会恢复普通用户的EUID为普通用户ID.这样就不会使普通用户一直拥有root权限。</p>
<p>这就是我们设置用户ID位的作用，它的存在就是为了普通用户在某些需要特权权限时，去临时的改变有效用户ID而获得特权权限。</p>
<p>但是你可能有疑问，为什么我们不用setuid()直接修改呢？何苦绕这么大的弯子。但是如果可以使用setuid()来直接修改有效用户ID来获得特权权限，那么我们的特权权限就会不可控了。这违背了最小权限模型。</p>
<p>所以我们Linux特意将setuid设置成在非特权用户下，有效用户ID只能设置成为实际用户ID和保存设置用户ID，而保存设置用户ID又是来自于有效用户ID的复制，而有效用户ID只能是实际用户ID或者文件所有者ID（在你设置了保存设置用户ID情况下才可以）。</p>
<p>这样你就没法将有效用户ID设置成随意值，所以对普通用户创建的任何文件如果没有得到超级用户的授权，那么无论他怎么编写代码来设置自己的有效用户ID，或者设置保存用户ID位，由于你这个可执行文件是你自己编写的，所有你的权限更本没有得到实质性的改变。这里也就是说只有root自己创建的文件才具有这样的特权权限。这样是不是很好的保护了操作系统对权限的控制呢？</p>
<h1 id="保存设置用户id的作用">保存设置用户ID的作用<a hidden class="anchor" aria-hidden="true" href="#保存设置用户id的作用">#</a></h1>
<p>那么保存设置用户ID的作用又是什么呢？既然保存用户ID是有效用户ID的副本，那么肯定是为在某个时刻用于恢复我们的有效用户ID。这样就可能实现我们的用户权限的切换。</p>
<p>例如：man（这是AUP上面的例子，当然实际linux上好像不是这样实现，不过为了便于说明，还是直接使用了这个例子）</p>
<p>man程序的实际用户ID是man，有效用户ID也是man</p>
<ol>
<li>
<p>首先我们的进程要执行man命令，所以exec发现/usr/bin/man已经设置了用户ID位，于是进程的有效用户ID给改了/usr/bin/man的拥有者，即改成man了，并且复制了man给保存设置用户ID，然后我们就可以顺利执行man命令了。</p>
<p>此时我们进程的ID：</p>
<p>实际用户ID = 我们的用户ID</p>
<p>有效用户ID = man（为了执行man命令）</p>
<p>保存的设置用户ID = man（exec设置的）</p>
<p>man程序访问需要配置文件和手册页，这些文件时名为man的用户所有的，因为有效用户ID是man,所有我们的操作得以顺利的被执行了。</p>
</li>
<li>
<p>我们的进程要求man执行其他命令（这里不仅我们要执行man命令，我们还会让man代表我们执行一些命令），但是现在我们的有效ID是man，所以需要更改有效ID为我们进程的实际ID，调用setuid（getuid（））函数,由于我不是超级用户，所以，</p>
<p>实际用户ID = 我们的用户ID</p>
<p>有效用户ID = 我们的用户ID（setuid改的）</p>
<p>保存的设置用户ID = man</p>
<p>现在man进程是以我们的用户ID而运行的，这就意味着能访问的只有我们通常可以访问的，而没有额外的权限，</p>
</li>
<li>
<p>当man完成代替我们执行的命令后，我们当然要回到我们之前有效用户ID，也就是man,此时我们的保存设置用户ID这个副本就开始发挥它的作用了，我们只需要setuid(geteuid());即可，</p>
<p>通过了这个有效用户ID的副本保存设置用户ID，我们的有效用户ID才能在man-&gt;uid-&gt;man这样的切换。如果没有保存设置用户ID这个副本，显然，我们是没有办法在man程序代替我们执行完命令之后，在将有效用户ID设置成man的。</p>
</li>
</ol>
<p>参考：<a href="">http://blog.csdn.net/demiaowu/article/details/39370355</a></p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
