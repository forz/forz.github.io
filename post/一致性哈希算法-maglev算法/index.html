<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>一致性哈希算法-Maglev算法 | Forz Blog</title>
<meta name="keywords" content="一致性哈希" />
<meta name="description" content="Maglev一致性哈希算法 Maglev哈希算法来自 Google ， 在其2016年发布的一篇论文中[1]， 介绍了自2008年起服役的网络负载均衡器Magl">
<meta name="author" content="">
<link rel="canonical" href="/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95-maglev%E7%AE%97%E6%B3%95/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="一致性哈希算法-Maglev算法" />
<meta property="og:description" content="Maglev一致性哈希算法 Maglev哈希算法来自 Google ， 在其2016年发布的一篇论文中[1]， 介绍了自2008年起服役的网络负载均衡器Magl" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95-maglev%E7%AE%97%E6%B3%95/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-10-09T21:03:19&#43;00:00" />
<meta property="article:modified_time" content="2019-10-09T21:03:19&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="一致性哈希算法-Maglev算法"/>
<meta name="twitter:description" content="Maglev一致性哈希算法 Maglev哈希算法来自 Google ， 在其2016年发布的一篇论文中[1]， 介绍了自2008年起服役的网络负载均衡器Magl"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "一致性哈希算法-Maglev算法",
      "item": "/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95-maglev%E7%AE%97%E6%B3%95/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "一致性哈希算法-Maglev算法",
  "name": "一致性哈希算法-Maglev算法",
  "description": "Maglev一致性哈希算法 Maglev哈希算法来自 Google ， 在其2016年发布的一篇论文中[1]， 介绍了自2008年起服役的网络负载均衡器Magl",
  "keywords": [
    "一致性哈希"
  ],
  "articleBody": "Maglev一致性哈希算法 Maglev哈希算法来自 Google ， 在其2016年发布的一篇论文中[1]， 介绍了自2008年起服役的网络负载均衡器Maglev， 文中包括Maglev负载均衡器中所使用的一致性哈希算法，即Maglev一致性哈希 (Maglev Consistent Hashing)。\n我们要设计一个一致性哈希算法，要求映射均匀，并尽力把槽位变化时的映射变化降到最小（避免全局重新映射）。\nMaglev一致性哈希的思路是查表： 建立一个槽位的查找表(lookup table)， 对输入 k 做哈希再取余，即可映射到表中一个槽位。 下面的图1.1是一个示意图， 其中 entry 是查找表，里面记录了一个槽位序列， 查找表的长度为 M， 当输入一个 k 时，映射到目标槽位的过程就是 entry[hash(k)%M]。\n如何查表很好理解。 接下来看，如何生成一张查找表。 先新建一张大小为 M 的待填充的空表 entry。 为每个槽位生成一个大小为 M 的序列 permutation， 叫做「偏好序列」吧。 然后， 按照偏好序列中数字的顺序，每个槽位轮流填充查找表。 将偏好序列中的数字当做查找表中的目标位置，把槽位标号填充到目标位置。 如果填充的目标位置已经被占用，则顺延该序列的下一个填。 这么简短地讲不大容易明白， 看一个例子就可以清楚了。 下面图1.2是演示填充查找表的原图：\n我做了一张更容易理解的图来理解填表过程。 下面的图1.3中，左边的每一个纵列代表槽位的偏好序列， 右边是我们要填充的查找表。 我们看下整个的填充过程：\n B0 的偏好序列的第一个数字是 3， 所以填充 B0 到 entry[3]。 轮到 B1 填充了， B1 的偏好序列第一个是 0， 所以填充 B1 到 entry[0]。 轮到 B2 填充了，由于 entry[3]被占用， 所以向下看 B2 偏好序列的下一个数字，是 4， 因此填充 B2 到 entry[4]。 接下来， 又轮到 B0 填充了， 该看它的偏好序列的第2个数字了，是 0，但是 entry[0] 被占用了； 所以要继续看偏好序列的第3个数字，是 4， 同理， 这个也不能用，直到测试到 1 可以用， 则填充 B0 到 entry[1]。 如上面的玩法， 直到把整张查找表填充满。  还有一个问题没有解决：偏好序列是怎么生成的？取两个无关的哈希函数 $h_1$ 和 $h_2$， 假设一个槽位的名字是 $b$，先用这两个哈希函数算出一个 $offset$ 和 $skip$\n$$ offset = h_1(b) % M \\\nskip = h_2(b) % (M - 1) + 1 $$\n然后， 对每个 $j$，计算出 $permutation$ 中的所有数字，即为槽位 $b$ 生成了一个偏好序列：\n$$ permutation\\left[j\\right] = (offset + j \\times skip) % M $$\n可以看到，这是一种类似二次哈希的方法，使用了两个独立无关的哈希函数来减少映射结果的碰撞次数，提高随机性。生成偏好序列的方法可以有很多种（比如直接采用一个随机序列等），不必须是 Google 的这个方法，\n但是无论何种方式，目的都是一样的， 生成的偏好序列要随机、要均匀。\n此外，查找表的长度 $M$ 必须是一个质数,和哈希表的槽位数量最好是质数是一个道理，这样可以减少哈希值的聚集和碰撞，让分布更均匀。\n以上就是Maglev一致性哈希的算法的内容， 简单来说：\n 为每个槽位生成一个偏好序列， 尽量均匀随机。 建表：每个槽位轮流用自己的偏好序列填充查找表。 查表：哈希后取余数的方法做映射。  Maglev哈希算法的边缘情况 不过这个算法还存在一个边缘情况：假如所有的偏好序列都不包含某个数字呢？\n下面的图1.4中，所有偏好序列都不包含 $2$，导致最终的查找表的 $entry\\left[2\\right]$ 是空的。\n这种情况出现的概率非常低，但是并不是没有可能。论文中未对这种情况做出说明，不过还是可以想到解决办法的（当然，方法不止一种）：如果填充后的查找表有位置没有被填充，可以统计下哪个槽位的占比最小，把那个槽位填到这里。\n上面的图1.4中，不巧的是三个槽位都占了2个位置，那么直接随意给标号最小的 $B_0$ 好啦。\nMaglev哈希的槽位增删分析 我们接下来看下这个算法是否满足一致性哈希算法的定义标准:映射均匀和一致性。由于偏好序列中的数字分布是均匀的，查找表是所有偏好序列轮流填充的，容易知道，查找表也是分布均匀的,这样，映射也是均匀的。所以，下面着重分析下槽位增删对映射的干扰， 即分析槽位增删对查找表的填充的影响。\n假如，槽位增删导致查找表的某个位置填充的槽位标号发生变化，我们称这是一种干扰.槽位增删必然导致填充干扰，我们的目的是追求这个干扰的最小化。\n下面的图2.1中演示了删除槽位 $B_1$ 前后的填表情况。红色圆圈内标出了受干扰的填表结果， 可以看到，查找表7个位置中有3个被重新填充。其中两个位置(第 $0$，$2$行)是因为 $B_1$ 的移除导致被其他槽位接管，还有一个第 $6$ 行的 $B_0 \\rightarrow B_2$ 的联动干扰（因为 $B_0$ 接管了 $B_1$ 的 $entry\\left[2\\right]$ 导致原本自己的 $entry\\left[6\\right]$ 被 $B_2$ 抢占）。\n下面的图2.2中演示了新增槽位 $B_3$ 前后的填表情况。同样，红色圆圈内标记了受干扰的填表结果， 可以看到，7个位置中有3个被重新填充。其中两个位置(第 $1$，$5$行)是因为 $B_3$ 的加入抢占了其他槽位的填充机会，另一个第 $6$ 行的 $B_0 \\rightarrow B_2$ 则是一种联动干扰。\n在上面图2.2的基础上，我们继续删除一个槽位 $B_0$， 看下前后的变化。 从下面的图2.3可以看出，这一次的填表干扰更严重了， 7个里面出现了4个被重新填充其中两个（第 $3$，$4$ 行）是因为 $B_0$ 的移除导致位置被其他槽位接管，还有两个（第 $1$，$6$ 行， $B_3 \\rightarrow B_1$ 和 $B_2 \\rightarrow B_3$）都是属于联动干扰。\n查找表的重填意味着查表时的重新映射。从上面的三个例子可以看出，Maglev一致性哈希虽然没有导致全量重新映射，但却没有做到最小化重新映射.不过，在 Google 的实际测试中总结出来，当查找表的长度越大时，Maglev哈希的一致性会越好.\nMaglev哈希的复杂度分析 显然，查表的时间复杂度是 $O(1)$ 。\n下面分析下建表的复杂度。\n论文中给出了填表过程的伪代码实现。其中，$N$ 是槽位的总数目，$permutation[i]$ 是槽位 $i$ 的偏好序列。$next[i]$ 用来记录槽位 $i$ 的偏好序列将迭代的下一个位置（即这个序列该跑第几个了）。对于每一个槽位 $i$ , 我们从它的偏好序列中找出一个候选的、还没占用的位置数字 $c$ ,然后把槽位标号 $i$ 填入查找表 $entry$ 中。\n先看下，最坏的时间复杂度是怎样的？那肯定是，在查找下一个合适的填充位置的时候，把所有已经被抢占的位置数字放在这个目标位置的前面，这样的尝试次数最多！ 这种情况发生在 $N = M$ 且 所有偏好序列完全一样的情况下。 下面的图3.2中描述了这种复杂度最高的情况， 有3个槽位、查找表的长度为3、而且所有偏好序列都一样，总共需要尝试 $4+3+2+1$ 个数字（也就是 ${((4+1)\\times 4)} / {2}$），所以最坏复杂度是 $O(((M+1)\\times M)/2)$， 即平方级别的 $O(M^2)$。\n现在考虑下平均的时间复杂度，我们就要分析这个过程总共需要尝试多少个数字。一步一步来想：\n 第一次填表的时候，由于查找表 $entry$ 还是空的，所以第一个数字一定合适， 只需要尝试 $1$ 次。 第二次填表的时候，由于前面已经填了一个槽位到 $entry$ 中， 所以空余的空位还有 $M-1$ 个，所以每个空位被选中的概率是 $1/(M-1)$。 每次查找一个可以填充位置的过程，都是在一个偏好序列中尝试，而序列的长度是 $M$ ， 所以需要尝试 $M/(M-1)$ 次。 依次类推， 当我们已经填充了查找表 $entry$ 的 $n$ 个位置的时候，我们下一步就需要尝试 $M/(M-n)$ 次来找到下一个可以填充的空位置。  计算下来，总共需要尝试的次数是： $M/M + M/(M-1) + … + M / (M - (M-1))$， 即 $\\sum { n=1 }^{ M }{ \\frac { M }{ n } }$，是 $1$ 到 $1/M$ 的倒数之和 与 $M$ 的乘积。调和级数和自然对数的差是收敛到一个小数的.所以，平均的时间复杂度是对数级别的 $O(Mln(M))$， 也就是 $O(Mlog(M))$ (注意到 $O(ln(n)) = O(\\frac { log{2}{n} } { log_{2}{e} })$)。\n一般选择 $M \\gg N$ ($M$ 远大于 $N$) ，这样各个槽位的偏好序列更随机、均匀，也不容易发生不同槽位的偏好序列一样的情况。当然，也不是越大越好， 越大的 $M$ 意味着更高的内存消耗、更慢的建表时长。应该选择一个远大于 $N$ 的质数当做查找表的大小 $M$。\n论文中提到，在 Google 的实践过程中，一般选择 $M$ 为一个大于 $100 \\times N$ 的质数，这样各个槽位在查找表上的分布的差异就不会超过 $1%$。\nMaglev哈希的测试表现 论文中对Maglev一致性哈希的测试关注在两个指标：映射的平均性和对槽位变化的适应能力。\n下面图4.1对比了 Maglev哈希、 经典的哈希环算法和endezvous哈希环算法在不同槽位数量的情况下（对应的查找表大小分别是 $65537$ 和 $655373$ ），映射结果中占比最大和最小的槽位的占比。从图中可以看到，两种槽位数量的情况下，Maglev的映射结果中占比最大和占比最小的占比量都非常接近，也就是说，Maglev一致性哈希的映射平均性非常好。\n关于槽位增删对映射一致性的干扰影响，由于哈希环算法实现了最小的重新映射所以当删除槽位时（比如节点故障时）哈希环算法可以保证剩余的槽位的映射不受影响。而我们前面有分析，对于Maglev算法来讲, 则并没有做到最小的重新映射。下面的图4.2中是 Google 对Maglev负载均衡器做的测试结果，演示了在相同数量的后端节点、但是不同大小的查找表的情况下(分别是 $65537$ 和 $655373$)，映射结果发生变化的节点的占比相对于节点故障占比的关系。可以看到，查找表越大，Maglev哈希对槽位增删的容忍能力更强，映射干扰也越小。\n不过，即使这样，实际中 Google 仍然选择 $65537$ 作为查找表大小。论文中给出的说法是， 当他们把查找表大小从 $65537$ 调大到 $655373$ 时，查找表的生成时间从 $1.8ms$ 升高到了 $22.9ms$， 所以查找表的大小不是越大越好。\n论文中同时提到：在 Google 的场景下， 并没有把后端槽位的变化带来的干扰看的太重要。实际上，工程中节点损失是低概率事件， 并且 Google 的设计中主要的保护手段是连接跟踪，而不是完全依赖一致性哈希。这样，也可以理解了，这个一致性哈希算法的设计上就没有做到最小化干扰的要求。\nMaglev哈希的热扩容和容灾 对于Maglev哈希来讲，热扩容或许还可以做，容灾却无法依赖备份的方式进行。\n回到kvdb的例子上来， 看一下我们的诉求：\n 扩容： 新加一个节点， 如何做到不停服？ 容灾： 损失一个节点，如何做到影响最小？  先看第一个问题： 如何做热扩容。\n新加一个全新的节点时， 必然要迁移数据才可以服务。还是采用类似的办法，即请求中继：\n新加入的节点对于读取不到的数据，可以把请求中继(relay)到老节点，并把这个数据迁移过来。\n老节点是什么呢？ 就是加入新节点之前，数据应该映射到的那个节点。举例子来说，观察前面的图2.2中，假设数据 $k$ 先前映射到的节点是 $B_0$， 后来因为新加入了节点 $B_3$，导致 $k$ 现在映射到 $B_3$， 那么 $B_0$ 就叫做 $k$ 的老节点。\n要知道数据的老节点是什么，就要保存一份加入新节点之前的查找表。也就是节点要保存两份查找表。如果经最新的查找表映射到的节点上没有数据，再去经老查找表映射到老节点上去查。\n然而第二个问题： 如何做容灾， 则没那么容易。\n回顾下前面章节中的图2.2和图2.3。\n图2.3演示了删除一个节点的情况，为了演示方便，这里直接把图2.3照搬下来：\n图2.2中演示了新增节点前后的填表情况，如果我们从右往左看，它也可以演示删除节点的情况，就是下面图5.1的样子：\n可以观察到两个图中都是从完全一样的状况、完全一样的表格，分别删除不同节点的情况。图2.3中，删除 $B_0$ 后，导致了一个 $B_3 \\rightarrow B_1$ 的映射变化。所以， 我们需要把 $B_3$ 的数据备份到 $B_1$ 上，才可以应对这一变化，而不丢数据、不停服。图5.1中，删除 $B_3$ 后则导致了 $B_3 \\rightarrow B_0$ 和 $B_3 \\rightarrow B_2$的映射变化，意思是， 在损失节点 $B_3$ 之后，$B_3$ 中的数据一部分会映射到 $B_0$ 上， 一部分又会映射到 $B_2$ 上，我们除非把 $B_3$ 的数据全部备份一份到 $B_0$, $B_1$, $B_2$ 上，否则没有很好的办法做 $B_3$ 的数据备份。\n这样，关于容灾这个话题，\n我的结论是没有很好的办法做数据备份，所以无法做不停服的容灾处理。 (需要注意：这部分并不是论文中的内容，而是我个人的分析结论。)\n论文中所讨论的Maglev哈希算法的应用场景是负载均衡，确切的说是弱状态化的后端的负载均衡。如果后端节点的数据是类似数据库性质的强状态化数据，那么就会有容灾设计的问题。如果后端节点是无状态的、或者是弱状态的（如缓存），Maglev哈希算法的一致性的特点还是有好处的：比如降低故障情况下的缓存击穿的比例、连接重新建立的比例等等。\n带权重的Maglev哈希 Maglev哈希做到了尽量平均的映射分布，但是，如果槽位之间不是平权的呢？关于带权重的Maglev哈希，论文中只提了一句话：可以通过改变槽位间填表的相对频率来做加权。\n就是不「轮流」填了，可以你填1次，我填3次。 填表越频繁的槽位，权重就越大。\n最后我们再玩一次填表游戏。下面的图6.1中，假设 $B_0$ 的权重是 $2$， 其他的槽位的权重都是 $1$，也就是其他槽位每填表一次， $B_0$ 填表两次。可以观察到，填表的结果上， $B_0$ 的席位占比 $4/7$， 符合权重的设定。\n小结 Maglev哈希是 Google 在自家的负载均衡器Maglev中使用的一致性哈希算法。槽位变化时，虽然避免了全局重新映射，但是没有做到最小化的重新映射。映射的均匀性非常好。映射的时间复杂度是 $O(1)$， 建立查找表的时间复杂度是 $O(Mlog(M))$。可以通过改变填表的相对频率来实现加权。难以实现后端节点的数据备份逻辑，因此工程上更适合弱状态后端的场景。\n转载:https://writings.sh/post/consistent-hashing-algorithms-part-4-maglev-consistent-hash\n",
  "wordCount" : "5331",
  "inLanguage": "zh-cn",
  "datePublished": "2019-10-09T21:03:19Z",
  "dateModified": "2019-10-09T21:03:19Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95-maglev%E7%AE%97%E6%B3%95/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      一致性哈希算法-Maglev算法
    </h1>
    <div class="post-meta">October 9, 2019
</div>
  </header> 
  <div class="post-content"><h1 id="maglev一致性哈希算法">Maglev一致性哈希算法<a hidden class="anchor" aria-hidden="true" href="#maglev一致性哈希算法">#</a></h1>
<p>Maglev哈希算法来自 Google ， 在其2016年发布的一篇论文中[1]， 介绍了自2008年起服役的网络负载均衡器Maglev， 文中包括Maglev负载均衡器中所使用的一致性哈希算法，即Maglev一致性哈希 (Maglev Consistent Hashing)。</p>
<p>我们要设计一个一致性哈希算法，要求映射均匀，并尽力把槽位变化时的映射变化降到最小（避免全局重新映射）。</p>
<p>Maglev一致性哈希的思路是查表： 建立一个槽位的查找表(lookup table)， 对输入 k 做哈希再取余，即可映射到表中一个槽位。 下面的图1.1是一个示意图， 其中 entry 是查找表，里面记录了一个槽位序列， 查找表的长度为 M， 当输入一个 k 时，映射到目标槽位的过程就是 entry[hash(k)%M]。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191010152406.jpg" alt=""  />
</p>
<p>如何查表很好理解。 接下来看，如何生成一张查找表。 先新建一张大小为 M 的待填充的空表 entry。 为每个槽位生成一个大小为 M 的序列 permutation， 叫做「偏好序列」吧。 然后， 按照偏好序列中数字的顺序，每个槽位轮流填充查找表。 将偏好序列中的数字当做查找表中的目标位置，把槽位标号填充到目标位置。 如果填充的目标位置已经被占用，则顺延该序列的下一个填。 这么简短地讲不大容易明白， 看一个例子就可以清楚了。 下面图1.2是演示填充查找表的原图：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191010152832.png" alt=""  />
</p>
<p>我做了一张更容易理解的图来理解填表过程。 下面的图1.3中，左边的每一个纵列代表槽位的偏好序列， 右边是我们要填充的查找表。 我们看下整个的填充过程：</p>
<ol>
<li>B0 的偏好序列的第一个数字是 3， 所以填充 B0 到 entry[3]。</li>
<li>轮到 B1 填充了， B1 的偏好序列第一个是 0， 所以填充 B1 到 entry[0]。</li>
<li>轮到 B2 填充了，由于 entry[3]被占用， 所以向下看 B2 偏好序列的下一个数字，是 4， 因此填充 B2 到 entry[4]。</li>
<li>接下来， 又轮到 B0 填充了， 该看它的偏好序列的第2个数字了，是 0，但是 entry[0] 被占用了； 所以要继续看偏好序列的第3个数字，是 4， 同理， 这个也不能用，直到测试到 1 可以用， 则填充 B0 到 entry[1]。</li>
<li>如上面的玩法， 直到把整张查找表填充满。</li>
</ol>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191010153329.jpg" alt=""  />
</p>
<p>还有一个问题没有解决：偏好序列是怎么生成的？取两个无关的哈希函数 $h_1$ 和 $h_2$， 假设一个槽位的名字是 $b$，先用这两个哈希函数算出一个 $offset$ 和 $skip$</p>
<p>$$
offset = h_1(b) % M
\<br>
skip = h_2(b) % (M - 1) + 1
$$</p>
<p>然后， 对每个 $j$，计算出  $permutation$ 中的所有数字，即为槽位 $b$ 生成了一个偏好序列：</p>
<p>$$
permutation\left[j\right] = (offset + j \times skip) % M
$$</p>
<p>可以看到，这是一种类似二次哈希的方法，使用了两个独立无关的哈希函数来减少映射结果的碰撞次数，提高随机性。生成偏好序列的方法可以有很多种（比如直接采用一个随机序列等），不必须是 Google 的这个方法，</p>
<p>但是无论何种方式，目的都是一样的， <strong>生成的偏好序列要随机、要均匀</strong>。</p>
<p>此外，查找表的长度 $M$ 必须是一个质数,和哈希表的槽位数量最好是质数是一个道理，这样可以减少哈希值的聚集和碰撞，让分布更均匀。</p>
<p>以上就是Maglev一致性哈希的算法的内容， 简单来说：</p>
<ol>
<li>为每个槽位生成一个偏好序列， 尽量均匀随机。</li>
<li>建表：每个槽位轮流用自己的偏好序列填充查找表。</li>
<li>查表：哈希后取余数的方法做映射。</li>
</ol>
<h3 id="maglev哈希算法的边缘情况">Maglev哈希算法的边缘情况<a hidden class="anchor" aria-hidden="true" href="#maglev哈希算法的边缘情况">#</a></h3>
<p>不过这个算法还存在一个边缘情况：假如所有的偏好序列都不包含某个数字呢？</p>
<p>下面的图1.4中，所有偏好序列都不包含 $2$，导致最终的查找表的 $entry\left[2\right]$ 是空的。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191010154720.jpg" alt=""  />
</p>
<p>这种情况出现的概率非常低，但是并不是没有可能。论文中未对这种情况做出说明，不过还是可以想到解决办法的（当然，方法不止一种）：如果填充后的查找表有位置没有被填充，可以统计下哪个槽位的占比最小，把那个槽位填到这里。</p>
<p>上面的图1.4中，不巧的是三个槽位都占了2个位置，那么直接随意给标号最小的 $B_0$ 好啦。</p>
<h3 id="maglev哈希的槽位增删分析">Maglev哈希的槽位增删分析<a hidden class="anchor" aria-hidden="true" href="#maglev哈希的槽位增删分析">#</a></h3>
<p>我们接下来看下这个算法是否满足一致性哈希算法的定义标准:映射均匀和一致性。由于偏好序列中的数字分布是均匀的，查找表是所有偏好序列轮流填充的，容易知道，查找表也是分布均匀的,这样，映射也是均匀的。所以，下面着重分析下槽位增删对映射的干扰， 即分析槽位增删对查找表的填充的影响。</p>
<p>假如，槽位增删导致查找表的某个位置填充的槽位标号发生变化，我们称这是一种干扰.槽位增删必然导致填充干扰，我们的目的是追求这个干扰的最小化。</p>
<p>下面的图2.1中演示了删除槽位 $B_1$ 前后的填表情况。红色圆圈内标出了受干扰的填表结果， 可以看到，查找表7个位置中有3个被重新填充。其中两个位置(第 $0$，$2$行)是因为 $B_1$ 的移除导致被其他槽位接管，还有一个第 $6$ 行的 $B_0 \rightarrow B_2$ 的联动干扰（因为 $B_0$ 接管了 $B_1$ 的 $entry\left[2\right]$ 导致原本自己的 $entry\left[6\right]$ 被 $B_2$ 抢占）。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191010155515.jpg" alt=""  />
</p>
<p>下面的图2.2中演示了新增槽位 $B_3$ 前后的填表情况。同样，红色圆圈内标记了受干扰的填表结果， 可以看到，7个位置中有3个被重新填充。其中两个位置(第 $1$，$5$行)是因为 $B_3$ 的加入抢占了其他槽位的填充机会，另一个第 $6$ 行的 $B_0 \rightarrow B_2$ 则是一种联动干扰。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191010155741.jpg" alt=""  />
</p>
<p>在上面图2.2的基础上，我们继续删除一个槽位 $B_0$， 看下前后的变化。 从下面的图2.3可以看出，这一次的填表干扰更严重了， 7个里面出现了4个被重新填充其中两个（第 $3$，$4$ 行）是因为 $B_0$ 的移除导致位置被其他槽位接管，还有两个（第 $1$，$6$ 行， $B_3 \rightarrow B_1$ 和 $B_2 \rightarrow B_3$）都是属于联动干扰。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191010155818.jpg" alt=""  />
</p>
<p>查找表的重填意味着查表时的重新映射。从上面的三个例子可以看出，Maglev一致性哈希虽然没有导致全量重新映射，但却没有做到最小化重新映射.不过，在 Google 的实际测试中总结出来，当查找表的长度越大时，Maglev哈希的一致性会越好.</p>
<h3 id="maglev哈希的复杂度分析">Maglev哈希的复杂度分析<a hidden class="anchor" aria-hidden="true" href="#maglev哈希的复杂度分析">#</a></h3>
<p>显然，查表的时间复杂度是 $O(1)$ 。</p>
<p>下面分析下建表的复杂度。</p>
<p>论文中给出了填表过程的伪代码实现。其中，$N$ 是槽位的总数目，$permutation[i]$ 是槽位 $i$ 的偏好序列。$next[i]$ 用来记录槽位 $i$ 的偏好序列将迭代的下一个位置（即这个序列该跑第几个了）。对于每一个槽位 $i$ , 我们从它的偏好序列中找出一个候选的、还没占用的位置数字 $c$ ,然后把槽位标号 $i$ 填入查找表 $entry$ 中。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191010160403.jpg" alt=""  />
</p>
<p>先看下，最坏的时间复杂度是怎样的？那肯定是，在查找下一个合适的填充位置的时候，把所有已经被抢占的位置数字放在这个目标位置的前面，这样的尝试次数最多！ 这种情况发生在 $N = M$ 且 所有偏好序列完全一样的情况下。
下面的图3.2中描述了这种复杂度最高的情况， 有3个槽位、查找表的长度为3、而且所有偏好序列都一样，总共需要尝试 $4+3+2+1$ 个数字（也就是 ${((4+1)\times 4)} / {2}$），所以最坏复杂度是 $O(((M+1)\times M)/2)$， 即平方级别的 $O(M^2)$。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191010161142.jpg" alt=""  />
</p>
<p>现在考虑下平均的时间复杂度，我们就要分析这个过程总共需要尝试多少个数字。一步一步来想：</p>
<ul>
<li>第一次填表的时候，由于查找表 $entry$ 还是空的，所以第一个数字一定合适， 只需要尝试 $1$ 次。</li>
<li>第二次填表的时候，由于前面已经填了一个槽位到 $entry$ 中， 所以空余的空位还有 $M-1$ 个，所以每个空位被选中的概率是 $1/(M-1)$。 每次查找一个可以填充位置的过程，都是在一个偏好序列中尝试，而序列的长度是 $M$ ， 所以需要尝试 $M/(M-1)$ 次。</li>
<li>依次类推， 当我们已经填充了查找表 $entry$ 的 $n$ 个位置的时候，我们下一步就需要尝试 $M/(M-n)$ 次来找到下一个可以填充的空位置。</li>
</ul>
<p>计算下来，总共需要尝试的次数是： $M/M + M/(M-1) + &hellip; + M / (M - (M-1))$， 即 $\sum <em>{ n=1 }^{ M }{ \frac { M }{ n }  }$，是 $1$ 到 $1/M$ 的倒数之和 与 $M$ 的乘积。调和级数和自然对数的差是收敛到一个小数的.所以，平均的时间复杂度是对数级别的 $O(Mln(M))$， 也就是 $O(Mlog(M))$ (注意到 $O(ln(n)) = O(\frac { log</em>{2}{n} } { log_{2}{e} })$)。</p>
<p>一般选择 $M \gg N$ ($M$ 远大于 $N$) ，这样各个槽位的偏好序列更随机、均匀，也不容易发生不同槽位的偏好序列一样的情况。当然，也不是越大越好， 越大的 $M$ 意味着更高的内存消耗、更慢的建表时长。应该选择一个远大于 $N$ 的质数当做查找表的大小 $M$。</p>
<p>论文中提到，在 Google 的实践过程中，一般选择 $M$ 为一个大于 $100 \times N$ 的质数，这样各个槽位在查找表上的分布的差异就不会超过 $1%$。</p>
<h3 id="maglev哈希的测试表现">Maglev哈希的测试表现<a hidden class="anchor" aria-hidden="true" href="#maglev哈希的测试表现">#</a></h3>
<p>论文中对Maglev一致性哈希的测试关注在两个指标：映射的平均性和对槽位变化的适应能力。</p>
<p>下面图4.1对比了 <strong>M</strong>aglev哈希、 经典的哈希环算法和endezvous哈希环算法在不同槽位数量的情况下（对应的查找表大小分别是 $65537$ 和 $655373$ ），映射结果中占比最大和最小的槽位的占比。从图中可以看到，两种槽位数量的情况下，Maglev的映射结果中占比最大和占比最小的占比量都非常接近，也就是说，Maglev一致性哈希的映射平均性非常好。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191010161833.jpg" alt=""  />
</p>
<p>关于槽位增删对映射一致性的干扰影响，由于哈希环算法实现了最小的重新映射所以当删除槽位时（比如节点故障时）哈希环算法可以保证剩余的槽位的映射不受影响。而我们前面有分析，对于Maglev算法来讲, 则并没有做到最小的重新映射。下面的图4.2中是 Google 对Maglev负载均衡器做的测试结果，演示了在相同数量的后端节点、但是不同大小的查找表的情况下(分别是 $65537$ 和 $655373$)，映射结果发生变化的节点的占比相对于节点故障占比的关系。可以看到，查找表越大，Maglev哈希对槽位增删的容忍能力更强，映射干扰也越小。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191010161948.jpg" alt=""  />
</p>
<p>不过，即使这样，实际中 Google 仍然选择 $65537$ 作为查找表大小。论文中给出的说法是， 当他们把查找表大小从 $65537$ 调大到 $655373$ 时，查找表的生成时间从 $1.8ms$ 升高到了 $22.9ms$， 所以查找表的大小不是越大越好。</p>
<p>论文中同时提到：在 Google 的场景下， 并没有把后端槽位的变化带来的干扰看的太重要。实际上，工程中节点损失是低概率事件， 并且 Google 的设计中主要的保护手段是连接跟踪，而不是完全依赖一致性哈希。这样，也可以理解了，这个一致性哈希算法的设计上就没有做到最小化干扰的要求。</p>
<h3 id="maglev哈希的热扩容和容灾">Maglev哈希的热扩容和容灾<a hidden class="anchor" aria-hidden="true" href="#maglev哈希的热扩容和容灾">#</a></h3>
<p>对于Maglev哈希来讲，热扩容或许还可以做，容灾却无法依赖备份的方式进行。</p>
<p>回到kvdb的例子上来， 看一下我们的诉求：</p>
<ul>
<li><strong>扩容</strong>： 新加一个节点， 如何做到不停服？</li>
<li><strong>容灾</strong>： 损失一个节点，如何做到影响最小？</li>
</ul>
<p>先看第一个问题： 如何做热扩容。</p>
<p>新加一个全新的节点时， 必然要迁移数据才可以服务。还是采用类似的办法，即<strong>请求中继</strong>：</p>
<p>新加入的节点对于读取不到的数据，可以把请求中继(relay)到老节点，并把这个数据迁移过来。</p>
<p>老节点是什么呢？ 就是加入新节点之前，数据应该映射到的那个节点。举例子来说，观察前面的图2.2中，假设数据 $k$ 先前映射到的节点是 $B_0$， 后来因为新加入了节点 $B_3$，导致 $k$ 现在映射到 $B_3$， 那么 $B_0$ 就叫做 $k$ 的老节点。</p>
<p>要知道数据的老节点是什么，就要保存一份加入新节点之前的查找表。也就是节点要保存两份查找表。如果经最新的查找表映射到的节点上没有数据，再去经老查找表映射到老节点上去查。</p>
<p>然而第二个问题： 如何做容灾， 则没那么容易。</p>
<p>回顾下前面章节中的图2.2和图2.3。</p>
<p>图2.3演示了删除一个节点的情况，为了演示方便，这里直接把图2.3照搬下来：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191010155818.jpg" alt=""  />
</p>
<p>图2.2中演示了新增节点前后的填表情况，如果我们从右往左看，它也可以演示删除节点的情况，就是下面图5.1的样子：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191010164115.jpg" alt=""  />
</p>
<p>可以观察到两个图中都是从完全一样的状况、完全一样的表格，分别删除不同节点的情况。图2.3中，删除 $B_0$ 后，导致了一个 $B_3 \rightarrow B_1$ 的映射变化。所以， 我们需要把 $B_3$ 的数据备份到 $B_1$ 上，才可以应对这一变化，而不丢数据、不停服。图5.1中，删除 $B_3$ 后则导致了 $B_3 \rightarrow B_0$ 和 $B_3 \rightarrow B_2$的映射变化，意思是， 在损失节点 $B_3$ 之后，$B_3$ 中的数据一部分会映射到 $B_0$ 上， 一部分又会映射到 $B_2$ 上，我们除非把 $B_3$ 的数据全部备份一份到 $B_0$, $B_1$, $B_2$ 上，否则没有很好的办法做 $B_3$ 的数据备份。</p>
<p>这样，关于容灾这个话题，</p>
<p>我的结论是没有很好的办法做数据备份，所以无法做不停服的容灾处理。
(<em>需要注意：这部分并不是论文中的内容，而是我个人的分析结论。</em>)</p>
<p>论文中所讨论的Maglev哈希算法的应用场景是负载均衡，确切的说是弱状态化的后端的负载均衡。如果后端节点的数据是类似数据库性质的强状态化数据，那么就会有容灾设计的问题。如果后端节点是无状态的、或者是弱状态的（如缓存），Maglev哈希算法的一致性的特点还是有好处的：比如降低故障情况下的缓存击穿的比例、连接重新建立的比例等等。</p>
<h3 id="带权重的maglev哈希">带权重的Maglev哈希<a hidden class="anchor" aria-hidden="true" href="#带权重的maglev哈希">#</a></h3>
<p>Maglev哈希做到了尽量平均的映射分布，但是，如果槽位之间不是平权的呢？关于带权重的Maglev哈希，论文中只提了一句话：可以通过改变槽位间填表的相对频率来做加权。</p>
<p>就是不「轮流」填了，可以你填1次，我填3次。 填表越频繁的槽位，权重就越大。</p>
<p>最后我们再玩一次填表游戏。下面的图6.1中，假设 $B_0$ 的权重是 $2$， 其他的槽位的权重都是 $1$，也就是其他槽位每填表一次， $B_0$ 填表两次。可以观察到，填表的结果上， $B_0$ 的席位占比 $4/7$， 符合权重的设定。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191010164325.jpg" alt=""  />
</p>
<h3 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h3>
<p>Maglev哈希是 Google 在自家的负载均衡器Maglev中使用的一致性哈希算法。槽位变化时，虽然避免了全局重新映射，但是没有做到最小化的重新映射。映射的均匀性非常好。映射的时间复杂度是 $O(1)$， 建立查找表的时间复杂度是 $O(Mlog(M))$。可以通过改变填表的相对频率来实现加权。难以实现后端节点的数据备份逻辑，因此工程上更适合弱状态后端的场景。</p>
<p>转载:<a href="https://writings.sh/post/consistent-hashing-algorithms-part-4-maglev-consistent-hash">https://writings.sh/post/consistent-hashing-algorithms-part-4-maglev-consistent-hash</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/">一致性哈希</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
