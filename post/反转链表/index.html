<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>反转链表 | Forz Blog</title>
<meta name="keywords" content="Linked List" />
<meta name="description" content="LeetCode 24. Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head. For example, Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 解析：直接交换当前结点和其后继节点的">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="反转链表" />
<meta property="og:description" content="LeetCode 24. Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head. For example, Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 解析：直接交换当前结点和其后继节点的" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-25T02:24:14&#43;00:00" />
<meta property="article:modified_time" content="2017-06-25T02:24:14&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="反转链表"/>
<meta name="twitter:description" content="LeetCode 24. Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head. For example, Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 解析：直接交换当前结点和其后继节点的"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "反转链表",
      "item": "/post/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "反转链表",
  "name": "反转链表",
  "description": "LeetCode 24. Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head. For example, Given 1-\u0026gt;2-\u0026gt;3-\u0026gt;4, you should return the list as 2-\u0026gt;1-\u0026gt;4-\u0026gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 解析：直接交换当前结点和其后继节点的",
  "keywords": [
    "Linked List"
  ],
  "articleBody": "LeetCode 24. Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head.\nFor example, Given 1-2-3-4, you should return the list as 2-1-4-3.\nYour algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.\n解析：直接交换当前结点和其后继节点的值即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* p = head; while (p \u0026\u0026 p-next) { swap(p-val, p-next-val); p = p-next-next; } return head; } };   LeetCode 206. Reverse Linked List Reverse a singly linked list.\n解析：\n迭代方法，此题因为是整体翻转，所以只需要翻转每一个关系，最后返回尾结点作为新的头节点。\n用三个指针完成链表翻转，每次翻转一个关系 A-B-X ==B-A-X ，为了防止后面的链表丢失，每次翻转前都要先记录当前结点的后继节点。\n优化解法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution { public: ListNode* reverseList(ListNode* head) { if(head==NULL||head-next==NULL) //健壮性  return head; ListNode * pre=NULL; //前驱节点A(最初一定要是NULL，因为head-next==NULL)  ListNode * cur=head; //当前节点B  ListNode * tmp=NULL; //后继节点  while(cur) //保证A节点存在就可以  { tmp=cur-next; //保存后继节点 X  cur-next=pre; //翻转关系 B-A  pre=cur; //记录前驱节点  cur=tmp; //当前结点变为新节点  } return pre; } };   一般解法：\n常规解法就是将除头节点外每个节点用头插法放到当前头节点后面。\n在原链表之前建立一个dummy伪头节点N，因为首节点也会翻转。这样的话就算头结点变动了，我们还可以通过dummy-next来获得新链表的头结点\nN-$-A-B-Y ==== N-B-$-A-Y (N为伪头节点) 已知A和B和N 按照 N-B-$-A-Y从后往前的顺序依次进行连接（$=N-next）,加粗箭头说明关系无变化，不用维护。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public: ListNode* reverseList(ListNode* head) { if (!head) return head; ListNode *dummy = new ListNode(-1); dummy-next = head; ListNode *pre = head; //A  ListNode *cur = pre-next; //B  while (cur) { pre-next = cur-next; //A-Y  cur-next = dummy-next;//B-$  dummy-next = cur;// N-B  cur= pre-next; //cur节点后移，表示下一个需要进行头插法的节点  } return dummy-next; } };   补充：\n递归的解法可以这么思考，对于一个节点p，假设它后面的剩余链表已经是反转的了，此时该如何处理？\n向递归传入当前头节点的下一个节点当作递归的头节点，然后在当前递归中只处理当前头节点和其下一个节点的关系。当前头节点可以直接看作尾节点。递归返回的p是指翻转后的头节点（也就是原来的尾节点）\n因为递归过程中是从后往前的，所以不会丢失任何一个节点。不需要任何辅助变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { if (head == nullptr || head-next == nullptr) return head;//递归结束边界  ListNode *p = reverseList(head-next); head-next-next = head;//翻转关系（后到前）  head-next = nullptr;//（前置0）  return p; } };   92. Reverse Linked List II Reverse a linked list from position m to n. Do it in-place and in one-pass.\nFor example:\nGiven 1-2-3-4-5-NULL, m = 2 and n = 4, return 1-4-3-2-5-NULL.\nNote: Given m, n satisfy the following condition:\n1 ≤ m ≤ n ≤ length of list.\n解析：\n给出翻转链表的范围。将m到n的所有节点翻转，此题需要用到3个指针，和上题一般解法完全一致。\n移动到起点的前一位，将这位作为新的伪头节点newhead,然后进行n-m次将节点cur插在新的伪头节点后面（尾插法），然后将cur移动到prev的后面，prev一直保持在当前翻转链表的末尾（即第一个需要翻转的节点）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *reverseBetween(ListNode *head, int m, int n) { ListNode dummy(-1); dummy.next = head; ListNode *prev = \u0026dummy; for (int i = 0; i  m-1; ++i)//头节点移到起始位置的前一位  prev = prev-next; ListNode* const newhead = prev;//newhead为第m-1个节点,可以看作伪头节点 X  prev = newhead-next;//翻转链表的头节点A  ListNode *cur = prev-next;//头节点的下一节点B  for (int i = m; i  n; ++i) { prev-next = cur-next; //A-Y  cur-next = newhead-next;//B-$  newhead-next = cur; // N-B  cur = prev-next; //cur节点后移，表示下一个需要进行尾插法的节点  } return dummy.next; } };   143. Reorder List Given a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…\nYou must do this in-place without altering the nodes’ values.\nFor example,\nGiven {1,2,3,4}, reorder it to {1,4,2,3}.\n解析：\n先使用快慢指针将链表从中间分割成两段，然后后半段就地逆置．之后合并插入到前半段链表，时间复杂度O(n)。因为是从中部翻转到结尾，使用优化解法进行翻转即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: void reorderList(ListNode* head) { if(!head || !head-next) return; ListNode *slow = head, *fast = head, *p=head, *q=head; while(fast-next \u0026\u0026 fast-next-next) slow = slow-next, fast = fast-next-next; fast = slow-next,slow-next = NULL; //fast暂时保存slow后面的节点，将链表前后分割  ListNode * pre=fast; ListNode * cur=fast-next; ListNode * tmp=NULL; fast-next = NULL; while(cur) { tmp=cur-next; cur-next=pre; pre=cur; cur=tmp; } while(head \u0026\u0026 pre) //head和pre分别是两个链表的头节点  { auto tem1 = head-next, tem2 = pre-next; //暂时保存后继节点，防止链表丢失。  pre-next = head-next; head-next = pre; head = tem1, pre = tem2; } } };   25. Reverse Nodes in k-Group Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\nYou may not alter the values in the nodes, only nodes itself may be changed.\nOnly constant memory is allowed.\nFor example,\nGiven this linked list: 1-2-3-4-5\nFor k = 2, you should return: 2-1-4-3-5\nFor k = 3, you should return: 3-2-1-4-5\n解析：\n首先创建伪头节点dummy，然后因为翻转k元组，最后不足k的不翻转，所以要提前计算链表长度num。\n将整个链表分割成多个长度为K的区间，分别翻转，翻转结束后维护nhead=pre，也就是当前已翻转链表的尾节点，也就是翻转前的第一个节点 nhead-next，因为pre一直没有改变过指向地址。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *curt; * ListNode(int x) : val(x), curt(NULL) {} * }; */ class Solution { public: ListNode *reverseKGroup(ListNode *head, int k) { if(head==NULL||k==1) return head; ListNode *dummy = new ListNode(-1);//伪头节点  dummy-next = head;//伪头节点链接  int num=1; while(head = head-next) //统计链表长度  num++; ListNode *pre = dummy, *cur, *nhead = dummy; while(num=k) {//不翻转最后剩下的长度小于k的区间  pre = nhead-next; cur = pre-next; for(int i=1;ik;++i) {//执行k次翻转操作  pre-next=cur-next; cur-next=nhead-next; nhead-next=cur; cur=pre-next; } nhead = pre; //更新伪头节点（即上一个翻转子链表的尾节点pre）  num-=k; } return dummy-next; } };   ",
  "wordCount" : "2297",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-25T02:24:14Z",
  "dateModified": "2017-06-25T02:24:14Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      反转链表
    </h1>
    <div class="post-meta">June 25, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="leetcode-24-swap-nodes-in-pairs">LeetCode 24. Swap Nodes in Pairs<a hidden class="anchor" aria-hidden="true" href="#leetcode-24-swap-nodes-in-pairs">#</a></h1>
<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example, <br>
Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>
<p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p>
<p>解析：直接交换当前结点和其后继节点的值即可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for singly-linked list.
</span><span class="cm"> * struct ListNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     ListNode *next;
</span><span class="cm"> *     ListNode(int x) : val(x), next(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">swapPairs</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-206-reverse-linked-list">LeetCode 206. Reverse Linked List<a hidden class="anchor" aria-hidden="true" href="#leetcode-206-reverse-linked-list">#</a></h1>
<p>Reverse a singly linked list.</p>
<p>解析：</p>
<p>迭代方法，此题因为是整体翻转，所以只需要翻转每一个关系，最后返回尾结点作为新的头节点。</p>
<p>用三个指针完成链表翻转，每次翻转一个关系 A-&gt;B-&gt;X ==&gt;B-&gt;A-&gt;X ，为了防止后面的链表丢失，每次翻转前都要先记录当前结点的后继节点。</p>
<p>优化解法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>  
<span class="nl">public</span><span class="p">:</span>  
<span class="n">ListNode</span><span class="o">*</span> <span class="n">reverseList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>  
    <span class="k">if</span><span class="p">(</span><span class="n">head</span><span class="o">==</span><span class="nb">NULL</span><span class="o">||</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>  <span class="c1">//健壮性
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">head</span><span class="p">;</span>  
    <span class="n">ListNode</span> <span class="o">*</span> <span class="n">pre</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>  <span class="c1">//前驱节点A(最初一定要是NULL，因为head-&gt;next==NULL)
</span><span class="c1"></span>    <span class="n">ListNode</span> <span class="o">*</span> <span class="n">cur</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>  <span class="c1">//当前节点B
</span><span class="c1"></span>    <span class="n">ListNode</span> <span class="o">*</span> <span class="n">tmp</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>  <span class="c1">//后继节点
</span><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span>  <span class="c1">//保证A节点存在就可以
</span><span class="c1"></span>    <span class="p">{</span>  
        <span class="n">tmp</span><span class="o">=</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>  <span class="c1">//保存后继节点 X
</span><span class="c1"></span>        <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">pre</span><span class="p">;</span>  <span class="c1">//翻转关系 B-&gt;A
</span><span class="c1"></span>        <span class="n">pre</span><span class="o">=</span><span class="n">cur</span><span class="p">;</span>  <span class="c1">//记录前驱节点  
</span><span class="c1"></span>        <span class="n">cur</span><span class="o">=</span><span class="n">tmp</span><span class="p">;</span>  <span class="c1">//当前结点变为新节点
</span><span class="c1"></span>    <span class="p">}</span>  
    <span class="k">return</span> <span class="n">pre</span><span class="p">;</span>  
<span class="p">}</span>  
<span class="p">};</span> 
</code></pre></td></tr></table>
</div>
</div><p>一般解法：</p>
<p>常规解法就是将除头节点外每个节点用头插法放到当前头节点后面。</p>
<p>在原链表之前建立一个dummy伪头节点N，因为首节点也会翻转。这样的话就算头结点变动了，我们还可以通过dummy-&gt;next来获得新链表的头结点</p>
<p>N-&gt;$-&gt;A-&gt;B-&gt;Y ====&gt; N-&gt;B-&gt;$-&gt;A-&gt;Y (N为伪头节点)
已知A和B和N 按照 N-&gt;B-&gt;$-&gt;A-&gt;Y从后往前的顺序依次进行连接（$=N-&gt;next）,加粗箭头说明关系无变化，不用维护。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">ListNode</span><span class="o">*</span> <span class="n">reverseList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">)</span> <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">pre</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>    <span class="c1">//A
</span><span class="c1"></span>    <span class="n">ListNode</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>    <span class="c1">//B
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>    <span class="c1">//A-&gt;Y
</span><span class="c1"></span>        <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//B-&gt;$
</span><span class="c1"></span>        <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span><span class="c1">// N-&gt;B
</span><span class="c1"></span>        <span class="n">cur</span><span class="o">=</span> <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>    <span class="c1">//cur节点后移，表示下一个需要进行头插法的节点
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>补充：</p>
<p>递归的解法可以这么思考，对于一个节点p，假设它后面的剩余链表已经是反转的了，此时该如何处理？</p>
<p>向递归传入当前头节点的下一个节点当作递归的头节点，然后在当前递归中只处理当前头节点和其下一个节点的关系。当前头节点可以直接看作尾节点。递归返回的p是指翻转后的头节点（也就是原来的尾节点）</p>
<p>因为递归过程中是从后往前的，所以不会丢失任何一个节点。不需要任何辅助变量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for singly-linked list.
</span><span class="cm"> * struct ListNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     ListNode *next;
</span><span class="cm"> *     ListNode(int x) : val(x), next(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">ListNode</span><span class="o">*</span> <span class="n">reverseList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="n">nullptr</span> <span class="o">||</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">head</span><span class="p">;</span><span class="c1">//递归结束边界
</span><span class="c1"></span>    <span class="n">ListNode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">reverseList</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
    <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span><span class="c1">//翻转关系（后到前）
</span><span class="c1"></span>       <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span><span class="c1">//（前置0）
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="92-reverse-linked-list-ii">92. Reverse Linked List II<a hidden class="anchor" aria-hidden="true" href="#92-reverse-linked-list-ii">#</a></h1>
<p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p>
<p>For example:<br>
Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4, <br>
return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.</p>
<p>Note:   <br>
Given m, n satisfy the following condition:<br>
1 ≤ m ≤ n ≤ length of list.</p>
<p>解析：</p>
<p>给出翻转链表的范围。将m到n的所有节点翻转，此题需要用到3个指针，和上题一般解法完全一致。</p>
<p>移动到起点的前一位，将这位作为新的伪头节点newhead,然后进行n-m次将节点cur插在新的伪头节点后面（尾插法），然后将cur移动到prev的后面，prev一直保持在当前翻转链表的末尾（即第一个需要翻转的节点）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for singly-linked list.
</span><span class="cm"> * struct ListNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     ListNode *next;
</span><span class="cm"> *     ListNode(int x) : val(x), next(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">ListNode</span> <span class="o">*</span><span class="n">reverseBetween</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ListNode</span> <span class="n">dummy</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">dummy</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="c1">//头节点移到起始位置的前一位
</span><span class="c1"></span>        <span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="k">const</span> <span class="n">newhead</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span><span class="c1">//newhead为第m-1个节点,可以看作伪头节点 X
</span><span class="c1"></span>    <span class="n">prev</span> <span class="o">=</span> <span class="n">newhead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//翻转链表的头节点A
</span><span class="c1"></span>    <span class="n">ListNode</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//头节点的下一节点B
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>        <span class="c1">//A-&gt;Y
</span><span class="c1"></span>        <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">newhead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//B-&gt;$
</span><span class="c1"></span>        <span class="n">newhead</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>  <span class="c1">// N-&gt;B
</span><span class="c1"></span>        <span class="n">cur</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>    <span class="c1">//cur节点后移，表示下一个需要进行尾插法的节点
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="143-reorder-list">143. Reorder List<a hidden class="anchor" aria-hidden="true" href="#143-reorder-list">#</a></h1>
<p>Given a singly linked list L: L0→L1→…→Ln-1→Ln, <br>
reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You must do this in-place without altering the nodes’ values.</p>
<p>For example,</p>
<p>Given {1,2,3,4}, reorder it to {1,4,2,3}.</p>
<p>解析：</p>
<p>先使用快慢指针将链表从中间分割成两段，然后后半段就地逆置．之后合并插入到前半段链表，时间复杂度O(n)。因为是从中部翻转到结尾，使用优化解法进行翻转即可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/** 
</span><span class="cm"> * Definition for singly-linked list. 
</span><span class="cm"> * struct ListNode { 
</span><span class="cm"> *     int val; 
</span><span class="cm"> *     ListNode *next; 
</span><span class="cm"> *     ListNode(int x) : val(x), next(NULL) {} 
</span><span class="cm"> * }; 
</span><span class="cm"> */</span>  
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>  
<span class="nl">public</span><span class="p">:</span>  
<span class="kt">void</span> <span class="n">reorderList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>  
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">head</span> <span class="o">||</span> <span class="o">!</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>  
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>  
    <span class="k">while</span><span class="p">(</span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>  
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
     <span class="n">fast</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span><span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">//fast暂时保存slow后面的节点，将链表前后分割
</span><span class="c1"></span>    <span class="n">ListNode</span> <span class="o">*</span> <span class="n">pre</span><span class="o">=</span><span class="n">fast</span><span class="p">;</span>  
    <span class="n">ListNode</span> <span class="o">*</span> <span class="n">cur</span><span class="o">=</span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>  
    <span class="n">ListNode</span> <span class="o">*</span> <span class="n">tmp</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>  
    <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  
    <span class="k">while</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="n">tmp</span><span class="o">=</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> 
        <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">pre</span><span class="p">;</span> 
        <span class="n">pre</span><span class="o">=</span><span class="n">cur</span><span class="p">;</span>  
        <span class="n">cur</span><span class="o">=</span><span class="n">tmp</span><span class="p">;</span>  
    <span class="p">}</span>  
    <span class="k">while</span><span class="p">(</span><span class="n">head</span> <span class="o">&amp;&amp;</span> <span class="n">pre</span><span class="p">)</span>  <span class="c1">//head和pre分别是两个链表的头节点
</span><span class="c1"></span>    <span class="p">{</span>   <span class="k">auto</span> <span class="n">tem1</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">tem2</span> <span class="o">=</span> <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="c1">//暂时保存后继节点，防止链表丢失。
</span><span class="c1"></span>        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>  
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">pre</span><span class="p">;</span>  
        <span class="n">head</span> <span class="o">=</span> <span class="n">tem1</span><span class="p">,</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">tem2</span><span class="p">;</span>  
    <span class="p">}</span>  
<span class="p">}</span>  
<span class="p">};</span>  
</code></pre></td></tr></table>
</div>
</div><h1 id="25-reverse-nodes-in-k-group">25. Reverse Nodes in k-Group<a hidden class="anchor" aria-hidden="true" href="#25-reverse-nodes-in-k-group">#</a></h1>
<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>
<p>You may not alter the values in the nodes, only nodes itself may be changed.</p>
<p>Only constant memory is allowed.</p>
<p>For example,</p>
<p>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
<p>解析：</p>
<p>首先创建伪头节点dummy，然后因为翻转k元组，最后不足k的不翻转，所以要提前计算链表长度num。</p>
<p>将整个链表分割成多个长度为K的区间，分别翻转，翻转结束后维护nhead=pre，也就是当前已翻转链表的尾节点，也就是翻转前的第一个节点 nhead-&gt;next，因为pre一直没有改变过指向地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for singly-linked list.
</span><span class="cm"> * struct ListNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     ListNode *curt;
</span><span class="cm"> *     ListNode(int x) : val(x), curt(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">ListNode</span> <span class="o">*</span><span class="n">reverseKGroup</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">head</span><span class="o">==</span><span class="nb">NULL</span><span class="o">||</span><span class="n">k</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="c1">//伪头节点
</span><span class="c1"></span>    <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span><span class="c1">//伪头节点链接
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">num</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="c1">//统计链表长度
</span><span class="c1"></span>        <span class="n">num</span><span class="o">++</span><span class="p">;</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">pre</span> <span class="o">=</span> <span class="n">dummy</span><span class="p">,</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span> <span class="o">*</span><span class="n">nhead</span> <span class="o">=</span> <span class="n">dummy</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">num</span><span class="o">&gt;=</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span><span class="c1">//不翻转最后剩下的长度小于k的区间
</span><span class="c1"></span>        <span class="n">pre</span> <span class="o">=</span> <span class="n">nhead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">k</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="c1">//执行k次翻转操作
</span><span class="c1"></span>            <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">nhead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">nhead</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">cur</span><span class="p">;</span>
            <span class="n">cur</span><span class="o">=</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">nhead</span> <span class="o">=</span> <span class="n">pre</span><span class="p">;</span>    <span class="c1">//更新伪头节点（即上一个翻转子链表的尾节点pre）
</span><span class="c1"></span>        <span class="n">num</span><span class="o">-=</span><span class="n">k</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/linked-list/">Linked List</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
