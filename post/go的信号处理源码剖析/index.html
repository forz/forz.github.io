<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go的信号处理源码剖析 | Forz Blog</title>
<meta name="keywords" content="Go源码" />
<meta name="description" content="前言 我们已经知道了 Go 运行时调度以 Goroutine 的方式调度了所有用户态代码。 每个 Goroutine 都有可能在不同的线程上重新被执行。 那么如果用户态的某个 Goroutine 需要接收系统信号">
<meta name="author" content="">
<link rel="canonical" href="/post/go%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Go的信号处理源码剖析" />
<meta property="og:description" content="前言 我们已经知道了 Go 运行时调度以 Goroutine 的方式调度了所有用户态代码。 每个 Goroutine 都有可能在不同的线程上重新被执行。 那么如果用户态的某个 Goroutine 需要接收系统信号" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-11-26T22:58:57&#43;00:00" />
<meta property="article:modified_time" content="2020-11-26T22:58:57&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go的信号处理源码剖析"/>
<meta name="twitter:description" content="前言 我们已经知道了 Go 运行时调度以 Goroutine 的方式调度了所有用户态代码。 每个 Goroutine 都有可能在不同的线程上重新被执行。 那么如果用户态的某个 Goroutine 需要接收系统信号"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Go的信号处理源码剖析",
      "item": "/post/go%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go的信号处理源码剖析",
  "name": "Go的信号处理源码剖析",
  "description": "前言 我们已经知道了 Go 运行时调度以 Goroutine 的方式调度了所有用户态代码。 每个 Goroutine 都有可能在不同的线程上重新被执行。 那么如果用户态的某个 Goroutine 需要接收系统信号",
  "keywords": [
    "Go源码"
  ],
  "articleBody": "前言 我们已经知道了 Go 运行时调度以 Goroutine 的方式调度了所有用户态代码。 每个 Goroutine 都有可能在不同的线程上重新被执行。 那么如果用户态的某个 Goroutine 需要接收系统信号， 如何才能确保某个线程的信号能够正确的发送到可能在其他线程上执行的监听信号的 Goroutine 呢？\n本节我们讨论调度器里涉及的 signal 信号处理机制。\n信号与软中断 信号机制是 UNIX、类 UNIX 甚至其他 POSIX 兼容系统上规定的一种进程异步通信的限制形式。 用于提醒某个事件的发生状态。 信号被定义为整数，产生信号的条件包括用户使用某些按键组合（比如 Control + C）、 硬件异常、kill 信号等等。\n这些信号通常有三种不同的处理方式：忽略、捕获或者执行系统的默认行为。 忽略与捕获处理无法处理 SIGKILL 和 SIGSTOP，默认处理通常为停止进程。 而对于捕获处理而言，当信号发生时，操作系统将中断用户代码，并保存其执行的上下文，切换到内核空间 并重新切换到用户空间来执行预先设置好的信号处理回调。当回调执行完毕之后，会重新切换回内核 空间，并从中断的位置进行恢复，如图所示。\n系统调用 sigaltstack 可以用于定义一个备用的信号栈来获取一个存在的额外信号栈的状态。 一个额外的信号栈会在信号处理执行中进行使用。\n每个进程都包含一个信号屏蔽字（signal mask），规定了当前要阻塞递送到该进程的信号集。 对于每种可能的信号，屏蔽字中都有一位与之对应。 对于某种信号，若其对应位置已设置，则它当前是被阻塞的。 如果要检测和修改当前信号屏蔽字，则需要调用 sigprocmask 系统调用来进行。通过 _SIG_SETMASK 可以直接设置想要的屏蔽字，并获得原先的屏蔽字。\n每个线程都有自己独立的signal mask，但所有线程共享进程的signal action。这意味着，你可以在线程中调用pthread_sigmask(不是sigmask)来决定本线程阻塞哪些信号。但你不能调用sigaction来指定单个线程的信号处理方式。如果在某个线程中调用了sigaction处理某个信号，那么这个进程中的未阻塞这个信号的线程在收到这个信号都会按同一种方式处理这个信号。所以每个线程不能按自己的方式处理信号。\n在Linux中的posix线程模型中，线程拥有独立的进程号，可以通过getpid()得到线程的进程号，而线程号保存在pthread_t的值中。而主线程的进程号就是整个进程的进程号，因此向主进程发送信号只会将信号发送到主线程中去。如果主线程设置了信号屏蔽，则信号会投递到一个可以处理的线程中去。\n  如果是异常产生的信号（比如程序错误，像SIGPIPE、SIGEGV这些），则只有产生异常的线程收到并处理。\n  如果是用pthread_kill产生的内部信号，则只有pthread_kill参数中指定的目标线程收到并处理。\n  如果是外部使用kill命令产生的信号，通常是SIGINT、SIGHUP等job control信号，则会遍历所有线程，直到找到一个不阻塞该信号的线程，然后调用它来处理。(一般从主线程找起)，注意只有一个线程能收到。   处理函数的初始化 调度循环中讨论过了 M 的生命周期，M 可以在两种情况下被创建：\n  程序运行之初的 M0，无需创建已经存在的系统线程，只需对其进行初始化即可。其函数调用链如下所示：\n1 2 3 4 5 6  schedinit ↳ mcommoninit ↳ mpreinit ↳ msigsave ↳ initSigmask ↳ mstart   ``\n  需要时创建的 M，某些特殊情况下一定会创建一个新的 M 并进行初始化，而后创建系统线程。这些情况包括：\n startm 时没有空闲 m startTemplateThread 时 startTheWorldWithSema 时 p 如果没有 m main 时创建系统监控 oneNewExtraM 时 其调用链为：  1 2 3 4 5 6 7  newm ↳ allocm ↳ mcommoninit ↳ mpreinit ↳ newm1 ↳ newosproc ↳ mstart   ``\n  在 mcommoninit 里，会在一个父线程（或引导时的主线程）上调用 mpreinit，并最终会为一个 M 创建 gsignal，是一个在 M 上用于处理信号的 Goroutine。因此，除了 g0 外，其实第一个创建的 g 应该是它， 但是它并没有设置 Goid (Goroutine ID)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func mcommoninit(mp *m) { ... // 初始化 gsignal，用于处理 m 上的信号。 \tmpreinit(mp) // gsignal 的运行栈边界处理 \tif mp.gsignal != nil { mp.gsignal.stackguard1 = mp.gsignal.stack.lo + _StackGuard } ... } // 从一个父线程上进行调用（引导时为主线程），可以分配内存 func mpreinit(mp *m) { mp.gsignal = malg(32 * 1024) // OS X 需要 = 8K，此处创建处理 singnal 的 g \tmp.gsignal.m = mp // 指定 gsignal 拥有的 m }   获取原始信号屏蔽字 在调度器的初始化的阶段，initSigmask 目标旨在记录主线程 M0 创建之初的屏蔽字 sigmask：\n1 2 3 4 5 6 7 8 9  func schedinit() { _g_ := getg() ... mcommoninit(_g_.m) ... msigsave(_g_.m) initSigmask = _g_.m.sigmask ... }   其中 msigsave 通过 sigprocmask 这个系统调用将当前 m0 的屏蔽字保存到 mp.sigmask 上：\n1 2 3 4 5 6 7 8  const _SIG_SETMASK = 3 // msigsave 将当前线程的信号屏蔽字保存到 mp.sigmask。 //go:nosplit //go:nowritebarrierrec func msigsave(mp *m) { sigprocmask(_SIG_SETMASK, nil, \u0026mp.sigmask) }   sigprocmask 的本质为系统调用，其返回值通过 old 交付给调用者：\n1 2 3 4 5 6 7 8  type sigset uint32 //go:nosplit //go:nowritebarrierrec func sigprocmask(how int32, new, old *sigset) { rtsigprocmask(how, new, old, int32(unsafe.Sizeof(*new))) } //go:noescape func rtsigprocmask(how int32, new, old *sigset, size int32)   rtsigprocmask 在 Linux 上由汇编直接包装 rt_sigprocmask 调用：\n1 2 3 4 5 6 7 8 9 10 11  TEXT runtime·rtsigprocmask(SB),NOSPLIT,$0-28 MOVL\thow+0(FP), DI MOVQ\tnew+8(FP), SI MOVQ\told+16(FP), DX MOVL\tsize+24(FP), R10 MOVL\t$SYS_rt_sigprocmask, AX SYSCALL CMPQ\tAX, $0xfffffffffffff001 JLS\t2(PC) MOVL\t$0xf1, 0xf1 // crash RET   注意，rt_sigprocmask 只适用于单个线程的调用，多线程上的调用时未定义行为， 不过初始化阶段的此时还未创建其他线程，因此此调用时安全的。\n在 Darwin 系统中，所有的信号处理函数均通过 pthread_sigmask 来完成：\n1 2 3 4 5 6  //go:nosplit //go:cgo_unsafe_args func sigprocmask(how uint32, new *sigset, old*sigset) { libcCall(unsafe.Pointer(funcPC(sigprocmask_trampoline)), unsafe.Pointer(\u0026how)) } func sigprocmask_trampoline()   1 2 3 4 5 6 7 8 9 10 11 12  TEXT runtime·sigprocmask_trampoline(SB),NOSPLIT,$0 PUSHQ\tBP MOVQ\tSP, BP MOVQ\t8(DI), SI\t// arg 2 new MOVQ\t16(DI), DX\t// arg 3 old MOVL\t0(DI), DI\t// arg 1 how CALL\tlibc_pthread_sigmask(SB) TESTL\tAX, AX JEQ\t2(PC) MOVL\t$0xf1, 0xf1 // crash POPQ\tBP RET   msigsave 执行完毕后，sigmask 最后保存到 initSigmask 这一全局变量中， 用于初始化新创建的 M 的信号屏蔽字：\n1 2 3 4 5 6 7 8  // 用于新创建的 M 的信号掩码 signal mask 的值。 var initSigmask sigset func schedinit() { ... initSigmask = _g_.m.sigmask ... }   用于当新创建 M 时（newm），将 M 的 sigmask 进行设置。\n初始化信号栈 在进入 mstart 后，调用链关系就变成了：\n1 2 3 4 5 6 7 8  mstart ↳ mstart1 ↳ minit ↳ mstartm0 (仅当 m0 调用) ↳ schedule ↳ mexit ↳ sigblock ↳ unminit   mstart1 会调用 minit 进行初始化：\n1 2 3 4 5 6 7 8  func minit() { minitSignals() ... } func minitSignals() { minitSignalStack() minitSignalMask() }   M 在初始化过程中，会判定当前线程是否设置了备用信号栈， 正常情况下一个新创建的 M 是没有备用信号栈的。 如果没有，则会将 m.gsignal 的执行栈设置为备用信号栈，用于处理产生的信号。\n另一种情况是，当使用 cgo 时，非 Go 线程可能调用 Go 代码， 而这时用户态的 C 代码可能已经为非 Go 线程设置了信号栈，这时的替换必须小心。 因此如果 M 已经存在了备用信号栈，则会将现有的信号栈保存到 m.goSigStack 中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  type stackt struct { // 信号栈 \tss_sp *byte ss_flags int32 pad_cgo_0 [4]byte ss_size uintptr } // 如果没有为线程设置备用信号栈（正常情况），则将备用信号栈设置为 gsignal 栈。 // 如果为线程设置了备用信号栈（非 Go 线程设置备用信号栈然后调用 Go 函数的情况）， // 则将 gsignal 栈设置为备用信号栈。 // 如果没有使用 cgo 我们还设置了额外的 gsignal 信号栈（无论其是否已经被设置） // 记录在 newSigstack 中做出的选择， // 以便可以在 unminit 中撤消。 func minitSignalStack() { _g_ := getg() // 获取原有的信号栈 \tvar st stackt sigaltstack(nil, \u0026st) if st.ss_flags\u0026_SS_DISABLE != 0 { // 如果禁用了当前的信号栈 \t// 则将 gsignal 的执行栈设置为备用信号栈 \tsignalstack(\u0026_g_.m.gsignal.stack) _g_.m.newSigstack = true } else { // 否则将 m 的 gsignal 栈设置为从 sigaltstack 返回的备用信号栈 \tsetGsignalStack(\u0026st, \u0026_g_.m.goSigStack) _g_.m.newSigstack = false } } // 将 s 设置为备用信号栈，此方法仅在信号栈被禁用时调用 //go:nosplit func signalstack(s *stack) { st := stackt{ss_size: s.hi - s.lo} setSignalstackSP(\u0026st, s.lo) sigaltstack(\u0026st, nil) } //go:nosplit func setSignalstackSP(s*stackt, sp uintptr) { *(*uintptr)(unsafe.Pointer(\u0026s.ss_sp)) = sp } // setGsignalStack 将当前 m 的 gsignal 栈设置为从 sigaltstack 系统调用返回的备用信号堆栈。 // 它将旧值保存在 *old 中以供 restoreGsignalStack 使用。 // 如果非 Go 代码设置了，则在处理信号时使用备用栈。 //go:nosplit //go:nowritebarrierrec func setGsignalStack(st *stackt, old *gsignalStack) { g := getg() if old != nil { old.stack = g.m.gsignal.stack old.stackguard0 = g.m.gsignal.stackguard0 old.stackguard1 = g.m.gsignal.stackguard1 old.stktopsp = g.m.gsignal.stktopsp } stsp := uintptr(unsafe.Pointer(st.ss_sp)) g.m.gsignal.stack.lo = stsp g.m.gsignal.stack.hi = stsp + st.ss_size g.m.gsignal.stackguard0 = stsp +_StackGuard g.m.gsignal.stackguard1 = stsp + _StackGuard }   初始化信号屏蔽字 当设置好信号栈后，会开始对 M 设置信号的屏蔽字，通过 sigmask 来获得当前 M 的屏蔽字，而后通过遍历所有运行时信号表来对屏蔽字进行初始化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  func minitSignalMask() { nmask := getg().m.sigmask // 遍历整个信号表 \tfor i := range sigtable { // 判断某个信号是否为不可阻止的信号， \t// 如果是不可阻止的信号，则删除对应的屏蔽字所在位 \tif !blockableSig(uint32(i)) { sigdelset(\u0026nmask, i) } } // 重新设置屏蔽字 \tsigprocmask(_SIG_SETMASK, \u0026nmask, nil) } // 判断某个信号是否为不可阻止的信号 // 1. 当信号是非阻塞信号，则不可阻止 // 2. 当改程序为模块时，则可阻止 // 3. 当信号为 Kill 或 Throw 时，可阻止，否则不可阻止 func blockableSig(sig uint32) bool { flags := sigtable[sig].flags if flags\u0026_SigUnblock != 0 { return false } if isarchive || islibrary { return true } return flags\u0026(_SigKill|_SigThrow) == 0 } func sigdelset(mask *sigset, i int) { *mask \u0026^= 1  (uint32(i) - 1) }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  type sigTabT struct { flags int32 name string } var sigtable = [...]sigTabT{ /*0*/ {0, \"SIGNONE: no trap\"}, /*1*/ {_SigNotify +_SigKill, \"SIGHUP: terminal line hangup\"}, ... /*63*/ {_SigNotify, \"signal 63\"}, /* 64 */ {_SigNotify, \"signal 64\"}, } const ( _SigNotify = 1  iota // let signal.Notify have signal, even if from kernel \t_SigKill // if signal.Notify doesn't take it, exit quietly \t_SigThrow // if signal.Notify doesn't take it, exit loudly \t_SigPanic // if the signal is from the kernel, panic \t_SigDefault // if the signal isn't explicitly requested, don't monitor it \t_SigGoExit // cause all runtime procs to exit (only used on Plan 9). \t_SigSetStack // add SA_ONSTACK to libc handler \t_SigUnblock // always unblock; see blockableSig \t_SigIgn // _SIG_DFL action is to ignore the signal )   信号处理 万事俱备，只欠东风。信号处理相关的初始化已经完成，包括了信号的屏蔽字、信号栈等。 正式进入调度循环之前，在 M0 上将调用 mstartm0，进而调用 initsig 初始化信号，针对每个信号进行单独处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  //go:yeswritebarrierrec func mstartm0() { ... initsig(false) } const ( _NSIG = 32 _SI_USER = 0 /* empirically true, but not what headers say */ _SIG_BLOCK = 1 _SIG_UNBLOCK = 2 _SIG_SETMASK = 3 _SS_DISABLE = 4 ) // Initialize signals. // Called by libpreinit so runtime may not be initialized. //go:nosplit //go:nowritebarrierrec // 循环注册信号处理程序 func initsig(preinit bool) { if !preinit { // It's now OK for signal handlers to run. \tsignalsOK = true } // For c-archive/c-shared this is called by libpreinit with \t// preinit == true. \tif (isarchive || islibrary) \u0026\u0026 !preinit { return } for i := uint32(0); i  _NSIG; i++ { t := \u0026sigtable[i] if t.flags == 0 || t.flags\u0026_SigDefault != 0 { continue } // We don't need to use atomic operations here because \t// there shouldn't be any other goroutines running yet. \t// 此时不需要原子操作，因为此时没有其他运行的 Goroutine \tfwdSig[i] = getsig(i) // 检查该信号是否需要设置 signal handler \tif !sigInstallGoHandler(i) { // Even if we are not installing a signal handler, \t// set SA_ONSTACK if necessary. \t// 即使不设置 signal handler，在必要时设置 SA_ONSTACK \tif fwdSig[i] != _SIG_DFL \u0026\u0026 fwdSig[i] != _SIG_IGN { setsigstack(i) } else if fwdSig[i] == _SIG_IGN { sigInitIgnored(i) } continue } handlingSig[i] = 1 // 注册信号对应的回调方法 \tsetsig(i, funcPC(sighandler)) } }   对于一个需要设置 sighandler 的信号，会通过 setsig 来设置信号对应的动作（action）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  //go:nosplit //go:nowritebarrierrec // sigtramp注册为处理程序 func setsig(i uint32, fn uintptr) { var sa usigactiont sa.sa_flags =_SA_SIGINFO |_SA_ONSTACK |_SA_RESTART sa.sa_mask = ^uint32(0) if fn == funcPC(sighandler) { if iscgo { fn = funcPC(cgoSigtramp) } else { fn = funcPC(sigtramp) } } *(*uintptr)(unsafe.Pointer(\u0026sa.__sigaction_u)) = fn sigaction(i, \u0026sa, nil) } //go:nosplit //go:cgo_unsafe_args func sigaction(sig uint32, new *usigactiont, old *usigactiont) { libcCall(unsafe.Pointer(funcPC(sigaction_trampoline)), unsafe.Pointer(\u0026sig)) }   1 2 3 4 5 6 7 8 9 10 11  // sigaction-sysSigaction-rt_sigaction // 调用rt_sigaction系统调用，注册处理程序 TEXT runtime·rt_sigaction(SB),NOSPLIT,$0-36 MOVQ\tsig+0(FP), DI MOVQ\tnew+8(FP), SI MOVQ\told+16(FP), DX MOVQ\tsize+24(FP), R10 MOVL\t$SYS_rt_sigaction, AX SYSCALL MOVL\tAX, ret+32(FP) RET   以上逻辑主要作用就是循环注册 _NSIG（32） 个信号处理程序，其实都是 sigtramp 函数。操作系统内核在收到信号后会调用此函数。\n值得注意的是这里有一个特殊处理，当 fn 为 sighandler 时候， 产生信号后的动作并非直接调用 sighandler，而是被替换为了 sigtramp：\n1 2 3 4 5 6 7 8 9  TEXT runtime·sigtramp(SB),NOSPLIT,$72 ... MOVQ\tDX, ctx-56(SP) MOVQ\tSI, info-64(SP) MOVQ\tDI, signum-72(SP) MOVQ\t$runtime·sigtrampgo(SB), AX CALL AX ... RET   进而调用 sigtrampgo。这样的处理方式是因为， sighandler 会将产生的信号交给对应的 g ，此时还无法决定究竟谁来进行处理。 因此，当信号发生时，而 sigtrampgo 会被调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  // sigtrampgo is called from the signal handler function, sigtramp, // written in assembly code. // This is called by the signal handler, and the world may be stopped. // // It must be nosplit because getg() is still the G that was running // (if any) when the signal was delivered, but it's (usually) called // on the gsignal stack. Until this switches the G to gsignal, the // stack bounds check won't work. // //go:nosplit //go:nowritebarrierrec func sigtrampgo(sig uint32, info *siginfo, ctx unsafe.Pointer) { //sigfwdgo 用于约定该信号是否应该由 Go 进行处理， 如果不由 Go 进行处理（例如 cgo）则将其转发到 Go 代码之前设置的 handler 上。 \tif sigfwdgo(sig, info, ctx) { return } c := \u0026sigctxt{info, ctx} g := sigFetchG(c) setg(g) if g == nil { if sig == _SIGPROF { sigprofNonGoPC(c.sigpc()) return } if sig == sigPreempt \u0026\u0026 preemptMSupported \u0026\u0026 debug.asyncpreemptoff == 0 { // This is probably a signal from preemptM sent \t// while executing Go code but received while \t// executing non-Go code. \t// We got past sigfwdgo, so we know that there is \t// no non-Go signal handler for sigPreempt. \t// The default behavior for sigPreempt is to ignore \t// the signal, so badsignal will be a no-op anyway. \tif GOOS == \"darwin\" { atomic.Xadd(\u0026pendingPreemptSignals, -1) } return } c.fixsigcode(sig) badsignal(uintptr(sig), c) return } setg(g.m.gsignal) // If some non-Go code called sigaltstack, adjust. \tvar gsignalStack gsignalStack setStack := adjustSignalStack(sig, g.m, \u0026gsignalStack) if setStack { g.m.gsignal.stktopsp = getcallersp() } if g.stackguard0 == stackFork { signalDuringFork(sig) } c.fixsigcode(sig) sighandler(sig, info, ctx, g) setg(g) if setStack { restoreGsignalStack(\u0026gsignalStack) } }   sigtramp是入口，sighandler根据不同信号调用处理程序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  //go:nowritebarrierrec func sighandler(sig uint32, info *siginfo, ctxt unsafe.Pointer, gp*g) { _g_ := getg() c := \u0026sigctxt{info, ctxt} // profile 时钟超时 \tif sig == _SIGPROF { sigprof(c.sigpc(), c.sigsp(), c.siglr(), gp, _g_.m) return } if sig == _SIGTRAP \u0026\u0026 testSigtrap != nil \u0026\u0026 testSigtrap(info, (*sigctxt)(noescape(unsafe.Pointer(c))), gp) { return } // 用户信号 \tif sig == _SIGUSR1 \u0026\u0026 testSigusr1 != nil \u0026\u0026 testSigusr1(gp) { return } if sig == sigPreempt { // 可能是一个抢占信号 \tdoSigPreempt(gp, c) // 即便这是一个抢占信号，它也可能与其他信号进行混合，因此我们 \t// 继续进行处理。 \t} flags := int32(_SigThrow) if sig  uint32(len(sigtable)) { flags = sigtable[sig].flags } if flags\u0026_SigPanic != 0 \u0026\u0026 gp.throwsplit { // 我们无法安全的 sigpanic 因为它可能造成栈的增长，因此忽略它 \tflags = (flags \u0026^ _SigPanic) | _SigThrow } ... if c.sigcode() != _SI_USER \u0026\u0026 flags\u0026_SigPanic != 0 { // 产生 panic 的信号 \t... c.preparePanic(sig, gp) return } // 对用户注册的信号进行转发 \tif c.sigcode() == _SI_USER || flags\u0026_SigNotify != 0 { if sigsend(sig) { return } } // 设置为可忽略的用户信号 \tif c.sigcode() == _SI_USER \u0026\u0026 signal_ignored(sig) { return } // 处理 KILL 信号 \tif flags\u0026_SigKill != 0 { dieFromSignal(sig) } // 非 THROW，返回 \tif flags\u0026_SigThrow == 0 { return } // 处理一些直接 panic 的情况 \t... }   注意，在信号处理中，当信号为 sigPreempt 时，将触发运行时的异步抢占机制.\n函数 sigsend 会将用户信号发送到信号队列 sig 中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  var sig struct { note note mask [(_NSIG + 31) / 32]uint32 wanted [(_NSIG + 31) / 32]uint32 ignored [(_NSIG + 31) / 32]uint32 recv [(_NSIG + 31) / 32]uint32 state uint32 delivering uint32 inuse bool } func sigsend(s uint32) bool { bit := uint32(1)  uint(s\u002631) if !sig.inuse || s = uint32(32*len(sig.wanted)) { return false } atomic.Xadd(\u0026sig.delivering, 1) // We are running in the signal handler; defer is not available.  if w := atomic.Load(\u0026sig.wanted[s/32]); w\u0026bit == 0 { atomic.Xadd(\u0026sig.delivering, -1) return false } // Add signal to outgoing queue. \tfor { mask := sig.mask[s/32] if mask\u0026bit != 0 { atomic.Xadd(\u0026sig.delivering, -1) return true // signal already in queue \t} if atomic.Cas(\u0026sig.mask[s/32], mask, mask|bit) { break } } // Notify receiver that queue has new bit. Send: for { switch atomic.Load(\u0026sig.state) { default: throw(\"sigsend: inconsistent state\") case sigIdle: if atomic.Cas(\u0026sig.state, sigIdle, sigSending) { break Send } case sigSending: // notification already pending \tbreak Send case sigReceiving: if atomic.Cas(\u0026sig.state, sigReceiving, sigIdle) { notewakeup(\u0026sig.note) break Send } } } atomic.Xadd(\u0026sig.delivering, -1) return true }   用户信号的接收方是通过 os/signal 完成的，我们随后讨论。\n辅 M 线程 辅 M 是一个用于服务非 Go 线程（cgo 产生的线程）回调的 M。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  //go:yeswritebarrierrec func mstartm0() { // 创建一个额外的 M 服务 non-Go 线程（cgo 调用中产生的线程）的回调，并且只创建一个 \t// windows 上也需要额外 M 来服务 syscall.NewCallback 产生的回调，见 issue #6751 \tif (iscgo || GOOS == \"windows\") \u0026\u0026 !cgoHasExtraM { cgoHasExtraM = true newextram() } initsig(false) } // newextram 分配一个 m 并将其放入 extra 列表中 // 它会被工作中的本地 m 调用，因此它能够做一些调用 schedlock 和 allocate 类似的事情。 func newextram() { c := atomic.Xchg(\u0026extraMWaiters, 0) if c  0 { for i := uint32(0); i  c; i++ { oneNewExtraM() } } else { // 确保至少有一个额外的 M \tmp := lockextra(true) unlockextra(mp) if mp == nil { oneNewExtraM() } } } // onNewExtraM 分配一个 m 并将其放入 extra list 中 func oneNewExtraM() { mp := allocm(nil, nil) gp := malg(4096) gp.sched.pc = funcPC(goexit) + sys.PCQuantum gp.sched.sp = gp.stack.hi gp.sched.sp -= 4 * sys.RegSize gp.sched.lr = 0 gp.sched.g = guintptr(unsafe.Pointer(gp)) gp.syscallpc = gp.sched.pc gp.syscallsp = gp.sched.sp gp.stktopsp = gp.sched.sp gp.gcscanvalid = true gp.gcscandone = true casgstatus(gp, _Gidle, _Gdead) gp.m = mp mp.curg = gp mp.lockedInt++ mp.lockedg.set(gp) gp.lockedm.set(mp) gp.goid = int64(atomic.Xadd64(\u0026sched.goidgen, 1)) ... // 给垃圾回收器使用 \tallgadd(gp) atomic.Xadd(\u0026sched.ngsys, +1) // 将 m 添加到 extra m 链表中 \tmnext := lockextra(true) mp.schedlink.set(mnext) extraMCount++ unlockextra(mp) }   对 os/signal 包的支持 原理 在初始化阶段，signal产生一个goroutine，该 goroutine 循环运行并充当处理信号的使用者。此循环将一直休眠直到得到通知。这是第一步：\n然后，当信号到达程序时，信号处理程序将其委托给称为gsignal的特殊 goroutine。此 goroutine 是使用固定的且无法增长的较大堆栈（32k，以满足不同操作系统的要求）创建的。每个线程（用 M 表示）都有一个内部gsignal goroutine 来处理信号。这是更新的图：\ngsignal 分析信号以检查其是否可处理，并唤醒睡眠的goroutine并将信号发送到队列：\nSIGBUS或SIGFPE之类的同步信号无法管理，将转换为 panic\n然后，此循环 goroutine 可以对其进行处理。它首先查找已预订此事件的 channel，并将信号推送给他们：\n锁定或阻塞gsignal会使信号处理陷入困境。由于其固定大小，它也无法分配内存。这就是为什么在信号处理链中具有两个独立的 goroutine 的重要性：一个在信号到达时立即将它们排队，另一个在同一队列中循环处理它们。\n现在，我们可以使用新组件来更新第一部分的插图：\n源码 我们已经看到了用户注册的信号会通过 sigsend 进行发送，这就是我们使用 os/signal 包的核心。\n在使用 os/signal 后，会调用 signal.init 函数，懒惰的注册一个用户端的信号处理循环（当调用 Notify 时启动）：\n1 2 3 4 5 6 7 8 9 10 11 12 13  var ( watchSignalLoopOnce sync.Once watchSignalLoop func() ) func init() { signal_enable(0) // 首次调用，进行初始化 \twatchSignalLoop = loop } func loop() { for { process(syscall.Signal(signal_recv())) } }   这个 signal_enable 和 signal_recv 用于激活运行时的信号队列，并从中接受信号：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  // 启用运行时信号队列 //go:linkname signal_enable os/signal.signal_enable func signal_enable(s uint32) { if !sig.inuse { // The first call to signal_enable is for us \t// to use for initialization. It does not pass \t// signal information in m. \tsig.inuse = true // enable reception of signals; cannot disable \tnoteclear(\u0026sig.note) return } if s = uint32(len(sig.wanted)*32) { return } w := sig.wanted[s/32] w |= 1  (s \u0026 31) atomic.Store(\u0026sig.wanted[s/32], w) i := sig.ignored[s/32] i \u0026^= 1  (s \u0026 31) atomic.Store(\u0026sig.ignored[s/32], i) sigenable(s) } // 从信号队列中接受信号 //go:linkname signal_recv os/signal.signal_recv func signal_recv() uint32 { for { // Serve any signals from local copy. \tfor i := uint32(0); i _NSIG; i++ { if sig.recv[i/32]\u0026(1(i\u002631)) != 0 { sig.recv[i/32] \u0026^= 1  (i \u0026 31) return i } } // Wait for updates to be available from signal sender. \tReceive: for { switch atomic.Load(\u0026sig.state) { default: throw(\"signal_recv: inconsistent state\") case sigIdle: if atomic.Cas(\u0026sig.state, sigIdle, sigReceiving) { notetsleepg(\u0026sig.note, -1) noteclear(\u0026sig.note) break Receive } case sigSending: if atomic.Cas(\u0026sig.state, sigSending, sigIdle) { break Receive } } } // Incorporate updates from sender into local copy. \tfor i := range sig.mask { sig.recv[i] = atomic.Xchg(\u0026sig.mask[i], 0) } } }   当接受到信号后，信号 sig 会被发送到用户在 Ignore/Notify/Stop 上所注册的 channel 上：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  func process(sig os.Signal) { n := signum(sig) if n  0 { return } handlers.Lock() defer handlers.Unlock() for c, h := range handlers.m { if h.want(n) { // 发送 \t// send but do not block for it \tselect { case c  sig: default: } } } // Stop 的处理 \t// Avoid the race mentioned in Stop. \tfor _, d := range handlers.stopping { if d.h.want(n) { select { case d.c  sig: default: } } } }   例如 signal.Notify，将信号 channel 注册到 handler 全局变量中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  var handlers struct { sync.Mutex m map[chan os.Signal]*handler ref [numSig]int64 stopping []stopping } func Notify(c chan os.Signal, sig ...os.Signal) { if c == nil { panic(\"os/signal: Notify using nil channel\") } watchSignalLoopOnce.Do(func() { if watchSignalLoop != nil { go watchSignalLoop() } }) handlers.Lock() defer handlers.Unlock() h := handlers.m[c] if h == nil { if handlers.m == nil { handlers.m = make(map[chan os.Signal]*handler) } h = new(handler) handlers.m[c] = h // 保存到 handler 中 \t} add := func(n int) { if n  0 { return } if !h.want(n) { h.set(n) if handlers.ref[n] == 0 { enableSignal(n) } handlers.ref[n]++ } } if len(sig) == 0 { for n := 0; n  numSig; n++ { add(n) } } else { for _, s := range sig { add(signum(s)) } } }   小结 由于调度器在 Go 程序运行时的特殊地位，以及在进行跨语言调用时需要 cgo 的支持， 运行时信号处理相对而言还是较为复杂的，需要一套完整的机制来对各种情况进行处理， 甚至对用户态代码的 os/signal 进行支持。\n转载: 6.6 信号处理机制\n",
  "wordCount" : "7125",
  "inLanguage": "zh-cn",
  "datePublished": "2020-11-26T22:58:57Z",
  "dateModified": "2020-11-26T22:58:57Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/go%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Go的信号处理源码剖析
    </h1>
    <div class="post-meta">November 26, 2020
</div>
  </header> 
  <div class="post-content"><h2 id="前言">前言<a hidden class="anchor" aria-hidden="true" href="#前言">#</a></h2>
<p>我们已经知道了 Go 运行时调度以 Goroutine 的方式调度了所有用户态代码。 每个 Goroutine 都有可能在不同的线程上重新被执行。 那么如果用户态的某个 Goroutine 需要接收系统信号， 如何才能确保某个线程的信号能够正确的发送到可能在其他线程上执行的监听信号的 Goroutine 呢？</p>
<p>本节我们讨论调度器里涉及的 signal 信号处理机制。</p>
<h2 id="信号与软中断">信号与软中断<a hidden class="anchor" aria-hidden="true" href="#信号与软中断">#</a></h2>
<p>信号机制是 UNIX、类 UNIX 甚至其他 POSIX 兼容系统上规定的一种进程异步通信的限制形式。 用于提醒某个事件的发生状态。 信号被定义为整数，产生信号的条件包括用户使用某些按键组合（比如 Control + C）、 硬件异常、kill 信号等等。</p>
<p>这些信号通常有三种不同的处理方式：忽略、捕获或者执行系统的默认行为。 忽略与捕获处理无法处理 SIGKILL 和 SIGSTOP，默认处理通常为停止进程。 而对于捕获处理而言，当信号发生时，操作系统将中断用户代码，并保存其执行的上下文，切换到内核空间 并重新切换到用户空间来执行预先设置好的信号处理回调。当回调执行完毕之后，会重新切换回内核 空间，并从中断的位置进行恢复，如图所示。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201126230856.png" alt=""  />
</p>
<p>系统调用 sigaltstack 可以用于定义一个备用的信号栈来获取一个存在的额外信号栈的状态。 一个额外的信号栈会在信号处理执行中进行使用。</p>
<p>每个进程都包含一个信号屏蔽字（signal mask），规定了当前要阻塞递送到该进程的信号集。 对于每种可能的信号，屏蔽字中都有一位与之对应。 对于某种信号，若其对应位置已设置，则它当前是被阻塞的。 如果要检测和修改当前信号屏蔽字，则需要调用 sigprocmask 系统调用来进行。通过 _SIG_SETMASK 可以直接设置想要的屏蔽字，并获得原先的屏蔽字。</p>
<p>每个线程都有自己独立的signal mask，但所有线程共享进程的signal action。这意味着，你可以在线程中调用pthread_sigmask(不是sigmask)来决定本线程阻塞哪些信号。但你不能调用sigaction来指定单个线程的信号处理方式。如果在某个线程中调用了sigaction处理某个信号，那么这个进程中的未阻塞这个信号的线程在收到这个信号都会按同一种方式处理这个信号。所以每个线程不能按自己的方式处理信号。</p>
<p>在Linux中的posix线程模型中，线程拥有独立的进程号，可以通过getpid()得到线程的进程号，而线程号保存在pthread_t的值中。而主线程的进程号就是整个进程的进程号，因此向主进程发送信号只会将信号发送到主线程中去。如果主线程设置了信号屏蔽，则信号会投递到一个可以处理的线程中去。</p>
<ol>
<li>
<p>如果是异常产生的信号（比如程序错误，像SIGPIPE、SIGEGV这些），则只有产生异常的线程收到并处理。</p>
</li>
<li>
<p>如果是用pthread_kill产生的内部信号，则只有pthread_kill参数中指定的目标线程收到并处理。</p>
</li>
<li>
<p>如果是外部使用kill命令产生的信号，通常是SIGINT、SIGHUP等job control信号，则会遍历所有线程，直到找到一个不阻塞该信号的线程，然后调用它来处理。(一般从主线程找起)，注意只有一个线程能收到。
　　</p>
</li>
</ol>
<h2 id="处理函数的初始化">处理函数的初始化<a hidden class="anchor" aria-hidden="true" href="#处理函数的初始化">#</a></h2>
<p>调度循环中讨论过了 M 的生命周期，M 可以在两种情况下被创建：</p>
<ol>
<li>
<p>程序运行之初的 M0，无需创建已经存在的系统线程，只需对其进行初始化即可。其函数调用链如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">schedinit</span>
 ↳ <span class="n">mcommoninit</span>
    ↳ <span class="n">mpreinit</span>
       ↳ <span class="n">msigsave</span>
          ↳ <span class="n">initSigmask</span>
             ↳ <span class="n">mstart</span>
</code></pre></td></tr></table>
</div>
</div><p>``</p>
</li>
<li>
<p>需要时创建的 M，某些特殊情况下一定会创建一个新的 M 并进行初始化，而后创建系统线程。这些情况包括：</p>
<ol>
<li>startm 时没有空闲 m</li>
<li>startTemplateThread 时</li>
<li>startTheWorldWithSema 时 p 如果没有 m</li>
<li>main 时创建系统监控</li>
<li>oneNewExtraM 时
其调用链为：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">newm</span>
 ↳ <span class="n">allocm</span>
    ↳ <span class="n">mcommoninit</span>
       ↳ <span class="n">mpreinit</span>
          ↳ <span class="n">newm1</span>
             ↳ <span class="n">newosproc</span>
                ↳ <span class="n">mstart</span>
</code></pre></td></tr></table>
</div>
</div><p>``</p>
</li>
</ol>
<p>在 mcommoninit 里，会在一个父线程（或引导时的主线程）上调用 mpreinit，并最终会为一个 M 创建 gsignal，是一个在 M 上用于处理信号的 Goroutine。因此，除了 g0 外，其实第一个创建的 g 应该是它， 但是它并没有设置 Goid (Goroutine ID)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mcommoninit</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="c1">// 初始化 gsignal，用于处理 m 上的信号。
</span><span class="c1"></span>	<span class="nf">mpreinit</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="c1">// gsignal 的运行栈边界处理
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stackguard1</span> <span class="p">=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
<span class="c1">// 从一个父线程上进行调用（引导时为主线程），可以分配内存
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mpreinit</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="mi">32</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="c1">// OS X 需要 &gt;= 8K，此处创建处理 singnal 的 g
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nx">mp</span>            <span class="c1">// 指定 gsignal 拥有的 m
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="获取原始信号屏蔽字">获取原始信号屏蔽字<a hidden class="anchor" aria-hidden="true" href="#获取原始信号屏蔽字">#</a></h3>
<p>在调度器的初始化的阶段，initSigmask 目标旨在记录主线程 M0 创建之初的屏蔽字 sigmask：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">schedinit</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="o">...</span>
	<span class="nf">mcommoninit</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>
	<span class="o">...</span>
	<span class="nf">msigsave</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>
	<span class="nx">initSigmask</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">sigmask</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中 msigsave 通过 sigprocmask 这个系统调用将当前 m0 的屏蔽字保存到 mp.sigmask 上：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">_SIG_SETMASK</span> <span class="p">=</span> <span class="mi">3</span>

<span class="c1">// msigsave 将当前线程的信号屏蔽字保存到 mp.sigmask。
</span><span class="c1">//go:nosplit
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">msigsave</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">sigprocmask</span><span class="p">(</span><span class="nx">_SIG_SETMASK</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">sigmask</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>sigprocmask 的本质为系统调用，其返回值通过 old 交付给调用者：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">sigset</span> <span class="kt">uint32</span>
<span class="c1">//go:nosplit
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sigprocmask</span><span class="p">(</span><span class="nx">how</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">new</span><span class="p">,</span> <span class="nx">old</span> <span class="o">*</span><span class="nx">sigset</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">rtsigprocmask</span><span class="p">(</span><span class="nx">how</span><span class="p">,</span> <span class="nx">new</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="o">*</span><span class="nx">new</span><span class="p">)))</span>
<span class="p">}</span>
<span class="c1">//go:noescape
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">rtsigprocmask</span><span class="p">(</span><span class="nx">how</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">new</span><span class="p">,</span> <span class="nx">old</span> <span class="o">*</span><span class="nx">sigset</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int32</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>rtsigprocmask 在 Linux 上由汇编直接包装 rt_sigprocmask 调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">TEXT</span> <span class="n">runtime</span>·<span class="nf">rtsigprocmask</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span><span class="n">NOSPLIT</span><span class="p">,</span><span class="o">$</span><span class="m">0-28</span>
	<span class="n">MOVL</span>	<span class="n">how</span><span class="m">+0</span><span class="p">(</span><span class="n">FP</span><span class="p">),</span> <span class="n">DI</span>
	<span class="n">MOVQ</span>	<span class="n">new</span><span class="m">+8</span><span class="p">(</span><span class="n">FP</span><span class="p">),</span> <span class="n">SI</span>
	<span class="n">MOVQ</span>	<span class="n">old</span><span class="m">+16</span><span class="p">(</span><span class="n">FP</span><span class="p">),</span> <span class="n">DX</span>
	<span class="n">MOVL</span>	<span class="n">size</span><span class="m">+24</span><span class="p">(</span><span class="n">FP</span><span class="p">),</span> <span class="n">R10</span>
	<span class="n">MOVL</span>	<span class="o">$</span><span class="n">SYS_rt_sigprocmask</span><span class="p">,</span> <span class="n">AX</span>
	<span class="n">SYSCALL</span>
	<span class="n">CMPQ</span>	<span class="n">AX</span><span class="p">,</span> <span class="o">$</span><span class="mh">0xfffffffffffff001</span>
	<span class="n">JLS</span>	<span class="m">2</span><span class="p">(</span><span class="n">PC</span><span class="p">)</span>
	<span class="n">MOVL</span>	<span class="o">$</span><span class="mh">0xf1</span><span class="p">,</span> <span class="mh">0xf1</span>  <span class="o">//</span> <span class="n">crash</span>
	<span class="n">RET</span>
</code></pre></td></tr></table>
</div>
</div><p>注意，rt_sigprocmask 只适用于单个线程的调用，多线程上的调用时未定义行为， 不过初始化阶段的此时还未创建其他线程，因此此调用时安全的。</p>
<p>在 Darwin 系统中，所有的信号处理函数均通过 pthread_sigmask 来完成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:nosplit
</span><span class="c1">//go:cgo_unsafe_args
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sigprocmask</span><span class="p">(</span><span class="nx">how</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">new</span> <span class="o">*</span><span class="nx">sigset</span><span class="p">,</span> <span class="nx">old</span><span class="o">*</span><span class="nx">sigset</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">libcCall</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nf">funcPC</span><span class="p">(</span><span class="nx">sigprocmask_trampoline</span><span class="p">)),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">how</span><span class="p">))</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">sigprocmask_trampoline</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">TEXT</span> <span class="n">runtime</span>·<span class="nf">sigprocmask_trampoline</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span><span class="n">NOSPLIT</span><span class="p">,</span><span class="o">$</span><span class="m">0</span>
	<span class="n">PUSHQ</span>	<span class="n">BP</span>
	<span class="n">MOVQ</span>	<span class="n">SP</span><span class="p">,</span> <span class="n">BP</span>
	<span class="n">MOVQ</span>	<span class="m">8</span><span class="p">(</span><span class="n">DI</span><span class="p">),</span> <span class="n">SI</span>	<span class="o">//</span> <span class="n">arg</span> <span class="m">2</span> <span class="n">new</span>
	<span class="n">MOVQ</span>	<span class="m">16</span><span class="p">(</span><span class="n">DI</span><span class="p">),</span> <span class="n">DX</span>	<span class="o">//</span> <span class="n">arg</span> <span class="m">3</span> <span class="n">old</span>
	<span class="n">MOVL</span>	<span class="m">0</span><span class="p">(</span><span class="n">DI</span><span class="p">),</span> <span class="n">DI</span>	<span class="o">//</span> <span class="n">arg</span> <span class="m">1</span> <span class="n">how</span>
	<span class="n">CALL</span>	<span class="nf">libc_pthread_sigmask</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
	<span class="n">TESTL</span>	<span class="n">AX</span><span class="p">,</span> <span class="n">AX</span>
	<span class="n">JEQ</span>	<span class="m">2</span><span class="p">(</span><span class="n">PC</span><span class="p">)</span>
	<span class="n">MOVL</span>	<span class="o">$</span><span class="mh">0xf1</span><span class="p">,</span> <span class="mh">0xf1</span>  <span class="o">//</span> <span class="n">crash</span>
	<span class="n">POPQ</span>	<span class="n">BP</span>
	<span class="n">RET</span>
</code></pre></td></tr></table>
</div>
</div><p>msigsave 执行完毕后，sigmask 最后保存到 initSigmask 这一全局变量中， 用于初始化新创建的 M 的信号屏蔽字：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 用于新创建的 M 的信号掩码 signal mask 的值。
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">initSigmask</span> <span class="nx">sigset</span>

<span class="kd">func</span> <span class="nf">schedinit</span><span class="p">()</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nx">initSigmask</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">sigmask</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>用于当新创建 M 时（newm），将 M 的 sigmask 进行设置。</p>
<h3 id="初始化信号栈">初始化信号栈<a hidden class="anchor" aria-hidden="true" href="#初始化信号栈">#</a></h3>
<p>在进入 mstart 后，调用链关系就变成了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">mstart</span>
 ↳ <span class="n">mstart1</span>
    ↳ <span class="n">minit</span>
       ↳ <span class="nf">mstartm0 </span><span class="p">(</span>仅当 <span class="n">m0</span> 调用<span class="p">)</span>
          ↳ <span class="n">schedule</span>
             ↳ <span class="n">mexit</span>
                ↳ <span class="n">sigblock</span>
                   ↳ <span class="n">unminit</span>
</code></pre></td></tr></table>
</div>
</div><p>mstart1 会调用 minit 进行初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">minit</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">minitSignals</span><span class="p">()</span>
	<span class="o">...</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">minitSignals</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">minitSignalStack</span><span class="p">()</span>
	<span class="nf">minitSignalMask</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>M 在初始化过程中，会判定当前线程是否设置了备用信号栈， 正常情况下一个新创建的 M 是没有备用信号栈的。 如果没有，则会将 m.gsignal 的执行栈设置为备用信号栈，用于处理产生的信号。</p>
<p>另一种情况是，当使用 cgo 时，非 Go 线程可能调用 Go 代码， 而这时用户态的 C 代码可能已经为非 Go 线程设置了信号栈，这时的替换必须小心。 因此如果 M 已经存在了备用信号栈，则会将现有的信号栈保存到 m.goSigStack 中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">stackt</span> <span class="kd">struct</span> <span class="p">{</span> <span class="c1">// 信号栈
</span><span class="c1"></span>	<span class="nx">ss_sp</span>     <span class="o">*</span><span class="kt">byte</span>
	<span class="nx">ss_flags</span>  <span class="kt">int32</span>
	<span class="nx">pad_cgo_0</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">byte</span>
	<span class="nx">ss_size</span>   <span class="kt">uintptr</span>
<span class="p">}</span>
<span class="c1">// 如果没有为线程设置备用信号栈（正常情况），则将备用信号栈设置为 gsignal 栈。
</span><span class="c1">// 如果为线程设置了备用信号栈（非 Go 线程设置备用信号栈然后调用 Go 函数的情况），
</span><span class="c1">// 则将 gsignal 栈设置为备用信号栈。
</span><span class="c1">// 如果没有使用 cgo 我们还设置了额外的 gsignal 信号栈（无论其是否已经被设置）
</span><span class="c1">// 记录在 newSigstack 中做出的选择，
</span><span class="c1">// 以便可以在 unminit 中撤消。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">minitSignalStack</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="c1">// 获取原有的信号栈
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">st</span> <span class="nx">stackt</span>
	<span class="nf">sigaltstack</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">st</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">st</span><span class="p">.</span><span class="nx">ss_flags</span><span class="o">&amp;</span><span class="nx">_SS_DISABLE</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 如果禁用了当前的信号栈
</span><span class="c1"></span>		<span class="c1">// 则将 gsignal 的执行栈设置为备用信号栈
</span><span class="c1"></span>		<span class="nf">signalstack</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">newSigstack</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 否则将 m 的 gsignal 栈设置为从 sigaltstack 返回的备用信号栈
</span><span class="c1"></span>		<span class="nf">setGsignalStack</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">st</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">goSigStack</span><span class="p">)</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">newSigstack</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 将 s 设置为备用信号栈，此方法仅在信号栈被禁用时调用
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">signalstack</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">stack</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">st</span> <span class="o">:=</span> <span class="nx">stackt</span><span class="p">{</span><span class="nx">ss_size</span><span class="p">:</span> <span class="nx">s</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">s</span><span class="p">.</span><span class="nx">lo</span><span class="p">}</span>
	<span class="nf">setSignalstackSP</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">st</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">lo</span><span class="p">)</span>
	<span class="nf">sigaltstack</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">st</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">setSignalstackSP</span><span class="p">(</span><span class="nx">s</span><span class="o">*</span><span class="nx">stackt</span><span class="p">,</span> <span class="nx">sp</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">ss_sp</span><span class="p">))</span> <span class="p">=</span> <span class="nx">sp</span>
<span class="p">}</span>
<span class="c1">// setGsignalStack 将当前 m 的 gsignal 栈设置为从 sigaltstack 系统调用返回的备用信号堆栈。
</span><span class="c1">// 它将旧值保存在 *old 中以供 restoreGsignalStack 使用。
</span><span class="c1">// 如果非 Go 代码设置了，则在处理信号时使用备用栈。
</span><span class="c1">//go:nosplit
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">setGsignalStack</span><span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">stackt</span><span class="p">,</span> <span class="nx">old</span> <span class="o">*</span><span class="nx">gsignalStack</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">g</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">old</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">old</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stack</span>
		<span class="nx">old</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stackguard0</span>
		<span class="nx">old</span><span class="p">.</span><span class="nx">stackguard1</span> <span class="p">=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stackguard1</span>
		<span class="nx">old</span><span class="p">.</span><span class="nx">stktopsp</span> <span class="p">=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stktopsp</span>
	<span class="p">}</span>
	<span class="nx">stsp</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">ss_sp</span><span class="p">))</span>
	<span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="p">=</span> <span class="nx">stsp</span>
	<span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="p">=</span> <span class="nx">stsp</span> <span class="o">+</span> <span class="nx">st</span><span class="p">.</span><span class="nx">ss_size</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stsp</span> <span class="o">+</span><span class="nx">_StackGuard</span>
	<span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stackguard1</span> <span class="p">=</span> <span class="nx">stsp</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="初始化信号屏蔽字">初始化信号屏蔽字<a hidden class="anchor" aria-hidden="true" href="#初始化信号屏蔽字">#</a></h3>
<p>当设置好信号栈后，会开始对 M 设置信号的屏蔽字，通过 sigmask 来获得当前 M 的屏蔽字，而后通过遍历所有运行时信号表来对屏蔽字进行初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">minitSignalMask</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">nmask</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">sigmask</span>
	<span class="c1">// 遍历整个信号表
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">sigtable</span> <span class="p">{</span>
		<span class="c1">// 判断某个信号是否为不可阻止的信号，
</span><span class="c1"></span>		<span class="c1">// 如果是不可阻止的信号，则删除对应的屏蔽字所在位
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nf">blockableSig</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="nf">sigdelset</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">nmask</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 重新设置屏蔽字
</span><span class="c1"></span>	<span class="nf">sigprocmask</span><span class="p">(</span><span class="nx">_SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">nmask</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 判断某个信号是否为不可阻止的信号
</span><span class="c1">// 1. 当信号是非阻塞信号，则不可阻止
</span><span class="c1">// 2. 当改程序为模块时，则可阻止
</span><span class="c1">// 3. 当信号为 Kill 或 Throw 时，可阻止，否则不可阻止
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">blockableSig</span><span class="p">(</span><span class="nx">sig</span> <span class="kt">uint32</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">flags</span> <span class="o">:=</span> <span class="nx">sigtable</span><span class="p">[</span><span class="nx">sig</span><span class="p">].</span><span class="nx">flags</span>
	<span class="k">if</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">_SigUnblock</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">isarchive</span> <span class="o">||</span> <span class="nx">islibrary</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">_SigKill</span><span class="p">|</span><span class="nx">_SigThrow</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">sigdelset</span><span class="p">(</span><span class="nx">mask</span> <span class="o">*</span><span class="nx">sigset</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">*</span><span class="nx">mask</span> <span class="o">&amp;^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">sigTabT</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">flags</span> <span class="kt">int32</span>
	<span class="nx">name</span>  <span class="kt">string</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">sigtable</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="nx">sigTabT</span><span class="p">{</span>
	<span class="cm">/*0*/</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#34;SIGNONE: no trap&#34;</span><span class="p">},</span>
	<span class="cm">/*1*/</span> <span class="p">{</span><span class="nx">_SigNotify</span> <span class="o">+</span><span class="nx">_SigKill</span><span class="p">,</span> <span class="s">&#34;SIGHUP: terminal line hangup&#34;</span><span class="p">},</span>
	<span class="o">...</span>
	<span class="cm">/*63*/</span> <span class="p">{</span><span class="nx">_SigNotify</span><span class="p">,</span> <span class="s">&#34;signal 63&#34;</span><span class="p">},</span>
	<span class="cm">/* 64 */</span> <span class="p">{</span><span class="nx">_SigNotify</span><span class="p">,</span> <span class="s">&#34;signal 64&#34;</span><span class="p">},</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">_SigNotify</span>   <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span> <span class="c1">// let signal.Notify have signal, even if from kernel
</span><span class="c1"></span>	<span class="nx">_SigKill</span>                 <span class="c1">// if signal.Notify doesn&#39;t take it, exit quietly
</span><span class="c1"></span>	<span class="nx">_SigThrow</span>                <span class="c1">// if signal.Notify doesn&#39;t take it, exit loudly
</span><span class="c1"></span>	<span class="nx">_SigPanic</span>                <span class="c1">// if the signal is from the kernel, panic
</span><span class="c1"></span>	<span class="nx">_SigDefault</span>              <span class="c1">// if the signal isn&#39;t explicitly requested, don&#39;t monitor it
</span><span class="c1"></span>	<span class="nx">_SigGoExit</span>               <span class="c1">// cause all runtime procs to exit (only used on Plan 9).
</span><span class="c1"></span>	<span class="nx">_SigSetStack</span>             <span class="c1">// add SA_ONSTACK to libc handler
</span><span class="c1"></span>	<span class="nx">_SigUnblock</span>              <span class="c1">// always unblock; see blockableSig
</span><span class="c1"></span>	<span class="nx">_SigIgn</span>                  <span class="c1">// _SIG_DFL action is to ignore the signal
</span><span class="c1"></span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="信号处理">信号处理<a hidden class="anchor" aria-hidden="true" href="#信号处理">#</a></h2>
<p>万事俱备，只欠东风。信号处理相关的初始化已经完成，包括了信号的屏蔽字、信号栈等。 正式进入调度循环之前，在 M0 上将调用 mstartm0，进而调用 initsig 初始化信号，针对每个信号进行单独处理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:yeswritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mstartm0</span><span class="p">()</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nf">initsig</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">_NSIG</span>        <span class="p">=</span> <span class="mi">32</span>
	<span class="nx">_SI_USER</span>     <span class="p">=</span> <span class="mi">0</span> <span class="cm">/* empirically true, but not what headers say */</span>
	<span class="nx">_SIG_BLOCK</span>   <span class="p">=</span> <span class="mi">1</span>
	<span class="nx">_SIG_UNBLOCK</span> <span class="p">=</span> <span class="mi">2</span>
	<span class="nx">_SIG_SETMASK</span> <span class="p">=</span> <span class="mi">3</span>
	<span class="nx">_SS_DISABLE</span>  <span class="p">=</span> <span class="mi">4</span>
<span class="p">)</span>
<span class="c1">// Initialize signals.
</span><span class="c1">// Called by libpreinit so runtime may not be initialized.
</span><span class="c1">//go:nosplit
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1">// 循环注册信号处理程序
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">initsig</span><span class="p">(</span><span class="nx">preinit</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">preinit</span> <span class="p">{</span>
		<span class="c1">// It&#39;s now OK for signal handlers to run.
</span><span class="c1"></span>		<span class="nx">signalsOK</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="c1">// For c-archive/c-shared this is called by libpreinit with
</span><span class="c1"></span>	<span class="c1">// preinit == true.
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="nx">isarchive</span> <span class="o">||</span> <span class="nx">islibrary</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">preinit</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">_NSIG</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sigtable</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">flags</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">t</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">_SigDefault</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="c1">// We don&#39;t need to use atomic operations here because
</span><span class="c1"></span>		<span class="c1">// there shouldn&#39;t be any other goroutines running yet.
</span><span class="c1"></span>		<span class="c1">// 此时不需要原子操作，因为此时没有其他运行的 Goroutine
</span><span class="c1"></span>		<span class="nx">fwdSig</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">getsig</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
		<span class="c1">// 检查该信号是否需要设置 signal handler
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nf">sigInstallGoHandler</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Even if we are not installing a signal handler,
</span><span class="c1"></span>			<span class="c1">// set SA_ONSTACK if necessary.
</span><span class="c1"></span>			<span class="c1">// 即使不设置 signal handler，在必要时设置 SA_ONSTACK
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">fwdSig</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">_SIG_DFL</span> <span class="o">&amp;&amp;</span> <span class="nx">fwdSig</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">_SIG_IGN</span> <span class="p">{</span>
				<span class="nf">setsigstack</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">fwdSig</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">_SIG_IGN</span> <span class="p">{</span>
				<span class="nf">sigInitIgnored</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="nx">handlingSig</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="c1">// 注册信号对应的回调方法
</span><span class="c1"></span>		<span class="nf">setsig</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">sighandler</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>对于一个需要设置 sighandler 的信号，会通过 setsig 来设置信号对应的动作（action）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:nosplit
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1">// sigtramp注册为处理程序
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">setsig</span><span class="p">(</span><span class="nx">i</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">fn</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">sa</span> <span class="nx">usigactiont</span>
	<span class="nx">sa</span><span class="p">.</span><span class="nx">sa_flags</span> <span class="p">=</span><span class="nx">_SA_SIGINFO</span> <span class="p">|</span><span class="nx">_SA_ONSTACK</span> <span class="p">|</span><span class="nx">_SA_RESTART</span>
	<span class="nx">sa</span><span class="p">.</span><span class="nx">sa_mask</span> <span class="p">=</span> <span class="p">^</span><span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">fn</span> <span class="o">==</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">sighandler</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">iscgo</span> <span class="p">{</span>
			<span class="nx">fn</span> <span class="p">=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">cgoSigtramp</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">fn</span> <span class="p">=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">sigtramp</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sa</span><span class="p">.</span><span class="nx">__sigaction_u</span><span class="p">))</span> <span class="p">=</span> <span class="nx">fn</span>
	<span class="nf">sigaction</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">sa</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//go:nosplit
</span><span class="c1">//go:cgo_unsafe_args
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sigaction</span><span class="p">(</span><span class="nx">sig</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">new</span> <span class="o">*</span><span class="nx">usigactiont</span><span class="p">,</span> <span class="nx">old</span> <span class="o">*</span><span class="nx">usigactiont</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">libcCall</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nf">funcPC</span><span class="p">(</span><span class="nx">sigaction_trampoline</span><span class="p">)),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sig</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">//</span> <span class="n">sigaction</span><span class="o">-&gt;</span><span class="n">sysSigaction</span><span class="o">-&gt;</span><span class="n">rt_sigaction</span>
<span class="o">//</span> 调用<span class="n">rt_sigaction系统调用</span>，注册处理程序
<span class="n">TEXT</span> <span class="n">runtime</span>·<span class="nf">rt_sigaction</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span><span class="n">NOSPLIT</span><span class="p">,</span><span class="o">$</span><span class="m">0-36</span>
	<span class="n">MOVQ</span>	<span class="n">sig</span><span class="m">+0</span><span class="p">(</span><span class="n">FP</span><span class="p">),</span> <span class="n">DI</span>
	<span class="n">MOVQ</span>	<span class="n">new</span><span class="m">+8</span><span class="p">(</span><span class="n">FP</span><span class="p">),</span> <span class="n">SI</span>
	<span class="n">MOVQ</span>	<span class="n">old</span><span class="m">+16</span><span class="p">(</span><span class="n">FP</span><span class="p">),</span> <span class="n">DX</span>
	<span class="n">MOVQ</span>	<span class="n">size</span><span class="m">+24</span><span class="p">(</span><span class="n">FP</span><span class="p">),</span> <span class="n">R10</span>
	<span class="n">MOVL</span>	<span class="o">$</span><span class="n">SYS_rt_sigaction</span><span class="p">,</span> <span class="n">AX</span>
	<span class="n">SYSCALL</span>
	<span class="n">MOVL</span>	<span class="n">AX</span><span class="p">,</span> <span class="n">ret</span><span class="m">+32</span><span class="p">(</span><span class="n">FP</span><span class="p">)</span>
	<span class="n">RET</span>
</code></pre></td></tr></table>
</div>
</div><p>以上逻辑主要作用就是循环注册 _NSIG（32） 个信号处理程序，其实都是 sigtramp 函数。操作系统内核在收到信号后会调用此函数。</p>
<p>值得注意的是这里有一个特殊处理，当 fn 为 sighandler 时候， 产生信号后的动作并非直接调用 sighandler，而是被替换为了 sigtramp：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">TEXT</span> <span class="n">runtime</span>·<span class="nf">sigtramp</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span><span class="n">NOSPLIT</span><span class="p">,</span><span class="o">$</span><span class="m">72</span>
	<span class="kc">...</span>
	<span class="n">MOVQ</span>	<span class="n">DX</span><span class="p">,</span> <span class="n">ctx</span><span class="m">-56</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
	<span class="n">MOVQ</span>	<span class="n">SI</span><span class="p">,</span> <span class="n">info</span><span class="m">-64</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
	<span class="n">MOVQ</span>	<span class="n">DI</span><span class="p">,</span> <span class="n">signum</span><span class="m">-72</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
	<span class="n">MOVQ</span>	<span class="o">$</span><span class="n">runtime</span>·<span class="nf">sigtrampgo</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">AX</span>
	<span class="n">CALL</span> <span class="n">AX</span>
	<span class="kc">...</span>
	<span class="n">RET</span>
</code></pre></td></tr></table>
</div>
</div><p>进而调用 sigtrampgo。这样的处理方式是因为， sighandler 会将产生的信号交给对应的 g ，此时还无法决定究竟谁来进行处理。 因此，当信号发生时，而 sigtrampgo 会被调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// sigtrampgo is called from the signal handler function, sigtramp,
</span><span class="c1">// written in assembly code.
</span><span class="c1">// This is called by the signal handler, and the world may be stopped.
</span><span class="c1">//
</span><span class="c1">// It must be nosplit because getg() is still the G that was running
</span><span class="c1">// (if any) when the signal was delivered, but it&#39;s (usually) called
</span><span class="c1">// on the gsignal stack. Until this switches the G to gsignal, the
</span><span class="c1">// stack bounds check won&#39;t work.
</span><span class="c1">//
</span><span class="c1">//go:nosplit
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sigtrampgo</span><span class="p">(</span><span class="nx">sig</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">info</span> <span class="o">*</span><span class="nx">siginfo</span><span class="p">,</span> <span class="nx">ctx</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//sigfwdgo 用于约定该信号是否应该由 Go 进行处理， 如果不由 Go 进行处理（例如 cgo）则将其转发到 Go 代码之前设置的 handler 上。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">sigfwdgo</span><span class="p">(</span><span class="nx">sig</span><span class="p">,</span> <span class="nx">info</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sigctxt</span><span class="p">{</span><span class="nx">info</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">}</span>
	<span class="nx">g</span> <span class="o">:=</span> <span class="nf">sigFetchG</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="nf">setg</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">g</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">sig</span> <span class="o">==</span> <span class="nx">_SIGPROF</span> <span class="p">{</span>
			<span class="nf">sigprofNonGoPC</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">sigpc</span><span class="p">())</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">sig</span> <span class="o">==</span> <span class="nx">sigPreempt</span> <span class="o">&amp;&amp;</span> <span class="nx">preemptMSupported</span> <span class="o">&amp;&amp;</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">asyncpreemptoff</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// This is probably a signal from preemptM sent
</span><span class="c1"></span>			<span class="c1">// while executing Go code but received while
</span><span class="c1"></span>			<span class="c1">// executing non-Go code.
</span><span class="c1"></span>			<span class="c1">// We got past sigfwdgo, so we know that there is
</span><span class="c1"></span>			<span class="c1">// no non-Go signal handler for sigPreempt.
</span><span class="c1"></span>			<span class="c1">// The default behavior for sigPreempt is to ignore
</span><span class="c1"></span>			<span class="c1">// the signal, so badsignal will be a no-op anyway.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;darwin&#34;</span> <span class="p">{</span>
				<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pendingPreemptSignals</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">fixsigcode</span><span class="p">(</span><span class="nx">sig</span><span class="p">)</span>
		<span class="nf">badsignal</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">sig</span><span class="p">),</span> <span class="nx">c</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nf">setg</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">)</span>

	<span class="c1">// If some non-Go code called sigaltstack, adjust.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">gsignalStack</span> <span class="nx">gsignalStack</span>
	<span class="nx">setStack</span> <span class="o">:=</span> <span class="nf">adjustSignalStack</span><span class="p">(</span><span class="nx">sig</span><span class="p">,</span> <span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">gsignalStack</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">setStack</span> <span class="p">{</span>
		<span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stktopsp</span> <span class="p">=</span> <span class="nf">getcallersp</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">g</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="o">==</span> <span class="nx">stackFork</span> <span class="p">{</span>
		<span class="nf">signalDuringFork</span><span class="p">(</span><span class="nx">sig</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">c</span><span class="p">.</span><span class="nf">fixsigcode</span><span class="p">(</span><span class="nx">sig</span><span class="p">)</span>
	<span class="nf">sighandler</span><span class="p">(</span><span class="nx">sig</span><span class="p">,</span> <span class="nx">info</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">,</span> <span class="nx">g</span><span class="p">)</span>
	<span class="nf">setg</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">setStack</span> <span class="p">{</span>
		<span class="nf">restoreGsignalStack</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gsignalStack</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>sigtramp是入口，sighandler根据不同信号调用处理程序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sighandler</span><span class="p">(</span><span class="nx">sig</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">info</span> <span class="o">*</span><span class="nx">siginfo</span><span class="p">,</span> <span class="nx">ctxt</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">gp</span><span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sigctxt</span><span class="p">{</span><span class="nx">info</span><span class="p">,</span> <span class="nx">ctxt</span><span class="p">}</span>

	<span class="c1">// profile 时钟超时
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sig</span> <span class="o">==</span> <span class="nx">_SIGPROF</span> <span class="p">{</span>
		<span class="nf">sigprof</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">sigpc</span><span class="p">(),</span> <span class="nx">c</span><span class="p">.</span><span class="nf">sigsp</span><span class="p">(),</span> <span class="nx">c</span><span class="p">.</span><span class="nf">siglr</span><span class="p">(),</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">sig</span> <span class="o">==</span> <span class="nx">_SIGTRAP</span> <span class="o">&amp;&amp;</span> <span class="nx">testSigtrap</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nf">testSigtrap</span><span class="p">(</span><span class="nx">info</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="nx">sigctxt</span><span class="p">)(</span><span class="nf">noescape</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">))),</span> <span class="nx">gp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// 用户信号
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sig</span> <span class="o">==</span> <span class="nx">_SIGUSR1</span> <span class="o">&amp;&amp;</span> <span class="nx">testSigusr1</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nf">testSigusr1</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">sig</span> <span class="o">==</span> <span class="nx">sigPreempt</span> <span class="p">{</span>
		<span class="c1">// 可能是一个抢占信号
</span><span class="c1"></span>		<span class="nf">doSigPreempt</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
		<span class="c1">// 即便这是一个抢占信号，它也可能与其他信号进行混合，因此我们
</span><span class="c1"></span>		<span class="c1">// 继续进行处理。
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="nx">flags</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">_SigThrow</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">sig</span> <span class="p">&lt;</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">sigtable</span><span class="p">))</span> <span class="p">{</span>
		<span class="nx">flags</span> <span class="p">=</span> <span class="nx">sigtable</span><span class="p">[</span><span class="nx">sig</span><span class="p">].</span><span class="nx">flags</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">_SigPanic</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">throwsplit</span> <span class="p">{</span>
		<span class="c1">// 我们无法安全的 sigpanic 因为它可能造成栈的增长，因此忽略它
</span><span class="c1"></span>		<span class="nx">flags</span> <span class="p">=</span> <span class="p">(</span><span class="nx">flags</span> <span class="o">&amp;^</span> <span class="nx">_SigPanic</span><span class="p">)</span> <span class="p">|</span> <span class="nx">_SigThrow</span>
	<span class="p">}</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nf">sigcode</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">_SI_USER</span> <span class="o">&amp;&amp;</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">_SigPanic</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 产生 panic 的信号
</span><span class="c1"></span>		<span class="o">...</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">preparePanic</span><span class="p">(</span><span class="nx">sig</span><span class="p">,</span> <span class="nx">gp</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// 对用户注册的信号进行转发
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nf">sigcode</span><span class="p">()</span> <span class="o">==</span> <span class="nx">_SI_USER</span> <span class="o">||</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">_SigNotify</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nf">sigsend</span><span class="p">(</span><span class="nx">sig</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 设置为可忽略的用户信号
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nf">sigcode</span><span class="p">()</span> <span class="o">==</span> <span class="nx">_SI_USER</span> <span class="o">&amp;&amp;</span> <span class="nf">signal_ignored</span><span class="p">(</span><span class="nx">sig</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// 处理 KILL 信号
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">_SigKill</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">dieFromSignal</span><span class="p">(</span><span class="nx">sig</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 非 THROW，返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">_SigThrow</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// 处理一些直接 panic 的情况
</span><span class="c1"></span>	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意，在信号处理中，当信号为 sigPreempt 时，将触发运行时的异步抢占机制.</p>
<p>函数 sigsend 会将用户信号发送到信号队列 sig 中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">sig</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">note</span>       <span class="nx">note</span>
	<span class="nx">mask</span>       <span class="p">[(</span><span class="nx">_NSIG</span> <span class="o">+</span> <span class="mi">31</span><span class="p">)</span> <span class="o">/</span> <span class="mi">32</span><span class="p">]</span><span class="kt">uint32</span>
	<span class="nx">wanted</span>     <span class="p">[(</span><span class="nx">_NSIG</span> <span class="o">+</span> <span class="mi">31</span><span class="p">)</span> <span class="o">/</span> <span class="mi">32</span><span class="p">]</span><span class="kt">uint32</span>
	<span class="nx">ignored</span>    <span class="p">[(</span><span class="nx">_NSIG</span> <span class="o">+</span> <span class="mi">31</span><span class="p">)</span> <span class="o">/</span> <span class="mi">32</span><span class="p">]</span><span class="kt">uint32</span>
	<span class="nx">recv</span>       <span class="p">[(</span><span class="nx">_NSIG</span> <span class="o">+</span> <span class="mi">31</span><span class="p">)</span> <span class="o">/</span> <span class="mi">32</span><span class="p">]</span><span class="kt">uint32</span>
	<span class="nx">state</span>      <span class="kt">uint32</span>
	<span class="nx">delivering</span> <span class="kt">uint32</span>
	<span class="nx">inuse</span>      <span class="kt">bool</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">sigsend</span><span class="p">(</span><span class="nx">s</span> <span class="kt">uint32</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">bit</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">s</span><span class="o">&amp;</span><span class="mi">31</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">sig</span><span class="p">.</span><span class="nx">inuse</span> <span class="o">||</span> <span class="nx">s</span> <span class="o">&gt;=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">32</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="nx">sig</span><span class="p">.</span><span class="nx">wanted</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sig</span><span class="p">.</span><span class="nx">delivering</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="c1">// We are running in the signal handler; defer is not available.
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nx">w</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sig</span><span class="p">.</span><span class="nx">wanted</span><span class="p">[</span><span class="nx">s</span><span class="o">/</span><span class="mi">32</span><span class="p">]);</span> <span class="nx">w</span><span class="o">&amp;</span><span class="nx">bit</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sig</span><span class="p">.</span><span class="nx">delivering</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// Add signal to outgoing queue.
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">mask</span> <span class="o">:=</span> <span class="nx">sig</span><span class="p">.</span><span class="nx">mask</span><span class="p">[</span><span class="nx">s</span><span class="o">/</span><span class="mi">32</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">mask</span><span class="o">&amp;</span><span class="nx">bit</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sig</span><span class="p">.</span><span class="nx">delivering</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="kc">true</span> <span class="c1">// signal already in queue
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sig</span><span class="p">.</span><span class="nx">mask</span><span class="p">[</span><span class="nx">s</span><span class="o">/</span><span class="mi">32</span><span class="p">],</span> <span class="nx">mask</span><span class="p">,</span> <span class="nx">mask</span><span class="p">|</span><span class="nx">bit</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Notify receiver that queue has new bit.
</span><span class="c1"></span><span class="nx">Send</span><span class="p">:</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sig</span><span class="p">.</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;sigsend: inconsistent state&#34;</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">sigIdle</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sig</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">sigIdle</span><span class="p">,</span> <span class="nx">sigSending</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">break</span> <span class="nx">Send</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="nx">sigSending</span><span class="p">:</span>
			<span class="c1">// notification already pending
</span><span class="c1"></span>			<span class="k">break</span> <span class="nx">Send</span>
		<span class="k">case</span> <span class="nx">sigReceiving</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sig</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">sigReceiving</span><span class="p">,</span> <span class="nx">sigIdle</span><span class="p">)</span> <span class="p">{</span>
				<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sig</span><span class="p">.</span><span class="nx">note</span><span class="p">)</span>
				<span class="k">break</span> <span class="nx">Send</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sig</span><span class="p">.</span><span class="nx">delivering</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>用户信号的接收方是通过 os/signal 完成的，我们随后讨论。</p>
<h2 id="辅-m-线程">辅 M 线程<a hidden class="anchor" aria-hidden="true" href="#辅-m-线程">#</a></h2>
<p>辅 M 是一个用于服务非 Go 线程（cgo 产生的线程）回调的 M。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:yeswritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mstartm0</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 创建一个额外的 M 服务 non-Go 线程（cgo 调用中产生的线程）的回调，并且只创建一个
</span><span class="c1"></span>	<span class="c1">// windows 上也需要额外 M 来服务 syscall.NewCallback 产生的回调，见 issue #6751
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="nx">iscgo</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;windows&#34;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">cgoHasExtraM</span> <span class="p">{</span>
		<span class="nx">cgoHasExtraM</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nf">newextram</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nf">initsig</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// newextram 分配一个 m 并将其放入 extra 列表中
</span><span class="c1">// 它会被工作中的本地 m 调用，因此它能够做一些调用 schedlock 和 allocate 类似的事情。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newextram</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">extraMWaiters</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">c</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nf">oneNewExtraM</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 确保至少有一个额外的 M
</span><span class="c1"></span>		<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">lockextra</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
		<span class="nf">unlockextra</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">mp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">oneNewExtraM</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="c1">// onNewExtraM 分配一个 m 并将其放入 extra list 中
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">oneNewExtraM</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">allocm</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">malg</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">goexit</span><span class="p">)</span> <span class="o">+</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PCQuantum</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span> <span class="o">-=</span> <span class="mi">4</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">RegSize</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lr</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">))</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">syscallpc</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">stktopsp</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">gcscanvalid</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">gcscandone</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gidle</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">)</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nx">mp</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">curg</span> <span class="p">=</span> <span class="nx">gp</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">lockedInt</span><span class="o">++</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">lockedg</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">lockedm</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">goid</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">goidgen</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
	<span class="o">...</span>
	<span class="c1">// 给垃圾回收器使用
</span><span class="c1"></span>	<span class="nf">allgadd</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>

	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ngsys</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>

	<span class="c1">// 将 m 添加到 extra m 链表中
</span><span class="c1"></span>	<span class="nx">mnext</span> <span class="o">:=</span> <span class="nf">lockextra</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">schedlink</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">mnext</span><span class="p">)</span>
	<span class="nx">extraMCount</span><span class="o">++</span>
	<span class="nf">unlockextra</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="对-ossignal-包的支持">对 os/signal 包的支持<a hidden class="anchor" aria-hidden="true" href="#对-ossignal-包的支持">#</a></h2>
<h3 id="原理">原理<a hidden class="anchor" aria-hidden="true" href="#原理">#</a></h3>
<p>在初始化阶段，signal产生一个goroutine，该 goroutine 循环运行并充当处理信号的使用者。此循环将一直休眠直到得到通知。这是第一步：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201222205306.png" alt=""  />
</p>
<p>然后，当信号到达程序时，信号处理程序将其委托给称为gsignal的特殊 goroutine。此 goroutine 是使用固定的且无法增长的较大堆栈（32k，以满足不同操作系统的要求）创建的。每个线程（用 M 表示）都有一个内部gsignal goroutine 来处理信号。这是更新的图：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201222205317.png" alt=""  />
</p>
<p>gsignal 分析信号以检查其是否可处理，并唤醒睡眠的goroutine并将信号发送到队列：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201222205328.png" alt=""  />
</p>
<p>SIGBUS或SIGFPE之类的同步信号无法管理，将转换为 panic</p>
<p>然后，此循环 goroutine 可以对其进行处理。它首先查找已预订此事件的 channel，并将信号推送给他们：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201222205340.png" alt=""  />
</p>
<p>锁定或阻塞gsignal会使信号处理陷入困境。由于其固定大小，它也无法分配内存。这就是为什么在信号处理链中具有两个独立的 goroutine 的重要性：一个在信号到达时立即将它们排队，另一个在同一队列中循环处理它们。</p>
<p>现在，我们可以使用新组件来更新第一部分的插图：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201222205411.png" alt=""  />
</p>
<h3 id="源码">源码<a hidden class="anchor" aria-hidden="true" href="#源码">#</a></h3>
<p>我们已经看到了用户注册的信号会通过 sigsend 进行发送，这就是我们使用 os/signal 包的核心。</p>
<p>在使用 os/signal 后，会调用 signal.init 函数，懒惰的注册一个用户端的信号处理循环（当调用 Notify 时启动）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">watchSignalLoopOnce</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
	<span class="nx">watchSignalLoop</span>     <span class="kd">func</span><span class="p">()</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">signal_enable</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// 首次调用，进行初始化
</span><span class="c1"></span>	<span class="nx">watchSignalLoop</span> <span class="p">=</span> <span class="nx">loop</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nf">process</span><span class="p">(</span><span class="nx">syscall</span><span class="p">.</span><span class="nf">Signal</span><span class="p">(</span><span class="nf">signal_recv</span><span class="p">()))</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个 signal_enable 和 signal_recv 用于激活运行时的信号队列，并从中接受信号：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 启用运行时信号队列
</span><span class="c1">//go:linkname signal_enable os/signal.signal_enable
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">signal_enable</span><span class="p">(</span><span class="nx">s</span> <span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">sig</span><span class="p">.</span><span class="nx">inuse</span> <span class="p">{</span>
		<span class="c1">// The first call to signal_enable is for us
</span><span class="c1"></span>		<span class="c1">// to use for initialization. It does not pass
</span><span class="c1"></span>		<span class="c1">// signal information in m.
</span><span class="c1"></span>		<span class="nx">sig</span><span class="p">.</span><span class="nx">inuse</span> <span class="p">=</span> <span class="kc">true</span> <span class="c1">// enable reception of signals; cannot disable
</span><span class="c1"></span>		<span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sig</span><span class="p">.</span><span class="nx">note</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">s</span> <span class="o">&gt;=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">sig</span><span class="p">.</span><span class="nx">wanted</span><span class="p">)</span><span class="o">*</span><span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">w</span> <span class="o">:=</span> <span class="nx">sig</span><span class="p">.</span><span class="nx">wanted</span><span class="p">[</span><span class="nx">s</span><span class="o">/</span><span class="mi">32</span><span class="p">]</span>
	<span class="nx">w</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nx">s</span> <span class="o">&amp;</span> <span class="mi">31</span><span class="p">)</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sig</span><span class="p">.</span><span class="nx">wanted</span><span class="p">[</span><span class="nx">s</span><span class="o">/</span><span class="mi">32</span><span class="p">],</span> <span class="nx">w</span><span class="p">)</span>

	<span class="nx">i</span> <span class="o">:=</span> <span class="nx">sig</span><span class="p">.</span><span class="nx">ignored</span><span class="p">[</span><span class="nx">s</span><span class="o">/</span><span class="mi">32</span><span class="p">]</span>
	<span class="nx">i</span> <span class="o">&amp;^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nx">s</span> <span class="o">&amp;</span> <span class="mi">31</span><span class="p">)</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sig</span><span class="p">.</span><span class="nx">ignored</span><span class="p">[</span><span class="nx">s</span><span class="o">/</span><span class="mi">32</span><span class="p">],</span> <span class="nx">i</span><span class="p">)</span>

	<span class="nf">sigenable</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 从信号队列中接受信号
</span><span class="c1">//go:linkname signal_recv os/signal.signal_recv
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">signal_recv</span><span class="p">()</span> <span class="kt">uint32</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// Serve any signals from local copy.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span><span class="nx">_NSIG</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">sig</span><span class="p">.</span><span class="nx">recv</span><span class="p">[</span><span class="nx">i</span><span class="o">/</span><span class="mi">32</span><span class="p">]</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="nx">i</span><span class="o">&amp;</span><span class="mi">31</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">sig</span><span class="p">.</span><span class="nx">recv</span><span class="p">[</span><span class="nx">i</span><span class="o">/</span><span class="mi">32</span><span class="p">]</span> <span class="o">&amp;^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&amp;</span> <span class="mi">31</span><span class="p">)</span>
				<span class="k">return</span> <span class="nx">i</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// Wait for updates to be available from signal sender.
</span><span class="c1"></span>	<span class="nx">Receive</span><span class="p">:</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sig</span><span class="p">.</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">default</span><span class="p">:</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;signal_recv: inconsistent state&#34;</span><span class="p">)</span>
			<span class="k">case</span> <span class="nx">sigIdle</span><span class="p">:</span>
				<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sig</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">sigIdle</span><span class="p">,</span> <span class="nx">sigReceiving</span><span class="p">)</span> <span class="p">{</span>
					<span class="nf">notetsleepg</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sig</span><span class="p">.</span><span class="nx">note</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
					<span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sig</span><span class="p">.</span><span class="nx">note</span><span class="p">)</span>
					<span class="k">break</span> <span class="nx">Receive</span>
				<span class="p">}</span>
			<span class="k">case</span> <span class="nx">sigSending</span><span class="p">:</span>
				<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sig</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">sigSending</span><span class="p">,</span> <span class="nx">sigIdle</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">break</span> <span class="nx">Receive</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// Incorporate updates from sender into local copy.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">sig</span><span class="p">.</span><span class="nx">mask</span> <span class="p">{</span>
			<span class="nx">sig</span><span class="p">.</span><span class="nx">recv</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sig</span><span class="p">.</span><span class="nx">mask</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当接受到信号后，信号 sig 会被发送到用户在 Ignore/Notify/Stop 上所注册的 channel 上：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">process</span><span class="p">(</span><span class="nx">sig</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Signal</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nf">signum</span><span class="p">(</span><span class="nx">sig</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">handlers</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">handlers</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="k">for</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">h</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">handlers</span><span class="p">.</span><span class="nx">m</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">want</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 发送
</span><span class="c1"></span>			<span class="c1">// send but do not block for it
</span><span class="c1"></span>			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="nx">c</span> <span class="o">&lt;-</span> <span class="nx">sig</span><span class="p">:</span>
			<span class="k">default</span><span class="p">:</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// Stop 的处理
</span><span class="c1"></span>	<span class="c1">// Avoid the race mentioned in Stop.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">d</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">handlers</span><span class="p">.</span><span class="nx">stopping</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">h</span><span class="p">.</span><span class="nf">want</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="nx">d</span><span class="p">.</span><span class="nx">c</span> <span class="o">&lt;-</span> <span class="nx">sig</span><span class="p">:</span>
			<span class="k">default</span><span class="p">:</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>例如 signal.Notify，将信号 channel 注册到 handler 全局变量中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">handlers</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Signal</span><span class="p">]</span><span class="o">*</span><span class="nx">handler</span>
	<span class="nx">ref</span> <span class="p">[</span><span class="nx">numSig</span><span class="p">]</span><span class="kt">int64</span>
	<span class="nx">stopping</span> <span class="p">[]</span><span class="nx">stopping</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">Notify</span><span class="p">(</span><span class="nx">c</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Signal</span><span class="p">,</span> <span class="nx">sig</span> <span class="o">...</span><span class="nx">os</span><span class="p">.</span><span class="nx">Signal</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;os/signal: Notify using nil channel&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">watchSignalLoopOnce</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">watchSignalLoop</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">go</span> <span class="nf">watchSignalLoop</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">})</span>

	<span class="nx">handlers</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">handlers</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">handlers</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">c</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">handlers</span><span class="p">.</span><span class="nx">m</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">handlers</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Signal</span><span class="p">]</span><span class="o">*</span><span class="nx">handler</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">h</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">handler</span><span class="p">)</span>
		<span class="nx">handlers</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">c</span><span class="p">]</span> <span class="p">=</span> <span class="nx">h</span> <span class="c1">// 保存到 handler 中
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="nx">add</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">want</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">handlers</span><span class="p">.</span><span class="nx">ref</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nf">enableSignal</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">handlers</span><span class="p">.</span><span class="nx">ref</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">sig</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">numSig</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
			<span class="nf">add</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">s</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">sig</span> <span class="p">{</span>
			<span class="nf">add</span><span class="p">(</span><span class="nf">signum</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h2>
<p>由于调度器在 Go 程序运行时的特殊地位，以及在进行跨语言调用时需要 cgo 的支持， 运行时信号处理相对而言还是较为复杂的，需要一套完整的机制来对各种情况进行处理， 甚至对用户态代码的 os/signal 进行支持。</p>
<p>转载: <a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/signal/">6.6 信号处理机制</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go%E6%BA%90%E7%A0%81/">Go源码</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
