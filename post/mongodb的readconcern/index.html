<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>MongoDB的ReadConcern | Forz Blog</title>
<meta name="keywords" content="MongoDB" />
<meta name="description" content="综述 在读取数据的过程中我们需要关注以下两个问题 从哪里读？关注数据节点位置 什么样的数据可以读？关注数据的隔离性 第一个问题是是由 readPreference 来解決 第二个问">
<meta name="author" content="">
<link rel="canonical" href="/post/mongodb%E7%9A%84readconcern/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="MongoDB的ReadConcern" />
<meta property="og:description" content="综述 在读取数据的过程中我们需要关注以下两个问题 从哪里读？关注数据节点位置 什么样的数据可以读？关注数据的隔离性 第一个问题是是由 readPreference 来解決 第二个问" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/mongodb%E7%9A%84readconcern/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-03-26T23:53:52&#43;00:00" />
<meta property="article:modified_time" content="2020-03-26T23:53:52&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="MongoDB的ReadConcern"/>
<meta name="twitter:description" content="综述 在读取数据的过程中我们需要关注以下两个问题 从哪里读？关注数据节点位置 什么样的数据可以读？关注数据的隔离性 第一个问题是是由 readPreference 来解決 第二个问"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "MongoDB的ReadConcern",
      "item": "/post/mongodb%E7%9A%84readconcern/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MongoDB的ReadConcern",
  "name": "MongoDB的ReadConcern",
  "description": "综述 在读取数据的过程中我们需要关注以下两个问题 从哪里读？关注数据节点位置 什么样的数据可以读？关注数据的隔离性 第一个问题是是由 readPreference 来解決 第二个问",
  "keywords": [
    "MongoDB"
  ],
  "articleBody": "综述 在读取数据的过程中我们需要关注以下两个问题\n 从哪里读？关注数据节点位置 什么样的数据可以读？关注数据的隔离性  第一个问题是是由 readPreference 来解決 第二个问题则是由 readConcern 来解決\n为了避免混淆，先简单说明下二者的区别。\n readPreference 主要控制客户端 Driver 从复制集的哪个节点读取数据，这个特性可方便的实现读写分离、就近读取等策略。 readConcern 决定到某个读取数据时，能读到什么样的数据。  readPreference 什么是 readPreference readpreference 决定使用哪一个节点来满足正在发起的读请求。可选值包括\n prmary：只选择主节点 primarypreferred：优先选择主节点，如果不可用则选择从节点； secondary：只选择从节点 secondarypreferred：优先选择从节点，如果从节点不可用则选择主节点 nearest：选择最近的节点  ReadPreference 场景举例  用户下订单后马上将用户转到订单详情页–primary/primarypreferred。因为此时从节点可能还没复制到新订单. 用户查询自己下过的订单–secondary/secondarypreferred。查询历史订单对时效性通常没有太高要求. 生成报表–secondary.报表对时效性要求不高，但资源需求大，可以在从节点单独处理，避免对线上用户造成影响. 将用户上传的图片分发到全世界，让各地用户能够就近读取- nearest。每个地区的应用选择最近的节点读取数据。  Readpreference与Tag readpreference 只能控制使用一类节点。Tag 则可以将节点选择控制到一个或几个节点。考虑以下场景:\n 一个5个节点的复制集； 3个节点硬件较好，专用于服务线上客户 2个节点硬件较差，专用于生成报表；  可以使用 Tag 来达到这样的控制目的\n 为3个较好的节点打上{purpose: “online”} 为2个较差的节点打上{purpose:“analyse”} 在线应用读取时指定online，报表读取时指定analyse  Readpreference配置 通过 Mongodb 的连接串参数:\n1  mongodb://host1:27107,host2:27107,host3:27017/?replicaset=rs\u0026readpreference=secondary   通过 Mongodb 驱动程序 APl:\n1  MongoCollection.Withreadpreference(Readpreference readpref)   Mongo Shell:\n1  db.collection.Find({}).Readpref (\"secondary\")   注意事项  指定 readpreference 时也应注意高可用问题。例如将readpreference指定 prmary，则发生故障转移不存在prmary期间将没有节点可读。如果业务允许，则应选择 primarypreferred 使用 Tag 时也会遇到同样的问题，如果只有一个节点拥有一个特定 Tag，则在这个节点失效时将无节点可读。这在有时候是期望的结果，有时候不是。例如:  如果报表使用的节点失效，即使不生成报表，通常也不希望将报表负载转移到其他节点上，此时只有一个节点有报表 Tag 是合理的选择 如果线上节点失效，通常希望有替代节点，所以应该保持多个节点有同样的Tag;   Tag 有时需要与优先级、选举权综合考虑。例如做报表的节点通常不会希望它成为主节点，则优先级应为0。  readConcern 什么是 read Concern? 在 readpreference 选择了指定的节点后，read Concern 决定这个节点上的数据哪些是可读的，类似于关系数据库的隔离级别。可选值包括\n available：读取所有可用的数据; local：读取所有可用且属于当前分片的数据； majority：读取在大多数节点上提交完成的数据；事务隔离级别相当于提交读. linearizable：可线性化读取文档; snapshot：读取最近快照中的数据；  local和available 在复制集中{oalL 和 available 是没有区别的。两者的区别主要体现在分片集上。考虑以下场景\n 一个 chunk x 正在从 shard1 向 shard2 迁移 整个迁移过程中 chunk x 中的部分数据会在 shard1 和 shard2 中同时存在，但源分片 shard1 仍然是 chunk X 的负责方：  所有对 chunk x 的读写操作仍然进入 shard1 config 中记录的信息 chunk x 仍然属于 shard1   此时如果读 shard2, 则会体现出 local 和 available 的区别  local：只取应该由 shard2 负责的数据（不包括 x) available: shard2 上有什么就读什么（包括 x)    注意事项:\n 虽然看上去总是应该选择local，但毕竟对结果集进行过滤会造成额外消耗。在一些无关紧要的场景（例如统计）下，也可以考虑 available Mongodb 从主节点读取数据时默认 read Concern 是 local,从从节点读取数据时默认 readConcern是available（向前兼容原因）  majority 只读取大多数据节点上都提交了的数据。考虑如下场景:\n 集合中原有文档{x:0} 将x值更新为 1  如果在各节点上应用{readConcern: “majority”}来读取数据\nmajority的实现方式 考虑 t3 时刻的 Secondary1, 此时:\n 对于要求 majority 的读操作，它将返回 X=0 对于不要求 majoity 的读操作，它将返回 x=1  如何实现？\n节点上维护多个x版本，MVCC机制.Mongodb通过维护多个快照来链接不同的版本:\n 每个被大多数节点确认过的版本都将是一个快照 快照持续到没有人使用为止才被删除；  majority与脏读 readConcern 的初衷在于解决『脏读』的问题，比如用户从 MongoDB 的 primary 上读取了某一条数据，但这条数据并没有同步到大多数节点，然后 primary 就故障了，重新恢复后 这个primary节点会将未同步到大多数节点的数据回滚掉，导致用户读到了『脏数据』。\n当指定 readConcern 级别为 majority 时，能保证用户读到的数据『已经写入到大多数节点』，而这样的数据肯定不会发生回滚，避免了脏读的问题。\n需要注意的是，readConcern 能保证读到的数据『不会发生回滚』，但并不能保证读到的数据是最新的.\n有用户误以为，readConcern 指定为 majority 时，客户端会从大多数的节点读取数据，然后返回最新的数据。实际上并不是这样，无论何种级别的 readConcern，客户端都只会从『某一个确定的节点』（具体是哪个节点由 readPreference 决定）读取数据，该节点根据自己看到的同步状态视图，只会返回已经同步到大多数节点的数据。\nMONGODB中的回滚:\n 写操作到达大多数节点之前都是不安全的，一旦主节点崩溃，而从节还没复制到该次操作，刚才的写操作就丢失了 把一次写操作视为一个事务，从事务的角度，可以认为事务被回滚了。  所以从分布式系统的角度来看，事务的提交被提升到了分布式集群的多个节点级别的\"提交\"，而不再是单个节点上的“提交”。\n在可能发生回滚的前提下考虑脏读问题:\n 如果在一次写操作到达大多数节点前读取了这个写操作，然后因为系统故障该操作回滚了，则发生了脏读问题；  使用{readConcern:\"majority\"}可以有效避免脏读\nmajority实现安全的读写分离 考虑如下场景:\n 向主节点写入一条数据； 立即从从节点读取这条数据。  如何保证自己能够读到刚刚写入的数据？\n下述方式有可能读不到刚写入的订单:\n1 2  db.orders.insert({oid: 101, sku: \"kite\", q: 1}) db.orders.find({foid: 101}).Readpref(\"secondary\")   使用 writeConcern+readConcern majority 来解決:\n1 2  db.orders.insert({oid: 101,sku:\"kiteboar\",q: 1},{writeConcern:{w: \"majority\"}}) db.orders.find({oid: 101).readPref(\"secondary\").readConcern(\"majority\")   readConcern 实现原理 MongoDB 要支持 majority 的 readConcern 级别，必须设置replication.enableMajorityReadConcern参数，加上这个参数后，MongoDB 会起一个单独的snapshot 线程，会周期性的对当前的数据集进行 snapshot，并记录 snapshot 时最新 oplog的时间戳，得到一个映射表。\n   最新oplog时间戳 snapshot 状态     t0 snapshot0 committed   t1 snapshot1 uncommitted   t2 snapshot2 uncommitted   t3 snapshot3 uncommitted    只有确保 oplog 已经同步到大多数节点时，对应的 snapshot 才会标记为 commmited，用户读取时，从最新的 commited 状态的 snapshot 读取数据，就能保证读到的数据一定已经同步到的大多数节点。\n关键的问题就是如何确定『oplog 已经同步到大多数节点』？\nprimary 节点 secondary 节点在自身oplog发生变化时，会通过 replSetUpdatePosition 命令来将 oplog 进度立即通知给 primary，另外心跳的消息里也会包含最新 oplog 的信息；通过上述方式，primary 节点能很快知道 oplog 同步情况，知道『最新一条已经同步到大多数节点的 oplog』，并更新 snapshot 的状态。比如当t2已经写入到大多数据节点时，snapshot1、snapshot2都可以更新为 commited 状态。（不必要的 snapshot也会定期被清理掉）\nsecondary 节点 secondary 节点拉取 oplog 时，primary 节点会将『最新一条已经同步到大多数节点的 oplog』的信息返回给 secondary 节点，secondary 节点通过这个oplog时间戳来更新自身的 snapshot 状态。\nlinearizable 只读取大多数节点确认过的数据。和majority最大差别是保证绝对的操作线性顺序一在写操作自然时间后面的发生的读，一定可以读到之前的写.\n 只对读取单个文档时有效； 可能导致非常慢的读，因此总是建议配合使用maxTimeMS；  即使用了majority,在极少数情况下依然会有脏读存在:\n 初始状态,x=1更新到3个节点. 主节点没有宕机,但因为网络问题与从节点失联,其他两节点与主节点失联后会进行选举,产生新的primary. 收到x=2更新请求,新的主节点和从节点对x更新. 旧的主节点在自检过程中,且还没发现自身失联时,客户端请求,会读取到旧数据x=1.  在这种情况下,需要使用linearizable.如果设置linearizable,在读取单个文档时,数据库会检查所有节点,只有多个节点响应数据为最新值,才会返回.如果旧的主节点和其他节点失联,会在检查中发现,不会读取到旧数据x=1.\n因为linearizable的性能非常低,一般情况下用不到这个级别.\nsnapshot snapshot只在多文档事务中生效。将一个事务的readConcern设置为snapshot，将保证在事务中的读：\n 不出现脏读； 不出现不可重复读； 不出现幻读。  因为所有的读都将使用同一个快照，直到事务提交为止该快照才被释放。\n注意事项  目前 readConcern 主要用于跟 mongos 与 config server 的交互上，参考MongoDB Sharded Cluster 路由策略 使用 readConcern 需要配置replication.enableMajorityReadConcern选项 只有支持 readCommited 隔离级别的存储引擎才能支持 readConcern，比如 wiredtiger 引擎，而 mmapv1引擎则不能支持。  参考:https://mongoing.com/archives/3403\n",
  "wordCount" : "3907",
  "inLanguage": "zh-cn",
  "datePublished": "2020-03-26T23:53:52Z",
  "dateModified": "2020-03-26T23:53:52Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/mongodb%E7%9A%84readconcern/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      MongoDB的ReadConcern
    </h1>
    <div class="post-meta">March 26, 2020
</div>
  </header> 
  <div class="post-content"><h1 id="综述">综述<a hidden class="anchor" aria-hidden="true" href="#综述">#</a></h1>
<p>在读取数据的过程中我们需要关注以下两个问题</p>
<ul>
<li>从哪里读？关注数据节点位置</li>
<li>什么样的数据可以读？关注数据的隔离性</li>
</ul>
<p>第一个问题是是由 readPreference 来解決
第二个问题则是由 readConcern 来解決</p>
<p>为了避免混淆，先简单说明下二者的区别。</p>
<ul>
<li>readPreference 主要控制客户端 Driver 从复制集的哪个节点读取数据，这个特性可方便的实现读写分离、就近读取等策略。</li>
<li>readConcern 决定到某个读取数据时，能读到什么样的数据。</li>
</ul>
<h1 id="readpreference">readPreference<a hidden class="anchor" aria-hidden="true" href="#readpreference">#</a></h1>
<h2 id="什么是-readpreference">什么是 readPreference<a hidden class="anchor" aria-hidden="true" href="#什么是-readpreference">#</a></h2>
<p>readpreference 决定使用哪一个节点来满足正在发起的读请求。可选值包括</p>
<ul>
<li>prmary：只选择主节点</li>
<li>primarypreferred：优先选择主节点，如果不可用则选择从节点；</li>
<li>secondary：只选择从节点</li>
<li>secondarypreferred：优先选择从节点，如果从节点不可用则选择主节点</li>
<li>nearest：选择最近的节点</li>
</ul>
<h2 id="readpreference-场景举例">ReadPreference 场景举例<a hidden class="anchor" aria-hidden="true" href="#readpreference-场景举例">#</a></h2>
<ul>
<li>用户下订单后马上将用户转到订单详情页&ndash;primary/primarypreferred。因为此时从节点可能还没复制到新订单.</li>
<li>用户查询自己下过的订单&ndash;secondary/secondarypreferred。查询历史订单对时效性通常没有太高要求.</li>
<li>生成报表&ndash;secondary.报表对时效性要求不高，但资源需求大，可以在从节点单独处理，避免对线上用户造成影响.</li>
<li>将用户上传的图片分发到全世界，让各地用户能够就近读取- nearest。每个地区的应用选择最近的节点读取数据。</li>
</ul>
<h2 id="readpreference与tag">Readpreference与Tag<a hidden class="anchor" aria-hidden="true" href="#readpreference与tag">#</a></h2>
<p>readpreference 只能控制使用一类节点。Tag 则可以将节点选择控制到一个或几个节点。考虑以下场景:</p>
<ul>
<li>一个5个节点的复制集；</li>
<li>3个节点硬件较好，专用于服务线上客户</li>
<li>2个节点硬件较差，专用于生成报表；</li>
</ul>
<p>可以使用 Tag 来达到这样的控制目的</p>
<ul>
<li>为3个较好的节点打上{purpose: &ldquo;online&rdquo;}</li>
<li>为2个较差的节点打上{purpose:&ldquo;analyse&rdquo;}</li>
<li>在线应用读取时指定online，报表读取时指定analyse</li>
</ul>
<h2 id="readpreference配置">Readpreference配置<a hidden class="anchor" aria-hidden="true" href="#readpreference配置">#</a></h2>
<p>通过 Mongodb 的连接串参数:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="err">mongodb://host</span><span class="mi">1</span><span class="err">:</span><span class="mi">27107</span><span class="err">,host</span><span class="mi">2</span><span class="err">:</span><span class="mi">27107</span><span class="err">,host</span><span class="mi">3</span><span class="err">:</span><span class="mi">27017</span><span class="err">/?replicaset=rs&amp;readpreference=secondary</span>
</code></pre></td></tr></table>
</div>
</div><p>通过 Mongodb 驱动程序 APl:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="err">MongoCollection.Withreadpreference(Readpreference</span> <span class="err">readpref)</span>
</code></pre></td></tr></table>
</div>
</div><p>Mongo Shell:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="err">db.collection.Find(</span><span class="p">{}</span><span class="err">).Readpref</span> <span class="err">(</span><span class="s2">&#34;secondary&#34;</span><span class="err">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="注意事项">注意事项<a hidden class="anchor" aria-hidden="true" href="#注意事项">#</a></h2>
<ul>
<li>指定 readpreference 时也应注意高可用问题。例如将readpreference指定 prmary，则发生故障转移不存在prmary期间将没有节点可读。如果业务允许，则应选择 primarypreferred</li>
<li>使用 Tag 时也会遇到同样的问题，如果只有一个节点拥有一个特定 Tag，则在这个节点失效时将无节点可读。这在有时候是期望的结果，有时候不是。例如:
<ul>
<li>如果报表使用的节点失效，即使不生成报表，通常也不希望将报表负载转移到其他节点上，此时只有一个节点有报表 Tag 是合理的选择</li>
<li>如果线上节点失效，通常希望有替代节点，所以应该保持多个节点有同样的Tag;</li>
</ul>
</li>
<li>Tag 有时需要与优先级、选举权综合考虑。例如做报表的节点通常不会希望它成为主节点，则优先级应为0。</li>
</ul>
<h1 id="readconcern">readConcern<a hidden class="anchor" aria-hidden="true" href="#readconcern">#</a></h1>
<h2 id="什么是-read-concern">什么是 read Concern?<a hidden class="anchor" aria-hidden="true" href="#什么是-read-concern">#</a></h2>
<p>在 readpreference 选择了指定的节点后，read Concern 决定这个节点上的数据哪些是可读的，类似于关系数据库的隔离级别。可选值包括</p>
<ul>
<li>available：读取所有可用的数据;</li>
<li>local：读取所有可用且属于当前分片的数据；</li>
<li>majority：读取在大多数节点上提交完成的数据；事务隔离级别相当于提交读.</li>
<li>linearizable：可线性化读取文档;</li>
<li>snapshot：读取最近快照中的数据；</li>
</ul>
<h2 id="local和available">local和available<a hidden class="anchor" aria-hidden="true" href="#local和available">#</a></h2>
<p>在复制集中{oalL 和 available 是没有区别的。两者的区别主要体现在分片集上。考虑以下场景</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200327103012.png" alt=""  />
</p>
<ol>
<li>一个 chunk x 正在从 shard1 向 shard2 迁移</li>
<li>整个迁移过程中 chunk x 中的部分数据会在 shard1 和 shard2 中同时存在，但源分片 shard1 仍然是 chunk X 的负责方：
<ul>
<li>所有对 chunk x 的读写操作仍然进入 shard1</li>
<li>config 中记录的信息 chunk x 仍然属于 shard1</li>
</ul>
</li>
<li>此时如果读 shard2, 则会体现出 local 和 available 的区别
<ul>
<li>local：只取应该由 shard2 负责的数据（不包括 x)</li>
<li>available: shard2 上有什么就读什么（包括 x)</li>
</ul>
</li>
</ol>
<p>注意事项:</p>
<ul>
<li>虽然看上去总是应该选择local，但毕竟对结果集进行过滤会造成额外消耗。在一些无关紧要的场景（例如统计）下，也可以考虑 available</li>
<li>Mongodb &lt;=3.6 不支持对从节点使用{readConcern:&ldquo;local&rdquo;}</li>
<li>从主节点读取数据时默认 read Concern 是 local,从从节点读取数据时默认 readConcern是available（向前兼容原因）</li>
</ul>
<h2 id="majority">majority<a hidden class="anchor" aria-hidden="true" href="#majority">#</a></h2>
<p>只读取大多数据节点上都提交了的数据。考虑如下场景:</p>
<ul>
<li>集合中原有文档{x:0}</li>
<li>将x值更新为 1</li>
</ul>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200327104022.png" alt=""  />
</p>
<p>如果在各节点上应用{readConcern: &ldquo;majority&rdquo;}来读取数据</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200327104330.png" alt=""  />
</p>
<h3 id="majority的实现方式">majority的实现方式<a hidden class="anchor" aria-hidden="true" href="#majority的实现方式">#</a></h3>
<p>考虑 t3 时刻的 Secondary1, 此时:</p>
<ul>
<li>对于要求 majority 的读操作，它将返回 X=0</li>
<li>对于不要求 majoity 的读操作，它将返回 x=1</li>
</ul>
<p>如何实现？</p>
<p>节点上维护多个x版本，MVCC机制.Mongodb通过维护多个快照来链接不同的版本:</p>
<ul>
<li>每个被大多数节点确认过的版本都将是一个快照</li>
<li>快照持续到没有人使用为止才被删除；</li>
</ul>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200327104617.png" alt=""  />
</p>
<h3 id="majority与脏读">majority与脏读<a hidden class="anchor" aria-hidden="true" href="#majority与脏读">#</a></h3>
<p>readConcern 的初衷在于解决『脏读』的问题，比如用户从 MongoDB 的 primary 上读取了某一条数据，但这条数据并没有同步到大多数节点，然后 primary 就故障了，重新恢复后 这个primary节点会将未同步到大多数节点的数据回滚掉，导致用户读到了『脏数据』。</p>
<p>当指定 readConcern 级别为 majority 时，能保证用户读到的数据『已经写入到大多数节点』，而这样的数据肯定不会发生回滚，避免了脏读的问题。</p>
<p>需要注意的是，readConcern 能保证读到的数据『不会发生回滚』，但并不能保证读到的数据是最新的.</p>
<p>有用户误以为，readConcern 指定为 majority 时，客户端会从大多数的节点读取数据，然后返回最新的数据。实际上并不是这样，无论何种级别的 readConcern，客户端都只会从『某一个确定的节点』（具体是哪个节点由 readPreference 决定）读取数据，该节点根据自己看到的同步状态视图，只会返回已经同步到大多数节点的数据。</p>
<p>MONGODB中的回滚:</p>
<ul>
<li>写操作到达大多数节点之前都是不安全的，一旦主节点崩溃，而从节还没复制到该次操作，刚才的写操作就丢失了</li>
<li>把一次写操作视为一个事务，从事务的角度，可以认为事务被回滚了。</li>
</ul>
<p>所以从分布式系统的角度来看，事务的提交被提升到了分布式集群的多个节点级别的&quot;提交&quot;，而不再是单个节点上的“提交”。</p>
<p>在可能发生回滚的前提下考虑脏读问题:</p>
<ul>
<li>如果在一次写操作到达大多数节点前读取了这个写操作，然后因为系统故障该操作回滚了，则发生了脏读问题；</li>
</ul>
<p>使用<code>{readConcern:&quot;majority&quot;}</code>可以有效避免脏读</p>
<h3 id="majority实现安全的读写分离">majority实现安全的读写分离<a hidden class="anchor" aria-hidden="true" href="#majority实现安全的读写分离">#</a></h3>
<p>考虑如下场景:</p>
<ol>
<li>向主节点写入一条数据；</li>
<li>立即从从节点读取这条数据。</li>
</ol>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200327105504.png" alt=""  />
</p>
<p>如何保证自己能够读到刚刚写入的数据？</p>
<p>下述方式有可能读不到刚写入的订单:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="err">db.orders.insert(</span><span class="p">{</span><span class="err">oid:</span> <span class="err">101,</span> <span class="err">sku:</span> <span class="nt">&#34;kite&#34;</span><span class="p">,</span> <span class="err">q:</span> <span class="err">1</span><span class="p">}</span><span class="err">)</span>
<span class="err">db.orders.find(</span><span class="p">{</span><span class="err">foid:</span> <span class="err">101</span><span class="p">}</span><span class="err">).Readpref(</span><span class="s2">&#34;secondary&#34;</span><span class="err">)</span>
</code></pre></td></tr></table>
</div>
</div><p>使用 writeConcern+readConcern majority 来解決:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="err">db.orders.insert(</span><span class="p">{</span><span class="err">oid:</span> <span class="err">101,sku:</span><span class="nt">&#34;kiteboar&#34;</span><span class="p">,</span><span class="err">q:</span> <span class="err">1</span><span class="p">}</span><span class="err">,</span><span class="p">{</span><span class="err">writeConcern:{w:</span> <span class="nt">&#34;majority&#34;</span><span class="p">}</span><span class="err">})</span> 
<span class="err">db.orders.find(</span><span class="p">{</span><span class="err">oid:</span> <span class="err">101).readPref(</span><span class="nt">&#34;secondary&#34;</span><span class="err">).readConcern(</span><span class="s2">&#34;majority&#34;</span><span class="err">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="readconcern-实现原理">readConcern 实现原理<a hidden class="anchor" aria-hidden="true" href="#readconcern-实现原理">#</a></h3>
<p>MongoDB 要支持 majority 的 readConcern 级别，必须设置replication.enableMajorityReadConcern参数，加上这个参数后，MongoDB 会起一个单独的snapshot 线程，会周期性的对当前的数据集进行 snapshot，并记录 snapshot 时最新 oplog的时间戳，得到一个映射表。</p>
<table>
<thead>
<tr>
<th>最新oplog时间戳</th>
<th>snapshot</th>
<th>状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>t0</td>
<td>snapshot0</td>
<td>committed</td>
</tr>
<tr>
<td>t1</td>
<td>snapshot1</td>
<td>uncommitted</td>
</tr>
<tr>
<td>t2</td>
<td>snapshot2</td>
<td>uncommitted</td>
</tr>
<tr>
<td>t3</td>
<td>snapshot3</td>
<td>uncommitted</td>
</tr>
</tbody>
</table>
<p>只有确保 oplog 已经同步到大多数节点时，对应的 snapshot 才会标记为 commmited，用户读取时，从最新的 commited 状态的 snapshot 读取数据，就能保证读到的数据一定已经同步到的大多数节点。</p>
<p>关键的问题就是如何确定『oplog 已经同步到大多数节点』？</p>
<h4 id="primary-节点">primary 节点<a hidden class="anchor" aria-hidden="true" href="#primary-节点">#</a></h4>
<p>secondary 节点在自身oplog发生变化时，会通过 replSetUpdatePosition 命令来将 oplog 进度立即通知给 primary，另外心跳的消息里也会包含最新 oplog 的信息；通过上述方式，primary 节点能很快知道 oplog 同步情况，知道『最新一条已经同步到大多数节点的 oplog』，并更新 snapshot 的状态。比如当t2已经写入到大多数据节点时，snapshot1、snapshot2都可以更新为 commited 状态。（不必要的 snapshot也会定期被清理掉）</p>
<h4 id="secondary-节点">secondary 节点<a hidden class="anchor" aria-hidden="true" href="#secondary-节点">#</a></h4>
<p>secondary 节点拉取 oplog 时，primary 节点会将『最新一条已经同步到大多数节点的 oplog』的信息返回给 secondary 节点，secondary 节点通过这个oplog时间戳来更新自身的 snapshot 状态。</p>
<h2 id="linearizable">linearizable<a hidden class="anchor" aria-hidden="true" href="#linearizable">#</a></h2>
<p>只读取大多数节点确认过的数据。和majority最大差别是保证绝对的操作线性顺序一在写操作自然时间后面的发生的读，一定可以读到之前的写.</p>
<ul>
<li>只对读取单个文档时有效；</li>
<li>可能导致非常慢的读，因此总是建议配合使用maxTimeMS；</li>
</ul>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200327114700.png" alt=""  />
</p>
<p>即使用了majority,在极少数情况下依然会有脏读存在:</p>
<ol>
<li>初始状态,x=1更新到3个节点.</li>
<li>主节点没有宕机,但因为网络问题与从节点失联,其他两节点与主节点失联后会进行选举,产生新的primary.</li>
<li>收到x=2更新请求,新的主节点和从节点对x更新.</li>
<li>旧的主节点在自检过程中,且还没发现自身失联时,客户端请求,会读取到旧数据x=1.</li>
</ol>
<p>在这种情况下,需要使用linearizable.如果设置linearizable,在读取单个文档时,数据库会检查所有节点,只有多个节点响应数据为最新值,才会返回.如果旧的主节点和其他节点失联,会在检查中发现,不会读取到旧数据x=1.</p>
<p>因为linearizable的性能非常低,一般情况下用不到这个级别.</p>
<h2 id="snapshot">snapshot<a hidden class="anchor" aria-hidden="true" href="#snapshot">#</a></h2>
<p>snapshot只在多文档事务中生效。将一个事务的readConcern设置为snapshot，将保证在事务中的读：</p>
<ul>
<li>不出现脏读；</li>
<li>不出现不可重复读；</li>
<li>不出现幻读。</li>
</ul>
<p>因为所有的读都将使用同一个快照，直到事务提交为止该快照才被释放。</p>
<h1 id="注意事项-1">注意事项<a hidden class="anchor" aria-hidden="true" href="#注意事项-1">#</a></h1>
<ul>
<li>目前 readConcern 主要用于跟 mongos 与 config server 的交互上，参考MongoDB Sharded Cluster 路由策略</li>
<li>使用 readConcern 需要配置replication.enableMajorityReadConcern选项</li>
<li>只有支持 readCommited 隔离级别的存储引擎才能支持 readConcern，比如 wiredtiger 引擎，而 mmapv1引擎则不能支持。</li>
</ul>
<p>参考:<a href="https://mongoing.com/archives/3403">https://mongoing.com/archives/3403</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/mongodb/">MongoDB</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
