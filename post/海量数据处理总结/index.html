<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>海量数据处理总结 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="转载：http://blog.csdn.net/v_july_v/article/details/7382693 前言 一般而言，标题含有“秒杀" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.87.0 with theme even" />


<link rel="canonical" href="/post/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="海量数据处理总结" />
<meta property="og:description" content="转载：http://blog.csdn.net/v_july_v/article/details/7382693 前言 一般而言，标题含有“秒杀" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-25T22:44:31+00:00" />
<meta property="article:modified_time" content="2017-06-25T22:44:31+00:00" />

<meta itemprop="name" content="海量数据处理总结">
<meta itemprop="description" content="转载：http://blog.csdn.net/v_july_v/article/details/7382693 前言 一般而言，标题含有“秒杀"><meta itemprop="datePublished" content="2017-06-25T22:44:31+00:00" />
<meta itemprop="dateModified" content="2017-06-25T22:44:31+00:00" />
<meta itemprop="wordCount" content="15749">
<meta itemprop="keywords" content="量数据," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="海量数据处理总结"/>
<meta name="twitter:description" content="转载：http://blog.csdn.net/v_july_v/article/details/7382693 前言 一般而言，标题含有“秒杀"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav><li style="display:inline-block;margin-right:10px;">
  <input type="search" class="docsearch-input" placeholder="Search" />
</li>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">海量数据处理总结</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-06-25 </span>
        <div class="post-category">
            <a href="/categories/%E7%AE%97%E6%B3%95/"> 算法 </a>
            </div>
          <span class="more-meta"> 约 15749 字 </span>
          <span class="more-meta"> 预计阅读 32 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#setmapmultisetmultimap">set/map/multiset/multimap</a></li>
    <li><a href="#hash_sethash_maphash_multisethash_multimap">hash_set/hash_map/hash_multiset/hash_multimap</a></li>
    <li><a href="#rbtree-pk-hashtable">rbtree PK hashtable</a></li>
  </ul>

  <ul>
    <li><a href="#密匙一分而治之hash映射--hash_map统计--堆快速归并排序">密匙一、分而治之/Hash映射 + Hash_map统计 + 堆/快速/归并排序</a>
      <ul>
        <li><a href="#1海量日志数据提取出某日访问百度次数最多的那个ip">1、海量日志数据，提取出某日访问百度次数最多的那个IP。</a></li>
        <li><a href="#2寻找热门查询300万个查询字符串中统计最热门的10个查询">2、寻找热门查询，300万个查询字符串中统计最热门的10个查询</a></li>
        <li><a href="#3有一个1g大小的一个文件里面每一行是一个词词的大小不超过16字节内存限制大小是1m返回频数最高的100个词">3、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</a></li>
        <li><a href="#4海量数据分布在100台电脑中想个办法高效统计出这批数据的top10">4、海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。</a></li>
        <li><a href="#5有10个文件每个文件1g每个文件的每一行存放的都是用户的query每个文件的query都可能重复要求你按照query的频度排序">5、有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。</a></li>
        <li><a href="#6-给定ab两个文件各存放50亿个url每个url各占64字节内存限制是4g让你找出ab文件共同的url">6、 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</a></li>
        <li><a href="#7怎么在海量数据中找出重复次数最多的一个">7、怎么在海量数据中找出重复次数最多的一个？</a></li>
        <li><a href="#8上千万或上亿数据有重复统计其中出现次数最多的前n个数据">8、上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。</a></li>
        <li><a href="#9一个文本文件大约有一万行每行一个词要求统计出其中最频繁出现的前10个词请给出思想给出时间复杂度分析">9、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</a></li>
        <li><a href="#10-1000万字符串其中有些是重复的需要把重复的全部去掉保留没有重复的字符串请怎么设计和实现">10. 1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？</a></li>
        <li><a href="#11-一个文本文件找出前10个经常出现的词但这次文件比较长说是上亿行或十亿行总之无法一次读入内存问最优解">11. 一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。</a></li>
        <li><a href="#12-100w个数中找出最大的100个数">12. 100w个数中找出最大的100个数。</a></li>
      </ul>
    </li>
    <li><a href="#密匙二多层划分">密匙二、多层划分</a>
      <ul>
        <li><a href="#1325亿个整数中找出不重复的整数的个数内存空间不足以容纳这25亿个整数">13、2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。</a></li>
        <li><a href="#145亿个int找它们的中位数">14、5亿个int找它们的中位数。</a></li>
      </ul>
    </li>
    <li><a href="#密匙三bloom-filterbitmap">密匙三：Bloom filter/Bitmap</a>
      <ul>
        <li><a href="#bloom-filter">Bloom filter</a></li>
      </ul>
    </li>
    <li><a href="#位图法bitmap">位图法（Bitmap）</a></li>
    <li><a href="#密匙四trie树数据库倒排索引">密匙四、Trie树/数据库/倒排索引</a>
      <ul>
        <li><a href="#trie树">Trie树</a></li>
        <li><a href="#数据库索引">数据库索引</a></li>
        <li><a href="#倒排索引inverted-index">倒排索引(Inverted index)</a></li>
      </ul>
    </li>
    <li><a href="#密匙五外排序">密匙五、外排序</a></li>
    <li><a href="#密匙六分布式处理之mapreduce">密匙六、分布式处理之Mapreduce</a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#只用2gb内存在20亿个整数中找到出现次数最多的数">只用2GB内存在20亿个整数中找到出现次数最多的数</a></li>
        <li><a href="#40亿个非负整数中找到没出现的数">40亿个非负整数中找到没出现的数</a></li>
        <li><a href="#找到100亿个url中重复的url以及搜索词汇的top-k问题">找到100亿个URL中重复的URL以及搜索词汇的top K问题</a></li>
        <li><a href="#40亿个非负整数中找到出现两次的数和所有数的中位数">40亿个非负整数中找到出现两次的数和所有数的中位数</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>转载：<a href="">http://blog.csdn.net/v_july_v/article/details/7382693</a></p>
<h1 id="前言">前言</h1>
<p>一般而言，标题含有“秒杀”，“99%”，“史上最全/最强”等词汇的往往都脱不了哗众取宠之嫌，但进一步来讲，如果读者读罢此文，却无任何收获，那么，我也甘愿背负这样的罪名 :-)，同时，此文可以看做是对这篇文章：十道海量数据处理面试题与十个方法大总结的一般抽象性总结。</p>
<p>毕竟受文章和理论之限，本文将摒弃绝大部分的细节，只谈方法/模式论，且注重用最通俗最直白的语言阐述相关问题。最后，有一点必须强调的是，全文行文是基于面试题的分析基础之上的，具体实践过程中，还是得具体情况具体分析，且各个场景下需要考虑的细节也远比本文所描述的任何一种解决方法复杂得多。</p>
<p>OK，若有任何问题，欢迎随时不吝赐教。谢谢。</p>
<h1 id="何谓海量数据处理">何谓海量数据处理？</h1>
<p>所谓海量数据处理，无非就是基于海量数据上的存储、处理、操作。何谓海量，就是数据量太大，所以导致要么是无法在较短时间内迅速解决，要么是数据太大，导致无法一次性装入内存。</p>
<p>那解决办法呢?针对时间，我们可以采用巧妙的算法搭配合适的数据结构，如Bloom filter/Hash/bit-map/堆/数据库或倒排索引/trie树，针对空间，无非就一个办法：大而化小，分而治之（hash映射），你不是说规模太大嘛，那简单啊，就把规模大化为规模小的，各个击破不就完了嘛。</p>
<p>至于所谓的单机及集群问题，通俗点来讲，单机就是处理装载数据的机器有限(只要考虑cpu，内存，硬盘的数据交互)，而集群，机器有多辆，适合分布式处理，并行计算(更多考虑节点和节点间的数据交互)。</p>
<p>再者，通过本blog内的有关海量数据处理的文章：Big Data Processing，我们已经大致知道，处理海量数据问题，无非就是：</p>
<ol>
<li>分而治之/hash映射 + hash统计 + 堆/快速/归并排序；</li>
<li>双层桶划分</li>
<li>Bloom filter/Bitmap；</li>
<li>Trie树/数据库/倒排索引；</li>
<li>外排序；</li>
<li>分布式处理之Hadoop/Mapreduce。</li>
</ol>
<p>下面，本文第一部分、从set/map谈到hashtable/hash_map/hash_set，简要介绍下set/map/multiset/multimap，及hash_set/hash_map/hash_multiset/hash_multimap之区别(万丈高楼平地起，基础最重要)，而本文第二部分，则针对上述那6种方法模式结合对应的海量数据处理面试题分别具体阐述。</p>
<h1 id="第一部分从setmap谈到hashtablehash_maphash_set">第一部分、从set/map谈到hashtable/hash_map/hash_set</h1>
<p>稍后本文第二部分中将多次提到hash_map/hash_set，下面稍稍介绍下这些容器，以作为基础准备。一般来说，STL容器分两种，</p>
<ol>
<li>
<p>序列式容器(vector/list/deque/stack/queue/heap)，</p>
</li>
<li>
<p>关联式容器。关联式容器又分为set(集合)和map(映射表)两大类，以及这两大类的衍生体multiset(多键集合)和multimap(多键映射表)，这些容器均以RB-tree完成。此外，还有第3类关联式容器，如hashtable(散列表)，以及以hashtable为底层机制完成的hash_set(散列集合)/hash_map(散列映射表)/hash_multiset(散列多键集合)/hash_multimap(散列多键映射表)。也就是说，set/map/multiset/multimap都内含一个RB-tree，而hash_set/hash_map/hash_multiset/hash_multimap都内含一个hashtable。</p>
</li>
</ol>
<p>所谓关联式容器，类似关联式数据库，每笔数据或每个元素都有一个键值(key)和一个实值(value)，即所谓的Key-Value(键-值对)。当元素被插入到关联式容器中时，容器内部结构(RB-tree/hashtable)便依照其键值大小，以某种特定规则将这个元素放置于适当位置。</p>
<p>包括在非关联式数据库中，比如，在MongoDB内，文档(document)是最基本的数据组织形式，每个文档也是以Key-Value（键-值对）的方式组织起来。一个文档可以有多个Key-Value组合，每个Value可以是不同的类型，比如String、Integer、List等等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="p">{</span> <span class="s">&#34;name&#34;</span> <span class="o">:</span> <span class="s">&#34;July&#34;</span><span class="p">,</span>  
  <span class="s">&#34;sex&#34;</span> <span class="o">:</span> <span class="s">&#34;male&#34;</span><span class="p">,</span>  
    <span class="s">&#34;age&#34;</span> <span class="o">:</span> <span class="mi">23</span> <span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><h2 id="setmapmultisetmultimap">set/map/multiset/multimap</h2>
<p>set，同map一样，所有元素都会根据元素的键值自动被排序，因为set/map两者的所有各种操作，都只是转而调用RB-tree的操作行为，不过，值得注意的是，两者都不允许两个元素有相同的键值。</p>
<p>不同的是：set的元素不像map那样可以同时拥有实值(value)和键值(key)，set元素的键值就是实值，实值就是键值，而map的所有元素都是pair，同时拥有实值(value)和键值(key)，pair的第一个元素被视为键值，第二个元素被视为实值。</p>
<p>至于multiset/multimap，他们的特性及用法和set/map完全相同，唯一的差别就在于它们允许键值重复，即所有的插入操作基于RB-tree的insert_equal()而非insert_unique()。</p>
<h2 id="hash_sethash_maphash_multisethash_multimap">hash_set/hash_map/hash_multiset/hash_multimap</h2>
<p>hash_set/hash_map，两者的一切操作都是基于hashtable之上。不同的是，hash_set同set一样，同时拥有实值和键值，且实质就是键值，键值就是实值，而hash_map同map一样，每一个元素同时拥有一个实值(value)和一个键值(key)，所以其使用方式，和上面的map基本相同。但由于hash_set/hash_map都是基于hashtable之上，所以不具备自动排序功能。为什么?因为hashtable没有自动排序功能。</p>
<p>至于hash_multiset/hash_multimap的特性与上面的multiset/multimap完全相同，唯一的差别就是它们hash_multiset/hash_multimap的底层实现机制是hashtable（而multiset/multimap，上面说了，底层实现机制是RB-tree），所以它们的元素都不会被自动排序，不过也都允许键值重复。</p>
<h2 id="rbtree-pk-hashtable">rbtree PK hashtable</h2>
<p>1、hash_set在千万级数据下，insert操作优于set?</p>
<p>2、那map和hash_map的性能比较呢? 谁做过相关实验?</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/1333606713_6865.jpg" alt=""></p>
<p>3、那查询操作呢，如下段文字所述?</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/1333607153_1433.jpg" alt=""></p>
<p>或者小数据量时用map，构造快，大数据量时用hash_map?</p>
<p>当数据量基本上int型key时，hash table是rbtree的3-4倍，但hash table一般会浪费大概一半内存。</p>
<p>因为hash table所做的运算就是个%，而rbtree要比较很多，比如rbtree要看value的数据 ，每个节点要多出3个指针（或者偏移量） 如果需要其他功能，比如，统计某个范围内的key的数量，就需要加一个计数成员。</p>
<p>1s rbtree能进行大概50w+次插入，hash table大概是差不多200w次。不过很多的时候，其速度可以忍了，例如倒排索引差不多也是这个速度，而且单线程，且倒排表的拉链长度不会太大。正因为基于树的实现其实不比hashtable慢到哪里去，所以数据库的索引一般都是用的B/B+树，而且B+树还对磁盘友好(B树能有效降低它的高度，所以减少磁盘交互次数)。比如现在非常流行的NoSQL数据库，像MongoDB也是采用的B树索引。</p>
<h1 id="第二部分处理海量数据问题之六把密匙">第二部分、处理海量数据问题之六把密匙</h1>
<h2 id="密匙一分而治之hash映射--hash_map统计--堆快速归并排序">密匙一、分而治之/Hash映射 + Hash_map统计 + 堆/快速/归并排序</h2>
<h3 id="1海量日志数据提取出某日访问百度次数最多的那个ip">1、海量日志数据，提取出某日访问百度次数最多的那个IP。</h3>
<p>既然是海量数据处理，那么可想而知，给我们的数据那就一定是海量的。针对这个数据的海量，我们如何着手呢?对的，无非就是分而治之/hash映射 + hash统计 + 堆/快速/归并排序，说白了，就是先映射，而后统计，最后排序：</p>
<ol>
<li>
<p>分而治之/hash映射：针对数据太大，内存受限，只能是：把大文件化成(取模映射)小文件，即16字方针：大而化小，各个击破，缩小规模，逐个解决</p>
</li>
<li>
<p>hash_map统计：当大文件转化了小文件，那么我们便可以采用常规的hash_map(ip，value)来进行频率统计。</p>
</li>
<li>
<p>堆/快速排序：统计完了之后，便进行排序(可采取堆排序)，得到次数最多的IP。</p>
</li>
</ol>
<p>具体而论，则是： “首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如%1000，把整个大文件映射为1000个小文件，再找出每个小文件中出现频率最大的IP（可以采用hash_map对那1000个文件中的所有IP进行频率统计，然后依次找出各个文件中频率最大的那个IP）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。</p>
<p>关于本题，还有几个问题，如下：</p>
<ol>
<li>
<p>Hash取模是一种等价映射，不会存在同一个元素分散到不同小文件中的情况，即这里采用的是mod1000算法，那么相同的IP在hash取模后，只可能落在同一个文件中，不可能被分散的。因为如果两个IP相等，那么经过Hash(IP)之后的哈希值是相同的，将此哈希值取模（如模1000），必定仍然相等。</p>
</li>
<li>
<p>那到底什么是hash映射呢？简单来说，就是为了便于计算机在有限的内存中处理big数据，从而通过一种映射散列的方式让数据均匀分布在对应的内存位置(如大数据通过取余的方式映射成小树存放在内存中，或大文件映射成多个小文件)，而这个映射散列方式便是我们通常所说的hash函数，设计的好的hash函数能让数据均匀分布而减少冲突。尽管数据映射到了另外一些不同的位置，但数据还是原来的数据，只是代替和表示这些原始数据的形式发生了变化而已。</p>
</li>
</ol>
<h3 id="2寻找热门查询300万个查询字符串中统计最热门的10个查询">2、寻找热门查询，300万个查询字符串中统计最热门的10个查询</h3>
<p>原题：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p>
<p>解答：</p>
<p>由上面第1题，我们知道，数据大则划为小的，如如一亿个Ip求Top 10，可先%1000将ip分到1000个小文件中去，并保证一种ip只出现在一个文件中，再对每个小文件中的ip进行hashmap计数统计并按数量排序，最后归并或者最小堆依次处理每个小文件的top10以得到最后的结果。</p>
<p>但如果数据规模比较小，能一次性装入内存呢?比如这第2题，虽然有一千万个Query，但是由于重复度比较高，因此事实上只有300万的Query，每个Query255Byte，因此我们可以考虑把他们都放进内存中去（300万个字符串假设没有重复，都是最大长度，那么最多占用内存3M*1K/4=0.75G。所以可以将所有字符串都存放在内存中进行处理），而现在只是需要一个合适的数据结构，在这里，HashTable绝对是我们优先的选择。</p>
<p>所以我们放弃分而治之/hash映射的步骤，直接上hash统计，然后排序。So，针对此类典型的TOP K问题，采取的对策往往是：hashmap + 堆。如下所示：</p>
<ol>
<li>
<p>hash_map统计：先对这批海量数据预处理。具体方法是：维护一个Key为Query字串，Value为该Query出现次数的HashTable，即hash_map(Query，Value)，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(N)的时间复杂度内用Hash表完成了统计；</p>
</li>
<li>
<p>堆排序：第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。即借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比。所以，我们最终的时间复杂度是：O（N） + N’ * O（logK），（N为1000万，N’为300万）。</p>
</li>
</ol>
<p>维护k个元素的最小堆，即用容量为k的最小堆存储最先遍历到的k个数，并假设它们即是最大的k个数，建堆费时O（k），并调整堆(费时O（logk）)后，有k1&gt;k2&gt;…kmin（kmin设为小顶堆中最小元素）。继续遍历数列，每次遍历一个元素x，与堆顶元素比较，若x&gt;kmin，则更新堆（x入堆，用时logk），否则不更新堆。这样下来，总费时O（klogk+（n-k）logk）=O（n*logk）。此方法得益于在堆中，查找等各项操作时间复杂度均为logk。</p>
<p>当然，你也可以采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p>
<h3 id="3有一个1g大小的一个文件里面每一行是一个词词的大小不超过16字节内存限制大小是1m返回频数最高的100个词">3、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</h3>
<p>由上面那两个例题，分而治之 + hash统计 + 堆/快速排序这个套路，我们已经开始有了屡试不爽的感觉。下面，再拿几道再多多验证下。请看此第3题：又是文件很大，又是内存受限，咋办?还能怎么办呢?无非还是：</p>
<ol>
<li>
<p>分而治之/hash映射：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。</p>
</li>
<li>
<p>hash_map统计：对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。</p>
</li>
<li>
<p>堆/归并排序：取出出现频率最大的100个词（可以用含100个结点的最小堆）后，再把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并（类似于归并排序）的过程了。</p>
</li>
</ol>
<h3 id="4海量数据分布在100台电脑中想个办法高效统计出这批数据的top10">4、海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。</h3>
<p>如果每个数据元素只出现一次，而且只出现在某一台机器中，那么可以采取以下步骤统计出现次数TOP10的数据元素：</p>
<ol>
<li>
<p>堆排序：在每台电脑上求出TOP10，可以采用包含10个元素的堆完成（TOP10小，用最大堆，TOP10大，用最小堆，比如求TOP10大，我们首先取前10个元素调整成最小堆，如果发现，然后扫描后面的数据，并与堆顶元素比较，如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。最后堆中的元素就是TOP10大）。</p>
</li>
<li>
<p>求出每台电脑上的TOP10后，然后把这100台电脑上的TOP10组合起来，共1000个数据，再利用上面类似的方法求出TOP10就可以了。</p>
</li>
</ol>
<p>但如果同一个元素重复出现在不同的电脑中呢，如下例子所述：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20170613134405.png" alt=""></p>
<p>这个时候，你可以有两种方法：</p>
<ol>
<li>
<p>遍历一遍所有数据，重新hash取摸，如此使得同一个元素只出现在单独的一台电脑中，然后采用上面所说的方法，统计每台电脑中各个元素的出现次数找出TOP10，继而组合100台电脑上的TOP10，找出最终的TOP10。</p>
</li>
<li>
<p>或者，暴力求解：直接统计统计每台电脑中各个元素的出现次数，然后把同一个元素在不同机器中的出现次数相加，最终从所有数据中找出TOP10。</p>
</li>
</ol>
<h3 id="5有10个文件每个文件1g每个文件的每一行存放的都是用户的query每个文件的query都可能重复要求你按照query的频度排序">5、有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。</h3>
<p>方案1：</p>
<ol>
<li>
<p>hash映射：顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为a0,a1,..a9）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。</p>
</li>
<li>
<p>hash_map统计：找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。注：hash_map(query,query_count)是用来统计每个query的出现次数，不是存储他们的值，出现一次，则count+1。</p>
</li>
<li>
<p>堆/快速/归并排序：利用快速/堆/归并排序按照出现次数进行排序，将排序好的query和对应的query_cout输出到文件中，这样得到了10个排好序的文件（记为）。最后，对这10个文件进行归并排序（内排序与外排序相结合）。</p>
</li>
</ol>
<p>除此之外，此题还有以下两个方法：</p>
<p>方案2：一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。</p>
<p>方案3：与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。</p>
<h3 id="6-给定ab两个文件各存放50亿个url每个url各占64字节内存限制是4g让你找出ab文件共同的url">6、 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</h3>
<p>可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。</p>
<ol>
<li>
<p>分而治之/hash映射：遍历文件a，对每个url求取，然后根据所取得的值将url分别存储到1000个小文件（记为，这里漏写个了a1）中。这样每个小文件的大约为300M。遍历文件b，采取和a相同的方式将url分别存储到1000小文件中（记为）。这样处理后，所有可能相同的url都在对应的小文件（）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。</p>
</li>
<li>
<p>hash_set统计：求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</p>
</li>
</ol>
<p>OK，此第一种方法：分而治之/hash映射 + hash统计 + 堆/快速/归并排序，再看最后4道题，如下：</p>
<h3 id="7怎么在海量数据中找出重复次数最多的一个">7、怎么在海量数据中找出重复次数最多的一个？</h3>
<p>方案：先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。</p>
<h3 id="8上千万或上亿数据有重复统计其中出现次数最多的前n个数据">8、上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。</h3>
<p>方案：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后利用堆取出前N个出现次数最多的数据。</p>
<h3 id="9一个文本文件大约有一万行每行一个词要求统计出其中最频繁出现的前10个词请给出思想给出时间复杂度分析">9、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</h3>
<p>方案1：如果文件比较大，无法一次性读入内存，可以采用hash取模的方法，将大文件分解为多个小文件，对于单个小文件利用hash_map统计出每个小文件中10个最常出现的词，然后再进行归并处理，找出最终的10个最常出现的词。</p>
<p>方案2：通过hash取模将大文件分解为多个小文件后，除了可以用hash_map统计出每个小文件中10个最常出现的词，也可以用trie树统计每个词出现的次数，时间复杂度是O(n<em>le)（le表示单词的平均长度），最终同样找出出现最频繁的前10个词（可用堆来实现），时间复杂度是O(n</em>lg10)。</p>
<h3 id="10-1000万字符串其中有些是重复的需要把重复的全部去掉保留没有重复的字符串请怎么设计和实现">10. 1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？</h3>
<p>这题用trie树比较合适，hash_map也行。</p>
<h3 id="11-一个文本文件找出前10个经常出现的词但这次文件比较长说是上亿行或十亿行总之无法一次读入内存问最优解">11. 一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。</h3>
<p>方案1：首先根据用hash并求模，将文件分解为多个小文件，对于单个文件利用上题的方法求出每个文件件中10个最常出现的词。然后再进行归并处理，找出最终的10个最常出现的词。</p>
<h3 id="12-100w个数中找出最大的100个数">12. 100w个数中找出最大的100个数。</h3>
<p>方案1：采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w*100)。</p>
<p>方案2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w*100)。</p>
<p>方案3：在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)。</p>
<p>接下来，咱们来看第二种方法，双层捅划分。</p>
<h2 id="密匙二多层划分">密匙二、多层划分</h2>
<p>多层划分—-其实本质上还是分而治之的思想，重在“分”的技巧上！
　　
适用范围：第k大，中位数，不重复或重复的数字</p>
<p>基本原理及要点：因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。</p>
<p>问题实例：</p>
<h3 id="1325亿个整数中找出不重复的整数的个数内存空间不足以容纳这25亿个整数">13、2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。</h3>
<p>有点像鸽巢原理，整数个数为2^32,也就是，我们可以将这2^32个数，划分为2^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用bitmap就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。</p>
<h3 id="145亿个int找它们的中位数">14、5亿个int找它们的中位数。</h3>
<p>思路一：这个例子比上面那个更明显。首先我们将int划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。</p>
<p>实际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成2^24个区域，然后确定区域的第几大数，在将该区域分成2^20个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有2^20，就可以直接利用direct addr table进行统计了。</p>
<p>思路二@绿色夹克衫：同样需要做两遍统计，如果数据存在硬盘上，就需要读取2次。</p>
<p>方法同基数排序有些像，开一个大小为65536的Int数组，第一遍读取，统计Int32的高16位的情况，也就是0-65535，都算作0,65536 - 131071都算作1。就相当于用该数除以65536。Int32 除以 65536的结果不会超过65536种情况，因此开一个长度为65536的数组计数就可以。每读取一个数，数组中对应的计数+1，考虑有负数的情况，需要将结果加32768后，记录在相应的数组内。</p>
<p>第一遍统计之后，遍历数组，逐个累加统计，看中位数处于哪个区间，比如处于区间k，那么0- k-1的区间里数字的数量sum应该&lt;n/2（2.5亿）。而k+1 - 65535的计数和也&lt;n/2，第二遍统计同上面的方法类似，但这次只统计处于区间k的情况，也就是说(x / 65536) + 32768 = k。统计只统计低16位的情况。并且利用刚才统计的sum，比如sum = 2.49亿，那么现在就是要在低16位里面找100万个数(2.5亿-2.49亿)。这次计数之后，再统计一下，看中位数所处的区间，最后将高位和低位组合一下就是结果了。</p>
<h2 id="密匙三bloom-filterbitmap">密匙三：Bloom filter/Bitmap</h2>
<h3 id="bloom-filter">Bloom filter</h3>
<p>适用范围：可以用来实现数据字典，进行数据的判重，或者集合求交集</p>
<p>基本原理及要点：</p>
<p>对于原理来说很简单，位数组+k个独立hash函数。将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显这个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。所以一个简单的改进就是 counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。</p>
<p>还有一个比较重要的问题，如何根据输入元素个数n，确定位数组m的大小及hash函数个数。当hash函数个数k=(ln2)<em>(m/n)时错误率最小。在错误率不大于E的情况下，m至少要等于n</em>lg(1/E)才能表示任意n个元素的集合。但m还应该更大些，因为还要保证bit数组里至少一半为0，则m应该&gt;=nlg(1/E)*lge 大概就是nlg(1/E)1.44倍(lg表示以2为底的对数)。</p>
<p>举个例子我们假设错误率为0.01，则此时m应大概是n的13倍。这样k大概是8个。</p>
<p>注意这里m与n的单位不同，m是bit为单位，而n则是以元素个数为单位(准确的说是不同元素的个数)。通常单个元素的长度都是有很多bit的。所以使用bloom filter内存上通常都是节省的。</p>
<p>扩展：</p>
<p>Bloom filter将集合中的元素映射到位数组中，用k（k为哈希函数个数）个映射位是否全1表示元素在不在这个集合中。Counting bloom filter（CBF）将位数组中的每一位扩展为一个counter，从而支持了元素的删除操作。Spectral Bloom Filter（SBF）将其与集合元素的出现次数关联。SBF采用counter中的最小值来近似表示元素的出现频率。</p>
<p>可以看下上文中的第6题：</p>
<p>6、给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢？</p>
<p>根据这个问题我们来计算下内存的占用，4G=2^32大概是40亿*8大概是340亿，n=50亿，如果按出错率0.01算需要的大概是650亿个bit。现在可用的是340亿，相差并不多，这样可能会使出错率上升些。另外如果这些urlip是一一对应的，就可以转换成ip，则大大简单了。</p>
<p>同时，上文的第5题：给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。”</p>
<h2 id="位图法bitmap">位图法（Bitmap）</h2>
<p>下面关于Bitmap的应用，可以看下上文中的第13题，以及另外一道新题：</p>
<p>在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</p>
<p>方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。</p>
<p>方案2：也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。”</p>
<p>给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</p>
<p>方案1：用位图/Bitmap的方法，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。</p>
<h2 id="密匙四trie树数据库倒排索引">密匙四、Trie树/数据库/倒排索引</h2>
<h3 id="trie树">Trie树</h3>
<p>适用范围：数据量大，重复多，但是数据种类小可以放入内存</p>
<p>基本原理及要点：实现方式，节点孩子的表示方式</p>
<p>扩展：压缩实现。</p>
<p>问题实例：</p>
<p>上面的第2题：寻找热门查询：查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个，每个不超过255字节。</p>
<p>上面的第5题：有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。要你按照query的频度排序。</p>
<p>1000万字符串，其中有些是相同的(重复),需要把重复的全部去掉，保留没有重复的字符串。请问怎么设计和实现？</p>
<p>上面的第8题：一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词。其解决方法是：用trie树统计每个词出现的次数，时间复杂度是O(n*le)（le表示单词的平准长度），然后是找出出现最频繁的前10个词。</p>
<h3 id="数据库索引">数据库索引</h3>
<p>　　
适用范围：大数据量的增删改查
　　
基本原理及要点：利用数据的设计实现方法，对海量数据的增删改查进行处理。</p>
<h3 id="倒排索引inverted-index">倒排索引(Inverted index)</h3>
<p>　　
适用范围：搜索引擎，关键字查询
　　
基本原理及要点：为何叫倒排索引？一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。
　
以英文为例，下面是要被索引的文本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">T0</span> <span class="o">=</span> <span class="s">&#34;it is what it is&#34;</span>
<span class="n">T1</span> <span class="o">=</span> <span class="s">&#34;what is it&#34;</span>
<span class="n">T2</span> <span class="o">=</span> <span class="s">&#34;it is a banana&#34;</span>
<span class="err">我们就能得到下面的反向文件索引：</span>
<span class="s">&#34;a&#34;</span><span class="o">:</span>      <span class="p">{</span><span class="mi">2</span><span class="p">}</span>
<span class="s">&#34;banana&#34;</span><span class="o">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">}</span>
<span class="s">&#34;is&#34;</span><span class="o">:</span>     <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="s">&#34;it&#34;</span><span class="o">:</span>     <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="s">&#34;what&#34;</span><span class="o">:</span>   <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>检索的条件”what”,”is”和”it”将对应集合的交集。</p>
<p>　　
正向索引开发出来用来存储每个文档的单词的列表。正向索引的查询往往满足每个文档有序频繁的全文查询和每个单词在校验文档中的验证这样的查询。在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。也就是说文档指向了它包含的那些单词，而反向索引则是单词指向了包含它的文档，很容易看到这个反向的关系。
　　
扩展：</p>
<p>　　问题实例：文档检索系统，查询那些文件包含了某单词，比如常见的学术论文的关键字搜索。</p>
<h2 id="密匙五外排序">密匙五、外排序</h2>
<p>适用范围：大数据的排序，去重
　　
基本原理及要点：外排序的归并方法，置换选择败者树原理，最优归并树</p>
<p>问题实例：</p>
<p>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16个字节，内存限制大小是1M。返回频数最高的100个词。</p>
<p>这个数据具有很明显的特点，词的大小为16个字节，但是内存只有1M做hash明显不够，所以可以用来排序。内存可以当输入缓冲区使用。</p>
<h2 id="密匙六分布式处理之mapreduce">密匙六、分布式处理之Mapreduce</h2>
<p>MapReduce是一种计算模型，简单的说就是将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）。这样做的好处是可以在任务被分解后，可以通过大量机器进行并行计算，减少整个操作的时间。但如果你要我再通俗点介绍，那么，说白了，Mapreduce的原理就是一个归并排序。</p>
<p>适用范围：数据量大，但是数据种类小可以放入内存</p>
<p>基本原理及要点：将数据交给不同的机器去处理，数据划分，结果归约。</p>
<p>问题实例：</p>
<p>海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。</p>
<p>一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数的中数(median)？</p>
<h1 id="总结">总结</h1>
<p>至此，六种处理海量数据问题的模式/方法已经阐述完毕。据观察，这方面的面试题无外乎以上一种或其变形，然题目为何取为是：秒杀99%的海量数据处理面试题，而不是100%呢。OK，给读者看最后一道题，如下：</p>
<p>非常大的文件，装不进内存。每行一个int类型数据，现在要你随机取100个数。</p>
<p>我们发现上述这道题，无论是以上任何一种模式/方法都不好做，那有什么好的别的方法呢？我们可以看看：操作系统内存分页系统设计(说白了，就是映射+建索引)。</p>
<p>Windows 2000使用基于分页机制的虚拟内存。每个进程有4GB的虚拟地址空间。基于分页机制，这4GB地址空间的一些部分被映射了物理内存，一些部分映射硬盘上的交换文 件，一些部分什么也没有映射。程序中使用的都是4GB地址空间中的虚拟地址。而访问物理内存，需要使用物理地址。 关于什么是物理地址和虚拟地址，请看：</p>
<p>物理地址 (physical address): 放在寻址总线上的地址。放在寻址总线上，如果是读，电路根据这个地址每位的值就将相应地址的物理内存中的数据放到数据总线中传输。如果是写，电路根据这个 地址每位的值就将相应地址的物理内存中放入数据总线上的内容。物理内存是以字节(8位)为单位编址的。</p>
<p>虚拟地址 (virtual address): 4G虚拟地址空间中的地址，程序中使用的都是虚拟地址。 使用了分页机制之后，4G的地址空间被分成了固定大小的页，每一页或者被映射到物理内存，或者被映射到硬盘上的交换文件中，或者没有映射任何东西。对于一 般程序来说，4G的地址空间，只有一小部分映射了物理内存，大片大片的部分是没有映射任何东西。物理内存也被分页，来映射地址空间。对于32bit的 Win2k，页的大小是4K字节。CPU用来把虚拟地址转换成物理地址的信息存放在叫做页目录和页表的结构里。</p>
<p>物理内存分页，一个物理页的大小为4K字节，第0个物理页从物理地址 0x00000000 处开始。由于页的大小为4KB，就是0x1000字节，所以第1页从物理地址 0x00001000 处开始。第2页从物理地址 0x00002000 处开始。可以看到由于页的大小是4KB，所以只需要32bit的地址中高20bit来寻址物理页。</p>
<p>返回上面我们的题目：非常大的文件，装不进内存。每行一个int类型数据，现在要你随机取100个数。针对此题，我们可以借鉴上述操作系统中内存分页的设计方法，做出如下解决方案：</p>
<p>操作系统中的方法，先生成4G的地址表，在把这个表划分为小的4M的小文件做个索引，二级索引。30位前十位表示第几个4M文件，后20位表示在这个4M文件的第几个，等等，基于key value来设计存储，用key来建索引。</p>
<p>但如果现在只有10000个数，然后怎么去随机从这一万个数里面随机取100个数？请读者思考。</p>
<h1 id="补充">补充</h1>
<h3 id="只用2gb内存在20亿个整数中找到出现次数最多的数">只用2GB内存在20亿个整数中找到出现次数最多的数</h3>
<p>想要在很多整数中找到出现次数最多的数，通常的做法是使用哈希表对出现的每一个数做词频统计，哈希表的key是某一个整数，value是这个数出现的次数。就本题来说，一共有20亿个数，哪怕只是一个数出现了 20亿次，用32位的整数也可以表示其出现的次数.而不会产生溢出，所以哈希表的key需要占用4B，value也是4B。那么哈希表的一条记录(key,value)需要占用8B,当哈希表记录数为2亿个时，需要至少1.6GB的内存。</p>
<p>但如果20亿个数中不同的数超过2亿种，最极端的情况是20亿个数都不同，那么在哈希表中可能需要产生20亿条记录，这样内存会不够用，所以一次性用哈希表统计20亿个数的办法是有很大风险的。</p>
<p>解决办法是把包含20亿个数的大文件用哈希函数分成16个小文件，根据哈希函数的性质，同一种数不可能被哈希到不同的小文件上，同时每个小文件中不同的数一定不会大于2亿种，假设哈希函数足够好。然后对每一个小文件用哈希表来统计其中每种数出现的次数，这样我们就得到了 16个小文件中各自出现次数最多的数，还有各自的次数统计。接下来只要选出这16个小文件各自的第一名中谁出现的次数最多即可。把一个大的集合通过哈希函数分配到多台机器中，或者分配到多个文件里，这种技巧是处理大数据面试题时最常用的技巧之一。但是到底分配到多少台机器、分配到多少文件，在解题时一定要确定下来。可能是在与面试官沟通的过程中由面试官指定，也可能是根据具体的限制来确定，比如本题确定分成16个文件，就是根据内存限制2GB的条件来确定的。</p>
<h3 id="40亿个非负整数中找到没出现的数">40亿个非负整数中找到没出现的数</h3>
<p>题目:</p>
<p>32位无符号整数的范围是0〜4294967295,现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然有没出现过的数。可以使用最多1GB的内存，怎么找到所有没出现过的数？</p>
<p>进阶：内存限制为10MB,但是只用找到一个没出现过的数即可。</p>
<p>原问题。如果用哈希表来保存出现过的数，那么如果40亿个数都不同，则哈希表的记录数为40亿条，存一个32位整数需要4B,所以最差情况下需要40亿x4B=160亿字节，大约需要16GB的空间，这是不符合要求的。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170827-060838@2x.png" alt=""></p>
<p>总结一下进阶的解法：</p>
<ol>
<li>根据10MB的内存限制，确定统计区间的大小，就是第二次遍历时的bitArr大小。</li>
<li>利用区间计数的方式，找到那个计数不足的区间，这个区间上肯定有没出现的数。</li>
<li>对这个区间上的数做bit map映射，再遍历bit map,找到一个没出现的数即可。</li>
</ol>
<h3 id="找到100亿个url中重复的url以及搜索词汇的top-k问题">找到100亿个URL中重复的URL以及搜索词汇的top K问题</h3>
<p>题目:</p>
<p>有一个包含100亿个URL的大文件，假设每个URL占用64B,请找出其中所有重复的 URL。</p>
<p>补充:</p>
<p>某搜索公司一天的用户搜索词汇是海量的（百亿数据量），请设计一种求出每天最热top100词汇的可行办法。</p>
<p>原问题的解法使用解决大数据问题的一种常规方法：把大文件通过哈希函数分配到机器，或者通过哈希函数把大文件拆成小文件。一直进行这种划分，直到划分的结果满足资源限制的要求。首先，你要向面试官询问在资源上的限制有哪些，包括内存、计算时间等要求。在明确了限制要求之后，可以将每条URL通过哈希函数分配到若干机器或者拆分成若干小文件，这里的“若干”由具体的资源限制来计算出精确的数量。</p>
<p>例如，将100亿字节的大文件通过哈希函数分配到100台机器上，然后每一台机器分别统计分给自己的URL中是否有重复的URL,同时哈希函数的性质决定了同一条URL不可能分给不同的机器；或者在单机上将大文件通过哈希函数拆成1000个小文件，对每一个小文件再利用哈希表遍历，找出重复的URL:或者在分给机器或拆完文件之后，进行排序，排序过后再看是否有重复的URL出现。总之，牢记一点，很多大数据问题都离不开分流，要么是哈希函数把大文件的内容分配给不同的机器，要么是哈希函数把大文件拆成小文件，然后处理每一个小数量的集合。</p>
<p>补充问题最开始还是用哈希分流的思路来处理，把包含百亿数据量的词汇文件分流到不同的机器上，具体多少台机器由面试官规定或者由更多的限制来决定。对每一台机器来说，如果分到的数据量依然很大，比如，内存不够或其他问题，可以再用哈希函数把每台机器的分流文件拆成更小的文件处理。处理每一个小文件的时候，哈希表统计每种词及其词频，哈希表记录建立完成后，再遍历哈希表，遍历哈希表的过程中使用大小为100的小根堆来选出每一个小文件的top 100 (整体未排序的top 100)。每一个小文件都有自己词频的小根堆（整体未排序的top 100),将小根堆里的词按照词频排序，就得到了每个小文件的排序后top 100。然后把各个小文件排序后的top 100进行外排序或者继续利用小根堆，就可以选出每台机器上的top 100。不同机器之间的toplOO再进行外排序或者继续利用小根堆，最终求出整个百亿数据量中的top 100。对于topK的问题，除哈希函数分流和用哈希表做词频统计之外，还经常用堆结构和外排序的手段进行处理。</p>
<h3 id="40亿个非负整数中找到出现两次的数和所有数的中位数">40亿个非负整数中找到出现两次的数和所有数的中位数</h3>
<p>题目:</p>
<p>32位无符号整数的范围是0〜4294967295,现在有40亿个无符号整数，可以使用最多1GB的内存，找出所有出现了两次的数。</p>
<p>补充:</p>
<p>可以使用最多10MB的内存，怎么找到这40亿个整数的中位数？</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170827-065657@2x.png" alt="">
<img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170827-065727@2x.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2017-06-25
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E9%87%8F%E6%95%B0%E6%8D%AE/">量数据</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">红黑树详解</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E4%BB%8Eb%E6%A0%91b-%E6%A0%91b-%E6%A0%91%E8%B0%88%E5%88%B0r%E6%A0%91/">
            <span class="next-text nav-default">从B树、B&#43;树、B*树谈到R树</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
