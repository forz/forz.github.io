<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Dockerfile参考 | Forz Blog</title>
<meta name="keywords" content="Docker" />
<meta name="description" content="Dockerfile参考（Dockerfile reference） Docker可以通过读取Dockerfile中的指令自动构建镜像。 Dock">
<meta name="author" content="">
<link rel="canonical" href="/post/dockerfile%E5%8F%82%E8%80%83/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Dockerfile参考" />
<meta property="og:description" content="Dockerfile参考（Dockerfile reference） Docker可以通过读取Dockerfile中的指令自动构建镜像。 Dock" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/dockerfile%E5%8F%82%E8%80%83/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-03-03T13:25:03&#43;00:00" />
<meta property="article:modified_time" content="2021-03-03T13:25:03&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Dockerfile参考"/>
<meta name="twitter:description" content="Dockerfile参考（Dockerfile reference） Docker可以通过读取Dockerfile中的指令自动构建镜像。 Dock"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Dockerfile参考",
      "item": "/post/dockerfile%E5%8F%82%E8%80%83/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Dockerfile参考",
  "name": "Dockerfile参考",
  "description": "Dockerfile参考（Dockerfile reference） Docker可以通过读取Dockerfile中的指令自动构建镜像。 Dock",
  "keywords": [
    "Docker"
  ],
  "articleBody": "Dockerfile参考（Dockerfile reference） Docker可以通过读取Dockerfile中的指令自动构建镜像。 Dockerfile是一个文本文档，其中包含用户可以在命令行上调用以装配镜像的所有命令。 使用docker build用户可以创建一个连续执行多个命令行指令的自动构建。\n本页介绍了可以在Dockerfile中使用的命令。\n用法（Usage） docker build命令从Dockerfile和上下文构建镜像。 构建的上下文是指定位置PATH或URL处的文件集。 PATH是本地文件系统上的目录。 URL是Git存储库位置。\n上下文是递归处理的。 因此，PATH包括任何子目录，URL包括存储库及其子模块。 此示例显示了使用当前目录作为上下文的构建命令：\n1 2 3  $ docker build . Sending build context to Docker daemon 6.51 MB ...   构建由Docker守护进程（daemon）运行，而不是由CLI运行。 构建过程的第一件事是将整个上下文（递归地）发送到守护进程。 在大多数情况下，最好从空目录开始作为上下文，并将Dockerfile保存在该目录中。 仅添加构建Dockerfile所需的文件。\n警告：不要将根目录/用作PATH，因为它会导致构建将硬盘驱动器的全部内容传输到Docker守护程序。\n要在构建上下文中使用文件，Dockerfile引用指令中指定的文件，例如COPY指令。 要提高构建的性能，请通过将.dockerignore文件添加到上下文目录来排除文件和目录。\n习惯上，Dockerfile称为Dockerfile，位于上下文的根目录中。 你可以将-f标志与docker build一起使用，以指向文件系统中任何位置的Dockerfile。\n1  docker build -f /path/to/a/Dockerfile .   如果构建成功，你可以指定存储库和标记以保存新镜像：\n1  docker build -t shykes/myapp .   要在构建后将映像标记为多个存储库，请在运行build命令时添加多个-t参数：\n1  docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .   在Docker守护进程运行Dockerfile中的指令之前，它会执行Dockerfile的初步验证，如果语法不正确则返回错误：\n1 2 3  $ docker build -t test/myapp . Sending build context to Docker daemon 2.048 kB Error response from daemon: Unknown instruction: RUNCMD   Docker守护进程逐个运行Dockerfile中的指令，在必要时将每条指令的结果提交给新镜像，最后输出新镜像的ID。 Docker守护进程将自动清理你发送的上下文。\n请注意，每条指令都是独立运行的，并且会导致创建新镜像 - 因此RUN cd / tmp对下一条指令不会产生任何影响。\n只要有可能，Docker将重新使用中间镜像（缓存），以显著地加速docker build过程。 这由控制台输出中的Using cache消息指示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  $ docker build -t svendowideit/ambassador . Sending build context to Docker daemon 15.36 kB Step 1/4 : FROM alpine:3.2 --- 31f630c65071 Step 2/4 : MAINTAINER SvenDowideit@home.org.au --- Using cache --- 2a1c91448f5f Step 3/4 : RUN apk update \u0026\u0026 apk add socat \u0026\u0026 rm -r /var/cache/ --- Using cache --- 21ed6e7fbb73 Step 4/4 : CMD env | grep _TCP= | (sed 's/.*_PORT_\\([0-9]*\\)_TCP=tcp:\\/\\/\\(.*\\):\\(.*\\)/socat -t 100000000 TCP4-LISTEN:\\1,fork,reuseaddr TCP4:\\2:\\3 \\\u0026/' \u0026\u0026 echo wait) | sh --- Using cache --- 7ea8aef582cc Successfully built 7ea8aef582cc   构建缓存仅用于具有本地父链的镜像。 这意味着这些镜像是由以前的版本创建的，或者整个镜像链都用docker load装载了。如果你希望使用特定镜像的构建缓存，可以使用–cache-from选项指定它。 使用–cache-from指定的镜像不需要具有父链，可以从其他注册表中提取。\n完成构建后，你已准备好查看将存储库推送到其注册表。\n格式（Format） 这是Dockerfile的格式：\n1 2  # Comment INSTRUCTION arguments   该指令不区分大小写。 但是，惯例是让它们成为大写的，以便更容易地将它们与参数区分开来。\nDocker按顺序在Dockerfile中运行指令。 Dockerfile必须以FROM指令开头。 FROM指令指定要构建的基础镜像(Base Image)。 FROM只能在一个或多个ARG指令之前，这些指令声明在Dockerfile中的FROM行中使用的参数。\nDocker将以＃开头的行视为注释，除非该行是有效的解析器指令(parser directive)。 行中任何其他位置的＃标记都被视为参数。 允许这样的语句：\n1 2  # Comment RUN echo 'we are running some # of cool things'   注释中不支持行继续符。\n解析器指令（Parser directives） 解析器指令是可选的，并且会影响处理Dockerfile中后续行的方式。解析器指令不会向构建添加层，也不会显示为构建步骤。解析器指令以＃directive = value的形式编写为特殊类型的注释。单个指令只能使用一次。\n一旦处理了注释，空行或构建器指令，Docker就不再查找解析器指令。相反，它将格式化为解析器指令的任何内容视为注释，并且不会尝试验证它是否可能是解析器指令。因此，所有解析器指令必须位于Dockerfile的最顶层。\n解析器指令不区分大小写。但是，惯例是它们是小写的。约定还包括任何解析器指令后面的空行。解析器指令不支持行继续符。\n由于这些规则，以下示例均无效：\n由于行继续而无效：\n1 2  # direc \\ tive=value   由于出现两次无效：\n1 2 3 4  # directive=value1 # directive=value2 FROM ImageName   由于在构建器指令后出现而被视为注释：\n1 2  FROM ImageName # directive=value   由于在注释之后出现而被视为注释，而不是解析器指令：\n1 2 3  # About my dockerfile # directive=value FROM ImageName   由于未被识别，未知指令被视为注释。 此外，由于出现在注释之后，已知指令被视为注释，而不是解析器指令。\n1 2  # unknowndirective=value # knowndirective=value   解析器指令中允许使用非换行空格。 因此，以下几行都是相同的：\n1 2 3 4 5  # directive=value # directive =value #\tdirective= value # directive = value # dIrEcTiVe=value   支持以下解析器指令：\n escape syntax  语法（syntax） 1  # syntax=[remote image reference]   例如：\n1 2 3 4 5  # syntax=docker/dockerfile # syntax=docker/dockerfile:1.0 # syntax=docker.io/docker/dockerfile:1 # syntax=docker/dockerfile:1.0.0-experimental t # syntax=example.com/user/repo:tag@sha256:abcdef.   仅当使用BuildKit后端时才启用此功能。\n语法指令定义用于构建当前Dockerfile的Dockerfile构建器的位置。BuildKit后端允许无缝使用构建器的外部实现，这些构建器以Docker映像的形式分发并在容器沙箱环境中执行。\n自定义Dockerfile实现允许您执行以下操作：\n 自动获取错误修正，而无需更新守护程序 确保所有用户都使用相同的实现来构建您的Dockerfile 使用最新功能，而不更新守护程序 试用新的实验性或第三方功能  官方发布 Docker分发了映像的正式版本，这些映像可用于docker/dockerfile在Docker Hub上的存储库下构建Dockerfile 。有两个发布新图像的渠道：稳定版和实验版。\n稳定的通道遵循语义版本控制。例如：\n docker/dockerfile:1.0.0 -仅允许不可变版本 1.0.0 docker/dockerfile:1.0 -允许版本 1.0.* docker/dockerfile:1 -允许版本 1.. docker/dockerfile:latest -稳定频道上的最新版本  在发布之时，实验频道使用稳定版本中主要和次要组件的增量版本控制。例如：\n docker/dockerfile:1.0.1-experimental -仅允许不可变版本 1.0.1-experimental docker/dockerfile:1.0-experimental -之后的最新实验版本 1.0 docker/dockerfile:experimental -实验频道的最新版本  您应该选择最适合自己需求的渠道。如果您只想修正错误，则应使用docker/dockerfile:1.0。如果您想从实验功能中受益，则应使用实验频道。如果您使用的是实验性频道，则较新的版本可能无法向后兼容，因此建议使用不可变的完整版本。\n有关主版本和每夜发布的功能，请参考源存储库中的描述 。\n转义（escape） 1  # escape=\\ (backslash)   或\n1  # escape=` (backtick)   escape指令设置用于转义Dockerfile中字符的字符。如果未指定，则默认转义字符为\\。\n转义字符既用于转义行中的字符，也用于转义换行符。这允许Dockerfile指令跨越多行。请注意，无论转义解析器指令是否包含在Dockerfile中，都不会在RUN命令中执行转义，除非在行尾。\n将转义字符设置为`在Windows上特别有用，其中\\是目录路径分隔符。`与Windows PowerShell一致。\n请考虑以下示例，该示例在Windows上以非显而易见的方式失败。第二行末尾的第二个\\将被解释为换行符的转义符，而不是第一个\\的转义目标。类似地，假设它实际上作为指令处理，第三行末尾的\\将导致它被视为行继续。这个dockerfile的结果是第二行和第三行被认为是单个指令：\n1 2 3  FROM microsoft/nanoserver COPY testfile.txt c:\\\\ RUN dir c:\\   结果是：\n1 2 3 4 5 6 7  PS C:\\John docker build -t cmd . Sending build context to Docker daemon 3.072 kB Step 1/2 : FROM microsoft/nanoserver --- 22738ff49c6d Step 2/2 : COPY testfile.txt c:\\RUN dir c: GetFileAttributesEx c:RUN: The system cannot find the file specified. PS C:\\John   上面的一个解决方案是使用/作为COPY指令和dir的目标。 但是，这种语法充其量是令人困惑的，因为它对于Windows上的路径来说并不自然，并且最坏的情况是，由于Windows上的所有命令都不支持/作为路径分隔符，因此容易出错。\n通过添加转义(escape)解析器指令，以下Dockerfile按预期成功使用Windows上的自然平台语义文件路径：\n1 2 3 4 5  # escape=` FROM microsoft/nanoserver COPY testfile.txt c:\\ RUN dir c:\\   结果是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  PS C:\\John docker build -t succeeds --no-cache=true . Sending build context to Docker daemon 3.072 kB Step 1/3 : FROM microsoft/nanoserver --- 22738ff49c6d Step 2/3 : COPY testfile.txt c:\\ --- 96655de338de Removing intermediate container 4db9acbb1682 Step 3/3 : RUN dir c:\\ --- Running in a2c157f842f5 Volume in drive C has no label. Volume Serial Number is 7E6D-E0F7 Directory of c:\\ 10/05/2016 05:04 PM 1,894 License.txt 10/05/2016 02:22 PM DIR Program Files 10/05/2016 02:14 PM DIR Program Files (x86) 10/28/2016 11:18 AM 62 testfile.txt 10/28/2016 11:20 AM DIR Users 10/28/2016 11:20 AM DIR Windows 2 File(s) 1,956 bytes 4 Dir(s) 21,259,096,064 bytes free --- 01c7f3bef04f Removing intermediate container a2c157f842f5 Successfully built 01c7f3bef04f PS C:\\John   环境更换（Environment replacement） 环境变量（使用ENV语句声明）也可以在某些指令中用作Dockerfile要解释的变量。还会处理转义，以便将类似变量的语法包含在字面上。\n使用$variable_name或${variable_name}在Dockerfile中标注环境变量。它们被等效地处理，并且括号语法通常用于解决具有没有空格的变量名称的问题，例如${foo}_bar。\n ${variable_name}语法还支持以下指定的一些标准bash修饰符：  ${variable:-word}表示如果设置了variable，那么结果将是该值。如果未设置variable，那么word将是结果。 ${variable:+word}表示如果设置了variable，那么word将是结果，否则结果是空字符串。    在所有情况下，word可以是任何字符串，包括其他环境变量。\n可以通过在变量之前添加\\来进行转义：\\$foo或\\${foo}，例如，将分别转换为$foo和${foo}文字。\n示例（在＃之后显示解析的表示）：\n1 2 3 4 5  FROM busybox ENV foo /bar WORKDIR ${foo} # WORKDIR /bar ADD . $foo # ADD . /bar COPY \\$foo /quux # COPY $foo /quux   Dockerfile中的以下指令列表支持环境变量：\n ADD COPY ENV EXPOSE FROM LABEL STOPSIGNAL USER VOLUME WORKDIR  以及：\n ONBUILD（当与上面支持的指令之一结合使用时）  注意：在1.4之前，ONBUILD指令不支持环境变量，即使与上面列出的任何指令结合使用也是如此。\n环境变量替换将在整个指令中对每个变量使用相同的值。 换句话说，在这个例子中：\n1 2 3  ENV abc=hello ENV abc=bye def=$abc ENV ghi=$abc   将导致def具有hello值，而不是bye。但是，ghi将具有bye值，因为它不是将abc设置为bye的相同指令的一部分。\n.dockerignore文件 在docker CLI将上下文发送到docker守护进程之前，它会在上下文的根目录中查找名为.dockerignore的文件。如果此文件存在，CLI将修改上下文以排除与其中的模式匹配的文件和目录。这有助于避免不必要地将大型或敏感文件和目录发送到守护进程，并可能使用ADD或COPY将它们添加到镜像。\nCLI将.dockerignore文件解释为新行分隔的模式列表，类似于Unix shell的文件globs。出于匹配的目的，上下文的根被认为是工作目录和根目录。例如，模式 /foo/bar和foo/bar都会在PATH的foo子目录中或位于URL的git存储库的根目录中排除名为bar的文件或目录。两者都不包括任何其他内容。\n如果.dockerignore文件中的一行的第1列以＃开头，则此行被视为注释，并在CLI解释之前被忽略。\n这是一个示例.dockerignore文件：\n1 2 3 4 5  # comment*/temp**/*/temp*temp?  此文件导致以下构建行为：\n   规则 行为     # 注释 忽略   /temp 在根的任何直接子目录中排除名称以temp开头的文件和目录。 例如，排除普通文件/somedir/temporary.txt，目录/somedir/temp也是如此。   //temp* 从根目录下两级的任何子目录中排除以temp开头的文件和目录。 例如，排除了/somedir/subdir/temporary.txt。   temp? 排除根目录中的文件和目录，其名称是temp的单字符扩展。 例如，排除/tempa和/tempb。    匹配是使用Go的filepath.Match规则完成的。 预处理步骤使用Go的filepath.Clean删除前导和尾随空格并消除. 和..元素。 预处理后为空行将被忽略。\n除了Go的filepath.Match规则，Docker还支持一个特殊的通配符字符串**，它匹配任意数量的目录（包括零）。 例如，**/*.go将排除在所有目录中找到的以.go结尾的所有文件，包括构建上下文的根目录。\n!（感叹号）开头的行可用于排除例外情况。 以下是使用此机制的示例.dockerignore文件：\n1 2  *.md!README.md  除README.md之外的所有markdown文件都将从上下文中排除。\n!例外规则的位置会影响行为：与特定文件匹配的.dockerignore的最后一行确定是包含还是排除。 请考虑以下示例：\n1 2 3  *.md!README*.mdREADME-secret.md  除了README-secret.md以外的README文件，上下文中不包含markdown文件。\n现在考虑这个例子：\n1 2 3  *.mdREADME-secret.md!README*.md  包含所有README文件。 中间行没有效果，因为!README*.md匹配README-secret.md并且是最后一个。\n你甚至可以使用.dockerignore文件来排除Dockerfile和.dockerignore文件。 这些文件仍然发送到守护程序，因为它需要它们来完成它的工作。 但ADD和COPY指令不会将它们复制到镜像中。\n最后，你可能希望指定要包含在上下文中的文件，而不是要排除的文件。 要实现此目的，请将*指定为第一个模式，然后指定一个或多个模式! 例外模式。\n注意：由于历史原因，模式. 被忽略了。\nFORM 指定基础镜像 1  FROM image [AS name]   或\n1  FROM image[:tag] [AS name]   或\n1  FROM image[@digest] [AS name]   FROM指令初始化新的构建阶段并为后续指令设置基础镜像。因此，有效的Dockerfile必须以FROM指令开头。镜像可以是任何有效镜像 - 通过从公共存储库中提取镜像（pulling an image）来启动它尤其容易。\n  ARG是Dockerfile中唯一可以在FROM之前的指令。请参阅了解ARG和FROM如何交互。\n  FROM可以在单个Dockerfile中多次出现以创建多个镜像，或者使用一个构建阶段作为另一个构建阶段的依赖项。只需在每个新的FROM指令之前记下提交输出的最后一个图像ID。每个FROM指令清除先前指令创建的任何状态。\n  通过将AS name添加到FROM指令，可以将可选的名称赋予新的构建阶段。该名称可以在后续的FROM和COPY –from=指令中使用，以引用此阶段构建的镜像。\n  tag（标记）或digest（摘要）值是可选的。如果省略其中任何一个，则构建器默认采用latest（最新）标记。如果找不到tag值，构建器将返回错误。\n  了解ARG和FROM如何互动 FROM指令支持在第一个FROM之前发生的任何ARG指令声明的变量。\n1 2 3 4 5 6  ARG CODE_VERSION=latest FROM base:${CODE_VERSION} CMD /code/run-app FROM extras:${CODE_VERSION} CMD /code/run-extras   在FROM之前声明的ARG在构建阶段之外，因此在FROM之后的任何指令中都不能使用它。 要使用在第一个FROM之前声明的ARG的默认值，请在构建阶段内使用没有值的ARG指令：\n1 2 3 4  ARG VERSION=latest FROM busybox:$VERSION ARG VERSION RUN echo $VERSION  image_version   RUN 执行命令 RUN有两种形式：\n RUN  (shell形式，运行在shell的命令, 在Linux上默认为/bin/sh -c或在Windows上为cmd /S /C) RUN [\"executable\", \"param1\", \"param2\"] (exec执行程序形式)  RUN指令将在当前镜像之上的新层中执行任何命令并提交结果。 生成的已提交镜像将用于Dockerfile中的下一步。\n分层的RUN指令和生成提交符合Docker的核心概念，其中提交很便宜，并且可以从镜像历史中的任何点创建容器，就像源代码控制一样。\nexec（执行程序）形式可以避免shell字符串重写，并使用不包含指定shell可执行文件的基础镜像来运行RUN命令。\n可以使用SHELL命令更改shell形式的默认shell。\n在shell形式中，你可以使用\\（反斜杠）将单个RUN指令继续到下一行。 例如，考虑以下两行：\n1 2  RUN /bin/bash -c 'source $HOME/.bashrc; \\echo $HOME'   它们一起相当于这一行：\n1  RUN /bin/bash -c 'source $HOME/.bashrc; echo $HOME'   注意：要使用除“/bin/sh”之外的其他shell，请使用传入所需shell的exec形式。例如，RUN [\"/bin/bash\", \"-c\", \"echo hello\"]\n注意：exec形式被解析为JSON数组，这意味着你必须使用双引号（\"）来围绕单词而不是单引号（’）。\n注意：与shell形式不同，exec形式不会调用命令shell。这意味着不会发生正常的shell处理。例如，RUN [ \"echo\", \"$HOME\" ]不会对$HOME执行变量替换。如果你想要shell处理，那么要么使用shell形式，要么直接执行shell，例如：RUN [ \"sh\", \"-c\", \"echo $HOME\" ]。当使用exec形式并直接执行shell时，就像shell形式的情况一样，它是执行环境变量扩展的shell，而不是docker。\n注意：在JSON表单中，必须转义反斜杠。这在反斜杠是路径分隔符的Windows上尤为重要。由于不是有效的JSON，以下行将被视为shell表单，并以意外方式失败：RUN [\"c:\\windows\\system32\\tasklist.exe\"]。此示例的正确语法是：RUN [\"c:\\\\windows\\\\system32\\\\tasklist.exe\"]\nRUN指令的缓存在下一次​​构建期间不会自动失效。像RUN apt-get dist-upgrade -y这样的指令的缓存将在下一次构建期间重用。可以使用--no-cache标志使RUN指令的缓存无效，例如docker build --no-cache。\n有关详细信息，请参阅Dockerfile最佳实践指南。\nADD指令可以使RUN指令的缓存无效。请参阅下文了解详情。\nCMD 设置默认命令 CMD指令有三种形式：\n CMD [\"executable\",\"param1\",\"param2\"] (exec形式，这是首选形式) CMD [\"param1\",\"param2\"] (作为ENTRYPOINT的默认参数) CMD command param1 param2 (shell形式)  Dockerfile中只能有一条CMD指令。如果列出多个CMD，则只有最后一个CMD才会生效。\nCMD的主要目的是为正在执行的容器提供默认命令。这些默认命令可以包含可执行文件，也可以省略可执行文件，在这种情况下，你还必须指定ENTRYPOINT指令。\n注意：如果使用CMD为ENTRYPOINT指令提供默认参数，则应使用JSON数组格式指定CMD和ENTRYPOINT指令。\n注意：exec形式解析为JSON数组，这意味着你必须使用双引号（\"）来围绕单词而不是单引号（’）。\n注意：与shell形式不同，exec形式不会调用命令shell。这意味着不会发生正常的shell处理。例如，RUN [ \"echo\", \"$HOME\" ]不会对$HOME执行变量替换。如果你想要shell处理，那么要么使用shell形式，要么直接执行shell，例如：RUN [ \"sh\", \"-c\", \"echo $HOME\" ]。当使用exec形式并直接执行shell时，就像shell形式的情况一样，它是执行环境变量扩展的shell，而不是docker。\n在shell或exec格式中使用时，CMD指令设置运行镜像时要执行的命令。\n如果你使用CMD的shell形式，那么将在/bin/sh -c中执行：\n1 2  FROM ubuntu CMD echo \"This is a test.\" | wc -   如果要在没有shell的情况下运行，则必须将该命令表示为JSON数组，并提供可执行文件的完整路径。 此数组形式是CMD的首选格式。 任何其他参数必须在数组中单独表示为字符串：\n1 2  FROM ubuntu CMD [\"/usr/bin/wc\",\"--help\"]   如果你希望容器每次都运行相同的可执行文件，那么你应该考虑将ENTRYPOINT与CMD结合使用。 请参阅ENTRYPOINT。\n如果用户指定了docker run的参数，那么它们将覆盖CMD中指定的默认命令。\n注意：不要将RUN与CMD混淆。 RUN实际上运行一个命令并提交结果; CMD在构建时不执行任何操作，但指定了镜像的预期命令。\nLABEL 设置标签 1  LABEL key=value key=value key=value ...   LABEL指令将元数据添加到镜像。 LABEL是键值对。 要在LABEL值中包含空格，请使用引号和反斜杠，就像在命令行解析中一样。 一些用法示例：\n1 2 3 4 5  LABEL \"com.example.vendor\"=\"ACME Incorporated\" LABEL com.example.label-with-value=\"foo\" LABEL version=\"1.0\" LABEL description=\"This text illustrates \\that label-values can span multiple lines.\"   镜像可以有多个标签。 你可以在一行中指定多个标签。 在Docker 1.10之前，这减小了最终镜像的大小，但现在不再是这种情况了。 你仍然可以选择在单个指令中指定多个标签，方法有以下两种：\n1  LABEL multi.label1=\"value1\" multi.label2=\"value2\" other=\"value3\"   1 2 3  LABEL multi.label1=\"value1\" \\ multi.label2=\"value2\" \\ other=\"value3\"   基础或父镜像中包含的标签（FROM行中的镜像）由你的镜像继承。 如果标签已存在但具有不同的值，则最近适用的值将覆盖任何先前设置的值。\n要查看镜像的标签，请使用docker inspect命令。\n1 2 3 4 5 6 7 8 9  \"Labels\": { \"com.example.vendor\": \"ACME Incorporated\" \"com.example.label-with-value\": \"foo\", \"version\": \"1.0\", \"description\": \"This text illustrates that label-values can span multiple lines.\", \"multi.label1\": \"value1\", \"multi.label2\": \"value2\", \"other\": \"value3\" },   MAINTAINER 设置作者(deprecated已弃用) 1  MAINTAINER name   MAINTAINER指令设置生成镜像的Author（作者）字段。 LABEL指令是一个更加灵活的版本，你应该使用它，因为它可以设置你需要的任何元数据，并且可以轻松查看，例如使用docker inspect。 要设置与MAINTAINER字段对应的标签，你可以使用：\n1  LABEL maintainer=\"SvenDowideit@home.org.au\"   然后，这将通过docker inspect与其他标签一起显示。\nEXPOSE 声明端口 1  EXPOSE port [port/protocol...]   EXPOSE指令通知Docker容器在运行时侦听指定的网络端口。 你可以指定端口是侦听TCP还是UDP，如果未指定协议，则默认为TCP。\nEXPOSE指令实际上不发布端口。 它作为构建镜像的人和运行容器的人之间的一种文档，用于计划要发布的端口。 要在运行容器时实际发布端口，请在docker run上使用-p标志发布和映射一个或多个端口，或使用-P标志发布所有公开的端口并将它们映射到高阶(high-order)端口。\n默认情况下，EXPOSE假定为TCP。 你还可以指定UDP：\n1  EXPOSE 80/udp   要同时公开TCP和UDP，请包含两行：\n1 2  EXPOSE 80/tcp EXPOSE 80/udp   在这种情况下，如果将-P与docker run一起使用，则端口将针对TCP公开一次，针对UDP公开一次。 请记住，-P在主机上使用短暂的高阶主机端口，因此TCP和UDP的端口不同。\n无论EXPOSE设置如何，你都可以使用-p标志在运行时覆盖它们。 例如\n1  docker run -p 80:80/tcp -p 80:80/udp   要在主机系统上设置端口重定向，请参阅使用-P标志。 docker network命令支持创建用于容器之间通信的网络，而无需公开或发布特定端口，因为连接到网络的容器可以通过任何端口相互通信。 有关详细信息，请参阅此功能的概述）。\nENV 设置环境变量 1 2  ENV key value ENV key=value ...   ENV指令将环境变量设置为值。 此值将存在于构建阶段中所有后续指令的环境中，并且也可以在许多时候内部替换。\nENV指令有两种形式。\n第一种形式ENV  ，将单个变量设置为一个值。 第一个空格后面的整个字符串将被视为 - 包括空格字符。 该值将针对其他环境变量进行解释，因此如果未对其进行转义，则将删除引号字符。\n第二种形式ENV = ...允许一次设置多个变量。 请注意，第二种形式在语法中使用等号(=)，而第一种形式则不然。 与命令行解析一样，引号和反斜杠可用于在值内包含空格。\n例如：\n1 2  ENV myName=\"John Doe\" myDog=Rex\\ The\\ Dog \\ myCat=fluffy   和\n1 2 3  ENV myName John Doe ENV myDog Rex The Dog ENV myCat fluffy   将在最终镜像中产生相同的净结果。\n当从生成的镜像运行容器时，使用ENV设置的环境变量将保持不变。 你可以使用docker inspect查看值，并使用docker run --env =更改它们。\n注意：环境变量持久性可能会导致意外的副作用。 例如，设置ENV DEBIAN_FRONTEND noninteractive可能会使基于Debian的镜像上的apt-get用户感到困惑。 要为单个命令设置值，请使用RUN = 。\nADD 添加文件 ADD有两种形式：\n ADD [--chown=:] ...  ADD [--chown=:] [\"\",... \"\"] （这种形式要求包含空格的路径）  注意：–chown功能仅在用于构建Linux容器的Dockerfiles上受支持，并且不适用于Windows容器。由于用户和组所有权概念不能在Linux和Windows之间进行转换，因此使用/etc/passwd和/etc/group将用户名和组名转换为ID会限制此功能仅适用于基于Linux OS的容器。\nADD指令从复制新文件、目录或远程文件URL，并将它们添加到镜像的文件系统路径中。\n可以指定多个资源，但如果它们是文件或目录，则它们的路径将被解释为相对于构建上下文的源。\n每个可能包含通配符，匹配将使用Go的filepath.Match规则完成。 例如：\n1 2  ADD hom* /mydir/ # adds all files starting with \"hom\" ADD hom?.txt /mydir/ # ? is replaced with any single character, e.g., \"home.txt\"   是绝对路径，或相对于WORKDIR的路径，源将在目标容器中复制到该路径中。\n1 2  ADD test relativeDir/ # adds \"test\" to `WORKDIR`/relativeDir/ ADD test /absoluteDir/ # adds \"test\" to /absoluteDir/   添加包含特殊字符（例如[和]）的文件或目录时，需要按照Golang规则转义这些路径，以防止它们被视为匹配模式。 例如，要添加名为arr[0].txt的文件，请使用以下命令：\n1  ADD arr[[]0].txt /mydir/ # copy a file named \"arr[0].txt\" to /mydir/   除非可选的--chown标志指定给定用户名、组名或UID/GID组合以请求添加内容的特定所有权，否则将使用UID和GID为0创建所有新文件和目录。 --chown标志的格式允许用户名和组名字符串或任意组合的直接整数UID和GID。 提供没有组名的用户名或没有GID的UID将使用与GID相同的数字UID。 如果提供了用户名或组名，则容器的根文件系统/etc/passwd和/etc/group文件将分别用于执行从名称到整数UID或GID的转换。 以下示例显示了–chown标志的有效定义：\n1 2 3 4  ADD --chown=55:mygroup files*/somedir/ ADD --chown=bin files* /somedir/ ADD --chown=1 files*/somedir/ ADD --chown=10:11 files* /somedir/   如果容器根文件系统不包含/etc/passwd或/etc/group文件，并且在–chown标志中使用了用户名或组名，则构建将在ADD操作上失败。使用数字ID不需要查找，也不依赖于容器根文件系统内容。\n在是远程文件URL的情况下，目标将具有600的权限。如果正在检索的远程文件具有HTTP Last-Modified头，则该头的时间戳将用于设置目标上的mtime。文件。但是，与ADD期间处理的任何其他文件一样，mtime将不包含在确定文件是否已更改且应更新缓存中。\n注意：如果通过将Dockerfile传递给STDIN（docker build - ）来构建，则没有构建上下文，因此Dockerfile只能包含基于URL的ADD指令。你还可以通过STDIN传递压缩存档：（docker build - ），Dockerfile在存档根目录下，存档的其余部分将用作构建的上下文。\n注意：如果你的URL文件使用身份验证进行保护，则需要使用RUN wget，RUN curl或使用容器内的其他工具，因为ADD指令不支持身份验证。\n注意：如果的内容已更改，则第一个遇到的ADD指令将使来自Dockerfile的所有后续指令的缓存无效。这包括使RUN指令的缓存无效。有关详细信息，请参阅Dockerfile最佳实践指南。\nADD遵守以下规则：\n  路径必须位于构建的上下文中；你不能ADD ../something/something，因为docker构建的第一步是将上下文目录（和子目录）发送到docker守护进程。\n  如果是URL且不以尾部斜杠结尾，则从URL下载文件并将其复制到。\n  如果是URL并且以尾部斜杠结尾，则从URL推断文件名，并将文件下载到/。例如，ADD  /将创建文件/foobar。 URL必须具有有意义的路径，以便在这种情况下可以发现适当的文件名（http://example.com将不起作用）。\n  如果是目录，则复制目录的全部内容，包括文件系统元数据。 注意：不复制目录本身，只复制其内容。\n  如果是可识别的压缩格式（identity、gzip、bzip2或xz）的本地tar存档，则将其解压缩为目录。远程URL中的资源不解压缩。复制或解压缩目录时，它与tar -x具有相同的行为，结果是：\n 无论在目的地路径上存在什么， 源目录树的内容，在逐个文件的基础上解决有利于“2.”的冲突。 注意：文件是否被识别为可识别的压缩格式仅基于文件的内容而不是文件的名称来完成。例如，如果空文件恰好以.tar.gz结尾，则不会将其识别为压缩文件，也不会生成任何类型的解压缩错误消息，而是将文件简单地复制到目标。    如果是任何其他类型的文件，则将其与元数据一起单独复制。在这种情况下，如果以尾部斜杠/结束，则将其视为目录，的内容将写入/base()。\n  如果直接或由于使用通配符指定了多个资源，则必须是目录，并且必须以斜杠/结尾。\n  如果不以尾部斜杠结束，则它将被视为常规文件，的内容将写入。\n  如果不存在，则会在其路径中创建所有缺少的目录。\n  COPY 复制文件（ADD的简化版，能用COPY就不用ADD） COPY有两种形式：\n COPY [--chown=:] ...  COPY [--chown=:] [\"\",... \"\"]（这种形式要求包含空格的路径）  注意：--chown功能仅在用于构建Linux容器的Dockerfiles上受支持，并且不适用于Windows容器。 由于用户和组所有权概念不能在Linux和Windows之间进行转换，因此使用/etc/passwd和/etc/group将用户名和组名转换为ID会限制此功能仅适用于基于Linux OS的容器。\nCOPY指令从复制新文件或目录，并将它们添加到容器的文件系统的路径中。\n可以指定多个资源，但文件和目录的路径将被解释为相对于构建上下文的源。\n每个可能包含通配符，匹配将使用Go的filepath.Match规则完成。 例如：\nCOPY hom* /mydir/ # adds all files starting with “hom” COPY hom?.txt /mydir/ # ? is replaced with any single character, e.g., “home.txt” 1 2 是绝对路径，或相对于WORKDIR的路径，源将在目标容器中复制到该路径中。\nCOPY test relativeDir/ # adds “test” to WORKDIR/relativeDir/ COPY test /absoluteDir/ # adds “test” to /absoluteDir/ 1 2 添加包含特殊字符（例如[和]）的文件或目录时，需要按照Golang规则转义这些路径，以防止它们被视为匹配模式。 例如，要添加名为arr[0].txt的文件，请使用以下命令：\nCOPY arr[[]0].txt /mydir/ # copy a file named “arr[0].txt” to /mydir/ 1 除非可选的–chown标志指定给定用户名、组名或UID/GID组合以请求添加内容的特定所有权，否则将使用UID和GID为0创建所有新文件和目录。 –chown标志的格式允许用户名和组名字符串或任意组合的直接整数UID和GID。 提供没有组名的用户名或没有GID的UID将使用与GID相同的数字UID。 如果提供了用户名或组名，则容器的根文件系统/etc/passwd和/etc/group文件将分别用于执行从名称到整数UID或GID的转换。 以下示例显示了–chown标志的有效定义：\nCOPY –chown=55:mygroup files*/somedir/ COPY –chown=bin files* /somedir/ COPY –chown=1 files*/somedir/ COPY –chown=10:11 files* /somedir/ 1 2 3 4 如果容器根文件系统不包含/etc/passwd或/etc/group文件，并且在–chown标志中使用了用户名或组名，则构建将在COPY操作上失败。使用数字ID不需要查找，也不依赖于容器根文件系统内容。\n注意：如果通过将Dockerfile传递给STDIN（docker build - COPY接受一个可选标志–from=，可用于将源位置设置为先前的构建阶段（使用FROM .. AS 创建），而不是由用户发送的构建上下文。该标志还接受使用FROM指令启动的所有先前构建阶段分配的数字索引。如果找不到具有指定名称的构建阶段，则尝试使用具有相同名称的镜像。\nCOPY遵守以下规则：\n路径必须位于构建的上下文中；你不能COPY ../something/something，因为docker build的第一步是将上下文目录（和子目录）发送到docker守护进程。\n如果是目录，则复制目录的全部内容，包括文件系统元数据。\n注意：不复制目录本身，只复制其内容。\n如果是任何其他类型的文件，则将其与元数据一起单独复制。在这种情况下，如果以尾部斜杠/结束，则将其视为目录，的内容将写入/base()。\n如果直接或由于使用通配符指定了多个资源，则必须是目录，并且必须以斜杠/结尾。\n如果不以尾部斜杠结束，则它将被视为常规文件，的内容将写入。\n如果不存在，则会在其路径中创建所有缺少的目录。\nENTRYPOINT 配置容器入口点 ENTRYPOINT有两种形式:\nENTRYPOINT [“executable”, “param1”, “param2”] (exec形式, 首选) ENTRYPOINT command param1 param2 (shell形式) ENTRYPOINT允许你配置将作为可执行文件运行的容器。\n例如，以下将使用其默认内容启动nginx，侦听端口80：\ndocker run -i -t –rm -p 80:80 nginx 1 docker run 的命令行参数将在exec中的所有元素形成ENTRYPOINT后附加，并将覆盖使用CMD指定的所有元素。这允许将参数传递给入口点，即docker run -d将-d参数传递给入口点。你可以使用docker run –entrypoint标志覆盖ENTRYPOINT指令。\nshell形式阻止使用任何CMD或run命令行参数，但缺点是ENTRYPOINT将作为/bin/sh -c的子命令启动，它不传递信号。这意味着可执行程序不是容器的PID 1 - 并且不会接收Unix信号 - 因此你的可执行程序将不会从docker stop 接收SIGTERM。\n只有Dockerfile中的最后一个ENTRYPOINT指令才会生效。\nExec形式ENTRYPOINT示例 你可以使用ENTRYPOINT的exec形式设置相当稳定的默认命令和参数，然后使用任一形式的CMD来设置更可能更改的其他默认值。\nFROM ubuntu ENTRYPOINT [“top”, “-b”] CMD [\"-c\"] 1 2 3 运行容器时，你可以看到top是唯一的进程：\n$ docker run -it –rm –name test top -H top - 08:25:00 up 7:27, 0 users, load average: 0.00, 0.01, 0.05 Threads: 1 total, 1 running, 0 sleeping, 0 stopped, 0 zombie %Cpu(s): 0.1 us, 0.1 sy, 0.0 ni, 99.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem: 2056668 total, 1616832 used, 439836 free, 99352 buffers KiB Swap: 1441840 total, 0 used, 1441840 free. 1324440 cached Mem\nPID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1 root 20 0 19744 2336 2080 R 0.0 0.1 0:00.04 top 1 2 3 4 5 6 7 8 9 要进一步检查结果，可以使用docker exec：\n$ docker exec -it test ps aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 2.6 0.1 19752 2352 ? Ss+ 08:24 0:00 top -b -H root 7 0.0 0.1 15572 2164 ? R+ 08:25 0:00 ps aux 1 2 3 4 并且你可以优雅地请求使用docker stop test来关闭top。\n以下Dockerfile显示使用ENTRYPOINT在前台运行Apache（即，作为PID 1）：\nFROM debian:stable RUN apt-get update \u0026\u0026 apt-get install -y –force-yes apache2 EXPOSE 80 443 VOLUME [\"/var/www\", “/var/log/apache2”, “/etc/apache2”] ENTRYPOINT [\"/usr/sbin/apache2ctl\", “-D”, “FOREGROUND”] 1 2 3 4 5 如果需要为单个可执行文件编写启动脚本，可以使用exec和gosu命令确保最终的可执行文件接收Unix信号：\n!/usr/bin/env bash set -e\nif [ “$1” = ‘postgres’ ]; then chown -R postgres “$PGDATA”\nif [ -z \"$(ls -A \"$PGDATA\")\" ]; then gosu postgres initdb fi exec gosu postgres \"$@\"  fi\nexec “$@” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 最后，如果你需要在关机时进行一些额外的清理（或与其他容器通信），或者协调多个可执行文件，你可能需要确保ENTRYPOINT脚本接收Unix信号，传递它们，然后做一些工作：\n!/bin/sh Note: I’ve written this using sh so it works in the busybox container too USE the trap if you need to also do manual cleanup after the service is stopped or need to start multiple services in the one container trap “echo TRAPed signal” HUP INT QUIT TERM\nstart service in background here /usr/sbin/apachectl start\necho “[hit enter key to exit] or run ‘docker stop '” read\nstop service and clean up here echo “stopping apache” /usr/sbin/apachectl stop\necho “exited $0” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 如果使用docker run -it –rm -p 80:80 –name test apache运行此镜像，则可以使用docker exec或docker top检查容器的进程，然后让脚本停止Apache：\n$ docker exec -it test ps aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.1 0.0 4448 692 ? Ss+ 00:42 0:00 /bin/sh /run.sh 123 cmd cmd2 root 19 0.0 0.2 71304 4440 ? Ss 00:42 0:00 /usr/sbin/apache2 -k start www-data 20 0.2 0.2 360468 6004 ? Sl 00:42 0:00 /usr/sbin/apache2 -k start www-data 21 0.2 0.2 360468 6000 ? Sl 00:42 0:00 /usr/sbin/apache2 -k start root 81 0.0 0.1 15572 2140 ? R+ 00:44 0:00 ps aux $ docker top test PID USER COMMAND 10035 root {run.sh} /bin/sh /run.sh 123 cmd cmd2 10054 root /usr/sbin/apache2 -k start 10055 33 /usr/sbin/apache2 -k start 10056 33 /usr/sbin/apache2 -k start $ /usr/bin/time docker stop test test real\t0m 0.27s user\t0m 0.03s sys\t0m 0.03s 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 注意：你可以使用–entrypoint覆盖ENTRYPOINT设置，但这只能将二进制设置为exec（不会使用sh -c）。\n注意：exec形式被解析为JSON数组，这意味着你必须使用双引号（\"）来围绕单词而不是单引号（’）。\n注意：与shell形式不同，exec形式不会调用命令shell。这意味着不会发生正常的shell处理。例如，ENTRYPOINT [ “echo”, “$HOME” ]不会对$HOME执行变量替换。如果你想要shell处理，那么要么使用shell形式，要么直接执行shell，例如：ENTRYPOINT [ “sh”, “-c”, “echo $HOME” ]。当使用exec形式并直接执行shell时，就像shell形式的情况一样，它是执行环境变量扩展的shell，而不是docker。\nShell形式ENTRYPOINT示例 你可以为ENTRYPOINT指定一个纯字符串，它将在/bin/sh -c中执行。这种形式将使用shell处理来替换shell环境变量，并将忽略任何CMD或docker run命令行参数。要确保docker stop能正确发信号给任何长时间运行的ENTRYPOINT可执行文件，你需要记住用exec启动它：\nFROM ubuntu ENTRYPOINT exec top -b 1 2 运行此镜像时，你将看到单个PID 1进程：\n$ docker run -it –rm –name test top Mem: 1704520K used, 352148K free, 0K shrd, 0K buff, 140368121167873K cached CPU: 5% usr 0% sys 0% nic 94% idle 0% io 0% irq 0% sirq Load average: 0.08 0.03 0.05 2/98 6 PID PPID USER STAT VSZ %VSZ %CPU COMMAND 1 0 root R 3164 0% 0% top -b 1 2 3 4 5 6 在docker stop时干净地退出：\n$ /usr/bin/time docker stop test test real\t0m 0.20s user\t0m 0.02s sys\t0m 0.04s 1 2 3 4 5 如果你忘记将exec添加到ENTRYPOINT的开头：\nFROM ubuntu ENTRYPOINT top -b CMD –ignored-param1 1 2 3 然后，你可以运行它（为了下一步给个名字）：\n$ docker run -it –name test top –ignored-param2 Mem: 1704184K used, 352484K free, 0K shrd, 0K buff, 140621524238337K cached CPU: 9% usr 2% sys 0% nic 88% idle 0% io 0% irq 0% sirq Load average: 0.01 0.02 0.05 2/101 7 PID PPID USER STAT VSZ %VSZ %CPU COMMAND 1 0 root S 3168 0% 0% /bin/sh -c top -b cmd cmd2 7 1 root R 3164 0% 0% top -b 1 2 3 4 5 6 7 你可以从top的输出中看到指定的ENTRYPOINT不是PID 1。\n如果运行docker stop test，容器将不会干净地退出 - stop命令将被强制在超时后发送SIGKILL：\n$ docker exec -it test ps aux PID USER COMMAND 1 root /bin/sh -c top -b cmd cmd2 7 root top -b 8 root ps aux $ /usr/bin/time docker stop test test real\t0m 10.19s user\t0m 0.04s sys\t0m 0.03s 1 2 3 4 5 6 7 8 9 10 了解CMD和ENTRYPOINT如何相互作用 CMD和ENTRYPOINT指令都定义了运行容器时执行的命令。 这里有点规则描述他们之间的合作。\nDockerfile应至少指定一个CMD或ENTRYPOINT命令。 使用容器作为可执行文件时，应定义ENTRYPOINT。 CMD应该用作为ENTRYPOINT命令定义默认参数或在容器中执行特定命令的方法。 使用备用参数运行容器时，将覆盖CMD。 下表显示了针对不同ENTRYPOINT / CMD组合执行的命令：\nNo ENTRYPOINT\tENTRYPOINT exec_entry p1_entry\tENTRYPOINT [“exec_entry”, “p1_entry”] No CMD\terror, not allowed\t/bin/sh -c exec_entry p1_entry\texec_entry p1_entry CMD [“exec_cmd”, “p1_cmd”]\texec_cmd p1_cmd\t/bin/sh -c exec_entry p1_entry\texec_entry p1_entry exec_cmd p1_cmd CMD [“p1_cmd”, “p2_cmd”]\tp1_cmd p2_cmd\t/bin/sh -c exec_entry p1_entry\texec_entry p1_entry p1_cmd p2_cmd CMD exec_cmd p1_cmd\t/bin/sh -c exec_cmd p1_cmd\t/bin/sh -c exec_entry p1_entry\texec_entry p1_entry /bin/sh -c exec_cmd p1_cmd VOLUME 创建外部卷 VOLUME [\"/data\"] 1 VOLUME指令创建具有指定名称的安装点，并将其标记为从本机主机或其他容器保存外部安装的卷。 该值可以是JSON数组，VOLUME [\"/var/log/\"]或具有多个参数的纯字符串，例如VOLUME /var/log 或 VOLUME /var/log /var/db。 有关通过Docker客户端提供的更多信息/示例和安装说明，请参阅通过卷共享目录文档。\ndocker run命令使用基础镜像中指定位置存在的任何数据初始化新创建的卷。 例如，请考虑以下Dockerfile片段：\nFROM ubuntu RUN mkdir /myvol RUN echo “hello world”  /myvol/greeting VOLUME /myvol 1 2 3 4 此Dockerfile会生成一个镜像，该镜像会导致docker run在/myvol上创建新的挂载点，并将greeting文件复制到新创建的卷中。\n有关指定卷的说明 关于Dockerfile中的卷，请记住以下事项。\n基于Windows容器上的卷：使用基于Windows的容器时，容器中卷的目标必须是以下之一： 不存在或空目录 C:以外的驱动器： 从Dockerfile中更改卷：如果任何构建步骤在声明后更改卷内的数据，那么这些更改将被丢弃。 JSON格式：列表被解析为JSON数组。你必须用双引号（\"）而不是单引号（’）括起来。 主机目录在容器运行时声明：主机目录（挂载点）本质上是依赖于主机的。这是为了保持镜像的可移植性，因为不能保证给定的主机目录在所有主机上都可用。因此，你无法从Dockerfile中挂载主机目录。 VOLUME指令不支持指定host-dir参数。你必须在创建或运行容器时指定挂载点。 USER 设置当前用户 USER [:] or USER [:] 1 2 USER指令设置用户名（或UID）以及可选的用户组（或GID），以便在运行镜像时以及Dockerfile中跟随它的任何RUN、CMD和ENTRYPOINT指令时使用。\n警告：当用户没有主组时，将使用root组运行镜像（或下一条指令）。\n在Windows上，如果用户不是内置帐户，则必须先创建用户。 这可以使用作为Dockerfile一部分调用的net user命令来完成。\nFROM microsoft/windowsservercore # Create Windows user in the container RUN net user /add patrick # Set it for subsequent commands USER patrick  1 2 3 4 5 WORKDIR 设置工作目录 WORKDIR /path/to/workdir 1 WORKDIR指令为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。 如果WORKDIR不存在，即使它未在任何后续Dockerfile指令中使用，也将创建它。\nWORKDIR指令可以在Dockerfile中多次使用。 如果提供了相对路径，则它将相对于先前WORKDIR指令的路径。 例如：\nWORKDIR /a WORKDIR b WORKDIR c RUN pwd 1 2 3 4 此Dockerfile中最终pwd命令的输出为/a/b/c。\nWORKDIR指令可以解析先前使用ENV设置的环境变量。 你只能使用Dockerfile中显式设置的环境变量。 例如：\nENV DIRPATH /path WORKDIR $DIRPATH/$DIRNAME RUN pwd 1 2 3 此Dockerfile中最后一个pwd命令的输出将是/path/$DIRNAME。\nARG 构建参数 ARG [=] 1 ARG指令使用–build-arg =标志定义一个变量，用户可以使用docker build命令在构建时将该变量传递给构建器。如果用户指定了未在Dockerfile中定义的构建参数，则构建会输出警告。\n[Warning] One or more build-args [foo] were not consumed. 1 Dockerfile可以包括一个或多个ARG指令。 例如，以下是有效的Dockerfile：\nFROM busybox ARG user1 ARG buildno … 1 2 3 4 警告：建议不要使用构建时变量来传递密码，例如github密钥、用户凭据等。使用docker history命令，任何图像用户都可以看到构建时变量值。\nDefault values 默认值 ARG指令可以包含可选的默认值：\nFROM busybox ARG user1=someuser ARG buildno=1 … 1 2 3 4 如果ARG指令具有默认值，并且在构建时没有传递值，则构建器将使用默认值。\nScope 作用域 ARG变量定义从Dockerfile中定义的行开始生效，而不是从命令行或其他地方的参数使用时才生效。 例如，考虑这个Dockerfile：\n1 FROM busybox 2 USER ${user:-some_user} 3 ARG user 4 USER $user … 1 2 3 4 5 用户通过调用以下内容构建此文件：\n$ docker build –build-arg user=what_user . 1 第2行的USER设值为some_user，因为在后续第3行才定义了用户变量。第4行的USER在定义用户时设值为what_user，并在命令行上传递what_user值。 在通过ARG指令定义之前，对变量的任何使用都会导致空字符串。\nARG指令在构建阶段结束时超出作用域。 要在多个阶段中使用arg，每个阶段必须包含ARG指令。\nFROM busybox ARG SETTINGS RUN ./run/setup $SETTINGS\nFROM busybox ARG SETTINGS RUN ./run/other $SETTINGS 1 2 3 4 5 6 7 Using ARG variables 使用参数变量 你可以使用ARG或ENV指令指定RUN指令可用的变量。 使用ENV指令定义的环境变量始终覆盖同名的ARG指令。 考虑这个带有ENV和ARG指令的Dockerfile。\n1 FROM ubuntu 2 ARG CONT_IMG_VER 3 ENV CONT_IMG_VER v1.0.0 4 RUN echo $CONT_IMG_VER 1 2 3 4 然后，假设使用此命令构建此镜像：\n$ docker build –build-arg CONT_IMG_VER=v2.0.1 . 1 在这种情况下，RUN指令使用v1.0.0而不是用户传递的ARG设置：v2.0.1。此行为类似于shell脚本，其中本地作用域的变量会覆盖作为参数传递或从定义点继承的环境变量， 。\n使用上面的示例，但不同的ENV规范，你可以在ARG和ENV指令之间创建更有用的交互：\n1 FROM ubuntu 2 ARG CONT_IMG_VER 3 ENV CONT_IMG_VER ${CONT_IMG_VER:-v1.0.0} 4 RUN echo $CONT_IMG_VER 1 2 3 4 与ARG指令不同，ENV值始终保留在构建的镜像中。 考虑没有–build-arg标志的docker构建：\n$ docker build . 1 使用此Dockerfile示例，CONT_IMG_VER仍然保留在镜像中，但其值为v1.0.0，因为它是ENV指令在第3行中的默认设置。\n此示例中的变量扩展技术允许你从命令行传递参数，并通过利用ENV指令将它们保存在最终镜像中。 只有一组有限的Dockerfile指令支持变量扩展。\nPredefined ARGs 预定义的ARG Docker有一组预定义的ARG变量，你可以在Dockerfile中使用而无需相应的ARG指令。\nHTTP_PROXY http_proxy HTTPS_PROXY https_proxy FTP_PROXY ftp_proxy NO_PROXY no_proxy 要使用它们，只需使用标志在命令行上传递它们：\n–build-arg =1 默认情况下，这些预定义变量将从docker history的输出中排除。 排除它们可降低在HTTP_PROXY变量中意外泄露敏感验证信息的风险。\n例如，考虑使用–build-arg HTTP_PROXY=http://user:pass@proxy.lon.example.com构建以下Dockerfile\nFROM ubuntu RUN echo “Hello World” 1 2 在这种情况下，HTTP_PROXY变量的值在docker history中不可用，并且不会被缓存。 如果要更改位置，并且代理服务器已更改为http://user:pass@proxy.sfo.example.com，则后续构建不会导致缓存未命中。\n如果你需要覆盖此行为，则可以通过在Dockerfile中添加ARG语句来执行此操作，如下所示：\nFROM ubuntu ARG HTTP_PROXY RUN echo “Hello World” 1 2 3 构建此Dockerfile时，HTTP_PROXY将保留在docker history中，并且更改其值会使构建缓存无效。\nInpact on build caching 对构建缓存的影响 ARG变量不会像ENV变量那样持久存储到构建的镜像中。 但是，ARG变量会以类似的方式影响构建缓存。 如果Dockerfile定义了一个值与先前版本不同的ARG变量，那么在第一次使用时会发生“缓存未命中”，而不是其定义。 特别是，ARG指令之后的所有RUN指令都隐式使用ARG变量（作为环境变量），因此可能导致缓存未命中。 除非Dockerfile中存在匹配的ARG语句，否则所有预定义的ARG变量都将免于缓存。\n例如，考虑这两个Dockerfile：\n1 FROM ubuntu 2 ARG CONT_IMG_VER 3 RUN echo $CONT_IMG_VER 1 2 3 1 FROM ubuntu 2 ARG CONT_IMG_VER 3 RUN echo hello 1 2 3 如果在命令行上指定–build-arg CONT_IMG_VER=，则在这两种情况下，第2行上的规范不会导致高速缓存未命中; 第3行确实导致缓存未命中。ARG CONT_IMG_VER导致RUN行被识别为与运行CONT_IMG_VER=echo hello相同，因此如果发生更改，我们将获得缓存未命中。\n考虑同一命令行下的另一个示例：\n1 FROM ubuntu 2 ARG CONT_IMG_VER 3 ENV CONT_IMG_VER $CONT_IMG_VER 4 RUN echo $CONT_IMG_VER 1 2 3 4 在此示例中，缓存未命中发生在第3行。由于ENV中的变量值引用ARG变量并且该变量通过命令行发生更改，因此发生未命中。 在此示例中，ENV命令使镜像包含该值。\n如果ENV指令覆盖了同名的ARG指令，就像这个Dockerfile：\n1 FROM ubuntu 2 ARG CONT_IMG_VER 3 ENV CONT_IMG_VER hello 4 RUN echo $CONT_IMG_VER 1 2 3 4 第3行不会导致缓存未命中，因为CONT_IMG_VER的值是常量（hello）。 因此，RUN（第4行）上使用的环境变量和值在构建之间不会发生变化。\nONBUILD 为下游镜像添加触发器 ONBUILD [INSTRUCTION] 1 当镜像用作另一个构建的基础时，ONBUILD指令向镜像添加将在稍后执行的触发指令。触发器将在下游构建的上下文中执行，就好像它已经在下游Dockerfile中的FROM指令之后立即插入一样。\n任何构建指令都可以注册为触发器。\n如果要构建将用作构建其他镜像的基础镜像（例如，可以使用特定于用户的配置自定义的应用程序构建环境变量或守护进程），这将非常有用。\n例如，如果你的镜像是可重用的Python应用程序构建器，则需要将应用程序源代码添加到特定目录中，并且可能需要在此之后调用构建脚本。你现在不能只调用ADD和RUN，因为你还无法访问应用程序源代码，并且每个应用程序构建都会有所不同。你可以简单地为应用程序开发人员提供一个样板Dockerfile来复制粘贴到他们的应用程序中，但这样做效率低，容易出错且难以更新，因为它与特定于应用程序的代码混合在一起。\n解决方案是使用ONBUILD来注册预先指令，以便在下一个构建阶段运行。\n以下是它的工作原理：\n当遇到ONBUILD指令时，构建器会向正在构建的图像的元数据添加触发器。该指令不会影响当前构建。 在构建结束时，所有触发器的列表都存储在镜像清单中的OnBuild键下。可以使用docker inspect命令检查它们。 稍后，可以使用FROM指令将镜像用作新构建的基础。作为处理FROM指令的一部分，下游构建器查找ONBUILD触发器，并按照它们注册的顺序执行它们。如果任何触发器失败，则中止FROM指令，这反过来导致构建失败。如果所有触发器都成功，则FROM指令完成，并且构建继续照常进行。 执行后，触发器将从最终镜像中清除。换句话说，它们不是由“大孩子(grand-children)”构建继承的。 例如，你可以添加以下内容：\n[…] ONBUILD ADD . /app/src ONBUILD RUN /usr/local/bin/python-build –dir /app/src […] 1 2 3 4 警告：不允许使用ONBUILD ONBUILD这样的链状ONBUILD指令。\n警告：ONBUILD指令可能不会触发FROM或MAINTAINER指令。\nSTOPSIGNAL 容器退出信号 STOPSIGNAL signal 1 STOPSIGNAL指令设置将发送给容器退出的系统调用信号。此信号可以是与内核的系统调用表中的位置匹配的有效无符号数，例如9，或SIGNAME格式的信号名，例如SIGKILL。\nHEALTHCHECK 健康检查 HEALTHCHECK指令有两种形式：\nHEALTHCHECK [OPTIONS] CMD command（通过在容器内运行命令来检查容器运行状况） HEALTHCHECK NONE（禁用从基础镜像继承的任何健康检查） HEALTHCHECK指令告诉Docker如何测试容器以检查它是否仍在工作。可以检测到陷入无限循环且无法处理新连接的Web服务器，即使服务器进程仍在运行等情况。\n当容器指定了运行状况检查时，除了正常状态外，它还具有运行状况。此状态最初为starting。每当健康检查通过时，它就会变得healthy（无论以前处于什么状态）。经过一定数量的连续失败后，它变得unhealthy。\n可以在CMD之前出现的选项是：\n–interval=DURATION (默认值：30s) –timeout=DURATION (默认值：30s) –start-period=DURATION (默认值：0s) –retries=N (默认值：3) 运行状况检查将首先在容器启动后的**间隔(interval)秒运行，然后在每次上一次检查完成后再间隔(interval)**秒。\n如果单次运行的检查花费的时间超过**超时(timeout)**秒数，那么检查将被视为unhealthy。\n它需要**重试(retries)**连续的健康检查失败才能将容器视为不健康。\n**启动期间(start period)**为需要时间引导的容器提供初始化时间。在此期间探测失败将不计入最大重试次数。但是，如果在启动期间运行状况检查成功，则会将容器视为已启动，并且所有连续失败将计入最大重试次数。\nDockerfile中只能有一个HEALTHCHECK指令。如果列出多个，那么只有最后一个HEALTHCHECK才会生效。\nCMD关键字之后的命令可以是shell命令（例如HEALTHCHECK CMD /bin/check-running）或exec数组（与其他Dockerfile命令一样;有关详细信息，请参阅例如ENTRYPOINT）。\n命令的退出状态指示容器的运行状况。可能的值是：\n0: success 成功 - 容器健康且随时可用 1: unhealthy 不健康 - 容器无法正常工作 2: reserved 保留 - 不要使用此退出代码 例如，要检查每五分钟左右网络服务器能够在三秒钟内提供网站的主页面： HEALTHCHECK –interval=5m –timeout=3s\nCMD curl -f http://localhost/ || exit 1 1 2 为了帮助调试失败的探测器，命令在stdout或stderr上写入的任何输出文本（UTF-8编码）都将存储在运行状况(health status)中，并可以使用docker inspect进行查询。 此类输出应保持较短（目前仅存储前4096个字节）。\n当容器的运行状况更改时，将生成具有新状态的health_status事件。\n在Docker 1.12中添加了HEALTHCHECK功能。\nSHELL SHELL [“executable”, “parameters”] 1 SHELL指令允许覆盖用于shell命令形式的默认shell。 Linux上的默认shell是[\"/bin/sh\", “-c”]，在Windows上是[“cmd”, “/S”, “/C”]。 SHELL指令必须以JSON格式写入Dockerfile。\nSHELL指令在Windows上特别有用，其中有两个常用且相当不同的本机shell：cmd和powershell，以及包括sh的备用shell。\nSHELL指令可以多次出现。 每个SHELL指令都会覆盖所有先前的SHELL指令，并影响所有后续指令。 例如：\nFROM microsoft/windowsservercore\nExecuted as cmd /S /C echo default RUN echo default\nExecuted as cmd /S /C powershell -command Write-Host default RUN powershell -command Write-Host default\nExecuted as powershell -command Write-Host hello SHELL [“powershell”, “-command”] RUN Write-Host hello\nExecuted as cmd /S /C echo hello SHELL [“cmd”, “/S”, “/C”] RUN echo hello 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 当在Dockerfile中使用它们的shell形式时，SHELL指令可能会影响以下指令：RUN，CMD和ENTRYPOINT。\n以下示例是在Windows上找到的常见模式，可以使用SHELL指令简化：\n… RUN powershell -command Execute-MyCmdlet -param1 “c:\\foo.txt” … 1 2 3 docker调用的命令将是：\ncmd /S /C powershell -command Execute-MyCmdlet -param1 “c:\\foo.txt” 1 由于两个原因，这是低效的。 首先，调用一个不必要的cmd.exe命令处理器（也就是shell）。 其次，shell形式的每个RUN指令都需要额外的powershell -command前缀命令。\n为了提高效率，可以采用两种机制中的一种。 一种是使用RUN命令的JSON形式，例如：\n… RUN [“powershell”, “-command”, “Execute-MyCmdlet”, “-param1 \"c:\\foo.txt\"\"] … 1 2 3 虽然JSON形式是明确的，并且不使用不必要的cmd.exe，但它需要通过双引号和转义使得更加赘言。 替代机制是使用SHELL指令和shell形式，为Windows用户提供更自然的语法，特别是与escape解析器指令结合使用时：\nescape=` FROM microsoft/nanoserver SHELL [“powershell”,\"-command”] RUN New-Item -ItemType Directory C:\\Example ADD Execute-MyCmdlet.ps1 c:\\example\nRUN c:\\example\\Execute-MyCmdlet -sample ‘hello world’ 1 2 3 4 5 6 7 结果是:\nPS E:\\docker\\build\\shell docker build -t shell . Sending build context to Docker daemon 4.096 kB Step 1/5 : FROM microsoft/nanoserver — 22738ff49c6d Step 2/5 : SHELL powershell -command — Running in 6fcdb6855ae2 — 6331462d4300 Removing intermediate container 6fcdb6855ae2 Step 3/5 : RUN New-Item -ItemType Directory C:\\Example — Running in d0eef8386e97\nDirectory: C:\\  Mode LastWriteTime Length Name\n d—– 10/28/2016 11:26 AM Example\n— 3f2fbf1395d9 Removing intermediate container d0eef8386e97 Step 4/5 : ADD Execute-MyCmdlet.ps1 c:\\example\n— a955b2621c31 Removing intermediate container b825593d39fc Step 5/5 : RUN c:\\example\\Execute-MyCmdlet ‘hello world’ — Running in be6d8e63fe75 hello world — 8e559e9bf424 Removing intermediate container be6d8e63fe75 Successfully built 8e559e9bf424 PS E:\\docker\\build\\shell 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 SHELL指令也可用于修改shell的运行方式。 例如，在Windows上使用SHELL cmd /S /C /V:ON|OFF，可以修改延迟的环境变量扩展语义。\n如果需要备用shell，例如zsh、csh、tcsh等，也可以在Linux上使用SHELL指令。\n在Docker 1.12中添加了SHELL功能。\nDockerfile示例 下面你可以看到Dockerfile语法的一些示例。 如果你对更现实的东西感兴趣，请查看Dockerization示例列表。\nNginx  VERSION 0.0.1 FROM ubuntu LABEL Description=“This image is used to start the foobar executable” Vendor=“ACME Products” Version=“1.0” RUN apt-get update \u0026\u0026 apt-get install -y inotify-tools nginx apache2 openssh-server 1 2 3 4 5 6 7\nFirefox over VNC  VERSION 0.3 FROM ubuntu\nInstall vnc, xvfb in order to create a ‘fake’ display and firefox RUN apt-get update \u0026\u0026 apt-get install -y x11vnc xvfb firefox RUN mkdir ~/.vnc\nSetup a password RUN x11vnc -storepasswd 1234 ~/.vnc/passwd\nAutostart firefox (might not be the best way, but it does the trick) RUN bash -c ‘echo “firefox” » /.bashrc’\nEXPOSE 5900 CMD [“x11vnc”, “-forever”, “-usepw”, “-create”] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\nMultiple images example  VERSION 0.1 FROM ubuntu RUN echo foo  bar\nWill output something like === 907ad6c2736f FROM ubuntu RUN echo moo  oink\nWill output something like === 695d7793cbe4 You’ll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with /oink ",
  "wordCount" : "22545",
  "inLanguage": "zh-cn",
  "datePublished": "2021-03-03T13:25:03Z",
  "dateModified": "2021-03-03T13:25:03Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/dockerfile%E5%8F%82%E8%80%83/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Dockerfile参考
    </h1>
    <div class="post-meta">March 3, 2021
</div>
  </header> 
  <div class="post-content"><h2 id="dockerfile参考dockerfile-reference">Dockerfile参考（Dockerfile reference）<a hidden class="anchor" aria-hidden="true" href="#dockerfile参考dockerfile-reference">#</a></h2>
<p>Docker可以通过读取Dockerfile中的指令自动构建镜像。 Dockerfile是一个文本文档，其中包含用户可以在命令行上调用以装配镜像的所有命令。 使用docker build用户可以创建一个连续执行多个命令行指令的自动构建。</p>
<p>本页介绍了可以在Dockerfile中使用的命令。</p>
<h2 id="用法usage">用法（Usage）<a hidden class="anchor" aria-hidden="true" href="#用法usage">#</a></h2>
<p>docker build命令从Dockerfile和上下文构建镜像。 构建的上下文是指定位置PATH或URL处的文件集。 PATH是本地文件系统上的目录。 URL是Git存储库位置。</p>
<p>上下文是递归处理的。 因此，PATH包括任何子目录，URL包括存储库及其子模块。 此示例显示了使用当前目录作为上下文的构建命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">docker</span> <span class="n">build</span> <span class="n">.
</span><span class="n">Sending</span> <span class="n">build</span> <span class="n">context</span> <span class="n">to</span> <span class="n">Docker</span> <span class="n">daemon</span>  <span class="m">6.51</span> <span class="n">MB</span>
<span class="kc">...</span>
</code></pre></td></tr></table>
</div>
</div><p>构建由Docker守护进程（daemon）运行，而不是由CLI运行。 构建过程的第一件事是将整个上下文（递归地）发送到守护进程。 在大多数情况下，最好从空目录开始作为上下文，并将Dockerfile保存在该目录中。 仅添加构建Dockerfile所需的文件。</p>
<p>警告：不要将根目录/用作PATH，因为它会导致构建将硬盘驱动器的全部内容传输到Docker守护程序。</p>
<p>要在构建上下文中使用文件，Dockerfile引用指令中指定的文件，例如COPY指令。 要提高构建的性能，请通过将.dockerignore文件添加到上下文目录来排除文件和目录。</p>
<p>习惯上，Dockerfile称为Dockerfile，位于上下文的根目录中。 你可以将-f标志与docker build一起使用，以指向文件系统中任何位置的Dockerfile。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">docker</span> <span class="n">build</span> <span class="o">-</span><span class="n">f</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">a</span><span class="o">/</span><span class="n">Dockerfile</span> <span class="n">.
</span></code></pre></td></tr></table>
</div>
</div><p>如果构建成功，你可以指定存储库和标记以保存新镜像：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">docker</span> <span class="n">build</span> <span class="o">-</span><span class="n">t</span> <span class="n">shykes</span><span class="o">/</span><span class="n">myapp</span> <span class="n">.
</span></code></pre></td></tr></table>
</div>
</div><p>要在构建后将映像标记为多个存储库，请在运行build命令时添加多个-t参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">docker</span> <span class="n">build</span> <span class="o">-</span><span class="n">t</span> <span class="n">shykes</span><span class="o">/</span><span class="n">myapp</span><span class="o">:</span><span class="m">1.0.2</span> <span class="o">-</span><span class="n">t</span> <span class="n">shykes</span><span class="o">/</span><span class="n">myapp</span><span class="o">:</span><span class="n">latest</span> <span class="n">.
</span></code></pre></td></tr></table>
</div>
</div><p>在Docker守护进程运行Dockerfile中的指令之前，它会执行Dockerfile的初步验证，如果语法不正确则返回错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">docker</span> <span class="n">build</span> <span class="o">-</span><span class="n">t</span> <span class="n">test</span><span class="o">/</span><span class="n">myapp</span> <span class="n">.
</span><span class="n">Sending</span> <span class="n">build</span> <span class="n">context</span> <span class="n">to</span> <span class="n">Docker</span> <span class="n">daemon</span> <span class="m">2.048</span> <span class="n">kB</span>
<span class="n">Error</span> <span class="n">response</span> <span class="n">from</span> <span class="n">daemon</span><span class="o">:</span> <span class="n">Unknown</span> <span class="n">instruction</span><span class="o">:</span> <span class="n">RUNCMD</span>
</code></pre></td></tr></table>
</div>
</div><p>Docker守护进程逐个运行Dockerfile中的指令，在必要时将每条指令的结果提交给新镜像，最后输出新镜像的ID。 Docker守护进程将自动清理你发送的上下文。</p>
<p>请注意，每条指令都是独立运行的，并且会导致创建新镜像 - 因此RUN cd / tmp对下一条指令不会产生任何影响。</p>
<p>只要有可能，Docker将重新使用中间镜像（缓存），以显著地加速docker build过程。 这由控制台输出中的Using cache消息指示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">docker</span> <span class="n">build</span> <span class="o">-</span><span class="n">t</span> <span class="n">svendowideit</span><span class="o">/</span><span class="n">ambassador</span> <span class="n">.
</span><span class="n">Sending</span> <span class="n">build</span> <span class="n">context</span> <span class="n">to</span> <span class="n">Docker</span> <span class="n">daemon</span> <span class="m">15.36</span> <span class="n">kB</span>
<span class="n">Step</span> <span class="m">1</span><span class="o">/</span><span class="m">4</span> <span class="o">:</span> <span class="n">FROM</span> <span class="n">alpine</span><span class="o">:</span><span class="m">3.2</span>
 <span class="o">---&gt;</span> <span class="m">31</span><span class="n">f630c65071</span>
<span class="n">Step</span> <span class="m">2</span><span class="o">/</span><span class="m">4</span> <span class="o">:</span> <span class="n">MAINTAINER</span> <span class="n">SvenDowideit</span><span class="o">@</span><span class="n">home.org.au</span>
 <span class="o">---&gt;</span> <span class="n">Using</span> <span class="n">cache</span>
 <span class="o">---&gt;</span> <span class="m">2</span><span class="n">a1c91448f5f</span>
<span class="n">Step</span> <span class="m">3</span><span class="o">/</span><span class="m">4</span> <span class="o">:</span> <span class="n">RUN</span> <span class="n">apk</span> <span class="n">update</span> <span class="o">&amp;&amp;</span>      <span class="n">apk</span> <span class="n">add</span> <span class="n">socat</span> <span class="o">&amp;&amp;</span>        <span class="n">rm</span> <span class="o">-</span><span class="n">r</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">cache</span><span class="o">/</span>
 <span class="o">---&gt;</span> <span class="n">Using</span> <span class="n">cache</span>
 <span class="o">---&gt;</span> <span class="m">21</span><span class="n">ed6e7fbb73</span>
<span class="n">Step</span> <span class="m">4</span><span class="o">/</span><span class="m">4</span> <span class="o">:</span> <span class="n">CMD</span> <span class="n">env</span> <span class="o">|</span> <span class="n">grep</span> <span class="n">_TCP</span><span class="o">=</span> <span class="o">|</span> <span class="p">(</span><span class="n">sed</span> <span class="s">&#39;s/.*_PORT_\([0-9]*\)_TCP=tcp:\/\/\(.*\):\(.*\)/socat -t 100000000 TCP4-LISTEN:\1,fork,reuseaddr TCP4:\2:\3 \&amp;/&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">echo</span> <span class="n">wait</span><span class="p">)</span> <span class="o">|</span> <span class="n">sh</span>
 <span class="o">---&gt;</span> <span class="n">Using</span> <span class="n">cache</span>
 <span class="o">---&gt;</span> <span class="m">7</span><span class="n">ea8aef582cc</span>
<span class="n">Successfully</span> <span class="n">built</span> <span class="m">7</span><span class="n">ea8aef582cc</span>
</code></pre></td></tr></table>
</div>
</div><p>构建缓存仅用于具有本地父链的镜像。 这意味着这些镜像是由以前的版本创建的，或者整个镜像链都用docker load装载了。如果你希望使用特定镜像的构建缓存，可以使用&ndash;cache-from选项指定它。 使用&ndash;cache-from指定的镜像不需要具有父链，可以从其他注册表中提取。</p>
<p>完成构建后，你已准备好查看将存储库推送到其注册表。</p>
<h2 id="格式format">格式（Format）<a hidden class="anchor" aria-hidden="true" href="#格式format">#</a></h2>
<p>这是Dockerfile的格式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="c1"># Comment</span>
<span class="n">INSTRUCTION</span> <span class="n">arguments</span>
</code></pre></td></tr></table>
</div>
</div><p>该指令不区分大小写。 但是，惯例是让它们成为大写的，以便更容易地将它们与参数区分开来。</p>
<p>Docker按顺序在Dockerfile中运行指令。 Dockerfile必须以FROM指令开头。 FROM指令指定要构建的基础镜像(Base Image)。 FROM只能在一个或多个ARG指令之前，这些指令声明在Dockerfile中的FROM行中使用的参数。</p>
<p>Docker将以＃开头的行视为注释，除非该行是有效的解析器指令(parser directive)。 行中任何其他位置的＃标记都被视为参数。 允许这样的语句：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="c1"># Comment</span>
<span class="n">RUN</span> <span class="n">echo</span> <span class="s">&#39;we are running some # of cool things&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>注释中不支持行继续符。</p>
<h2 id="解析器指令parser-directives">解析器指令（Parser directives）<a hidden class="anchor" aria-hidden="true" href="#解析器指令parser-directives">#</a></h2>
<p>解析器指令是可选的，并且会影响处理Dockerfile中后续行的方式。解析器指令不会向构建添加层，也不会显示为构建步骤。解析器指令以<code>＃directive = value</code>的形式编写为特殊类型的注释。单个指令只能使用一次。</p>
<p>一旦处理了注释，空行或构建器指令，Docker就不再查找解析器指令。相反，它将格式化为解析器指令的任何内容视为注释，并且不会尝试验证它是否可能是解析器指令。因此，所有解析器指令必须位于Dockerfile的最顶层。</p>
<p>解析器指令不区分大小写。但是，惯例是它们是小写的。约定还包括任何解析器指令后面的空行。解析器指令不支持行继续符。</p>
<p>由于这些规则，以下示例均无效：</p>
<p>由于行继续而无效：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="c1"># direc \</span>
<span class="n">tive</span><span class="o">=</span><span class="n">value</span>
</code></pre></td></tr></table>
</div>
</div><p>由于出现两次无效：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="c1"># directive=value1</span>
<span class="c1"># directive=value2</span>

<span class="n">FROM</span> <span class="n">ImageName</span>
</code></pre></td></tr></table>
</div>
</div><p>由于在构建器指令后出现而被视为注释：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">FROM</span> <span class="n">ImageName</span>
<span class="c1"># directive=value</span>
</code></pre></td></tr></table>
</div>
</div><p>由于在注释之后出现而被视为注释，而不是解析器指令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="c1"># About my dockerfile</span>
<span class="c1"># directive=value</span>
<span class="n">FROM</span> <span class="n">ImageName</span>
</code></pre></td></tr></table>
</div>
</div><p>由于未被识别，未知指令被视为注释。 此外，由于出现在注释之后，已知指令被视为注释，而不是解析器指令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="c1"># unknowndirective=value</span>
<span class="c1"># knowndirective=value</span>
</code></pre></td></tr></table>
</div>
</div><p>解析器指令中允许使用非换行空格。 因此，以下几行都是相同的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="c1"># directive=value</span>
<span class="c1"># directive =value</span>
<span class="c1">#	directive= value</span>
<span class="c1"># directive = value</span>
<span class="c1">#     dIrEcTiVe=value</span>
</code></pre></td></tr></table>
</div>
</div><p>支持以下解析器指令：</p>
<ul>
<li>escape</li>
<li>syntax</li>
</ul>
<h2 id="语法syntax">语法（syntax）<a hidden class="anchor" aria-hidden="true" href="#语法syntax">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="c1"># syntax=[remote image reference]</span>
</code></pre></td></tr></table>
</div>
</div><p>例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="c1"># syntax=docker/dockerfile</span>
<span class="c1"># syntax=docker/dockerfile:1.0</span>
<span class="c1"># syntax=docker.io/docker/dockerfile:1</span>
<span class="c1"># syntax=docker/dockerfile:1.0.0-experimental t</span>
<span class="c1"># syntax=example.com/user/repo:tag@sha256:abcdef.</span>
</code></pre></td></tr></table>
</div>
</div><p>仅当使用BuildKit后端时才启用此功能。</p>
<p>语法指令定义用于构建当前Dockerfile的Dockerfile构建器的位置。BuildKit后端允许无缝使用构建器的外部实现，这些构建器以Docker映像的形式分发并在容器沙箱环境中执行。</p>
<p>自定义Dockerfile实现允许您执行以下操作：</p>
<ul>
<li>自动获取错误修正，而无需更新守护程序</li>
<li>确保所有用户都使用相同的实现来构建您的Dockerfile</li>
<li>使用最新功能，而不更新守护程序</li>
<li>试用新的实验性或第三方功能</li>
</ul>
<h3 id="官方发布">官方发布<a hidden class="anchor" aria-hidden="true" href="#官方发布">#</a></h3>
<p>Docker分发了映像的正式版本，这些映像可用于docker/dockerfile在Docker Hub上的存储库下构建Dockerfile 。有两个发布新图像的渠道：稳定版和实验版。</p>
<p>稳定的通道遵循语义版本控制。例如：</p>
<ul>
<li>docker/dockerfile:1.0.0 -仅允许不可变版本 1.0.0</li>
<li>docker/dockerfile:1.0 -允许版本 1.0.*</li>
<li>docker/dockerfile:1 -允许版本 1.<em>.</em></li>
<li>docker/dockerfile:latest -稳定频道上的最新版本</li>
</ul>
<p>在发布之时，实验频道使用稳定版本中主要和次要组件的增量版本控制。例如：</p>
<ul>
<li>docker/dockerfile:1.0.1-experimental -仅允许不可变版本 1.0.1-experimental</li>
<li>docker/dockerfile:1.0-experimental -之后的最新实验版本 1.0</li>
<li>docker/dockerfile:experimental -实验频道的最新版本</li>
</ul>
<p>您应该选择最适合自己需求的渠道。如果您只想修正错误，则应使用docker/dockerfile:1.0。如果您想从实验功能中受益，则应使用实验频道。如果您使用的是实验性频道，则较新的版本可能无法向后兼容，因此建议使用不可变的完整版本。</p>
<p>有关主版本和每夜发布的功能，请参考源存储库中的描述 。</p>
<h2 id="转义escape">转义（escape）<a hidden class="anchor" aria-hidden="true" href="#转义escape">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="c1"># escape=\ (backslash)</span>
</code></pre></td></tr></table>
</div>
</div><p>或</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="c1"># escape=` (backtick)</span>
</code></pre></td></tr></table>
</div>
</div><p>escape指令设置用于转义Dockerfile中字符的字符。如果未指定，则默认转义字符为\。</p>
<p>转义字符既用于转义行中的字符，也用于转义换行符。这允许Dockerfile指令跨越多行。请注意，无论转义解析器指令是否包含在Dockerfile中，都不会在RUN命令中执行转义，除非在行尾。</p>
<p>将转义字符设置为`在Windows上特别有用，其中\是目录路径分隔符。`与Windows PowerShell一致。</p>
<p>请考虑以下示例，该示例在Windows上以非显而易见的方式失败。第二行末尾的第二个\将被解释为换行符的转义符，而不是第一个\的转义目标。类似地，假设它实际上作为指令处理，第三行末尾的\将导致它被视为行继续。这个dockerfile的结果是第二行和第三行被认为是单个指令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">FROM</span> <span class="n">microsoft</span><span class="o">/</span><span class="n">nanoserver</span>
<span class="n">COPY</span> <span class="n">testfile.txt</span> <span class="n">c</span><span class="o">:</span><span class="n">\\</span>
<span class="n">RUN</span> <span class="n">dir</span> <span class="n">c</span><span class="o">:</span><span class="n">\</span>
</code></pre></td></tr></table>
</div>
</div><p>结果是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">PS</span> <span class="n">C</span><span class="o">:</span><span class="n">\John</span><span class="o">&gt;</span> <span class="n">docker</span> <span class="n">build</span> <span class="o">-</span><span class="n">t</span> <span class="n">cmd</span> <span class="n">.
</span><span class="n">Sending</span> <span class="n">build</span> <span class="n">context</span> <span class="n">to</span> <span class="n">Docker</span> <span class="n">daemon</span> <span class="m">3.072</span> <span class="n">kB</span>
<span class="n">Step</span> <span class="m">1</span><span class="o">/</span><span class="m">2</span> <span class="o">:</span> <span class="n">FROM</span> <span class="n">microsoft</span><span class="o">/</span><span class="n">nanoserver</span>
 <span class="o">---&gt;</span> <span class="m">22738</span><span class="n">ff49c6d</span>
<span class="n">Step</span> <span class="m">2</span><span class="o">/</span><span class="m">2</span> <span class="o">:</span> <span class="n">COPY</span> <span class="n">testfile.txt</span> <span class="n">c</span><span class="o">:</span><span class="n">\RUN</span> <span class="n">dir</span> <span class="n">c</span><span class="o">:</span>
<span class="n">GetFileAttributesEx</span> <span class="n">c</span><span class="o">:</span><span class="n">RUN</span><span class="o">:</span> <span class="n">The</span> <span class="n">system</span> <span class="n">cannot</span> <span class="n">find</span> <span class="n">the</span> <span class="n">file</span> <span class="n">specified.</span>
<span class="n">PS</span> <span class="n">C</span><span class="o">:</span><span class="n">\John</span><span class="o">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的一个解决方案是使用/作为COPY指令和dir的目标。 但是，这种语法充其量是令人困惑的，因为它对于Windows上的路径来说并不自然，并且最坏的情况是，由于Windows上的所有命令都不支持/作为路径分隔符，因此容易出错。</p>
<p>通过添加转义(escape)解析器指令，以下Dockerfile按预期成功使用Windows上的自然平台语义文件路径：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="c1"># escape=`</span>

<span class="n">FROM</span> <span class="n">microsoft</span><span class="o">/</span><span class="n">nanoserver</span>
<span class="n">COPY</span> <span class="n">testfile.txt</span> <span class="n">c</span><span class="o">:</span><span class="n">\</span>
<span class="n">RUN</span> <span class="n">dir</span> <span class="n">c</span><span class="o">:</span><span class="n">\</span>
</code></pre></td></tr></table>
</div>
</div><p>结果是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">PS</span> <span class="n">C</span><span class="o">:</span><span class="n">\John</span><span class="o">&gt;</span> <span class="n">docker</span> <span class="n">build</span> <span class="o">-</span><span class="n">t</span> <span class="n">succeeds</span> <span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">cache</span><span class="o">=</span><span class="n">true</span> <span class="n">.
</span><span class="n">Sending</span> <span class="n">build</span> <span class="n">context</span> <span class="n">to</span> <span class="n">Docker</span> <span class="n">daemon</span> <span class="m">3.072</span> <span class="n">kB</span>
<span class="n">Step</span> <span class="m">1</span><span class="o">/</span><span class="m">3</span> <span class="o">:</span> <span class="n">FROM</span> <span class="n">microsoft</span><span class="o">/</span><span class="n">nanoserver</span>
 <span class="o">---&gt;</span> <span class="m">22738</span><span class="n">ff49c6d</span>
<span class="n">Step</span> <span class="m">2</span><span class="o">/</span><span class="m">3</span> <span class="o">:</span> <span class="n">COPY</span> <span class="n">testfile.txt</span> <span class="n">c</span><span class="o">:</span><span class="n">\</span>
 <span class="o">---&gt;</span> <span class="m">96655</span><span class="n">de338de</span>
<span class="n">Removing</span> <span class="n">intermediate</span> <span class="n">container</span> <span class="m">4</span><span class="n">db9acbb1682</span>
<span class="n">Step</span> <span class="m">3</span><span class="o">/</span><span class="m">3</span> <span class="o">:</span> <span class="n">RUN</span> <span class="n">dir</span> <span class="n">c</span><span class="o">:</span><span class="n">\</span>
 <span class="o">---&gt;</span> <span class="n">Running</span> <span class="n">in</span> <span class="n">a2c157f842f5</span>
 <span class="n">Volume</span> <span class="n">in</span> <span class="n">drive</span> <span class="n">C</span> <span class="n">has</span> <span class="n">no</span> <span class="n">label.</span>
 <span class="n">Volume</span> <span class="n">Serial</span> <span class="n">Number</span> <span class="n">is</span> <span class="m">7E6</span><span class="n">D</span><span class="o">-</span><span class="n">E0F7</span>

 <span class="n">Directory</span> <span class="n">of</span> <span class="n">c</span><span class="o">:</span><span class="n">\</span>

<span class="m">10</span><span class="o">/</span><span class="m">05</span><span class="o">/</span><span class="m">2016</span>  <span class="m">05</span><span class="o">:</span><span class="m">04</span> <span class="n">PM</span>             <span class="m">1</span><span class="p">,</span><span class="m">894</span> <span class="n">License.txt</span>
<span class="m">10</span><span class="o">/</span><span class="m">05</span><span class="o">/</span><span class="m">2016</span>  <span class="m">02</span><span class="o">:</span><span class="m">22</span> <span class="n">PM</span>    <span class="o">&lt;</span><span class="n">DIR</span><span class="o">&gt;</span>          <span class="n">Program</span> <span class="n">Files</span>
<span class="m">10</span><span class="o">/</span><span class="m">05</span><span class="o">/</span><span class="m">2016</span>  <span class="m">02</span><span class="o">:</span><span class="m">14</span> <span class="n">PM</span>    <span class="o">&lt;</span><span class="n">DIR</span><span class="o">&gt;</span>          <span class="n">Program</span> <span class="nf">Files </span><span class="p">(</span><span class="n">x86</span><span class="p">)</span>
<span class="m">10</span><span class="o">/</span><span class="m">28</span><span class="o">/</span><span class="m">2016</span>  <span class="m">11</span><span class="o">:</span><span class="m">18</span> <span class="n">AM</span>                <span class="m">62</span> <span class="n">testfile.txt</span>
<span class="m">10</span><span class="o">/</span><span class="m">28</span><span class="o">/</span><span class="m">2016</span>  <span class="m">11</span><span class="o">:</span><span class="m">20</span> <span class="n">AM</span>    <span class="o">&lt;</span><span class="n">DIR</span><span class="o">&gt;</span>          <span class="n">Users</span>
<span class="m">10</span><span class="o">/</span><span class="m">28</span><span class="o">/</span><span class="m">2016</span>  <span class="m">11</span><span class="o">:</span><span class="m">20</span> <span class="n">AM</span>    <span class="o">&lt;</span><span class="n">DIR</span><span class="o">&gt;</span>          <span class="n">Windows</span>
           <span class="m">2</span> <span class="nf">File</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>          <span class="m">1</span><span class="p">,</span><span class="m">956</span> <span class="n">bytes</span>
           <span class="m">4</span> <span class="nf">Dir</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="m">21</span><span class="p">,</span><span class="m">259</span><span class="p">,</span><span class="m">096</span><span class="p">,</span><span class="m">064</span> <span class="n">bytes</span> <span class="n">free</span>
 <span class="o">---&gt;</span> <span class="m">01</span><span class="n">c7f3bef04f</span>
<span class="n">Removing</span> <span class="n">intermediate</span> <span class="n">container</span> <span class="n">a2c157f842f5</span>
<span class="n">Successfully</span> <span class="n">built</span> <span class="m">01</span><span class="n">c7f3bef04f</span>
<span class="n">PS</span> <span class="n">C</span><span class="o">:</span><span class="n">\John</span><span class="o">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="环境更换environment-replacement">环境更换（Environment replacement）<a hidden class="anchor" aria-hidden="true" href="#环境更换environment-replacement">#</a></h2>
<p>环境变量（使用ENV语句声明）也可以在某些指令中用作Dockerfile要解释的变量。还会处理转义，以便将类似变量的语法包含在字面上。</p>
<p>使用<code>$variable_name</code>或<code>${variable_name}</code>在Dockerfile中标注环境变量。它们被等效地处理，并且括号语法通常用于解决具有没有空格的变量名称的问题，例如<code>${foo}_bar</code>。</p>
<ul>
<li><code>${variable_name}</code>语法还支持以下指定的一些标准bash修饰符：
<ul>
<li><code>${variable:-word}</code>表示如果设置了variable，那么结果将是该值。如果未设置variable，那么word将是结果。</li>
<li><code>${variable:+word}</code>表示如果设置了variable，那么word将是结果，否则结果是空字符串。</li>
</ul>
</li>
</ul>
<p>在所有情况下，word可以是任何字符串，包括其他环境变量。</p>
<p>可以通过在变量之前添加<code>\</code>来进行转义：<code>\$foo</code>或<code>\${foo}</code>，例如，将分别转换为<code>$foo</code>和<code>${foo}</code>文字。</p>
<p>示例（在<code>＃</code>之后显示解析的表示）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">FROM</span> <span class="n">busybox</span>
<span class="n">ENV</span> <span class="n">foo</span> <span class="o">/</span><span class="n">bar</span>
<span class="n">WORKDIR</span> <span class="o">$</span><span class="p">{</span><span class="n">foo</span><span class="p">}</span>   <span class="c1"># WORKDIR /bar</span>
<span class="n">ADD</span> <span class="n">. </span><span class="o">$</span><span class="n">foo</span>       <span class="c1"># ADD . /bar</span>
<span class="n">COPY</span> <span class="n">\</span><span class="o">$</span><span class="n">foo</span> <span class="o">/</span><span class="n">quux</span> <span class="c1"># COPY $foo /quux</span>
</code></pre></td></tr></table>
</div>
</div><p>Dockerfile中的以下指令列表支持环境变量：</p>
<ul>
<li>ADD</li>
<li>COPY</li>
<li>ENV</li>
<li>EXPOSE</li>
<li>FROM</li>
<li>LABEL</li>
<li>STOPSIGNAL</li>
<li>USER</li>
<li>VOLUME</li>
<li>WORKDIR</li>
</ul>
<p>以及：</p>
<ul>
<li>ONBUILD（当与上面支持的指令之一结合使用时）</li>
</ul>
<p>注意：在1.4之前，ONBUILD指令不支持环境变量，即使与上面列出的任何指令结合使用也是如此。</p>
<p>环境变量替换将在整个指令中对每个变量使用相同的值。 换句话说，在这个例子中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">ENV</span> <span class="n">abc</span><span class="o">=</span><span class="n">hello</span>
<span class="n">ENV</span> <span class="n">abc</span><span class="o">=</span><span class="n">bye</span> <span class="n">def</span><span class="o">=$</span><span class="n">abc</span>
<span class="n">ENV</span> <span class="n">ghi</span><span class="o">=$</span><span class="n">abc</span>
</code></pre></td></tr></table>
</div>
</div><p>将导致def具有hello值，而不是bye。但是，ghi将具有bye值，因为它不是将abc设置为bye的相同指令的一部分。</p>
<h2 id="dockerignore文件">.dockerignore文件<a hidden class="anchor" aria-hidden="true" href="#dockerignore文件">#</a></h2>
<p>在docker CLI将上下文发送到docker守护进程之前，它会在上下文的根目录中查找名为.dockerignore的文件。如果此文件存在，CLI将修改上下文以排除与其中的模式匹配的文件和目录。这有助于避免不必要地将大型或敏感文件和目录发送到守护进程，并可能使用ADD或COPY将它们添加到镜像。</p>
<p>CLI将.dockerignore文件解释为新行分隔的模式列表，类似于Unix shell的文件globs。出于匹配的目的，上下文的根被认为是工作目录和根目录。例如，模式 /foo/bar和foo/bar都会在PATH的foo子目录中或位于URL的git存储库的根目录中排除名为bar的文件或目录。两者都不包括任何其他内容。</p>
<p>如果.dockerignore文件中的一行的第1列以＃开头，则此行被视为注释，并在CLI解释之前被忽略。</p>
<p>这是一个示例.dockerignore文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="c"># comment</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">*/temp*</span><span class="w">
</span><span class="w"></span><span class="cp">*/*/temp*</span><span class="w">
</span><span class="w"></span><span class="l">temp?</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>此文件导致以下构建行为：</p>
<table>
<thead>
<tr>
<th>规则</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td># 注释</td>
<td>忽略</td>
</tr>
<tr>
<td><em>/temp</em></td>
<td>在根的任何直接子目录中排除名称以temp开头的文件和目录。 例如，排除普通文件/somedir/temporary.txt，目录/somedir/temp也是如此。</td>
</tr>
<tr>
<td><em>/</em>/temp*</td>
<td>从根目录下两级的任何子目录中排除以temp开头的文件和目录。 例如，排除了/somedir/subdir/temporary.txt。</td>
</tr>
<tr>
<td>temp?</td>
<td>排除根目录中的文件和目录，其名称是temp的单字符扩展。 例如，排除/tempa和/tempb。</td>
</tr>
</tbody>
</table>
<p>匹配是使用Go的filepath.Match规则完成的。 预处理步骤使用Go的filepath.Clean删除前导和尾随空格并消除. 和..元素。 预处理后为空行将被忽略。</p>
<p>除了Go的filepath.Match规则，Docker还支持一个特殊的通配符字符串<code>**</code>，它匹配任意数量的目录（包括零）。 例如，<code>**/*.go</code>将排除在所有目录中找到的以<code>.go</code>结尾的所有文件，包括构建上下文的根目录。</p>
<p>!（感叹号）开头的行可用于排除例外情况。 以下是使用此机制的示例.dockerignore文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="w">    </span><span class="cp">*.md</span><span class="w">
</span><span class="w">    </span>!<span class="l">README.md</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>除README.md之外的所有markdown文件都将从上下文中排除。</p>
<p>!例外规则的位置会影响行为：与特定文件匹配的.dockerignore的最后一行确定是包含还是排除。 请考虑以下示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="w">    </span><span class="cp">*.md</span><span class="w">
</span><span class="w">    </span>!<span class="l">README*.md</span><span class="w">
</span><span class="w">    </span><span class="l">README-secret.md</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>除了README-secret.md以外的README文件，上下文中不包含markdown文件。</p>
<p>现在考虑这个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yml" data-lang="yml"><span class="w">    </span><span class="cp">*.md</span><span class="w">
</span><span class="w">    </span><span class="l">README-secret.md</span><span class="w">
</span><span class="w">    </span>!<span class="l">README*.md</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>包含所有README文件。 中间行没有效果，因为<code>!README*.md</code>匹配<code>README-secret.md</code>并且是最后一个。</p>
<p>你甚至可以使用.dockerignore文件来排除Dockerfile和.dockerignore文件。 这些文件仍然发送到守护程序，因为它需要它们来完成它的工作。 但ADD和COPY指令不会将它们复制到镜像中。</p>
<p>最后，你可能希望指定要包含在上下文中的文件，而不是要排除的文件。 要实现此目的，请将*指定为第一个模式，然后指定一个或多个模式! 例外模式。</p>
<p>注意：由于历史原因，模式. 被忽略了。</p>
<h2 id="form-指定基础镜像">FORM 指定基础镜像<a hidden class="anchor" aria-hidden="true" href="#form-指定基础镜像">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">FROM</span> <span class="o">&lt;</span><span class="n">image</span><span class="o">&gt;</span> <span class="n">[AS</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="n">]</span>
</code></pre></td></tr></table>
</div>
</div><p>或</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">FROM</span> <span class="o">&lt;</span><span class="n">image</span><span class="o">&gt;</span><span class="n">[</span><span class="o">:&lt;</span><span class="n">tag</span><span class="o">&gt;</span><span class="n">]</span> <span class="n">[AS</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="n">]</span>
</code></pre></td></tr></table>
</div>
</div><p>或</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">FROM</span> <span class="o">&lt;</span><span class="n">image</span><span class="o">&gt;</span><span class="n">[</span><span class="o">@&lt;</span><span class="n">digest</span><span class="o">&gt;</span><span class="n">]</span> <span class="n">[AS</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="n">]</span>
</code></pre></td></tr></table>
</div>
</div><p>FROM指令初始化新的构建阶段并为后续指令设置基础镜像。因此，有效的Dockerfile必须以FROM指令开头。镜像可以是任何有效镜像 - 通过从公共存储库中提取镜像（pulling an image）来启动它尤其容易。</p>
<ul>
<li>
<p>ARG是Dockerfile中唯一可以在FROM之前的指令。请参阅了解ARG和FROM如何交互。</p>
</li>
<li>
<p>FROM可以在单个Dockerfile中多次出现以创建多个镜像，或者使用一个构建阶段作为另一个构建阶段的依赖项。只需在每个新的FROM指令之前记下提交输出的最后一个图像ID。每个FROM指令清除先前指令创建的任何状态。</p>
</li>
<li>
<p>通过将AS name添加到FROM指令，可以将可选的名称赋予新的构建阶段。该名称可以在后续的FROM和COPY &ndash;from=&lt;name|index&gt;指令中使用，以引用此阶段构建的镜像。</p>
</li>
<li>
<p>tag（标记）或digest（摘要）值是可选的。如果省略其中任何一个，则构建器默认采用latest（最新）标记。如果找不到tag值，构建器将返回错误。</p>
</li>
</ul>
<h3 id="了解arg和from如何互动">了解ARG和FROM如何互动<a hidden class="anchor" aria-hidden="true" href="#了解arg和from如何互动">#</a></h3>
<p>FROM指令支持在第一个FROM之前发生的任何ARG指令声明的变量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">ARG</span>  <span class="n">CODE_VERSION</span><span class="o">=</span><span class="n">latest</span>
<span class="n">FROM</span> <span class="n">base</span><span class="o">:$</span><span class="p">{</span><span class="n">CODE_VERSION</span><span class="p">}</span>
<span class="n">CMD</span>  <span class="o">/</span><span class="n">code</span><span class="o">/</span><span class="n">run</span><span class="o">-</span><span class="n">app</span>

<span class="n">FROM</span> <span class="n">extras</span><span class="o">:$</span><span class="p">{</span><span class="n">CODE_VERSION</span><span class="p">}</span>
<span class="n">CMD</span>  <span class="o">/</span><span class="n">code</span><span class="o">/</span><span class="n">run</span><span class="o">-</span><span class="n">extras</span>
</code></pre></td></tr></table>
</div>
</div><p>在FROM之前声明的ARG在构建阶段之外，因此在FROM之后的任何指令中都不能使用它。 要使用在第一个FROM之前声明的ARG的默认值，请在构建阶段内使用没有值的ARG指令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">ARG</span> <span class="n">VERSION</span><span class="o">=</span><span class="n">latest</span>
<span class="n">FROM</span> <span class="n">busybox</span><span class="o">:$</span><span class="n">VERSION</span>
<span class="n">ARG</span> <span class="n">VERSION</span>
<span class="n">RUN</span> <span class="n">echo</span> <span class="o">$</span><span class="n">VERSION</span> <span class="o">&gt;</span> <span class="n">image_version</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="run-执行命令">RUN 执行命令<a hidden class="anchor" aria-hidden="true" href="#run-执行命令">#</a></h2>
<p>RUN有两种形式：</p>
<ul>
<li><code>RUN &lt;command&gt;</code> (shell形式，运行在shell的命令, 在Linux上默认为/bin/sh -c或在Windows上为cmd /S /C)</li>
<li><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> (exec执行程序形式)</li>
</ul>
<p>RUN指令将在当前镜像之上的新层中执行任何命令并提交结果。 生成的已提交镜像将用于Dockerfile中的下一步。</p>
<p>分层的RUN指令和生成提交符合Docker的核心概念，其中提交很便宜，并且可以从镜像历史中的任何点创建容器，就像源代码控制一样。</p>
<p>exec（执行程序）形式可以避免shell字符串重写，并使用不包含指定shell可执行文件的基础镜像来运行RUN命令。</p>
<p>可以使用SHELL命令更改shell形式的默认shell。</p>
<p>在shell形式中，你可以使用\（反斜杠）将单个RUN指令继续到下一行。 例如，考虑以下两行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">RUN</span> <span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">bash</span> <span class="o">-</span><span class="n">c</span> <span class="s">&#39;</span><span class="err">source $HOME/.bashrc; \</span><span class="s">
</span><span class="s">echo $HOME&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>它们一起相当于这一行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">RUN</span> <span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">bash</span> <span class="o">-</span><span class="n">c</span> <span class="s">&#39;source $HOME/.bashrc; echo $HOME&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>注意：要使用除“/bin/sh”之外的其他shell，请使用传入所需shell的exec形式。例如，<code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code></p>
<p>注意：exec形式被解析为JSON数组，这意味着你必须使用双引号（&quot;）来围绕单词而不是单引号（’）。</p>
<p>注意：与shell形式不同，exec形式不会调用命令shell。这意味着不会发生正常的shell处理。例如，<code>RUN [ &quot;echo&quot;, &quot;$HOME&quot; ]</code>不会对<code>$HOME</code>执行变量替换。如果你想要shell处理，那么要么使用shell形式，要么直接执行shell，例如：<code>RUN [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code>。当使用exec形式并直接执行shell时，就像shell形式的情况一样，它是执行环境变量扩展的shell，而不是docker。</p>
<p>注意：在JSON表单中，必须转义反斜杠。这在反斜杠是路径分隔符的Windows上尤为重要。由于不是有效的JSON，以下行将被视为shell表单，并以意外方式失败：<code>RUN [&quot;c:\windows\system32\tasklist.exe&quot;]</code>。此示例的正确语法是：<code>RUN [&quot;c:\\windows\\system32\\tasklist.exe&quot;]</code></p>
<p>RUN指令的缓存在下一次​​构建期间不会自动失效。像<code>RUN apt-get dist-upgrade -y</code>这样的指令的缓存将在下一次构建期间重用。可以使用<code>--no-cache</code>标志使RUN指令的缓存无效，例如<code>docker build --no-cache</code>。</p>
<p>有关详细信息，请参阅Dockerfile最佳实践指南。</p>
<p>ADD指令可以使RUN指令的缓存无效。请参阅下文了解详情。</p>
<h3 id="cmd-设置默认命令">CMD 设置默认命令<a hidden class="anchor" aria-hidden="true" href="#cmd-设置默认命令">#</a></h3>
<p>CMD指令有三种形式：</p>
<ul>
<li><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> (exec形式，这是首选形式)</li>
<li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code> (作为ENTRYPOINT的默认参数)</li>
<li><code>CMD command param1 param2</code> (shell形式)</li>
</ul>
<p>Dockerfile中只能有一条CMD指令。如果列出多个CMD，则只有最后一个CMD才会生效。</p>
<p>CMD的主要目的是为正在执行的容器提供默认命令。这些默认命令可以包含可执行文件，也可以省略可执行文件，在这种情况下，你还必须指定ENTRYPOINT指令。</p>
<p>注意：如果使用CMD为ENTRYPOINT指令提供默认参数，则应使用JSON数组格式指定CMD和ENTRYPOINT指令。</p>
<p>注意：exec形式解析为JSON数组，这意味着你必须使用双引号（&quot;）来围绕单词而不是单引号（’）。</p>
<p>注意：与shell形式不同，exec形式不会调用命令shell。这意味着不会发生正常的shell处理。例如，<code>RUN [ &quot;echo&quot;, &quot;$HOME&quot; ]</code>不会对$HOME执行变量替换。如果你想要shell处理，那么要么使用shell形式，要么直接执行shell，例如：<code>RUN [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code>。当使用exec形式并直接执行shell时，就像shell形式的情况一样，它是执行环境变量扩展的shell，而不是docker。</p>
<p>在shell或exec格式中使用时，CMD指令设置运行镜像时要执行的命令。</p>
<p>如果你使用CMD的shell形式，那么<code>&lt;command&gt;</code>将在<code>/bin/sh -c</code>中执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">FROM</span> <span class="n">ubuntu</span>
<span class="n">CMD</span> <span class="n">echo</span> <span class="s">&#34;This is a test.&#34;</span> <span class="o">|</span> <span class="n">wc</span> <span class="o">-</span>
</code></pre></td></tr></table>
</div>
</div><p>如果要在没有shell的情况下运行<code>&lt;command&gt;</code>，则必须将该命令表示为JSON数组，并提供可执行文件的完整路径。 此数组形式是CMD的首选格式。 任何其他参数必须在数组中单独表示为字符串：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">FROM</span> <span class="n">ubuntu</span>
<span class="n">CMD</span> <span class="n">[</span><span class="s">&#34;/usr/bin/wc&#34;</span><span class="p">,</span><span class="s">&#34;--help&#34;</span><span class="n">]</span>
</code></pre></td></tr></table>
</div>
</div><p>如果你希望容器每次都运行相同的可执行文件，那么你应该考虑将ENTRYPOINT与CMD结合使用。 请参阅ENTRYPOINT。</p>
<p>如果用户指定了docker run的参数，那么它们将覆盖CMD中指定的默认命令。</p>
<p>注意：不要将RUN与CMD混淆。 RUN实际上运行一个命令并提交结果; CMD在构建时不执行任何操作，但指定了镜像的预期命令。</p>
<h2 id="label-设置标签">LABEL 设置标签<a hidden class="anchor" aria-hidden="true" href="#label-设置标签">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">LABEL</span> <span class="o">&lt;</span><span class="n">key</span><span class="o">&gt;=&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">key</span><span class="o">&gt;=&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">key</span><span class="o">&gt;=&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="kc">...</span>
</code></pre></td></tr></table>
</div>
</div><p>LABEL指令将元数据添加到镜像。 LABEL是键值对。 要在LABEL值中包含空格，请使用引号和反斜杠，就像在命令行解析中一样。 一些用法示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">LABEL</span> <span class="s">&#34;com.example.vendor&#34;</span><span class="o">=</span><span class="s">&#34;ACME Incorporated&#34;</span>
<span class="n">LABEL</span> <span class="n">com.example.label</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">value</span><span class="o">=</span><span class="s">&#34;foo&#34;</span>
<span class="n">LABEL</span> <span class="n">version</span><span class="o">=</span><span class="s">&#34;1.0&#34;</span>
<span class="n">LABEL</span> <span class="n">description</span><span class="o">=</span><span class="s">&#34;</span><span class="err">This text illustrates \</span><span class="s">
</span><span class="s">that label-values can span multiple lines.&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>镜像可以有多个标签。 你可以在一行中指定多个标签。 在Docker 1.10之前，这减小了最终镜像的大小，但现在不再是这种情况了。 你仍然可以选择在单个指令中指定多个标签，方法有以下两种：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">LABEL</span> <span class="n">multi.label1</span><span class="o">=</span><span class="s">&#34;value1&#34;</span> <span class="n">multi.label2</span><span class="o">=</span><span class="s">&#34;value2&#34;</span> <span class="n">other</span><span class="o">=</span><span class="s">&#34;value3&#34;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">LABEL</span> <span class="n">multi.label1</span><span class="o">=</span><span class="s">&#34;value1&#34;</span> <span class="n">\</span>
      <span class="n">multi.label2</span><span class="o">=</span><span class="s">&#34;value2&#34;</span> <span class="n">\</span>
      <span class="n">other</span><span class="o">=</span><span class="s">&#34;value3&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>基础或父镜像中包含的标签（FROM行中的镜像）由你的镜像继承。 如果标签已存在但具有不同的值，则最近适用的值将覆盖任何先前设置的值。</p>
<p>要查看镜像的标签，请使用docker inspect命令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="s">&#34;Labels&#34;</span><span class="o">:</span> <span class="p">{</span>
    <span class="s">&#34;com.example.vendor&#34;</span><span class="o">:</span> <span class="s">&#34;ACME Incorporated&#34;</span>
    <span class="s">&#34;com.example.label-with-value&#34;</span><span class="o">:</span> <span class="s">&#34;foo&#34;</span><span class="p">,</span>
    <span class="s">&#34;version&#34;</span><span class="o">:</span> <span class="s">&#34;1.0&#34;</span><span class="p">,</span>
    <span class="s">&#34;description&#34;</span><span class="o">:</span> <span class="s">&#34;This text illustrates that label-values can span multiple lines.&#34;</span><span class="p">,</span>
    <span class="s">&#34;multi.label1&#34;</span><span class="o">:</span> <span class="s">&#34;value1&#34;</span><span class="p">,</span>
    <span class="s">&#34;multi.label2&#34;</span><span class="o">:</span> <span class="s">&#34;value2&#34;</span><span class="p">,</span>
    <span class="s">&#34;other&#34;</span><span class="o">:</span> <span class="s">&#34;value3&#34;</span>
<span class="p">},</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="maintainer-设置作者deprecated已弃用">MAINTAINER 设置作者(deprecated已弃用)<a hidden class="anchor" aria-hidden="true" href="#maintainer-设置作者deprecated已弃用">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">MAINTAINER</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>MAINTAINER指令设置生成镜像的Author（作者）字段。 LABEL指令是一个更加灵活的版本，你应该使用它，因为它可以设置你需要的任何元数据，并且可以轻松查看，例如使用docker inspect。 要设置与MAINTAINER字段对应的标签，你可以使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">LABEL</span> <span class="n">maintainer</span><span class="o">=</span><span class="s">&#34;SvenDowideit@home.org.au&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>然后，这将通过docker inspect与其他标签一起显示。</p>
<h2 id="expose-声明端口">EXPOSE 声明端口<a hidden class="anchor" aria-hidden="true" href="#expose-声明端口">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">EXPOSE</span> <span class="o">&lt;</span><span class="n">port</span><span class="o">&gt;</span> <span class="n">[</span><span class="o">&lt;</span><span class="n">port</span><span class="o">&gt;/&lt;</span><span class="n">protocol</span><span class="o">&gt;</span><span class="kc">...</span><span class="n">]</span>
</code></pre></td></tr></table>
</div>
</div><p>EXPOSE指令通知Docker容器在运行时侦听指定的网络端口。 你可以指定端口是侦听TCP还是UDP，如果未指定协议，则默认为TCP。</p>
<p>EXPOSE指令实际上不发布端口。 它作为构建镜像的人和运行容器的人之间的一种文档，用于计划要发布的端口。 要在运行容器时实际发布端口，请在docker run上使用-p标志发布和映射一个或多个端口，或使用-P标志发布所有公开的端口并将它们映射到高阶(high-order)端口。</p>
<p>默认情况下，EXPOSE假定为TCP。 你还可以指定UDP：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">EXPOSE</span> <span class="m">80</span><span class="o">/</span><span class="n">udp</span>
</code></pre></td></tr></table>
</div>
</div><p>要同时公开TCP和UDP，请包含两行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">EXPOSE</span> <span class="m">80</span><span class="o">/</span><span class="n">tcp</span>
<span class="n">EXPOSE</span> <span class="m">80</span><span class="o">/</span><span class="n">udp</span>
</code></pre></td></tr></table>
</div>
</div><p>在这种情况下，如果将-P与docker run一起使用，则端口将针对TCP公开一次，针对UDP公开一次。 请记住，-P在主机上使用短暂的高阶主机端口，因此TCP和UDP的端口不同。</p>
<p>无论EXPOSE设置如何，你都可以使用-p标志在运行时覆盖它们。 例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">p</span> <span class="m">80</span><span class="o">:</span><span class="m">80</span><span class="o">/</span><span class="n">tcp</span> <span class="o">-</span><span class="n">p</span> <span class="m">80</span><span class="o">:</span><span class="m">80</span><span class="o">/</span><span class="n">udp</span>
</code></pre></td></tr></table>
</div>
</div><p>要在主机系统上设置端口重定向，请参阅使用-P标志。 docker network命令支持创建用于容器之间通信的网络，而无需公开或发布特定端口，因为连接到网络的容器可以通过任何端口相互通信。 有关详细信息，请参阅此功能的概述）。</p>
<h2 id="env-设置环境变量">ENV 设置环境变量<a hidden class="anchor" aria-hidden="true" href="#env-设置环境变量">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">ENV</span> <span class="o">&lt;</span><span class="n">key</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span>
<span class="n">ENV</span> <span class="o">&lt;</span><span class="n">key</span><span class="o">&gt;=&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="kc">...</span>
</code></pre></td></tr></table>
</div>
</div><p>ENV指令将环境变量<code>&lt;key&gt;</code>设置为值<code>&lt;value&gt;</code>。 此值将存在于构建阶段中所有后续指令的环境中，并且也可以在许多时候内部替换。</p>
<p>ENV指令有两种形式。</p>
<p>第一种形式<code>ENV &lt;key&gt; &lt;value&gt;</code>，将单个变量设置为一个值。 第一个空格后面的整个字符串将被视为<code>&lt;value&gt;</code> - 包括空格字符。 该值将针对其他环境变量进行解释，因此如果未对其进行转义，则将删除引号字符。</p>
<p>第二种形式ENV <code>&lt;key&gt;=&lt;value&gt; ...</code>允许一次设置多个变量。 请注意，第二种形式在语法中使用等号(=)，而第一种形式则不然。 与命令行解析一样，引号和反斜杠可用于在值内包含空格。</p>
<p>例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">ENV</span> <span class="n">myName</span><span class="o">=</span><span class="s">&#34;John Doe&#34;</span> <span class="n">myDog</span><span class="o">=</span><span class="n">Rex\</span> <span class="n">The\</span> <span class="n">Dog</span> <span class="n">\</span>
    <span class="n">myCat</span><span class="o">=</span><span class="n">fluffy</span>
</code></pre></td></tr></table>
</div>
</div><p>和</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">ENV</span> <span class="n">myName</span> <span class="n">John</span> <span class="n">Doe</span>
<span class="n">ENV</span> <span class="n">myDog</span> <span class="n">Rex</span> <span class="n">The</span> <span class="n">Dog</span>
<span class="n">ENV</span> <span class="n">myCat</span> <span class="n">fluffy</span>
</code></pre></td></tr></table>
</div>
</div><p>将在最终镜像中产生相同的净结果。</p>
<p>当从生成的镜像运行容器时，使用ENV设置的环境变量将保持不变。 你可以使用<code>docker inspect</code>查看值，并使用<code>docker run --env &lt;key&gt;=&lt;value&gt;</code>更改它们。</p>
<p>注意：环境变量持久性可能会导致意外的副作用。 例如，设置ENV DEBIAN_FRONTEND noninteractive可能会使基于Debian的镜像上的apt-get用户感到困惑。 要为单个命令设置值，请使用<code>RUN &lt;key&gt;=&lt;value&gt; &lt;command&gt;</code>。</p>
<h2 id="add-添加文件">ADD 添加文件<a hidden class="anchor" aria-hidden="true" href="#add-添加文件">#</a></h2>
<p>ADD有两种形式：</p>
<ul>
<li><code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></li>
<li><code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code> （这种形式要求包含空格的路径）</li>
</ul>
<p>注意：&ndash;chown功能仅在用于构建Linux容器的Dockerfiles上受支持，并且不适用于Windows容器。由于用户和组所有权概念不能在Linux和Windows之间进行转换，因此使用/etc/passwd和/etc/group将用户名和组名转换为ID会限制此功能仅适用于基于Linux OS的容器。</p>
<p>ADD指令从<code>&lt;src&gt;</code>复制新文件、目录或远程文件URL，并将它们添加到镜像的文件系统<code>&lt;dest&gt;</code>路径中。</p>
<p>可以指定多个<code>&lt;src&gt;</code>资源，但如果它们是文件或目录，则它们的路径将被解释为相对于构建上下文的源。</p>
<p>每个<code>&lt;src&gt;</code>可能包含通配符，匹配将使用Go的filepath.Match规则完成。 例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">ADD</span> <span class="n">hom</span><span class="o">*</span> <span class="o">/</span><span class="n">mydir</span><span class="o">/</span>        <span class="c1"># adds all files starting with &#34;hom&#34;</span>
<span class="n">ADD</span> <span class="n">hom</span><span class="o">?</span><span class="n">.txt</span> <span class="o">/</span><span class="n">mydir</span><span class="o">/</span>    <span class="c1"># ? is replaced with any single character, e.g., &#34;home.txt&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>&lt;dest&gt;</code>是绝对路径，或相对于WORKDIR的路径，源将在目标容器中复制到该路径中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">ADD</span> <span class="n">test</span> <span class="n">relativeDir</span><span class="o">/</span>          <span class="c1"># adds &#34;test&#34; to `WORKDIR`/relativeDir/</span>
<span class="n">ADD</span> <span class="n">test</span> <span class="o">/</span><span class="n">absoluteDir</span><span class="o">/</span>         <span class="c1"># adds &#34;test&#34; to /absoluteDir/</span>
</code></pre></td></tr></table>
</div>
</div><p>添加包含特殊字符（例如<code>[</code>和<code>]</code>）的文件或目录时，需要按照Golang规则转义这些路径，以防止它们被视为匹配模式。 例如，要添加名为arr[0].txt的文件，请使用以下命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">ADD</span> <span class="n">arr[[]0].txt</span> <span class="o">/</span><span class="n">mydir</span><span class="o">/</span>    <span class="c1"># copy a file named &#34;arr[0].txt&#34; to /mydir/</span>
</code></pre></td></tr></table>
</div>
</div><p>除非可选的<code>--chown</code>标志指定给定用户名、组名或UID/GID组合以请求添加内容的特定所有权，否则将使用UID和GID为0创建所有新文件和目录。 <code>--chown</code>标志的格式允许用户名和组名字符串或任意组合的直接整数UID和GID。 提供没有组名的用户名或没有GID的UID将使用与GID相同的数字UID。 如果提供了用户名或组名，则容器的根文件系统/etc/passwd和/etc/group文件将分别用于执行从名称到整数UID或GID的转换。 以下示例显示了&ndash;chown标志的有效定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">ADD</span> <span class="o">--</span><span class="n">chown</span><span class="o">=</span><span class="m">55</span><span class="o">:</span><span class="n">mygroup</span> <span class="n">files</span><span class="o">*/</span><span class="n">somedir</span><span class="o">/</span>
<span class="n">ADD</span> <span class="o">--</span><span class="n">chown</span><span class="o">=</span><span class="n">bin</span> <span class="n">files</span><span class="o">*</span> <span class="o">/</span><span class="n">somedir</span><span class="o">/</span>
<span class="n">ADD</span> <span class="o">--</span><span class="n">chown</span><span class="o">=</span><span class="m">1</span> <span class="n">files</span><span class="o">*/</span><span class="n">somedir</span><span class="o">/</span>
<span class="n">ADD</span> <span class="o">--</span><span class="n">chown</span><span class="o">=</span><span class="m">10</span><span class="o">:</span><span class="m">11</span> <span class="n">files</span><span class="o">*</span> <span class="o">/</span><span class="n">somedir</span><span class="o">/</span>
</code></pre></td></tr></table>
</div>
</div><p>如果容器根文件系统不包含/etc/passwd或/etc/group文件，并且在&ndash;chown标志中使用了用户名或组名，则构建将在ADD操作上失败。使用数字ID不需要查找，也不依赖于容器根文件系统内容。</p>
<p>在<code>&lt;src&gt;</code>是远程文件URL的情况下，目标将具有600的权限。如果正在检索的远程文件具有HTTP Last-Modified头，则该头的时间戳将用于设置目标上的mtime。文件。但是，与ADD期间处理的任何其他文件一样，mtime将不包含在确定文件是否已更改且应更新缓存中。</p>
<p>注意：如果通过将Dockerfile传递给STDIN（<code>docker build - &lt; somefile</code>）来构建，则没有构建上下文，因此Dockerfile只能包含基于URL的ADD指令。你还可以通过STDIN传递压缩存档：（<code>docker build - &lt; archive.tar.gz</code>），Dockerfile在存档根目录下，存档的其余部分将用作构建的上下文。</p>
<p>注意：如果你的URL文件使用身份验证进行保护，则需要使用RUN wget，RUN curl或使用容器内的其他工具，因为ADD指令不支持身份验证。</p>
<p>注意：如果<code>&lt;src&gt;</code>的内容已更改，则第一个遇到的ADD指令将使来自Dockerfile的所有后续指令的缓存无效。这包括使RUN指令的缓存无效。有关详细信息，请参阅Dockerfile最佳实践指南。</p>
<p>ADD遵守以下规则：</p>
<ul>
<li>
<p><code>&lt;src&gt;</code>路径必须位于构建的上下文中；你不能ADD ../something/something，因为docker构建的第一步是将上下文目录（和子目录）发送到docker守护进程。</p>
</li>
<li>
<p>如果<code>&lt;src&gt;</code>是URL且<code>&lt;dest&gt;</code>不以尾部斜杠结尾，则从URL下载文件并将其复制到<code>&lt;dest&gt;</code>。</p>
</li>
<li>
<p>如果<code>&lt;src&gt;</code>是URL并且<code>&lt;dest&gt;</code>以尾部斜杠结尾，则从URL推断文件名，并将文件下载到<code>&lt;dest&gt;/&lt;filename&gt;</code>。例如，<code>ADD &lt;http://example.com/foobar&gt; /</code>将创建文件/foobar。 URL必须具有有意义的路径，以便在这种情况下可以发现适当的文件名（<code>http://example.com</code>将不起作用）。</p>
</li>
<li>
<p>如果<code>&lt;src&gt;</code>是目录，则复制目录的全部内容，包括文件系统元数据。
注意：不复制目录本身，只复制其内容。</p>
</li>
<li>
<p>如果<code>&lt;src&gt;</code>是可识别的压缩格式（identity、gzip、bzip2或xz）的本地tar存档，则将其解压缩为目录。远程URL中的资源不解压缩。复制或解压缩目录时，它与tar -x具有相同的行为，结果是：</p>
<ol>
<li>无论在目的地路径上存在什么，</li>
<li>源目录树的内容，在逐个文件的基础上解决有利于“2.”的冲突。
注意：文件是否被识别为可识别的压缩格式仅基于文件的内容而不是文件的名称来完成。例如，如果空文件恰好以.tar.gz结尾，则不会将其识别为压缩文件，也不会生成任何类型的解压缩错误消息，而是将文件简单地复制到目标。</li>
</ol>
</li>
<li>
<p>如果<code>&lt;src&gt;</code>是任何其他类型的文件，则将其与元数据一起单独复制。在这种情况下，如果<code>&lt;dest&gt;</code>以尾部斜杠/结束，则将其视为目录，<code>&lt;src&gt;</code>的内容将写入<code>&lt;dest&gt;/base(&lt;src&gt;)</code>。</p>
</li>
<li>
<p>如果直接或由于使用通配符指定了多个<code>&lt;src&gt;</code>资源，则<code>&lt;dest&gt;</code>必须是目录，并且必须以斜杠/结尾。</p>
</li>
<li>
<p>如果<code>&lt;dest&gt;</code>不以尾部斜杠结束，则它将被视为常规文件，<code>&lt;src&gt;</code>的内容将写入<code>&lt;dest&gt;</code>。</p>
</li>
<li>
<p>如果<code>&lt;dest&gt;</code>不存在，则会在其路径中创建所有缺少的目录。</p>
</li>
</ul>
<h2 id="copy-复制文件add的简化版能用copy就不用add">COPY 复制文件（ADD的简化版，能用COPY就不用ADD）<a hidden class="anchor" aria-hidden="true" href="#copy-复制文件add的简化版能用copy就不用add">#</a></h2>
<p>COPY有两种形式：</p>
<ul>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></li>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code>（这种形式要求包含空格的路径）</li>
</ul>
<p>注意：<code>--chown</code>功能仅在用于构建Linux容器的Dockerfiles上受支持，并且不适用于Windows容器。 由于用户和组所有权概念不能在Linux和Windows之间进行转换，因此使用<code>/etc/passwd</code>和<code>/etc/group</code>将用户名和组名转换为ID会限制此功能仅适用于基于Linux OS的容器。</p>
<p>COPY指令从<code>&lt;src&gt;</code>复制新文件或目录，并将它们添加到容器的文件系统的<code>&lt;dest&gt;</code>路径中。</p>
<p>可以指定多个<code>&lt;src&gt;</code>资源，但文件和目录的路径将被解释为相对于构建上下文的源。</p>
<p>每个<!-- raw HTML omitted -->可能包含通配符，匹配将使用Go的filepath.Match规则完成。 例如：</p>
<p>COPY hom* /mydir/        # adds all files starting with &ldquo;hom&rdquo;
COPY hom?.txt /mydir/    # ? is replaced with any single character, e.g., &ldquo;home.txt&rdquo;
1
2
<!-- raw HTML omitted -->是绝对路径，或相对于WORKDIR的路径，源将在目标容器中复制到该路径中。</p>
<p>COPY test relativeDir/   # adds &ldquo;test&rdquo; to <code>WORKDIR</code>/relativeDir/
COPY test /absoluteDir/  # adds &ldquo;test&rdquo; to /absoluteDir/
1
2
添加包含特殊字符（例如[和]）的文件或目录时，需要按照Golang规则转义这些路径，以防止它们被视为匹配模式。 例如，要添加名为arr[0].txt的文件，请使用以下命令：</p>
<p>COPY arr[[]0].txt /mydir/    # copy a file named &ldquo;arr[0].txt&rdquo; to /mydir/
1
除非可选的&ndash;chown标志指定给定用户名、组名或UID/GID组合以请求添加内容的特定所有权，否则将使用UID和GID为0创建所有新文件和目录。 &ndash;chown标志的格式允许用户名和组名字符串或任意组合的直接整数UID和GID。 提供没有组名的用户名或没有GID的UID将使用与GID相同的数字UID。 如果提供了用户名或组名，则容器的根文件系统/etc/passwd和/etc/group文件将分别用于执行从名称到整数UID或GID的转换。 以下示例显示了&ndash;chown标志的有效定义：</p>
<p>COPY &ndash;chown=55:mygroup files*/somedir/
COPY &ndash;chown=bin files* /somedir/
COPY &ndash;chown=1 files*/somedir/
COPY &ndash;chown=10:11 files* /somedir/
1
2
3
4
如果容器根文件系统不包含/etc/passwd或/etc/group文件，并且在&ndash;chown标志中使用了用户名或组名，则构建将在COPY操作上失败。使用数字ID不需要查找，也不依赖于容器根文件系统内容。</p>
<p>注意：如果通过将Dockerfile传递给STDIN（docker build - &lt; somefile）来构建，则没有构建上下文，因此COPY不能使用。</p>
<p>COPY接受一个可选标志&ndash;from=&lt;name|index&gt;，可用于将源位置设置为先前的构建阶段（使用FROM .. AS <!-- raw HTML omitted -->创建），而不是由用户发送的构建上下文。该标志还接受使用FROM指令启动的所有先前构建阶段分配的数字索引。如果找不到具有指定名称的构建阶段，则尝试使用具有相同名称的镜像。</p>
<p>COPY遵守以下规则：</p>
<p><!-- raw HTML omitted -->路径必须位于构建的上下文中；你不能COPY ../something/something，因为docker build的第一步是将上下文目录（和子目录）发送到docker守护进程。</p>
<p>如果<!-- raw HTML omitted -->是目录，则复制目录的全部内容，包括文件系统元数据。</p>
<p>注意：不复制目录本身，只复制其内容。</p>
<p>如果<!-- raw HTML omitted -->是任何其他类型的文件，则将其与元数据一起单独复制。在这种情况下，如果<!-- raw HTML omitted -->以尾部斜杠/结束，则将其视为目录，<!-- raw HTML omitted -->的内容将写入<!-- raw HTML omitted -->/base(<!-- raw HTML omitted -->)。</p>
<p>如果直接或由于使用通配符指定了多个<!-- raw HTML omitted -->资源，则<!-- raw HTML omitted -->必须是目录，并且必须以斜杠/结尾。</p>
<p>如果<!-- raw HTML omitted -->不以尾部斜杠结束，则它将被视为常规文件，<!-- raw HTML omitted -->的内容将写入<!-- raw HTML omitted -->。</p>
<p>如果<!-- raw HTML omitted -->不存在，则会在其路径中创建所有缺少的目录。</p>
<p>ENTRYPOINT 配置容器入口点
ENTRYPOINT有两种形式:</p>
<p>ENTRYPOINT [&ldquo;executable&rdquo;, &ldquo;param1&rdquo;, &ldquo;param2&rdquo;] (exec形式, 首选)
ENTRYPOINT command param1 param2 (shell形式)
ENTRYPOINT允许你配置将作为可执行文件运行的容器。</p>
<p>例如，以下将使用其默认内容启动nginx，侦听端口80：</p>
<p>docker run -i -t &ndash;rm -p 80:80 nginx
1
docker run <!-- raw HTML omitted -->的命令行参数将在exec中的所有元素形成ENTRYPOINT后附加，并将覆盖使用CMD指定的所有元素。这允许将参数传递给入口点，即docker run <!-- raw HTML omitted --> -d将-d参数传递给入口点。你可以使用docker run &ndash;entrypoint标志覆盖ENTRYPOINT指令。</p>
<p>shell形式阻止使用任何CMD或run命令行参数，但缺点是ENTRYPOINT将作为/bin/sh -c的子命令启动，它不传递信号。这意味着可执行程序不是容器的PID 1 - 并且不会接收Unix信号 - 因此你的可执行程序将不会从docker stop <!-- raw HTML omitted -->接收SIGTERM。</p>
<p>只有Dockerfile中的最后一个ENTRYPOINT指令才会生效。</p>
<p>Exec形式ENTRYPOINT示例
你可以使用ENTRYPOINT的exec形式设置相当稳定的默认命令和参数，然后使用任一形式的CMD来设置更可能更改的其他默认值。</p>
<p>FROM ubuntu
ENTRYPOINT [&ldquo;top&rdquo;, &ldquo;-b&rdquo;]
CMD [&quot;-c&quot;]
1
2
3
运行容器时，你可以看到top是唯一的进程：</p>
<p>$ docker run -it &ndash;rm &ndash;name test  top -H
top - 08:25:00 up  7:27,  0 users,  load average: 0.00, 0.01, 0.05
Threads:   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem:   2056668 total,  1616832 used,   439836 free,    99352 buffers
KiB Swap:  1441840 total,        0 used,  1441840 free.  1324440 cached Mem</p>
<p>PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
1 root      20   0   19744   2336   2080 R  0.0  0.1   0:00.04 top
1
2
3
4
5
6
7
8
9
要进一步检查结果，可以使用docker exec：</p>
<p>$ docker exec -it test ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  2.6  0.1  19752  2352 ?        Ss+  08:24   0:00 top -b -H
root         7  0.0  0.1  15572  2164 ?        R+   08:25   0:00 ps aux
1
2
3
4
并且你可以优雅地请求使用docker stop test来关闭top。</p>
<p>以下Dockerfile显示使用ENTRYPOINT在前台运行Apache（即，作为PID 1）：</p>
<p>FROM debian:stable
RUN apt-get update &amp;&amp; apt-get install -y &ndash;force-yes apache2
EXPOSE 80 443
VOLUME [&quot;/var/www&quot;, &ldquo;/var/log/apache2&rdquo;, &ldquo;/etc/apache2&rdquo;]
ENTRYPOINT [&quot;/usr/sbin/apache2ctl&quot;, &ldquo;-D&rdquo;, &ldquo;FOREGROUND&rdquo;]
1
2
3
4
5
如果需要为单个可执行文件编写启动脚本，可以使用exec和gosu命令确保最终的可执行文件接收Unix信号：</p>
<h1 id="usrbinenv-bash">!/usr/bin/env bash<a hidden class="anchor" aria-hidden="true" href="#usrbinenv-bash">#</a></h1>
<p>set -e</p>
<p>if [ &ldquo;$1&rdquo; = &lsquo;postgres&rsquo; ]; then
chown -R postgres &ldquo;$PGDATA&rdquo;</p>
<pre><code>if [ -z &quot;$(ls -A &quot;$PGDATA&quot;)&quot; ]; then
    gosu postgres initdb
fi

exec gosu postgres &quot;$@&quot;
</code></pre>
<p>fi</p>
<p>exec &ldquo;$@&rdquo;
1
2
3
4
5
6
7
8
9
10
11
12
13
14
最后，如果你需要在关机时进行一些额外的清理（或与其他容器通信），或者协调多个可执行文件，你可能需要确保ENTRYPOINT脚本接收Unix信号，传递它们，然后做一些工作：</p>
<h1 id="binsh">!/bin/sh<a hidden class="anchor" aria-hidden="true" href="#binsh">#</a></h1>
<h1 id="note-ive-written-this-using-sh-so-it-works-in-the-busybox-container-too">Note: I&rsquo;ve written this using sh so it works in the busybox container too<a hidden class="anchor" aria-hidden="true" href="#note-ive-written-this-using-sh-so-it-works-in-the-busybox-container-too">#</a></h1>
<h1 id="use-the-trap-if-you-need-to-also-do-manual-cleanup-after-the-service-is-stopped">USE the trap if you need to also do manual cleanup after the service is stopped<a hidden class="anchor" aria-hidden="true" href="#use-the-trap-if-you-need-to-also-do-manual-cleanup-after-the-service-is-stopped">#</a></h1>
<h1 id="or-need-to-start-multiple-services-in-the-one-container">or need to start multiple services in the one container<a hidden class="anchor" aria-hidden="true" href="#or-need-to-start-multiple-services-in-the-one-container">#</a></h1>
<p>trap &ldquo;echo TRAPed signal&rdquo; HUP INT QUIT TERM</p>
<h1 id="start-service-in-background-here">start service in background here<a hidden class="anchor" aria-hidden="true" href="#start-service-in-background-here">#</a></h1>
<p>/usr/sbin/apachectl start</p>
<p>echo &ldquo;[hit enter key to exit] or run &lsquo;docker stop <!-- raw HTML omitted -->'&rdquo;
read</p>
<h1 id="stop-service-and-clean-up-here">stop service and clean up here<a hidden class="anchor" aria-hidden="true" href="#stop-service-and-clean-up-here">#</a></h1>
<p>echo &ldquo;stopping apache&rdquo;
/usr/sbin/apachectl stop</p>
<p>echo &ldquo;exited $0&rdquo;
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
如果使用docker run -it &ndash;rm -p 80:80 &ndash;name test apache运行此镜像，则可以使用docker exec或docker top检查容器的进程，然后让脚本停止Apache：</p>
<p>$ docker exec -it test ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.1  0.0   4448   692 ?        Ss+  00:42   0:00 /bin/sh /run.sh 123 cmd cmd2
root        19  0.0  0.2  71304  4440 ?        Ss   00:42   0:00 /usr/sbin/apache2 -k start
www-data    20  0.2  0.2 360468  6004 ?        Sl   00:42   0:00 /usr/sbin/apache2 -k start
www-data    21  0.2  0.2 360468  6000 ?        Sl   00:42   0:00 /usr/sbin/apache2 -k start
root        81  0.0  0.1  15572  2140 ?        R+   00:44   0:00 ps aux
$ docker top test
PID                 USER                COMMAND
10035               root                {run.sh} /bin/sh /run.sh 123 cmd cmd2
10054               root                /usr/sbin/apache2 -k start
10055               33                  /usr/sbin/apache2 -k start
10056               33                  /usr/sbin/apache2 -k start
$ /usr/bin/time docker stop test
test
real	0m 0.27s
user	0m 0.03s
sys		0m 0.03s
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
注意：你可以使用&ndash;entrypoint覆盖ENTRYPOINT设置，但这只能将二进制设置为exec（不会使用sh -c）。</p>
<p>注意：exec形式被解析为JSON数组，这意味着你必须使用双引号（&quot;）来围绕单词而不是单引号（’）。</p>
<p>注意：与shell形式不同，exec形式不会调用命令shell。这意味着不会发生正常的shell处理。例如，ENTRYPOINT [ &ldquo;echo&rdquo;, &ldquo;$HOME&rdquo; ]不会对$HOME执行变量替换。如果你想要shell处理，那么要么使用shell形式，要么直接执行shell，例如：ENTRYPOINT [ &ldquo;sh&rdquo;, &ldquo;-c&rdquo;, &ldquo;echo $HOME&rdquo; ]。当使用exec形式并直接执行shell时，就像shell形式的情况一样，它是执行环境变量扩展的shell，而不是docker。</p>
<p>Shell形式ENTRYPOINT示例
你可以为ENTRYPOINT指定一个纯字符串，它将在/bin/sh -c中执行。这种形式将使用shell处理来替换shell环境变量，并将忽略任何CMD或docker run命令行参数。要确保docker stop能正确发信号给任何长时间运行的ENTRYPOINT可执行文件，你需要记住用exec启动它：</p>
<p>FROM ubuntu
ENTRYPOINT exec top -b
1
2
运行此镜像时，你将看到单个PID 1进程：</p>
<p>$ docker run -it &ndash;rm &ndash;name test top
Mem: 1704520K used, 352148K free, 0K shrd, 0K buff, 140368121167873K cached
CPU:   5% usr   0% sys   0% nic  94% idle   0% io   0% irq   0% sirq
Load average: 0.08 0.03 0.05 2/98 6
PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND
1     0 root     R     3164   0%   0% top -b
1
2
3
4
5
6
在docker stop时干净地退出：</p>
<p>$ /usr/bin/time docker stop test
test
real	0m 0.20s
user	0m 0.02s
sys	0m 0.04s
1
2
3
4
5
如果你忘记将exec添加到ENTRYPOINT的开头：</p>
<p>FROM ubuntu
ENTRYPOINT top -b
CMD &ndash;ignored-param1
1
2
3
然后，你可以运行它（为了下一步给个名字）：</p>
<p>$ docker run -it &ndash;name test top &ndash;ignored-param2
Mem: 1704184K used, 352484K free, 0K shrd, 0K buff, 140621524238337K cached
CPU:   9% usr   2% sys   0% nic  88% idle   0% io   0% irq   0% sirq
Load average: 0.01 0.02 0.05 2/101 7
PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND
1     0 root     S     3168   0%   0% /bin/sh -c top -b cmd cmd2
7     1 root     R     3164   0%   0% top -b
1
2
3
4
5
6
7
你可以从top的输出中看到指定的ENTRYPOINT不是PID 1。</p>
<p>如果运行docker stop test，容器将不会干净地退出 - stop命令将被强制在超时后发送SIGKILL：</p>
<p>$ docker exec -it test ps aux
PID   USER     COMMAND
1 root     /bin/sh -c top -b cmd cmd2
7 root     top -b
8 root     ps aux
$ /usr/bin/time docker stop test
test
real	0m 10.19s
user	0m 0.04s
sys	0m 0.03s
1
2
3
4
5
6
7
8
9
10
了解CMD和ENTRYPOINT如何相互作用
CMD和ENTRYPOINT指令都定义了运行容器时执行的命令。 这里有点规则描述他们之间的合作。</p>
<p>Dockerfile应至少指定一个CMD或ENTRYPOINT命令。
使用容器作为可执行文件时，应定义ENTRYPOINT。
CMD应该用作为ENTRYPOINT命令定义默认参数或在容器中执行特定命令的方法。
使用备用参数运行容器时，将覆盖CMD。
下表显示了针对不同ENTRYPOINT / CMD组合执行的命令：</p>
<p>No ENTRYPOINT	ENTRYPOINT exec_entry p1_entry	ENTRYPOINT [“exec_entry”, “p1_entry”]
No CMD	error, not allowed	/bin/sh -c exec_entry p1_entry	exec_entry p1_entry
CMD [“exec_cmd”, “p1_cmd”]	exec_cmd p1_cmd	/bin/sh -c exec_entry p1_entry	exec_entry p1_entry exec_cmd p1_cmd
CMD [“p1_cmd”, “p2_cmd”]	p1_cmd p2_cmd	/bin/sh -c exec_entry p1_entry	exec_entry p1_entry p1_cmd p2_cmd
CMD exec_cmd p1_cmd	/bin/sh -c exec_cmd p1_cmd	/bin/sh -c exec_entry p1_entry	exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd
VOLUME 创建外部卷
VOLUME [&quot;/data&quot;]
1
VOLUME指令创建具有指定名称的安装点，并将其标记为从本机主机或其他容器保存外部安装的卷。 该值可以是JSON数组，VOLUME [&quot;/var/log/&quot;]或具有多个参数的纯字符串，例如VOLUME /var/log 或 VOLUME /var/log /var/db。 有关通过Docker客户端提供的更多信息/示例和安装说明，请参阅通过卷共享目录文档。</p>
<p>docker run命令使用基础镜像中指定位置存在的任何数据初始化新创建的卷。 例如，请考虑以下Dockerfile片段：</p>
<p>FROM ubuntu
RUN mkdir /myvol
RUN echo &ldquo;hello world&rdquo; &gt; /myvol/greeting
VOLUME /myvol
1
2
3
4
此Dockerfile会生成一个镜像，该镜像会导致docker run在/myvol上创建新的挂载点，并将greeting文件复制到新创建的卷中。</p>
<p>有关指定卷的说明
关于Dockerfile中的卷，请记住以下事项。</p>
<p>基于Windows容器上的卷：使用基于Windows的容器时，容器中卷的目标必须是以下之一：
不存在或空目录
C:以外的驱动器：
从Dockerfile中更改卷：如果任何构建步骤在声明后更改卷内的数据，那么这些更改将被丢弃。
JSON格式：列表被解析为JSON数组。你必须用双引号（&quot;）而不是单引号（’）括起来。
主机目录在容器运行时声明：主机目录（挂载点）本质上是依赖于主机的。这是为了保持镜像的可移植性，因为不能保证给定的主机目录在所有主机上都可用。因此，你无法从Dockerfile中挂载主机目录。 VOLUME指令不支持指定host-dir参数。你必须在创建或运行容器时指定挂载点。
USER 设置当前用户
USER <!-- raw HTML omitted -->[:<!-- raw HTML omitted -->] or
USER <!-- raw HTML omitted -->[:<!-- raw HTML omitted -->]
1
2
USER指令设置用户名（或UID）以及可选的用户组（或GID），以便在运行镜像时以及Dockerfile中跟随它的任何RUN、CMD和ENTRYPOINT指令时使用。</p>
<p>警告：当用户没有主组时，将使用root组运行镜像（或下一条指令）。</p>
<p>在Windows上，如果用户不是内置帐户，则必须先创建用户。 这可以使用作为Dockerfile一部分调用的net user命令来完成。</p>
<pre><code>FROM microsoft/windowsservercore
# Create Windows user in the container
RUN net user /add patrick
# Set it for subsequent commands
USER patrick
</code></pre>
<p>1
2
3
4
5
WORKDIR 设置工作目录
WORKDIR /path/to/workdir
1
WORKDIR指令为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。 如果WORKDIR不存在，即使它未在任何后续Dockerfile指令中使用，也将创建它。</p>
<p>WORKDIR指令可以在Dockerfile中多次使用。 如果提供了相对路径，则它将相对于先前WORKDIR指令的路径。 例如：</p>
<p>WORKDIR /a
WORKDIR b
WORKDIR c
RUN pwd
1
2
3
4
此Dockerfile中最终pwd命令的输出为/a/b/c。</p>
<p>WORKDIR指令可以解析先前使用ENV设置的环境变量。 你只能使用Dockerfile中显式设置的环境变量。 例如：</p>
<p>ENV DIRPATH /path
WORKDIR $DIRPATH/$DIRNAME
RUN pwd
1
2
3
此Dockerfile中最后一个pwd命令的输出将是/path/$DIRNAME。</p>
<p>ARG 构建参数
ARG <!-- raw HTML omitted -->[=<!-- raw HTML omitted -->]
1
ARG指令使用&ndash;build-arg <!-- raw HTML omitted -->=<!-- raw HTML omitted -->标志定义一个变量，用户可以使用docker build命令在构建时将该变量传递给构建器。如果用户指定了未在Dockerfile中定义的构建参数，则构建会输出警告。</p>
<p>[Warning] One or more build-args [foo] were not consumed.
1
Dockerfile可以包括一个或多个ARG指令。 例如，以下是有效的Dockerfile：</p>
<p>FROM busybox
ARG user1
ARG buildno
&hellip;
1
2
3
4
警告：建议不要使用构建时变量来传递密码，例如github密钥、用户凭据等。使用docker history命令，任何图像用户都可以看到构建时变量值。</p>
<p>Default values 默认值
ARG指令可以包含可选的默认值：</p>
<p>FROM busybox
ARG user1=someuser
ARG buildno=1
&hellip;
1
2
3
4
如果ARG指令具有默认值，并且在构建时没有传递值，则构建器将使用默认值。</p>
<p>Scope 作用域
ARG变量定义从Dockerfile中定义的行开始生效，而不是从命令行或其他地方的参数使用时才生效。 例如，考虑这个Dockerfile：</p>
<p>1 FROM busybox
2 USER ${user:-some_user}
3 ARG user
4 USER $user
&hellip;
1
2
3
4
5
用户通过调用以下内容构建此文件：</p>
<p>$ docker build &ndash;build-arg user=what_user .
1
第2行的USER设值为some_user，因为在后续第3行才定义了用户变量。第4行的USER在定义用户时设值为what_user，并在命令行上传递what_user值。 在通过ARG指令定义之前，对变量的任何使用都会导致空字符串。</p>
<p>ARG指令在构建阶段结束时超出作用域。 要在多个阶段中使用arg，每个阶段必须包含ARG指令。</p>
<p>FROM busybox
ARG SETTINGS
RUN ./run/setup $SETTINGS</p>
<p>FROM busybox
ARG SETTINGS
RUN ./run/other $SETTINGS
1
2
3
4
5
6
7
Using ARG variables 使用参数变量
你可以使用ARG或ENV指令指定RUN指令可用的变量。 使用ENV指令定义的环境变量始终覆盖同名的ARG指令。 考虑这个带有ENV和ARG指令的Dockerfile。</p>
<p>1 FROM ubuntu
2 ARG CONT_IMG_VER
3 ENV CONT_IMG_VER v1.0.0
4 RUN echo $CONT_IMG_VER
1
2
3
4
然后，假设使用此命令构建此镜像：</p>
<p>$ docker build &ndash;build-arg CONT_IMG_VER=v2.0.1 .
1
在这种情况下，RUN指令使用v1.0.0而不是用户传递的ARG设置：v2.0.1。此行为类似于shell脚本，其中本地作用域的变量会覆盖作为参数传递或从定义点继承的环境变量， 。</p>
<p>使用上面的示例，但不同的ENV规范，你可以在ARG和ENV指令之间创建更有用的交互：</p>
<p>1 FROM ubuntu
2 ARG CONT_IMG_VER
3 ENV CONT_IMG_VER ${CONT_IMG_VER:-v1.0.0}
4 RUN echo $CONT_IMG_VER
1
2
3
4
与ARG指令不同，ENV值始终保留在构建的镜像中。 考虑没有&ndash;build-arg标志的docker构建：</p>
<p>$ docker build .
1
使用此Dockerfile示例，CONT_IMG_VER仍然保留在镜像中，但其值为v1.0.0，因为它是ENV指令在第3行中的默认设置。</p>
<p>此示例中的变量扩展技术允许你从命令行传递参数，并通过利用ENV指令将它们保存在最终镜像中。 只有一组有限的Dockerfile指令支持变量扩展。</p>
<p>Predefined ARGs 预定义的ARG
Docker有一组预定义的ARG变量，你可以在Dockerfile中使用而无需相应的ARG指令。</p>
<p>HTTP_PROXY
http_proxy
HTTPS_PROXY
https_proxy
FTP_PROXY
ftp_proxy
NO_PROXY
no_proxy
要使用它们，只需使用标志在命令行上传递它们：</p>
<p>&ndash;build-arg <!-- raw HTML omitted -->=<!-- raw HTML omitted -->
1
默认情况下，这些预定义变量将从docker history的输出中排除。 排除它们可降低在HTTP_PROXY变量中意外泄露敏感验证信息的风险。</p>
<p>例如，考虑使用&ndash;build-arg HTTP_PROXY=<a href="http://user:pass@proxy.lon.example.com%E6%9E%84%E5%BB%BA%E4%BB%A5%E4%B8%8BDockerfile">http://user:pass@proxy.lon.example.com构建以下Dockerfile</a></p>
<p>FROM ubuntu
RUN echo &ldquo;Hello World&rdquo;
1
2
在这种情况下，HTTP_PROXY变量的值在docker history中不可用，并且不会被缓存。 如果要更改位置，并且代理服务器已更改为<a href="http://user:pass@proxy.sfo.example.com">http://user:pass@proxy.sfo.example.com</a>，则后续构建不会导致缓存未命中。</p>
<p>如果你需要覆盖此行为，则可以通过在Dockerfile中添加ARG语句来执行此操作，如下所示：</p>
<p>FROM ubuntu
ARG HTTP_PROXY
RUN echo &ldquo;Hello World&rdquo;
1
2
3
构建此Dockerfile时，HTTP_PROXY将保留在docker history中，并且更改其值会使构建缓存无效。</p>
<p>Inpact on build caching 对构建缓存的影响
ARG变量不会像ENV变量那样持久存储到构建的镜像中。 但是，ARG变量会以类似的方式影响构建缓存。 如果Dockerfile定义了一个值与先前版本不同的ARG变量，那么在第一次使用时会发生“缓存未命中”，而不是其定义。 特别是，ARG指令之后的所有RUN指令都隐式使用ARG变量（作为环境变量），因此可能导致缓存未命中。 除非Dockerfile中存在匹配的ARG语句，否则所有预定义的ARG变量都将免于缓存。</p>
<p>例如，考虑这两个Dockerfile：</p>
<p>1 FROM ubuntu
2 ARG CONT_IMG_VER
3 RUN echo $CONT_IMG_VER
1
2
3
1 FROM ubuntu
2 ARG CONT_IMG_VER
3 RUN echo hello
1
2
3
如果在命令行上指定&ndash;build-arg CONT_IMG_VER=<!-- raw HTML omitted -->，则在这两种情况下，第2行上的规范不会导致高速缓存未命中; 第3行确实导致缓存未命中。ARG CONT_IMG_VER导致RUN行被识别为与运行CONT_IMG_VER=<!-- raw HTML omitted --> echo hello相同，因此如果<!-- raw HTML omitted -->发生更改，我们将获得缓存未命中。</p>
<p>考虑同一命令行下的另一个示例：</p>
<p>1 FROM ubuntu
2 ARG CONT_IMG_VER
3 ENV CONT_IMG_VER $CONT_IMG_VER
4 RUN echo $CONT_IMG_VER
1
2
3
4
在此示例中，缓存未命中发生在第3行。由于ENV中的变量值引用ARG变量并且该变量通过命令行发生更改，因此发生未命中。 在此示例中，ENV命令使镜像包含该值。</p>
<p>如果ENV指令覆盖了同名的ARG指令，就像这个Dockerfile：</p>
<p>1 FROM ubuntu
2 ARG CONT_IMG_VER
3 ENV CONT_IMG_VER hello
4 RUN echo $CONT_IMG_VER
1
2
3
4
第3行不会导致缓存未命中，因为CONT_IMG_VER的值是常量（hello）。 因此，RUN（第4行）上使用的环境变量和值在构建之间不会发生变化。</p>
<p>ONBUILD 为下游镜像添加触发器
ONBUILD [INSTRUCTION]
1
当镜像用作另一个构建的基础时，ONBUILD指令向镜像添加将在稍后执行的触发指令。触发器将在下游构建的上下文中执行，就好像它已经在下游Dockerfile中的FROM指令之后立即插入一样。</p>
<p>任何构建指令都可以注册为触发器。</p>
<p>如果要构建将用作构建其他镜像的基础镜像（例如，可以使用特定于用户的配置自定义的应用程序构建环境变量或守护进程），这将非常有用。</p>
<p>例如，如果你的镜像是可重用的Python应用程序构建器，则需要将应用程序源代码添加到特定目录中，并且可能需要在此之后调用构建脚本。你现在不能只调用ADD和RUN，因为你还无法访问应用程序源代码，并且每个应用程序构建都会有所不同。你可以简单地为应用程序开发人员提供一个样板Dockerfile来复制粘贴到他们的应用程序中，但这样做效率低，容易出错且难以更新，因为它与特定于应用程序的代码混合在一起。</p>
<p>解决方案是使用ONBUILD来注册预先指令，以便在下一个构建阶段运行。</p>
<p>以下是它的工作原理：</p>
<p>当遇到ONBUILD指令时，构建器会向正在构建的图像的元数据添加触发器。该指令不会影响当前构建。
在构建结束时，所有触发器的列表都存储在镜像清单中的OnBuild键下。可以使用docker inspect命令检查它们。
稍后，可以使用FROM指令将镜像用作新构建的基础。作为处理FROM指令的一部分，下游构建器查找ONBUILD触发器，并按照它们注册的顺序执行它们。如果任何触发器失败，则中止FROM指令，这反过来导致构建失败。如果所有触发器都成功，则FROM指令完成，并且构建继续照常进行。
执行后，触发器将从最终镜像中清除。换句话说，它们不是由“大孩子(grand-children)”构建继承的。
例如，你可以添加以下内容：</p>
<p>[&hellip;]
ONBUILD ADD . /app/src
ONBUILD RUN /usr/local/bin/python-build &ndash;dir /app/src
[&hellip;]
1
2
3
4
警告：不允许使用ONBUILD ONBUILD这样的链状ONBUILD指令。</p>
<p>警告：ONBUILD指令可能不会触发FROM或MAINTAINER指令。</p>
<p>STOPSIGNAL 容器退出信号
STOPSIGNAL signal
1
STOPSIGNAL指令设置将发送给容器退出的系统调用信号。此信号可以是与内核的系统调用表中的位置匹配的有效无符号数，例如9，或SIGNAME格式的信号名，例如SIGKILL。</p>
<p>HEALTHCHECK 健康检查
HEALTHCHECK指令有两种形式：</p>
<p>HEALTHCHECK [OPTIONS] CMD command（通过在容器内运行命令来检查容器运行状况）
HEALTHCHECK NONE（禁用从基础镜像继承的任何健康检查）
HEALTHCHECK指令告诉Docker如何测试容器以检查它是否仍在工作。可以检测到陷入无限循环且无法处理新连接的Web服务器，即使服务器进程仍在运行等情况。</p>
<p>当容器指定了运行状况检查时，除了正常状态外，它还具有运行状况。此状态最初为starting。每当健康检查通过时，它就会变得healthy（无论以前处于什么状态）。经过一定数量的连续失败后，它变得unhealthy。</p>
<p>可以在CMD之前出现的选项是：</p>
<p>&ndash;interval=DURATION (默认值：30s)
&ndash;timeout=DURATION (默认值：30s)
&ndash;start-period=DURATION (默认值：0s)
&ndash;retries=N (默认值：3)
运行状况检查将首先在容器启动后的**间隔(interval)秒运行，然后在每次上一次检查完成后再间隔(interval)**秒。</p>
<p>如果单次运行的检查花费的时间超过**超时(timeout)**秒数，那么检查将被视为unhealthy。</p>
<p>它需要**重试(retries)**连续的健康检查失败才能将容器视为不健康。</p>
<p>**启动期间(start period)**为需要时间引导的容器提供初始化时间。在此期间探测失败将不计入最大重试次数。但是，如果在启动期间运行状况检查成功，则会将容器视为已启动，并且所有连续失败将计入最大重试次数。</p>
<p>Dockerfile中只能有一个HEALTHCHECK指令。如果列出多个，那么只有最后一个HEALTHCHECK才会生效。</p>
<p>CMD关键字之后的命令可以是shell命令（例如HEALTHCHECK CMD /bin/check-running）或exec数组（与其他Dockerfile命令一样;有关详细信息，请参阅例如ENTRYPOINT）。</p>
<p>命令的退出状态指示容器的运行状况。可能的值是：</p>
<p>0: success 成功 - 容器健康且随时可用
1: unhealthy 不健康 - 容器无法正常工作
2: reserved 保留 - 不要使用此退出代码
例如，要检查每五分钟左右网络服务器能够在三秒钟内提供网站的主页面：
HEALTHCHECK &ndash;interval=5m &ndash;timeout=3s<br>
CMD curl -f <a href="http://localhost/">http://localhost/</a> || exit 1
1
2
为了帮助调试失败的探测器，命令在stdout或stderr上写入的任何输出文本（UTF-8编码）都将存储在运行状况(health status)中，并可以使用docker inspect进行查询。 此类输出应保持较短（目前仅存储前4096个字节）。</p>
<p>当容器的运行状况更改时，将生成具有新状态的health_status事件。</p>
<p>在Docker 1.12中添加了HEALTHCHECK功能。</p>
<p>SHELL
SHELL [&ldquo;executable&rdquo;, &ldquo;parameters&rdquo;]
1
SHELL指令允许覆盖用于shell命令形式的默认shell。 Linux上的默认shell是[&quot;/bin/sh&quot;, &ldquo;-c&rdquo;]，在Windows上是[&ldquo;cmd&rdquo;, &ldquo;/S&rdquo;, &ldquo;/C&rdquo;]。 SHELL指令必须以JSON格式写入Dockerfile。</p>
<p>SHELL指令在Windows上特别有用，其中有两个常用且相当不同的本机shell：cmd和powershell，以及包括sh的备用shell。</p>
<p>SHELL指令可以多次出现。 每个SHELL指令都会覆盖所有先前的SHELL指令，并影响所有后续指令。 例如：</p>
<p>FROM microsoft/windowsservercore</p>
<h1 id="executed-as-cmd-s-c-echo-default">Executed as cmd /S /C echo default<a hidden class="anchor" aria-hidden="true" href="#executed-as-cmd-s-c-echo-default">#</a></h1>
<p>RUN echo default</p>
<h1 id="executed-as-cmd-s-c-powershell--command-write-host-default">Executed as cmd /S /C powershell -command Write-Host default<a hidden class="anchor" aria-hidden="true" href="#executed-as-cmd-s-c-powershell--command-write-host-default">#</a></h1>
<p>RUN powershell -command Write-Host default</p>
<h1 id="executed-as-powershell--command-write-host-hello">Executed as powershell -command Write-Host hello<a hidden class="anchor" aria-hidden="true" href="#executed-as-powershell--command-write-host-hello">#</a></h1>
<p>SHELL [&ldquo;powershell&rdquo;, &ldquo;-command&rdquo;]
RUN Write-Host hello</p>
<h1 id="executed-as-cmd-s-c-echo-hello">Executed as cmd /S /C echo hello<a hidden class="anchor" aria-hidden="true" href="#executed-as-cmd-s-c-echo-hello">#</a></h1>
<p>SHELL [&ldquo;cmd&rdquo;, &ldquo;/S&rdquo;, &ldquo;/C&rdquo;]
RUN echo hello
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
当在Dockerfile中使用它们的shell形式时，SHELL指令可能会影响以下指令：RUN，CMD和ENTRYPOINT。</p>
<p>以下示例是在Windows上找到的常见模式，可以使用SHELL指令简化：</p>
<p>&hellip;
RUN powershell -command Execute-MyCmdlet -param1 &ldquo;c:\foo.txt&rdquo;
&hellip;
1
2
3
docker调用的命令将是：</p>
<p>cmd /S /C powershell -command Execute-MyCmdlet -param1 &ldquo;c:\foo.txt&rdquo;
1
由于两个原因，这是低效的。 首先，调用一个不必要的cmd.exe命令处理器（也就是shell）。 其次，shell形式的每个RUN指令都需要额外的powershell -command前缀命令。</p>
<p>为了提高效率，可以采用两种机制中的一种。 一种是使用RUN命令的JSON形式，例如：</p>
<p>&hellip;
RUN [&ldquo;powershell&rdquo;, &ldquo;-command&rdquo;, &ldquo;Execute-MyCmdlet&rdquo;, &ldquo;-param1 &quot;c:\foo.txt&quot;&quot;]
&hellip;
1
2
3
虽然JSON形式是明确的，并且不使用不必要的cmd.exe，但它需要通过双引号和转义使得更加赘言。 替代机制是使用SHELL指令和shell形式，为Windows用户提供更自然的语法，特别是与escape解析器指令结合使用时：</p>
<h1 id="escape">escape=`<a hidden class="anchor" aria-hidden="true" href="#escape">#</a></h1>
<p>FROM microsoft/nanoserver
SHELL [&ldquo;powershell&rdquo;,&quot;-command&rdquo;]
RUN New-Item -ItemType Directory C:\Example
ADD Execute-MyCmdlet.ps1 c:\example<br>
RUN c:\example\Execute-MyCmdlet -sample &lsquo;hello world&rsquo;
1
2
3
4
5
6
7
结果是:</p>
<p>PS E:\docker\build\shell&gt; docker build -t shell .
Sending build context to Docker daemon 4.096 kB
Step 1/5 : FROM microsoft/nanoserver
&mdash;&gt; 22738ff49c6d
Step 2/5 : SHELL powershell -command
&mdash;&gt; Running in 6fcdb6855ae2
&mdash;&gt; 6331462d4300
Removing intermediate container 6fcdb6855ae2
Step 3/5 : RUN New-Item -ItemType Directory C:\Example
&mdash;&gt; Running in d0eef8386e97</p>
<pre><code>Directory: C:\
</code></pre>
<p>Mode                LastWriteTime         Length Name</p>
<hr>
<p>d&mdash;&ndash;       10/28/2016  11:26 AM                Example</p>
<p>&mdash;&gt; 3f2fbf1395d9
Removing intermediate container d0eef8386e97
Step 4/5 : ADD Execute-MyCmdlet.ps1 c:\example<br>
&mdash;&gt; a955b2621c31
Removing intermediate container b825593d39fc
Step 5/5 : RUN c:\example\Execute-MyCmdlet &lsquo;hello world&rsquo;
&mdash;&gt; Running in be6d8e63fe75
hello world
&mdash;&gt; 8e559e9bf424
Removing intermediate container be6d8e63fe75
Successfully built 8e559e9bf424
PS E:\docker\build\shell&gt;
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
SHELL指令也可用于修改shell的运行方式。 例如，在Windows上使用SHELL cmd /S /C /V:ON|OFF，可以修改延迟的环境变量扩展语义。</p>
<p>如果需要备用shell，例如zsh、csh、tcsh等，也可以在Linux上使用SHELL指令。</p>
<p>在Docker 1.12中添加了SHELL功能。</p>
<p>Dockerfile示例
下面你可以看到Dockerfile语法的一些示例。 如果你对更现实的东西感兴趣，请查看Dockerization示例列表。</p>
<h1 id="nginx">Nginx<a hidden class="anchor" aria-hidden="true" href="#nginx">#</a></h1>
<h1 id="heading"><a hidden class="anchor" aria-hidden="true" href="#heading">#</a></h1>
<h1 id="version---------------001">VERSION               0.0.1<a hidden class="anchor" aria-hidden="true" href="#version---------------001">#</a></h1>
<p>FROM      ubuntu
LABEL Description=&ldquo;This image is used to start the foobar executable&rdquo; Vendor=&ldquo;ACME Products&rdquo; Version=&ldquo;1.0&rdquo;
RUN apt-get update &amp;&amp; apt-get install -y inotify-tools nginx apache2 openssh-server
1
2
3
4
5
6
7</p>
<h1 id="firefox-over-vnc">Firefox over VNC<a hidden class="anchor" aria-hidden="true" href="#firefox-over-vnc">#</a></h1>
<h1 id="heading-1"><a hidden class="anchor" aria-hidden="true" href="#heading-1">#</a></h1>
<h1 id="version---------------03">VERSION               0.3<a hidden class="anchor" aria-hidden="true" href="#version---------------03">#</a></h1>
<p>FROM ubuntu</p>
<h1 id="install-vnc-xvfb-in-order-to-create-a-fake-display-and-firefox">Install vnc, xvfb in order to create a &lsquo;fake&rsquo; display and firefox<a hidden class="anchor" aria-hidden="true" href="#install-vnc-xvfb-in-order-to-create-a-fake-display-and-firefox">#</a></h1>
<p>RUN apt-get update &amp;&amp; apt-get install -y x11vnc xvfb firefox
RUN mkdir ~/.vnc</p>
<h1 id="setup-a-password">Setup a password<a hidden class="anchor" aria-hidden="true" href="#setup-a-password">#</a></h1>
<p>RUN x11vnc -storepasswd 1234 ~/.vnc/passwd</p>
<h1 id="autostart-firefox-might-not-be-the-best-way-but-it-does-the-trick">Autostart firefox (might not be the best way, but it does the trick)<a hidden class="anchor" aria-hidden="true" href="#autostart-firefox-might-not-be-the-best-way-but-it-does-the-trick">#</a></h1>
<p>RUN bash -c &lsquo;echo &ldquo;firefox&rdquo; &raquo; /.bashrc&rsquo;</p>
<p>EXPOSE 5900
CMD    [&ldquo;x11vnc&rdquo;, &ldquo;-forever&rdquo;, &ldquo;-usepw&rdquo;, &ldquo;-create&rdquo;]
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</p>
<h1 id="multiple-images-example">Multiple images example<a hidden class="anchor" aria-hidden="true" href="#multiple-images-example">#</a></h1>
<h1 id="heading-2"><a hidden class="anchor" aria-hidden="true" href="#heading-2">#</a></h1>
<h1 id="version---------------01">VERSION               0.1<a hidden class="anchor" aria-hidden="true" href="#version---------------01">#</a></h1>
<p>FROM ubuntu
RUN echo foo &gt; bar</p>
<h1 id="will-output-something-like--907ad6c2736f">Will output something like ===&gt; 907ad6c2736f<a hidden class="anchor" aria-hidden="true" href="#will-output-something-like--907ad6c2736f">#</a></h1>
<p>FROM ubuntu
RUN echo moo &gt; oink</p>
<h1 id="will-output-something-like--695d7793cbe4">Will output something like ===&gt; 695d7793cbe4<a hidden class="anchor" aria-hidden="true" href="#will-output-something-like--695d7793cbe4">#</a></h1>
<h1 id="youll-now-have-two-images-907ad6c2736f-with-bar-and-695d7793cbe4-with">You&rsquo;ll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with<a hidden class="anchor" aria-hidden="true" href="#youll-now-have-two-images-907ad6c2736f-with-bar-and-695d7793cbe4-with">#</a></h1>
<h1 id="oink">/oink<a hidden class="anchor" aria-hidden="true" href="#oink">#</a></h1>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/docker/">Docker</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
