<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>链表有环和相交问题 | Forz Blog</title>
<meta name="keywords" content="Linked List, Two Pointers" />
<meta name="description" content="LeetCode 141. Linked List Cycle Given a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space? 解析： FLOYD判圈算法(判断是否有环): 如何检测一个链表是否有环，如果有，那么如何确">
<meta name="author" content="">
<link rel="canonical" href="/post/%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF%E5%92%8C%E7%9B%B8%E4%BA%A4%E9%97%AE%E9%A2%98/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="链表有环和相交问题" />
<meta property="og:description" content="LeetCode 141. Linked List Cycle Given a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space? 解析： FLOYD判圈算法(判断是否有环): 如何检测一个链表是否有环，如果有，那么如何确" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF%E5%92%8C%E7%9B%B8%E4%BA%A4%E9%97%AE%E9%A2%98/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-25T02:24:38&#43;00:00" />
<meta property="article:modified_time" content="2017-06-25T02:24:38&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="链表有环和相交问题"/>
<meta name="twitter:description" content="LeetCode 141. Linked List Cycle Given a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space? 解析： FLOYD判圈算法(判断是否有环): 如何检测一个链表是否有环，如果有，那么如何确"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "链表有环和相交问题",
      "item": "/post/%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF%E5%92%8C%E7%9B%B8%E4%BA%A4%E9%97%AE%E9%A2%98/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "链表有环和相交问题",
  "name": "链表有环和相交问题",
  "description": "LeetCode 141. Linked List Cycle Given a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space? 解析： FLOYD判圈算法(判断是否有环): 如何检测一个链表是否有环，如果有，那么如何确",
  "keywords": [
    "Linked List", "Two Pointers"
  ],
  "articleBody": "LeetCode 141. Linked List Cycle Given a linked list, determine if it has a cycle in it.\nFollow up:\nCan you solve it without using extra space?\n解析：\nFLOYD判圈算法(判断是否有环):\n如何检测一个链表是否有环，如果有，那么如何确定环的起点. Floyd用两个指针，一个慢指针（龟）每次前进一步，快指针（兔）指针每次前进两步\n两步或多步效果是等价的，只要一个比另一个快就行，如果两个人同时出发，如果赛道有环，那么快的一方总能追上慢的一方。\n进一步想，追上时快的一方肯定比慢的一方多跑了几圈，即多跑的路的长度是圈的长度的倍数。\n如果两者在链表头以外的某一点相遇（即相等）了，那么说明链表有环，否则，如果（快指针）到达了链表的结尾,那么说明没环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: bool hasCycle(ListNode *head) { // 设置两个指针，一个快一个慢  ListNode *slow = head, *fast = head; while (fast \u0026\u0026 fast-next) {//如果（快指针）到达了链表的结尾,那么说明没环。  slow = slow-next; fast = fast-next-next; if (slow == fast) return true; } return false; } };   LeetCode 142. Linked List Cycle II Given a linked list, return the node where the cycle begins. If there is no cycle, return null.\nNote: Do not modify the linked list.\nFollow up: Can you solve it without using extra space?\n1). 使用快慢指针法，若链表中有环，可以得到两指针的交点M.\n2). 记链表的头节点为H，环的起点为E.\n2.1) L1为H到E的距离.\n2.2) L2为从E出发，首次到达M时的路程. 2.3) C为环的周长.\n2.4) n为快慢指针首次相遇时，快指针在环中绕行的次数.\n根据L1,L2和C的定义，我们可以得到：慢指针行进的距离为L1 + L2 快指针行进的距离为L1 + L2 + n C 由于快慢指针行进的距离有2倍关系，因此：\n2 (L1+L2) = L1 + L2 + n C = L1 + L2 = n C = L1 = (n - 1) C + (C - L2)  因为在指针的前进过程中，(n-1)c 是原地打转，会被自动消掉，所以 可以推出H到E的距离 = 从M出发绕环到达E时的路程\n因此，当快慢指针在环中相遇时，我们再令快指针从头节点出发,接下来当快指针和慢指针相遇时，即为E所在的位置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *slow = head, *fast = head; while (fast \u0026\u0026 fast-next) { slow = slow-next; fast = fast-next-next; if (slow == fast) { fast = head;//快指针从头走  while (fast != slow) { fast = fast-next; slow = slow-next; } return slow; } } return nullptr; } };   LeetCode 160. Intersection of Two Linked Lists(无环) Write a program to find the node at which the intersection of two singly linked lists begins.\nFor example, the following two linked lists:\nA: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3  begin to intersect at node c1.\nNotes:\nIf the two linked lists have no intersection at all, return null.\nThe linked lists must retain their original structure after the function returns.\nYou may assume there are no cycles anywhere in the entire linked structure.\nYour code should preferably run in O(n) time and use only O(1) memory.\n解析:\n如何判断两个无环链表是否相交，相交则返回第一个相交节点，不相交则返 回 null。 如果两个无环链表相交，那么从相交节点开始，一直到两个链表终止的这一段，是两个链表共享的。解决问题的具体过程如下：\n 链表1从头节点开始，走到最后一个节点（不是结束），统计链表1的长度记为lenl,同时记录链表1的最后一个节点记为end1。 链表2从头节点开始，走到最后一个节点（不是结束），统计链表2的长度记为len2,同时记录链表2的最后一个节点记为end2。 如果endl!=end2，说明两个链表不相交，返回null即可；如果end==end2，说明两个链表相交，进入步骤4来找寻第一个相交节点。 如果链表1比较长，链表1就先走lenl-len2步；如果链表2比较长，链表2就先走len2-lenl步。然后两个链表一起走，一起走的过程中，两个链表第一次走到一起的那个节点，就是第一个相交的节点。  例如：链表1长度为100,链表2长度为30，如果己经由步骤3确定了链表1和链表2一定相交，那么接下来，链表1先走70步，然后链表1和链表2一起走，它们一定会共同进入第一个相交的节点。\n因为本题已经知道必有相交,所以有一种简化代码的方法.\n维护两个指针pA和pB，初始分别指向A和B。然后让它们分别遍历整个链表，每步一个节点。\n当pA到达链表末尾时，让它指向B的头节点；类似的当pB到达链表末尾时，重新指向A的头节点。\n如果pA在某一点与pB相遇，则pA或pB就是交点。\n所以最多遍历 链表A的长度+链表B的长度 即可判断出是否有相交的节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *p1 = headA; ListNode *p2 = headB; if (p1 == NULL || p2 == NULL) return NULL; while (p1 != NULL \u0026\u0026 p2 != NULL \u0026\u0026 p1 != p2) { p1 = p1-next; p2 = p2-next; if (p1 == p2) return p1; if (p1 == NULL) p1 = headB; if (p2 == NULL) p2 = headA; } return p1; } };   判断两个有环链表是否相交 如何判断两个有环链表是否相交，相交则返回第一个相交节点，不相交则返 回 null。\n考虑问题三的时候，我们己经得到了两个链表各自的第一个入环节点，假设链表1的第一个入环节点记为loop1,链表2的第一个入环节点记为loop2。以下是解决问题的过程：\n  如果loopl=loop2，那么两个链表的拓扑结构如图所示。\n这种情况下，我们只要考虑链表1从头开始到loop1这一段与链表2从头开始到loop2这一段，在哪里第一次相交即可，而不用考虑进环该怎么处理，这就与上题类似，只不过上题是把null作为一个链表的终点，而这里是把loop1(1oop2)作为链表的终点。但是判断的主要过程是相同的。\n  如果loop1!=loop2,两个链表不相交的拓扑结构如图2-5所示。两个链表相交的拓扑结构如图所示。\n如何分辨是这两种拓扑结构的哪一种呢？进入步骤3。\n  让链表1从loopl出发，因为loop1和之后的所有节点都在环上，所以将来一定能回到loop1。如果回到loop1之前并没有遇到loop2,说明两个链表的拓扑结构如图2-5所不，也就是不相交，直接返回null;\n  如果回到loopl之前遇到了 loop2,说明两个链表的拓扑结构如图2-6所示，也就是相交。因为loopl和loop2都在两条链表上，只不过loop1是 离链表1较近的节点，loop2是离链表2较近的节点。所以，此时返回loop1或loop2都可以。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  public static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2) { Node cur1 = null; Node cur2 = null; if (loop1 == loop2) { cur1 = head1; cur2 = head2; int n = 0; while (cur1 != loop1) { n++; cur1 = cur1.next; } while (cur2 != loop2) { n--; cur2 = cur2.next; } cur1 = n  0 ? head1 : head2; cur2 = cur1 == head1 ? head2 : head1; n = Math.abs(n); while (n != 0) { n--; cur1 = cur1.next; } while (cur1 != cur2) { cur1 = cur1.next; cur2 = cur2.next; } return cur1; } else { cur1 = loop1.next; while (cur1 != loop1) { if (cur1 == loop2) { return loop1; } cur1 = cur1.next; } return null; } }   ",
  "wordCount" : "2527",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-25T02:24:38Z",
  "dateModified": "2017-06-25T02:24:38Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF%E5%92%8C%E7%9B%B8%E4%BA%A4%E9%97%AE%E9%A2%98/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      链表有环和相交问题
    </h1>
    <div class="post-meta">June 25, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="leetcode-141-linked-list-cycle">LeetCode 141. Linked List Cycle<a hidden class="anchor" aria-hidden="true" href="#leetcode-141-linked-list-cycle">#</a></h1>
<p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>
Can you solve it without using extra space?</p>
<p>解析：</p>
<p>FLOYD判圈算法(判断是否有环):<br>
如何检测一个链表是否有环，如果有，那么如何确定环的起点.
Floyd用两个指针，一个慢指针（龟）每次前进一步，快指针（兔）指针每次前进两步</p>
<p>两步或多步效果是等价的，只要一个比另一个快就行，如果两个人同时出发，如果赛道有环，那么快的一方总能追上慢的一方。</p>
<p>进一步想，追上时快的一方肯定比慢的一方多跑了几圈，即多跑的路的长度是圈的长度的倍数。</p>
<p>如果两者在链表头以外的某一点相遇（即相等）了，那么说明链表有环，否则，如果（快指针）到达了链表的结尾,那么说明没环。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for singly-linked list.
</span><span class="cm"> * struct ListNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     ListNode *next;
</span><span class="cm"> *     ListNode(int x) : val(x), next(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">bool</span> <span class="n">hasCycle</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 设置两个指针，一个快一个慢
</span><span class="c1"></span>    <span class="n">ListNode</span> <span class="o">*</span><span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">fast</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span><span class="c1">//如果（快指针）到达了链表的结尾,那么说明没环。
</span><span class="c1"></span>        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">slow</span> <span class="o">==</span> <span class="n">fast</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-142-linked-list-cycle-ii">LeetCode 142. Linked List Cycle II<a hidden class="anchor" aria-hidden="true" href="#leetcode-142-linked-list-cycle-ii">#</a></h1>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>Note: Do not modify the linked list.</p>
<p>Follow up: <br>
Can you solve it without using extra space?</p>
<p>1). 使用快慢指针法，若链表中有环，可以得到两指针的交点M.<br>
2). 记链表的头节点为H，环的起点为E.<br>
2.1) L1为H到E的距离.<br>
2.2) L2为从E出发，首次到达M时的路程.  <br>
2.3) C为环的周长.<br>
2.4) n为快慢指针首次相遇时，快指针在环中绕行的次数.</p>
<p>根据L1,L2和C的定义，我们可以得到：慢指针行进的距离为L1 + L2
快指针行进的距离为L1 + L2 + n C 由于快慢指针行进的距离有2倍关系，因此：</p>
<pre><code>2 (L1+L2) = L1 + L2 + n C =&gt; L1 + L2 = n C =&gt; L1 = (n - 1) C + (C - L2)
</code></pre>
<p>因为在指针的前进过程中，(n-1)c 是原地打转，会被自动消掉，所以
可以推出H到E的距离 = 从M出发绕环到达E时的路程</p>
<p>因此，当快慢指针在环中相遇时，我们再令快指针从头节点出发,接下来当快指针和慢指针相遇时，即为E所在的位置</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for singly-linked list.
</span><span class="cm"> * struct ListNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     ListNode *next;
</span><span class="cm"> *     ListNode(int x) : val(x), next(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>

<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">ListNode</span> <span class="o">*</span><span class="n">detectCycle</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">fast</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">slow</span> <span class="o">==</span> <span class="n">fast</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span><span class="c1">//快指针从头走
</span><span class="c1"></span>            <span class="k">while</span> <span class="p">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="n">slow</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">slow</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-160-intersection-of-two-linked-lists无环">LeetCode 160. Intersection of Two Linked Lists(无环)<a hidden class="anchor" aria-hidden="true" href="#leetcode-160-intersection-of-two-linked-lists无环">#</a></h1>
<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>For example, the following two linked lists:</p>
<pre><code>A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
</code></pre>
<p>begin to intersect at node c1.</p>
<p>Notes:</p>
<p>If the two linked lists have no intersection at all, return null.</p>
<p>The linked lists must retain their original structure after the function returns.</p>
<p>You may assume there are no cycles anywhere in the entire linked structure.</p>
<p>Your code should preferably run in O(n) time and use only O(1) memory.</p>
<p>解析:</p>
<p>如何判断两个无环链表是否相交，相交则返回第一个相交节点，不相交则返
回 null。
如果两个无环链表相交，那么从相交节点开始，一直到两个链表终止的这一段，是两个链表共享的。解决问题的具体过程如下：</p>
<ol>
<li>链表1从头节点开始，走到最后一个节点（不是结束），统计链表1的长度记为lenl,同时记录链表1的最后一个节点记为end1。</li>
<li>链表2从头节点开始，走到最后一个节点（不是结束），统计链表2的长度记为len2,同时记录链表2的最后一个节点记为end2。</li>
<li>如果endl!=end2，说明两个链表不相交，返回null即可；如果end==end2，说明两个链表相交，进入步骤4来找寻第一个相交节点。</li>
<li>如果链表1比较长，链表1就先走lenl-len2步；如果链表2比较长，链表2就先走len2-lenl步。然后两个链表一起走，一起走的过程中，两个链表第一次走到一起的那个节点，就是第一个相交的节点。</li>
</ol>
<p>例如：链表1长度为100,链表2长度为30，如果己经由步骤3确定了链表1和链表2一定相交，那么接下来，链表1先走70步，然后链表1和链表2一起走，它们一定会共同进入第一个相交的节点。</p>
<p>因为本题已经知道必有相交,所以有一种简化代码的方法.</p>
<p>维护两个指针pA和pB，初始分别指向A和B。然后让它们分别遍历整个链表，每步一个节点。</p>
<p>当pA到达链表末尾时，让它指向B的头节点；类似的当pB到达链表末尾时，重新指向A的头节点。</p>
<p>如果pA在某一点与pB相遇，则pA或pB就是交点。</p>
<p>所以最多遍历 链表A的长度+链表B的长度 即可判断出是否有相交的节点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for singly-linked list.
</span><span class="cm"> * struct ListNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     ListNode *next;
</span><span class="cm"> *     ListNode(int x) : val(x), next(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">ListNode</span> <span class="o">*</span><span class="n">getIntersectionNode</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">headA</span><span class="p">,</span> <span class="n">ListNode</span> <span class="o">*</span><span class="n">headB</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="n">headA</span><span class="p">;</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="n">headB</span><span class="p">;</span>        
    <span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">p2</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">p2</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="o">==</span> <span class="n">p2</span><span class="p">)</span> <span class="k">return</span> <span class="n">p1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">headB</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p2</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">headA</span><span class="p">;</span>
    <span class="p">}</span>
        
    <span class="k">return</span> <span class="n">p1</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="判断两个有环链表是否相交">判断两个有环链表是否相交<a hidden class="anchor" aria-hidden="true" href="#判断两个有环链表是否相交">#</a></h1>
<p>如何判断两个有环链表是否相交，相交则返回第一个相交节点，不相交则返
回 null。</p>
<p>考虑问题三的时候，我们己经得到了两个链表各自的第一个入环节点，假设链表1的第一个入环节点记为loop1,链表2的第一个入环节点记为loop2。以下是解决问题的过程：</p>
<ol>
<li>
<p>如果loopl=loop2，那么两个链表的拓扑结构如图所示。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170817-124235@2x.png" alt=""  />
</p>
<p>这种情况下，我们只要考虑链表1从头开始到loop1这一段与链表2从头开始到loop2这一段，在哪里第一次相交即可，而不用考虑进环该怎么处理，这就与上题类似，只不过上题是把null作为一个链表的终点，而这里是把loop1(1oop2)作为链表的终点。但是判断的主要过程是相同的。</p>
</li>
<li>
<p>如果loop1!=loop2,两个链表不相交的拓扑结构如图2-5所示。两个链表相交的拓扑结构如图所示。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170817-124636@2x.png" alt=""  />
</p>
<p>如何分辨是这两种拓扑结构的哪一种呢？进入步骤3。</p>
</li>
<li>
<p>让链表1从loopl出发，因为loop1和之后的所有节点都在环上，所以将来一定能回到loop1。如果回到loop1之前并没有遇到loop2,说明两个链表的拓扑结构如图2-5所不，也就是不相交，直接返回null;</p>
</li>
</ol>
<p>如果回到loopl之前遇到了 loop2,说明两个链表的拓扑结构如图2-6所示，也就是相交。因为loopl和loop2都在两条链表上，只不过loop1是
离链表1较近的节点，loop2是离链表2较近的节点。所以，此时返回loop1或loop2都可以。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">	<span class="kd">public</span> <span class="kd">static</span> <span class="n">Node</span> <span class="nf">bothLoop</span><span class="o">(</span><span class="n">Node</span> <span class="n">head1</span><span class="o">,</span> <span class="n">Node</span> <span class="n">loop1</span><span class="o">,</span> <span class="n">Node</span> <span class="n">head2</span><span class="o">,</span> <span class="n">Node</span> <span class="n">loop2</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Node</span> <span class="n">cur1</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
		<span class="n">Node</span> <span class="n">cur2</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">loop1</span> <span class="o">==</span> <span class="n">loop2</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">cur1</span> <span class="o">=</span> <span class="n">head1</span><span class="o">;</span>
			<span class="n">cur2</span> <span class="o">=</span> <span class="n">head2</span><span class="o">;</span>
			<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
			<span class="k">while</span> <span class="o">(</span><span class="n">cur1</span> <span class="o">!=</span> <span class="n">loop1</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">n</span><span class="o">++;</span>
				<span class="n">cur1</span> <span class="o">=</span> <span class="n">cur1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
			<span class="o">}</span>
			<span class="k">while</span> <span class="o">(</span><span class="n">cur2</span> <span class="o">!=</span> <span class="n">loop2</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">n</span><span class="o">--;</span>
				<span class="n">cur2</span> <span class="o">=</span> <span class="n">cur2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
			<span class="o">}</span>
			<span class="n">cur1</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">?</span> <span class="n">head1</span> <span class="o">:</span> <span class="n">head2</span><span class="o">;</span>
			<span class="n">cur2</span> <span class="o">=</span> <span class="n">cur1</span> <span class="o">==</span> <span class="n">head1</span> <span class="o">?</span> <span class="n">head2</span> <span class="o">:</span> <span class="n">head1</span><span class="o">;</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
			<span class="k">while</span> <span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">n</span><span class="o">--;</span>
				<span class="n">cur1</span> <span class="o">=</span> <span class="n">cur1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
			<span class="o">}</span>
			<span class="k">while</span> <span class="o">(</span><span class="n">cur1</span> <span class="o">!=</span> <span class="n">cur2</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">cur1</span> <span class="o">=</span> <span class="n">cur1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
				<span class="n">cur2</span> <span class="o">=</span> <span class="n">cur2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
			<span class="o">}</span>
			<span class="k">return</span> <span class="n">cur1</span><span class="o">;</span>
		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="n">cur1</span> <span class="o">=</span> <span class="n">loop1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
			<span class="k">while</span> <span class="o">(</span><span class="n">cur1</span> <span class="o">!=</span> <span class="n">loop1</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">cur1</span> <span class="o">==</span> <span class="n">loop2</span><span class="o">)</span> <span class="o">{</span>
					<span class="k">return</span> <span class="n">loop1</span><span class="o">;</span>
				<span class="o">}</span>
				<span class="n">cur1</span> <span class="o">=</span> <span class="n">cur1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
			<span class="o">}</span>
			<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/linked-list/">Linked List</a></li>
      <li><a href="/tags/two-pointers/">Two Pointers</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
