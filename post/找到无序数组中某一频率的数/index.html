<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>找到无序数组中某一频率的数 | Forz Blog</title>
<meta name="keywords" content="Array, Heap, Bucket Sort, 多数投票算法" />
<meta name="description" content="LeetCode 451. Sort Characters By Frequency Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input: “tree” Output: “eert” Explanation: ‘e’ appears twice while ‘r’ and ‘t’ both appear once. So ‘e’ must appear before both ‘r’ and ‘t’. Therefore">
<meta name="author" content="">
<link rel="canonical" href="/post/%E6%89%BE%E5%88%B0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%90%E4%B8%80%E9%A2%91%E7%8E%87%E7%9A%84%E6%95%B0/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="找到无序数组中某一频率的数" />
<meta property="og:description" content="LeetCode 451. Sort Characters By Frequency Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input: “tree” Output: “eert” Explanation: ‘e’ appears twice while ‘r’ and ‘t’ both appear once. So ‘e’ must appear before both ‘r’ and ‘t’. Therefore" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E6%89%BE%E5%88%B0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%90%E4%B8%80%E9%A2%91%E7%8E%87%E7%9A%84%E6%95%B0/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-25T00:00:19&#43;00:00" />
<meta property="article:modified_time" content="2017-06-25T00:00:19&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="找到无序数组中某一频率的数"/>
<meta name="twitter:description" content="LeetCode 451. Sort Characters By Frequency Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input: “tree” Output: “eert” Explanation: ‘e’ appears twice while ‘r’ and ‘t’ both appear once. So ‘e’ must appear before both ‘r’ and ‘t’. Therefore"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "找到无序数组中某一频率的数",
      "item": "/post/%E6%89%BE%E5%88%B0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%90%E4%B8%80%E9%A2%91%E7%8E%87%E7%9A%84%E6%95%B0/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "找到无序数组中某一频率的数",
  "name": "找到无序数组中某一频率的数",
  "description": "LeetCode 451. Sort Characters By Frequency Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input: “tree” Output: “eert” Explanation: ‘e’ appears twice while ‘r’ and ‘t’ both appear once. So ‘e’ must appear before both ‘r’ and ‘t’. Therefore",
  "keywords": [
    "Array", "Heap", "Bucket Sort", "多数投票算法"
  ],
  "articleBody": "LeetCode 451. Sort Characters By Frequency Given a string, sort it in decreasing order based on the frequency of characters.\nExample 1:\nInput:\n“tree”\nOutput:\n“eert”\nExplanation:\n‘e’ appears twice while ‘r’ and ‘t’ both appear once.\nSo ‘e’ must appear before both ‘r’ and ‘t’. Therefore “eetr” is also a valid answer.\nExample 2:\nInput: “cccaaa”\nOutput:\n“cccaaa”\nExplanation:\nBoth ‘c’ and ‘a’ appear three times, so “aaaccc” is also a valid answer.\nNote that “cacaca” is incorrect, as the same characters must be together.\nExample 3:\nInput: “Aabb”.\nOutput:\n“bbAa”.\nExplanation:\n“bbaA” is also a valid answer, but “Aabb” is incorrect.\nNote that ‘A’ and ‘a’ are treated as two different characters.\n解析：因为是sort，需要排列所有元素。所以直接用sort函数。cmp函数用lambda表示。\n1 2 3 4 5 6 7 8 9 10 11  class Solution { public: string frequencySort(string s) { unordered_mapchar, int m; for (char c : s) ++m[c]; sort(s.begin(), s.end(), [\u0026](char\u0026 a, char\u0026 b){//采用隐式引用捕获  return m[a]  m[b] || (m[a] == m[b] \u0026\u0026 a  b); }); return s; } };   LeetCode 347. Top K Frequent Elements Given a non-empty array of integers, return the k most frequent elements.\nFor example, Given [1,1,1,2,2,3] and k = 2, return [1,2].\nNote:\nYou may assume k is always valid, 1 ≤ k ≤ number of unique elements.\nYour algorithm’s time complexity must be better than O(n log n), where n is the array’s size.\n解析：根据题设要求的时间复杂度，只能选择堆排序和桶排序。先利用哈希表处理，求出所有元素出现次数，这就当作该元素的权值。然后构造小顶堆。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public: vectorint topKFrequent(vectorint\u0026 nums, int k) { unordered_mapint, int hash; priority_queuepairint, int, vectorpairint, int, greaterpairint, int heap;//构造小顶堆  vectorint ret; for(int num:nums) hash[num]++; for(auto it:hash) { heap.push(make_pair(it.second, it.first)); if(heap.size()  k) heap.pop();//在堆元素超过K时，删除堆顶元素，因为它不可能是数量最多的K个元素之一  } while(!heap.empty()) {//遍历完所有数组元素之后堆中剩下的K个元素即是所求结果  ret.push_back(heap.top().second); heap.pop(); } return ret; } };   注意：pair默认按first排序，所以要想在小顶堆内按出现频率排序，需要将second和first换位。\n补充：因为出现频率最高也就是nums.size(),所以出现频率是一个可知的范围。将每一个出现频率看作一个桶，把相同出现频率的元素放到一个桶中，然后倒序扫描每个桶，输出k个元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public: vectorint topKFrequent(vectorint\u0026 nums, int k) { unordered_mapint, int hash; vectorvectorint buckets(nums.size()+1); vectorint ret; for(int num:nums) hash[num]++; for(auto it:hash) buckets[it.second].push_back(it.first); for(int i=buckets.size()-1; i0; --i) { for(auto num:buckets[i]) { ret.push_back(num); if(ret.size() == k) return ret; } } return ret; } };   169. Majority Element Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.\nYou may assume that the array is non-empty and the majority element always exist in the array.\n解析：\n多数投票算法，可以在O(1)空间复杂度中求众数。\n简单的理解算法，投票过程中，若从数组中可找出一个二元组，该二元组包含1个候选元素和1个不同的元素，将其从数组中删除。可以形象的理解为多数投票过程。count表示当前候选者的票数。\n求解步骤：\n如果count==0，则将candidate的值设置为数组的当前元素，将count赋值为1；（候选者本人算一票）\n否则，如果candidate和现在数组元素值相同，则count++，反之count–； （相当于投票过程）\n重复上述两步，直到扫描完数组。最后的candidate就是出现次数超过一半的数。\n检查步骤：\ncount赋值为0，再次从头扫描数组，如果数组元素值与vote的值相同则count++，直到扫描完数组为止。如果此时count的值大于等于n/2，则返回vote的值，反之则返回-1；\n由于题目保证结果一定存在，所以我们省去了最后一步的检查验证\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution { public: int majorityElement(vectorint\u0026 nums) { int candidate = 0; int count = 0; for(int i = 0; i  nums.size(); i ++) { if(count == 0)//没有候选者就要新立一位候选者  { candidate = nums[i]; count = 1; } else //count！=0  { if(nums[i] == candidate)//当前候选者票数增加  count ++; else//候选者票数减少，相当于删除二元组  count --; } } return candidate; } };   补充：hash算法，空间复杂度O(n)\n1 2 3 4 5 6 7 8 9 10 11  class Solution { public: int majorityElement(vectorint\u0026 nums) { unordered_mapint, int counts; int n = nums.size(); for (int i = 0; i  n; i++) if (++counts[nums[i]]  n / 2) return nums[i]; return -1; } };   229. Majority Element II Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1)\n解析：因为要找出的是出现次数大于 n/3 的元素，因此最多只可能存在两个这样的元素。第一次遍历数组，多数投票算法，求出两个众数。\n在每一轮投票过程中，若从数组中可找出一个三元组，该三元组包含2个候选元素和1个不同的元素，将其从数组中删除。这样不断的删除直到无法再进行投票，如果数组为空，则没有任何元素出现的次数超过该数组长度的一半。如果只存在一种元素，那么这个元素则可能为目标元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class Solution { public: vectorint majorityElement(vectorint\u0026 nums) { int n=nums.size(); vectorint result; int count1=0, count2=0;//计数器  int result1=INT_MAX, result2=INT_MAX;//候选元素  for(int num:nums){ if(num==result1) count1++; else if(num==result2) count2++;//没有找到不同元素，只需要把相同元素累计起来  else if(count1==0) { result1=num; count1=1; }//设当前元素为候选元素  else if(count2==0) { result2=num; count2=1; } else { count1--; count2--; }//相当于删除一个三元组  } //因为本题未说明结果一定存在，所以需要检验过程  count1=count2=0; for(int num:nums){//第二次遍历数组，记录候选元素真正出现的次数。  if(num==result1) count1++; else if(num==result2) count2++; } if(count1n/3) result.push_back(result1); if(count2n/3) result.push_back(result2); return result; } };   这种一次删掉K个不同的数的思想在面试中通常会变形之后反复出现。例如，下面这道题：有一场投票，投票有效的条件是必须有一个候选人得票数超过半数，但是验票人员不能看到每张选票上选了谁，只能把任意两张选票放到一台机器上看这两张选票是否一样，若一样，则机器给出true的提醒，不一样则给出false的提醒。如果你作为验票的人员，怎么判断这场投票是有效的？这道题目就是原问题的变形，但是“不能看到每张选票上选了谁”的这个限制实际上把用哈希表来解题的可能性完全堵死了。但本文的方法却可以满足题目的要求，因为我们实现的方法只需要当前数和候选数做比较，而不需要知道每个数的值。\n",
  "wordCount" : "2182",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-25T00:00:19Z",
  "dateModified": "2017-06-25T00:00:19Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E6%89%BE%E5%88%B0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%90%E4%B8%80%E9%A2%91%E7%8E%87%E7%9A%84%E6%95%B0/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      找到无序数组中某一频率的数
    </h1>
    <div class="post-meta">June 25, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="leetcode-451-sort-characters-by-frequency">LeetCode 451. Sort Characters By Frequency<a hidden class="anchor" aria-hidden="true" href="#leetcode-451-sort-characters-by-frequency">#</a></h1>
<p>Given a string, sort it in decreasing order based on the frequency of characters.</p>
<p>Example 1:</p>
<p>Input:<br>
“tree”</p>
<p>Output:<br>
“eert”</p>
<p>Explanation:</p>
<p>‘e’ appears twice while ‘r’ and ‘t’ both appear once.</p>
<p>So ‘e’ must appear before both ‘r’ and ‘t’. Therefore “eetr” is also a valid answer.</p>
<p>Example 2:</p>
<p>Input: <br>
“cccaaa”</p>
<p>Output:<br>
“cccaaa”</p>
<p>Explanation:</p>
<p>Both ‘c’ and ‘a’ appear three times, so “aaaccc” is also a valid answer.</p>
<p>Note that “cacaca” is incorrect, as the same characters must be together.</p>
<p>Example 3:</p>
<p>Input: <br>
“Aabb”.</p>
<p>Output:<br>
“bbAa”.</p>
<p>Explanation:</p>
<p>“bbaA” is also a valid answer, but “Aabb” is incorrect.</p>
<p>Note that ‘A’ and ‘a’ are treated as two different characters.</p>
<p>解析：因为是sort，需要排列所有元素。所以直接用sort函数。cmp函数用lambda表示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">string</span> <span class="n">frequencySort</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">s</span><span class="p">)</span> <span class="o">++</span><span class="n">m</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">char</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">){</span><span class="c1">//采用隐式引用捕获
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">m</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="n">m</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-347-top-k-frequent-elements">LeetCode 347. Top K Frequent Elements<a hidden class="anchor" aria-hidden="true" href="#leetcode-347-top-k-frequent-elements">#</a></h1>
<p>Given a non-empty array of integers, return the k most frequent elements.</p>
<p>For example,  <br>
Given [1,1,1,2,2,3] and k = 2, return [1,2].</p>
<p>Note:</p>
<p>You may assume k is always valid, 1 ≤ k ≤ number of unique elements.</p>
<p>Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size.</p>
<p>解析：根据题设要求的时间复杂度，只能选择堆排序和桶排序。先利用哈希表处理，求出所有元素出现次数，这就当作该元素的权值。然后构造小顶堆。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">topKFrequent</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">hash</span><span class="p">;</span>
    <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">heap</span><span class="p">;</span><span class="c1">//构造小顶堆
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">num</span><span class="p">:</span><span class="n">nums</span><span class="p">)</span> 
        <span class="n">hash</span><span class="p">[</span><span class="n">num</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">it</span><span class="p">:</span><span class="n">hash</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">heap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">second</span><span class="p">,</span> <span class="n">it</span><span class="p">.</span><span class="n">first</span><span class="p">));</span>
        <span class="k">if</span><span class="p">(</span><span class="n">heap</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span> <span class="n">heap</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="c1">//在堆元素超过K时，删除堆顶元素，因为它不可能是数量最多的K个元素之一
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">heap</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span><span class="c1">//遍历完所有数组元素之后堆中剩下的K个元素即是所求结果
</span><span class="c1"></span>        <span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">heap</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">second</span><span class="p">);</span>
        <span class="n">heap</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>注意：pair默认按first排序，所以要想在小顶堆内按出现频率排序，需要将second和first换位。</p>
<p>补充：因为出现频率最高也就是nums.size(),所以出现频率是一个可知的范围。将每一个出现频率看作一个桶，把相同出现频率的元素放到一个桶中，然后倒序扫描每个桶，输出k个元素。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>  
<span class="nl">public</span><span class="p">:</span>  
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">topKFrequent</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>  
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">hash</span><span class="p">;</span>  
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">buckets</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>  
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">;</span>      
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">num</span><span class="p">:</span><span class="n">nums</span><span class="p">)</span>   
     <span class="n">hash</span><span class="p">[</span><span class="n">num</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>  
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">it</span><span class="p">:</span><span class="n">hash</span><span class="p">)</span>   
    <span class="n">buckets</span><span class="p">[</span><span class="n">it</span><span class="p">.</span><span class="n">second</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>  
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">buckets</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>  
        <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">num</span><span class="p">:</span><span class="n">buckets</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>  
            <span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>  
            <span class="k">if</span><span class="p">(</span><span class="n">ret</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>  
<span class="p">}</span>  
<span class="p">};</span>  
</code></pre></td></tr></table>
</div>
</div><h1 id="169-majority-element">169. Majority Element<a hidden class="anchor" aria-hidden="true" href="#169-majority-element">#</a></h1>
<p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p>解析：</p>
<p>多数投票算法，可以在O(1)空间复杂度中求众数。</p>
<p>简单的理解算法，投票过程中，若从数组中可找出一个二元组，该二元组包含1个候选元素和1个不同的元素，将其从数组中删除。可以形象的理解为多数投票过程。count表示当前候选者的票数。</p>
<p>求解步骤：</p>
<p>如果count==0，则将candidate的值设置为数组的当前元素，将count赋值为1；（候选者本人算一票）</p>
<p>否则，如果candidate和现在数组元素值相同，则count++，反之count–； （相当于投票过程）</p>
<p>重复上述两步，直到扫描完数组。最后的candidate就是出现次数超过一半的数。</p>
<p>检查步骤：</p>
<p>count赋值为0，再次从头扫描数组，如果数组元素值与vote的值相同则count++，直到扫描完数组为止。如果此时count的值大于等于n/2，则返回vote的值，反之则返回-1；</p>
<p>由于题目保证结果一定存在，所以我们省去了最后一步的检查验证</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">majorityElement</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">candidate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="c1">//没有候选者就要新立一位候选者
</span><span class="c1"></span>        <span class="p">{</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>  <span class="c1">//count！=0
</span><span class="c1"></span>        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">candidate</span><span class="p">)</span><span class="c1">//当前候选者票数增加
</span><span class="c1"></span>                <span class="n">count</span> <span class="o">++</span><span class="p">;</span>
            <span class="k">else</span><span class="c1">//候选者票数减少，相当于删除二元组
</span><span class="c1"></span>                <span class="n">count</span> <span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">candidate</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>补充：hash算法，空间复杂度O(n)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">majorityElement</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">counts</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">counts</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="229-majority-element-ii">229. Majority Element II<a hidden class="anchor" aria-hidden="true" href="#229-majority-element-ii">#</a></h1>
<p>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1)</p>
<p>解析：因为要找出的是出现次数大于 n/3 的元素，因此最多只可能存在两个这样的元素。第一次遍历数组，多数投票算法，求出两个众数。</p>
<p>在每一轮投票过程中，若从数组中可找出一个三元组，该三元组包含2个候选元素和1个不同的元素，将其从数组中删除。这样不断的删除直到无法再进行投票，如果数组为空，则没有任何元素出现的次数超过该数组长度的一半。如果只存在一种元素，那么这个元素则可能为目标元素。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">majorityElement</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">count2</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//计数器
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">result1</span><span class="o">=</span><span class="n">INT_MAX</span><span class="p">,</span> <span class="n">result2</span><span class="o">=</span><span class="n">INT_MAX</span><span class="p">;</span><span class="c1">//候选元素
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">num</span><span class="p">:</span><span class="n">nums</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">num</span><span class="o">==</span><span class="n">result1</span><span class="p">)</span> <span class="n">count1</span><span class="o">++</span><span class="p">;</span>
        <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">num</span><span class="o">==</span><span class="n">result2</span><span class="p">)</span> <span class="n">count2</span><span class="o">++</span><span class="p">;</span><span class="c1">//没有找到不同元素，只需要把相同元素累计起来
</span><span class="c1"></span>        <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">count1</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">result1</span><span class="o">=</span><span class="n">num</span><span class="p">;</span> <span class="n">count1</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span><span class="c1">//设当前元素为候选元素
</span><span class="c1"></span>        <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">count2</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">result2</span><span class="o">=</span><span class="n">num</span><span class="p">;</span> <span class="n">count2</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span> <span class="n">count1</span><span class="o">--</span><span class="p">;</span> <span class="n">count2</span><span class="o">--</span><span class="p">;</span> <span class="p">}</span><span class="c1">//相当于删除一个三元组
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="c1">//因为本题未说明结果一定存在，所以需要检验过程
</span><span class="c1"></span>    <span class="n">count1</span><span class="o">=</span><span class="n">count2</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">num</span><span class="p">:</span><span class="n">nums</span><span class="p">){</span><span class="c1">//第二次遍历数组，记录候选元素真正出现的次数。
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">num</span><span class="o">==</span><span class="n">result1</span><span class="p">)</span> <span class="n">count1</span><span class="o">++</span><span class="p">;</span>
        <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">num</span><span class="o">==</span><span class="n">result2</span><span class="p">)</span>  <span class="n">count2</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">count1</span><span class="o">&gt;</span><span class="n">n</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">result1</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">count2</span><span class="o">&gt;</span><span class="n">n</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">result2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>这种一次删掉K个不同的数的思想在面试中通常会变形之后反复出现。例如，下面这道题：有一场投票，投票有效的条件是必须有一个候选人得票数超过半数，但是验票人员不能看到每张选票上选了谁，只能把任意两张选票放到一台机器上看这两张选票是否一样，若一样，则机器给出true的提醒，不一样则给出false的提醒。如果你作为验票的人员，怎么判断这场投票是有效的？这道题目就是原问题的变形，但是“不能看到每张选票上选了谁”的这个限制实际上把用哈希表来解题的可能性完全堵死了。但本文的方法却可以满足题目的要求，因为我们实现的方法只需要当前数和候选数做比较，而不需要知道每个数的值。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/array/">Array</a></li>
      <li><a href="/tags/heap/">heap</a></li>
      <li><a href="/tags/bucket-sort/">Bucket Sort</a></li>
      <li><a href="/tags/%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95/">多数投票算法</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
