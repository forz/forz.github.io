<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>课程安排 | Forz Blog</title>
<meta name="keywords" content="DFS, BFS, 拓扑排序" />
<meta name="description" content="LeetCode 207. Course Schedule There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? For example:">
<meta name="author" content="">
<link rel="canonical" href="/post/%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="课程安排" />
<meta property="og:description" content="LeetCode 207. Course Schedule There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? For example:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-24T19:51:39&#43;00:00" />
<meta property="article:modified_time" content="2017-06-24T19:51:39&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="课程安排"/>
<meta name="twitter:description" content="LeetCode 207. Course Schedule There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? For example:"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "课程安排",
      "item": "/post/%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "课程安排",
  "name": "课程安排",
  "description": "LeetCode 207. Course Schedule There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? For example:",
  "keywords": [
    "DFS", "BFS", "拓扑排序"
  ],
  "articleBody": "LeetCode 207. Course Schedule There are a total of n courses you have to take, labeled from 0 to n - 1.\nSome courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]\nGiven the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?\nFor example:\n2, [[1,0]]\nThere are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.\n2, [[1,0],[0,1]]\nThere are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\nNote:\nThe input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.\nYou may assume that there are no duplicate edges in the input prerequisites.\n解析：\n本题需要判断有向图是否存在环，可以用拓扑排序算法。如果只是判断是否有环存在，不需要建队列来存节点。\nBFS原理很简单，在一个有向图中，每次找到一个没有前驱节点的节点（也就是入度为0的节点），然后把它指向其他节点的边都去掉，重复这个过程（BFS），直到所有节点已被找到，或者没有符合条件的节点（如果图中有环存在）。\nBFS使用每个节点的indegrees。 我们将首先尝试找到一个具有0入度的节点。 如果我们没有找到，在图中必须有一个循环，我们返回false。 我们找到该节点后，将其indegree设置为-1，以防止再次访问它，并将所有其邻居的入度减少1.这个过程将重复n（节点数）次。\n如果我们没有返回false，我们将返回true。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class Solution { public: bool canFinish(int numCourses, vectorpairint, int\u0026 prerequisites) { vectorunordered_setint graph = make_graph(numCourses, prerequisites); vectorint degrees = compute_indegree(graph); for (int i = 0; i  numCourses; i++) {//拓扑排序需要（numCourses-1）次循环  int j = 0; for (; j  numCourses; j++)//找入度为0的节点  if (!degrees[j]) break; if (j == numCourses) return false;//没找到，直接返回false  degrees[j] = -1; for (int neigh : graph[j])//更新邻接节点的入度  degrees[neigh]--; } return true; } private: vectorunordered_setint make_graph(int numCourses, vectorpairint, int\u0026 prerequisites) { vectorunordered_setint graph(numCourses);//创建邻接表  for (auto pre : prerequisites) graph[pre.second].insert(pre.first); return graph; } vectorint compute_indegree(vectorunordered_setint\u0026 graph) { //计算入度  vectorint degrees(graph.size(), 0); for (auto neighbors : graph) for (int neigh : neighbors) degrees[neigh]++; return degrees; } };   补充：\nDFS的解法，也需要建立有向图，还是用二维数组来建立，和BFS不同的是，我们像现在需要一个一维数组visit来记录访问状态，\n大体思路是，先建立好有向图，然后从第一个门课开始，找其可构成哪门课，暂时将当前课程标记为已访问，然后对新得到的课程调用DFS递归，直到出现新的课程已经访问过了，则返回false，没有冲突的话返回true，然后把标记为已访问的课程改为未访问。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution { public: bool canFinish(int numCourses, vectorpairint, int\u0026 prerequisites) { vectorunordered_setint graph = make_graph(numCourses, prerequisites);//保存邻接表  vectorbool onpath(numCourses, false), visited(numCourses, false);//保存访问情况和是否只存在一条路  for (int i = 0; i  numCourses; i++)//扫描所有节点  if (!visited[i] \u0026\u0026 dfs_cycle(graph, i, onpath, visited))//先计算visited，若为0，则进行dfs  return false;//如果dfs返回真，那么存在环  return true; } private: vectorunordered_setint make_graph(int numCourses, vectorpairint, int\u0026 prerequisites) { vectorunordered_setint graph(numCourses);//包含set的vector存储邻接表  for (auto pre : prerequisites) graph[pre.second].insert(pre.first); return graph; } bool dfs_cycle(vectorunordered_setint\u0026 graph, int node, vectorbool\u0026 onpath, vectorbool\u0026 visited) { //dfs过程中需要传递的变量有当前dfs过程中经过的点和总的访问情况  if (visited[node]) return false;//如果之前dfs经过  onpath[node] = visited[node] = true; for (int neigh : graph[node])//nopath维护当前dfs过程中经过的点，  if (onpath[neigh] || dfs_cycle(graph, neigh, onpath, visited)) return true;//如果邻接点有此次dfs中已经访问过的点，说明有环  return onpath[node] = false;//如果没找到环，维护onpath为false 返回false } };   LeetCode 210. Course Schedule II There are a total of n courses you have to take, labeled from 0 to n - 1.\nSome courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]\nGiven the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.\nThere may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.\nFor example:\n2, [[1,0]]\nThere are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]\n4, [[1,0],[2,0],[3,1],[3,2]]\nThere are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].\nNote:\nThe input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.\nYou may assume that there are no duplicate edges in the input prerequisites.\n解析：\n这个题是Leetcode 207 Course Schedule的延伸，解法与其类似，只是多了一个按序添加完成的课程。此处不作过多解释，可以看之前的文章。使用广度优先搜索和深度优先搜索均可实现拓扑排序，最后加一步判断是否存在环，如果存在环则返回空集合。bfs和dfs的区别在于是按照入度还是出度来考虑问题上。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  class Solution { public: vectorint findOrder(int numCourses, vectorpairint, int\u0026 prerequisites) { vectorunordered_setint graph = make_graph(numCourses, prerequisites);//存储邻接表  vectorint degrees = compute_indegree(graph);//保存入度  queueint zeros;//保存拓扑排序  for (int i = 0; i  numCourses; i++)//入度为0的点入队列  if (!degrees[i]) zeros.push(i); vectorint toposort; for (int i = 0; i  numCourses; i++) {//至多执行numcourses次BFS 就可以得到拓扑序列  if (zeros.empty()) return {}; //上一次循环把最后一个点读出也没找到入度为1的邻接点，不存在拓扑序列  int zero = zeros.front();//取出起点  zeros.pop(); toposort.push_back(zero);//放入结果中  for (int neigh : graph[zero]) { if (!--degrees[neigh])//如果入度减1后为0压入队列，可以进入拓扑结果  zeros.push(neigh); } } return toposort; } private: vectorunordered_setint make_graph(int numCourses, vectorpairint, int\u0026 prerequisites) { vectorunordered_setint graph(numCourses); for (auto pre : prerequisites) graph[pre.second].insert(pre.first); return graph; } vectorint compute_indegree(vectorunordered_setint\u0026 graph) { vectorint degrees(graph.size(), 0); for (auto neighbors : graph) for (int neigh : neighbors) degrees[neigh]++; return degrees; } };   补充：DFS\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Solution { public: vectorint findOrder(int numCourses, vectorpairint, int\u0026 prerequisites) { vectorunordered_setint graph = make_graph(numCourses, prerequisites); vectorint toposort; vectorbool onpath(numCourses, false), visited(numCourses, false); for (int i = 0; i  numCourses; i++) if (!visited[i] \u0026\u0026 dfs(graph, i, onpath, visited, toposort)) return {}; reverse(toposort.begin(), toposort.end()); return toposort; } private: vectorunordered_setint make_graph(int numCourses, vectorpairint, int\u0026 prerequisites) { vectorunordered_setint graph(numCourses); for (auto pre : prerequisites) graph[pre.second].insert(pre.first); return graph; } bool dfs(vectorunordered_setint\u0026 graph, int node, vectorbool\u0026 onpath, vectorbool\u0026 visited, vectorint\u0026 toposort) { if (visited[node]) return false; onpath[node] = visited[node] = true; for (int neigh : graph[node]) if (onpath[neigh] || dfs(graph, neigh, onpath, visited, toposort)) return true; toposort.push_back(node); return onpath[node] = false; } };   ",
  "wordCount" : "2216",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-24T19:51:39Z",
  "dateModified": "2017-06-24T19:51:39Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      课程安排
    </h1>
    <div class="post-meta">June 24, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="leetcode-207-course-schedule">LeetCode 207. Course Schedule<a hidden class="anchor" aria-hidden="true" href="#leetcode-207-course-schedule">#</a></h1>
<p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>
<p>For example:</p>
<p>2, [[1,0]]</p>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p>
<p>2, [[1,0],[0,1]]</p>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p>
<p>Note:</p>
<p>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.</p>
<p>You may assume that there are no duplicate edges in the input prerequisites.</p>
<p>解析：</p>
<p>本题需要判断有向图是否存在环，可以用拓扑排序算法。如果只是判断是否有环存在，不需要建队列来存节点。</p>
<p>BFS原理很简单，在一个有向图中，每次找到一个没有前驱节点的节点（也就是入度为0的节点），然后把它指向其他节点的边都去掉，重复这个过程（BFS），直到所有节点已被找到，或者没有符合条件的节点（如果图中有环存在）。</p>
<p>BFS使用每个节点的indegrees。 我们将首先尝试找到一个具有0入度的节点。 如果我们没有找到，在图中必须有一个循环，我们返回false。 我们找到该节点后，将其indegree设置为-1，以防止再次访问它，并将所有其邻居的入度减少1.这个过程将重复n（节点数）次。</p>
<p>如果我们没有返回false，我们将返回true。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">bool</span> <span class="n">canFinish</span><span class="p">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">prerequisites</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">make_graph</span><span class="p">(</span><span class="n">numCourses</span><span class="p">,</span> <span class="n">prerequisites</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">degrees</span> <span class="o">=</span> <span class="n">compute_indegree</span><span class="p">(</span><span class="n">graph</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="c1">//拓扑排序需要（numCourses-1）次循环
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="c1">//找入度为0的节点
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">degrees</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">numCourses</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//没找到，直接返回false
</span><span class="c1"></span>        <span class="n">degrees</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">neigh</span> <span class="p">:</span> <span class="n">graph</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="c1">//更新邻接节点的入度
</span><span class="c1"></span>            <span class="n">degrees</span><span class="p">[</span><span class="n">neigh</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="nl">private</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">make_graph</span><span class="p">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">prerequisites</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="p">(</span><span class="n">numCourses</span><span class="p">);</span><span class="c1">//创建邻接表
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">pre</span> <span class="p">:</span> <span class="n">prerequisites</span><span class="p">)</span>
        <span class="n">graph</span><span class="p">[</span><span class="n">pre</span><span class="p">.</span><span class="n">second</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="n">pre</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">graph</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">compute_indegree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">graph</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//计算入度
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">degrees</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">neighbors</span> <span class="p">:</span> <span class="n">graph</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">neigh</span> <span class="p">:</span> <span class="n">neighbors</span><span class="p">)</span>
            <span class="n">degrees</span><span class="p">[</span><span class="n">neigh</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">degrees</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span> 
</code></pre></td></tr></table>
</div>
</div><p>补充：</p>
<p>DFS的解法，也需要建立有向图，还是用二维数组来建立，和BFS不同的是，我们像现在需要一个一维数组visit来记录访问状态，</p>
<p>大体思路是，先建立好有向图，然后从第一个门课开始，找其可构成哪门课，暂时将当前课程标记为已访问，然后对新得到的课程调用DFS递归，直到出现新的课程已经访问过了，则返回false，没有冲突的话返回true，然后把标记为已访问的课程改为未访问。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">bool</span> <span class="n">canFinish</span><span class="p">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">prerequisites</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">make_graph</span><span class="p">(</span><span class="n">numCourses</span><span class="p">,</span> <span class="n">prerequisites</span><span class="p">);</span><span class="c1">//保存邻接表
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">onpath</span><span class="p">(</span><span class="n">numCourses</span><span class="p">,</span> <span class="nb">false</span><span class="p">),</span> <span class="n">visited</span><span class="p">(</span><span class="n">numCourses</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span><span class="c1">//保存访问情况和是否只存在一条路
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//扫描所有节点
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">dfs_cycle</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">onpath</span><span class="p">,</span> <span class="n">visited</span><span class="p">))</span><span class="c1">//先计算visited，若为0，则进行dfs
</span><span class="c1"></span>            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//如果dfs返回真，那么存在环
</span><span class="c1"></span>    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="nl">private</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">make_graph</span><span class="p">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">prerequisites</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="p">(</span><span class="n">numCourses</span><span class="p">);</span><span class="c1">//包含set的vector存储邻接表
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">pre</span> <span class="p">:</span> <span class="n">prerequisites</span><span class="p">)</span>
        <span class="n">graph</span><span class="p">[</span><span class="n">pre</span><span class="p">.</span><span class="n">second</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="n">pre</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">graph</span><span class="p">;</span>
<span class="p">}</span> 
<span class="kt">bool</span> <span class="n">dfs_cycle</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">graph</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="n">onpath</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="n">visited</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//dfs过程中需要传递的变量有当前dfs过程中经过的点和总的访问情况
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//如果之前dfs经过
</span><span class="c1"></span>    <span class="n">onpath</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> 
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">neigh</span> <span class="p">:</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">])</span><span class="c1">//nopath维护当前dfs过程中经过的点，
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">onpath</span><span class="p">[</span><span class="n">neigh</span><span class="p">]</span> <span class="o">||</span> <span class="n">dfs_cycle</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">neigh</span><span class="p">,</span> <span class="n">onpath</span><span class="p">,</span> <span class="n">visited</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span><span class="c1">//如果邻接点有此次dfs中已经访问过的点，说明有环
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">onpath</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//如果没找到环，维护onpath为false 返回false
</span><span class="c1"></span><span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-210-course-schedule-ii">LeetCode 210. Course Schedule II<a hidden class="anchor" aria-hidden="true" href="#leetcode-210-course-schedule-ii">#</a></h1>
<p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.</p>
<p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>
<p>For example:</p>
<p>2, [[1,0]]</p>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]</p>
<p>4, [[1,0],[2,0],[3,1],[3,2]]</p>
<p>There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].</p>
<p>Note:</p>
<p>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.</p>
<p>You may assume that there are no duplicate edges in the input prerequisites.</p>
<p>解析：</p>
<p>这个题是Leetcode 207 Course Schedule的延伸，解法与其类似，只是多了一个按序添加完成的课程。此处不作过多解释，可以看之前的文章。使用广度优先搜索和深度优先搜索均可实现拓扑排序，最后加一步判断是否存在环，如果存在环则返回空集合。bfs和dfs的区别在于是按照入度还是出度来考虑问题上。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">findOrder</span><span class="p">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">prerequisites</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">make_graph</span><span class="p">(</span><span class="n">numCourses</span><span class="p">,</span> <span class="n">prerequisites</span><span class="p">);</span><span class="c1">//存储邻接表
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">degrees</span> <span class="o">=</span> <span class="n">compute_indegree</span><span class="p">(</span><span class="n">graph</span><span class="p">);</span><span class="c1">//保存入度
</span><span class="c1"></span>    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">zeros</span><span class="p">;</span><span class="c1">//保存拓扑排序
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//入度为0的点入队列
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">degrees</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">zeros</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">toposort</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="c1">//至多执行numcourses次BFS 就可以得到拓扑序列
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">zeros</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="p">{};</span>
    <span class="c1">//上一次循环把最后一个点读出也没找到入度为1的邻接点，不存在拓扑序列
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">zero</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">.</span><span class="n">front</span><span class="p">();</span><span class="c1">//取出起点
</span><span class="c1"></span>        <span class="n">zeros</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">toposort</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">zero</span><span class="p">);</span><span class="c1">//放入结果中
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">neigh</span> <span class="p">:</span> <span class="n">graph</span><span class="p">[</span><span class="n">zero</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">degrees</span><span class="p">[</span><span class="n">neigh</span><span class="p">])</span><span class="c1">//如果入度减1后为0压入队列，可以进入拓扑结果
</span><span class="c1"></span>                <span class="n">zeros</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">neigh</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">toposort</span><span class="p">;</span>
<span class="p">}</span>
<span class="nl">private</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">make_graph</span><span class="p">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">prerequisites</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="p">(</span><span class="n">numCourses</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">pre</span> <span class="p">:</span> <span class="n">prerequisites</span><span class="p">)</span>
        <span class="n">graph</span><span class="p">[</span><span class="n">pre</span><span class="p">.</span><span class="n">second</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="n">pre</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">graph</span><span class="p">;</span> 
<span class="p">}</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">compute_indegree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">graph</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">degrees</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">neighbors</span> <span class="p">:</span> <span class="n">graph</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">neigh</span> <span class="p">:</span> <span class="n">neighbors</span><span class="p">)</span>
            <span class="n">degrees</span><span class="p">[</span><span class="n">neigh</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">degrees</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>补充：DFS</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">findOrder</span><span class="p">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">prerequisites</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">make_graph</span><span class="p">(</span><span class="n">numCourses</span><span class="p">,</span> <span class="n">prerequisites</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">toposort</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">onpath</span><span class="p">(</span><span class="n">numCourses</span><span class="p">,</span> <span class="nb">false</span><span class="p">),</span> <span class="n">visited</span><span class="p">(</span><span class="n">numCourses</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">onpath</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">toposort</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">{};</span>
    <span class="n">reverse</span><span class="p">(</span><span class="n">toposort</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">toposort</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">toposort</span><span class="p">;</span>
<span class="p">}</span>
<span class="nl">private</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">make_graph</span><span class="p">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">prerequisites</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="p">(</span><span class="n">numCourses</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">pre</span> <span class="p">:</span> <span class="n">prerequisites</span><span class="p">)</span>
        <span class="n">graph</span><span class="p">[</span><span class="n">pre</span><span class="p">.</span><span class="n">second</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="n">pre</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">graph</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="n">dfs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">graph</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="n">onpath</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="n">visited</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">toposort</span><span class="p">)</span> <span class="p">{</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">onpath</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> 
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">neigh</span> <span class="p">:</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">onpath</span><span class="p">[</span><span class="n">neigh</span><span class="p">]</span> <span class="o">||</span> <span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">neigh</span><span class="p">,</span> <span class="n">onpath</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">toposort</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">toposort</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">onpath</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/dfs/">DFS</a></li>
      <li><a href="/tags/bfs/">BFS</a></li>
      <li><a href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/">拓扑排序</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
