<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>区间查询问题 | Forz Blog</title>
<meta name="keywords" content="Binary Indexed Tree, DP" />
<meta name="description" content="LeetCode 303. Range Sum Query - Immutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -&gt; 1 sumRange(2, 5) -&gt; -1 sumRange(0, 5) -&gt; -3 Note: You may assume that the array does not change. There are many calls to sumRange function. 解析： 数">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="区间查询问题" />
<meta property="og:description" content="LeetCode 303. Range Sum Query - Immutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -&gt; 1 sumRange(2, 5) -&gt; -1 sumRange(0, 5) -&gt; -3 Note: You may assume that the array does not change. There are many calls to sumRange function. 解析： 数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-24T16:11:52&#43;00:00" />
<meta property="article:modified_time" content="2017-06-24T16:11:52&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="区间查询问题"/>
<meta name="twitter:description" content="LeetCode 303. Range Sum Query - Immutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -&gt; 1 sumRange(2, 5) -&gt; -1 sumRange(0, 5) -&gt; -3 Note: You may assume that the array does not change. There are many calls to sumRange function. 解析： 数"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "区间查询问题",
      "item": "/post/%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "区间查询问题",
  "name": "区间查询问题",
  "description": "LeetCode 303. Range Sum Query - Immutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -\u0026gt; 1 sumRange(2, 5) -\u0026gt; -1 sumRange(0, 5) -\u0026gt; -3 Note: You may assume that the array does not change. There are many calls to sumRange function. 解析： 数",
  "keywords": [
    "Binary Indexed Tree", "DP"
  ],
  "articleBody": "LeetCode 303. Range Sum Query - Immutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.\nExample:\nGiven nums = [-2, 0, 3, -5, 2, -1]\nsumRange(0, 2) - 1\nsumRange(2, 5) - -1\nsumRange(0, 5) - -3\nNote:\nYou may assume that the array does not change.\nThere are many calls to sumRange function.\n解析：\n数组不会更新的话求固定区间的和，只需要预处理的时候维护前缀和即可。注意数组本身为空的情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class NumArray {//前缀和 public: NumArray(vectorint nums) { accu.push_back(0);//虚拟头节点可以防止nums本身为空  for (int num : nums)//维护前缀和  accu.push_back(accu.back() + num); } int sumRange(int i, int j) { return accu[j + 1] - accu[i];//accu有虚拟头节点 } private: vectorint accu; }; // Your NumArray object will be instantiated and called as such: // NumArray numArray(nums); // numArray.sumRange(0, 1); // numArray.sumRange(1, 2);   LeetCode 304. Range Sum Query 2D - Immutable Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).\nThe above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.\nExample:\nGiven matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5] ] sumRegion(2, 1, 4, 3) - 8 sumRegion(1, 1, 2, 2) - 11 sumRegion(1, 2, 2, 4) - 12  Note:\nYou may assume that the matrix does not change.\nThere are many calls to sumRegion function.\nYou may assume that row1 ≤ row2 and col1 ≤ col2.\n解析：\nacc[i][j]表示累计区间(0, 0)到(i, j)这个矩形区间所有的数字之和，\nacc[i][j] = acc[i][j-1] + acc[i-1][j] - acc[i-1][j-1] + matrix[i-1][j-1]\nDP过程中为了优化代码，存在一个辅助边框：第0行和第0列，防止DP过程越界\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class NumMatrix { private: vectorvectorint acc; public: NumMatrix(vectorvectorint matrix) { if (matrix.empty()) return; int n = matrix.size(), m = matrix[0].size();//n为行，m为列  acc.resize(n + 1, vectorint(m + 1)); for (int i = 0; i  n; ++i) acc[i][0] = 0;//初始化dp边界值（辅助行和辅助列）  for (int j = 0; j  m; ++j) acc[0][j] = 0; for (int i = 1; i  n; ++i) {//i和j都从1开始，存在一个辅助边框防止越界  for (int j = 1; j  m; ++j) { acc[i][j] = acc[i][j-1] + acc[i-1][j] - acc[i-1][j-1] + matrix[i-1][j-1]; } } } int sumRegion(int row1, int col1, int row2, int col2) {//坐标从0开始，但因为添加辅助边框，需要+1再求结果  return acc[row2+1][col2+1] - acc[row1][col2+1] - acc[row2+1][col1] + acc[row1][col1]; } }; /** * Your NumMatrix object will be instantiated and called as such: * NumMatrix obj = new NumMatrix(matrix); * int param_1 = obj.sumRegion(row1,col1,row2,col2); */   LeetCode 307. Range Sum Query - Mutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.\nThe update(i, val) function modifies nums by updating the element at index i to val. Example:\nGiven nums = [1, 3, 5] sumRange(0, 2) - 9 update(1, 2) sumRange(0, 2) - 8  Note:\nThe array is only modifiable by the update function.\nYou may assume the number of calls to update and sumRange function is distributed evenly.\n解析：\n如果数组是可更新的，用树状数组。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  class NumArray { public: vectorint sums; vectorint nums; int lowbit(int x){//移动  return x\u0026(-x); } void change(int i, int vals){ while(isums.size()){ sums[i]+=vals; i+=lowbit(i); } } int sum(int n){//求和  int sum=0; while(n0){ sum+=sums[n]; n-=lowbit(n); } return sum; } NumArray(const vectorint \u0026nums) {//此处注意，需要修改vector为const  this-nums = nums; sums.resize(nums.size()+1); for(int i=0;inums.size();i++){ change(i+1,nums[i]); } } void update(int i, int val) { int delta = val-nums[i]; nums[i] = val; change(i+1,delta);//树状数组下标从1开始 } int sumRange(int i, int j) { return sum(j+1)-sum(i); } };   LeetCode 315. Count of Smaller Numbers After Self You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].\nExample:\nGiven nums = [5, 2, 6, 1]\nTo the right of 5 there are 2 smaller elements (2 and 1).\nTo the right of 2 there is only 1 smaller element (1).\nTo the right of 6 there is 1 smaller element (1).\nTo the right of 1 there is 0 smaller element.\nReturn the array [2, 1, 1, 0].\n解析：\n线段树适用于和区间统计有关的问题。比如某些数据可以按区间进行划分，按区间动态进行修改，而且还需要按区间多次进行查询，那么使用线段树可以达到较快查询速度。\n数状数组每一个元素都代表当前索引位置的结果。看似一个数组，其实是一个保存了结果的区间。求逆序数就是找每个元素后面比它小的元素个数。后面的元素个数可以用树状数组保存，逆序扫描，每次查询完一个结果，就可以将元素添加进去再继续扫描。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  class Solution { public: vectorint countSmaller(vectorint\u0026 nums) { vectorint ret, clone = nums; int len =nums.size(); unordered_mapint, int reflect; array.resize(len + 1); sort(clone.begin(), clone.end());//重新排序（只是为了离散化）  //因为数的范围大，但数的个数固定，所以可以把n个范围极大的数利用map离散化，映射成1~n  //这样就不用开像数的范围那么大的数组，只需要开n+1个元素的数组，而且保证了大小关系  for (int i = 0; i  len; ++ i) reflect[clone[i]] = i + 1;//按大小标号，保证每个数与其他数的大小关系不变  for (int i = len - 1; i = 0; -- i) {//逆向扫描原数组（与每个数有关的只有后面比它小的数）  clone[i] = query(reflect[nums[i]] - 1);//查询结果（查询小于等于i-1的数的总个数）  add(reflect[nums[i]], 1);//在该位置和该位置之后全部+1  } return clone; } private: vectorint array; inline int lowbit(int pos) {//找x二进制下为1的最低位  return pos \u0026 -pos; } void add(int pos, int val) {//建树  for (int i=pos;iarray.size();i+=lowbit(i)) { array[i] += val; } } int query(int pos) {//求解  int ret = 0; for(int i=pos;i0;i-=lowbit(i)) { ret += array[i]; } return ret; } };   LeetCode 327. Count of Range Sum Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive.\nRange sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i ≤ j), inclusive.\nNote:\nA naive algorithm of O(n2) is trivial. You MUST do better than that.\nExample:\nGiven nums = [-2, 5, -1], lower = -2, upper = 2,\nReturn 3.\nThe three ranges are : [0, 0], [2, 2], [0, 2] and their respective sums are: -2, -1, 2.\n解析：\n树状数组\n需要找满足条件 lower ≤ sum[j] – sum[i – 1] ≤ upper ，也就是lower + sum[i – 1] ≤ sum[j] ≤ upper + sum[i – 1]\n我们同样的求出和，然后离散化，接着从右向左扫描，对每个i 查询满足在[ lower + sum[i – 1], upper + sum[i – 1] ]范围内的个数（用线段树或者Fenwick Tree）这样复杂度就是O(n log n)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  typedef long long LL; class FenwickTree { vectorint sum_array; int n; inline int lowbit(int x) { return x \u0026 -x; } public: FenwickTree(int n) :n(n), sum_array(n + 1, 0) {} void add(int x, int val) { while (x  n) { sum_array[x] += val; x += lowbit(x); } } int sum(int x) { int res = 0; while (x  0) { res += sum_array[x]; x -= lowbit(x); } return res; } }; class Solution { public: int countRangeSum(vectorint\u0026 nums, int lower, int upper) { if (nums.size() == 0) return 0; vectorLL sum_array (nums.size() * 3,0); LL sum = 0; for (int i = 0; i  nums.size(); i++) { sum += nums[i]; sum_array[i * 3] = sum; sum_array[i * 3 + 1] = sum + lower - 1; sum_array[i * 3 + 2] = sum + upper; } sum_array.push_back(upper); sum_array.push_back(lower - 1); unordered_mapLL, int index; sort(sum_array.begin(), sum_array.end()); auto end = unique(sum_array.begin(), sum_array.end()); auto it = sum_array.begin(); for (int i = 1; it != end;i++,it++) { index[*it] = i; } FenwickTree tree(index.size()); int ans = 0; for (int i = nums.size() - 1; i = 0; i--) { tree.add(index[sum],1); sum -= nums[i]; ans += tree.sum(index[upper + sum]) - tree.sum(index[lower + sum -1]); } return ans; } }; 补充：STL方法 class Solution { public: int countRangeSum(vectorint\u0026 nums, int lower, int upper) { long long sum=0,ret=0; multisetlong long accum={0}; for(auto x:nums){ sum+=x; auto start=accum.lower_bound(sum-upper),end=accum.upper_bound(sum-lower); while(start!=end) ret++,start++; accum.insert(sum); } return ret; } };   补充：\n归并方法\n将子数组和转换成两个前缀数组和的差，定义数组 sum, sum[i] 表示数组前 i 个元素的和，特殊的, sum[0]=0，那么元素 i 到元素 j 的和可以表示为 sum[j]-sum[i-1]。我们枚举 0 到nums.length，\n比如枚举到了 sum[j]，我们需要求满足条件的 i（i用二分维护有序数组（用 splice 插入），同时用二分找到临界的数据，一次迭代需要多次二分。\n在合并左右数组的时候对于左边数组中的每一个元素在右边数组找到一个范围, 使得在这个范围中的的元素与左边的元素构成的区间和落在[lower, upper]之间.即在右边数组找到两个边界, 设为m, n, 其中m是在右边数组中第一个使得sum[m] - sum[i] = lower的位置, n是第一个使得sum[n] - sum[i]  upper的位置,\n这样n-m就是与左边元素i所构成的位于[lower, upper]范围的区间个数. 因为左右两边都是已经有序的, 这样可以避免不必要的比较\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class Solution { public: int mergeSort(vectorlong\u0026 sum, int lower, int upper, int low, int high) { if(high-low  1) return 0; //递归终止条件  int mid = low+(high-low)/2, m = mid, n = mid, count =0; count = mergeSort(sum,lower,upper,low,mid) + mergeSort(sum,lower,upper,mid,high); for(int i =low; i mid; i++) { while(m  high \u0026\u0026 sum[m] - sum[i]  lower) m++; while(n  high \u0026\u0026 sum[n] - sum[i]  upper) n++; count += n - m; } // sort(sum.begin()+low，sum.begin()+high);  return count; } int countRangeSum(vectorint\u0026 nums, int lower, int upper) { int len = nums.size(); vectorlong sum(len + 1, 0); for(int i =0; i len; i++) sum[i+1] = sum[i]+nums[i]; //预处理前缀和  return mergeSort(sum, lower, upper, 0, len+1); } };   LeetCode 493. Reverse Pairs Given an array nums, we call (i, j) an important reverse pair if i 2*nums[j].\nYou need to return the number of important reverse pairs in the given array.\nExample1:\nInput: [1,3,2,3,1]. Output: 2. Example2:\nInput: [2,4,3,5,1]. Output: 3. Note:\nThe length of the given array will not exceed 50,000.\nAll the numbers in the input array are in the range of 32-bit integer.\n解析：树状数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class Solution { public: int reversePairs(vectorint\u0026 nums) { int res = 0; int n = nums.size(); for (int i = n - 1; i = 0; i--) { res += query((long long)nums[i] - 1); add((long long)nums[i] * 2); } return res; } private: void add(long long x) { for (x += 1LL  34; x  1LL  36; x += lowbit(x)) { bit[x]++; } } int query(long long x) { int cnt = 0; for (x += 1LL  34; x != 0; x -= lowbit(x)) { if (bit.count(x)) cnt += bit[x]; } return cnt; } long long lowbit(long long x) { return x \u0026 (-x); } private: unordered_maplong long, int bit; };   补充：归并\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution { private: int count; void mergeSort(vectorint\u0026 nums, int start, int end){ if(start == end) return; int mid = (start + end)/2; mergeSort(nums,start, mid); mergeSort(nums,mid+1,end); int l = start, r = mid + 1; while(l  mid \u0026\u0026 r  end){ if((long)nums[l]  (long) 2 * nums[r]){ count += (mid - l + 1); r++; }else{ l++; } } sort(nums.begin() + start, nums.begin() + end + 1);//便于比较  return; } public: int reversePairs(vectorint\u0026 nums) { if(!nums.size())return 0; count = 0; mergeSort(nums,0,nums.size()-1); return count; } };   ",
  "wordCount" : "3237",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-24T16:11:52Z",
  "dateModified": "2017-06-24T16:11:52Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      区间查询问题
    </h1>
    <div class="post-meta">June 24, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="leetcode-303-range-sum-query---immutable">LeetCode 303. Range Sum Query - Immutable<a hidden class="anchor" aria-hidden="true" href="#leetcode-303-range-sum-query---immutable">#</a></h1>
<p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.</p>
<p>Example:<br>
Given nums = [-2, 0, 3, -5, 2, -1]</p>
<p>sumRange(0, 2) -&gt; 1<br>
sumRange(2, 5) -&gt; -1<br>
sumRange(0, 5) -&gt; -3</p>
<p>Note:</p>
<p>You may assume that the array does not change.<br>
There are many calls to sumRange function.</p>
<p>解析：</p>
<p>数组不会更新的话求固定区间的和，只需要预处理的时候维护前缀和即可。注意数组本身为空的情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">NumArray</span> <span class="p">{</span><span class="c1">//前缀和
</span><span class="c1"></span><span class="nl">public</span><span class="p">:</span>
<span class="n">NumArray</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">accu</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="c1">//虚拟头节点可以防止nums本身为空
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">num</span> <span class="p">:</span> <span class="n">nums</span><span class="p">)</span><span class="c1">//维护前缀和
</span><span class="c1"></span>        <span class="n">accu</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">accu</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">+</span> <span class="n">num</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">sumRange</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">accu</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">accu</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="c1">//accu有虚拟头节点
</span><span class="c1"></span><span class="p">}</span>
<span class="nl">private</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">accu</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// Your NumArray object will be instantiated and called as such:
</span><span class="c1">// NumArray numArray(nums);
</span><span class="c1">// numArray.sumRange(0, 1);
</span><span class="c1">// numArray.sumRange(1, 2); 
</span></code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-304-range-sum-query-2d---immutable">LeetCode 304. Range Sum Query 2D - Immutable<a hidden class="anchor" aria-hidden="true" href="#leetcode-304-range-sum-query-2d---immutable">#</a></h1>
<p>Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/range_sum_query_2d.png" alt=""  />
</p>
<p>The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.</p>
<p>Example:</p>
<pre><code>Given matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -&gt; 8  
sumRegion(1, 1, 2, 2) -&gt; 11  
sumRegion(1, 2, 2, 4) -&gt; 12 
</code></pre>
<p>Note:</p>
<p>You may assume that the matrix does not change.</p>
<p>There are many calls to sumRegion function.</p>
<p>You may assume that row1 ≤ row2 and col1 ≤ col2.</p>
<p>解析：</p>
<p>acc[i][j]表示累计区间(0, 0)到(i, j)这个矩形区间所有的数字之和，</p>
<p>acc[i][j] = acc[i][j-1] + acc[i-1][j] - acc[i-1][j-1] + matrix[i-1][j-1]</p>
<p>DP过程中为了优化代码，存在一个辅助边框：第0行和第0列，防止DP过程越界</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">NumMatrix</span> <span class="p">{</span>
<span class="nl">private</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">acc</span><span class="p">;</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">NumMatrix</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">matrix</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="c1">//n为行，m为列
</span><span class="c1"></span>    <span class="n">acc</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">acc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//初始化dp边界值（辅助行和辅助列）
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="c1">//i和j都从1开始，存在一个辅助边框防止越界
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">acc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">acc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">acc</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">acc</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span> 
<span class="p">}</span>
<span class="kt">int</span> <span class="n">sumRegion</span><span class="p">(</span><span class="kt">int</span> <span class="n">row1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col2</span><span class="p">)</span> <span class="p">{</span><span class="c1">//坐标从0开始，但因为添加辅助边框，需要+1再求结果
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">acc</span><span class="p">[</span><span class="n">row2</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">col2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">acc</span><span class="p">[</span><span class="n">row1</span><span class="p">][</span><span class="n">col2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">acc</span><span class="p">[</span><span class="n">row2</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">col1</span><span class="p">]</span> <span class="o">+</span> <span class="n">acc</span><span class="p">[</span><span class="n">row1</span><span class="p">][</span><span class="n">col1</span><span class="p">];</span>
<span class="p">}</span>
<span class="p">};</span>
<span class="cm">/**
</span><span class="cm"> * Your NumMatrix object will be instantiated and called as such:
</span><span class="cm"> * NumMatrix obj = new NumMatrix(matrix);
</span><span class="cm"> * int param_1 = obj.sumRegion(row1,col1,row2,col2);
</span><span class="cm"> */</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-307-range-sum-query---mutable">LeetCode 307. Range Sum Query - Mutable<a hidden class="anchor" aria-hidden="true" href="#leetcode-307-range-sum-query---mutable">#</a></h1>
<p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.</p>
<p>The update(i, val) function modifies nums by updating the element at index i to val.
Example:</p>
<pre><code>Given nums = [1, 3, 5]
sumRange(0, 2) -&gt; 9  
update(1, 2)  
sumRange(0, 2) -&gt; 8  
</code></pre>
<p>Note:</p>
<p>The array is only modifiable by the update function.</p>
<p>You may assume the number of calls to update and sumRange function is distributed evenly.</p>
<p>解析：</p>
<p>如果数组是可更新的，用树状数组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">NumArray</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sums</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">lowbit</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span><span class="c1">//移动
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">x</span><span class="o">&amp;</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">change</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vals</span><span class="p">){</span>
    <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">sums</span><span class="p">.</span><span class="n">size</span><span class="p">()){</span>
        <span class="n">sums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="n">vals</span><span class="p">;</span>
        <span class="n">i</span><span class="o">+=</span><span class="n">lowbit</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span><span class="c1">//求和
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span>
        <span class="n">sum</span><span class="o">+=</span><span class="n">sums</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
        <span class="n">n</span><span class="o">-=</span><span class="n">lowbit</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">NumArray</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">)</span> <span class="p">{</span><span class="c1">//此处注意，需要修改vector为const
</span><span class="c1"></span>    <span class="n">this</span><span class="o">-&gt;</span><span class="n">nums</span> <span class="o">=</span> <span class="n">nums</span><span class="p">;</span>
    <span class="n">sums</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">change</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">val</span><span class="o">-</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">change</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">delta</span><span class="p">);</span><span class="c1">//树状数组下标从1开始
</span><span class="c1"></span><span class="p">}</span>
<span class="kt">int</span> <span class="n">sumRange</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">sum</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-315-count-of-smaller-numbers-after-self">LeetCode 315. Count of Smaller Numbers After Self<a hidden class="anchor" aria-hidden="true" href="#leetcode-315-count-of-smaller-numbers-after-self">#</a></h1>
<p>You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].</p>
<p>Example:</p>
<p>Given nums = [5, 2, 6, 1]</p>
<p>To the right of 5 there are 2 smaller elements (2 and 1).<br>
To the right of 2 there is only 1 smaller element (1).<br>
To the right of 6 there is 1 smaller element (1).<br>
To the right of 1 there is 0 smaller element.<br>
Return the array [2, 1, 1, 0].</p>
<p>解析：</p>
<p>线段树适用于和区间统计有关的问题。比如某些数据可以按区间进行划分，按区间动态进行修改，而且还需要按区间多次进行查询，那么使用线段树可以达到较快查询速度。</p>
<p>数状数组每一个元素都代表当前索引位置的结果。看似一个数组，其实是一个保存了结果的区间。求逆序数就是找每个元素后面比它小的元素个数。后面的元素个数可以用树状数组保存，逆序扫描，每次查询完一个结果，就可以将元素添加进去再继续扫描。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">countSmaller</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">,</span> <span class="n">clone</span> <span class="o">=</span> <span class="n">nums</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">reflect</span><span class="p">;</span>
    <span class="n">array</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">clone</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">clone</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="c1">//重新排序（只是为了离散化）
</span><span class="c1"></span>    <span class="c1">//因为数的范围大，但数的个数固定，所以可以把n个范围极大的数利用map离散化，映射成1~n
</span><span class="c1"></span>    <span class="c1">//这样就不用开像数的范围那么大的数组，只需要开n+1个元素的数组，而且保证了大小关系
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">reflect</span><span class="p">[</span><span class="n">clone</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//按大小标号，保证每个数与其他数的大小关系不变
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="c1">//逆向扫描原数组（与每个数有关的只有后面比它小的数）
</span><span class="c1"></span>        <span class="n">clone</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">query</span><span class="p">(</span><span class="n">reflect</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span><span class="c1">//查询结果（查询小于等于i-1的数的总个数）
</span><span class="c1"></span>        <span class="n">add</span><span class="p">(</span><span class="n">reflect</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="mi">1</span><span class="p">);</span><span class="c1">//在该位置和该位置之后全部+1
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="n">clone</span><span class="p">;</span>
<span class="p">}</span>
<span class="nl">private</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">array</span><span class="p">;</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">lowbit</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span><span class="c1">//找x二进制下为1的最低位
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span><span class="c1">//建树
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">pos</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">array</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">+=</span><span class="n">lowbit</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>
<span class="kt">int</span> <span class="nf">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span><span class="c1">//求解
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">pos</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">-=</span><span class="n">lowbit</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-327-count-of-range-sum">LeetCode 327. Count of Range Sum<a hidden class="anchor" aria-hidden="true" href="#leetcode-327-count-of-range-sum">#</a></h1>
<p>Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive.</p>
<p>Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i ≤ j), inclusive.</p>
<p>Note:</p>
<p>A naive algorithm of O(n2) is trivial. You MUST do better than that.</p>
<p>Example:</p>
<p>Given nums = [-2, 5, -1], lower = -2, upper = 2,</p>
<p>Return 3.</p>
<p>The three ranges are : [0, 0], [2, 2], [0, 2] and their respective sums are: -2, -1, 2.</p>
<p>解析：</p>
<p>树状数组</p>
<p>需要找满足条件 lower ≤ sum[j] – sum[i – 1] ≤ upper ，也就是lower + sum[i – 1] ≤ sum[j] ≤ upper + sum[i – 1]</p>
<p>我们同样的求出和，然后离散化，接着从右向左扫描，对每个i 查询满足在[ lower + sum[i – 1], upper + sum[i – 1] ]范围内的个数（用线段树或者Fenwick Tree）这样复杂度就是O(n log n)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">LL</span><span class="p">;</span>
<span class="n">class</span> <span class="n">FenwickTree</span> <span class="p">{</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sum_array</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">lowbit</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">FenwickTree</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span><span class="n">n</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">sum_array</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sum_array</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="n">lowbit</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="n">sum_array</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
        <span class="n">x</span> <span class="o">-=</span> <span class="n">lowbit</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>

<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">countRangeSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lower</span><span class="p">,</span> <span class="kt">int</span> <span class="n">upper</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">LL</span><span class="o">&gt;</span> <span class="n">sum_array</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">LL</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">sum_array</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
        <span class="n">sum_array</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">lower</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">sum_array</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">upper</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">sum_array</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">upper</span><span class="p">);</span>
    <span class="n">sum_array</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">lower</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">LL</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">index</span><span class="p">;</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">sum_array</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">sum_array</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">sum_array</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">sum_array</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">sum_array</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">index</span><span class="p">[</span><span class="o">*</span><span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">FenwickTree</span> <span class="n">tree</span><span class="p">(</span><span class="n">index</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tree</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="n">sum</span><span class="p">],</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">sum</span> <span class="o">-=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">ans</span> <span class="o">+=</span> <span class="n">tree</span><span class="p">.</span><span class="n">sum</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="n">upper</span> <span class="o">+</span> <span class="n">sum</span><span class="p">])</span> <span class="o">-</span> <span class="n">tree</span><span class="p">.</span><span class="n">sum</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="n">lower</span> <span class="o">+</span> <span class="n">sum</span> <span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
<span class="err">补充：</span><span class="n">STL方法</span>

<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">countRangeSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lower</span><span class="p">,</span> <span class="kt">int</span> <span class="n">upper</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">ret</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">multiset</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span> <span class="n">accum</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">x</span><span class="p">:</span><span class="n">nums</span><span class="p">){</span>
        <span class="n">sum</span><span class="o">+=</span><span class="n">x</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">start</span><span class="o">=</span><span class="n">accum</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">sum</span><span class="o">-</span><span class="n">upper</span><span class="p">),</span><span class="n">end</span><span class="o">=</span><span class="n">accum</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">sum</span><span class="o">-</span><span class="n">lower</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="n">start</span><span class="o">!=</span><span class="n">end</span><span class="p">)</span> <span class="n">ret</span><span class="o">++</span><span class="p">,</span><span class="n">start</span><span class="o">++</span><span class="p">;</span>
        <span class="n">accum</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>补充：</p>
<p>归并方法</p>
<p>将子数组和转换成两个前缀数组和的差，定义数组 sum, sum[i] 表示数组前 i 个元素的和，特殊的,
sum[0]=0，那么元素 i 到元素 j 的和可以表示为 sum[j]-sum[i-1]。我们枚举 0 到nums.length，</p>
<p>比如枚举到了 sum[j]，我们需要求满足条件的 i（i&lt;j)，sum[j]-sum[i] 的值满足大于等于 lower，小于等于 upper。我们需要枚举 sum[0] 到 sum[i]，复杂度还是 O(n^2)，如果 sum[0] 到 sum[i] 有序呢？</p>
<p>用二分维护有序数组（用 splice 插入），同时用二分找到临界的数据，一次迭代需要多次二分。</p>
<p>在合并左右数组的时候对于左边数组中的每一个元素在右边数组找到一个范围, 使得在这个范围中的的元素与左边的元素构成的区间和落在[lower, upper]之间.即在右边数组找到两个边界, 设为m, n, 其中m是在右边数组中第一个使得sum[m] - sum[i] &gt;= lower的位置, n是第一个使得sum[n] - sum[i] &gt; upper的位置,</p>
<p>这样n-m就是与左边元素i所构成的位于[lower, upper]范围的区间个数. 因为左右两边都是已经有序的, 这样可以避免不必要的比较</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>  
<span class="nl">public</span><span class="p">:</span>  
<span class="kt">int</span> <span class="n">mergeSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;&amp;</span> <span class="n">sum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lower</span><span class="p">,</span> <span class="kt">int</span> <span class="n">upper</span><span class="p">,</span> <span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="k">if</span><span class="p">(</span><span class="n">high</span><span class="o">-</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">//递归终止条件
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">low</span><span class="o">+</span><span class="p">(</span><span class="n">high</span><span class="o">-</span><span class="n">low</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">mid</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">mid</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>  
    <span class="n">count</span> <span class="o">=</span> <span class="n">mergeSort</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span><span class="n">lower</span><span class="p">,</span><span class="n">upper</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">mid</span><span class="p">)</span> <span class="o">+</span> <span class="n">mergeSort</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span><span class="n">lower</span><span class="p">,</span><span class="n">upper</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="n">high</span><span class="p">);</span>  

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="n">low</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">mid</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>  
        <span class="k">while</span><span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="n">high</span> <span class="o">&amp;&amp;</span> <span class="n">sum</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lower</span><span class="p">)</span> <span class="n">m</span><span class="o">++</span><span class="p">;</span>  
        <span class="k">while</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">high</span> <span class="o">&amp;&amp;</span> <span class="n">sum</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">upper</span><span class="p">)</span> <span class="n">n</span><span class="o">++</span><span class="p">;</span>  
        <span class="n">count</span> <span class="o">+=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span><span class="p">;</span>  
    <span class="p">}</span>  
   <span class="c1">// sort(sum.begin()+low，sum.begin()+high);
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>  
<span class="p">}</span>  

<span class="kt">int</span> <span class="n">countRangeSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lower</span><span class="p">,</span> <span class="kt">int</span> <span class="n">upper</span><span class="p">)</span> <span class="p">{</span>  
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>  
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>  <span class="c1">//预处理前缀和
</span><span class="c1"></span>    <span class="k">return</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>  
<span class="p">}</span>  
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-493-reverse-pairs">LeetCode 493. Reverse Pairs<a hidden class="anchor" aria-hidden="true" href="#leetcode-493-reverse-pairs">#</a></h1>
<p>Given an array nums, we call (i, j) an important reverse pair if i &lt; j and nums[i] &gt; 2*nums[j].</p>
<p>You need to return the number of important reverse pairs in the given array.</p>
<p>Example1:</p>
<p>Input: [1,3,2,3,1].
Output: 2.
Example2:</p>
<p>Input: [2,4,3,5,1].
Output: 3.
Note:<br>
The length of the given array will not exceed 50,000.<br>
All the numbers in the input array are in the range of 32-bit integer.</p>
<p>解析：树状数组</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">reversePairs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">query</span><span class="p">((</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">add</span><span class="p">((</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private</span><span class="p">:</span>
    <span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">1LL</span> <span class="o">&lt;&lt;</span> <span class="mi">34</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">1LL</span> <span class="o">&lt;&lt;</span> <span class="mi">36</span><span class="p">;</span> <span class="n">x</span> <span class="o">+=</span> <span class="n">lowbit</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">bit</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">query</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">1LL</span> <span class="o">&lt;&lt;</span> <span class="mi">34</span><span class="p">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">-=</span> <span class="n">lowbit</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bit</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="n">cnt</span> <span class="o">+=</span> <span class="n">bit</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">long</span> <span class="kt">long</span> <span class="n">lowbit</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">private</span><span class="p">:</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">bit</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>补充：归并</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">private</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
        <span class="n">mergeSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span><span class="n">start</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
        <span class="n">mergeSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">end</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">start</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">mid</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">){</span>
            <span class="k">if</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">nums</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="p">]){</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="p">(</span><span class="n">mid</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
                <span class="n">r</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                <span class="n">l</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">start</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span><span class="c1">//便于比较
</span><span class="c1"></span>        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">reversePairs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">mergeSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/binary-indexed-tree/">Binary Indexed Tree</a></li>
      <li><a href="/tags/dp/">DP</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
