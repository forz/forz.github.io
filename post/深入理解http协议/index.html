<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>深入理解HTTP协议 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="介绍 HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。今天普遍使用的一个版本——HTTP 1.1。 HTTP协议（HyperTe" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.88.1 with theme even" />


<link rel="canonical" href="/post/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3http%E5%8D%8F%E8%AE%AE/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="深入理解HTTP协议" />
<meta property="og:description" content="介绍 HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。今天普遍使用的一个版本——HTTP 1.1。 HTTP协议（HyperTe" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3http%E5%8D%8F%E8%AE%AE/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-25T20:08:31+00:00" />
<meta property="article:modified_time" content="2017-06-25T20:08:31+00:00" />

<meta itemprop="name" content="深入理解HTTP协议">
<meta itemprop="description" content="介绍 HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。今天普遍使用的一个版本——HTTP 1.1。 HTTP协议（HyperTe"><meta itemprop="datePublished" content="2017-06-25T20:08:31+00:00" />
<meta itemprop="dateModified" content="2017-06-25T20:08:31+00:00" />
<meta itemprop="wordCount" content="15197">
<meta itemprop="keywords" content="TTP," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="深入理解HTTP协议"/>
<meta name="twitter:description" content="介绍 HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。今天普遍使用的一个版本——HTTP 1.1。 HTTP协议（HyperTe"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/%20/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">深入理解HTTP协议</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-06-25 </span>
        <div class="post-category">
            <a href="/categories/%E7%BD%91%E7%BB%9C/"> 网络 </a>
            </div>
          <span class="more-meta"> 约 15197 字 </span>
          <span class="more-meta"> 预计阅读 31 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#host头域">host头域</a></li>
    <li><a href="#referer头域">Referer头域</a></li>
    <li><a href="#user-agent头域">User-Agent头域</a></li>
    <li><a href="#cache-control头域">Cache-Control头域</a></li>
    <li><a href="#date头域">Date头域</a></li>
  </ul>

  <ul>
    <li><a href="#建立连接方面">建立连接方面</a></li>
    <li><a href="#host域">Host域</a></li>
    <li><a href="#状态响应码">状态响应码</a></li>
  </ul>

  <ul>
    <li><a href="#接收方向">接收方向</a></li>
    <li><a href="#发送方向">发送方向</a></li>
    <li><a href="#请求方式">请求方式</a></li>
    <li><a href="#请求消息">请求消息</a>
      <ul>
        <li><a href="#请求消息格式">请求消息格式</a></li>
      </ul>
    </li>
    <li><a href="#请求方法">请求方法</a>
      <ul>
        <li><a href="#getpostputdelete">GET，POST，PUT，DELETE</a></li>
        <li><a href="#get与post">GET与POST</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#响应消息格式">响应消息格式</a></li>
    <li><a href="#请求头">请求头</a></li>
    <li><a href="#响应头">响应头</a></li>
  </ul>

  <ul>
    <li><a href="#与cookie相关的扩展头">与Cookie相关的扩展头</a></li>
    <li><a href="#与缓存相关的扩展头">与缓存相关的扩展头</a></li>
    <li><a href="#cookie和session">Cookie和Session</a></li>
    <li><a href="#区别">区别</a></li>
  </ul>

  <ul>
    <li><a href="#使用cookie来实现">使用Cookie来实现</a></li>
    <li><a href="#使用url回显来实现">使用URL回显来实现</a></li>
  </ul>

  <ul>
    <li><a href="#什么是web缓存">什么是Web缓存</a></li>
    <li><a href="#缓存的优点">缓存的优点</a></li>
    <li><a href="#缓存机制">缓存机制</a></li>
    <li><a href="#强制缓存">强制缓存</a></li>
    <li><a href="#expires">Expires</a></li>
    <li><a href="#对比缓存">对比缓存</a></li>
    <li><a href="#两次打开网页的工作流程">两次打开网页的工作流程</a>
      <ul>
        <li><a href="#总结">总结</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#断点续传">断点续传</a></li>
    <li><a href="#多线程下载">多线程下载</a></li>
  </ul>

  <ul>
    <li><a href="#什么是https">什么是https</a></li>
    <li><a href="#https的实现原理">https的实现原理</a></li>
    <li><a href="#https通信的优点">https通信的优点</a></li>
  </ul>

  <ul>
    <li><a href="#http代理服务器">http代理服务器</a></li>
    <li><a href="#http代理服务器的主要功能">http代理服务器的主要功能</a></li>
  </ul>

  <ul>
    <li><a href="#什么是虚拟主机">什么是虚拟主机</a></li>
    <li><a href="#虚拟主机的实现原理">虚拟主机的实现原理</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="介绍">介绍</h1>
<p>HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。今天普遍使用的一个版本——HTTP 1.1。</p>
<p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p>
<p>HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。</p>
<p>HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/o_http%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0-11.jpg" alt=""></p>
<p>默认HTTP的端口号为80，HTTPS的端口号为443。</p>
<h1 id="特性">特性</h1>
<p>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<p>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</p>
<p>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<h1 id="请求响应模型">请求响应模型</h1>
<p>HTTP协议永远都是客户端发起请求，服务器回送响应。见下图：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/o_http%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0-12.jpg" alt=""></p>
<p>这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。</p>
<p>HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。</p>
<h1 id="工作流程">工作流程</h1>
<p>一次HTTP操作称为一个事务，其工作过程可分为四步：</p>
<ol>
<li>
<p>首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。</p>
</li>
<li>
<p>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</p>
</li>
<li>
<p>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</p>
</li>
<li>
<p>客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</p>
</li>
</ol>
<p>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</p>
<h1 id="头域">头域</h1>
<p>每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/o_http%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0-%E6%A6%82%E5%BF%B5-4.jpg" alt=""></p>
<h2 id="host头域">host头域</h2>
<p>Host头域指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/o_http%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0-%E6%A6%82%E5%BF%B5-6.jpg" alt=""></p>
<h2 id="referer头域">Referer头域</h2>
<p>Referer头域允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等。他也允许废除的或错误的连接由于维护的目的被追踪。如果请求的uri没有自己的uri地址，Referer不能被发送。如果指定的是部分uri地址，则此地址应该是一个相对地址。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/o_http%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0-%E6%A6%82%E5%BF%B5-7.jpg" alt=""></p>
<h2 id="user-agent头域">User-Agent头域</h2>
<p>User-Agent头域的内容包含发出请求的用户信息。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/o_http%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0-%E6%A6%82%E5%BF%B5-8.jpg" alt=""></p>
<h2 id="cache-control头域">Cache-Control头域</h2>
<p>Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/o_http%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0-%E6%A6%82%E5%BF%B5-9.jpg" alt=""></p>
<h2 id="date头域">Date头域</h2>
<p>Date头域表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/o_http%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0-%E6%A6%82%E5%BF%B5-10.jpg" alt=""></p>
<h1 id="http10和http11的比较">HTTP/1.0和HTTP/1.1的比较</h1>
<h2 id="建立连接方面">建立连接方面</h2>
<p>HTTP/1.0 每次请求都需要建立新的TCP连接，连接不能复用。HTTP/1.1 新的请求可以在上次请求建立的TCP连接之上发送，连接可以复用。优点是减少重复进行TCP三次握手的开销，提高效率。</p>
<p>在http1.1，request和reponse头中都有可能出现一个connection的头，此header的含义是当client和server通信时对于长链接如何进行处理。</p>
<p>在http1.1中，client和server都是默认对方支持长链接的， 如果client使用http1.1协议，但又不希望使用长链接，则需要在header中指明connection的值为close；如果server方也不想支持长链接，则在response中也需要明确说明connection的值为close。不论request还是response的header中包含了值为close的connection，都表明当前正在使用的tcp链接在当天请求处理完毕后会被断掉。以后client再进行新的请求时就必须创建新的tcp链接了。</p>
<h2 id="host域">Host域</h2>
<p>HTTP1.1在Request消息头里头多了一个Host域, HTTP1.0则没有这个域。</p>
<pre><code>Eg：  
    GET /pub/WWW/TheProject.html HTTP/1.1  
    Host: www.w3.org  
</code></pre>
<p>可能HTTP1.0的时候认为，建立TCP连接的时候已经指定了IP地址，这个IP地址上只有一个host。</p>
<h2 id="状态响应码">状态响应码</h2>
<p>状态响应码100 (Continue) 状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。</p>
<p>客户端在Request头部中包含</p>
<pre><code>Expect: 100-continue  
</code></pre>
<p>Server看到之后呢如果回100 (Continue) 这个状态代码，客户端就继续发request body。这个是HTTP1.1才有的。</p>
<p>另外在HTTP/1.1中还增加了101、203、205等等性状态响应码</p>
<h1 id="日期时间戳">日期时间戳</h1>
<h2 id="接收方向">接收方向</h2>
<p>无论是HTTP1.0还是HTTP1.1，都要能解析下面三种date/time stamp：</p>
<pre><code>Sun, 06 Nov 1994 08:49:37 GMT ; RFC 822, updated by RFC 1123
Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036
Sun Nov 6 08:49:37 1994       ; ANSI C's asctime() format
</code></pre>
<h2 id="发送方向">发送方向</h2>
<p>HTTP1.0要求不能生成第三种asctime格式的date/time stamp；</p>
<p>HTTP1.1则要求只生成RFC 1123(第一种)格式的date/time stamp。</p>
<h2 id="请求方式">请求方式</h2>
<p>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>
<h2 id="请求消息">请求消息</h2>
<h3 id="请求消息格式">请求消息格式</h3>
<p>请求消息格式如下所示：</p>
<p>请求行</p>
<p>请求行 = 方法 [空格] 请求URI [空格] 版本号 [回车换行]</p>
<p>请求行实例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">Eg1</span><span class="err">：</span>  
<span class="n">GET</span> <span class="o">/</span><span class="n">index</span><span class="p">.</span><span class="n">html</span> <span class="n">HTTP</span><span class="o">/</span><span class="mf">1.1</span>  
<span class="n">Eg2</span><span class="err">：</span>  
<span class="n">POST</span> <span class="nl">http</span><span class="p">:</span><span class="c1">//192.168.2.217:8080/index.jsp HTTP/1.1 
</span></code></pre></td></tr></table>
</div>
</div><p>HTTP请求消息实例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">GET</span> <span class="o">/</span><span class="n">hello</span><span class="p">.</span><span class="n">htm</span> <span class="n">HTTP</span><span class="o">/</span><span class="mf">1.1</span>
<span class="nl">Accept</span><span class="p">:</span> <span class="err">*/</span><span class="o">*</span> 
<span class="n">Accept</span><span class="o">-</span><span class="nl">Language</span><span class="p">:</span> <span class="n">zh</span><span class="o">-</span><span class="n">cn</span> 
<span class="n">Accept</span><span class="o">-</span><span class="nl">Encoding</span><span class="p">:</span> <span class="n">gzip</span><span class="p">,</span> <span class="n">deflate</span>   
<span class="n">If</span><span class="o">-</span><span class="n">Modified</span><span class="o">-</span><span class="nl">Since</span><span class="p">:</span> <span class="n">Wed</span><span class="p">,</span> <span class="mi">17</span> <span class="n">Oct</span> <span class="mi">2007</span> <span class="mo">02</span><span class="o">:</span><span class="mi">15</span><span class="o">:</span><span class="mi">55</span> <span class="n">GMT</span>   
<span class="n">If</span><span class="o">-</span><span class="n">None</span><span class="o">-</span><span class="nl">Match</span><span class="p">:</span> <span class="n">W</span><span class="o">/</span><span class="s">&#34;158-1192587355000&#34;</span>   
<span class="n">User</span><span class="o">-</span><span class="nl">Agent</span><span class="p">:</span> <span class="n">Mozilla</span><span class="o">/</span><span class="mf">4.0</span> <span class="p">(</span><span class="n">compatible</span><span class="p">;</span> <span class="n">MSIE</span> <span class="mf">6.0</span><span class="p">;</span> <span class="n">Windows</span> <span class="n">NT</span> <span class="mf">5.1</span><span class="p">;</span> <span class="n">SV1</span><span class="p">)</span>  
<span class="nl">Host</span><span class="p">:</span> <span class="mf">192.168.2.162</span><span class="o">:</span><span class="mi">8080</span>  
<span class="nl">Connection</span><span class="p">:</span> <span class="n">Keep</span><span class="o">-</span><span class="n">Alive</span>  
</code></pre></td></tr></table>
</div>
</div><h2 id="请求方法">请求方法</h2>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/VQXOBF11C513Y58%5B%60%7DN6LE0.png" alt=""></p>
<h3 id="getpostputdelete">GET，POST，PUT，DELETE</h3>
<p>一般我们在浏览器输入一个网址访问网站都是GET请求;再FORM表单中，可以通过设置Method指定提交方式为GET或者POST提交方式，默认为GET提交方式。</p>
<p>HTTP定义了与服务器交互的不同方法，其中最基本的四种：GET，POST，PUT，DELETE，（HEAD），其中GET和HEAD被称为安全方法，因为使用GET和HEAD的HTTP请求不会产生什么动作。不会产生动作意味着GET和HEAD的HTTP请求不会在服务器上产生任何结果。但是安全方法并不是什么动作都不产生，这里的安全方法仅仅指不会修改信息。</p>
<ol>
<li>
<p>GET请求会向数据库发索取数据的请求，从而来获取信息，该请求就像数据库的select操作一样，只是用来查询一下数据，不会修改、增加数据，不会影响资源的内容，即该请求不会产生副作用。无论进行多少次操作，结果都是一样的。</p>
</li>
<li>
<p>与GET不同的是，PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样，用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。</p>
</li>
<li>
<p>POST请求同PUT请求类似，都是向服务器端发送数据的，但是该请求会改变数据的种类等资源，就像数据库的insert操作一样，会创建新的内容。几乎目前所有的提交操作都是用POST请求的。</p>
</li>
<li>
<p>DELETE请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的delete操作。</p>
</li>
</ol>
<p>注意:对资源的增，删，改，查操作，其实都可以通过GET/POST完成，不需要用到PUT和DELETE。</p>
<h3 id="get与post">GET与POST</h3>
<p>首先，我们先看一下HTTP请求的格式：</p>
<pre><code>&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;  
&lt;headers&gt;  

&lt;entity-body&gt;  
</code></pre>
<p>在HTTP请求中，奇异行必须是一个请求行，包括请求方法，请求URL，报文所用HTTP版本信息。紧接着是一个herders小节，可以有零个或一个首部，用来说明服务器要使用的附加信息。在首部之后就是一个空行，最后就是报文实体的主体部分，包含一个由任意数据组成的数据块。但是并不是所有的报文都包含实体的主体部分。</p>
<p>GET请求实例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">GET</span> <span class="nl">http</span><span class="p">:</span><span class="c1">//weibo.com/signup/signup.php?inviteCode=2388493434  
</span><span class="c1"></span><span class="nl">Host</span><span class="p">:</span> <span class="n">weibo</span><span class="p">.</span><span class="n">com</span>  
<span class="nl">Accept</span><span class="p">:</span> <span class="n">text</span><span class="o">/</span><span class="n">html</span><span class="p">,</span><span class="n">application</span><span class="o">/</span><span class="n">xhtml</span><span class="o">+</span><span class="n">xml</span><span class="p">,</span><span class="n">application</span><span class="o">/</span><span class="n">xml</span><span class="p">;</span><span class="n">q</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span><span class="n">image</span><span class="o">/</span><span class="n">webp</span><span class="p">,</span><span class="err">*/</span><span class="o">*</span><span class="p">;</span><span class="n">q</span><span class="o">=</span><span class="mf">0.8</span>  
</code></pre></td></tr></table>
</div>
</div><p>POST请求实例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">POST</span> <span class="o">/</span><span class="n">inventory</span><span class="o">-</span><span class="n">check</span><span class="p">.</span><span class="n">cgi</span> <span class="n">HTTP</span><span class="o">/</span><span class="mf">1.1</span>  
<span class="nl">Host</span><span class="p">:</span> <span class="n">www</span><span class="p">.</span><span class="n">joes</span><span class="o">-</span><span class="n">hardware</span><span class="p">.</span><span class="n">com</span>  
<span class="n">Content</span><span class="o">-</span><span class="nl">Type</span><span class="p">:</span> <span class="n">text</span><span class="o">/</span><span class="n">plain</span>  
<span class="n">Content</span><span class="o">-</span><span class="nl">length</span><span class="p">:</span> <span class="mi">18</span>  

<span class="n">item</span><span class="o">=</span><span class="n">bandsaw</span> <span class="mi">2647</span>  
</code></pre></td></tr></table>
</div>
</div><h4 id="请求方式-1">请求方式：</h4>
<p>GET请求，请求的数据会附加在URL之后，以?分割URL和传输数据，多个参数用&amp;连接。URL的编码格式采用的是ASCII编码，而不是uniclde，即是说所有的非ASCII字符都要编码之后再传输。</p>
<p>POST请求：POST请求会把请求的数据放置在HTTP请求包的包体中。上面的item=bandsaw就是实际的传输数据。</p>
<p>因此，GET请求的数据会暴露在地址栏中，而POST请求则不会。</p>
<h4 id="传输数据的大小">传输数据的大小</h4>
<p>在HTTP规范中，没有对URL的长度和传输的数据大小进行限制。但是在实际开发过程中，对于GET，特定的浏览器和服务器对URL的长度有限制。因此，在使用GET请求时，传输数据会受到URL长度的限制。</p>
<p>对于POST，由于不是URL传值，理论上是不会受限制的，但是实际上各个服务器会规定对POST提交数据大小进行限制，Apache、IIS都有各自的配置。</p>
<h4 id="安全性">安全性</h4>
<p>POST的安全性比GET的高。这里的安全是指真正的安全，而不同于上面GET提到的安全方法中的安全，上面提到的安全仅仅是不修改服务器的数据。比如，在进行登录操作，通过GET请求，用户名和密码都会暴露再URL上，因为登录页面有可能被浏览器缓存以及其他人查看浏览器的历史记录的原因，此时的用户名和密码就很容易被他人拿到了。除此之外，GET请求提交的数据还可能会造成Cross-site request frogery攻击</p>
<h1 id="响应消息">响应消息</h1>
<h2 id="响应消息格式">响应消息格式</h2>
<p>HTTP响应消息的格式如下所示： <br>
状态行.<br>
状态行 = 版本号 [空格] 状态码 [空格] 原因 [回车换行].<br>
状态行举例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">Eg1</span><span class="err">：</span>
<span class="n">HTTP</span><span class="o">/</span><span class="mf">1.0</span> <span class="mi">200</span> <span class="n">OK</span>   

<span class="n">Eg2</span><span class="err">：</span>  
<span class="n">HTTP</span><span class="o">/</span><span class="mf">1.1</span> <span class="mi">400</span> <span class="n">Bad</span> <span class="n">Request</span>  
<span class="n">HTTP响应消息实例如下所示</span><span class="err">：</span>  
<span class="n">HTTP</span><span class="o">/</span><span class="mf">1.1</span> <span class="mi">200</span> <span class="n">OK</span>  
<span class="nl">ETag</span><span class="p">:</span> <span class="n">W</span><span class="o">/</span><span class="s">&#34;158-1192590101000&#34;</span>  
<span class="n">Last</span><span class="o">-</span><span class="nl">Modified</span><span class="p">:</span> <span class="n">Wed</span><span class="p">,</span> <span class="mi">17</span> <span class="n">Oct</span> <span class="mi">2007</span> <span class="mo">03</span><span class="o">:</span><span class="mo">01</span><span class="o">:</span><span class="mi">41</span> <span class="n">GMT</span>  
<span class="n">Content</span><span class="o">-</span><span class="nl">Type</span><span class="p">:</span> <span class="n">text</span><span class="o">/</span><span class="n">html</span>  
<span class="n">Content</span><span class="o">-</span><span class="nl">Length</span><span class="p">:</span> <span class="mi">158</span>  
<span class="nl">Date</span><span class="p">:</span> <span class="n">Wed</span><span class="p">,</span> <span class="mi">17</span> <span class="n">Oct</span> <span class="mi">2007</span> <span class="mo">03</span><span class="o">:</span><span class="mo">01</span><span class="o">:</span><span class="mi">59</span> <span class="n">GMT</span>  
<span class="nl">Server</span><span class="p">:</span> <span class="n">Apache</span><span class="o">-</span><span class="n">Coyote</span><span class="o">/</span><span class="mf">1.1</span>  
</code></pre></td></tr></table>
</div>
</div><p>http的状态响应码</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/1.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/2.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/3.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/4.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/NOMAEA%28%5D%60CKDAN4F~R@WY~S.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/1L3~OPG0RWH9_%60A%7DA$%28IK%250.png" alt=""></p>
<h2 id="请求头">请求头</h2>
<p>HTTP最常见的请求头如下：</p>
<p>Accept：浏览器可接受的MIME类型；</p>
<p>Accept-Charset：浏览器可接受的字符集；</p>
<p>Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间；</p>
<p>Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到；</p>
<p>Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中；</p>
<p>Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小；</p>
<p>Content-Length：表示请求消息正文的长度；</p>
<p>Cookie：这是最重要的请求头信息之一；</p>
<p>From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它；</p>
<p>Host：初始URL中的主机和端口；</p>
<p>If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答；</p>
<p>Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝；</p>
<p>Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。</p>
<p>User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用；</p>
<p>UA-Pixels，UA-Color，UA-OS，UA-CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。</p>
<h2 id="响应头">响应头</h2>
<p>HTTP最常见的响应头如下所示：</p>
<p>Allow：服务器支持哪些请求方法（如GET、POST等）；</p>
<p>Content-Encoding：文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面；</p>
<p>Content-Length：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容；</p>
<p>Content-Type： 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentTyep。 可在web.xml文件中配置扩展名和MIME类型的对应关系；</p>
<p>Date：当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦；</p>
<p>Expires：指明应该在什么时候认为文档已经过期，从而不再缓存它。</p>
<p>Last-Modified：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置；</p>
<p>Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302；</p>
<p>Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</p>
<h1 id="实体头">实体头</h1>
<p>实体头用作实体内容的元信息，描述了实体内容的属性，包括实体信息类型，长度，压缩方法，最后一次修改时间，数据有效性等。</p>
<p>Allow：GET,POST</p>
<p>Content-Encoding：文档的编码（Encode）方法，例如：gzip，见“响应头”；</p>
<p>Content-Language：内容的语言类型，例如：zh-cn；</p>
<p>Content-Length：表示内容长度，eg：80，可参考“响应头”；</p>
<p>Content-Location：表示客户应当到哪里去提取文档，例如：http://www.dfdf.org/ dfdf.html，可参考“2.5响应头”；</p>
<p>Content-MD5：MD5 实体的一种MD5摘要，用作校验和。发送方和接受方都计算MD5摘要，接受方将其计算的值与此头标中传递的值进行比较。Eg1：Content-MD5: 。Eg2：dfdfdfdfdfdfdff==；</p>
<p>Content-Range：随部分实体一同发送；标明被插入字节的低位与高位字节偏移，也标明此实体的总长度。Eg1：Content-Range: 1001-2000/5000，eg2：bytes 2543-4532/7898
Content-Type：标明发送或者接收的实体的MIME类型。Eg：text/html; charset=GB2312 主类型/子类型；</p>
<p>Expires：为0证明不缓存；</p>
<p>Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT.</p>
<h1 id="扩展头">扩展头</h1>
<p>在HTTP消息中，也可以使用一些再HTTP1.1正式规范里没有定义的头字段，这些头字段统称为自定义的HTTP头或者扩展头，他们通常被当作是一种实体头处理。</p>
<p>现在流行的浏览器实际上都支持Cookie,Set-Cookie,Refresh和Content-Disposition等几个常用的扩展头字段。</p>
<p>Refresh：1;url=http://www.dfdf.org //过1秒跳转到指定位置；</p>
<p>Content-Disposition：头字段,可参考“2.5响应头”；</p>
<p>Content-Type：WEB 服务器告诉浏览器自己响应的对象的类型。</p>
<h2 id="与cookie相关的扩展头">与Cookie相关的扩展头</h2>
<p>Cookie：客户端将服务器设置的Cookie返回到服务器；</p>
<p>Set-Cookie：服务器向客户端设置Cookie；</p>
<p>Cookie2 (RFC2965)）：客户端指示服务器支持Cookie的版本；</p>
<p>Set-Cookie2 (RFC2965)：服务器向客户端设置Cookie。</p>
<h2 id="与缓存相关的扩展头">与缓存相关的扩展头</h2>
<p>Expires：指示响应内容过期的时间，格林威治时间GMT</p>
<p>Cache-Control：更细致的控制缓存的内容</p>
<p>Last-Modified：响应中资源最后一次修改的时间</p>
<p>ETag：响应中资源的校验值，在服务器上某个时段是唯一标识的。</p>
<p>Date：服务器的时间</p>
<p>If-Modified-Since：客户端存取的该资源最后一次修改的时间，同Last-Modified。</p>
<p>If-None-Match：客户端存取的该资源的检验值，同ETag。</p>
<h2 id="cookie和session">Cookie和Session</h2>
<p>Cookie和Session都为了用来保存状态信息，都是保存客户端状态的机制，它们都是为了解决HTTP无状态的问题而所做的努力。</p>
<p>当你在浏览网站的时候，WEB 服务器会先送一小小资料放在你的计算机上，Cookie 会帮你在网站上所打的文字或是一些选择，都记录下来。当下次你再光临同一个网站，WEB 服务器会先看看有没有它上次留下的 Cookie 资料，有的话，就会依据 Cookie里的内容来判断使用者，送出特定的网页内容给你。</p>
<p>Cookie 的使用很普遍，许多有提供个人化服务的网站，都是利用 Cookie来辨认使用者，以方便送出使用者量身定做的内容，像是 Web 接口的免费 email 网站，都要用到 Cookie。</p>
<p>具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。</p>
<p>Session可以用Cookie来实现，也可以用URL回写的机制来实现。用Cookie来实现的Session可以认为是对Cookie更高级的应用。</p>
<h2 id="区别">区别</h2>
<p>Cookie和Session有以下明显的不同点：</p>
<ol>
<li>
<p>Cookie将状态保存在客户端，Session将状态保存在服务器端；</p>
</li>
<li>
<p>Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies。Session并没有在HTTP的协议中定义；</p>
</li>
<li>
<p>Session是针对每一个用户的，变量的值保存在服务器上，用一个sessionID来区分是哪个用户session变量,这个值是通过用户的浏览器在访问的时候返回给服务器，当客户禁用cookie时，这个值也可能设置为由get来返回给服务器；</p>
</li>
<li>
<p>就安全性来说：当你访问一个使用session 的站点，同时在自己机子上建立一个cookie，建议在服务器端的SESSION机制更安全些.因为它不会任意读取客户存储的信息。</p>
</li>
</ol>
<h1 id="cookie机制">cookie机制</h1>
<p>正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。</p>
<p>cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。</p>
<p>会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie</p>
<p>保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏</p>
<p>览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式</p>
<h1 id="session机制">Session机制</h1>
<p>Session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。</p>
<p>当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为 session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个 session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个 session id将被在本次响应中返回给客户端保存。</p>
<h1 id="session的实现方式">Session的实现方式</h1>
<h2 id="使用cookie来实现">使用Cookie来实现</h2>
<p>服务器给每个Session分配一个唯一的JSESSIONID，并通过Cookie发送给客户端。
当客户端发起新的请求的时候，将在Cookie头中携带这个JSESSIONID。这样服务器能够找到这个客户端对应的Session。</p>
<h2 id="使用url回显来实现">使用URL回显来实现</h2>
<p>URL回写是指服务器在发送给浏览器页面的所有链接中都携带JSESSIONID的参数，这样客户端点击任何一个链接都会把JSESSIONID带会服务器。</p>
<h1 id="缓存机制及原理">缓存机制及原理</h1>
<h2 id="什么是web缓存">什么是Web缓存</h2>
<p>WEB缓存(cache)位于Web服务器和客户端之间。</p>
<p>缓存会根据请求保存输出内容的副本，例如html页面，图片，文件，当下一个请求来到的时候：如果是相同的URL，缓存直接使用副本响应访问请求，而不是向源服务器再次发送请求。</p>
<p>HTTP协议定义了相关的消息头来使WEB缓存尽可能好的工作。</p>
<h2 id="缓存的优点">缓存的优点</h2>
<ol>
<li>
<p>减少相应延迟：因为请求从缓存服务器（离客户端更近）而不是源服务器被相应，这个过程耗时更少，让web服务器看上去相应更快。</p>
</li>
<li>
<p>减少网络带宽消耗：当副本被重用时会减低客户端的带宽消耗；客户可以节省带宽费用，控制带宽的需求的增长并更易于管理。</p>
</li>
</ol>
<h2 id="缓存机制">缓存机制</h2>
<p>HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，对比缓存)</p>
<p>在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解。</p>
<p>已存在缓存数据时，仅基于强制缓存，请求数据的流程如下</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/632130-20170210135521072-1812985836.png" alt=""></p>
<p>已存在缓存数据时，仅基于对比缓存，请求数据的流程如下</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/632130-20170210141716838-764535017.png" alt=""></p>
<p>我们可以看到两类缓存规则的不同，强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。</p>
<p>两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。</p>
<h2 id="强制缓存">强制缓存</h2>
<p>从上文我们得知，强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是如何判断缓存数据是否失效呢？</p>
<p>我们知道，在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应header中。</p>
<p>对于强制缓存来说，响应header中会有两个字段来标明失效规则（Expires/Cache-Control）
使用chrome的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/632130-20170210141755072-1978466289.png" alt=""></p>
<h2 id="expires">Expires</h2>
<p>Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。</p>
<p>不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。
另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。</p>
<p>所以HTTP 1.1 的版本，使用Cache-Control替代。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">Cache</span><span class="o">-</span><span class="n">Control</span>
<span class="n">Cache</span><span class="o">-</span><span class="n">Control</span> <span class="err">是最重要的规则。常见的取值有</span><span class="n">private</span><span class="err">、</span><span class="n">public</span><span class="err">、</span><span class="n">no</span><span class="o">-</span><span class="n">cache</span><span class="err">、</span><span class="n">max</span><span class="o">-</span><span class="n">age</span><span class="err">，</span><span class="n">no</span><span class="o">-</span><span class="n">store</span><span class="err">，默认为</span><span class="n">private</span><span class="err">。</span>
<span class="nl">private</span><span class="p">:</span>             <span class="err">客户端可以缓存</span>
<span class="nl">public</span><span class="p">:</span>              <span class="err">客户端和代理服务器都可缓存（前端的同学，可以认为</span><span class="n">public和private是一样的</span><span class="err">）</span>
<span class="n">max</span><span class="o">-</span><span class="n">age</span><span class="o">=</span><span class="nl">xxx</span><span class="p">:</span>   <span class="err">缓存的内容将在</span> <span class="n">xxx</span> <span class="err">秒后失效</span>
<span class="n">no</span><span class="o">-</span><span class="nl">cache</span><span class="p">:</span>          <span class="err">需要使用对比缓存来验证缓存数据（后面介绍）</span>
<span class="n">no</span><span class="o">-</span><span class="nl">store</span><span class="p">:</span>           <span class="err">所有内容都不会缓存，强制缓存，对比缓存都不会触发</span>
</code></pre></td></tr></table>
</div>
</div><p>举例</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/632130-20170210141836104-1513192908.png" alt=""></p>
<p>图中Cache-Control仅指定了max-age，所以默认为private，缓存时间为31536000秒（365天）.<br>
也就是说，在365天内再次请求这条数据，都会直接获取缓存数据库中的数据，直接使用。</p>
<h2 id="对比缓存">对比缓存</h2>
<p>对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。</p>
<p>浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。</p>
<p>再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。</p>
<p>第一次访问：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/632130-20170210141911682-1756976419.png" alt=""></p>
<p>再次访问：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/632130-20170210141921697-379821074.png" alt=""></p>
<p>通过两图的对比，我们可以很清楚的发现，在对比缓存生效时，状态码为304，并且报文大小和请求时间大大减少。</p>
<p>原因是，服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。</p>
<p>对于对比缓存来说，缓存标识的传递是我们着重需要理解的，它在请求header和响应header间进行传递，
一共分为两种标识传递，接下来，我们分开介绍。</p>
<ol>
<li>
<p>Etag / If-None-Match（优先级高于Last-Modified / If-Modified-Since）</p>
<p>服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/632130-20170210142054182-1766818273.png" alt=""></p>
<p>再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。</p>
<p>服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/632130-20170210142115479-1921175758.png" alt=""></p>
</li>
<li>
<p>Last-Modified / If-Modified-Since</p>
<p>服务器在响应请求时，告诉浏览器资源的最后修改时间。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/632130-20170210142249541-789089587.png" alt=""></p>
<p>再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。</p>
<p>服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。</p>
<p>若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/632130-20170210142307166-135607673.png" alt=""></p>
</li>
</ol>
<h2 id="两次打开网页的工作流程">两次打开网页的工作流程</h2>
<p>浏览器第一次请求：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/632130-20170210142134291-1976923079.png" alt=""></p>
<p>浏览器再次请求时：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/632130-20170210141453338-1263276228.png" alt=""></p>
<h3 id="总结">总结</h3>
<p>对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。</p>
<p>对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</p>
<h1 id="断点续传和多线程下载">断点续传和多线程下载</h1>
<h2 id="断点续传">断点续传</h2>
<p>对于HTTP协议，向服务器请求某个文件时，只要发送类似如下的请求即可：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">GET</span> <span class="o">/</span><span class="n">Path</span><span class="o">/</span><span class="n">FileName</span> <span class="n">HTTP</span><span class="o">/</span><span class="mf">1.0</span> 
<span class="nl">Host</span><span class="p">:</span> <span class="n">www</span><span class="p">.</span><span class="n">server</span><span class="p">.</span><span class="nl">com</span><span class="p">:</span><span class="mi">80</span> 
<span class="nl">Accept</span><span class="p">:</span> <span class="err">*/</span><span class="o">*</span> 
<span class="n">User</span><span class="o">-</span><span class="nl">Agent</span><span class="p">:</span> <span class="n">GeneralDownloadApplication</span> 
<span class="nl">Connection</span><span class="p">:</span> <span class="n">close</span> 
</code></pre></td></tr></table>
</div>
</div><p>如果服务器成功收到该请求，并且没有出现任何错误，则会返回类似下面的数据：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">HTTP</span><span class="o">/</span><span class="mf">1.0</span> <span class="mi">200</span> <span class="n">OK</span> 
<span class="n">Content</span><span class="o">-</span><span class="nl">Length</span><span class="p">:</span> <span class="mi">13057672</span> 
<span class="n">Content</span><span class="o">-</span><span class="nl">Type</span><span class="p">:</span> <span class="n">application</span><span class="o">/</span><span class="n">octet</span><span class="o">-</span><span class="n">stream</span> 
<span class="n">Last</span><span class="o">-</span><span class="nl">Modified</span><span class="p">:</span> <span class="n">Wed</span><span class="p">,</span> <span class="mi">10</span> <span class="n">Oct</span> <span class="mi">2005</span> <span class="mo">00</span><span class="o">:</span><span class="mi">56</span><span class="o">:</span><span class="mi">34</span> <span class="n">GMT</span> 
<span class="n">Accept</span><span class="o">-</span><span class="nl">Ranges</span><span class="p">:</span> <span class="n">bytes</span> 
<span class="nl">ETag</span><span class="p">:</span> <span class="s">&#34;2f38a6cac7cec51:160c&#34;</span> 
<span class="nl">Server</span><span class="p">:</span> <span class="n">Microsoft</span><span class="o">-</span><span class="n">IIS</span><span class="o">/</span><span class="mf">6.0</span> 
<span class="n">X</span><span class="o">-</span><span class="n">Powered</span><span class="o">-</span><span class="nl">By</span><span class="p">:</span> <span class="n">ASP</span><span class="p">.</span><span class="n">NET</span> 
<span class="nl">Date</span><span class="p">:</span> <span class="n">Wed</span><span class="p">,</span> <span class="mi">16</span> <span class="n">Nov</span> <span class="mi">2005</span> <span class="mo">01</span><span class="o">:</span><span class="mi">57</span><span class="o">:</span><span class="mi">54</span> <span class="n">GMT</span> 
<span class="nl">Connection</span><span class="p">:</span> <span class="n">close</span> 
</code></pre></td></tr></table>
</div>
</div><p>以上就是通过HTTP协议实现文件下载的全过程。但还不能实现断点续传，而实际上断点续传的实现非常简单，只要在请求中加一个Range字段就可以了。</p>
<p>假如一个文件有1000个字节，那么其范围就是0-999，则：</p>
<pre><code>Range: bytes=500-      表示读取该文件的500-999字节，共500字节。 
Range: bytes=500-599   表示读取该文件的500-599字节，共100字节。 
</code></pre>
<p>Range还有其它几种写法，但上面这两种是最常用的，对于断点续传也足矣了。如果HTTP请求中包含Range字段，那么服务器会返回206（Partial Content），同时HTTP头中也会有一个相应的Content-Range字段，类似下面的格式：</p>
<pre><code>Content-Range: bytes 500-999/1000 
</code></pre>
<p>Content-Range字段说明服务器返回了文件的某个范围及文件的总长度。这时Content-Length字段就不是整个文件的大小了，而是对应文件这个范围的字节数，这一点一定要注意。</p>
<p>如果我们请求的文件的URL是类似http://www.server.com/filename.exe这样的文件，则不会有问题。但是很多软件下载网站的文件下载链接都是通过程序重定向的，比如pchome的ACDSee的HTTP下载地址是：</p>
<pre><code>http://download.pchome.Net/PHP/tdownload2.php?sid=5547&amp;url=/multimedia/viewer/acdc31sr1b051007.exe&amp;svr=1&amp;typ=0
</code></pre>
<p>这种地址并没有直接标识文件的位置，而是通过程序进行了重定向。如果向服务器请求这样的URL，服务器就会返回302（Moved Temporarily），意思就是需要重定向，同时在HTTP头中会包含一个Location字段，Location字段的值就是重定向后的目的URL。这时就需要断开当前的连接，而向这个重定向后的服务器发请求。</p>
<p>HTTP协议的GET方法，支持只请求某个资源的某一部分；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="mi">206</span> <span class="n">Partial</span> <span class="n">Content</span> <span class="err">部分内容响应；</span>  
<span class="n">Range</span> <span class="err">请求的资源范围；</span>  
<span class="n">Content</span><span class="o">-</span><span class="n">Range</span> <span class="err">响应的资源范围；</span>  
</code></pre></td></tr></table>
</div>
</div><p>连接断开重连时，客户端只请求该资源未下载的部分，而不是重新请求整个资源，来实现断点续传。</p>
<p>分块请求资源实例：</p>
<pre><code>Eg1：Range: bytes=306302- ：请求这个资源从306302个字节到末尾的部分；  

Eg2：Content-Range: bytes 306302-604047/604048：响应中指示携带的是该资源的第306302-604047的字节，该资源共604048个字节；  
</code></pre>
<p>客户端通过并发的请求相同资源的不同片段，来实现对某个资源的并发分块下载。从而达到快速下载的目的。目前流行的FlashGet和迅雷基本都是这个原理。</p>
<h2 id="多线程下载">多线程下载</h2>
<p>下载工具开启多个发出HTTP请求的线程；</p>
<p>每个http请求只请求资源文件的一部分：Content-Range: bytes 20000-40000/47000；</p>
<p>合并每个线程下载的文件。</p>
<h1 id="https通信过程">https通信过程</h1>
<h2 id="什么是https">什么是https</h2>
<p>HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容请看SSL。</p>
<p>https所用的端口号是443。</p>
<h2 id="https的实现原理">https的实现原理</h2>
<p>有两种基本的加解密算法类型：</p>
<ol>
<li>
<p>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</p>
</li>
<li>
<p>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</p>
</li>
</ol>
<h2 id="https通信的优点">https通信的优点</h2>
<ol>
<li>
<p>客户端产生的密钥只有客户端和服务器端能得到；</p>
</li>
<li>
<p>加密的数据只有客户端和服务器端才能得到明文；</p>
</li>
<li>
<p>客户端到服务端的通信是安全的。</p>
</li>
</ol>
<h1 id="http代理">http代理</h1>
<h2 id="http代理服务器">http代理服务器</h2>
<p>代理服务器英文全称是Proxy Server，其功能就是代理网络用户去取得网络信息。形象的说：它是网络信息的中转站。</p>
<p>代理服务器是介于浏览器和Web服务器之间的一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页而是向代理服务器发出请求，Request信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。</p>
<p>而且，大部分代理服务器都具有缓冲的功能，就好象一个大的Cache，它有很大的存储空间，它不断将新取得数据储存到它本机的存储器上，如果浏览器所请求的数据在它本机的存储器上已经存在而且是最新的，那么它就不重新从Web服务器取数据，而直接将存储器上的数据传送给用户的浏览器，这样就能显著提高浏览速度和效率。</p>
<p>更重要的是：Proxy Server(代理服务器)是Internet链路级网关所提供的一种重要的安全功能，它的工作主要在开放系统互联(OSI)模型的对话层。</p>
<h2 id="http代理服务器的主要功能">http代理服务器的主要功能</h2>
<p>主要功能如下：</p>
<ol>
<li>
<p>突破自身IP访问限制，访问国外站点。如：教育网、169网等网络用户可以通过代理访问国外网站；</p>
</li>
<li>
<p>访问一些单位或团体内部资源，如某大学FTP(前提是该代理地址在该资源的允许访问范围之内)，使用教育网内地址段免费代理服务器，就可以用于对教育 网开放的各类FTP下载上传，以及各类资料查询共享等服务；</p>
</li>
<li>
<p>突破中国电信的IP封锁：中国电信用户有很多网站是被限制访问的，这种限制是人为的，不同Serve对地址的封锁是不同的。所以不能访问时可以换一个国 外的代理服务器试试；</p>
</li>
<li>
<p>提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度；</p>
</li>
<li>
<p>隐藏真实IP：上网者也可以通过这种方法隐藏自己的IP，免受攻击。</p>
</li>
</ol>
<p>对于客户端浏览器而言，http代理服务器相当于服务器。</p>
<p>而对于Web服务器而言，http代理服务器又担当了客户端的角色。</p>
<h1 id="虚拟主机的实现">虚拟主机的实现</h1>
<h2 id="什么是虚拟主机">什么是虚拟主机</h2>
<p>虚拟主机：是在网络服务器上划分出一定的磁盘空间供用户放置站点、应用组件等，提供必要的站点功能与数据存放、传输功能。</p>
<p>所谓虚拟主机，也叫“网站空间”就是把一台运行在互联网上的服务器划分成多个“虚拟”的服务器，每一个虚拟主机都具有独立的域名和完整的Internet服务器（支持WWW、FTP、E-mail等）功能。一台服务器上的不同虚拟主机是各自独立的，并由用户自行管理。但一台服务器主机只能够支持一定数量的虚拟主机，当超过这个数量时，用户将会感到性能急剧下降。</p>
<h2 id="虚拟主机的实现原理">虚拟主机的实现原理</h2>
<p>虚拟主机是用同一个WEB服务器，为不同域名网站提供服务的技术。Apache、Tomcat等均可通过配置实现这个功能。</p>
<p>相关的HTTP消息头：Host。</p>
<p>例如：Host: <a href="http://www.baidu.com">www.baidu.com</a></p>
<p>客户端发送HTTP请求的时候，会携带Host头，Host头记录的是客户端输入的域名。这样服务器可以根据Host头确认客户要访问的是哪一个域名。</p>
<p>转载：<a href="">http://www.cnblogs.com/chenqf/p/6386163.html</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2017-06-25
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/ttp/">TTP</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E8%AE%A4%E8%AF%86%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">认识布隆过滤器</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/tcp%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E6%B5%85%E6%9E%90/">
            <span class="next-text nav-default">TCP连接管理浅析</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
