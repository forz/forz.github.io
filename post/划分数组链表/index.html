<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>划分数组/链表 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="LeetCode 75. Sort Colors Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.89.3 with theme even" />


<link rel="canonical" href="/post/%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="划分数组/链表" />
<meta property="og:description" content="LeetCode 75. Sort Colors Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-24T20:31:14+00:00" />
<meta property="article:modified_time" content="2017-06-24T20:31:14+00:00" />

<meta itemprop="name" content="划分数组/链表">
<meta itemprop="description" content="LeetCode 75. Sort Colors Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library"><meta itemprop="datePublished" content="2017-06-24T20:31:14+00:00" />
<meta itemprop="dateModified" content="2017-06-24T20:31:14+00:00" />
<meta itemprop="wordCount" content="3040">
<meta itemprop="keywords" content="Linked List,Quick Sort,Array,Two Pointers," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="划分数组/链表"/>
<meta name="twitter:description" content="LeetCode 75. Sort Colors Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">划分数组/链表</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-06-24 </span>
        <div class="post-category">
            <a href="/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"> 解题报告 </a>
            </div>
          <span class="more-meta"> 约 3040 字 </span>
          <span class="more-meta"> 预计阅读 7 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="leetcode-75-sort-colors">LeetCode 75. Sort Colors</h1>
<p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>
<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p>Note:<br>
You are not suppose to use the library’s sort function for this problem.</p>
<p>解析：</p>
<p>本题要求在原地操作，并且仅扫描数组一次，而且只有3种元素，可以用三向切分快速排序。对于包含大量重复元素的数组，这个算法将排序时间从线性对数级降到了线性级别</p>
<p>三向切分快速排序添加处理等于划分元素的值的逻辑，将所有等于划分元素的值集中在一起，并且以后不会再对他们进行划分。
三向切分将数组分为个区间（本题val=1）</p>
<p>0~l 小于val.<br>
l+1~k 等于val.<br>
r~n-1 大于val.</p>
<p>用三个指针来切分数组。这和普通的划分数组的不同之处在于数组中部多了一个区间，这个区间保存等于val的值。这就需要我们将常规划分下【val左侧区间】重新划分。因此多加了k指针。</p>
<p>用k指针来扫描数组,只有扫描到小于相等val的元素时k才会前进</p>
<p>该元素小于1，放到第一区间中，l和k指针右移，因为影响了前两个区间的位置。</p>
<p>该元素大于1，放到第三区间中，r指针左移，从r交换的元素需要继续判断。</p>
<p>该元素等于1，放到第二区间中，k指针右移，
（该元素位置固定，即使之后被l指针扫到，也只是重新排到新的k指针的位置上。）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">void</span> <span class="n">sortColors</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
     <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="n">val</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">l</span><span class="o">++</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]);</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="o">--</span><span class="p">]);</span>
        <span class="k">else</span>
            <span class="n">k</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="数组的划分调整">数组的划分调整</h1>
<p>题目:</p>
<p>给定一个有序数组arr,调整arr使得这个数组的左半部分没有重复元素且升序，而不
用保证右部分是否有序。</p>
<p>例如，arr=[1，2,2,2,3,3,4,5,6,6,7,7,8,8,8,9]，调整之后 arr=[1，2,3,4,5,6,7,8,9，&hellip;]。</p>
<p>解析:</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170902-111718@2x.png" alt="">
<img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170902-111822@2x.png" alt=""></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">leftUnique</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">arr</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="n">2</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">return</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
		<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">++]</span> <span class="o">!=</span> <span class="n">arr</span><span class="o">[</span><span class="n">u</span><span class="o">])</span> <span class="o">{</span>
				<span class="n">swap</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="o">++</span><span class="n">u</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-324-wiggle-sort-ii">LeetCode 324. Wiggle Sort II</h1>
<p>Given an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]….</p>
<p>Example: <br>
(1) Given nums = [1, 5, 1, 1, 6, 4], one possible answer is [1, 4, 1, 5, 1, 6]. <br>
(2) Given nums = [1, 3, 2, 2, 3, 1], one possible answer is [2, 3, 1, 3, 1, 2].</p>
<p>Note: <br>
You may assume all input has valid answer.</p>
<p>Follow Up:  <br>
Can you do it in O(n) time and/or in-place with O(1) extra space?</p>
<p>解析：</p>
<pre><code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]....
</code></pre>
<p>分析该排序，可以得出排序只需要满足nums[0] &lt; nums[1] &gt; nums[2] ，而不具有传递性，比如nums[0] &lt; nums[2]。所以可以得出一种排序方法：</p>
<p>将数组分成两部分，前半部分小于后半部分，然后前半部分元素填充到结果数组的偶数位，后半部分元素填充到结果数组的奇数位。</p>
<p>先用STL中nth_element()快速找到中位数。</p>
<p>由于上一步只是找到中值的位置，并且让小于等于中值的数在左侧，大于等于中位数的在右侧，这就有一个问题了，等于中值的可能分布在任意位置，必须把等于中值的放在一堆，才能保证nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]….，否则可能出现相等的情况，因此需要再使用三向切分快速排序将中位数全部聚集在中部。</p>
<p>然后填充结果返回。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="c1">//空间复杂度O(n)
</span><span class="c1"></span><span class="nl">public</span><span class="p">:</span>
<span class="kt">void</span> <span class="n">wiggleSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="c1">//中位数位置
</span><span class="c1"></span>    <span class="n">nth_element</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">mid</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="c1">//求出中位数
</span><span class="c1"></span>    <span class="n">threeWayPartition</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="c1">//存储坐标映射后的数组
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">largeStart</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="c1">//后半段的末尾
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">smallStart</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="nl">mid</span> <span class="p">:</span> <span class="p">(</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="c1">//前半段的末尾
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span><span class="c1">//前半段逆向填充偶数位
</span><span class="c1"></span>        <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">smallStart</span><span class="o">--</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span><span class="c1">//后半段逆向填充奇数位
</span><span class="c1"></span>        <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">largeStart</span><span class="o">--</span><span class="p">];</span>
    <span class="n">nums</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">threeWayPartition</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">)</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]);</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">)</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="o">--</span><span class="p">]);</span>
        <span class="k">else</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>补充：</p>
<p>空间复杂度O(1)的做法</p>
<p>之前我们是独立的插入大于或者小于中位数的数, 现在我们可以同时做, 也就是, 遍历数组的时候如果当前的数大于中位数就将其从左往右放奇数位置, 如果小于中位数就将其从右往左放在偶数位置. 这样还需要解决的一个问题是如何可以互不干扰的放到正确位置. 举个栗子: 1, 1, 2, 2, 2, 3这六个数:</p>
<p>我们可以按照这样一个顺序将数组索引拉开成这样: 1, 3, 5, 0, 2, 4, 也就是我们可以按照这样一个顺序来遍历数组, 同时维护一个低位指针用来代表奇数位置已经放到哪里, 和一个高位指针来表示偶数位置已经放到哪里, 这样在我们遍历数组的每一个元素的时候就可以按照这样的方式将元素分别放高位还是低位. 而要将数组按照这样索引的方式遍历我们只需要一个映射即可, 即(2*i+1)%(len|1).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">void</span> <span class="n">wiggleSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">midptr</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">nth_element</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">midptr</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">*</span><span class="n">midptr</span><span class="p">;</span>
    <span class="cp">#define A(i) nums[(1+2*(i)) % (n|1)]</span><span class="c1">//映射坐标
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="p">)</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="o">++</span><span class="p">),</span> <span class="n">A</span><span class="p">(</span><span class="n">j</span><span class="o">++</span><span class="p">));</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">mid</span><span class="p">)</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">A</span><span class="p">(</span><span class="n">k</span><span class="o">--</span><span class="p">));</span>
        <span class="k">else</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-86-partition-list">LeetCode 86. Partition List</h1>
<p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p>For example,   <br>
Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,  <br>
return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.</p>
<p>解析：此题是链表版的partition，可以利用链表的性质，直接将链表分为2个子链表来实现partition</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for singly-linked list.
</span><span class="cm"> * struct ListNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     ListNode *next;
</span><span class="cm"> *     ListNode(int x) : val(x), next(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">partition</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="n">node1</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">node2</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node1</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2</span><span class="p">;</span><span class="c1">//将链表分为两个子链表
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">p2</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">p1</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node2</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">node1</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="将单向链表按某值划分成左边小中间相等右边大的形式">将单向链表按某值划分成左边小、中间相等、右边大的形式</h1>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170816-222510@2x.png" alt="">
<img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170816-222659@2x.png" alt=""></p>
<p>对每部分都增加了节点顺序要求，同时时间复杂度仍然为O(n),额外空间复杂度为O(1)。既然额外空间复杂度为0(1),说明实现时只能使用有限的几个变量来完成所有的调整。</p>
<p>进阶解法的具体过程如下：</p>
<ol>
<li>
<p>将原链表中的所有节点依次划分进三个链表，三个链表分别为small代表左部分，equal代表中间部分，big代表右部分。</p>
<p>例如，链表 7-&gt;9-&gt;1-&gt;8-&gt;5-&gt;2-&gt;5，pivot=5。在划分之后，small、equal、big 分别为：</p>
<pre><code> small： 1-&gt;2-&gt;null
 equal: 5-&gt;5-&gt;null
 big： 7-&gt;9-&gt;8-&gt;null
</code></pre>
</li>
<li>
<p>将small、equal和big三个链表重新串起来即可。</p>
</li>
<li>
<p>整个过程需要特别注意对null节点的判断和处理。</p>
</li>
</ol>
<p>进阶解法还是主要考查面试者利用有限几个变量调整链表的代码实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">	<span class="kd">public</span> <span class="kd">static</span> <span class="n">Node</span> <span class="nf">listPartition2</span><span class="o">(</span><span class="n">Node</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">pivot</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Node</span> <span class="n">sH</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// small head
</span><span class="c1"></span>		<span class="n">Node</span> <span class="n">sT</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// small tail
</span><span class="c1"></span>		<span class="n">Node</span> <span class="n">eH</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// equal head
</span><span class="c1"></span>		<span class="n">Node</span> <span class="n">eT</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// equal tail
</span><span class="c1"></span>		<span class="n">Node</span> <span class="n">bH</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// big head
</span><span class="c1"></span>		<span class="n">Node</span> <span class="n">bT</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// big tail
</span><span class="c1"></span>		<span class="n">Node</span> <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// save next node
</span><span class="c1"></span>		<span class="c1">// 所有的节点分进三个链表中
</span><span class="c1"></span>		<span class="k">while</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
			<span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">value</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">sH</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">sH</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
					<span class="n">sT</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
				<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
					<span class="n">sT</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
					<span class="n">sT</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
				<span class="o">}</span>
			<span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">value</span> <span class="o">==</span> <span class="n">pivot</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">eH</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">eH</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
					<span class="n">eT</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
				<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
					<span class="n">eT</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
					<span class="n">eT</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
				<span class="o">}</span>
			<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">bH</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">bH</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
					<span class="n">bT</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
				<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
					<span class="n">bT</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
					<span class="n">bT</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
				<span class="o">}</span>
			<span class="o">}</span>
			<span class="n">head</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="c1">//小的和相等的重新连接
</span><span class="c1"></span>		<span class="k">if</span> <span class="o">(</span><span class="n">sT</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">sT</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">eH</span><span class="o">;</span>
			<span class="n">eT</span> <span class="o">=</span> <span class="n">eT</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">sT</span> <span class="o">:</span> <span class="n">eT</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="c1">//所有的重新连接
</span><span class="c1"></span>		<span class="k">if</span> <span class="o">(</span><span class="n">eT</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">eT</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">bH</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">sH</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">sH</span> <span class="o">:</span> <span class="n">eH</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">eH</span> <span class="o">:</span> <span class="n">bH</span><span class="o">;</span>
	<span class="o">}</span>


</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-328-odd-even-linked-list">LeetCode 328. Odd Even Linked List</h1>
<p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>
<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>
<p>Example:</p>
<pre><code>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,       
return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL.   
</code></pre>
<p>Note:</p>
<p>The relative order inside both the even and odd groups should remain as it was in the input.   <br>
The first node is considered odd, the second node even and so on ….</p>
<p>解析：</p>
<p>将一个链表分成两个链表.odd奇数链表的头指针是head，尾指针是odd even偶数链表的头指针是evenhead 尾指针是even</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for singly-linked list.
</span><span class="cm"> * struct ListNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     ListNode *next;
</span><span class="cm"> *     ListNode(int x) : val(x), next(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span><span class="c1">//Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
</span><span class="c1"></span><span class="nl">public</span><span class="p">:</span>
<span class="n">ListNode</span><span class="o">*</span> <span class="n">oddEvenList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">ListNode</span> <span class="o">*</span><span class="n">odd</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">even</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">evenHead</span> <span class="o">=</span> <span class="n">even</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">even</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">even</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">odd</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">even</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//1-3
</span><span class="c1"></span>        <span class="n">odd</span> <span class="o">=</span> <span class="n">odd</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//更新尾节点
</span><span class="c1"></span>        <span class="n">even</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">odd</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//2-4
</span><span class="c1"></span>        <span class="n">even</span> <span class="o">=</span> <span class="n">even</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//更新尾节点
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="n">odd</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">evenHead</span><span class="p">;</span><span class="c1">//偶数链表插在奇数链表后面
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2017-06-24
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/linked-list/">Linked List</a>
          <a href="/tags/quick-sort/">Quick Sort</a>
          <a href="/tags/array/">Array</a>
          <a href="/tags/two-pointers/">Two Pointers</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">单链表排序总结</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E4%B9%B1%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/">
            <span class="next-text nav-default">乱序字符串</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
