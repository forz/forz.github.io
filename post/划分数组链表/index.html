<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>划分数组/链表 | Forz Blog</title>
<meta name="keywords" content="Linked List, Quick Sort, Array, Two Pointers" />
<meta name="description" content="LeetCode 75. Sort Colors Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="划分数组/链表" />
<meta property="og:description" content="LeetCode 75. Sort Colors Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-24T20:31:14&#43;00:00" />
<meta property="article:modified_time" content="2017-06-24T20:31:14&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="划分数组/链表"/>
<meta name="twitter:description" content="LeetCode 75. Sort Colors Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "划分数组/链表",
      "item": "/post/%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "划分数组/链表",
  "name": "划分数组\/链表",
  "description": "LeetCode 75. Sort Colors Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library",
  "keywords": [
    "Linked List", "Quick Sort", "Array", "Two Pointers"
  ],
  "articleBody": "LeetCode 75. Sort Colors Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.\nHere, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\nNote:\nYou are not suppose to use the library’s sort function for this problem.\n解析：\n本题要求在原地操作，并且仅扫描数组一次，而且只有3种元素，可以用三向切分快速排序。对于包含大量重复元素的数组，这个算法将排序时间从线性对数级降到了线性级别\n三向切分快速排序添加处理等于划分元素的值的逻辑，将所有等于划分元素的值集中在一起，并且以后不会再对他们进行划分。 三向切分将数组分为个区间（本题val=1）\n0~l 小于val.\nl+1~k 等于val.\nr~n-1 大于val.\n用三个指针来切分数组。这和普通的划分数组的不同之处在于数组中部多了一个区间，这个区间保存等于val的值。这就需要我们将常规划分下【val左侧区间】重新划分。因此多加了k指针。\n用k指针来扫描数组,只有扫描到小于相等val的元素时k才会前进\n该元素小于1，放到第一区间中，l和k指针右移，因为影响了前两个区间的位置。\n该元素大于1，放到第三区间中，r指针左移，从r交换的元素需要继续判断。\n该元素等于1，放到第二区间中，k指针右移， （该元素位置固定，即使之后被l指针扫到，也只是重新排到新的k指针的位置上。）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution { public: void sortColors(vectorint\u0026 nums) { int l = 0, k = 1,val=1; int r = nums.size()-1; while (k  r){ if (nums[k]  1) swap(nums[l++], nums[k++]); else if (nums[k]  1) swap(nums[k], nums[r--]); else k++; } } };   数组的划分调整 题目:\n给定一个有序数组arr,调整arr使得这个数组的左半部分没有重复元素且升序，而不 用保证右部分是否有序。\n例如，arr=[1，2,2,2,3,3,4,5,6,6,7,7,8,8,8,9]，调整之后 arr=[1，2,3,4,5,6,7,8,9，…]。\n解析:\n1 2 3 4 5 6 7 8 9 10 11 12  public static void leftUnique(int[] arr) { if (arr == null || arr.length  2) { return; } int u = 0; int i = 1; while (i != arr.length) { if (arr[i++] != arr[u]) { swap(arr, ++u, i - 1); } } }   LeetCode 324. Wiggle Sort II Given an unsorted array nums, reorder it such that nums[0] nums[2] Example: (1) Given nums = [1, 5, 1, 1, 6, 4], one possible answer is [1, 4, 1, 5, 1, 6]. (2) Given nums = [1, 3, 2, 2, 3, 1], one possible answer is [2, 3, 1, 3, 1, 2].\nNote: You may assume all input has valid answer.\nFollow Up: Can you do it in O(n) time and/or in-place with O(1) extra space?\n解析：\nnums[0] nums[2]  分析该排序，可以得出排序只需要满足nums[0] nums[2] ，而不具有传递性，比如nums[0] 将数组分成两部分，前半部分小于后半部分，然后前半部分元素填充到结果数组的偶数位，后半部分元素填充到结果数组的奇数位。\n先用STL中nth_element()快速找到中位数。\n由于上一步只是找到中值的位置，并且让小于等于中值的数在左侧，大于等于中位数的在右侧，这就有一个问题了，等于中值的可能分布在任意位置，必须把等于中值的放在一堆，才能保证nums[0] nums[2] 然后填充结果返回。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class Solution { //空间复杂度O(n) public: void wiggleSort(vectorint\u0026 nums) { int n = nums.size(); int mid = n/2;//中位数位置  nth_element(nums.begin(), nums.begin() + mid, nums.end());//求出中位数  threeWayPartition(nums, nums[mid]); vectorint res(n);//存储坐标映射后的数组  int largeStart = n-1;//后半段的末尾  int smallStart = (n%2) ? mid : (mid-1);//前半段的末尾  for (int i = 0; i  n; i+=2)//前半段逆向填充偶数位  res[i] = nums[smallStart--]; for (int i = 1; i  n; i+=2)//后半段逆向填充奇数位  res[i] = nums[largeStart--]; nums = res; } void threeWayPartition(vectorint \u0026nums, int val) { int i = 0, j = 0; int k = nums.size()-1; while (j  k){ if (nums[j]  val) swap(nums[i++], nums[j++]); else if (nums[j]  val) swap(nums[j], nums[k--]); else j++; } } };   补充：\n空间复杂度O(1)的做法\n之前我们是独立的插入大于或者小于中位数的数, 现在我们可以同时做, 也就是, 遍历数组的时候如果当前的数大于中位数就将其从左往右放奇数位置, 如果小于中位数就将其从右往左放在偶数位置. 这样还需要解决的一个问题是如何可以互不干扰的放到正确位置. 举个栗子: 1, 1, 2, 2, 2, 3这六个数:\n我们可以按照这样一个顺序将数组索引拉开成这样: 1, 3, 5, 0, 2, 4, 也就是我们可以按照这样一个顺序来遍历数组, 同时维护一个低位指针用来代表奇数位置已经放到哪里, 和一个高位指针来表示偶数位置已经放到哪里, 这样在我们遍历数组的每一个元素的时候就可以按照这样的方式将元素分别放高位还是低位. 而要将数组按照这样索引的方式遍历我们只需要一个映射即可, 即(2*i+1)%(len|1).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public: void wiggleSort(vectorint\u0026 nums) { int n = nums.size(); auto midptr = nums.begin() + n / 2; nth_element(nums.begin(), midptr, nums.end()); int mid = *midptr; #define A(i) nums[(1+2*(i)) % (n|1)]//映射坐标  int i = 0, j = 0, k = n - 1; while (j  k) { if (A(j)  mid) swap(A(i++), A(j++)); else if (A(j)  mid) swap(A(j), A(k--)); else j++; } } };   LeetCode 86. Partition List Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\nYou should preserve the original relative order of the nodes in each of the two partitions.\nFor example, Given 1-4-3-2-5-2 and x = 3, return 1-2-2-4-3-5.\n解析：此题是链表版的partition，可以利用链表的性质，直接将链表分为2个子链表来实现partition\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *partition(ListNode *head, int x) { ListNode node1(0), node2(0); ListNode *p1 = \u0026node1, *p2 = \u0026node2;//将链表分为两个子链表  while (head) { if (head-val  x) p1 = p1-next = head; else p2 = p2-next = head; head = head-next; } p2-next = NULL; p1-next = node2.next; return node1.next; } };   将单向链表按某值划分成左边小、中间相等、右边大的形式 对每部分都增加了节点顺序要求，同时时间复杂度仍然为O(n),额外空间复杂度为O(1)。既然额外空间复杂度为0(1),说明实现时只能使用有限的几个变量来完成所有的调整。\n进阶解法的具体过程如下：\n  将原链表中的所有节点依次划分进三个链表，三个链表分别为small代表左部分，equal代表中间部分，big代表右部分。\n例如，链表 7-9-1-8-5-2-5，pivot=5。在划分之后，small、equal、big 分别为：\n small： 1-2-null equal: 5-5-null big： 7-9-8-null    将small、equal和big三个链表重新串起来即可。\n  整个过程需要特别注意对null节点的判断和处理。\n  进阶解法还是主要考查面试者利用有限几个变量调整链表的代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  public static Node listPartition2(Node head, int pivot) { Node sH = null; // small head \tNode sT = null; // small tail \tNode eH = null; // equal head \tNode eT = null; // equal tail \tNode bH = null; // big head \tNode bT = null; // big tail \tNode next = null; // save next node \t// 所有的节点分进三个链表中 \twhile (head != null) { next = head.next; head.next = null; if (head.value  pivot) { if (sH == null) { sH = head; sT = head; } else { sT.next = head; sT = head; } } else if (head.value == pivot) { if (eH == null) { eH = head; eT = head; } else { eT.next = head; eT = head; } } else { if (bH == null) { bH = head; bT = head; } else { bT.next = head; bT = head; } } head = next; } //小的和相等的重新连接 \tif (sT != null) { sT.next = eH; eT = eT == null ? sT : eT; } //所有的重新连接 \tif (eT != null) { eT.next = bH; } return sH != null ? sH : eH != null ? eH : bH; }   LeetCode 328. Odd Even Linked List Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.\nYou should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.\nExample:\nGiven 1-2-3-4-5-NULL, return 1-3-5-2-4-NULL.  Note:\nThe relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on ….\n解析：\n将一个链表分成两个链表.odd奇数链表的头指针是head，尾指针是odd even偶数链表的头指针是evenhead 尾指针是even\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution {//Given 1-2-3-4-5-NULL public: ListNode* oddEvenList(ListNode* head) { if (head == NULL) return NULL; ListNode *odd = head, *even = head-next, *evenHead = even; while (even != NULL \u0026\u0026 even-next != NULL) { odd-next = even-next;//1-3  odd = odd-next;//更新尾节点  even-next = odd-next;//2-4  even = even-next;//更新尾节点  } odd-next = evenHead;//偶数链表插在奇数链表后面  return head; } };   ",
  "wordCount" : "3040",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-24T20:31:14Z",
  "dateModified": "2017-06-24T20:31:14Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      划分数组/链表
    </h1>
    <div class="post-meta">June 24, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="leetcode-75-sort-colors">LeetCode 75. Sort Colors<a hidden class="anchor" aria-hidden="true" href="#leetcode-75-sort-colors">#</a></h1>
<p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>
<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p>Note:<br>
You are not suppose to use the library’s sort function for this problem.</p>
<p>解析：</p>
<p>本题要求在原地操作，并且仅扫描数组一次，而且只有3种元素，可以用三向切分快速排序。对于包含大量重复元素的数组，这个算法将排序时间从线性对数级降到了线性级别</p>
<p>三向切分快速排序添加处理等于划分元素的值的逻辑，将所有等于划分元素的值集中在一起，并且以后不会再对他们进行划分。
三向切分将数组分为个区间（本题val=1）</p>
<p>0~l 小于val.<br>
l+1~k 等于val.<br>
r~n-1 大于val.</p>
<p>用三个指针来切分数组。这和普通的划分数组的不同之处在于数组中部多了一个区间，这个区间保存等于val的值。这就需要我们将常规划分下【val左侧区间】重新划分。因此多加了k指针。</p>
<p>用k指针来扫描数组,只有扫描到小于相等val的元素时k才会前进</p>
<p>该元素小于1，放到第一区间中，l和k指针右移，因为影响了前两个区间的位置。</p>
<p>该元素大于1，放到第三区间中，r指针左移，从r交换的元素需要继续判断。</p>
<p>该元素等于1，放到第二区间中，k指针右移，
（该元素位置固定，即使之后被l指针扫到，也只是重新排到新的k指针的位置上。）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">void</span> <span class="n">sortColors</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
     <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="n">val</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">l</span><span class="o">++</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]);</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="o">--</span><span class="p">]);</span>
        <span class="k">else</span>
            <span class="n">k</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="数组的划分调整">数组的划分调整<a hidden class="anchor" aria-hidden="true" href="#数组的划分调整">#</a></h1>
<p>题目:</p>
<p>给定一个有序数组arr,调整arr使得这个数组的左半部分没有重复元素且升序，而不
用保证右部分是否有序。</p>
<p>例如，arr=[1，2,2,2,3,3,4,5,6,6,7,7,8,8,8,9]，调整之后 arr=[1，2,3,4,5,6,7,8,9，&hellip;]。</p>
<p>解析:</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170902-111718@2x.png" alt=""  />

<img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170902-111822@2x.png" alt=""  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">leftUnique</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">arr</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="n">2</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">return</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
		<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">++]</span> <span class="o">!=</span> <span class="n">arr</span><span class="o">[</span><span class="n">u</span><span class="o">])</span> <span class="o">{</span>
				<span class="n">swap</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="o">++</span><span class="n">u</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-324-wiggle-sort-ii">LeetCode 324. Wiggle Sort II<a hidden class="anchor" aria-hidden="true" href="#leetcode-324-wiggle-sort-ii">#</a></h1>
<p>Given an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]….</p>
<p>Example: <br>
(1) Given nums = [1, 5, 1, 1, 6, 4], one possible answer is [1, 4, 1, 5, 1, 6]. <br>
(2) Given nums = [1, 3, 2, 2, 3, 1], one possible answer is [2, 3, 1, 3, 1, 2].</p>
<p>Note: <br>
You may assume all input has valid answer.</p>
<p>Follow Up:  <br>
Can you do it in O(n) time and/or in-place with O(1) extra space?</p>
<p>解析：</p>
<pre><code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]....
</code></pre>
<p>分析该排序，可以得出排序只需要满足nums[0] &lt; nums[1] &gt; nums[2] ，而不具有传递性，比如nums[0] &lt; nums[2]。所以可以得出一种排序方法：</p>
<p>将数组分成两部分，前半部分小于后半部分，然后前半部分元素填充到结果数组的偶数位，后半部分元素填充到结果数组的奇数位。</p>
<p>先用STL中nth_element()快速找到中位数。</p>
<p>由于上一步只是找到中值的位置，并且让小于等于中值的数在左侧，大于等于中位数的在右侧，这就有一个问题了，等于中值的可能分布在任意位置，必须把等于中值的放在一堆，才能保证nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]….，否则可能出现相等的情况，因此需要再使用三向切分快速排序将中位数全部聚集在中部。</p>
<p>然后填充结果返回。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="c1">//空间复杂度O(n)
</span><span class="c1"></span><span class="nl">public</span><span class="p">:</span>
<span class="kt">void</span> <span class="n">wiggleSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="c1">//中位数位置
</span><span class="c1"></span>    <span class="n">nth_element</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">mid</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="c1">//求出中位数
</span><span class="c1"></span>    <span class="n">threeWayPartition</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="c1">//存储坐标映射后的数组
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">largeStart</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="c1">//后半段的末尾
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">smallStart</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="nl">mid</span> <span class="p">:</span> <span class="p">(</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="c1">//前半段的末尾
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span><span class="c1">//前半段逆向填充偶数位
</span><span class="c1"></span>        <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">smallStart</span><span class="o">--</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span><span class="c1">//后半段逆向填充奇数位
</span><span class="c1"></span>        <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">largeStart</span><span class="o">--</span><span class="p">];</span>
    <span class="n">nums</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">threeWayPartition</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">)</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]);</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">)</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="o">--</span><span class="p">]);</span>
        <span class="k">else</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>补充：</p>
<p>空间复杂度O(1)的做法</p>
<p>之前我们是独立的插入大于或者小于中位数的数, 现在我们可以同时做, 也就是, 遍历数组的时候如果当前的数大于中位数就将其从左往右放奇数位置, 如果小于中位数就将其从右往左放在偶数位置. 这样还需要解决的一个问题是如何可以互不干扰的放到正确位置. 举个栗子: 1, 1, 2, 2, 2, 3这六个数:</p>
<p>我们可以按照这样一个顺序将数组索引拉开成这样: 1, 3, 5, 0, 2, 4, 也就是我们可以按照这样一个顺序来遍历数组, 同时维护一个低位指针用来代表奇数位置已经放到哪里, 和一个高位指针来表示偶数位置已经放到哪里, 这样在我们遍历数组的每一个元素的时候就可以按照这样的方式将元素分别放高位还是低位. 而要将数组按照这样索引的方式遍历我们只需要一个映射即可, 即(2*i+1)%(len|1).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">void</span> <span class="n">wiggleSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">midptr</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">nth_element</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">midptr</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">*</span><span class="n">midptr</span><span class="p">;</span>
    <span class="cp">#define A(i) nums[(1+2*(i)) % (n|1)]</span><span class="c1">//映射坐标
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="p">)</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="o">++</span><span class="p">),</span> <span class="n">A</span><span class="p">(</span><span class="n">j</span><span class="o">++</span><span class="p">));</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">mid</span><span class="p">)</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">A</span><span class="p">(</span><span class="n">k</span><span class="o">--</span><span class="p">));</span>
        <span class="k">else</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-86-partition-list">LeetCode 86. Partition List<a hidden class="anchor" aria-hidden="true" href="#leetcode-86-partition-list">#</a></h1>
<p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p>For example,   <br>
Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,  <br>
return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.</p>
<p>解析：此题是链表版的partition，可以利用链表的性质，直接将链表分为2个子链表来实现partition</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for singly-linked list.
</span><span class="cm"> * struct ListNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     ListNode *next;
</span><span class="cm"> *     ListNode(int x) : val(x), next(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">partition</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="n">node1</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">node2</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node1</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2</span><span class="p">;</span><span class="c1">//将链表分为两个子链表
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">p2</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">p1</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node2</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">node1</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="将单向链表按某值划分成左边小中间相等右边大的形式">将单向链表按某值划分成左边小、中间相等、右边大的形式<a hidden class="anchor" aria-hidden="true" href="#将单向链表按某值划分成左边小中间相等右边大的形式">#</a></h1>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170816-222510@2x.png" alt=""  />

<img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170816-222659@2x.png" alt=""  />
</p>
<p>对每部分都增加了节点顺序要求，同时时间复杂度仍然为O(n),额外空间复杂度为O(1)。既然额外空间复杂度为0(1),说明实现时只能使用有限的几个变量来完成所有的调整。</p>
<p>进阶解法的具体过程如下：</p>
<ol>
<li>
<p>将原链表中的所有节点依次划分进三个链表，三个链表分别为small代表左部分，equal代表中间部分，big代表右部分。</p>
<p>例如，链表 7-&gt;9-&gt;1-&gt;8-&gt;5-&gt;2-&gt;5，pivot=5。在划分之后，small、equal、big 分别为：</p>
<pre><code> small： 1-&gt;2-&gt;null
 equal: 5-&gt;5-&gt;null
 big： 7-&gt;9-&gt;8-&gt;null
</code></pre>
</li>
<li>
<p>将small、equal和big三个链表重新串起来即可。</p>
</li>
<li>
<p>整个过程需要特别注意对null节点的判断和处理。</p>
</li>
</ol>
<p>进阶解法还是主要考查面试者利用有限几个变量调整链表的代码实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">	<span class="kd">public</span> <span class="kd">static</span> <span class="n">Node</span> <span class="nf">listPartition2</span><span class="o">(</span><span class="n">Node</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">pivot</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Node</span> <span class="n">sH</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// small head
</span><span class="c1"></span>		<span class="n">Node</span> <span class="n">sT</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// small tail
</span><span class="c1"></span>		<span class="n">Node</span> <span class="n">eH</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// equal head
</span><span class="c1"></span>		<span class="n">Node</span> <span class="n">eT</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// equal tail
</span><span class="c1"></span>		<span class="n">Node</span> <span class="n">bH</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// big head
</span><span class="c1"></span>		<span class="n">Node</span> <span class="n">bT</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// big tail
</span><span class="c1"></span>		<span class="n">Node</span> <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// save next node
</span><span class="c1"></span>		<span class="c1">// 所有的节点分进三个链表中
</span><span class="c1"></span>		<span class="k">while</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
			<span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">value</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">sH</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">sH</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
					<span class="n">sT</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
				<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
					<span class="n">sT</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
					<span class="n">sT</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
				<span class="o">}</span>
			<span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">value</span> <span class="o">==</span> <span class="n">pivot</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">eH</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">eH</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
					<span class="n">eT</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
				<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
					<span class="n">eT</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
					<span class="n">eT</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
				<span class="o">}</span>
			<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">bH</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">bH</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
					<span class="n">bT</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
				<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
					<span class="n">bT</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
					<span class="n">bT</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
				<span class="o">}</span>
			<span class="o">}</span>
			<span class="n">head</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="c1">//小的和相等的重新连接
</span><span class="c1"></span>		<span class="k">if</span> <span class="o">(</span><span class="n">sT</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">sT</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">eH</span><span class="o">;</span>
			<span class="n">eT</span> <span class="o">=</span> <span class="n">eT</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">sT</span> <span class="o">:</span> <span class="n">eT</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="c1">//所有的重新连接
</span><span class="c1"></span>		<span class="k">if</span> <span class="o">(</span><span class="n">eT</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">eT</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">bH</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">sH</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">sH</span> <span class="o">:</span> <span class="n">eH</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">eH</span> <span class="o">:</span> <span class="n">bH</span><span class="o">;</span>
	<span class="o">}</span>


</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-328-odd-even-linked-list">LeetCode 328. Odd Even Linked List<a hidden class="anchor" aria-hidden="true" href="#leetcode-328-odd-even-linked-list">#</a></h1>
<p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>
<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>
<p>Example:</p>
<pre><code>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,       
return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL.   
</code></pre>
<p>Note:</p>
<p>The relative order inside both the even and odd groups should remain as it was in the input.   <br>
The first node is considered odd, the second node even and so on ….</p>
<p>解析：</p>
<p>将一个链表分成两个链表.odd奇数链表的头指针是head，尾指针是odd even偶数链表的头指针是evenhead 尾指针是even</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for singly-linked list.
</span><span class="cm"> * struct ListNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     ListNode *next;
</span><span class="cm"> *     ListNode(int x) : val(x), next(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span><span class="c1">//Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
</span><span class="c1"></span><span class="nl">public</span><span class="p">:</span>
<span class="n">ListNode</span><span class="o">*</span> <span class="n">oddEvenList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">ListNode</span> <span class="o">*</span><span class="n">odd</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">even</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">evenHead</span> <span class="o">=</span> <span class="n">even</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">even</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">even</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">odd</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">even</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//1-3
</span><span class="c1"></span>        <span class="n">odd</span> <span class="o">=</span> <span class="n">odd</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//更新尾节点
</span><span class="c1"></span>        <span class="n">even</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">odd</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//2-4
</span><span class="c1"></span>        <span class="n">even</span> <span class="o">=</span> <span class="n">even</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//更新尾节点
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="n">odd</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">evenHead</span><span class="p">;</span><span class="c1">//偶数链表插在奇数链表后面
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/linked-list/">Linked List</a></li>
      <li><a href="/tags/quick-sort/">Quick Sort</a></li>
      <li><a href="/tags/array/">Array</a></li>
      <li><a href="/tags/two-pointers/">Two Pointers</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
