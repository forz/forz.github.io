<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>最短路径算法总结 | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="BFS 4. 举例 题目: 用一个整型矩阵matrix表示一个网络，1代表有路，0代表无路，每一个位置只要不越界，都有上下左右4个方向，求从最左上角到最右">
<meta name="author" content="">
<link rel="canonical" href="/post/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="最短路径算法总结" />
<meta property="og:description" content="BFS 4. 举例 题目: 用一个整型矩阵matrix表示一个网络，1代表有路，0代表无路，每一个位置只要不越界，都有上下左右4个方向，求从最左上角到最右" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-07-31T14:45:52&#43;00:00" />
<meta property="article:modified_time" content="2017-07-31T14:45:52&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="最短路径算法总结"/>
<meta name="twitter:description" content="BFS 4. 举例 题目: 用一个整型矩阵matrix表示一个网络，1代表有路，0代表无路，每一个位置只要不越界，都有上下左右4个方向，求从最左上角到最右"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "最短路径算法总结",
      "item": "/post/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "最短路径算法总结",
  "name": "最短路径算法总结",
  "description": "BFS 4. 举例 题目: 用一个整型矩阵matrix表示一个网络，1代表有路，0代表无路，每一个位置只要不越界，都有上下左右4个方向，求从最左上角到最右",
  "keywords": [
    
  ],
  "articleBody": "BFS 4. 举例 题目:\n用一个整型矩阵matrix表示一个网络，1代表有路，0代表无路，每一个位置只要不越界，都有上下左右4个方向，求从最左上角到最右下角的最短通路值。\n例如，matrix为:\n1 0 1 1 1 1 0 1 0 1 1 1 1 0 1 0 0 0 0 1  通路只有一条，由12个1构成，所以返回12。\n解析:\n使用宽度优先遍历即可，时间复杂度为O(N*M).具体过程如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  public static int minPathValue(int[][] m) { if (m == null || m.length == 0 || m[0].length == 0 || m[0][0] != 1 || m[m.length - 1][m[0].length - 1] != 1) { return 0; } int res = 0; int[][] map = new int[m.length][m[0].length]; map[0][0] = 1; QueueInteger rQ = new LinkedListInteger(); QueueInteger cQ = new LinkedListInteger(); rQ.add(0); cQ.add(0); int r = 0; int c = 0; while (!rQ.isEmpty()) { r = rQ.poll(); c = cQ.poll(); if (r == m.length - 1 \u0026\u0026 c == m[0].length - 1) { return map[r][c]; } walkTo(map[r][c], r - 1, c, m, map, rQ, cQ); // up \twalkTo(map[r][c], r + 1, c, m, map, rQ, cQ); // down \twalkTo(map[r][c], r, c - 1, m, map, rQ, cQ); // left \twalkTo(map[r][c], r, c + 1, m, map, rQ, cQ); // right \t} return res; }   Dijkstra 1.定义概览 Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。\n注意该算法要求图中不存在负权边。\n问题描述：在无向图 G=(V,E) 中，假设每条边 E[i] 的长度为 w[i]，找到由顶点 V0 到其余各点的最短路径。（单源最短路径）\n2.算法描述 1)算法思想： 设G=(V,E)是一个带权有向图，把图中顶点集合V分成两组，\n第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，以后每求得一条最短路径 , 就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了），\n第二组为其余未确定最短路径的顶点集合（用U表示），\n按最短路径长度的递增次序依次把第二组的顶点加入S中。\n在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。\n此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离，是从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。\n2)算法步骤：   初始时，S只包含源点，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即:U={其余顶点}，若v与U中顶点u有边，则正常有权值，若u不是v的出边邻接点，则权值为∞。\n  从U中选取一个距离v最小的顶点k，把k加入S中（该选定的距离就是v到k的最短路径长度）。\n  以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。\n  重复步骤2和3直到所有顶点都包含在S中。\n  执行动画过程如下图\n4.举例 题目大意：有N个点，给出从a点到b点的距离，当然a和b是互相可以抵达的，问从1到n的最短距离.\n解题思路：这题要注意的是有重边，dijkstra的算法需要考虑下，bellman-ford和spfa可以忽略这个问题.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  #include#include#includeusing namespace std; const int N=1005; const int M=2005; const int inf=(129); int n,m; int d[N]; struct { int v,w,next; }edge[2*M]; int edgehead[N]; //head[i]保存的是以i为起点的所有边中编号最大的那个,而把这个当作顶点i的第一条起始边的位置. int k; bool vis[N]; void addedge(int u,int v,int w) { edge[k].next=edgehead[u];//表示与第k条边同起点的上一条边的存储位置（头插法） \tedge[k].w=w; //边权值 \tedge[k].v=v; //表示第k条边的终点 \tedgehead[u]=k++; } //链式前向星也是一种通过存储边的信息的方式存储图的数据结构，可以静态建立邻接表。它将边存放在数组中， //把数组中的边按照起点顺序排序，前向星就构造完成了。为了查询方便，经常会有一个数组存储起点为Vi的第一条边的位置。 struct cmp { bool operator ()(const int a,const int b) { return d[a]d[b]; } }; int dijstra(int s) { priority_queueint,vectorint,cmp que; for(int i=1;in;i++)//预处理每个点到源点的距离 \td[i]=inf; d[s]=0; memset(vis,0,sizeof(vis)); que.push(1); while(!que.empty()) { int u=que.top(); que.pop(); if(vis[u])//排除已加入到最短路的顶点 \tcontinue; vis[u]=true; for(int i=edgehead[u];i;i=edge[i].next)//枚举所有邻接边 \t{ int v=edge[i].v; int w=edge[i].w; if(!vis[v]\u0026\u0026d[v]d[u]+w) { d[v]=d[u]+w; que.push(v); } } } return d[n]; } int main() { scanf(\"%d%d\",\u0026m,\u0026n); int u,v,w; k=1; for(int i=1;im;i++) { scanf(\"%d%d%d\",\u0026u,\u0026v,\u0026w); addedge(u,v,w); addedge(v,u,w); } printf(\"%d\\n\",dijstra(1)); return 0; }   Bellman_Ford 1.定义概览 单源最短路径：给定一个图,和一个源顶点src,找到从src到其它所有所有顶点的最短路径，图中可能含有负权值的边。\n关于这个问题我们已经讨论了迪杰斯特拉算法。\nDijksra的算法是一个贪婪算法,时间复杂度是O(VLogV)(使用最小堆)。但是迪杰斯特拉算法在有负权值边的图中不适用,\nBellman-Ford适合这样的图。在网络路由中，该算法会被用作距离向量路由算法。\nBellman-Ford也比迪杰斯特拉算法更简单和同时也适用于分布式系统。但Bellman-Ford的时间复杂度是O(VE),E为边的个数，这要比迪杰斯特拉算法慢。\n2. 算法描述 给定图G(V, E)（其中V、E分别为图G的顶点集与边集），源点s，数组Distant[i]记录从源点s到顶点i的路径长度，初始化数组Distant[n]为, Distant[s]为0；\n以下操作循环执行至多n-1次，n为顶点数：\n对于每一条边e(u, v)，如果Distant[u] + w(u, v) 若上述操作没有对Distant进行更新，说明最短路径已经查找完毕，或者部分点不可达，跳出循环。否则执行下次循环； 为了检测图中是否存在负环路，即权值之和小于0的环路。\n对于每一条边e(u, v)，如果存在Distant[u] + w(u, v) 可知，Bellman-Ford算法寻找单源最短路径的时间复杂度为O(V*E).\n3. 算法步骤：   初始化所有点。每一个点保存一个值，表示从原点到达这个点的距离，将原点的值设为0，其它的点的值设为无穷大（表示不可达）。\n  进行循环，循环下标为从1到n－1（n等于图中点的个数）。在循环内部，遍历所有的边，进行松弛计算。\n  遍历途中所有的边（edge（u，v）），判断是否存在这样情况：\n d（v）  d (u) + w(u,v)  则返回false，表示途中存在从源点可达的权为负的回路。\n之所以需要第三部分的原因，是因为，如果存在从源点可达的权为负的回路。则 应为无法收敛而导致不能求出最短路径。\n  4. 举例 给定N种货币，某些货币之间可以相互兑换，现在给定一些兑换规则，问能否从某一种货币开始兑换，经过一些中间货币之后，最后兑换回这种货币，并且得到的钱比之前的多。\n可以把初始兑换的货币看成源点，采用bellman-ford进行求解，若可以实现要求，则说明图中存在可以无限增大的环，这个可以通过bellman-ford算法判断环是否存在求出来，若在求解过程中发现已经兑换回原货币，并且钱比之前多，则可以直接退出算法。由于兑换过程中每种货币值必须为非负的，因此可以把所有初始路径长度设置为0，按照兑换方式对边进行松弛。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  #include#include#include#includeusing namespace std; const int MAXN=110; const int MAXE=210;//两倍 double dist[MAXN]; int tol;//边的总数 int D[MAXE][2];//存边的起点和终点 double C[MAXE][2];//存汇率和手续费 bool Bellman(int start,int n,double V) { for(int i=1;in;i++) dist[i]=0;////这里与bellman的目的刚好相反。初始化为源点到各点距离无穷小  dist[start]=V;//即bellman本用于找负环，求最小路径，本题是利用同样的思想找正环，求最大路径  for(int i=1;in;i++)//做n-1次（n-1个点） //Bellman-Ford算法不一定要循环n-1次， n为顶点个数只要在某次循环过程中，考虑每条边后， //源点到所有顶点的最短路径长度都没有变，那么Bellman-Ford算法就可以提前结束了  { bool flag=false;//优化  for(int j=0;jtol;j++)//枚举每条边  { int u=D[j][0]; int v=D[j][1]; if(dist[v]  (dist[u]-C[j][1])*C[j][0])//进行比较的是\"某点到自身的权值\"和\"某点到另一点的权值\"  { flag=true;//存在可用边，不能提前结束  dist[v]=(dist[u]-C[j][1])*C[j][0]; } } if(!flag)return false;//没有更新，循环提前结束，也表示不存在正环  } //做了n-1次的全部边松弛操作之后，就确定了所有点的最短路径值。 //如果做第n次全部边松弛操作的时候，还有点的最短值会被更新，则说明图里是存在正环的。  for(int j=0;jtol;j++) if(dist[D[j][1]](dist[D[j][0]]-C[j][1])*C[j][0])//正环能够无限松弛  return true;//有正环  return false; } int main() { int n; int M; int a,b; double c,d,e,f; int S; double V; while(scanf(\"%d%d%d%lf\",\u0026n,\u0026M,\u0026S,\u0026V)!=EOF)//存储数据  { tol=0; while(M--) { scanf(\"%d%d%lf%lf%lf%lf\",\u0026a,\u0026b,\u0026c,\u0026d,\u0026e,\u0026f); D[tol][0]=a; D[tol][1]=b; C[tol][0]=c; C[tol][1]=d; tol++; D[tol][0]=b; D[tol][1]=a; C[tol][0]=e; C[tol][1]=f; tol++; } if(Bellman(S,n,V)) printf(\"YES\\n\");//S为源点的钱，n为源点钱的数目  else printf(\"NO\\n\"); } return 0; }   SPFA 1. 定义概览 spfa可以看成是bellman-ford的队列优化版本，正如在前面讲到的，bellman每一轮用所有边来进行松弛操作可以多确定一个点的最短路径，但是用每次都把所有边拿来松弛太浪费了，不难发现，只有那些已经确定了最短路径的点所连出去的边才是有效的，因为新确定的点一定要先通过已知(最短路径的)节点。\n所以我们只需要把已知节点连出去的边用来松弛就行了，但是问题是我们并不知道哪些点是已知节点，不过我们可以放宽一下条件，找哪些可能是已知节点的点，也就是之前松弛后更新的点，已知节点必然在这些点中。\n所以spfa的做法就是把每次更新了的点放到队列中记录下来。\n在实现上，bellman-ford可以用边集数组或链式前向星来实现。\n而spfa则只能用链式前向星实现。\n在效率上，当图很稠密的时候spfa就退化成和bellman -ford差不多了，因为对于入队的每个节点都要和很多节点去进行松弛操作。\n2. 算法描述 简洁起见，我们约定有向加权图G不存在负权回路，即最短路径一定存在。我们用数组d记录每个结点的最短路径估计值，而且用邻接表来存储图G。\n我们采取的方法是动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且 v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。\nSPFA和经过简单优化的Bellman-Ford无论在思想上还是在复杂度上都有相似之处。算法是迭代式的，最短路径的估计值都是临时的。算法思想是不断地逼近最优解，只在最后一步才确定想要的结果。\n但是他们实现的方式上存在差异。正因为如此，它们的时间复杂度其实有较大差异的。在Bellman-Ford算法中，要是某个点的最短路径估计值更新了，那么我们必须对所有边指向的终点再做一次松弛操作；在SPFA算法中，某个点的最短路径估计值更新，只有以该点为起点的边指向的终点需要再做一次松弛操作。在极端情况下，后者的效率将是前者的n倍，一般情况下，后者的效率也比前者高出不少。基于两者在思想上的相似，可以这样说，SPFA算法其实是Bellman-Ford算法的一个进一步优化的版本。\n3. 算法步骤 算法大致流程是用一个队列来进行维护。初始时将源加入队列。每次从队列中取出一个元素，并对所有与他相邻的点进行松弛，若某个相邻的点松弛成功，则将其入队。直到队列为空时算法结束。\n这个算法，简单的说就是队列优化的bellman-ford,利用了每个点不会更新次数太多的特点发明的此算法SPFA——Shortest Path Faster Algorithm，它可以在O(kE)的时间复杂度内求出源点到其他所有点的最短路径，可以处理负边。\nSPFA的实现甚至比Dijkstra或者Bellman_Ford还要简单：\n  设Dist代表S到I点的当前最短距离，Fa代表S到I的当前最短路径中I点之前的一个点的编号。开始时Dist全部为+∞，只有Dist[S]=0，Fa全部为0。\n  维护一个队列，里面存放所有需要进行迭代的点。初始时队列中只有一个点S。用一个布尔数组记录每个点是否处在队列中。\n  每次迭代，取出队头的点v，依次枚举从v出发的边v-u，设边的长度为len，判断Dist[v]+len是否小于 Dist[u]，若小于则改进Dist[u]，将Fa[u]记为v，并且由于S到u的最短距离变小了，有可能u可以改进其它的点，所以若u不在队列中，就将它放入队尾。这样一直迭代下去直到队列变空，也就是S到所有的最短距离都确定下来，结束算法。\n  若一个点入队次数超过n，则有负权环。\n  SPFA 在形式上和宽度优先搜索非常类似，不同的是宽度优先搜索中一个点出了队列就不可能重新进入队列，但是SPFA中一个点可能在出队列之后再次被放入队列，也就是一个点改进过其它的点之后，过了一段时间可能本身被改进，于是再次用来改进其它的点，这样反复迭代下去。设一个点用来作为迭代点对其它点进行改进的平均次数为k，有办法证明对于通常的情况，k在2左右。\n4. 举例 题目大意：虫洞问题，现在有n个点，m条边，代表现在可以走的通路，比如从a到b和从b到a需要花费c时间，现在在地上出现了w个虫洞，虫洞的意义就是你从a到b话费的时间是-c(时间倒流,并且虫洞是单向的)，现在问你从某个点开始走，能回到从前.\n解题思路：其实给出了坐标，这个时候就可以构成一张图，然后将回到从前理解为是否会出现负权环，用SPFA就可以解出了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  #include #include #include #include using namespace std; int F,N,M,W; const int INF = 1  30; struct Edge { int e,w; Edge(int ee,int ww):e(ee),w(ww) { } }; vectorEdge G[1000]; //整个有向图 int updateTimes[1000]; //最短路的改进次数 int dist[1000]; //dist[i]是源到i的目前最短路长度 int Spfa(int v) { for( int i = 1; i  N; ++i)//初始化所有边到源的最短距离  dist[i] = INF; dist[v] = 0;//源点  queueint que; que.push(v); memset(updateTimes ,0,sizeof(updateTimes)); while( !que.empty()) { int s = que.front(); que.pop(); for( int i = 0;i  G[s].size(); ++i) {//枚举s的所有邻边  int e = G[s][i].e; if( dist[e]  dist[s] + G[s][i].w ) { dist[e] = dist[s] + G[s][i].w; //由于S到e的最短距离变小了，有可能e可以改进其它的点，所以若u不在队列中，就将它放入队尾。  que.push(e); ++updateTimes[e];//维护改进次数  if( updateTimes[e] = N) return true;//若一个点最短路被改进的次数达到n ，则有负权环  } } } return false; } int main(){ cin  F; while( F--) { cin  N  M  W; for( int i = 1; i 1000; ++i)//清空vector  G[i].clear(); int s,e,t; for( int i = 0; i  M; ++ i) {//正权边（双向）  cin  s  e  t; G[s].push_back(Edge(e,t)); G[e].push_back(Edge(s,t)); } for( int i = 0;i  W; ++i) {//负权边（单向）  cin  s  e  t; G[s].push_back(Edge(e,-t)); } if( Spfa(1)) cout  \"YES\" endl; else cout  \"NO\" endl; } }   Floyd 1. 定义概览 Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为O(N3)，空间复杂度为O(N2)。\n2. 算法思想 Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）\n从任意节点i到任意节点j的最短路径不外乎2种可能，1是直接从i到j，2是从i经过若干个节点k到j。所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查Dis(i,k) + Dis(k,j) 3. 算法步骤 a.从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。 b.对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是更新它。\n4. 举例 题意：众所周知，证券经纪业依靠的就是过度的传言。您需要想出股票经纪人中传播假情报的方法，让您的雇主在股票市场的占据优势。为了获得最大的效果，你必须蔓延最快的方式谣言。\n不幸的是你，股票经纪人信息只信任他们的“可靠来源”，这意味着你在你传播谣言之前必须考虑到他们的接触结构。它需要特定股票经纪人和一定的时间把谣言传递给他的每一位同事。你的任务将是写一个程序，告诉您选择哪一个股票经纪人作为谣言的出发点和所花费多少时间将谣言扩散到整个社会的股票经纪人。这一期限是衡量过去的人收到信息所需的时间。 输入\n你的程序包含多组股票经纪人的输入数据。每组以股票经纪人的人数开始。接下来的几行是每个经纪人与其他人接触的一些信息，包括这些人都是谁，以及将讯息传达到他们所需的时间。每个经纪人与其他人接触信息的格式如下：开头的第一个数表示共有n个联系人，接下来就有n对整数。每对整数列出的第一个数字指的是一个联系人（例如，一个'1’是指编号1的人），其次是在传递一个信息给那个人时所采取分钟的时间。没有特殊的标点符号或空格规则。\n每个人的编号为1至经纪人数目。所花费的传递时间是从1到10分钟（含10分种）。股票经纪的人数范围是从1到100。当输入股票经纪人的人数为0时，程序终止。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  #includeint stb[102][102]; int min(int x,int y){return xy?x:y;}//求最小值 void Floyd(int n) //用floyd算法求出所有结点对的最短路径 { int i,j,k; for(k=1;kn;k++) for(i=1;in;i++) for(j=1;jn;j++) stb[i][j]=min(stb[i][j],stb[i][k]+stb[k][j]); } int main() { int i,j; int num,num1,n,dis; int line,ansmix,linemax; while(scanf(\"%d\",\u0026num)\u0026\u0026num)//输入，num为0结束  { for(i=1;inum;i++)//数组初始化  for(j=1;jnum;j++) stb[i][j]=1000010; for(i=1;inum;i++) { scanf(\"%d\",\u0026num1); stb[i][i]=0; for(j=0;jnum1;j++) { scanf(\"%d %d\",\u0026n,\u0026dis); stb[i][n]=dis;//输入数据  } } Floyd(num);//找出每两个点的最短路径  ansmix=1000010; for(i=1;inum;i++) { linemax=0; for(j=1;jnum;j++) { /*找出所有最短路径最长的长度，也就是第i个人向其他人发出 消息，所有人都收到消息的最短时间*/ if(stb[i][j]linemax) { linemax=stb[i][j]; } } if(linemaxansmix) { ansmix=linemax;//找出最短时间  line=i;//确定是哪个人  } } if(ansmix==1000010) printf(\"disjoint\\n\"); else printf(\"%d %d\\n\",line,ansmix); } }   ",
  "wordCount" : "7502",
  "inLanguage": "zh-cn",
  "datePublished": "2017-07-31T14:45:52Z",
  "dateModified": "2017-07-31T14:45:52Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      最短路径算法总结
    </h1>
    <div class="post-meta">July 31, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="bfs">BFS<a hidden class="anchor" aria-hidden="true" href="#bfs">#</a></h1>
<h2 id="4-举例">4. 举例<a hidden class="anchor" aria-hidden="true" href="#4-举例">#</a></h2>
<p>题目:</p>
<p>用一个整型矩阵matrix表示一个网络，1代表有路，0代表无路，每一个位置只要不越界，都有上下左右4个方向，求从最左上角到最右下角的最短通路值。</p>
<p>例如，matrix为:</p>
<pre><code>1 0 1 1 1
1 0 1 0 1
1 1 1 0 1
0 0 0 0 1
</code></pre>
<p>通路只有一条，由12个1构成，所以返回12。</p>
<p>解析:</p>
<p>使用宽度优先遍历即可，时间复杂度为O(N*M).具体过程如下：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170902-113817@2x.png" alt=""  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minPathValue</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">m</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">0</span> <span class="o">||</span> <span class="n">m</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">length</span> <span class="o">==</span> <span class="n">0</span> <span class="o">||</span> <span class="n">m</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">0</span><span class="o">]</span> <span class="o">!=</span> <span class="n">1</span>
				<span class="o">||</span> <span class="n">m</span><span class="o">[</span><span class="n">m</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">m</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">]</span> <span class="o">!=</span> <span class="n">1</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">return</span> <span class="n">0</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
		<span class="kt">int</span><span class="o">[][]</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="n">m</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">length</span><span class="o">];</span>
		<span class="n">map</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
		<span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">rQ</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
		<span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cQ</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
		<span class="n">rQ</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
		<span class="n">cQ</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
		<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
		<span class="k">while</span> <span class="o">(!</span><span class="n">rQ</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">rQ</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
			<span class="n">c</span> <span class="o">=</span> <span class="n">cQ</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">==</span> <span class="n">m</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">return</span> <span class="n">map</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">];</span>
			<span class="o">}</span>
			<span class="n">walkTo</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">],</span> <span class="n">r</span> <span class="o">-</span> <span class="n">1</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">map</span><span class="o">,</span> <span class="n">rQ</span><span class="o">,</span> <span class="n">cQ</span><span class="o">);</span> <span class="c1">// up
</span><span class="c1"></span>			<span class="n">walkTo</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">],</span> <span class="n">r</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">map</span><span class="o">,</span> <span class="n">rQ</span><span class="o">,</span> <span class="n">cQ</span><span class="o">);</span> <span class="c1">// down
</span><span class="c1"></span>			<span class="n">walkTo</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">],</span> <span class="n">r</span><span class="o">,</span> <span class="n">c</span> <span class="o">-</span> <span class="n">1</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">map</span><span class="o">,</span> <span class="n">rQ</span><span class="o">,</span> <span class="n">cQ</span><span class="o">);</span> <span class="c1">// left
</span><span class="c1"></span>			<span class="n">walkTo</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">],</span> <span class="n">r</span><span class="o">,</span> <span class="n">c</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">map</span><span class="o">,</span> <span class="n">rQ</span><span class="o">,</span> <span class="n">cQ</span><span class="o">);</span> <span class="c1">// right
</span><span class="c1"></span>		<span class="o">}</span>
		<span class="k">return</span> <span class="n">res</span><span class="o">;</span>
	<span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div><h1 id="dijkstra">Dijkstra<a hidden class="anchor" aria-hidden="true" href="#dijkstra">#</a></h1>
<h2 id="1定义概览">1.定义概览<a hidden class="anchor" aria-hidden="true" href="#1定义概览">#</a></h2>
<p>Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。</p>
<p><strong>注意该算法要求图中不存在负权边。</strong></p>
<p>问题描述：在无向图 G=(V,E) 中，假设每条边 E[i] 的长度为 w[i]，找到由顶点 V0 到其余各点的最短路径。（单源最短路径）</p>
<h2 id="2算法描述">2.算法描述<a hidden class="anchor" aria-hidden="true" href="#2算法描述">#</a></h2>
<h3 id="1算法思想">1)算法思想：<a hidden class="anchor" aria-hidden="true" href="#1算法思想">#</a></h3>
<p>设G=(V,E)是一个带权有向图，把图中顶点集合V分成两组，</p>
<p>第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，以后每求得一条最短路径 , 就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了），</p>
<p>第二组为其余未确定最短路径的顶点集合（用U表示），</p>
<p>按最短路径长度的递增次序依次把第二组的顶点加入S中。</p>
<p>在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。</p>
<p>此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离，是从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。</p>
<h3 id="2算法步骤">2)算法步骤：<a hidden class="anchor" aria-hidden="true" href="#2算法步骤">#</a></h3>
<ol>
<li>
<p>初始时，S只包含源点，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即:U={其余顶点}，若v与U中顶点u有边，则&lt;u,v&gt;正常有权值，若u不是v的出边邻接点，则&lt;u,v&gt;权值为∞。</p>
</li>
<li>
<p>从U中选取一个距离v最小的顶点k，把k加入S中（该选定的距离就是v到k的最短路径长度）。</p>
</li>
<li>
<p>以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。</p>
</li>
<li>
<p>重复步骤2和3直到所有顶点都包含在S中。</p>
</li>
</ol>
<p>执行动画过程如下图</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/2012073019540660.gif" alt=""  />
</p>
<h2 id="4举例">4.举例<a hidden class="anchor" aria-hidden="true" href="#4举例">#</a></h2>
<p>题目大意：有N个点，给出从a点到b点的距离，当然a和b是互相可以抵达的，问从1到n的最短距离.</p>
<p>解题思路：这题要注意的是有重边，dijkstra的算法需要考虑下，bellman-ford和spfa可以忽略这个问题.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;queue&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;cstring&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span><span class="o">=</span><span class="mi">1005</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">M</span><span class="o">=</span><span class="mi">2005</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">inf</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">29</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="k">struct</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">M</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">edgehead</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="c1">//head[i]保存的是以i为起点的所有边中编号最大的那个,而把这个当作顶点i的第一条起始边的位置.
</span><span class="c1"></span><span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">vis</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">addedge</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span><span class="kt">int</span> <span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">edge</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">next</span><span class="o">=</span><span class="n">edgehead</span><span class="p">[</span><span class="n">u</span><span class="p">];</span><span class="c1">//表示与第k条边同起点的上一条边的存储位置（头插法）
</span><span class="c1"></span>	<span class="n">edge</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">;</span>            <span class="c1">//边权值
</span><span class="c1"></span>	<span class="n">edge</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="p">;</span>         <span class="c1">//表示第k条边的终点
</span><span class="c1"></span>	<span class="n">edgehead</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">k</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//链式前向星也是一种通过存储边的信息的方式存储图的数据结构，可以静态建立邻接表。它将边存放在数组中，
</span><span class="c1">//把数组中的边按照起点顺序排序，前向星就构造完成了。为了查询方便，经常会有一个数组存储起点为Vi的第一条边的位置。
</span><span class="c1"></span><span class="k">struct</span> <span class="n">cmp</span>
<span class="p">{</span>
	<span class="kt">bool</span> <span class="n">operator</span> <span class="p">()(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="k">const</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">&gt;</span><span class="n">d</span><span class="p">[</span><span class="n">b</span><span class="p">];</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">dijstra</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">priority_queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span><span class="n">cmp</span><span class="o">&gt;</span> <span class="n">que</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//预处理每个点到源点的距离
</span><span class="c1"></span>		<span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">inf</span><span class="p">;</span>
	<span class="n">d</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">vis</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">vis</span><span class="p">));</span>
	<span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">u</span><span class="o">=</span><span class="n">que</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
		<span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
		<span class="k">if</span><span class="p">(</span><span class="n">vis</span><span class="p">[</span><span class="n">u</span><span class="p">])</span><span class="c1">//排除已加入到最短路的顶点
</span><span class="c1"></span>			<span class="k">continue</span><span class="p">;</span>
		<span class="n">vis</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">edgehead</span><span class="p">[</span><span class="n">u</span><span class="p">];</span><span class="n">i</span><span class="p">;</span><span class="n">i</span><span class="o">=</span><span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="p">)</span><span class="c1">//枚举所有邻接边
</span><span class="c1"></span>		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">v</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">w</span><span class="o">=</span><span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">w</span><span class="p">;</span>
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">&amp;&amp;</span><span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">&gt;</span><span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">+</span><span class="n">w</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">+</span><span class="n">w</span><span class="p">;</span>
				<span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d%d&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">;</span>
	<span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d%d%d&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">u</span><span class="p">,</span><span class="o">&amp;</span><span class="n">v</span><span class="p">,</span><span class="o">&amp;</span><span class="n">w</span><span class="p">);</span>
		<span class="n">addedge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">);</span>
		<span class="n">addedge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">w</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">dijstra</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="bellman_ford">Bellman_Ford<a hidden class="anchor" aria-hidden="true" href="#bellman_ford">#</a></h1>
<h2 id="1定义概览-1">1.定义概览<a hidden class="anchor" aria-hidden="true" href="#1定义概览-1">#</a></h2>
<p>单源最短路径：给定一个图,和一个源顶点src,找到从src到其它所有所有顶点的最短路径，<strong>图中可能含有负权值的边。</strong></p>
<p>关于这个问题我们已经讨论了迪杰斯特拉算法。</p>
<p>Dijksra的算法是一个贪婪算法,时间复杂度是O(VLogV)(使用最小堆)。但是迪杰斯特拉算法在有负权值边的图中不适用,</p>
<p>Bellman-Ford适合这样的图。在网络路由中，该算法会被用作距离向量路由算法。</p>
<p>Bellman-Ford也比迪杰斯特拉算法更简单和同时也适用于分布式系统。但Bellman-Ford的时间复杂度是O(VE),E为边的个数，这要比迪杰斯特拉算法慢。</p>
<h2 id="2-算法描述">2. 算法描述<a hidden class="anchor" aria-hidden="true" href="#2-算法描述">#</a></h2>
<p>给定图G(V, E)（其中V、E分别为图G的顶点集与边集），源点s，数组Distant[i]记录从源点s到顶点i的路径长度，初始化数组Distant[n]为, Distant[s]为0；</p>
<p>以下操作循环执行至多n-1次，n为顶点数：</p>
<p>对于每一条边e(u, v)，如果Distant[u] + w(u, v) &lt; Distant[v]，则令Distant[v] = Distant[u]+w(u, v)。w(u, v)为边e(u,v)的权值；</p>
<p>若上述操作没有对Distant进行更新，说明最短路径已经查找完毕，或者部分点不可达，跳出循环。否则执行下次循环；
为了检测图中是否存在负环路，即权值之和小于0的环路。</p>
<p>对于每一条边e(u, v)，如果存在Distant[u] + w(u, v) &lt; Distant[v]的边，则图中存在负环路，即是说该图无法求出单源最短路径。否则数组Distant[n]中记录的就是源点s到各顶点的最短路径长度。</p>
<p>可知，Bellman-Ford算法寻找单源最短路径的时间复杂度为O(V*E).</p>
<h2 id="3-算法步骤">3. 算法步骤：<a hidden class="anchor" aria-hidden="true" href="#3-算法步骤">#</a></h2>
<ol>
<li>
<p>初始化所有点。每一个点保存一个值，表示从原点到达这个点的距离，将原点的值设为0，其它的点的值设为无穷大（表示不可达）。</p>
</li>
<li>
<p>进行循环，循环下标为从1到n－1（n等于图中点的个数）。在循环内部，遍历所有的边，进行松弛计算。</p>
</li>
<li>
<p>遍历途中所有的边（edge（u，v）），判断是否存在这样情况：</p>
<pre><code> d（v） &gt; d (u) + w(u,v)
</code></pre>
<p>则返回false，表示途中存在从源点可达的权为负的回路。</p>
<p>之所以需要第三部分的原因，是因为，如果存在从源点可达的权为负的回路。则 应为无法收敛而导致不能求出最短路径。</p>
</li>
</ol>
<h2 id="4-举例-1">4. 举例<a hidden class="anchor" aria-hidden="true" href="#4-举例-1">#</a></h2>
<p>给定N种货币，某些货币之间可以相互兑换，现在给定一些兑换规则，问能否从某一种货币开始兑换，经过一些中间货币之后，最后兑换回这种货币，并且得到的钱比之前的多。</p>
<p>可以把初始兑换的货币看成源点，采用bellman-ford进行求解，若可以实现要求，则说明图中存在可以无限增大的环，这个可以通过bellman-ford算法判断环是否存在求出来，若在求解过程中发现已经兑换回原货币，并且钱比之前多，则可以直接退出算法。由于兑换过程中每种货币值必须为非负的，因此可以把所有初始路径长度设置为0，按照兑换方式对边进行松弛。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">MAXN</span><span class="o">=</span><span class="mi">110</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">MAXE</span><span class="o">=</span><span class="mi">210</span><span class="p">;</span><span class="c1">//两倍
</span><span class="c1"></span><span class="kt">double</span> <span class="n">dist</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">tol</span><span class="p">;</span><span class="c1">//边的总数
</span><span class="c1"></span><span class="kt">int</span> <span class="n">D</span><span class="p">[</span><span class="n">MAXE</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span><span class="c1">//存边的起点和终点
</span><span class="c1"></span><span class="kt">double</span> <span class="n">C</span><span class="p">[</span><span class="n">MAXE</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span><span class="c1">//存汇率和手续费
</span><span class="c1"></span><span class="kt">bool</span> <span class="nf">Bellman</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="kt">double</span> <span class="n">V</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">////这里与bellman的目的刚好相反。初始化为源点到各点距离无穷小
</span><span class="c1"></span>    <span class="n">dist</span><span class="p">[</span><span class="n">start</span><span class="p">]</span><span class="o">=</span><span class="n">V</span><span class="p">;</span><span class="c1">//即bellman本用于找负环，求最小路径，本题是利用同样的思想找正环，求最大路径
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//做n-1次（n-1个点）
</span><span class="c1">//Bellman-Ford算法不一定要循环n-1次， n为顶点个数只要在某次循环过程中，考虑每条边后，
</span><span class="c1">//源点到所有顶点的最短路径长度都没有变，那么Bellman-Ford算法就可以提前结束了
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">flag</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span><span class="c1">//优化
</span><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">tol</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="c1">//枚举每条边
</span><span class="c1"></span>        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">u</span><span class="o">=</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
            <span class="k">if</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">-</span><span class="n">C</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="c1">//进行比较的是&#34;某点到自身的权值&#34;和&#34;某点到另一点的权值&#34;
</span><span class="c1"></span>            <span class="p">{</span>
                <span class="n">flag</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span><span class="c1">//存在可用边，不能提前结束
</span><span class="c1"></span>                <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">-</span><span class="n">C</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">)</span><span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//没有更新，循环提前结束，也表示不存在正环
</span><span class="c1"></span>    <span class="p">}</span>
<span class="c1">//做了n-1次的全部边松弛操作之后，就确定了所有点的最短路径值。
</span><span class="c1">//如果做第n次全部边松弛操作的时候，还有点的最短值会被更新，则说明图里是存在正环的。
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">tol</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="k">if</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span><span class="o">&lt;</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">-</span><span class="n">C</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="c1">//正环能够无限松弛
</span><span class="c1"></span>        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span><span class="c1">//有正环
</span><span class="c1"></span>    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">M</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">f</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">S</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">V</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d%d%d%lf&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">,</span><span class="o">&amp;</span><span class="n">M</span><span class="p">,</span><span class="o">&amp;</span><span class="n">S</span><span class="p">,</span><span class="o">&amp;</span><span class="n">V</span><span class="p">)</span><span class="o">!=</span><span class="n">EOF</span><span class="p">)</span><span class="c1">//存储数据
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="n">tol</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">M</span><span class="o">--</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d%d%lf%lf%lf%lf&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="o">&amp;</span><span class="n">d</span><span class="p">,</span><span class="o">&amp;</span><span class="n">e</span><span class="p">,</span><span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>
            <span class="n">D</span><span class="p">[</span><span class="n">tol</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">;</span>
            <span class="n">D</span><span class="p">[</span><span class="n">tol</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">b</span><span class="p">;</span>
            <span class="n">C</span><span class="p">[</span><span class="n">tol</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">c</span><span class="p">;</span>
            <span class="n">C</span><span class="p">[</span><span class="n">tol</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">d</span><span class="p">;</span>
            <span class="n">tol</span><span class="o">++</span><span class="p">;</span>
            <span class="n">D</span><span class="p">[</span><span class="n">tol</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">b</span><span class="p">;</span>
            <span class="n">D</span><span class="p">[</span><span class="n">tol</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">;</span>
            <span class="n">C</span><span class="p">[</span><span class="n">tol</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">e</span><span class="p">;</span>
            <span class="n">C</span><span class="p">[</span><span class="n">tol</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">f</span><span class="p">;</span>
            <span class="n">tol</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">Bellman</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">V</span><span class="p">))</span> <span class="n">printf</span><span class="p">(</span><span class="s">&#34;YES</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span><span class="c1">//S为源点的钱，n为源点钱的数目
</span><span class="c1"></span>        <span class="k">else</span> <span class="n">printf</span><span class="p">(</span><span class="s">&#34;NO</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="spfa">SPFA<a hidden class="anchor" aria-hidden="true" href="#spfa">#</a></h1>
<h2 id="1-定义概览">1. 定义概览<a hidden class="anchor" aria-hidden="true" href="#1-定义概览">#</a></h2>
<p>spfa可以看成是bellman-ford的队列优化版本，正如在前面讲到的，bellman每一轮用所有边来进行松弛操作可以多确定一个点的最短路径，但是用每次都把所有边拿来松弛太浪费了，不难发现，只有那些已经确定了最短路径的点所连出去的边才是有效的，因为新确定的点一定要先通过已知(最短路径的)节点。</p>
<p>所以我们只需要把已知节点连出去的边用来松弛就行了，但是问题是我们并不知道哪些点是已知节点，不过我们可以放宽一下条件，找哪些可能是已知节点的点，也就是之前松弛后更新的点，已知节点必然在这些点中。</p>
<p>所以spfa的做法就是把每次更新了的点放到队列中记录下来。</p>
<p>在实现上，bellman-ford可以用边集数组或链式前向星来实现。</p>
<p>而spfa则只能用链式前向星实现。</p>
<p>在效率上，当图很稠密的时候spfa就退化成和bellman -ford差不多了，因为对于入队的每个节点都要和很多节点去进行松弛操作。</p>
<h2 id="2-算法描述-1">2. 算法描述<a hidden class="anchor" aria-hidden="true" href="#2-算法描述-1">#</a></h2>
<p>简洁起见，我们约定有向加权图G不存在负权回路，即最短路径一定存在。我们用数组d记录每个结点的最短路径估计值，而且用邻接表来存储图G。</p>
<p>我们采取的方法是动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且 v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。</p>
<p>SPFA和经过简单优化的Bellman-Ford无论在思想上还是在复杂度上都有相似之处。算法是迭代式的，最短路径的估计值都是临时的。算法思想是不断地逼近最优解，只在最后一步才确定想要的结果。</p>
<p>但是他们实现的方式上存在差异。正因为如此，它们的时间复杂度其实有较大差异的。在Bellman-Ford算法中，要是某个点的最短路径估计值更新了，那么我们必须对所有边指向的终点再做一次松弛操作；在SPFA算法中，某个点的最短路径估计值更新，只有以该点为起点的边指向的终点需要再做一次松弛操作。在极端情况下，后者的效率将是前者的n倍，一般情况下，后者的效率也比前者高出不少。基于两者在思想上的相似，可以这样说，SPFA算法其实是Bellman-Ford算法的一个进一步优化的版本。</p>
<h2 id="3-算法步骤-1">3. 算法步骤<a hidden class="anchor" aria-hidden="true" href="#3-算法步骤-1">#</a></h2>
<p>算法大致流程是用一个队列来进行维护。初始时将源加入队列。每次从队列中取出一个元素，并对所有与他相邻的点进行松弛，若某个相邻的点松弛成功，则将其入队。直到队列为空时算法结束。</p>
<p>这个算法，简单的说就是队列优化的bellman-ford,利用了每个点不会更新次数太多的特点发明的此算法SPFA——Shortest Path Faster Algorithm，它可以在O(kE)的时间复杂度内求出源点到其他所有点的最短路径，可以处理负边。</p>
<p>SPFA的实现甚至比Dijkstra或者Bellman_Ford还要简单：</p>
<ol>
<li>
<p>设Dist代表S到I点的当前最短距离，Fa代表S到I的当前最短路径中I点之前的一个点的编号。开始时Dist全部为+∞，只有Dist[S]=0，Fa全部为0。</p>
</li>
<li>
<p>维护一个队列，里面存放所有需要进行迭代的点。初始时队列中只有一个点S。用一个布尔数组记录每个点是否处在队列中。</p>
</li>
<li>
<p>每次迭代，取出队头的点v，依次枚举从v出发的边v-&gt;u，设边的长度为len，判断Dist[v]+len是否小于 Dist[u]，若小于则改进Dist[u]，将Fa[u]记为v，并且由于S到u的最短距离变小了，有可能u可以改进其它的点，所以若u不在队列中，就将它放入队尾。这样一直迭代下去直到队列变空，也就是S到所有的最短距离都确定下来，结束算法。</p>
</li>
<li>
<p>若一个点入队次数超过n，则有负权环。</p>
</li>
</ol>
<p>SPFA 在形式上和宽度优先搜索非常类似，不同的是宽度优先搜索中一个点出了队列就不可能重新进入队列，但是SPFA中一个点可能在出队列之后再次被放入队列，也就是一个点改进过其它的点之后，过了一段时间可能本身被改进，于是再次用来改进其它的点，这样反复迭代下去。设一个点用来作为迭代点对其它点进行改进的平均次数为k，有办法证明对于通常的情况，k在2左右。</p>
<h2 id="4-举例-2">4. 举例<a hidden class="anchor" aria-hidden="true" href="#4-举例-2">#</a></h2>
<p>题目大意：虫洞问题，现在有n个点，m条边，代表现在可以走的通路，比如从a到b和从b到a需要花费c时间，现在在地上出现了w个虫洞，虫洞的意义就是你从a到b话费的时间是-c(时间倒流,并且虫洞是单向的)，现在问你从某个点开始走，能回到从前.</p>
<p>解题思路：其实给出了坐标，这个时候就可以构成一张图，然后将回到从前理解为是否会出现负权环，用SPFA就可以解出了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">F</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">W</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">INF</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Edge</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">e</span><span class="p">,</span><span class="n">w</span><span class="p">;</span>
    <span class="n">Edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">ee</span><span class="p">,</span><span class="kt">int</span> <span class="n">ww</span><span class="p">)</span><span class="o">:</span><span class="n">e</span><span class="p">(</span><span class="n">ee</span><span class="p">),</span><span class="n">w</span><span class="p">(</span><span class="n">ww</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">G</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span> <span class="c1">//整个有向图
</span><span class="c1"></span><span class="kt">int</span> <span class="n">updateTimes</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span> <span class="c1">//最短路的改进次数
</span><span class="c1"></span><span class="kt">int</span> <span class="n">dist</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span> <span class="c1">//dist[i]是源到i的目前最短路长度
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">Spfa</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="c1">//初始化所有边到源的最短距离
</span><span class="c1"></span>        <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
    <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//源点
</span><span class="c1"></span>    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">que</span><span class="p">;</span> <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">updateTimes</span> <span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">updateTimes</span><span class="p">));</span>
    <span class="k">while</span><span class="p">(</span> <span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">[</span><span class="n">s</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="c1">//枚举s的所有邻边
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">e</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">dist</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">+</span> <span class="n">G</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">w</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">dist</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">+</span> <span class="n">G</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">w</span><span class="p">;</span>
<span class="c1">//由于S到e的最短距离变小了，有可能e可以改进其它的点，所以若u不在队列中，就将它放入队尾。
</span><span class="c1"></span>                <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
                <span class="o">++</span><span class="n">updateTimes</span><span class="p">[</span><span class="n">e</span><span class="p">];</span><span class="c1">//维护改进次数
</span><span class="c1"></span>                <span class="k">if</span><span class="p">(</span> <span class="n">updateTimes</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span><span class="c1">//若一个点最短路被改进的次数达到n ，则有负权环
</span><span class="c1"></span>            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">F</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span> <span class="n">F</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">N</span> <span class="o">&gt;&gt;</span> <span class="n">M</span> <span class="o">&gt;&gt;</span> <span class="n">W</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="c1">//清空vector
</span><span class="c1"></span>            <span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">s</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">t</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="c1">//正权边（双向）
</span><span class="c1"></span>            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="n">e</span> <span class="o">&gt;&gt;</span> <span class="n">t</span><span class="p">;</span>
            <span class="n">G</span><span class="p">[</span><span class="n">s</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">Edge</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">t</span><span class="p">));</span>
            <span class="n">G</span><span class="p">[</span><span class="n">e</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">Edge</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">W</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="c1">//负权边（单向）
</span><span class="c1"></span>            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="n">e</span> <span class="o">&gt;&gt;</span> <span class="n">t</span><span class="p">;</span>
            <span class="n">G</span><span class="p">[</span><span class="n">s</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">Edge</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="o">-</span><span class="n">t</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">Spfa</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;YES&#34;</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;NO&#34;</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="floyd">Floyd<a hidden class="anchor" aria-hidden="true" href="#floyd">#</a></h1>
<h2 id="1-定义概览-1">1. 定义概览<a hidden class="anchor" aria-hidden="true" href="#1-定义概览-1">#</a></h2>
<p>Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为O(N3)，空间复杂度为O(N2)。</p>
<h2 id="2-算法思想">2. 算法思想<a hidden class="anchor" aria-hidden="true" href="#2-算法思想">#</a></h2>
<p>Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）</p>
<p>从任意节点i到任意节点j的最短路径不外乎2种可能，1是直接从i到j，2是从i经过若干个节点k到j。所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查Dis(i,k) + Dis(k,j) &lt; Dis(i,j)是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们便设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。</p>
<h2 id="3-算法步骤-2">3. 算法步骤<a hidden class="anchor" aria-hidden="true" href="#3-算法步骤-2">#</a></h2>
<p>a.从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。 　　</p>
<p>b.对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是更新它。</p>
<h2 id="4-举例-3">4. 举例<a hidden class="anchor" aria-hidden="true" href="#4-举例-3">#</a></h2>
<p>题意：众所周知，证券经纪业依靠的就是过度的传言。您需要想出股票经纪人中传播假情报的方法，让您的雇主在股票市场的占据优势。为了获得最大的效果，你必须蔓延最快的方式谣言。</p>
<p>不幸的是你，股票经纪人信息只信任他们的“可靠来源”，这意味着你在你传播谣言之前必须考虑到他们的接触结构。它需要特定股票经纪人和一定的时间把谣言传递给他的每一位同事。你的任务将是写一个程序，告诉您选择哪一个股票经纪人作为谣言的出发点和所花费多少时间将谣言扩散到整个社会的股票经纪人。这一期限是衡量过去的人收到信息所需的时间。
输入</p>
<p>你的程序包含多组股票经纪人的输入数据。每组以股票经纪人的人数开始。接下来的几行是每个经纪人与其他人接触的一些信息，包括这些人都是谁，以及将讯息传达到他们所需的时间。每个经纪人与其他人接触信息的格式如下：开头的第一个数表示共有n个联系人，接下来就有n对整数。每对整数列出的第一个数字指的是一个联系人（例如，一个'1&rsquo;是指编号1的人），其次是在传递一个信息给那个人时所采取分钟的时间。没有特殊的标点符号或空格规则。</p>
<p>每个人的编号为1至经纪人数目。所花费的传递时间是从1到10分钟（含10分种）。股票经纪的人数范围是从1到100。当输入股票经纪人的人数为0时，程序终止。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="n">stb</span><span class="p">[</span><span class="mi">102</span><span class="p">][</span><span class="mi">102</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">min</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">){</span><span class="k">return</span> <span class="n">x</span><span class="o">&lt;</span><span class="n">y</span><span class="o">?</span><span class="nl">x</span><span class="p">:</span><span class="n">y</span><span class="p">;}</span><span class="c1">//求最小值
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">Floyd</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>  <span class="c1">//用floyd算法求出所有结点对的最短路径
</span><span class="c1"></span><span class="p">{</span>
      <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
      <span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
          <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
              <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
                  <span class="n">stb</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">min</span><span class="p">(</span><span class="n">stb</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">stb</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">stb</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num</span><span class="p">,</span><span class="n">num1</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">dis</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">line</span><span class="p">,</span><span class="n">ansmix</span><span class="p">,</span><span class="n">linemax</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">num</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="n">num</span><span class="p">)</span><span class="c1">//输入，num为0结束
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">num</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//数组初始化
</span><span class="c1"></span>            <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">num</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
                <span class="n">stb</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mi">1000010</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">num</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">num1</span><span class="p">);</span>
            <span class="n">stb</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">num1</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d %d&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">,</span><span class="o">&amp;</span><span class="n">dis</span><span class="p">);</span>
                <span class="n">stb</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span><span class="p">]</span><span class="o">=</span><span class="n">dis</span><span class="p">;</span><span class="c1">//输入数据
</span><span class="c1"></span>            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">Floyd</span><span class="p">(</span><span class="n">num</span><span class="p">);</span><span class="c1">//找出每两个点的最短路径
</span><span class="c1"></span>        <span class="n">ansmix</span><span class="o">=</span><span class="mi">1000010</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">num</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">linemax</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">num</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="cm">/*找出所有最短路径最长的长度，也就是第i个人向其他人发出
</span><span class="cm">                消息，所有人都收到消息的最短时间*/</span>
                <span class="k">if</span><span class="p">(</span><span class="n">stb</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="n">linemax</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">linemax</span><span class="o">=</span><span class="n">stb</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span><span class="p">(</span><span class="n">linemax</span><span class="o">&lt;</span><span class="n">ansmix</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">ansmix</span><span class="o">=</span><span class="n">linemax</span><span class="p">;</span><span class="c1">//找出最短时间
</span><span class="c1"></span>                <span class="n">line</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="c1">//确定是哪个人
</span><span class="c1"></span>            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ansmix</span><span class="o">==</span><span class="mi">1000010</span><span class="p">)</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&#34;disjoint</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">line</span><span class="p">,</span><span class="n">ansmix</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
