<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>interface和reflect源码剖析 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="interface Go 语言中的接口是一组方法的签名，它是 Go 语言的重要组成部分。使用接口能够让我们写出易于测试的代码，然而很多工程师对 Go 的接口了解都非常有限，也" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.89.4 with theme even" />


<link rel="canonical" href="/post/interface%E5%92%8Creflect%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="interface和reflect源码剖析" />
<meta property="og:description" content="interface Go 语言中的接口是一组方法的签名，它是 Go 语言的重要组成部分。使用接口能够让我们写出易于测试的代码，然而很多工程师对 Go 的接口了解都非常有限，也" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/interface%E5%92%8Creflect%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-06-28T11:13:34+00:00" />
<meta property="article:modified_time" content="2021-06-28T11:13:34+00:00" />

<meta itemprop="name" content="interface和reflect源码剖析">
<meta itemprop="description" content="interface Go 语言中的接口是一组方法的签名，它是 Go 语言的重要组成部分。使用接口能够让我们写出易于测试的代码，然而很多工程师对 Go 的接口了解都非常有限，也"><meta itemprop="datePublished" content="2021-06-28T11:13:34+00:00" />
<meta itemprop="dateModified" content="2021-06-28T11:13:34+00:00" />
<meta itemprop="wordCount" content="15938">
<meta itemprop="keywords" content="Go源码," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="interface和reflect源码剖析"/>
<meta name="twitter:description" content="interface Go 语言中的接口是一组方法的签名，它是 Go 语言的重要组成部分。使用接口能够让我们写出易于测试的代码，然而很多工程师对 Go 的接口了解都非常有限，也"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">interface和reflect源码剖析</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-06-28 </span>
        <div class="post-category">
            <a href="/categories/go%E6%BA%90%E7%A0%81/"> Go源码 </a>
            </div>
          <span class="more-meta"> 约 15938 字 </span>
          <span class="more-meta"> 预计阅读 32 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#interface">interface</a>
      <ul>
        <li><a href="#概述">概述</a></li>
        <li><a href="#数据结构">数据结构</a></li>
        <li><a href="#类型转换">类型转换</a></li>
        <li><a href="#类型断言">类型断言</a></li>
        <li><a href="#动态派发">动态派发</a></li>
        <li><a href="#小结">小结</a></li>
      </ul>
    </li>
    <li><a href="#reflect">reflect</a>
      <ul>
        <li><a href="#三大法则">三大法则</a></li>
        <li><a href="#typeofvalueof">TypeOf&amp;ValueOf</a></li>
        <li><a href="#valueset">Value.Set</a></li>
        <li><a href="#实现协议">实现协议</a></li>
        <li><a href="#方法调用">方法调用</a></li>
        <li><a href="#小结-1">小结</a></li>
      </ul>
    </li>
    <li><a href="#转载">转载</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="interface">interface</h2>
<p>Go 语言中的接口是一组方法的签名，它是 Go 语言的重要组成部分。使用接口能够让我们写出易于测试的代码，然而很多工程师对 Go 的接口了解都非常有限，也不清楚其底层的实现原理，这成为了开发高性能服务的阻碍。</p>
<p>本节会介绍使用接口时遇到的一些常见问题以及它的设计与实现，包括接口的类型转换、类型断言以及动态派发机制，帮助各位读者更好地理解接口类型。</p>
<h3 id="概述">概述</h3>
<p>在计算机科学中，接口是计算机系统中多个组件共享的边界，不同的组件能够在边界上交换信息。如下图所示，接口的本质是引入一个新的中间层，调用方可以通过接口与具体实现分离，解除上下游的耦合，上层的模块不再需要依赖下层的具体模块，只需要依赖一个约定好的接口。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210628113452.png" alt=""></p>
<p>这种面向接口的编程方式有着非常强大的生命力，无论是在框架还是操作系统中我们都能够找到接口的身影。可移植操作系统接口（Portable Operating System Interface，POSIX)就是一个典型的例子，它定义了应用程序接口和命令行等标准，为计算机软件带来了可移植性 — 只要操作系统实现了 POSIX，计算机软件就可以直接在不同操作系统上运行。</p>
<p>除了解耦有依赖关系的上下游，接口还能够帮助我们隐藏底层实现，减少关注点。《计算机程序的构造和解释》中有这么一句话：</p>
<p>代码必须能够被人阅读，只是机器恰好可以执行3</p>
<p>人能够同时处理的信息非常有限，定义良好的接口能够隔离底层的实现，让我们将重点放在当前的代码片段中。SQL 就是接口的一个例子，当我们使用 SQL 语句查询数据时，其实不需要关心底层数据库的具体实现，我们只在乎 SQL 返回的结果是否符合预期。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210628113854.png" alt=""></p>
<p>计算机科学中的接口是比较抽象的概念，但是编程语言中接口的概念就更加具体。Go 语言中的接口是一种内置的类型，它定义了一组方法的签名，本节会介绍 Go 语言接口的几个基本概念以及常见问题，为后面的实现原理做铺垫。</p>
<h4 id="隐式接口">隐式接口</h4>
<p>很多面向对象语言都有接口这一概念，例如 Java 和 C#。Java 的接口不仅可以定义方法签名，还可以定义变量，这些定义的变量可以直接在实现接口的类中使用，这里简单介绍一下 Java 中的接口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MyInterface</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">hello</span> <span class="o">=</span> <span class="s">&#34;Hello&#34;</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sayHello</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码定义了一个必须实现的方法 sayHello 和一个会注入到实现类的变量 hello。在下面的代码中，MyInterfaceImpl 实现了 MyInterface 接口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyInterfaceImpl</span> <span class="kd">implements</span> <span class="n">MyInterface</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sayHello</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">MyInterface</span><span class="o">.</span><span class="na">hello</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Java 中的类必须通过上述方式显式地声明实现的接口，但是在 Go 语言中实现接口就不需要使用类似的方式。首先，我们简单了解一下在 Go 语言中如何定义接口。定义接口需要使用 interface 关键字，在接口中我们只能定义方法签名，不能包含成员变量，一个常见的 Go 语言接口是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="kt">error</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果一个类型需要实现 error 接口，那么它只需要实现 Error() string 方法，下面的 RPCError 结构体就是 error 接口的一个实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">RPCError</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Code</span>    <span class="kt">int64</span>
	<span class="nx">Message</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">RPCError</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s, code=%d&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Message</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Code</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>细心的读者可能会发现上述代码根本就没有 error 接口的影子，这是为什么呢？Go 语言中接口的实现都是隐式的，我们只需要实现 <code>Error() string</code> 方法就实现了 error 接口。Go 语言实现接口的方式与 Java 完全不同：</p>
<ul>
<li>在 Java 中：实现接口需要显式地声明接口并实现所有方法；</li>
<li>在 Go 中：实现接口的所有方法就隐式地实现了接口；</li>
</ul>
<p>我们使用上述 RPCError 结构体时并不关心它实现了哪些接口，Go 语言只会在传递参数、返回参数以及变量赋值时才会对某个类型是否实现接口进行检查，这里举几个例子来演示发生接口类型检查的时机：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">rpcErr</span> <span class="kt">error</span> <span class="p">=</span> <span class="nf">NewRPCError</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="s">&#34;unknown err&#34;</span><span class="p">)</span> <span class="c1">// typecheck1
</span><span class="c1"></span>	<span class="nx">err</span> <span class="o">:=</span> <span class="nf">AsErr</span><span class="p">(</span><span class="nx">rpcErr</span><span class="p">)</span> <span class="c1">// typecheck2
</span><span class="c1"></span>	<span class="nb">println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewRPCError</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">RPCError</span><span class="p">{</span> <span class="c1">// typecheck3
</span><span class="c1"></span>		<span class="nx">Code</span><span class="p">:</span>    <span class="nx">code</span><span class="p">,</span>
		<span class="nx">Message</span><span class="p">:</span> <span class="nx">msg</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">AsErr</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Go 语言在编译期间对代码进行类型检查，上述代码总共触发了三次类型检查：</p>
<ol>
<li>将<code>*RPCError</code> 类型的变量赋值给 error 类型的变量 rpcErr；</li>
<li>将<code>*RPCError</code> 类型的变量 rpcErr 传递给签名中参数类型为 error 的 AsErr 函数；</li>
<li>将 <code>*RPCError</code> 类型的变量从函数签名的返回值类型为 error 的 NewRPCError 函数中返回；</li>
</ol>
<p>从类型检查的过程来看，编译器仅在需要时才检查类型，类型实现接口时只需要实现接口中的全部方法，不需要像 Java 等编程语言中一样显式声明。</p>
<h4 id="类型">类型</h4>
<p>接口也是 Go 语言中的一种类型，它能够出现在变量的定义、函数的入参和返回值中并对它们进行约束，不过 Go 语言中有两种略微不同的接口，一种是带有一组方法的接口，另一种是不带任何方法的 <code>interface{}</code>：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210628115031.png" alt=""></p>
<p>Go 语言使用 <code>runtime.iface</code> 表示第一种接口，使用 <code>runtime.eface</code> 表示第二种不包含任何方法的接口 <code>interface{}</code>，两种接口虽然都使用 interface 声明，但是由于后者在 Go 语言中很常见，所以在实现时使用了特殊的类型。</p>
<p>需要注意的是，与 C 语言中的 <code>void *</code> 不同，<code>interface{}</code> 类型不是任意类型。如果我们将类型转换成了 <code>interface{}</code> 类型，变量在运行期间的类型也会发生变化，获取变量类型时会得到 <code>interface{}</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="nx">Test</span> <span class="kd">struct</span><span class="p">{}</span>
	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">Test</span><span class="p">{}</span>
	<span class="nf">Print</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Print</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nb">println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述函数不接受任意类型的参数，只接受 <code>interface{}</code> 类型的值，在调用 Print 函数时会对参数 v 进行类型转换，将原来的 Test 类型转换成 <code>interface{}</code> 类型，本节会在后面介绍类型转换的实现原理。</p>
<h4 id="指针和接口">指针和接口</h4>
<p>在 Go 语言中同时使用指针和接口时会发生一些让人困惑的问题，接口在定义一组方法时没有对实现的接收者做限制，所以我们会看到某个类型实现接口的两种方式：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210628115619.png" alt=""></p>
<p>这是因为结构体类型和指针类型是不同的，就像我们不能向一个接受指针的函数传递结构体一样，在实现接口时这两种类型也不能划等号。虽然两种类型不同，但是上图中的两种实现不可以同时存在，Go 语言的编译器会在结构体类型和指针类型都实现一个方法时报错 “method redeclared”。</p>
<p>对 Cat 结构体来说，它在实现接口时可以选择接受者的类型，即结构体或者结构体指针，在初始化时也可以初始化成结构体或者指针。下面的代码总结了如何使用结构体、结构体指针实现接口，以及如何使用结构体、结构体指针初始化变量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Cat</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Duck</span> <span class="kd">interface</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span>  <span class="nx">Cat</span><span class="p">)</span> <span class="nx">Quack</span> <span class="p">{}</span>  <span class="c1">// 使用结构体实现接口
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cat</span><span class="p">)</span> <span class="nx">Quack</span> <span class="p">{}</span>  <span class="c1">// 使用结构体指针实现接口
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">d</span> <span class="nx">Duck</span> <span class="p">=</span> <span class="nx">Cat</span><span class="p">{}</span>      <span class="c1">// 使用结构体初始化变量
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">d</span> <span class="nx">Duck</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Cat</span><span class="p">{}</span>     <span class="c1">// 使用结构体指针初始化变量
</span></code></pre></td></tr></table>
</div>
</div><p>实现接口的类型和初始化返回的类型两个维度共组成了四种情况，然而这四种情况不是都能通过编译器的检查：</p>
<table>
<thead>
<tr>
<th></th>
<th>结构体实现接口</th>
<th>结构体指针实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>结构体初始化变量</td>
<td>通过</td>
<td>不通过</td>
</tr>
<tr>
<td>结构体指针初始化变量</td>
<td>通过</td>
<td>通过</td>
</tr>
</tbody>
</table>
<p>四种中只有使用指针实现接口，使用结构体初始化变量无法通过编译，其他的三种情况都可以正常执行。当实现接口的类型和初始化变量时返回的类型时相同时，代码通过编译是理所应当的：</p>
<ul>
<li>方法接受者和初始化类型都是结构体；</li>
<li>方法接受者和初始化类型都是结构体指针；</li>
</ul>
<p>而剩下的两种方式为什么一种能够通过编译，另一种无法通过编译呢？我们先来看一下能够通过编译的情况，即方法的接受者是结构体，而初始化的变量是结构体指针：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Cat</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">Cat</span><span class="p">)</span> <span class="nf">Quack</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;meow&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">c</span> <span class="nx">Duck</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Cat</span><span class="p">{}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Quack</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>作为指针的 <code>&amp;Cat{}</code> 变量能够隐式地获取到指向的结构体，所以能在结构体上调用 <code>Walk</code> 和 <code>Quack</code> 方法。我们可以将这里的调用理解成 C 语言中的 <code>d-&gt;Walk()</code> 和 <code>d-&gt;Speak()</code>，它们都会先获取指向的结构体再执行对应的方法。</p>
<p>但是如果我们将上述代码中方法的接受者和初始化的类型进行交换，代码就无法通过编译了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Duck</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Quack</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Cat</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cat</span><span class="p">)</span> <span class="nf">Quack</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;meow&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">c</span> <span class="nx">Duck</span> <span class="p">=</span> <span class="nx">Cat</span><span class="p">{}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Quack</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">build</span> <span class="n">interface.go</span>
<span class="n">./interface.go</span><span class="o">:</span><span class="m">20</span><span class="o">:</span><span class="m">6</span><span class="o">:</span> <span class="n">cannot</span> <span class="n">use</span> <span class="n">Cat</span> <span class="nf">literal </span><span class="p">(</span><span class="n">type</span> <span class="n">Cat</span><span class="p">)</span> <span class="n">as</span> <span class="n">type</span> <span class="n">Duck</span> <span class="n">in</span> <span class="n">assignment</span><span class="o">:</span>
	<span class="n">Cat</span> <span class="n">does</span> <span class="n">not</span> <span class="n">implement</span> <span class="nf">Duck </span><span class="p">(</span><span class="n">Quack</span> <span class="n">method</span> <span class="n">has</span> <span class="n">pointer</span> <span class="n">receiver</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>编译器会提醒我们：Cat 类型没有实现 Duck 接口，Quack 方法的接受者是指针。这两个报错对于刚刚接触 Go 语言的开发者比较难以理解，如果我们想要搞清楚这个问题，首先要知道 Go 语言在传递参数时都是传值的。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210628124124.png" alt=""></p>
<p>如上图所示，无论上述代码中初始化的变量 c 是 <code>Cat{}</code> 还是 <code>&amp;Cat{}</code>，使用 <code>c.Quack()</code> 调用方法时都会发生值拷贝：</p>
<ul>
<li>如上图左侧，对于 <code>&amp;Cat{}</code> 来说，这意味着拷贝一个新的 <code>&amp;Cat{}</code> 指针，这个指针与原来的指针指向一个相同并且唯一的结构体，所以编译器可以隐式的对变量解引用（dereference）获取指针指向的结构体；</li>
<li>如上图右侧，对于 <code>Cat{}</code> 来说，这意味着 Quack 方法会接受一个全新的 <code>Cat{}</code>，因为方法的参数是 <code>*Cat</code>，编译器不会无中生有创建一个新的指针；即使编译器可以创建新指针，这个指针指向的也不是最初调用该方法的结构体；</li>
</ul>
<p>上面的分析解释了指针类型的现象，当我们使用指针实现接口时，只有指针类型的变量才会实现该接口；当我们使用结构体实现接口时，指针类型和结构体类型都会实现该接口。当然这并不意味着我们应该一律使用结构体实现接口，这个问题在实际工程中也没那么重要，在这里我们只想解释现象背后的原因。</p>
<h4 id="nil-和-non-nil">nil 和 non-nil</h4>
<p>我们可以通过一个例子理解Go 语言的接口类型不是任意类型这一句话，下面的代码在 main 函数中初始化了一个 <code>*TestStruct</code> 类型的变量，由于指针的零值是 nil，所以变量 s 在初始化之后也是 nil：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">type</span> <span class="nx">TestStruct</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="nf">NilOrNot</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">v</span> <span class="o">==</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">TestStruct</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>      <span class="c1">//=&gt; true
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">NilOrNot</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>   <span class="c1">//=&gt; false
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">run</span> <span class="n">main.go</span>
<span class="n">true</span>
<span class="n">false</span>
</code></pre></td></tr></table>
</div>
</div><p>我们简单总结一下上述代码执行的结果：</p>
<ul>
<li>将上述变量与 nil 比较会返回 true；</li>
<li>将上述变量传入 NilOrNot 方法并与 nil 比较会返回 false；</li>
</ul>
<p>出现上述现象的原因是 —— 调用 NilOrNot 函数时发生了隐式的类型转换，除了向方法传入参数之外，变量的赋值也会触发隐式类型转换。在类型转换时，<code>*TestStruct</code> 类型会转换成 <code>interface{}</code>类型，转换后的变量不仅包含转换前的变量，还包含变量的类型信息 <code>TestStruct</code>，所以转换后的变量与 <code>nil</code> 不相等。</p>
<h3 id="数据结构">数据结构</h3>
<p>相信各位读者已经对 Go 语言的接口有了一些的了解，接下来我们从源代码和汇编指令层面介绍接口的底层数据结构。</p>
<p>Go 语言根据接口类型是否包含一组方法将接口类型分成了两类：</p>
<ul>
<li>使用 runtime.iface 结构体表示包含方法的接口</li>
<li>使用 runtime.eface 结构体表示不包含任何方法的 <code>interface{}</code> 类型；</li>
</ul>
<p>runtime.eface 结构体在 Go 语言中的定义是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">eface</span> <span class="kd">struct</span> <span class="p">{</span> <span class="c1">// 16 字节
</span><span class="c1"></span>	<span class="nx">_type</span> <span class="o">*</span><span class="nx">_type</span>
	<span class="nx">data</span>  <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>由于 <code>interface{}</code> 类型不包含任何方法，所以它的结构也相对来说比较简单，只包含指向底层数据和类型的两个指针。从上述结构我们也能推断出 — Go 语言的任意类型都可以转换成 <code>interface{}</code>。</p>
<p>另一个用于表示接口的结构体是 <code>runtime.iface</code>，这个结构体中有指向原始数据的指针 data，不过更重要的是 <code>runtime.itab</code> 类型的 tab 字段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">iface</span> <span class="kd">struct</span> <span class="p">{</span> <span class="c1">// 16 字节
</span><span class="c1"></span>	<span class="nx">tab</span>  <span class="o">*</span><span class="nx">itab</span>
	<span class="nx">data</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>接下来我们将详细分析 Go 语言接口中的这两个类型，即 <code>runtime._type</code> 和 <code>runtime.itab</code>。</p>
<h4 id="_type">_type</h4>
<p><code>runtime._type</code> 是 Go 语言类型的运行时表示。下面是运行时包中的结构体，其中包含了很多类型的元信息，例如：类型的大小、哈希、对齐以及种类等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">_type</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">size</span>       <span class="kt">uintptr</span>
	<span class="nx">ptrdata</span>    <span class="kt">uintptr</span>
	<span class="nx">hash</span>       <span class="kt">uint32</span>
	<span class="nx">tflag</span>      <span class="nx">tflag</span>
	<span class="nx">align</span>      <span class="kt">uint8</span>
	<span class="nx">fieldAlign</span> <span class="kt">uint8</span>
	<span class="nx">kind</span>       <span class="kt">uint8</span>
	<span class="nx">equal</span>      <span class="kd">func</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span>
	<span class="nx">gcdata</span>     <span class="o">*</span><span class="kt">byte</span>
	<span class="nx">str</span>        <span class="nx">nameOff</span>
	<span class="nx">ptrToThis</span>  <span class="nx">typeOff</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>size 字段存储了类型占用的内存空间，为内存空间的分配提供信息；</li>
<li>hash 字段能够帮助我们快速确定类型是否相等；</li>
<li>equal 字段用于判断当前类型的多个对象是否相等，该字段是为了减少 Go 语言二进制包大小从 typeAlg 结构体中迁移过来的；</li>
</ul>
<p>我们只需要对 runtime._type 结构体中的字段有一个大体的概念，不需要详细理解所有字段的作用和意义。</p>
<h4 id="itab">itab</h4>
<p><code>runtime.itab</code> 结构体是接口类型的核心组成部分，每一个 <code>runtime.itab</code> 都占 32 字节，我们可以将其看成接口类型和具体类型的组合，它们分别用 inter 和 _type 两个字段表示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// layout of Itab known to compilers
</span><span class="c1">// allocated in non-garbage-collected memory
</span><span class="c1">// Needs to be in sync with
</span><span class="c1">// ../cmd/compile/internal/gc/reflect.go:/^func.dumptabs.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">itab</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">inter</span> <span class="o">*</span><span class="nx">interfacetype</span>
	<span class="nx">_type</span> <span class="o">*</span><span class="nx">_type</span>
	<span class="nx">hash</span>  <span class="kt">uint32</span> <span class="c1">// copy of _type.hash. Used for type switches.
</span><span class="c1"></span>	<span class="nx">_</span>     <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">byte</span>
	<span class="nx">fun</span>   <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="kt">uintptr</span> <span class="c1">// variable sized. fun[0]==0 means _type does not implement inter.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>除了 inter 和 _type 两个用于表示类型的字段之外，上述结构体中的另外两个字段也有自己的作用：</p>
<ul>
<li>hash 是对 <code>_type.hash</code> 的拷贝，当我们想将 interface 类型转换成具体类型时，可以使用该字段快速判断目标类型和具体类型 <code>runtime._type</code> 是否一致；</li>
<li>fun 是一个动态大小的数组，它是一个用于动态派发的虚函数表，存储了一组函数指针。虽然该变量被声明成大小固定的数组，但是在使用时会通过原始指针获取其中的数据，所以 fun 数组中保存的元素数量是不确定的；</li>
</ul>
<p>我们会在类型断言中介绍 hash 字段的使用，在动态派发一节中介绍 fun 数组中存储的函数指针是如何被使用的。</p>
<h3 id="类型转换">类型转换</h3>
<p>既然我们已经了解了接口在运行时的数据结构，接下来会通过几个例子来深入理解接口类型是如何初始化和传递的，本节会介绍在实现接口时使用指针类型和结构体类型的区别。这两种不同的接口实现方式会导致 Go 语言编译器生成不同的汇编代码，进而影响最终的处理过程。</p>
<h4 id="指针类型">指针类型</h4>
<p>首先回到这一节开头提到的 Duck 接口的例子，我们使用 <code>//go:noinline</code>指令禁止 Quack 方法的内联编译：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">type</span> <span class="nx">Duck</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Quack</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Cat</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">//go:noinline
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cat</span><span class="p">)</span> <span class="nf">Quack</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Name</span> <span class="o">+</span> <span class="s">&#34; meow&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">c</span> <span class="nx">Duck</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Cat</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;draven&#34;</span><span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Quack</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们使用编译器将上述代码编译成汇编语言、删掉一些对理解接口原理无用的指令并保留与赋值语句 <code>var c Duck = &amp;Cat{Name: &quot;draven&quot;}</code> 相关的代码，这里将生成的汇编指令拆分成三部分分析：</p>
<ol>
<li>结构体 Cat 的初始化；</li>
<li>赋值触发的类型转换过程；</li>
<li>调用接口的方法 Quack()；</li>
</ol>
<p>我们先来分析结构体 Cat 的初始化过程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">LEAQ</span>	<span class="n">type.</span><span class="s">&#34;&#34;</span><span class="nf">.Cat</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">AX</span>                <span class="p">;;</span> <span class="n">AX</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">type.</span><span class="s">&#34;&#34;</span><span class="n">.Cat</span>
<span class="n">MOVQ</span>	<span class="n">AX</span><span class="p">,</span> <span class="p">(</span><span class="n">SP</span><span class="p">)</span>                           <span class="p">;;</span> <span class="n">SP</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">type.</span><span class="s">&#34;&#34;</span><span class="n">.Cat</span>
<span class="n">CALL</span>	<span class="nf">runtime.newobject</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>              <span class="p">;;</span> <span class="n">SP</span> <span class="o">+</span> <span class="m">8</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Cat</span><span class="p">{}</span>
<span class="n">MOVQ</span>	<span class="m">8</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">DI</span>                          <span class="p">;;</span> <span class="n">DI</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Cat</span><span class="p">{}</span>
<span class="n">MOVQ</span>	<span class="o">$</span><span class="m">6</span><span class="p">,</span> <span class="m">8</span><span class="p">(</span><span class="n">DI</span><span class="p">)</span>                          <span class="p">;;</span> <span class="nf">StringHeader</span><span class="p">(</span><span class="n">DI.Name</span><span class="p">)</span><span class="n">.Len</span> <span class="o">=</span> <span class="m">6</span>
<span class="n">LEAQ</span>	<span class="n">go.string.</span><span class="s">&#34;draven&#34;</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">AX</span>         <span class="p">;;</span> <span class="n">AX</span> <span class="o">=</span> <span class="o">&amp;</span><span class="s">&#34;draven&#34;</span>
<span class="n">MOVQ</span>	<span class="n">AX</span><span class="p">,</span> <span class="p">(</span><span class="n">DI</span><span class="p">)</span>                           <span class="p">;;</span> <span class="nf">StringHeader</span><span class="p">(</span><span class="n">DI.Name</span><span class="p">)</span><span class="n">.Data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="s">&#34;draven&#34;</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>获取 Cat 结构体类型指针并将其作为参数放到栈上；</li>
<li>通过 CALL 指定调用 <code>runtime.newobject</code> 函数，这个函数会以 Cat 结构体类型指针作为入参，分配一片新的内存空间并将指向这片内存空间的指针返回到 SP+8 上；</li>
<li>SP+8 现在存储了一个指向 Cat 结构体的指针，我们将栈上的指针拷贝到寄存器 DI 上方便操作；</li>
<li>由于 Cat 中只包含一个字符串类型的 Name 变量，所以在这里会分别将字符串地址 <code>&amp;&quot;draven&quot;</code> 和字符串长度 6 设置到结构体上，最后三行汇编指令等价于 <code>cat.Name = &quot;draven&quot;</code>；</li>
</ol>
<p>字符串在运行时的表示是指针加上字符串长度，在前面的章节字符串已经介绍过它的底层表示和实现原理，但是这里要看一下初始化之后的 Cat 结构体在内存中的表示是什么样的：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210628213631.png" alt=""></p>
<p>因为 Cat 结构体的定义中只包含一个字符串，而字符串在 Go 语言中总共占 16 字节，所以每一个 Cat 结构体的大小都是 16 字节。初始化 Cat 结构体之后就进入了将 *Cat 转换成 Duck 类型的过程了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">LEAQ</span>	<span class="n">go.itab.</span><span class="o">*</span><span class="s">&#34;&#34;</span><span class="n">.Cat</span><span class="p">,</span><span class="s">&#34;&#34;</span><span class="nf">.Duck</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">AX</span>    <span class="p">;;</span> <span class="n">AX</span> <span class="o">=*</span><span class="nf">itab</span><span class="p">(</span><span class="n">go.itab.</span><span class="o">*</span><span class="s">&#34;&#34;</span><span class="n">.Cat</span><span class="p">,</span><span class="s">&#34;&#34;</span><span class="n">.Duck</span><span class="p">)</span>
<span class="n">MOVQ</span>	<span class="n">DI</span><span class="p">,</span> <span class="p">(</span><span class="n">SP</span><span class="p">)</span>                           <span class="p">;;</span> <span class="n">SP</span> <span class="o">=</span> <span class="n">AX</span>
</code></pre></td></tr></table>
</div>
</div><p>类型转换的过程比较简单，Duck 作为一个包含方法的接口，它在底层使用 <code>runtime.iface</code> 结构体表示。<code>runtime.iface</code> 结构体包含两个字段，其中一个是指向数据的指针，另一个是表示接口和结构体关系的 tab 字段，我们已经通过上一段代码 SP+8 初始化了 Cat 结构体指针，这段代码只是将编译期间生成的 <code>runtime.itab</code> 结构体指针复制到 SP 上：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210628213925.png" alt=""></p>
<p>到这里，我们会发现 <code>SP ~ SP+16</code> 共同组成了 <code>runtime.iface</code> 结构体，而栈上的这个 <code>runtime.iface</code> 也是 Quack 方法的第一个入参。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">CALL</span>    <span class="s">&#34;&#34;</span><span class="n">.(</span><span class="o">*</span><span class="n">Cat</span><span class="p">)</span><span class="nf">.Quack</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>                <span class="p">;;</span> <span class="nf">SP.Quack</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码会直接通过 CALL 指令完成方法的调用，细心的读者可能会发现一个问题 —— 为什么在代码中我们调用的是 <code>Duck.Quack</code> 但生成的汇编是<code>*Cat.Quack</code> 呢？Go 语言的编译器会在编译期间将一些需要动态派发的方法调用改写成对目标方法的直接调用，以减少性能的额外开销。如果在这里禁用编译器优化，就会看到动态派发的过程，我们会在后面分析接口的动态派发以及性能上的额外开销。</p>
<h4 id="结构体类型">结构体类型</h4>
<p>在这里我们继续修改上一节中的代码，使用结构体类型实现 Duck 接口并初始化结构体类型的变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">type</span> <span class="nx">Duck</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Quack</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Cat</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">//go:noinline
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">Cat</span><span class="p">)</span> <span class="nf">Quack</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Name</span> <span class="o">+</span> <span class="s">&#34; meow&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">c</span> <span class="nx">Duck</span> <span class="p">=</span> <span class="nx">Cat</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;draven&#34;</span><span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Quack</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果我们在初始化变量时使用指针类型 <code>&amp;Cat{Name: &quot;draven&quot;}</code> 也能够通过编译，不过生成的汇编代码和上一节中的几乎完全相同，所以这里也就不分析这个情况了。</p>
<p>编译上述代码会得到如下所示的汇编指令，需要注意的是为了代码更容易理解和分析，这里的汇编指令依然经过了删减，不过不影响具体的执行过程。与上一节一样，我们将汇编代码的执行过程分成以下几个部分：</p>
<ol>
<li>初始化 Cat 结构体；</li>
<li>完成从 Cat 到 Duck 接口的类型转换；</li>
<li>调用接口的 Quack 方法；
我们先来看一下上述汇编代码中用于初始化 Cat 结构体的部分：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">XORPS</span>   <span class="n">X0</span><span class="p">,</span> <span class="n">X0</span>                          <span class="p">;;</span> <span class="n">X0</span> <span class="o">=</span> <span class="m">0</span>
<span class="n">MOVUPS</span>  <span class="n">X0</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="n">..autotmp_1</span><span class="m">+32</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>        <span class="p">;;</span> <span class="nf">StringHeader</span><span class="p">(</span><span class="n">SP</span><span class="m">+32</span><span class="p">)</span><span class="n">.Data</span> <span class="o">=</span> <span class="m">0</span>
<span class="n">LEAQ</span>    <span class="n">go.string.</span><span class="s">&#34;draven&#34;</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">AX</span>      <span class="p">;;</span> <span class="n">AX</span> <span class="o">=</span> <span class="o">&amp;</span><span class="s">&#34;draven&#34;</span>
<span class="n">MOVQ</span>    <span class="n">AX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="n">..autotmp_1</span><span class="m">+32</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>        <span class="p">;;</span> <span class="nf">StringHeader</span><span class="p">(</span><span class="n">SP</span><span class="m">+32</span><span class="p">)</span><span class="n">.Data</span> <span class="o">=</span> <span class="n">AX</span>
<span class="n">MOVQ</span>    <span class="o">$</span><span class="m">6</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="n">..autotmp_1</span><span class="m">+40</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>        <span class="p">;;</span> <span class="nf">StringHeader</span><span class="p">(</span><span class="n">SP</span><span class="m">+32</span><span class="p">)</span><span class="n">.Len</span> <span class="o">=</span> <span class="m">6</span>
</code></pre></td></tr></table>
</div>
</div><p>这段汇编指令会在栈上初始化 Cat 结构体，而上一节的代码在堆上申请了 16 字节的内存空间，栈上只有一个指向 Cat 的指针。</p>
<p>初始化结构体后会进入类型转换的阶段，编译器会将 go.itab.&quot;&quot;.Cat,&quot;&quot;.Duck 的地址和指向 Cat 结构体的指针作为参数一并传入 runtime.convT2I 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">LEAQ</span>	<span class="n">go.itab.</span><span class="s">&#34;&#34;</span><span class="n">.Cat</span><span class="p">,</span><span class="s">&#34;&#34;</span><span class="nf">.Duck</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">AX</span>     <span class="p">;;</span> <span class="n">AX</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">go.itab.</span><span class="s">&#34;&#34;</span><span class="n">.Cat</span><span class="p">,</span><span class="s">&#34;&#34;</span><span class="n">.Duck</span><span class="p">)</span>
<span class="n">MOVQ</span>	<span class="n">AX</span><span class="p">,</span> <span class="p">(</span><span class="n">SP</span><span class="p">)</span>                           <span class="p">;;</span> <span class="n">SP</span> <span class="o">=</span> <span class="n">AX</span>
<span class="n">LEAQ</span>	<span class="s">&#34;&#34;</span><span class="n">..autotmp_1</span><span class="m">+32</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">AX</span>           <span class="p">;;</span> <span class="n">AX</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">SP</span><span class="m">+32</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Cat</span><span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">&#34;draven&#34;</span><span class="p">}</span>
<span class="n">MOVQ</span>	<span class="n">AX</span><span class="p">,</span> <span class="m">8</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>                          <span class="p">;;</span> <span class="n">SP</span> <span class="o">+</span> <span class="m">8</span> <span class="o">=</span> <span class="n">AX</span>
<span class="n">CALL</span>	<span class="nf">runtime.convT2I</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>                <span class="p">;;</span> <span class="nf">runtime.convT2I</span><span class="p">(</span><span class="n">SP</span><span class="p">,</span> <span class="n">SP</span><span class="m">+8</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这个函数会获取 runtime.itab 中存储的类型，根据类型的大小申请一片内存空间并将 elem 指针中的内容拷贝到目标的内存中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">convT2I</span><span class="p">(</span><span class="nx">tab</span> <span class="o">*</span><span class="nx">itab</span><span class="p">,</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">i</span> <span class="nx">iface</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">tab</span><span class="p">.</span><span class="nx">_type</span>
	<span class="nx">x</span> <span class="o">:=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">elem</span><span class="p">)</span>
	<span class="nx">i</span><span class="p">.</span><span class="nx">tab</span> <span class="p">=</span> <span class="nx">tab</span>
	<span class="nx">i</span><span class="p">.</span><span class="nx">data</span> <span class="p">=</span> <span class="nx">x</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime.convT2I 会返回一个 runtime.iface，其中包含 runtime.itab 指针和 Cat 变量。当前函数返回之后，main 函数的栈上会包含以下数据：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210628214559.png" alt=""></p>
<p>SP 和 SP+8 中存储的 runtime.itab 和 Cat 指针是 runtime.convT2I 函数的入参，这个函数的返回值位于 SP+16，是一个占 16 字节内存空间的 runtime.iface 结构体，SP+32 存储的是在栈上的 Cat 结构体，它会在 runtime.convT2I 执行的过程中拷贝到堆上。</p>
<p>在最后，我们会通过以下的指令调用 Cat 实现的接口方法 Quack()：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">MOVQ</span>	<span class="m">16</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">AX</span> <span class="p">;;</span> <span class="n">AX</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">go.itab.</span><span class="s">&#34;&#34;</span><span class="n">.Cat</span><span class="p">,</span><span class="s">&#34;&#34;</span><span class="n">.Duck</span><span class="p">)</span>
<span class="n">MOVQ</span>	<span class="m">24</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">CX</span> <span class="p">;;</span> <span class="n">CX</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Cat</span><span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">&#34;draven&#34;</span><span class="p">}</span>
<span class="n">MOVQ</span>	<span class="m">24</span><span class="p">(</span><span class="n">AX</span><span class="p">),</span> <span class="n">AX</span> <span class="p">;;</span> <span class="n">AX</span> <span class="o">=</span> <span class="n">AX.fun[0]</span> <span class="o">=</span> <span class="n">Cat.Quack</span>
<span class="n">MOVQ</span>	<span class="n">CX</span><span class="p">,</span> <span class="p">(</span><span class="n">SP</span><span class="p">)</span>   <span class="p">;;</span> <span class="n">SP</span> <span class="o">=</span> <span class="n">CX</span>
<span class="n">CALL</span>	<span class="n">AX</span>         <span class="p">;;</span> <span class="nf">CX.Quack</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>这几个汇编指令还是非常好理解的，<code>MOVQ 24(AX), AX</code> 是最关键的指令，它从 <code>runtime.itab</code> 结构体中取出 Cat.Quack 方法指针作为 CALL 指令调用时的参数。接口变量的第 24 字节是 itab.fun 数组开始的位置，由于 Duck 接口只包含一个方法，所以 <code>itab.fun[0]</code> 中存储的就是指向 Quack 方法的指针了。</p>
<h3 id="类型断言">类型断言</h3>
<p>上一节介绍是如何把具体类型转换成接口类型，而这一节介绍的是如何将一个接口类型转换成具体类型。本节会根据接口中是否存在方法分两种情况介绍类型断言的执行过程。</p>
<h4 id="非空接口">非空接口</h4>
<p>首先分析接口中包含方法的情况，Duck 接口是一个非空的接口，我们来分析从 Duck 转换回 Cat 结构体的过程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">c</span> <span class="nx">Duck</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Cat</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;draven&#34;</span><span class="p">}</span>
	<span class="k">switch</span> <span class="nx">c</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">*</span><span class="nx">Cat</span><span class="p">:</span>
		<span class="nx">cat</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.(</span><span class="o">*</span><span class="nx">Cat</span><span class="p">)</span>
		<span class="nx">cat</span><span class="p">.</span><span class="nf">Quack</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们将编译得到的汇编指令分成两部分分析，第一部分是变量的初始化，第二部分是类型断言，第一部分的代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="m">00000</span> <span class="n">TEXT</span>	<span class="s">&#34;&#34;</span><span class="nf">.main</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">ABIInternal</span><span class="p">,</span> <span class="o">$</span><span class="m">32-0</span>
<span class="kc">...</span>
<span class="m">00029</span> <span class="n">XORPS</span>	<span class="n">X0</span><span class="p">,</span> <span class="n">X0</span>
<span class="m">00032</span> <span class="n">MOVUPS</span>	<span class="n">X0</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="n">..autotmp_4</span><span class="m">+8</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
<span class="m">00037</span> <span class="n">LEAQ</span>	<span class="n">go.string.</span><span class="s">&#34;draven&#34;</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">AX</span>
<span class="m">00044</span> <span class="n">MOVQ</span>	<span class="n">AX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="n">..autotmp_4</span><span class="m">+8</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
<span class="m">00049</span> <span class="n">MOVQ</span>	<span class="o">$</span><span class="m">6</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="n">..autotmp_4</span><span class="m">+16</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>0037 ~ 0049 三个指令初始化了 Duck 变量，Cat 结构体初始化在 SP+8 ~ SP+24 上。因为 Go 语言的编译器做了一些优化，所以代码中没有runtime.iface 的构建过程，不过对于这一节要介绍的类型断言和转换没有太多的影响。下面进入类型转换的部分：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="m">00058</span> <span class="n">CMPL</span>  <span class="n">go.itab.</span><span class="o">*</span><span class="s">&#34;&#34;</span><span class="n">.Cat</span><span class="p">,</span><span class="s">&#34;&#34;</span><span class="n">.Duck</span><span class="m">+16</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="o">$</span><span class="m">593696792</span>
                                        <span class="p">;;</span> <span class="nf">if </span><span class="p">(</span><span class="n">c.tab.hash</span> <span class="o">!=</span> <span class="m">593696792</span><span class="p">)</span> <span class="p">{</span>
<span class="m">00068</span> <span class="n">JEQ</span>   <span class="m">80</span>                          <span class="p">;;</span>
<span class="m">00070</span> <span class="n">MOVQ</span>  <span class="m">24</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">BP</span>                  <span class="p">;;</span>      <span class="n">BP</span> <span class="o">=</span> <span class="n">SP</span><span class="m">+24</span>
<span class="m">00075</span> <span class="n">ADDQ</span>  <span class="o">$</span><span class="m">32</span><span class="p">,</span> <span class="n">SP</span>                     <span class="p">;;</span>      <span class="n">SP</span> <span class="o">+=</span> <span class="m">32</span>
<span class="m">00079</span> <span class="n">RET</span>                               <span class="p">;;</span>      <span class="n">return</span>
                                        <span class="p">;;</span> <span class="p">}</span> <span class="n">else</span> <span class="p">{</span>
<span class="m">00080</span> <span class="n">LEAQ</span>  <span class="s">&#34;&#34;</span><span class="n">..autotmp_4</span><span class="m">+8</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">AX</span>     <span class="p">;;</span>      <span class="n">AX</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Cat</span><span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">&#34;draven&#34;</span><span class="p">}</span>
<span class="m">00085</span> <span class="n">MOVQ</span>  <span class="n">AX</span><span class="p">,</span> <span class="p">(</span><span class="n">SP</span><span class="p">)</span>                    <span class="p">;;</span>      <span class="n">SP</span> <span class="o">=</span> <span class="n">AX</span>
<span class="m">00089</span> <span class="n">CALL</span>  <span class="s">&#34;&#34;</span><span class="n">.(</span><span class="o">*</span><span class="n">Cat</span><span class="p">)</span><span class="nf">.Quack</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>         <span class="p">;;</span>      <span class="nf">SP.Quack</span><span class="p">()</span>
<span class="m">00094</span> <span class="n">JMP</span>   <span class="m">70</span>                          <span class="p">;;</span>      <span class="kc">...</span>
                                        <span class="p">;;</span>      <span class="n">BP</span> <span class="o">=</span> <span class="n">SP</span><span class="m">+24</span>
                                        <span class="p">;;</span>      <span class="n">SP</span> <span class="o">+=</span> <span class="m">32</span>
                                        <span class="p">;;</span>      <span class="n">return</span>
                                        <span class="p">;;</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>switch语句生成的汇编指令会将目标类型的 hash 与接口变量中的 itab.hash 进行比较：</p>
<ul>
<li>如果两者相等意味着变量的具体类型是 Cat，我们会跳转到 0080 所在的分支完成类型转换。
<ol>
<li>获取 SP+8 存储的 Cat 结构体指针；</li>
<li>将结构体指针拷贝到栈顶；</li>
<li>调用 Quack 方法；</li>
<li>恢复函数的栈并返回；</li>
</ol>
</li>
<li>如果接口中存在的具体类型不是 Cat，就会直接恢复栈指针并返回到调用方；</li>
</ul>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210629111743.png" alt=""></p>
<p>上图展示了调用 Quack 方法时的堆栈情况，其中 Cat 结构体存储在 SP+8 ~ SP+24 上，Cat 指针存储在栈顶并指向上述结构体。</p>
<h4 id="空接口">空接口</h4>
<p>当我们使用空接口类型 <code>interface{}</code> 进行类型断言时，如果不关闭 Go 语言编译器的优化选项，生成的汇编指令是差不多的。编译器会省略将 Cat 结构体转换成 runtime.eface 的过程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">c</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Cat</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;draven&#34;</span><span class="p">}</span>
	<span class="k">switch</span> <span class="nx">c</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">*</span><span class="nx">Cat</span><span class="p">:</span>
		<span class="nx">cat</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.(</span><span class="o">*</span><span class="nx">Cat</span><span class="p">)</span>
		<span class="nx">cat</span><span class="p">.</span><span class="nf">Quack</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果禁用编译器优化，上述代码会在类型断言时就不是直接获取变量中具体类型的 runtime._type，而是从 eface._type 中获取，汇编指令仍然会使用目标类型的 hash 与变量的类型比较。</p>
<h3 id="动态派发">动态派发</h3>
<p>动态派发（Dynamic dispatch）是在运行期间选择具体多态操作（方法或者函数）执行的过程，它是面向对象语言中的常见特性。Go 语言虽然不是严格意义上的面向对象语言，但是接口的引入为它带来了动态派发这一特性，调用接口类型的方法时，如果编译期间不能确认接口的类型，Go 语言会在运行期间决定具体调用该方法的哪个实现。</p>
<p>在如下所示的代码中，main 函数调用了两次 Quack 方法：</p>
<ol>
<li>第一次以 <code>Duck</code> 接口类型的身份调用，调用时需要经过运行时的动态派发；</li>
<li>第二次以 <code>*Cat</code> 具体类型的身份调用，编译期就会确定调用的函数：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">c</span> <span class="nx">Duck</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Cat</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;draven&#34;</span><span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Quack</span><span class="p">()</span>
	<span class="nx">c</span><span class="p">.(</span><span class="o">*</span><span class="nx">Cat</span><span class="p">).</span><span class="nf">Quack</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>因为编译器优化影响了我们对原始汇编指令的理解，所以需要使用编译参数 -N 关闭编译器优化。如果不指定这个参数，编译器会对代码进行重写，与最初生成的执行过程有一些偏差，例如：</p>
<ul>
<li>因为接口类型中的 tab 参数并没有被使用，所以优化从 Cat 转换到 Duck 的过程；</li>
<li>因为变量的具体类型是确定的，所以删除从 Duck 接口类型转换到 *Cat 具体类型时可能会发生崩溃的分支；</li>
</ul>
<p>在具体分析调用 Quack 方法的两种姿势之前，我们要先了解 Cat 结构体究竟是如何初始化的，以及初始化后的栈上有哪些数据：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">LEAQ</span>	<span class="n">type.</span><span class="s">&#34;&#34;</span><span class="nf">.Cat</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">AX</span>
<span class="n">MOVQ</span>	<span class="n">AX</span><span class="p">,</span> <span class="p">(</span><span class="n">SP</span><span class="p">)</span>
<span class="n">CALL</span>	<span class="nf">runtime.newobject</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>              <span class="p">;;</span> <span class="n">SP</span> <span class="o">+</span> <span class="m">8</span> <span class="o">=</span> <span class="nf">new</span><span class="p">(</span><span class="n">Cat</span><span class="p">)</span>
<span class="n">MOVQ</span>	<span class="m">8</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">DI</span>                          <span class="p">;;</span> <span class="n">DI</span> <span class="o">=</span> <span class="n">SP</span> <span class="o">+</span> <span class="m">8</span>
<span class="n">MOVQ</span>	<span class="n">DI</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="n">..autotmp_2</span><span class="m">+32</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>           <span class="p">;;</span> <span class="n">SP</span> <span class="o">+</span> <span class="m">32</span> <span class="o">=</span> <span class="n">DI</span>
<span class="n">MOVQ</span>	<span class="o">$</span><span class="m">6</span><span class="p">,</span> <span class="m">8</span><span class="p">(</span><span class="n">DI</span><span class="p">)</span>                          <span class="p">;;</span> <span class="nf">StringHeader</span><span class="p">(</span><span class="n">cat</span><span class="p">)</span><span class="n">.Len</span> <span class="o">=</span> <span class="m">6</span>
<span class="n">LEAQ</span>	<span class="n">go.string.</span><span class="s">&#34;draven&#34;</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">AX</span>         <span class="p">;;</span> <span class="n">AX</span> <span class="o">=</span> <span class="o">&amp;</span><span class="s">&#34;draven&#34;</span>
<span class="n">MOVQ</span>	<span class="n">AX</span><span class="p">,</span> <span class="p">(</span><span class="n">DI</span><span class="p">)</span>                           <span class="p">;;</span> <span class="nf">StringHeader</span><span class="p">(</span><span class="n">cat</span><span class="p">)</span><span class="n">.Data</span> <span class="o">=</span> <span class="n">AX</span>
<span class="n">MOVQ</span>	<span class="s">&#34;&#34;</span><span class="n">..autotmp_2</span><span class="m">+32</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">AX</span>           <span class="p">;;</span> <span class="n">AX</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Cat</span><span class="p">{</span><span class="kc">...</span><span class="p">}</span>
<span class="n">MOVQ</span>	<span class="n">AX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="n">..autotmp_1</span><span class="m">+40</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>           <span class="p">;;</span> <span class="n">SP</span> <span class="o">+</span> <span class="m">40</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Cat</span><span class="p">{</span><span class="kc">...</span><span class="p">}</span>
<span class="n">LEAQ</span>	<span class="n">go.itab.</span><span class="o">*</span><span class="s">&#34;&#34;</span><span class="n">.Cat</span><span class="p">,</span><span class="s">&#34;&#34;</span><span class="nf">.Duck</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">CX</span>    <span class="p">;;</span> <span class="n">CX</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">go.itab.</span><span class="o">*</span><span class="s">&#34;&#34;</span><span class="n">.Cat</span><span class="p">,</span><span class="s">&#34;&#34;</span><span class="n">.Duck</span>
<span class="n">MOVQ</span>	<span class="n">CX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="n">.c</span><span class="m">+48</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>                    <span class="p">;;</span> <span class="nf">iface</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="n">.tab</span> <span class="o">=</span> <span class="n">SP</span> <span class="o">+</span> <span class="m">48</span> <span class="o">=</span> <span class="n">CX</span>
<span class="n">MOVQ</span>	<span class="n">AX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="n">.c</span><span class="m">+56</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>                    <span class="p">;;</span> <span class="nf">iface</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="n">.data</span> <span class="o">=</span> <span class="n">SP</span> <span class="o">+</span> <span class="m">56</span> <span class="o">=</span> <span class="n">AX</span>
</code></pre></td></tr></table>
</div>
</div><p>这段代码的初始化过程其实和上两节中的过程没有太多的差别，它先初始化了 Cat 结构体指针，再将 Cat 和 tab 打包成了一个 runtime.iface 类型的结构体，我们直接来看初始化结束后的栈情况：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210629112408.png" alt=""></p>
<ul>
<li>SP 是 Cat 类型，它也是运行时 <code>runtime.newobject</code> 方法的参数；</li>
<li>SP+8 是 <code>runtime.newobject</code> 方法的返回值，即指向堆上的 Cat 结构体的指针；</li>
<li>SP+32、SP+40 是对 SP+8 的拷贝，这两个指针都会指向堆上的 Cat 结构体；</li>
<li>SP+48 ~ SP+64 是接口变量 runtime.iface 结构体，其中包含了 tab 结构体指针和 *Cat 指针；</li>
</ul>
<p>初始化过程结束后，就进入到了动态派发的过程，c.Quack() 语句展开的汇编指令会在运行时确定函数指针。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">MOVQ</span>	<span class="s">&#34;&#34;</span><span class="n">.c</span><span class="m">+48</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">AX</span>                    <span class="p">;;</span> <span class="n">AX</span> <span class="o">=</span> <span class="nf">iface</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="n">.tab</span>
<span class="n">MOVQ</span>	<span class="m">24</span><span class="p">(</span><span class="n">AX</span><span class="p">),</span> <span class="n">AX</span>                         <span class="p">;;</span> <span class="n">AX</span> <span class="o">=</span> <span class="nf">iface</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="n">.tab.fun[0]</span> <span class="o">=</span> <span class="n">Cat.Quack</span>
<span class="n">MOVQ</span>	<span class="s">&#34;&#34;</span><span class="n">.c</span><span class="m">+56</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">CX</span>                    <span class="p">;;</span> <span class="n">CX</span> <span class="o">=</span> <span class="nf">iface</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="n">.data</span>
<span class="n">MOVQ</span>	<span class="n">CX</span><span class="p">,</span> <span class="p">(</span><span class="n">SP</span><span class="p">)</span>                           <span class="p">;;</span> <span class="n">SP</span> <span class="o">=</span> <span class="n">CX</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Cat</span><span class="p">{</span><span class="kc">...</span><span class="p">}</span>
<span class="n">CALL</span>	<span class="n">AX</span>                                 <span class="p">;;</span> <span class="nf">SP.Quack</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>这段代码的执行过程可以分成以下三个步骤：</p>
<ol>
<li>从接口变量中获取保存 <code>Cat.Quack</code> 方法指针的 <code>tab.func[0]</code>；</li>
<li>接口变量在 <code>runtime.iface</code> 中的数据会被拷贝到栈顶；</li>
<li>方法指针会被拷贝到寄存器中并通过汇编指令 CALL 触发：</li>
</ol>
<p>另一个调用 <code>Quack</code> 方法的语句 <code>c.(*Cat).Quack()</code> 生成的汇编指令看起来会有一些复杂，但是代码前半部分都是在做类型转换，将接口类型转换成<code>*Cat</code> 类型，只有最后两行代码才是函数调用相关的指令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">MOVQ</span>	<span class="s">&#34;&#34;</span><span class="n">.c</span><span class="m">+56</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">AX</span>                    <span class="p">;;</span> <span class="n">AX</span> <span class="o">=</span> <span class="nf">iface</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="n">.data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Cat</span><span class="p">{</span><span class="kc">...</span><span class="p">}</span>
<span class="n">MOVQ</span>	<span class="s">&#34;&#34;</span><span class="n">.c</span><span class="m">+48</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">CX</span>                    <span class="p">;;</span> <span class="n">CX</span> <span class="o">=</span> <span class="nf">iface</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="n">.tab</span>
<span class="n">LEAQ</span>	<span class="n">go.itab.</span><span class="o">*</span><span class="s">&#34;&#34;</span><span class="n">.Cat</span><span class="p">,</span><span class="s">&#34;&#34;</span><span class="nf">.Duck</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">DX</span>    <span class="p">;;</span> <span class="n">DX</span> <span class="o">=</span> <span class="o">&amp;&amp;</span><span class="n">go.itab.</span><span class="o">*</span><span class="s">&#34;&#34;</span><span class="n">.Cat</span><span class="p">,</span><span class="s">&#34;&#34;</span><span class="n">.Duck</span>
<span class="n">CMPQ</span>	<span class="n">CX</span><span class="p">,</span> <span class="n">DX</span>                             <span class="p">;;</span> <span class="nf">CMP</span><span class="p">(</span><span class="n">CX</span><span class="p">,</span> <span class="n">DX</span><span class="p">)</span>
<span class="n">JEQ</span>	<span class="m">163</span>
<span class="n">JMP</span>	<span class="m">201</span>
<span class="n">MOVQ</span>	<span class="n">AX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="n">..autotmp_3</span><span class="m">+24</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>           <span class="p">;;</span> <span class="n">SP</span><span class="m">+24</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Cat</span><span class="p">{</span><span class="kc">...</span><span class="p">}</span>
<span class="n">MOVQ</span>	<span class="n">AX</span><span class="p">,</span> <span class="p">(</span><span class="n">SP</span><span class="p">)</span>                           <span class="p">;;</span> <span class="n">SP</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Cat</span><span class="p">{</span><span class="kc">...</span><span class="p">}</span>
<span class="n">CALL</span>	<span class="s">&#34;&#34;</span><span class="n">.(</span><span class="o">*</span><span class="n">Cat</span><span class="p">)</span><span class="nf">.Quack</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>                <span class="p">;;</span> <span class="nf">SP.Quack</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>下面的几行代码只是将 Cat 指针拷贝到了栈顶并调用 Quack 方法。这一次调用的函数指针在编译期就已经确定了，所以运行时就不需要动态查找方法的实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">MOVQ</span>	<span class="s">&#34;&#34;</span><span class="n">.c</span><span class="m">+48</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">AX</span>                    <span class="p">;;</span> <span class="n">AX</span> <span class="o">=</span> <span class="nf">iface</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="n">.tab</span>
<span class="n">MOVQ</span>	<span class="m">24</span><span class="p">(</span><span class="n">AX</span><span class="p">),</span> <span class="n">AX</span>                         <span class="p">;;</span> <span class="n">AX</span> <span class="o">=</span> <span class="nf">iface</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="n">.tab.fun[0]</span> <span class="o">=</span> <span class="n">Cat.Quack</span>
<span class="n">MOVQ</span>	<span class="s">&#34;&#34;</span><span class="n">.c</span><span class="m">+56</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">CX</span>                    <span class="p">;;</span> <span class="n">CX</span> <span class="o">=</span> <span class="nf">iface</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="n">.data</span>
</code></pre></td></tr></table>
</div>
</div><p>两次方法调用对应的汇编指令差异就是动态派发带来的额外开销，这些额外开销在有低延时、高吞吐量需求的服务中是不能被忽视的，我们来详细分析一下产生的额外汇编指令对性能造成的影响。</p>
<h4 id="基准测试">基准测试</h4>
<p>下面代码中的两个方法 BenchmarkDirectCall 和 BenchmarkDynamicDispatch 分别会调用结构体方法和接口方法，在接口上调用方法时会使用动态派发机制，我们以直接调用作为基准分析动态派发带来了多少额外开销：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BenchmarkDirectCall</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Cat</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;draven&#34;</span><span class="p">}</span>
	<span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// MOVQ	AX, &#34;&#34;.c+24(SP)
</span><span class="c1"></span>		<span class="c1">// MOVQ	AX, (SP)
</span><span class="c1"></span>		<span class="c1">// CALL	&#34;&#34;.(*Cat).Quack(SB)
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">Quack</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">BenchmarkDynamicDispatch</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nf">Duck</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Cat</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;draven&#34;</span><span class="p">})</span>
	<span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// MOVQ	&#34;&#34;.d+56(SP), AX
</span><span class="c1"></span>		<span class="c1">// MOVQ	24(AX), AX
</span><span class="c1"></span>		<span class="c1">// MOVQ	&#34;&#34;.d+64(SP), CX
</span><span class="c1"></span>		<span class="c1">// MOVQ	CX, (SP)
</span><span class="c1"></span>		<span class="c1">// CALL	AX
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">Quack</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们直接运行下面的命令，使用 1 个 CPU 运行上述代码，每一个基准测试都会被执行 3 次：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">test</span> <span class="o">-</span><span class="n">gcflags</span><span class="o">=-</span><span class="n">N</span> <span class="o">-</span><span class="n">benchmem</span> <span class="o">-</span><span class="n">test.count</span><span class="o">=</span><span class="m">3</span> <span class="o">-</span><span class="n">test.cpu</span><span class="o">=</span><span class="m">1</span> <span class="o">-</span><span class="n">test.benchtime</span><span class="o">=</span><span class="m">1</span><span class="n">s</span> <span class="o">-</span><span class="n">bench</span><span class="o">=</span><span class="n">.
</span><span class="n">goos</span><span class="o">:</span> <span class="n">darwin</span>
<span class="n">goarch</span><span class="o">:</span> <span class="n">amd64</span>
<span class="n">pkg</span><span class="o">:</span> <span class="n">github.com</span><span class="o">/</span><span class="n">golang</span><span class="o">/</span><span class="n">playground</span>
<span class="n">BenchmarkDirectCall</span>      	<span class="m">500000000</span>	         <span class="m">3.11</span> <span class="n">ns</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">B</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">allocs</span><span class="o">/</span><span class="n">op</span>
<span class="n">BenchmarkDirectCall</span>      	<span class="m">500000000</span>	         <span class="m">2.94</span> <span class="n">ns</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">B</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">allocs</span><span class="o">/</span><span class="n">op</span>
<span class="n">BenchmarkDirectCall</span>      	<span class="m">500000000</span>	         <span class="m">3.04</span> <span class="n">ns</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">B</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">allocs</span><span class="o">/</span><span class="n">op</span>
<span class="n">BenchmarkDynamicDispatch</span> 	<span class="m">500000000</span>	         <span class="m">3.40</span> <span class="n">ns</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">B</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">allocs</span><span class="o">/</span><span class="n">op</span>
<span class="n">BenchmarkDynamicDispatch</span> 	<span class="m">500000000</span>	         <span class="m">3.79</span> <span class="n">ns</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">B</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">allocs</span><span class="o">/</span><span class="n">op</span>
<span class="n">BenchmarkDynamicDispatch</span> 	<span class="m">500000000</span>	         <span class="m">3.55</span> <span class="n">ns</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">B</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">allocs</span><span class="o">/</span><span class="n">op</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>调用结构体方法时，每一次调用需要 ~3.03ns；</li>
<li>使用动态派发时，每一调用需要 ~3.58ns；</li>
</ul>
<p>在关闭编译器优化的情况下，从上面的数据来看，动态派发生成的指令会带来 ~18% 左右的额外性能开销。</p>
<p>这些性能开销在一个复杂的系统中不会带来太多的影响。一个项目不可能只使用动态派发，而且如果我们开启编译器优化后，动态派发的额外开销会降低至 ~5%，这对应用性能的整体影响就更小了，所以与使用接口带来的好处相比，动态派发的额外开销往往可以忽略。</p>
<p>上面的性能测试建立在实现和调用方法的都是结构体指针上，当我们将结构体指针换成结构体又会有比较大的差异：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BenchmarkDirectCall</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">Cat</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;draven&#34;</span><span class="p">}</span>
	<span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// MOVQ	AX, (SP)
</span><span class="c1"></span>		<span class="c1">// MOVQ	$6, 8(SP)
</span><span class="c1"></span>		<span class="c1">// CALL	&#34;&#34;.Cat.Quack(SB)
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">Quack</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">BenchmarkDynamicDispatch</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nf">Duck</span><span class="p">(</span><span class="nx">Cat</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;draven&#34;</span><span class="p">})</span>
	<span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// MOVQ	16(SP), AX
</span><span class="c1"></span>		<span class="c1">// MOVQ	24(SP), CX
</span><span class="c1"></span>		<span class="c1">// MOVQ	AX, &#34;&#34;.d+32(SP)
</span><span class="c1"></span>		<span class="c1">// MOVQ	CX, &#34;&#34;.d+40(SP)
</span><span class="c1"></span>		<span class="c1">// MOVQ	&#34;&#34;.d+32(SP), AX
</span><span class="c1"></span>		<span class="c1">// MOVQ	24(AX), AX
</span><span class="c1"></span>		<span class="c1">// MOVQ	&#34;&#34;.d+40(SP), CX
</span><span class="c1"></span>		<span class="c1">// MOVQ	CX, (SP)
</span><span class="c1"></span>		<span class="c1">// CALL	AX
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">Quack</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当我们重新执行相同的基准测试时，会得到如下所示的结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">test</span> <span class="o">-</span><span class="n">gcflags</span><span class="o">=-</span><span class="n">N</span> <span class="o">-</span><span class="n">benchmem</span> <span class="o">-</span><span class="n">test.count</span><span class="o">=</span><span class="m">3</span> <span class="o">-</span><span class="n">test.cpu</span><span class="o">=</span><span class="m">1</span> <span class="o">-</span><span class="n">test.benchtime</span><span class="o">=</span><span class="m">1</span><span class="n">s</span> <span class="n">.
</span><span class="n">goos</span><span class="o">:</span> <span class="n">darwin</span>
<span class="n">goarch</span><span class="o">:</span> <span class="n">amd64</span>
<span class="n">pkg</span><span class="o">:</span> <span class="n">github.com</span><span class="o">/</span><span class="n">golang</span><span class="o">/</span><span class="n">playground</span>
<span class="n">BenchmarkDirectCall</span>      	<span class="m">500000000</span>	         <span class="m">3.15</span> <span class="n">ns</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">B</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">allocs</span><span class="o">/</span><span class="n">op</span>
<span class="n">BenchmarkDirectCall</span>      	<span class="m">500000000</span>	         <span class="m">3.02</span> <span class="n">ns</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">B</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">allocs</span><span class="o">/</span><span class="n">op</span>
<span class="n">BenchmarkDirectCall</span>      	<span class="m">500000000</span>	         <span class="m">3.09</span> <span class="n">ns</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">B</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">allocs</span><span class="o">/</span><span class="n">op</span>
<span class="n">BenchmarkDynamicDispatch</span> 	<span class="m">200000000</span>	         <span class="m">6.92</span> <span class="n">ns</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">B</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">allocs</span><span class="o">/</span><span class="n">op</span>
<span class="n">BenchmarkDynamicDispatch</span> 	<span class="m">200000000</span>	         <span class="m">6.91</span> <span class="n">ns</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">B</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">allocs</span><span class="o">/</span><span class="n">op</span>
<span class="n">BenchmarkDynamicDispatch</span> 	<span class="m">200000000</span>	         <span class="m">7.10</span> <span class="n">ns</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">B</span><span class="o">/</span><span class="n">op</span>	       <span class="m">0</span> <span class="n">allocs</span><span class="o">/</span><span class="n">op</span>
</code></pre></td></tr></table>
</div>
</div><p>直接调用方法需要消耗时间的平均值和使用指针实现接口时差不多，约为 ~3.09ns，而使用动态派发调用方法却需要 ~6.98ns 相比直接调用额外消耗了 ~125% 的时间，从生成的汇编指令我们也能看出后者的额外开销会高很多。</p>
<table>
<thead>
<tr>
<th></th>
<th>直接调用</th>
<th>动态派发</th>
</tr>
</thead>
<tbody>
<tr>
<td>指针</td>
<td>~3.03ns</td>
<td>~3.58ns</td>
</tr>
<tr>
<td>结构体</td>
<td>~3.09ns</td>
<td>~6.98ns</td>
</tr>
</tbody>
</table>
<p>从上述表格我们可以看到使用结构体实现接口带来的开销会大于使用指针实现，而动态派发在结构体上的表现非常差，这也提醒我们应当尽量避免使用结构体类型实现接口。</p>
<p>使用结构体带来的巨大性能差异不只是接口带来的问题，带来性能问题主要因为 Go 语言在函数调用时是传值的，动态派发的过程只是放大了参数拷贝带来的影响。</p>
<h3 id="小结">小结</h3>
<p>重新回顾一下本节介绍的内容，我们在开头简单介绍了使用 Go 语言接口的常见问题，例如使用不同类型实现接口带来的差异、函数调用时发生的隐式类型转换；我们还分析了接口的类型转换、类型断言以及动态派发机制，相信这一节的内容能够帮助各位深入理解 Go 语言的接口。</p>
<h2 id="reflect">reflect</h2>
<p>虽然在大多数的应用和服务中并不常见，但是很多框架都依赖 Go 语言的反射机制简化代码。因为 Go 语言的语法元素很少、设计简单，所以它没有特别强的表达能力，但是 Go 语言的 reflect 包能够弥补它在语法上<code>reflect.Type</code>的一些劣势。</p>
<p>reflect 实现了运行时的反射能力，能够让程序操作不同类型的对象。反射包中有两对非常重要的函数和类型，两个函数分别是：</p>
<ul>
<li>reflect.TypeOf 能获取类型信息；</li>
<li>reflect.ValueOf 能获取数据的运行时表示；</li>
</ul>
<p>两个类型是 <code>reflect.Type</code> 和 <code>reflect.Value</code>，它们与函数是一一对应的关系：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210629165909.png" alt=""></p>
<p>类型 <code>reflect.Type</code> 是反射包定义的一个接口，我们可以使用 <code>reflect.TypeOf</code> 函数获取任意变量的类型，<code>reflect.Type</code> 接口中定义了一些有趣的方法，MethodByName 可以获取当前类型对应方法的引用、Implements 可以判断当前类型是否实现了某个接口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Type</span> <span class="kd">interface</span> <span class="p">{</span>
        <span class="nf">Align</span><span class="p">()</span> <span class="kt">int</span>
        <span class="nf">FieldAlign</span><span class="p">()</span> <span class="kt">int</span>
        <span class="nf">Method</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="nx">Method</span>
        <span class="nf">MethodByName</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Method</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>
        <span class="nf">NumMethod</span><span class="p">()</span> <span class="kt">int</span>
        <span class="o">...</span>
        <span class="nf">Implements</span><span class="p">(</span><span class="nx">u</span> <span class="nx">Type</span><span class="p">)</span> <span class="kt">bool</span>
        <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>反射包中 reflect.Value 的类型与 reflect.Type 不同，它被声明成了结构体。这个结构体没有对外暴露的字段，但是提供了获取或者写入数据的方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Value</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="c1">// 包含过滤的或者未导出的字段
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Value</span><span class="p">)</span> <span class="nf">Addr</span><span class="p">()</span> <span class="nx">Value</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Value</span><span class="p">)</span> <span class="nf">Bool</span><span class="p">()</span> <span class="kt">bool</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Value</span><span class="p">)</span> <span class="nf">Bytes</span><span class="p">()</span> <span class="p">[]</span><span class="kt">byte</span>
<span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div><p>反射包中的所有方法基本都是围绕着 <code>reflect.Type</code> 和 <code>reflect.Value</code> 两个类型设计的。我们通过 <code>reflect.TypeOf</code>、<code>reflect.ValueOf</code> 可以将一个普通的变量转换成反射包中提供的 <code>reflect.Type</code> 和 <code>reflect.Value</code>，随后就可以使用反射包中的方法对它们进行复杂的操作。</p>
<h3 id="三大法则">三大法则</h3>
<p>运行时反射是程序在运行期间检查其自身结构的一种方式。反射带来的灵活性是一把双刃剑，反射作为一种元编程方式可以减少重复代码，但是过量的使用反射会使我们的程序逻辑变得难以理解并且运行缓慢。我们在这一节中会介绍 Go 语言反射的三大法则，其中包括：</p>
<ol>
<li>从 <code>interface{}</code> 变量可以反射出反射对象；</li>
<li>从反射对象可以获取 <code>interface{}</code> 变量；</li>
<li>要修改反射对象，其值必须可设置；</li>
</ol>
<h4 id="第一法则">第一法则</h4>
<p>反射的第一法则是我们能将 Go 语言的 <code>interface{}</code> 变量转换成反射对象。很多读者可能会对这以法则产生困惑 — 为什么是从 <code>interface{}</code> 变量到反射对象？当我们执行 <code>reflect.ValueOf(1)</code> 时，虽然看起来是获取了基本类型 int 对应的反射类型，但是由于 <code>reflect.TypeOf</code>、<code>reflect.ValueOf</code> 两个方法的入参都是 interface{} 类型，所以在方法执行的过程中发生了类型转换。</p>
<p>因为Go 语言的函数调用都是值传递的，所以变量会在函数调用时进行类型转换。基本类型 int 会转换成 <code>interface{}</code> 类型，这也就是为什么第一条法则是从接口到反射对象。</p>
<p>上面提到的 <code>reflect.TypeOf</code> 和 <code>reflect.ValueOf</code> 函数就能完成这里的转换，如果我们认为 Go 语言的类型和反射类型处于两个不同的世界，那么这两个函数就是连接这两个世界的桥梁。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210629171357.png" alt=""></p>
<p>我们可以通过以下例子简单介绍它们的作用，<code>reflect.TypeOf</code> 获取了变量 author 的类型，<code>reflect.ValueOf</code> 获取了变量的值 draven。如果我们知道了一个变量的类型和值，那么就意味着我们知道了这个变量的全部信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;reflect&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">author</span> <span class="o">:=</span> <span class="s">&#34;draven&#34;</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;TypeOf author:&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">author</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;ValueOf author:&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">author</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">run</span> <span class="n">main.go</span>
<span class="n">TypeOf</span> <span class="n">author</span><span class="o">:</span> <span class="n">string</span>
<span class="n">ValueOf</span> <span class="n">author</span><span class="o">:</span> <span class="n">draven</span>
</code></pre></td></tr></table>
</div>
</div><p>有了变量的类型之后，我们可以通过 Method 方法获得类型实现的方法，通过 Field 获取类型包含的全部字段。对于不同的类型，我们也可以调用不同的方法获取相关信息：</p>
<ul>
<li>结构体：获取字段的数量并通过下标和字段名获取字段 StructField；</li>
<li>哈希表：获取哈希表的 Key 类型；</li>
<li>函数或方法：获取入参和返回值的类型；</li>
</ul>
<p>总而言之，使用 <code>reflect.TypeOf</code> 和 <code>reflect.ValueOf</code> 能够获取 Go 语言中的变量对应的反射对象。一旦获取了反射对象，我们就能得到跟当前类型相关数据和操作，并可以使用这些运行时获取的结构执行方法。</p>
<h4 id="第二法则">第二法则</h4>
<p>反射的第二法则是我们可以从反射对象可以获取 <code>interface{}</code> 变量。既然能够将接口类型的变量转换成反射对象，那么一定需要其他方法将反射对象还原成接口类型的变量，reflect 中的<code>reflect.Value.Interface</code> 就能完成这项工作：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210629171905.png" alt=""></p>
<p>不过调用 reflect.Value.Interface 方法只能获得 interface{} 类型的变量，如果想要将其还原成最原始的状态还需要经过如下所示的显式类型转换：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nx">v</span><span class="p">.</span><span class="nf">Interface</span><span class="p">().(</span><span class="kt">int</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>从反射对象到接口值的过程是从接口值到反射对象的镜面过程，两个过程都需要经历两次转换：</p>
<ul>
<li>从接口值到反射对象：
<ul>
<li>从基本类型到接口类型的类型转换；</li>
<li>从接口类型到反射对象的转换；</li>
</ul>
</li>
<li>从反射对象到接口值：
<ul>
<li>反射对象转换成接口类型；</li>
<li>通过显式类型转换变成原始类型；</li>
</ul>
</li>
</ul>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210629171935.png" alt=""></p>
<p>当然不是所有的变量都需要类型转换这一过程。如果变量本身就是 <code>interface{}</code> 类型的，那么它不需要类型转换，因为类型转换这一过程一般都是隐式的，所以我不太需要关心它，只有在我们需要将反射对象转换回基本类型时才需要显式的转换操作。</p>
<h4 id="第三法则">第三法则</h4>
<p>Go 语言反射的最后一条法则是与值是否可以被更改有关，如果我们想要更新一个 <code>reflect.Value</code>，那么它持有的值一定是可以被更新的，假设我们有以下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
	<span class="nx">v</span><span class="p">.</span><span class="nf">SetInt</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">run</span> <span class="n">reflect.go</span>
<span class="n">panic</span><span class="o">:</span> <span class="n">reflect</span><span class="o">:</span> <span class="n">reflect.flag.mustBeAssignable</span> <span class="n">using</span> <span class="n">unaddressable</span> <span class="n">value</span>

<span class="n">goroutine</span> <span class="m">1</span> <span class="n">[running]</span><span class="o">:</span>
<span class="nf">reflect.flag.mustBeAssignableSlow</span><span class="p">(</span><span class="mh">0x82</span><span class="p">,</span> <span class="mh">0x1014c0</span><span class="p">)</span>
	<span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">reflect</span><span class="o">/</span><span class="n">value.go</span><span class="o">:</span><span class="m">247</span> <span class="m">+0</span><span class="n">x180</span>
<span class="nf">reflect.flag.mustBeAssignable</span><span class="p">(</span><span class="kc">...</span><span class="p">)</span>
	<span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">reflect</span><span class="o">/</span><span class="n">value.go</span><span class="o">:</span><span class="m">234</span>
<span class="nf">reflect.Value.SetInt</span><span class="p">(</span><span class="mh">0x100dc0</span><span class="p">,</span> <span class="mh">0x414020</span><span class="p">,</span> <span class="mh">0x82</span><span class="p">,</span> <span class="mh">0x1840</span><span class="p">,</span> <span class="mh">0xa</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">)</span>
	<span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">reflect</span><span class="o">/</span><span class="n">value.go</span><span class="o">:</span><span class="m">1606</span> <span class="m">+0</span><span class="n">x40</span>
<span class="nf">main.main</span><span class="p">()</span>
	<span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">sandbox590309925</span><span class="o">/</span><span class="n">prog.go</span><span class="o">:</span><span class="m">11</span> <span class="m">+0</span><span class="n">xe0</span>
</code></pre></td></tr></table>
</div>
</div><p>运行上述代码会导致程序崩溃并报出 “reflect: reflect.flag.mustBeAssignable using unaddressable value” 错误，仔细思考一下就能够发现出错的原因：由于 Go 语言的函数调用都是传值的，所以我们得到的反射对象跟最开始的变量没有任何关系，那么直接修改反射对象无法改变原始变量，程序为了防止错误就会崩溃。</p>
<p>想要修改原变量只能使用如下的方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">i</span><span class="p">)</span>
	<span class="nx">v</span><span class="p">.</span><span class="nf">Elem</span><span class="p">().</span><span class="nf">SetInt</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">run</span> <span class="n">reflect.go</span>
<span class="m">10</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>调用 <code>reflect.ValueOf</code> 获取变量指针；</li>
<li>调用 <code>reflect.Value.Elem</code> 获取指针指向的变量；</li>
<li>调用 <code>reflect.Value.SetInt</code> 更新变量的值：</li>
</ul>
<p>由于 Go 语言的函数调用都是值传递的，所以我们只能只能用迂回的方式改变原变量：先获取指针对应的 <code>reflect.Value</code>，再通过 <code>reflect.Value.Elem</code> 方法得到可以被设置的变量，我们可以通过下面的代码理解这个过程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="nx">v</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">i</span>
	<span class="o">*</span><span class="nx">v</span> <span class="p">=</span> <span class="mi">10</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果不能直接操作 i 变量修改其持有的值，我们就只能获取 i 变量所在地址并使用*v 修改所在地址中存储的整数。</p>
<h3 id="typeofvalueof">TypeOf&amp;ValueOf</h3>
<p>Go 语言的 <code>interface{}</code> 类型在语言内部是通过 <code>reflect.emptyInterface</code> 结体表示的，其中的 rtype 字段用于表示变量的类型，另一个 word 字段指向内部封装的数据：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">emptyInterface</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">typ</span>  <span class="o">*</span><span class="nx">rtype</span>
	<span class="nx">word</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>用于获取变量类型的 <code>reflect.TypeOf</code> 函数将传入的变量隐式转换成 <code>reflect.emptyInterface</code> 类型并获取其中存储的类型信息 <code>reflect.rtype</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TypeOf</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">Type</span> <span class="p">{</span>
	<span class="nx">eface</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">emptyInterface</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">i</span><span class="p">))</span>
	<span class="k">return</span> <span class="nf">toType</span><span class="p">(</span><span class="nx">eface</span><span class="p">.</span><span class="nx">typ</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">toType</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">rtype</span><span class="p">)</span> <span class="nx">Type</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">t</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>reflect.rtype</code> 是一个实现了 <code>reflect.Type</code> 接口的结构体，该结构体实现的 <code>reflect.rtype.String</code> 方法可以帮助我们获取当前类型的名称：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">rtype</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">nameOff</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">str</span><span class="p">).</span><span class="nf">name</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">tflag</span><span class="o">&amp;</span><span class="nx">tflagExtraStar</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>reflect.TypeOf</code> 的实现原理其实并不复杂，它只是将一个 <code>interface{}</code> 变量转换成了内部的 <code>reflect.emptyInterface</code> 表示，然后从中获取相应的类型信息。</p>
<p>用于获取接口值 <code>reflect.Value</code> 的函数 <code>reflect.ValueOf</code> 实现也非常简单，在该函数中我们先调用了 <code>reflect.escapes</code> 保证当前值逃逸到堆上，然后通过 <code>reflect.unpackEface</code> 从接口中获取 <code>reflect.Value</code> 结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ValueOf</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">Value</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">Value</span><span class="p">{}</span>
	<span class="p">}</span>

	<span class="nf">escapes</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>

	<span class="k">return</span> <span class="nf">unpackEface</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">unpackEface</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">Value</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">emptyInterface</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">i</span><span class="p">))</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">typ</span>
	<span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">Value</span><span class="p">{}</span>
	<span class="p">}</span>
	<span class="nx">f</span> <span class="o">:=</span> <span class="nf">flag</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">Kind</span><span class="p">())</span>
	<span class="k">if</span> <span class="nf">ifaceIndir</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">f</span> <span class="o">|=</span> <span class="nx">flagIndir</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">Value</span><span class="p">{</span><span class="nx">t</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">word</span><span class="p">,</span> <span class="nx">f</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>reflect.unpackEface</code> 会将传入的接口转换成 <code>reflect.emptyInterface</code>，然后将具体类型和指针包装成 <code>reflect.Value</code> 结构体后返回。</p>
<p><code>reflect.TypeOf</code> 和 <code>reflect.ValueOf</code> 的实现都很简单。我们已经分析了这两个函数的实现，现在需要了解编译器在调用函数之前做了哪些工作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;reflect&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">20</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">gcflags</span><span class="o">=</span><span class="s">&#34;-S -N&#34;</span> <span class="n">main.go</span>
<span class="kc">...</span>
<span class="n">MOVQ</span>	<span class="o">$</span><span class="m">20</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="n">..autotmp_20</span><span class="m">+56</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span> <span class="o">//</span> <span class="n">autotmp</span> <span class="o">=</span> <span class="m">20</span>
<span class="n">LEAQ</span>	<span class="nf">type.int</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">AX</span>           <span class="o">//</span> <span class="n">AX</span> <span class="o">=</span> <span class="nf">type.int</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
<span class="n">MOVQ</span>	<span class="n">AX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="n">..autotmp_19</span><span class="m">+280</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span> <span class="o">//</span> <span class="n">autotmp_19</span><span class="m">+280</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span> <span class="o">=</span> <span class="nf">type.int</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
<span class="n">LEAQ</span>	<span class="s">&#34;&#34;</span><span class="n">..autotmp_20</span><span class="m">+56</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">CX</span>  <span class="o">//</span> <span class="n">CX</span> <span class="o">=</span> <span class="m">20</span>
<span class="n">MOVQ</span>	<span class="n">CX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="n">..autotmp_19</span><span class="m">+288</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span> <span class="o">//</span> <span class="n">autotmp_19</span><span class="m">+288</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span> <span class="o">=</span> <span class="m">20</span>
<span class="kc">...</span>
</code></pre></td></tr></table>
</div>
</div><p>从上面这段截取的汇编语言，我们可以发现在函数调用之前已经发生了类型转换，上述指令将 int 类型的变量转换成了占用 16 字节 autotmp_19+280(SP) ~ autotmp_19+288(SP) 的接口，两个 LEAQ 指令分别获取了类型的指针 type.int(SB) 以及变量 i 所在的地址。</p>
<p>当我们想要将一个变量转换成反射对象时，Go 语言会在编译期间完成类型转换，将变量的类型和值转换成了 interface{} 并等待运行期间使用 reflect 包获取接口中存储的信息。</p>
<h3 id="valueset">Value.Set</h3>
<p>当我们想要更新 <code>reflect.Value</code> 时，就需要调用 <code>reflect.Value.Set</code> 更新反射对象，该方法会调用 <code>reflect.flag.mustBeAssignable</code> 和 <code>reflect.flag.mustBeExported</code> 分别检查当前反射对象是否是可以被设置的以及字段是否是对外公开的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Value</span><span class="p">)</span> <span class="nf">Set</span><span class="p">(</span><span class="nx">x</span> <span class="nx">Value</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">v</span><span class="p">.</span><span class="nf">mustBeAssignable</span><span class="p">()</span>
	<span class="nx">x</span><span class="p">.</span><span class="nf">mustBeExported</span><span class="p">()</span>
	<span class="kd">var</span> <span class="nx">target</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nf">kind</span><span class="p">()</span> <span class="o">==</span> <span class="nx">Interface</span> <span class="p">{</span>
		<span class="nx">target</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">ptr</span>
	<span class="p">}</span>
	<span class="nx">x</span> <span class="p">=</span> <span class="nx">x</span><span class="p">.</span><span class="nf">assignTo</span><span class="p">(</span><span class="s">&#34;reflect.Set&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">typ</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span>
	<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">typ</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">x</span><span class="p">.</span><span class="nx">ptr</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>reflect.Value.Set</code> 会调用 <code>reflect.Value.assignTo</code> 并返回一个新的反射对象，这个返回的反射对象指针会直接覆盖原反射变量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Value</span><span class="p">)</span> <span class="nf">assignTo</span><span class="p">(</span><span class="nx">context</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">dst</span> <span class="o">*</span><span class="nx">rtype</span><span class="p">,</span> <span class="nx">target</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">Value</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nf">directlyAssignable</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">typ</span><span class="p">):</span>
		<span class="o">...</span>
		<span class="k">return</span> <span class="nx">Value</span><span class="p">{</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">fl</span><span class="p">}</span>
	<span class="k">case</span> <span class="nf">implements</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">typ</span><span class="p">):</span>
		<span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Kind</span><span class="p">()</span> <span class="o">==</span> <span class="nx">Interface</span> <span class="o">&amp;&amp;</span> <span class="nx">v</span><span class="p">.</span><span class="nf">IsNil</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">Value</span><span class="p">{</span><span class="nx">dst</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">flag</span><span class="p">(</span><span class="nx">Interface</span><span class="p">)}</span>
		<span class="p">}</span>
		<span class="nx">x</span> <span class="o">:=</span> <span class="nf">valueInterface</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">dst</span><span class="p">.</span><span class="nf">NumMethod</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kd">interface</span><span class="p">{})(</span><span class="nx">target</span><span class="p">)</span> <span class="p">=</span> <span class="nx">x</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">ifaceE2I</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">Value</span><span class="p">{</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">flagIndir</span> <span class="p">|</span> <span class="nf">flag</span><span class="p">(</span><span class="nx">Interface</span><span class="p">)}</span>
	<span class="p">}</span>
	<span class="nb">panic</span><span class="p">(</span><span class="nx">context</span> <span class="o">+</span> <span class="s">&#34;: value of type &#34;</span> <span class="o">+</span> <span class="nx">v</span><span class="p">.</span><span class="nx">typ</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34; is not assignable to type &#34;</span> <span class="o">+</span> <span class="nx">dst</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>reflect.Value.assignTo</code> 会根据当前和被设置的反射对象类型创建一个新的 <code>reflect.Value</code> 结构体：</p>
<ul>
<li>如果两个反射对象的类型是可以被直接替换，就会直接返回目标反射对象；</li>
<li>如果当前反射对象是接口并且目标对象实现了接口，就会把目标对象简单包装成接口值；</li>
</ul>
<p>在变量更新的过程中，<code>reflect.Value.assignTo</code> 返回的 <code>reflect.Value</code> 中的指针会覆盖当前反射对象中的指针实现变量的更新。</p>
<h3 id="实现协议">实现协议</h3>
<p>reflect 包还为我们提供了 <code>reflect.rtype.Implements</code> 方法可以用于判断某些类型是否遵循特定的接口。在 Go 语言中获取结构体的反射类型 reflect.Type 还是比较容易的，但是想要获得接口类型需要通过以下方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">((</span><span class="o">*</span><span class="p">&lt;</span><span class="kd">interface</span><span class="p">&gt;)(</span><span class="kc">nil</span><span class="p">)).</span><span class="nf">Elem</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>我们通过一个例子在介绍如何判断一个类型是否实现了某个接口。假设我们需要判断如下代码中的 CustomError 是否实现了 Go 语言标准库中的 error 接口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">CustomError</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">CustomError</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">typeOfError</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">((</span><span class="o">*</span><span class="kt">error</span><span class="p">)(</span><span class="kc">nil</span><span class="p">)).</span><span class="nf">Elem</span><span class="p">()</span>
	<span class="nx">customErrorPtr</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">CustomError</span><span class="p">{})</span>
	<span class="nx">customError</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">CustomError</span><span class="p">{})</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">customErrorPtr</span><span class="p">.</span><span class="nf">Implements</span><span class="p">(</span><span class="nx">typeOfError</span><span class="p">))</span> <span class="c1">// #=&gt; true
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">customError</span><span class="p">.</span><span class="nf">Implements</span><span class="p">(</span><span class="nx">typeOfError</span><span class="p">))</span> <span class="c1">// #=&gt; false
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码的运行结果正如我们在接口一节中介绍的：</p>
<ul>
<li>CustomError 类型并没有实现 error 接口；</li>
<li>*CustomError 指针类型实现了 error 接口；</li>
</ul>
<p>抛开上述的执行结果不谈，我们来分析一下 reflect.rtype.Implements 方法的工作原理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">rtype</span><span class="p">)</span> <span class="nf">Implements</span><span class="p">(</span><span class="nx">u</span> <span class="nx">Type</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">u</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;reflect: nil type passed to Type.Implements&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">u</span><span class="p">.</span><span class="nf">Kind</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">Interface</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;reflect: non-interface type passed to Type.Implements&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">implements</span><span class="p">(</span><span class="nx">u</span><span class="p">.(</span><span class="o">*</span><span class="nx">rtype</span><span class="p">),</span> <span class="nx">t</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>reflect.rtype.Implements</code> 会检查传入的类型是不是接口，如果不是接口或者是空值就会直接崩溃并中止当前程序。在参数没有问题的情况下，上述方法会调用私有函数 <code>reflect.implements</code> 判断类型之间是否有实现关系：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">implements</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">V</span> <span class="o">*</span><span class="nx">rtype</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">interfaceType</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">methods</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="o">...</span>
	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">V</span><span class="p">.</span><span class="nf">uncommon</span><span class="p">()</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">vmethods</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">methods</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">mcount</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">tm</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">methods</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">tmName</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">nameOff</span><span class="p">(</span><span class="nx">tm</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
		<span class="nx">vm</span> <span class="o">:=</span> <span class="nx">vmethods</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
		<span class="nx">vmName</span> <span class="o">:=</span> <span class="nx">V</span><span class="p">.</span><span class="nf">nameOff</span><span class="p">(</span><span class="nx">vm</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">vmName</span><span class="p">.</span><span class="nf">name</span><span class="p">()</span> <span class="o">==</span> <span class="nx">tmName</span><span class="p">.</span><span class="nf">name</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">V</span><span class="p">.</span><span class="nf">typeOff</span><span class="p">(</span><span class="nx">vm</span><span class="p">.</span><span class="nx">mtyp</span><span class="p">)</span> <span class="o">==</span> <span class="nx">t</span><span class="p">.</span><span class="nf">typeOff</span><span class="p">(</span><span class="nx">tm</span><span class="p">.</span><span class="nx">typ</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">i</span><span class="o">++</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">methods</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">true</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果接口中不包含任何方法，就意味着这是一个空的接口，任意类型都自动实现该接口，这时会直接返回 true。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210630113410.png" alt=""></p>
<p>在其他情况下，由于方法都是按照字母序存储的，reflect.implements 会维护两个用于遍历接口和类型方法的索引 i 和 j 判断类型是否实现了接口，因为最多只会进行 n 次比较（类型的方法数量），所以整个过程的时间复杂度是 𝑂(𝑛)。</p>
<h3 id="方法调用">方法调用</h3>
<p>作为一门静态语言，如果我们想要通过 reflect 包利用反射在运行期间执行方法不是一件容易的事情，下面的十几行代码就使用反射来执行 Add(0, 1) 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">Add</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Kind</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Func</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Type</span><span class="p">()</span>
	<span class="nx">argv</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nf">NumIn</span><span class="p">())</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">argv</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">In</span><span class="p">(</span><span class="nx">i</span><span class="p">).</span><span class="nf">Kind</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">argv</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="nx">argv</span><span class="p">)</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">result</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">Kind</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">result</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">Int</span><span class="p">())</span> <span class="c1">// #=&gt; 1
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>通过 reflect.ValueOf 获取函数 Add 对应的反射对象；</li>
<li>调用 reflect.rtype.NumIn 获取函数的入参个数；</li>
<li>多次调用 reflect.ValueOf 函数逐一设置 argv 数组中的各个参数；</li>
<li>调用反射对象 Add 的 reflect.Value.Call 方法并传入参数列表；</li>
<li>获取返回值数组、验证数组的长度以及类型并打印其中的数据；</li>
</ol>
<p>使用反射来调用方法非常复杂，原本只需要一行代码就能完成的工作，现在需要十几行代码才能完成，但这也是在静态语言中使用动态特性需要付出的成本。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Value</span><span class="p">)</span> <span class="nf">Call</span><span class="p">(</span><span class="nx">in</span> <span class="p">[]</span><span class="nx">Value</span><span class="p">)</span> <span class="p">[]</span><span class="nx">Value</span> <span class="p">{</span>
	<span class="nx">v</span><span class="p">.</span><span class="nf">mustBe</span><span class="p">(</span><span class="nx">Func</span><span class="p">)</span>
	<span class="nx">v</span><span class="p">.</span><span class="nf">mustBeExported</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">v</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="s">&#34;Call&#34;</span><span class="p">,</span> <span class="nx">in</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>reflect.Value.Call</code> 是运行时调用方法的入口，它通过两个 MustBe 开头的方法确定了当前反射对象的类型是函数以及可见性，随后调用 <code>reflect.Value.call</code> 完成方法调用，这个私有方法的执行过程会分成以下的几个部分：</p>
<ol>
<li>检查输入参数以及类型的合法性；</li>
<li>将传入的 reflect.Value 参数数组设置到栈上；</li>
<li>通过函数指针和输入参数调用函数；</li>
<li>从栈上获取函数的返回值；</li>
</ol>
<p>我们将按照上面的顺序分析使用 reflect 进行函数调用的几个过程。</p>
<h4 id="参数检查">参数检查</h4>
<p>参数检查是通过反射调用方法的第一步，在参数检查期间我们会从反射对象中取出当前的函数指针 unsafe.Pointer，如果该函数指针是方法，那么我们会通过 reflect.methodReceiver 获取方法的接收者和函数指针。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Value</span><span class="p">)</span> <span class="nf">call</span><span class="p">(</span><span class="nx">op</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">in</span> <span class="p">[]</span><span class="nx">Value</span><span class="p">)</span> <span class="p">[]</span><span class="nx">Value</span> <span class="p">{</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">funcType</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">typ</span><span class="p">))</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nx">flag</span><span class="o">&amp;</span><span class="nx">flagMethod</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">rcvr</span> <span class="p">=</span> <span class="nx">v</span>
		<span class="nx">rcvrtype</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">fn</span> <span class="p">=</span> <span class="nf">methodReceiver</span><span class="p">(</span><span class="nx">op</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">flag</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="nx">flagMethodShift</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">...</span>
	<span class="p">}</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">NumIn</span><span class="p">()</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;reflect: Call with too few input arguments&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;reflect: Call with too many input arguments&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">xt</span><span class="p">,</span> <span class="nx">targ</span> <span class="o">:=</span> <span class="nx">in</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">Type</span><span class="p">(),</span> <span class="nx">t</span><span class="p">.</span><span class="nf">In</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="p">!</span><span class="nx">xt</span><span class="p">.</span><span class="nf">AssignableTo</span><span class="p">(</span><span class="nx">targ</span><span class="p">)</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;reflect: &#34;</span> <span class="o">+</span> <span class="nx">op</span> <span class="o">+</span> <span class="s">&#34; using &#34;</span> <span class="o">+</span> <span class="nx">xt</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34; as type &#34;</span> <span class="o">+</span> <span class="nx">targ</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述方法还会检查传入参数的个数以及参数的类型与函数签名中的类型是否可以匹配，任何参数的不匹配都会导致整个程序的崩溃中止。</p>
<h4 id="准备参数">准备参数</h4>
<p>当我们已经对当前方法的参数完成验证后，就会进入函数调用的下一个阶段，为函数调用准备参数，在前面函数调用一节中，我们已经介绍过 Go 语言的函数调用惯例，函数或者方法在调用时，所有的参数都会被依次放到栈上。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">	<span class="nx">nout</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">NumOut</span><span class="p">()</span>
	<span class="nx">frametype</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">retOffset</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">framePool</span> <span class="o">:=</span> <span class="nf">funcLayout</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">rcvrtype</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">args</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="k">if</span> <span class="nx">nout</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">args</span> <span class="p">=</span> <span class="nx">framePool</span><span class="p">.</span><span class="nf">Get</span><span class="p">().(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">args</span> <span class="p">=</span> <span class="nf">unsafe_New</span><span class="p">(</span><span class="nx">frametype</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">off</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">rcvrtype</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">storeRcvr</span><span class="p">(</span><span class="nx">rcvr</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
		<span class="nx">off</span> <span class="p">=</span> <span class="nx">ptrSize</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span>
		<span class="nx">targ</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">In</span><span class="p">(</span><span class="nx">i</span><span class="p">).(</span><span class="o">*</span><span class="nx">rtype</span><span class="p">)</span>
		<span class="nx">a</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">targ</span><span class="p">.</span><span class="nx">align</span><span class="p">)</span>
		<span class="nx">off</span> <span class="p">=</span> <span class="p">(</span><span class="nx">off</span> <span class="o">+</span> <span class="nx">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="nx">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="nx">n</span> <span class="o">:=</span> <span class="nx">targ</span><span class="p">.</span><span class="nx">size</span>
		<span class="o">...</span>
		<span class="nx">addr</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">args</span><span class="p">,</span> <span class="nx">off</span><span class="p">,</span> <span class="s">&#34;n &gt; 0&#34;</span><span class="p">)</span>
		<span class="nx">v</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">assignTo</span><span class="p">(</span><span class="s">&#34;reflect.Value.Call&#34;</span><span class="p">,</span> <span class="nx">targ</span><span class="p">,</span> <span class="nx">addr</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">addr</span><span class="p">)</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">ptr</span>
		<span class="nx">off</span> <span class="o">+=</span> <span class="nx">n</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>通过 <code>reflect.funcLayout</code> 计算当前函数需要的参数和返回值的栈布局，也就是每一个参数和返回值所占的空间大小；</li>
<li>如果当前函数有返回值，需要为当前函数的参数和返回值分配一片内存空间 args；</li>
<li>如果当前函数是方法，需要向将方法的接收接收者者拷贝到 args 内存中；</li>
<li>将所有函数的参数按照顺序依次拷贝到对应 args 内存中
<ol>
<li>使用 reflect.funcLayout 返回的参数计算参数在内存中的位置；</li>
<li>将参数拷贝到内存空间中；</li>
</ol>
</li>
</ol>
<p>准备参数是计算各个参数和返回值占用的内存空间并将所有的参数都拷贝内存空间对应位置的过程，该过程会考虑函数和方法、返回值数量以及参数类型带来的差异。</p>
<h4 id="调用函数">调用函数</h4>
<p>准备好调用函数需要的全部参数后，就会通过下面的代码执行函数指针了。我们会向该函数传入栈类型、函数指针、参数和返回值的内存空间、栈的大小以及返回值的偏移量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">call</span><span class="p">(</span><span class="nx">frametype</span><span class="p">,</span> <span class="nx">fn</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">frametype</span><span class="p">.</span><span class="nx">size</span><span class="p">),</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">retOffset</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>上述函数实际上并不存在，它会在编译期间链接到 reflect.reflectcall 这个用汇编实现的函数上，我们在这里不会分析该函数的具体实现，感兴趣的读者可以自行了解其实现原理。</p>
<h4 id="处理返回值">处理返回值</h4>
<p>当函数调用结束之后，就会开始处理函数的返回值：</p>
<ul>
<li>如果函数没有任何返回值，会直接清空 args 中的全部内容来释放内存空间；</li>
<li>如果当前函数有返回值；
<ol>
<li>将 args 中与输入参数有关的内存空间清空；</li>
<li>创建一个 nout 长度的切片用于保存由反射对象构成的返回值数组；</li>
<li>从函数对象中获取返回值的类型和内存大小，将 args 内存中的数据转换成 reflect.Value 类型并存储到切片中；</li>
</ol>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">	<span class="kd">var</span> <span class="nx">ret</span> <span class="p">[]</span><span class="nx">Value</span>
	<span class="k">if</span> <span class="nx">nout</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">frametype</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
		<span class="nx">framePool</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nf">typedmemclrpartial</span><span class="p">(</span><span class="nx">frametype</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">retOffset</span><span class="p">)</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">nout</span><span class="p">)</span>
		<span class="nx">off</span> <span class="p">=</span> <span class="nx">retOffset</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">nout</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">tv</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Out</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
			<span class="nx">a</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">tv</span><span class="p">.</span><span class="nf">Align</span><span class="p">())</span>
			<span class="nx">off</span> <span class="p">=</span> <span class="p">(</span><span class="nx">off</span> <span class="o">+</span> <span class="nx">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="nx">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">tv</span><span class="p">.</span><span class="nf">Size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">fl</span> <span class="o">:=</span> <span class="nx">flagIndir</span> <span class="p">|</span> <span class="nf">flag</span><span class="p">(</span><span class="nx">tv</span><span class="p">.</span><span class="nf">Kind</span><span class="p">())</span>
				<span class="nx">ret</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">Value</span><span class="p">{</span><span class="nx">tv</span><span class="p">.</span><span class="nf">common</span><span class="p">(),</span> <span class="nf">add</span><span class="p">(</span><span class="nx">args</span><span class="p">,</span> <span class="nx">off</span><span class="p">,</span> <span class="s">&#34;tv.Size() != 0&#34;</span><span class="p">),</span> <span class="nx">fl</span><span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">ret</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">Zero</span><span class="p">(</span><span class="nx">tv</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">off</span> <span class="o">+=</span> <span class="nx">tv</span><span class="p">.</span><span class="nf">Size</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>由 reflect.Value 构成的 ret 数组会被返回到调用方，到这里为止使用反射实现函数调用的过程就结束了。</p>
<h3 id="小结-1">小结</h3>
<p>Go 语言的 reflect 包为我们提供了多种能力，包括如何使用反射来动态修改变量、判断类型是否实现了某些接口以及动态调用方法等功能，通过分析反射包中方法的原理能帮助我们理解之前看起来比较怪异、令人困惑的现象。</p>
<h2 id="转载">转载</h2>
<p><a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95">4.2 接口</a></p>
<p><a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/#435-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8">4.3 反射</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-06-28
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go%E6%BA%90%E7%A0%81/">Go源码</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">函数调用源码剖析</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E8%AF%ADpanic%E5%92%8Crecover%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
            <span class="next-text nav-default">基本原语panic和recover源码剖析</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
