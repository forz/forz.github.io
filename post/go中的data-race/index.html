<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go中的Data-Race | Forz Blog</title>
<meta name="keywords" content="Go" />
<meta name="description" content="数据竞争与竞态条件 数据竞争 定义：①多个线程对于同一个变量、②同时地、③进行读/写操作的现象并且④至少有一个线程进行写操作。（也就是说，如果所">
<meta name="author" content="">
<link rel="canonical" href="/post/go%E4%B8%AD%E7%9A%84data-race/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Go中的Data-Race" />
<meta property="og:description" content="数据竞争与竞态条件 数据竞争 定义：①多个线程对于同一个变量、②同时地、③进行读/写操作的现象并且④至少有一个线程进行写操作。（也就是说，如果所" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E4%B8%AD%E7%9A%84data-race/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-12-08T18:27:35&#43;08:00" />
<meta property="article:modified_time" content="2020-12-08T18:27:35&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go中的Data-Race"/>
<meta name="twitter:description" content="数据竞争与竞态条件 数据竞争 定义：①多个线程对于同一个变量、②同时地、③进行读/写操作的现象并且④至少有一个线程进行写操作。（也就是说，如果所"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Go中的Data-Race",
      "item": "/post/go%E4%B8%AD%E7%9A%84data-race/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go中的Data-Race",
  "name": "Go中的Data-Race",
  "description": "数据竞争与竞态条件 数据竞争 定义：①多个线程对于同一个变量、②同时地、③进行读/写操作的现象并且④至少有一个线程进行写操作。（也就是说，如果所",
  "keywords": [
    "Go"
  ],
  "articleBody": "数据竞争与竞态条件 数据竞争 定义：①多个线程对于同一个变量、②同时地、③进行读/写操作的现象并且④至少有一个线程进行写操作。（也就是说，如果所有线程都是只进行读操作，那么将不构成数据争用）\n后果：如果发生了数据争用，读取该变量时得到的值将变得不可知，使得该多线程程序的运行结果将完全不可预测，可能直接崩溃。\n如何防止：对于有可能被多个线程同时访问的变量使用排他访问控制，具体方法包括使用mutex（互斥量）和monitor（监视器），或者使用atomic变量。\n例如，对一个非同步变量进行多个并发读取就可以了：\n1 2 3 4 5 6 7 8  const a = 3 func main() { go func() { fmt.Printf(\"Thread B: %d\\n\", a) } fmt.Printf(\"Thread A: %d\\n\", a) }   即使打印顺序因执行而异，但由于两个线程都仅从数据读取，因此没有数据竞争。\n如果现在我们可以a可变地访问其中一个线程，则将引入数据竞争：\n1 2 3 4 5 6 7  func main() { a := 3 go func() { a = 10 } fmt.Printf(\"Thread A: %d\\n\", a) }   我们可以通过引入互斥量来同步访问权限来解决此问题a：\n1 2 3 4 5 6 7 8 9 10 11 12  func main() { a := 3 var m sync.Mutex go func() { m.Lock() a = 10 m.Unlock() } m.Lock() fmt.Printf(\"Thread A: %d\\n\", a) m.Unlock() }   两个线程正在同时访问a，并且其中一个正在写入，但是由于访问是同步的，因此这不再是数据竞争。\n竞态条件 相对于数据争用(data race)，竞态条件(race condition)指的是更加高层次的更加复杂的现象，一般需要在设计并行程序时进行细致入微的分析，才能确定。（也就是隐藏得更深）\n定义：受各线程上代码执行的顺序和时机的影响，程序的运行结果产生（预料之外）的变化。\n后果：如果存在竞态条件(race condition)，多次运行程序对于同一个输入将会有不同的结果，但结果并非完全不可预测，它将由输入数据和各线程的执行顺序共同决定。\n如何预防：竞态条件产生的原因很多是对于同一个资源的一系列连续操作并不是原子性的，也就是说有可能在执行的中途被其他线程抢占，同时这个“其他线程”刚好也要访问这个资源。解决方法通常是：将这一系列操作作为一个critical section（临界区）。\n从理论上讲，任何来自并发的可观察到的非确定性都可以视为 竞争条件，但实际上构成竞争条件的因素取决于我们希望程序尊重的属性。\n让我们以以下程序为例：\n1 2 3 4 5 6 7 8 9 10  func main() { go func() { for { fmt.Println(\"Thread B\") } } for { fmt.Println(\"Thread A\") } }   我们将看到两种消息的某种随机交织：\n1 2 3 4 5 6 7  Thread A Thread A Thread B Thread A Thread B Thread B ...   如果我们希望程序尊重印刷的确切顺序，那么这可以认为是一种竞争条件。我们可以使用某种形式的同步来强制执行该打印顺序。\n在实践中，即使执行不是确定性的，我们也不会将其视为竞争条件，因为这不是我们关心的属性。\n总而言之，竞争条件是由于程序的并行执行而导致我们的程序应具有的某些特性的违反。\n介绍 竞赛条件 是最隐蔽和难以捉摸的编程错误之一。它们通常会导致不稳定和神秘的故障，通常是在将代码部署到生产中之后很长时间了。尽管 Go 的并发机制使编写干净的并发代码变得容易，但它们并不能防止竞争情况。需要谨慎，勤奋和测试。工具可以提供帮助.\n我们很高兴地宣布 Go 1.1 包含了 竞态检测器 , 这是一种用于在 Go 代码中查找竞争条件的新工具。当前可用于具有 64 位 x86 处理器的 Linux, OS X, 和 Windows 系统.\n竞态检测器基于 C/C++ 的 ThreadSanitizer 运行时库 , 已用于检测 Google 内部代码库 和 Chromium. 该技术于 2012 年 9 月与 Go 集成在一起；从那之后，它在标准库中检测到 42 个竞态. 现在它是我们不断构建过程的一部分，在此过程中，它会不断捕获竞争条件.\n如何运行 竞态探测器与 go 工具链集成在一起。设置 -race 命令行标志时，编译器将使用记录访问时间和访问方式的代码来对所有内存访问进行检测，而运行时库将监视对共享变量的非同步访问。当检测到这种 “淫荡” 行为时，将打印警告. (有关算法的详细信息，请参阅 本文)\n由于其设计，竞态检测器只能在运行代码实际触发竞态条件时才检测竞态条件，这意味着在实际的工作负载下运行启用竞态的二进制文件非常重要。但是，启用竞态的二进制文件可以使用十倍于 CPU 和内存，因此始终启用竞态检测器是不切实际的。解决此难题的一种方法是在启用了竞态检测器的情况下运行一些测试。负载测试和集成测试是不错的选择，因为它们倾向于使用代码的并发部分。使用生产工作负载的另一种方法是在运行中的服务器池中部署一个启用了竞争的实例.\n使用竞态检测器 竞态探测器与 Go 工具链完全集成在一起。要在启用竞态检测器的情况下构建代码，只需在命令行中添加 -race 标志:\n1 2 3 4  go test -race mypkg // 测试程序包 go run -race mysrc.go // 编译并运行程序 go build -race mycmd // 构建命令 go install -race mypkg // 安装程序包   要自己尝试运行竞态检测器，请获取以下示例程序并运行:\n1 2  go get -race golang.org/x/blog/support/racy racy   -race选项用于检测数据竞争，在使用了-race的情况下，go程序跑起来之后，如果发生数据竞争，它就能检测到，它就会一层一层地把错误栈打印出来，就像打印panic一样。通常用于开发。当然开启了该选项也未必能检测出潜在的数据竞争，当你的程序跑到数据竞争的片段它就会检测出来，你的程序可能有很多模块，当程序没有执行到数据竞争的地方那直到整个程序执行结束它也检测不出来。\n示例 这里有竞态探测器检测到实际问题的两个示例.\n示例 1: Timer.Reset 第一个示例是由竞态检测器发现的实际错误的简化版本。它使用计时器在 0 到 1 秒之间的随机持续时间后打印消息。如此重复五秒钟。它使用 time.AfterFunc 函数创建一个 Timer 作为第一个消息，然后使用 Reset 方法来调度下一条消息，每次重新使用 Timer.\n1 2 3 4 5 6 7 8 9 10 11 12  func main() { start := time.Now() var t *time.Timer t = time.AfterFunc(randomDuration(), func() { fmt.Println(time.Now().Sub(start)) t.Reset(randomDuration()) }) time.Sleep(5* time.Second) } func randomDuration() time.Duration { return time.Duration(rand.Int63n(1e9)) }   这看起来像是合理的代码，但是在某些情况下，它以令人惊讶的方式失败:\n1 2 3 4 5 6 7 8 9 10 11 12  panic: runtime error: invalid memory address or nil pointer dereference [signal 0xb code=0x1 addr=0x8 pc=0x41e38a] goroutine 4 [running]: time.stopTimer(0x8, 0x12fe6b35d9472d96) src/pkg/runtime/ztime_linux_amd64.c:35 +0x25 time.(*Timer).Reset(0x0, 0x4e5904f, 0x1) src/pkg/time/sleep.go:81 +0x42 main.func·001() race.go:14 +0xe3 created by time.goFunc src/pkg/time/sleep.go:122 +0x48   这里发生了什么？在启用了竞态检测器的情况下运行程序更具启发性:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  ================== WARNING: DATA RACE Read by goroutine 5: main.func·001() race.go:14 +0x169 Previous write by goroutine 1: main.main() race.go:15 +0x174 Goroutine 5 (running) created at time.goFunc() src/pkg/time/sleep.go:122 +0x56 timerproc() src/pkg/runtime/ztime_linux_amd64.c:181 +0x189 ==================   竞态检测器显示了问题：来自不同 goroutine 的变量 t 的异步读取和写入。如果初始计时器持续时间非常短，则计时器函数可能会在主 goroutine 将值分配给 t 之前触发，因此对 t.Reset 的调用将被设置为一个空的 t.\n要修正竞态条件，我们将代码更改为仅从主 goroutine 中读取和写入变量 t:\n1 2 3 4 5 6 7 8 9 10 11 12 13  func main() { start := time.Now() reset := make(chan bool) var t *time.Timer t = time.AfterFunc(randomDuration(), func() { fmt.Println(time.Now().Sub(start)) reset  true }) for time.Since(start)  5*time.Second { reset t.Reset(randomDuration()) } }   这里的主协程完全负责设置和重置 Timer t， 并且新的重置通道传达了以线程安全的方式重置计时器的需求.\n一种简单但效率较低的方法是 避免重复使用计时器.\n示例 2: ioutil.Discard 第二个示例更加微妙.\nThe ioutil package’s Discard object implements io.Writer, but discards all the data written to it. Think of it like /dev/null: a place to send data that you need to read but don’t want to store. It is commonly used with io.Copy to drain a reader, like this:\nioutil 包的 Discard 对象实现了 io.Writer, 但会丢弃所有写入其中的数据。可以将其视为 /dev/null: 发送需要读取但不想存储的数据的地方。它通常与 io.Copy 一起使用以消耗读取器，例如:\n1  io.Copy(ioutil.Discard, reader)   回顾 2011 年 7 月，Go 团队注意到以这种方式使用 Discard 效率低下: Copy 函数每次调用时都会分配一个内部 32 kB 的缓冲区，但与 Discard 一起使用时缓冲区是不必要的，因为我们只是丢弃读取的数据。我们认为这种对 Copy 和 Discard 的惯用用法应该不会那么昂贵.\n解决方法很简单。如果给定的 Writer 实现了 ReadFrom 方法，则 Copy 的调用如下:\n1  io.Copy(writer, reader)   被委派给这个可能更有效的调用:\n1  writer.ReadFrom(reader)   我们为 Discard 的基础类型 添加了 ReadFrom 方法 , 该基础类型具有内部缓冲区，该缓冲区在所有用户之间共享。我们知道从理论上讲这是一个竞争条件，但是由于所有对缓冲区的写操作都应该被丢弃，所以我们认为这并不重要.\n实施竞态检测器后，它立即被标记为恶意代码 (golang.org/issue/3970). 再次，我们认为代码可能有问题，但是决定竞争条件不是 “真实的”. 为了避免在我们的版本中出现 “误报”, 我们实现了一个 非安全版本 , 该功能仅在运行竞态检测器时才启用.\n但是几个月后，Brad 遇到了一个 令人沮丧和奇怪的错误. 经过几天的调试，他将其范围缩小到了由 ioutil.Discard 引起的实际竞争情况.\n这是 io/ioutil 中的已知代码，其中 Discard 是一个 devNull, 它在所有用户之间共享一个缓冲区.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  var blackHole [4096]byte // 共享缓冲区  func (devNull) ReadFrom(r io.Reader) (n int64, err error) { readSize := 0 for { readSize, err = r.Read(blackHole[:]) n += int64(readSize) if err != nil { if err == io.EOF { return n, nil } return } } }   Brad 的程序包括一个 trackDigestReader 类型，该类型包装一个 io.Reader 并记录其读取内容的哈希摘要.\n1 2 3 4 5 6 7 8 9 10  type trackDigestReader struct { r io.Reader h hash.Hash } func (t trackDigestReader) Read(p []byte) (n int, err error) { n, err = t.r.Read(p) t.h.Write(p[:n]) return }   例如，可以在读取文件时将其用于计算文件的 SHA-1 哈希:\n1 2 3  tdr := trackDigestReader{r: file, h: sha1.New()} io.Copy(writer, tdr) fmt.Printf(\"File hash: %x\", tdr.h.Sum(nil))   在某些情况下，将无可写数据 - 但仍需要对文件进行哈希处理 - 因此将使用 Discard:\n1  io.Copy(ioutil.Discard, tdr)   但是在这种情况下，blackHole 缓冲区不仅仅是一个黑洞；在从源 io.Reader 读取数据并将其写入 hash.Hash 的之间存储数据的合法位置。通过同时使用多个 goroutines 散列文件 (每个文件共享相同的 blackHole 缓冲区), 竞争条件通过破坏读取和散列之间的数据来表现出来。没有发生错误或惊慌，但哈希是错误的。脑壳疼！\n1 2 3 4 5 6 7 8  func (t trackDigestReader) Read(p []byte) (n int, err error) { // 缓冲区 p 是一个黑洞  n, err = t.r.Read(p) // p 可能再这里被另一个协程破坏了,  // 在上面读取和下面写入之间  t.h.Write(p[:n]) return }   通过为 ioutil.Discard 的每次使用分配唯一的缓冲区，消除了共享缓冲区上的竞态条件，最终修复了该错误 (golang.org/cl/7011047).\n机器字 知道了 race condition 的定义后，我们先来看一段代码考考大家，以下代码是否正确。\n代码 A\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  package main import \"fmt\" type myType struct { A int } func main() { c := make(chan bool) x := new(myType) go func() { x = new(myType) // write to x \tc  true }() _ = *x // read from x \tc fmt.Println(\"end\") }   这段代码主要做了两件事情，在第 10 行的一个 goroutine 中写入了一个指针到 x，在第 13 行的另一个 goroutine 中读取了该指针中的数据。这是一段抽象出的代码，在真实项目的这段代码对应的是一个 goroutine 的行为，这个 goroutine 会定时地发起 http 请求更新缓存中的数据，然后另一个 goroutine 会不停地读取这个缓存。\n那么这段代码到底正确与否呢？答案是：即是错误的又是正确的。下面我们来慢慢分析。\nData Race 首先我们来说说为什么这段代码是错误的。 代码 A 所犯的错误叫 data race ， data race 是 race condition 中的一种。我们来看下 go 官方对 data race 的定义。\nA data race occurs when two goroutines access the same variable concurrently and at least one of the accesses is a write.\n简单来说 data race 就是在两个线程同时访问一块内存并且其中至少有一个写的操作，而上述的代码 A 就是 data race 的标准错误示例。\n为什么代码 A 又是正确的？\n首先在解释代码 A 正确之前我们需要先知道一个概念 pointer size，也就是指针占用的内存大小。\nTypically, a pointer is the same size as your system’s architecture, 32 bits on a 32 bit system and 64 bits on a 64 bit system. If the argument is a scalar type (bool, int, float, etc), it’s going to be less than or equal to the size of a pointer. If the argument is a compound type, such as a struct with multiple fields, it’s likely the pointer is smaller.\n通常情况下指针的大小是小于等于系统的 machine word 的，比如 32 位的系统指针 size 是小于等于 32 bit，64位的系统指针 size 是小于等于 64 bit。由这一点我们可以知道代码 A 中的指针大小也是小于等于一个 machine word 的。下面是一段简单的代码，可以亲自实践一下查看 pointer 具体的大小。\n1 2 3 4 5 6 7 8 9 10 11 12 13  // 输出 4 // 运行 GOARCH=\"386\" go run test.go // 输出 8 // 运行 GOARCH=\"amd64\" go run test.go package main import ( \"fmt\" \"unsafe\" ) func main() { var a *int fmt.Println(unsafe.Sizeof(a)) }   代码 A 是正确的第二点原因是 CPU 寄存器的大小一定大于一个 machine word 。也就是说数据复制的最小单元大于一个 machine word。所以在复制指针的时候不可能出现复制到一半的中间状态，这也就解释了为什么代码 A 一定是正确的。\n为什么代码 A 是正确的却不应该使用呢？\n第一点原因是代码 A 出现了 data race，而 data race 的行为对编译器来说是 undefined 的。完全有可能谋个版本的编译器做了特殊的优化，从而导致这部分代码会出错。\n第二点原因是代码 A 的用法依赖了硬件的实现，而硬件的实现对于 go 来说是不可控的，也就是 “uncontrollable events”。\n第三点原因是人的因素。写下代码 A 的人可能是个资深的程序员十分了解了上述的原理以及风险。但是后续维护的程序员不一定也掌握了这些知识，他们可能会依样画葫芦，针对其他数据结构也都不加同步控制的进行并发读写，从而造成一些可怕的结果。\n第四点原因是使用同步控制能够提升代码的可读性，当你的代码在某个地方加了并发控制，比如锁以后，其他程序员立刻就会警觉起来，从而更加注意减少犯错的风险。\n第五点原因是 go 有一个 race condition 的检测工具 go run -race xxx.go ，也就是当加上 -race 选项，可以辅助检测可能存在的 race condition。虽然代码 A 是“无害”的，但是这个工具可以立即检测出存在 data race。如果大家长期忽略这个检查，等真正出现 date race 时就有可能会被忽略了，从而造成危险。\n正确的做法\n所以在并发编程中正确的做法是一定要使用同步控制，比如互斥锁、channel、以及 sync/atomic。个人我很喜欢 atomic 这个包，它的性能是三者最好的。\n自增不是原子操作 让我们写一个非常的简单的包含竞态条件内置竞态检测代码的程序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  package main import ( \"fmt\" \"sync\" ) var Wait sync.WaitGroup var Counter int = 0 func main() { for routine := 1; routine  2; routine++ { Wait.Add(1) go Routine(routine) } Wait.Wait() fmt.Printf(\"Final Counter: %d\\n\", Counter) } func Routine(id int) { for count := 0; count  2; count++ { value := Counter value++ Counter = value } Wait.Done() }   这个程序看起来没有问题。它创建了两个协程，每一个协程都会增加全局变量 Counter 两次。当他们都运行结束后，程序显示全局变量 Counter 的值。当我运行这个程序的时候，他会显示正确答案 4。所以这个程序工作正常,但真的吗？\n让我们通过 Go 竞态检测运行这个代码，看看它会发现什么？ 在代码所在的目录打开终端，以 -race 参数编译代码。\n1  go build -race   然后程序输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  ================== WARNING: DATA RACE Read by goroutine 5: main.Routine() /Users/bill/Spaces/Test/src/test/main.go:29 +0x44 gosched0() /usr/local/go/src/pkg/runtime/proc.c:1218 +0x9f Previous write by goroutine 4: main.Routine() /Users/bill/Spaces/Test/src/test/main.go:33 +0x65 gosched0() /usr/local/go/src/pkg/runtime/proc.c:1218 +0x9f Goroutine 5 (running) created at: main.main() /Users/bill/Spaces/Test/src/test/main.go:17 +0x66 runtime.main() /usr/local/go/src/pkg/runtime/proc.c:182 +0x91 Goroutine 4 (finished) created at: main.main() /Users/bill/Spaces/Test/src/test/main.go:17 +0x66 runtime.main() /usr/local/go/src/pkg/runtime/proc.c:182 +0x91 ================== Final Counter: 4 Found 1 data race(s)   看起来，工具在代码中检测到竞争条件。如果你查看上面的竞争条件报告，你会看到针对程序的输出。全局变量 Counter 的值是 4。这就是这类的 bug 的难点所在，代码大部分情况是工作正常的，但错误的情况会随机产生。竞争检测告诉我们隐藏在代码中的糟糕问题。\n警告报告告诉我们问题发生的准确位置:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  Read by goroutine 5: main.Routine() /Users/bill/Spaces/Test/src/test/main.go:29 +0x44 gosched0() /usr/local/go/src/pkg/runtime/proc.c:1218 +0x9f value := Counter Previous write by goroutine 4: main.Routine() /Users/bill/Spaces/Test/src/test/main.go:33 +0x65 gosched0() /usr/local/go/src/pkg/runtime/proc.c:1218 +0x9f Counter = value Goroutine 5 (running) created at: main.main() /Users/bill/Spaces/Test/src/test/main.go:17 +0x66 runtime.main() /usr/local/go/src/pkg/runtime/proc.c:182 +0x91 go Routine(routine)   你能发现竞争检测器指出两行读和写全局变量 Counter 的代码。同时也指出生成协程的代码。\n让我们对代码进行简单修改，让竞争情况更容易暴露出来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  package main import ( \"fmt\" \"sync\" \"time\" ) var Wait sync.WaitGroup var Counter int = 0 func main() { for routine := 1; routine  2; routine++ { Wait.Add(1) go Routine(routine) } Wait.Wait() fmt.Printf(\"Final Counter: %d\\n\", Counter) } func Routine(id int) { for count := 0; count  2; count++ { value := Counter time.Sleep(1 * time.Nanosecond) value++ Counter = value } Wait.Done() }   我在循环中增加了一个纳秒的暂停。这个暂停正好位于协程读取全局变量 Couter 存储到本地副本之后。让我们运行这个程序看看在这种修改之后，全局变量 Counter 的值是什么？\n1  Final Counter: 2   循环中的暂停导致程序的失败。Counter 变量的值不再是 4 而是 2。发生了什么？ 让我们深挖代码看看为什么这个纳秒的暂停会导致这个 Bug。\n在没有暂停的情况下，代码运行如下图：\n没有暂停的情况下，第一个协程被生成，并且完成执行，紧接着第二个协程才开始运行。这就是为什么程序看起来像正确运行的原因，因为它在我的电脑上运行速度非常快，以至于代码自行排队运行。\n让我们看看在有暂停的情况下，代码如何运行:\n上图已经展示了所有必要的信息，因此我就没有把他全部画出来。这个暂停导致运行的两个协程之间进行了一次上下文切换。这次我们有一个完全不同的情况。让我们看看图中展示的代码:\n1 2 3 4 5 6 7  value := Counter time.Sleep(1 * time.Nanosecond) value++ Counter = value   在每一次循环的迭代过程中，全局变量 Counter 的值都被暂存到本地变量 value，本地的副本自增后，最终写回全局变量 Counter。如果这三行代码在没有中断的情况下，没有立即运行，那么程序就会出现问题。上面的图片展示了全局变量 Counter 的读取和上下文切换是如何导致问题的。\n在这幅图中，在被协程 1 增加的变量被写回全局变量 Counter 之前，协程 2 被唤醒并读取全局变量 Counter。实质上，这两个协程对全局Counter变量执行完全相同的读写操作，因此最终的结果才是 2。\n为了解决这个问题，你也许认为我们只需要将增加全局变量 Counter 的三行代码改写减少到一行即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  package main import ( \"fmt\" \"sync\" \"time\" ) var Wait sync.WaitGroup var Counter int = 0 func main() { for routine := 1; routine  2; routine++ { Wait.Add(1) go Routine(routine) } Wait.Wait() fmt.Printf(\"Final Counter: %d\\n\", Counter) } func Routine(id int) { for count := 0; count  2; count++ { Counter = Counter + 1 time.Sleep(1 * time.Nanosecond) } Wait.Done() }   当我们运行这个版本的代码的时候，我们会再次得到正确的结果:\n1  Final Counter: 4   如果我们启动竞争检测来运行该代码，上面出现的问题应该会消失:\n1  go build -race   并且输出为:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  ================== WARNING: DATA RACE Write by goroutine 5: main.Routine() /Users/bill/Spaces/Test/src/test/main.go:30 +0x44 gosched0() /usr/local/go/src/pkg/runtime/proc.c:1218 +0x9f Previous write by goroutine 4: main.Routine() /Users/bill/Spaces/Test/src/test/main.go:30 +0x44 gosched0() /usr/local/go/src/pkg/runtime/proc.c:1218 +0x9f Goroutine 5 (running) created at: main.main() /Users/bill/Spaces/Test/src/test/main.go:18 +0x66 runtime.main() /usr/local/go/src/pkg/runtime/proc.c:182 +0x91 Goroutine 4 (running) created at: main.main() /Users/bill/Spaces/Test/src/test/main.go:18 +0x66 runtime.main() /usr/local/go/src/pkg/runtime/proc.c:182 +0x91 ================== Final Counter: 4 Found 1 data race(s) 然而，在这三十行代码的程序中，我们仍然检测到一个竞争条件。 Write by goroutine 5: main.Routine() /Users/bill/Spaces/Test/src/test/main.go:30 +0x44 gosched0() /usr/local/go/src/pkg/runtime/proc.c:1218 +0x9f Counter = Counter + 1 Previous write by goroutine 4: main.Routine() /Users/bill/Spaces/Test/src/test/main.go:30 +0x44 gosched0() /usr/local/go/src/pkg/runtime/proc.c:1218 +0x9f Counter = Counter + 1 Goroutine 5 (running) created at: main.main() /Users/bill/Spaces/Test/src/test/main.go:18 +0x66 runtime.main() /usr/local/go/src/pkg/runtime/proc.c:182 +0x91 go Routine(routine)   使用一行代码进行增加操作的程序正确地运行了。但为什么代码仍然有一个竞态条件？ 不要被我们用于递增 Counter 变量的一行Go代码所欺骗。让我们看看这一行代码生成的汇编代码:\n1 2 3  0064 (./main.go:30) MOVQ Counter+0(SB),BX ; Copy the value of Counter to BX 0065 (./main.go:30) INCQ ,BX ; Increment the value of BX 0066 (./main.go:30) MOVQ BX,Counter+0(SB) ; Move the new value to Counter   实际上是执行这三行汇编代码增加 counter 变量。他们十分诡异地看起来像最初的 Go 代码。上下文切换可能发生在这三行汇编的中的任意一行后面。尽管这个程序正常工作了，但严格来说，Bug 仍然存在。\n尽管我使用的例子非常简单，它还是体现发现这种 Bug 的复杂性。任何一行由 Go 编译器产生的汇编代码都有可能因为下文切换而停止运行。我们的 Go 代码也许看起来能够安全地访问资源，实际上底层汇编代码可能漏洞百出。\n为了解决这类问题，我们需要确保读写全局变量 Counter 总是在任何其他协程访问该变量之前完成。管道(channle)能够帮助我们有序地访问资源。这一次，我会使用一个互斥锁(Mutex):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  package main import ( \"fmt\" \"sync\" \"time\" ) var Wait sync.WaitGroup var Counter int = 0 var Lock sync.Mutex func main() { for routine := 1; routine  2; routine++ { Wait.Add(1) go Routine(routine) } Wait.Wait() fmt.Printf(\"Final Counter: %d\\n\", Counter) } func Routine(id int) { for count := 0; count  2; count++ { Lock.Lock() value := Counter time.Sleep(1 * time.Nanosecond) value++ Counter = value Lock.Unlock() } Wait.Done() }   以竞态检测的模式，编译程序，查看运行结果:\n1 2  go build -race ./test   1  Final Counter: 4   这一次，我们得到了正确的结果，并且没有发现任何竞态条件。这个程序是没有问题的。互斥锁保护了在 Lock 和 Unlock 之间的代码，确保了一次只有一个协程执行该段代码。\n单例模式 下面这个demo就是一个常见的 懒汉式单例模式，依靠go的共享变量不需要担心可见性的问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  package main import ( \"fmt\" \"os\" \"strconv\" \"time\" ) var config map[string]string func main() { count, _ := strconv.Atoi(os.Args[1]) for x := 0; x  count; x++ { go getConfig() } time.After(time.Second) } func getConfig() map[string]string { if config == nil { fmt.Println(\"init config\") config = map[string]string{} return config } return config }   执行go run -race demo.go 100\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  sgcx015@172-15-68-151:~/go/code/com.anthony.http % go run -race cmd/once_demo.go 100 init config // load ================== WARNING: DATA RACE init config //load Write at 0x0000012109c0 by goroutine 7: // g7在22行写 main.getConfig() /Users/sgcx015/go/code/com.anthony.http/cmd/once_demo.go:22 +0xd2 Previous read at 0x0000012109c0 by goroutine 8: //g8在20行读 （race） main.getConfig() /Users/sgcx015/go/code/com.anthony.http/cmd/once_demo.go:20 +0x3e Goroutine 7 (running) created at:// 这些无效信息 main.main() /Users/sgcx015/go/code/com.anthony.http/cmd/once_demo.go:15 +0xae Goroutine 8 (running) created at: main.main() /Users/sgcx015/go/code/com.anthony.http/cmd/once_demo.go:15 +0xae ================== Found 1 data race(s) exit status 66   发现出现读写竞争了，那么对于我们这种写法来说，确实存在多个线程同时去load，所以加载了两次。那么我们的业务场景是无关紧要的，因为配置加载几次无所谓。\n​这里总结一下，race触发的条件不是同时写，而是读写同时发生，这个问题很严重，严重在哪呢，其实看一下tomic.Value就知道了，计算机64位的，8个字节，对于32位的机器，回去读两次。可能会出现一种情况是 a入32位字节，此时b读取了32位。然后a继续写入32位，此时发生的问题，就是读写不一致。所以atomic解决了这个问题。\n那么咱们也需要解决问题是让他加载一次。\n简单点，就是加个锁。然后双重检测一下。\n1 2 3 4 5 6 7 8 9 10 11 12 13  func getConfig() map[string]string { if config == nil { lock.Lock() defer lock.Unlock() if config != nil { return config } config = map[string]string{} fmt.Println(\"init config\") return config } return config }   还是出现了竞争读写的问题，必然的。\n1 2 3 4 5 6 7 8 9 10 11 12 13  sgcx015@172-15-68-151:~/go/code/com.anthony.http % go run -race cmd/once_demo.go 100 init config //加载一次 ================== WARNING: DATA RACE Read at 0x0000012109c0 by goroutine 8: main.getConfig() /Users/sgcx015/go/code/com.anthony.http/cmd/once_demo.go:24 +0x5b Previous write at 0x0000012109c0 by goroutine 7: main.getConfig() /Users/sgcx015/go/code/com.anthony.http/cmd/once_demo.go:30 +0xeb ================== Found 1 data race(s)   如何解决竞争呢，用atomic类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  import ( \"fmt\" \"os\" \"strconv\" \"sync/atomic\" \"time\" ) var config atomic.Value func main() { count, _ := strconv.Atoi(os.Args[1]) for x := 0; x  count; x++ { go getConfig() } time.After(time.Second * 2) } func getConfig() map[string]string { if config.Load() == nil { fmt.Println(\"init config\") config.Store(map[string]string{}) return config.Load().(map[string]string) } return config.Load().(map[string]string) }   执行: 发现确实没有竞争，原因很简单，就是atomic原子操作。然后load了两次\n1 2 3  ~/go/code/com.anthony.http % go run -race cmd/demo.go 1000 init config init config   结论 竞态检测器是检查并发程序正确性的强大工具。它不会发出误报，因此请认真对待其警告。但这仅与您的测试一样好。您必须确保它们充分利用代码的并发属性，以便竞态检测器能够执行其工作.\n参考 Go 并发编程——Race Condition\n在 Go 中发现竞态条件 (Race Conditions)\nGo -race是啥？ atomic解决了啥\n",
  "wordCount" : "8218",
  "inLanguage": "zh-cn",
  "datePublished": "2020-12-08T18:27:35+08:00",
  "dateModified": "2020-12-08T18:27:35+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/go%E4%B8%AD%E7%9A%84data-race/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Go中的Data-Race
    </h1>
    <div class="post-meta">December 8, 2020
</div>
  </header> 
  <div class="post-content"><h2 id="数据竞争与竞态条件">数据竞争与竞态条件<a hidden class="anchor" aria-hidden="true" href="#数据竞争与竞态条件">#</a></h2>
<h3 id="数据竞争">数据竞争<a hidden class="anchor" aria-hidden="true" href="#数据竞争">#</a></h3>
<p>定义：①多个线程对于同一个变量、②同时地、③进行读/写操作的现象并且④至少有一个线程进行写操作。（也就是说，如果所有线程都是只进行读操作，那么将不构成数据争用）</p>
<p>后果：如果发生了数据争用，读取该变量时得到的值将变得不可知，使得该多线程程序的运行结果将完全不可预测，可能直接崩溃。</p>
<p>如何防止：对于有可能被多个线程同时访问的变量使用排他访问控制，具体方法包括使用mutex（互斥量）和monitor（监视器），或者使用atomic变量。</p>
<p>例如，对一个非同步变量进行多个并发读取就可以了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">a</span> <span class="p">=</span> <span class="mi">3</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Thread B: %d\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Thread A: %d\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>即使打印顺序因执行而异，但由于两个线程都仅从数据读取，因此没有数据竞争。</p>
<p>如果现在我们可以a可变地访问其中一个线程，则将引入数据竞争：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="mi">3</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">a</span> <span class="p">=</span> <span class="mi">10</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Thread A: %d\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们可以通过引入互斥量来同步访问权限来解决此问题a：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="mi">3</span>
    <span class="kd">var</span> <span class="nx">m</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
        <span class="nx">a</span> <span class="p">=</span> <span class="mi">10</span>
        <span class="nx">m</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Thread A: %d\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
    <span class="nx">m</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>两个线程正在同时访问a，并且其中一个正在写入，但是由于访问是同步的，因此这不再是数据竞争。</p>
<h3 id="竞态条件">竞态条件<a hidden class="anchor" aria-hidden="true" href="#竞态条件">#</a></h3>
<p>相对于数据争用(data race)，竞态条件(race condition)指的是更加高层次的更加复杂的现象，一般需要在设计并行程序时进行细致入微的分析，才能确定。（也就是隐藏得更深）</p>
<p>定义：受各线程上代码执行的顺序和时机的影响，程序的运行结果产生（预料之外）的变化。</p>
<p>后果：如果存在竞态条件(race condition)，多次运行程序对于同一个输入将会有不同的结果，但结果并非完全不可预测，它将由输入数据和各线程的执行顺序共同决定。</p>
<p>如何预防：竞态条件产生的原因很多是对于同一个资源的一系列连续操作并不是原子性的，也就是说有可能在执行的中途被其他线程抢占，同时这个“其他线程”刚好也要访问这个资源。解决方法通常是：将这一系列操作作为一个critical section（临界区）。</p>
<p>从理论上讲，任何来自并发的可观察到的非确定性都可以视为 竞争条件，但实际上构成竞争条件的因素取决于我们希望程序尊重的属性。</p>
<p>让我们以以下程序为例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Thread B&#34;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Thread A&#34;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们将看到两种消息的某种随机交织：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">Thread</span> <span class="n">A</span>
<span class="n">Thread</span> <span class="n">A</span>
<span class="n">Thread</span> <span class="n">B</span>
<span class="n">Thread</span> <span class="n">A</span>
<span class="n">Thread</span> <span class="n">B</span>
<span class="n">Thread</span> <span class="n">B</span>
<span class="kc">...</span>
</code></pre></td></tr></table>
</div>
</div><p>如果我们希望程序尊重印刷的确切顺序，那么这可以认为是一种竞争条件。我们可以使用某种形式的同步来强制执行该打印顺序。</p>
<p>在实践中，即使执行不是确定性的，我们也不会将其视为竞争条件，因为这不是我们关心的属性。</p>
<p>总而言之，竞争条件是由于程序的并行执行而导致我们的程序应具有的某些特性的违反。</p>
<h2 id="介绍">介绍<a hidden class="anchor" aria-hidden="true" href="#介绍">#</a></h2>
<p>竞赛条件 是最隐蔽和难以捉摸的编程错误之一。它们通常会导致不稳定和神秘的故障，通常是在将代码部署到生产中之后很长时间了。尽管 Go 的并发机制使编写干净的并发代码变得容易，但它们并不能防止竞争情况。需要谨慎，勤奋和测试。工具可以提供帮助.</p>
<p>我们很高兴地宣布 Go 1.1 包含了 竞态检测器 , 这是一种用于在 Go 代码中查找竞争条件的新工具。当前可用于具有 64 位 x86 处理器的 Linux, OS X, 和 Windows 系统.</p>
<p>竞态检测器基于 C/C++ 的 ThreadSanitizer 运行时库 , 已用于检测 Google 内部代码库 和 Chromium. 该技术于 2012 年 9 月与 Go 集成在一起；从那之后，它在标准库中检测到 42 个竞态. 现在它是我们不断构建过程的一部分，在此过程中，它会不断捕获竞争条件.</p>
<h2 id="如何运行">如何运行<a hidden class="anchor" aria-hidden="true" href="#如何运行">#</a></h2>
<p>竞态探测器与 go 工具链集成在一起。设置 -race 命令行标志时，编译器将使用记录访问时间和访问方式的代码来对所有内存访问进行检测，而运行时库将监视对共享变量的非同步访问。当检测到这种 &ldquo;淫荡&rdquo; 行为时，将打印警告. (有关算法的详细信息，请参阅 本文)</p>
<p>由于其设计，竞态检测器只能在运行代码实际触发竞态条件时才检测竞态条件，这意味着在实际的工作负载下运行启用竞态的二进制文件非常重要。但是，启用竞态的二进制文件可以使用十倍于 CPU 和内存，因此始终启用竞态检测器是不切实际的。解决此难题的一种方法是在启用了竞态检测器的情况下运行一些测试。负载测试和集成测试是不错的选择，因为它们倾向于使用代码的并发部分。使用生产工作负载的另一种方法是在运行中的服务器池中部署一个启用了竞争的实例.</p>
<h2 id="使用竞态检测器">使用竞态检测器<a hidden class="anchor" aria-hidden="true" href="#使用竞态检测器">#</a></h2>
<p>竞态探测器与 Go 工具链完全集成在一起。要在启用竞态检测器的情况下构建代码，只需在命令行中添加 -race 标志:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">go</span> <span class="n">test</span> <span class="o">-</span><span class="n">race</span> <span class="n">mypkg</span>    <span class="o">//</span> 测试程序包
<span class="n">go</span> <span class="n">run</span> <span class="o">-</span><span class="n">race</span> <span class="n">mysrc.go</span>  <span class="o">//</span> 编译并运行程序
<span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">race</span> <span class="n">mycmd</span>   <span class="o">//</span> 构建命令
<span class="n">go</span> <span class="n">install</span> <span class="o">-</span><span class="n">race</span> <span class="n">mypkg</span> <span class="o">//</span> 安装程序包
</code></pre></td></tr></table>
</div>
</div><p>要自己尝试运行竞态检测器，请获取以下示例程序并运行:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">go</span> <span class="n">get</span> <span class="o">-</span><span class="n">race</span> <span class="n">golang.org</span><span class="o">/</span><span class="n">x</span><span class="o">/</span><span class="n">blog</span><span class="o">/</span><span class="n">support</span><span class="o">/</span><span class="n">racy</span>
<span class="n">racy</span>
</code></pre></td></tr></table>
</div>
</div><p>-race选项用于检测数据竞争，在使用了-race的情况下，go程序跑起来之后，如果发生数据竞争，它就能检测到，它就会一层一层地把错误栈打印出来，就像打印panic一样。通常用于开发。当然开启了该选项也未必能检测出潜在的数据竞争，当你的程序跑到数据竞争的片段它就会检测出来，你的程序可能有很多模块，当程序没有执行到数据竞争的地方那直到整个程序执行结束它也检测不出来。</p>
<h2 id="示例">示例<a hidden class="anchor" aria-hidden="true" href="#示例">#</a></h2>
<p>这里有竞态探测器检测到实际问题的两个示例.</p>
<h3 id="示例-1-timerreset">示例 1: Timer.Reset<a hidden class="anchor" aria-hidden="true" href="#示例-1-timerreset">#</a></h3>
<p>第一个示例是由竞态检测器发现的实际错误的简化版本。它使用计时器在 0 到 1 秒之间的随机持续时间后打印消息。如此重复五秒钟。它使用 time.AfterFunc 函数创建一个 Timer 作为第一个消息，然后使用 Reset 方法来调度下一条消息，每次重新使用 Timer.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nx">t</span> <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Timer</span>
    <span class="nx">t</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">AfterFunc</span><span class="p">(</span><span class="nf">randomDuration</span><span class="p">(),</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">start</span><span class="p">))</span>
        <span class="nx">t</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nf">randomDuration</span><span class="p">())</span>
    <span class="p">})</span>
    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">randomDuration</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Int63n</span><span class="p">(</span><span class="mf">1e9</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这看起来像是合理的代码，但是在某些情况下，它以令人惊讶的方式失败:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">panic</span><span class="o">:</span> <span class="n">runtime</span> <span class="n">error</span><span class="o">:</span> <span class="n">invalid</span> <span class="n">memory</span> <span class="n">address</span> <span class="n">or</span> <span class="n">nil</span> <span class="n">pointer</span> <span class="n">dereference</span>
<span class="n">[signal</span> <span class="mh">0xb</span> <span class="n">code</span><span class="o">=</span><span class="mh">0x1</span> <span class="n">addr</span><span class="o">=</span><span class="mh">0x8</span> <span class="n">pc</span><span class="o">=</span><span class="mh">0x41e38a</span><span class="n">]</span>

<span class="n">goroutine</span> <span class="m">4</span> <span class="n">[running]</span><span class="o">:</span>
<span class="nf">time.stopTimer</span><span class="p">(</span><span class="mh">0x8</span><span class="p">,</span> <span class="mh">0x12fe6b35d9472d96</span><span class="p">)</span>
    <span class="n">src</span><span class="o">/</span><span class="n">pkg</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">ztime_linux_amd64.c</span><span class="o">:</span><span class="m">35</span> <span class="m">+0</span><span class="n">x25</span>
<span class="nf">time.</span><span class="p">(</span><span class="o">*</span><span class="n">Timer</span><span class="p">)</span><span class="nf">.Reset</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x4e5904f</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">)</span>
    <span class="n">src</span><span class="o">/</span><span class="n">pkg</span><span class="o">/</span><span class="n">time</span><span class="o">/</span><span class="n">sleep.go</span><span class="o">:</span><span class="m">81</span> <span class="m">+0</span><span class="n">x42</span>
<span class="n">main.func</span>·<span class="m">001</span><span class="p">()</span>
    <span class="n">race.go</span><span class="o">:</span><span class="m">14</span> <span class="m">+0</span><span class="n">xe3</span>
<span class="n">created</span> <span class="n">by</span> <span class="n">time.goFunc</span>
    <span class="n">src</span><span class="o">/</span><span class="n">pkg</span><span class="o">/</span><span class="n">time</span><span class="o">/</span><span class="n">sleep.go</span><span class="o">:</span><span class="m">122</span> <span class="m">+0</span><span class="n">x48</span>
</code></pre></td></tr></table>
</div>
</div><p>这里发生了什么？在启用了竞态检测器的情况下运行程序更具启发性:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">==================</span>
<span class="n">WARNING</span><span class="o">:</span> <span class="n">DATA</span> <span class="n">RACE</span>
<span class="n">Read</span> <span class="n">by</span> <span class="n">goroutine</span> <span class="m">5</span><span class="o">:</span>
  <span class="n">main.func</span>·<span class="m">001</span><span class="p">()</span>
     <span class="n">race.go</span><span class="o">:</span><span class="m">14</span> <span class="m">+0</span><span class="n">x169</span>

<span class="n">Previous</span> <span class="n">write</span> <span class="n">by</span> <span class="n">goroutine</span> <span class="m">1</span><span class="o">:</span>
  <span class="nf">main.main</span><span class="p">()</span>
      <span class="n">race.go</span><span class="o">:</span><span class="m">15</span> <span class="m">+0</span><span class="n">x174</span>

<span class="n">Goroutine</span> <span class="m">5</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span> <span class="n">created</span> <span class="n">at</span>
  <span class="nf">time.goFunc</span><span class="p">()</span>
      <span class="n">src</span><span class="o">/</span><span class="n">pkg</span><span class="o">/</span><span class="n">time</span><span class="o">/</span><span class="n">sleep.go</span><span class="o">:</span><span class="m">122</span> <span class="m">+0</span><span class="n">x56</span>
  <span class="nf">timerproc</span><span class="p">()</span>
     <span class="n">src</span><span class="o">/</span><span class="n">pkg</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">ztime_linux_amd64.c</span><span class="o">:</span><span class="m">181</span> <span class="m">+0</span><span class="n">x189</span>
<span class="o">==================</span>
</code></pre></td></tr></table>
</div>
</div><p>竞态检测器显示了问题：来自不同 goroutine 的变量 t 的异步读取和写入。如果初始计时器持续时间非常短，则计时器函数可能会在主 goroutine 将值分配给 t 之前触发，因此对 t.Reset 的调用将被设置为一个空的 t.</p>
<p>要修正竞态条件，我们将代码更改为仅从主 goroutine 中读取和写入变量 t:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
    <span class="nx">reset</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">t</span> <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Timer</span>
    <span class="nx">t</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">AfterFunc</span><span class="p">(</span><span class="nf">randomDuration</span><span class="p">(),</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">start</span><span class="p">))</span>
        <span class="nx">reset</span> <span class="o">&lt;-</span> <span class="kc">true</span>
    <span class="p">})</span>
    <span class="k">for</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">start</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="p">{</span>
        <span class="o">&lt;-</span><span class="nx">reset</span>
        <span class="nx">t</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nf">randomDuration</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里的主协程完全负责设置和重置 Timer t， 并且新的重置通道传达了以线程安全的方式重置计时器的需求.</p>
<p>一种简单但效率较低的方法是 避免重复使用计时器.</p>
<h3 id="示例-2-ioutildiscard">示例 2: ioutil.Discard<a hidden class="anchor" aria-hidden="true" href="#示例-2-ioutildiscard">#</a></h3>
<p>第二个示例更加微妙.</p>
<p>The ioutil package&rsquo;s Discard object implements io.Writer, but discards all the data written to it. Think of it like /dev/null: a place to send data that you need to read but don&rsquo;t want to store. It is commonly used with io.Copy to drain a reader, like this:</p>
<p>ioutil 包的 Discard 对象实现了 io.Writer, 但会丢弃所有写入其中的数据。可以将其视为 /dev/null: 发送需要读取但不想存储的数据的地方。它通常与 io.Copy 一起使用以消耗读取器，例如:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">ioutil</span><span class="p">.</span><span class="nx">Discard</span><span class="p">,</span> <span class="nx">reader</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>回顾 2011 年 7 月，Go 团队注意到以这种方式使用 Discard 效率低下: Copy 函数每次调用时都会分配一个内部 32 kB 的缓冲区，但与 Discard 一起使用时缓冲区是不必要的，因为我们只是丢弃读取的数据。我们认为这种对 Copy 和 Discard 的惯用用法应该不会那么昂贵.</p>
<p>解决方法很简单。如果给定的 Writer 实现了 ReadFrom 方法，则 Copy 的调用如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">writer</span><span class="p">,</span> <span class="nx">reader</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>被委派给这个可能更有效的调用:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">writer</span><span class="p">.</span><span class="nf">ReadFrom</span><span class="p">(</span><span class="nx">reader</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>我们为 Discard 的基础类型 添加了 ReadFrom 方法 , 该基础类型具有内部缓冲区，该缓冲区在所有用户之间共享。我们知道从理论上讲这是一个竞争条件，但是由于所有对缓冲区的写操作都应该被丢弃，所以我们认为这并不重要.</p>
<p>实施竞态检测器后，它立即被标记为恶意代码 (golang.org/issue/3970). 再次，我们认为代码可能有问题，但是决定竞争条件不是 &ldquo;真实的&rdquo;. 为了避免在我们的版本中出现 &ldquo;误报&rdquo;, 我们实现了一个 非安全版本 , 该功能仅在运行竞态检测器时才启用.</p>
<p>但是几个月后，Brad 遇到了一个 令人沮丧和奇怪的错误. 经过几天的调试，他将其范围缩小到了由 ioutil.Discard 引起的实际竞争情况.</p>
<p>这是 io/ioutil 中的已知代码，其中 Discard 是一个 devNull, 它在所有用户之间共享一个缓冲区.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">blackHole</span> <span class="p">[</span><span class="mi">4096</span><span class="p">]</span><span class="kt">byte</span> <span class="c1">// 共享缓冲区
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">devNull</span><span class="p">)</span> <span class="nf">ReadFrom</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">readSize</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">readSize</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">blackHole</span><span class="p">[:])</span>
        <span class="nx">n</span> <span class="o">+=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">readSize</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="kc">nil</span>
            <span class="p">}</span>
            <span class="k">return</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Brad 的程序包括一个 trackDigestReader 类型，该类型包装一个 io.Reader 并记录其读取内容的哈希摘要.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">trackDigestReader</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span>
    <span class="nx">h</span> <span class="nx">hash</span><span class="p">.</span><span class="nx">Hash</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">trackDigestReader</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">h</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">p</span><span class="p">[:</span><span class="nx">n</span><span class="p">])</span>
    <span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>例如，可以在读取文件时将其用于计算文件的 SHA-1 哈希:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">tdr</span> <span class="o">:=</span> <span class="nx">trackDigestReader</span><span class="p">{</span><span class="nx">r</span><span class="p">:</span> <span class="nx">file</span><span class="p">,</span> <span class="nx">h</span><span class="p">:</span> <span class="nx">sha1</span><span class="p">.</span><span class="nf">New</span><span class="p">()}</span>
<span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">writer</span><span class="p">,</span> <span class="nx">tdr</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;File hash: %x&#34;</span><span class="p">,</span> <span class="nx">tdr</span><span class="p">.</span><span class="nx">h</span><span class="p">.</span><span class="nf">Sum</span><span class="p">(</span><span class="kc">nil</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>在某些情况下，将无可写数据 - 但仍需要对文件进行哈希处理 - 因此将使用 Discard:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">ioutil</span><span class="p">.</span><span class="nx">Discard</span><span class="p">,</span> <span class="nx">tdr</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>但是在这种情况下，blackHole 缓冲区不仅仅是一个黑洞；在从源 io.Reader 读取数据并将其写入 hash.Hash 的之间存储数据的合法位置。通过同时使用多个 goroutines 散列文件 (每个文件共享相同的 blackHole 缓冲区), 竞争条件通过破坏读取和散列之间的数据来表现出来。没有发生错误或惊慌，但哈希是错误的。脑壳疼！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">trackDigestReader</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 缓冲区 p 是一个黑洞
</span><span class="c1"></span>    <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
    <span class="c1">// p 可能再这里被另一个协程破坏了,
</span><span class="c1"></span>    <span class="c1">// 在上面读取和下面写入之间
</span><span class="c1"></span>    <span class="nx">t</span><span class="p">.</span><span class="nx">h</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">p</span><span class="p">[:</span><span class="nx">n</span><span class="p">])</span>
    <span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>通过为 ioutil.Discard 的每次使用分配唯一的缓冲区，消除了共享缓冲区上的竞态条件，最终修复了该错误 (golang.org/cl/7011047).</p>
<h2 id="机器字">机器字<a hidden class="anchor" aria-hidden="true" href="#机器字">#</a></h2>
<p>知道了 race condition 的定义后，我们先来看一段代码考考大家，以下代码是否正确。</p>
<p>代码 A</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
<span class="kd">type</span> <span class="nx">myType</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">A</span> <span class="kt">int</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>
	<span class="nx">x</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">myType</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">myType</span><span class="p">)</span> <span class="c1">// write to x
</span><span class="c1"></span>		<span class="nx">c</span> <span class="o">&lt;-</span> <span class="kc">true</span>
	<span class="p">}()</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="o">*</span><span class="nx">x</span> <span class="c1">// read from x
</span><span class="c1"></span>	<span class="o">&lt;-</span><span class="nx">c</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;end&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这段代码主要做了两件事情，在第 10 行的一个 goroutine 中写入了一个指针到 x，在第 13 行的另一个 goroutine 中读取了该指针中的数据。这是一段抽象出的代码，在真实项目的这段代码对应的是一个 goroutine 的行为，这个 goroutine 会定时地发起 http 请求更新缓存中的数据，然后另一个 goroutine 会不停地读取这个缓存。</p>
<p>那么这段代码到底正确与否呢？答案是：即是错误的又是正确的。下面我们来慢慢分析。</p>
<h3 id="data-race">Data Race<a hidden class="anchor" aria-hidden="true" href="#data-race">#</a></h3>
<p>首先我们来说说为什么这段代码是错误的。 代码 A 所犯的错误叫 data race ， data race 是 race condition 中的一种。我们来看下 go 官方对 data race 的定义。</p>
<p>A data race occurs when two goroutines access the same variable concurrently and at least one of the accesses is a write.</p>
<p>简单来说 data race 就是在两个线程同时访问一块内存并且其中至少有一个写的操作，而上述的代码 A 就是 data race 的标准错误示例。</p>
<p>为什么代码 A 又是正确的？</p>
<p>首先在解释代码 A 正确之前我们需要先知道一个概念 pointer size，也就是指针占用的内存大小。</p>
<p>Typically, a pointer is the same size as your system’s architecture, 32 bits on a 32 bit system and 64 bits on a 64 bit system. If the argument is a scalar type (bool, int, float, etc), it’s going to be less than or equal to the size of a pointer. If the argument is a compound type, such as a struct with multiple fields, it’s likely the pointer is smaller.</p>
<p>通常情况下指针的大小是小于等于系统的 machine word 的，比如 32 位的系统指针 size 是小于等于 32 bit，64位的系统指针 size 是小于等于 64 bit。由这一点我们可以知道代码 A 中的指针大小也是小于等于一个 machine word 的。下面是一段简单的代码，可以亲自实践一下查看 pointer 具体的大小。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 输出 4
</span><span class="c1">// 运行 GOARCH=&#34;386&#34;  go run test.go
</span><span class="c1">// 输出 8
</span><span class="c1">// 运行 GOARCH=&#34;amd64&#34;  go run test.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;unsafe&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span> <span class="o">*</span><span class="kt">int</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>代码 A 是正确的第二点原因是 CPU 寄存器的大小一定大于一个 machine word 。也就是说数据复制的最小单元大于一个 machine word。所以在复制指针的时候不可能出现复制到一半的中间状态，这也就解释了为什么代码 A 一定是正确的。</p>
<p>为什么代码 A 是正确的却不应该使用呢？</p>
<p>第一点原因是代码 A 出现了 data race，而 data race 的行为对编译器来说是 undefined 的。完全有可能谋个版本的编译器做了特殊的优化，从而导致这部分代码会出错。</p>
<p>第二点原因是代码 A 的用法依赖了硬件的实现，而硬件的实现对于 go 来说是不可控的，也就是 &ldquo;uncontrollable events&rdquo;。</p>
<p>第三点原因是人的因素。写下代码 A 的人可能是个资深的程序员十分了解了上述的原理以及风险。但是后续维护的程序员不一定也掌握了这些知识，他们可能会依样画葫芦，针对其他数据结构也都不加同步控制的进行并发读写，从而造成一些可怕的结果。</p>
<p>第四点原因是使用同步控制能够提升代码的可读性，当你的代码在某个地方加了并发控制，比如锁以后，其他程序员立刻就会警觉起来，从而更加注意减少犯错的风险。</p>
<p>第五点原因是 go 有一个 race condition 的检测工具 go run -race xxx.go ，也就是当加上 -race 选项，可以辅助检测可能存在的 race condition。虽然代码 A 是“无害”的，但是这个工具可以立即检测出存在 data race。如果大家长期忽略这个检查，等真正出现 date race 时就有可能会被忽略了，从而造成危险。</p>
<p>正确的做法</p>
<p>所以在并发编程中正确的做法是一定要使用同步控制，比如互斥锁、channel、以及 sync/atomic。个人我很喜欢 atomic 这个包，它的性能是三者最好的。</p>
<h2 id="自增不是原子操作">自增不是原子操作<a hidden class="anchor" aria-hidden="true" href="#自增不是原子操作">#</a></h2>
<p>让我们写一个非常的简单的包含竞态条件内置竞态检测代码的程序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">Wait</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="kd">var</span> <span class="nx">Counter</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">0</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="k">for</span> <span class="nx">routine</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">routine</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">routine</span><span class="o">++</span> <span class="p">{</span>

        <span class="nx">Wait</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">go</span> <span class="nf">Routine</span><span class="p">(</span><span class="nx">routine</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">Wait</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Final Counter: %d\n&#34;</span><span class="p">,</span> <span class="nx">Counter</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Routine</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">for</span> <span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">count</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">count</span><span class="o">++</span> <span class="p">{</span>

        <span class="nx">value</span> <span class="o">:=</span> <span class="nx">Counter</span>
        <span class="nx">value</span><span class="o">++</span>
        <span class="nx">Counter</span> <span class="p">=</span> <span class="nx">value</span>
    <span class="p">}</span>

    <span class="nx">Wait</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个程序看起来没有问题。它创建了两个协程，每一个协程都会增加全局变量 Counter 两次。当他们都运行结束后，程序显示全局变量 Counter 的值。当我运行这个程序的时候，他会显示正确答案 4。所以这个程序工作正常,但真的吗？</p>
<p>让我们通过 Go 竞态检测运行这个代码，看看它会发现什么？ 在代码所在的目录打开终端，以 -race 参数编译代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">race</span>
</code></pre></td></tr></table>
</div>
</div><p>然后程序输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">==================</span>
<span class="n">WARNING</span><span class="o">:</span> <span class="n">DATA</span> <span class="n">RACE</span>
<span class="n">Read</span> <span class="n">by</span> <span class="n">goroutine</span> <span class="m">5</span><span class="o">:</span>
  <span class="nf">main.Routine</span><span class="p">()</span>
      <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">bill</span><span class="o">/</span><span class="n">Spaces</span><span class="o">/</span><span class="n">Test</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">test</span><span class="o">/</span><span class="n">main.go</span><span class="o">:</span><span class="m">29</span> <span class="m">+0</span><span class="n">x44</span>
  <span class="nf">gosched0</span><span class="p">()</span>
      <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">pkg</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">proc.c</span><span class="o">:</span><span class="m">1218</span> <span class="m">+0</span><span class="n">x9f</span>

<span class="n">Previous</span> <span class="n">write</span> <span class="n">by</span> <span class="n">goroutine</span> <span class="m">4</span><span class="o">:</span>
  <span class="nf">main.Routine</span><span class="p">()</span>
      <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">bill</span><span class="o">/</span><span class="n">Spaces</span><span class="o">/</span><span class="n">Test</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">test</span><span class="o">/</span><span class="n">main.go</span><span class="o">:</span><span class="m">33</span> <span class="m">+0</span><span class="n">x65</span>
  <span class="nf">gosched0</span><span class="p">()</span>
      <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">pkg</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">proc.c</span><span class="o">:</span><span class="m">1218</span> <span class="m">+0</span><span class="n">x9f</span>

<span class="n">Goroutine</span> <span class="m">5</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span> <span class="n">created</span> <span class="n">at</span><span class="o">:</span>
  <span class="nf">main.main</span><span class="p">()</span>
      <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">bill</span><span class="o">/</span><span class="n">Spaces</span><span class="o">/</span><span class="n">Test</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">test</span><span class="o">/</span><span class="n">main.go</span><span class="o">:</span><span class="m">17</span> <span class="m">+0</span><span class="n">x66</span>
  <span class="nf">runtime.main</span><span class="p">()</span>
      <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">pkg</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">proc.c</span><span class="o">:</span><span class="m">182</span> <span class="m">+0</span><span class="n">x91</span>

<span class="n">Goroutine</span> <span class="m">4</span> <span class="p">(</span><span class="n">finished</span><span class="p">)</span> <span class="n">created</span> <span class="n">at</span><span class="o">:</span>
  <span class="nf">main.main</span><span class="p">()</span>
      <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">bill</span><span class="o">/</span><span class="n">Spaces</span><span class="o">/</span><span class="n">Test</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">test</span><span class="o">/</span><span class="n">main.go</span><span class="o">:</span><span class="m">17</span> <span class="m">+0</span><span class="n">x66</span>
  <span class="nf">runtime.main</span><span class="p">()</span>
      <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">pkg</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">proc.c</span><span class="o">:</span><span class="m">182</span> <span class="m">+0</span><span class="n">x91</span>

<span class="o">==================</span>
<span class="n">Final</span> <span class="n">Counter</span><span class="o">:</span> <span class="m">4</span>
<span class="n">Found</span> <span class="m">1</span> <span class="n">data</span> <span class="nf">race</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>看起来，工具在代码中检测到竞争条件。如果你查看上面的竞争条件报告，你会看到针对程序的输出。全局变量 Counter 的值是 4。这就是这类的 bug 的难点所在，代码大部分情况是工作正常的，但错误的情况会随机产生。竞争检测告诉我们隐藏在代码中的糟糕问题。</p>
<p>警告报告告诉我们问题发生的准确位置:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">Read</span> <span class="n">by</span> <span class="n">goroutine</span> <span class="m">5</span><span class="o">:</span>
  <span class="nf">main.Routine</span><span class="p">()</span>
      <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">bill</span><span class="o">/</span><span class="n">Spaces</span><span class="o">/</span><span class="n">Test</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">test</span><span class="o">/</span><span class="n">main.go</span><span class="o">:</span><span class="m">29</span> <span class="m">+0</span><span class="n">x44</span>
  <span class="nf">gosched0</span><span class="p">()</span>
      <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">pkg</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">proc.c</span><span class="o">:</span><span class="m">1218</span> <span class="m">+0</span><span class="n">x9f</span>

        <span class="n">value</span> <span class="o">:=</span> <span class="n">Counter</span>

<span class="n">Previous</span> <span class="n">write</span> <span class="n">by</span> <span class="n">goroutine</span> <span class="m">4</span><span class="o">:</span>
  <span class="nf">main.Routine</span><span class="p">()</span>
      <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">bill</span><span class="o">/</span><span class="n">Spaces</span><span class="o">/</span><span class="n">Test</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">test</span><span class="o">/</span><span class="n">main.go</span><span class="o">:</span><span class="m">33</span> <span class="m">+0</span><span class="n">x65</span>
  <span class="nf">gosched0</span><span class="p">()</span>
      <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">pkg</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">proc.c</span><span class="o">:</span><span class="m">1218</span> <span class="m">+0</span><span class="n">x9f</span>

        <span class="n">Counter</span> <span class="o">=</span> <span class="n">value</span>

<span class="n">Goroutine</span> <span class="m">5</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span> <span class="n">created</span> <span class="n">at</span><span class="o">:</span>
  <span class="nf">main.main</span><span class="p">()</span>
      <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">bill</span><span class="o">/</span><span class="n">Spaces</span><span class="o">/</span><span class="n">Test</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">test</span><span class="o">/</span><span class="n">main.go</span><span class="o">:</span><span class="m">17</span> <span class="m">+0</span><span class="n">x66</span>
  <span class="nf">runtime.main</span><span class="p">()</span>
      <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">pkg</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">proc.c</span><span class="o">:</span><span class="m">182</span> <span class="m">+0</span><span class="n">x91</span>

        <span class="n">go</span> <span class="nf">Routine</span><span class="p">(</span><span class="n">routine</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>你能发现竞争检测器指出两行读和写全局变量 Counter 的代码。同时也指出生成协程的代码。</p>
<p>让我们对代码进行简单修改，让竞争情况更容易暴露出来。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;sync&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">Wait</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="kd">var</span> <span class="nx">Counter</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">0</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="k">for</span> <span class="nx">routine</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">routine</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">routine</span><span class="o">++</span> <span class="p">{</span>

        <span class="nx">Wait</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">go</span> <span class="nf">Routine</span><span class="p">(</span><span class="nx">routine</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">Wait</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Final Counter: %d\n&#34;</span><span class="p">,</span> <span class="nx">Counter</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Routine</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">for</span> <span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">count</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">count</span><span class="o">++</span> <span class="p">{</span>

        <span class="nx">value</span> <span class="o">:=</span> <span class="nx">Counter</span>
        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Nanosecond</span><span class="p">)</span>
        <span class="nx">value</span><span class="o">++</span>
        <span class="nx">Counter</span> <span class="p">=</span> <span class="nx">value</span>
    <span class="p">}</span>

    <span class="nx">Wait</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我在循环中增加了一个纳秒的暂停。这个暂停正好位于协程读取全局变量 Couter 存储到本地副本之后。让我们运行这个程序看看在这种修改之后，全局变量 Counter 的值是什么？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">Final</span> <span class="n">Counter</span><span class="o">:</span> <span class="m">2</span>
</code></pre></td></tr></table>
</div>
</div><p>循环中的暂停导致程序的失败。Counter 变量的值不再是 4 而是 2。发生了什么？ 让我们深挖代码看看为什么这个纳秒的暂停会导致这个 Bug。</p>
<p>在没有暂停的情况下，代码运行如下图：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201209233238.png" alt=""  />
</p>
<p>没有暂停的情况下，第一个协程被生成，并且完成执行，紧接着第二个协程才开始运行。这就是为什么程序看起来像正确运行的原因，因为它在我的电脑上运行速度非常快，以至于代码自行排队运行。</p>
<p>让我们看看在有暂停的情况下，代码如何运行:</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201209233417.png" alt=""  />
</p>
<p>上图已经展示了所有必要的信息，因此我就没有把他全部画出来。这个暂停导致运行的两个协程之间进行了一次上下文切换。这次我们有一个完全不同的情况。让我们看看图中展示的代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">value</span> <span class="o">:=</span> <span class="nx">Counter</span>

<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Nanosecond</span><span class="p">)</span>

<span class="nx">value</span><span class="o">++</span>

<span class="nx">Counter</span> <span class="p">=</span> <span class="nx">value</span>
</code></pre></td></tr></table>
</div>
</div><p>在每一次循环的迭代过程中，全局变量 Counter 的值都被暂存到本地变量 value，本地的副本自增后，最终写回全局变量 Counter。如果这三行代码在没有中断的情况下，没有立即运行，那么程序就会出现问题。上面的图片展示了全局变量 Counter 的读取和上下文切换是如何导致问题的。</p>
<p>在这幅图中，在被协程 1 增加的变量被写回全局变量 Counter 之前，协程 2 被唤醒并读取全局变量 Counter。实质上，这两个协程对全局Counter变量执行完全相同的读写操作，因此最终的结果才是 2。</p>
<p>为了解决这个问题，你也许认为我们只需要将增加全局变量 Counter 的三行代码改写减少到一行即可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;sync&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">Wait</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="kd">var</span> <span class="nx">Counter</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">0</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="k">for</span> <span class="nx">routine</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">routine</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">routine</span><span class="o">++</span> <span class="p">{</span>

        <span class="nx">Wait</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">go</span> <span class="nf">Routine</span><span class="p">(</span><span class="nx">routine</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">Wait</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Final Counter: %d\n&#34;</span><span class="p">,</span> <span class="nx">Counter</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Routine</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">for</span> <span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">count</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">count</span><span class="o">++</span> <span class="p">{</span>

        <span class="nx">Counter</span> <span class="p">=</span> <span class="nx">Counter</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Nanosecond</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">Wait</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当我们运行这个版本的代码的时候，我们会再次得到正确的结果:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">Final</span> <span class="n">Counter</span><span class="o">:</span> <span class="m">4</span>
</code></pre></td></tr></table>
</div>
</div><p>如果我们启动竞争检测来运行该代码，上面出现的问题应该会消失:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">race</span>
</code></pre></td></tr></table>
</div>
</div><p>并且输出为:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">==================</span>
<span class="n">WARNING</span><span class="o">:</span> <span class="n">DATA</span> <span class="n">RACE</span>
<span class="n">Write</span> <span class="n">by</span> <span class="n">goroutine</span> <span class="m">5</span><span class="o">:</span>
  <span class="nf">main.Routine</span><span class="p">()</span>
      <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">bill</span><span class="o">/</span><span class="n">Spaces</span><span class="o">/</span><span class="n">Test</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">test</span><span class="o">/</span><span class="n">main.go</span><span class="o">:</span><span class="m">30</span> <span class="m">+0</span><span class="n">x44</span>
  <span class="nf">gosched0</span><span class="p">()</span>
      <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">pkg</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">proc.c</span><span class="o">:</span><span class="m">1218</span> <span class="m">+0</span><span class="n">x9f</span>

<span class="n">Previous</span> <span class="n">write</span> <span class="n">by</span> <span class="n">goroutine</span> <span class="m">4</span><span class="o">:</span>
  <span class="nf">main.Routine</span><span class="p">()</span>
      <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">bill</span><span class="o">/</span><span class="n">Spaces</span><span class="o">/</span><span class="n">Test</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">test</span><span class="o">/</span><span class="n">main.go</span><span class="o">:</span><span class="m">30</span> <span class="m">+0</span><span class="n">x44</span>
  <span class="nf">gosched0</span><span class="p">()</span>
      <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">pkg</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">proc.c</span><span class="o">:</span><span class="m">1218</span> <span class="m">+0</span><span class="n">x9f</span>

<span class="n">Goroutine</span> <span class="m">5</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span> <span class="n">created</span> <span class="n">at</span><span class="o">:</span>
  <span class="nf">main.main</span><span class="p">()</span>
      <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">bill</span><span class="o">/</span><span class="n">Spaces</span><span class="o">/</span><span class="n">Test</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">test</span><span class="o">/</span><span class="n">main.go</span><span class="o">:</span><span class="m">18</span> <span class="m">+0</span><span class="n">x66</span>
  <span class="nf">runtime.main</span><span class="p">()</span>
      <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">pkg</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">proc.c</span><span class="o">:</span><span class="m">182</span> <span class="m">+0</span><span class="n">x91</span>

<span class="n">Goroutine</span> <span class="m">4</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span> <span class="n">created</span> <span class="n">at</span><span class="o">:</span>
  <span class="nf">main.main</span><span class="p">()</span>
      <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">bill</span><span class="o">/</span><span class="n">Spaces</span><span class="o">/</span><span class="n">Test</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">test</span><span class="o">/</span><span class="n">main.go</span><span class="o">:</span><span class="m">18</span> <span class="m">+0</span><span class="n">x66</span>
  <span class="nf">runtime.main</span><span class="p">()</span>
      <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">pkg</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">proc.c</span><span class="o">:</span><span class="m">182</span> <span class="m">+0</span><span class="n">x91</span>

<span class="o">==================</span>
<span class="n">Final</span> <span class="n">Counter</span><span class="o">:</span> <span class="m">4</span>
<span class="n">Found</span> <span class="m">1</span> <span class="n">data</span> <span class="nf">race</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
然而，在这三十行代码的程序中，我们仍然检测到一个竞争条件。

<span class="n">Write</span> <span class="n">by</span> <span class="n">goroutine</span> <span class="m">5</span><span class="o">:</span>
  <span class="nf">main.Routine</span><span class="p">()</span>
      <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">bill</span><span class="o">/</span><span class="n">Spaces</span><span class="o">/</span><span class="n">Test</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">test</span><span class="o">/</span><span class="n">main.go</span><span class="o">:</span><span class="m">30</span> <span class="m">+0</span><span class="n">x44</span>
  <span class="nf">gosched0</span><span class="p">()</span>
      <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">pkg</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">proc.c</span><span class="o">:</span><span class="m">1218</span> <span class="m">+0</span><span class="n">x9f</span>

        <span class="n">Counter</span> <span class="o">=</span> <span class="n">Counter</span> <span class="o">+</span> <span class="m">1</span>

<span class="n">Previous</span> <span class="n">write</span> <span class="n">by</span> <span class="n">goroutine</span> <span class="m">4</span><span class="o">:</span>
  <span class="nf">main.Routine</span><span class="p">()</span>
      <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">bill</span><span class="o">/</span><span class="n">Spaces</span><span class="o">/</span><span class="n">Test</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">test</span><span class="o">/</span><span class="n">main.go</span><span class="o">:</span><span class="m">30</span> <span class="m">+0</span><span class="n">x44</span>
  <span class="nf">gosched0</span><span class="p">()</span>
      <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">pkg</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">proc.c</span><span class="o">:</span><span class="m">1218</span> <span class="m">+0</span><span class="n">x9f</span>

        <span class="n">Counter</span> <span class="o">=</span> <span class="n">Counter</span> <span class="o">+</span> <span class="m">1</span>

<span class="n">Goroutine</span> <span class="m">5</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span> <span class="n">created</span> <span class="n">at</span><span class="o">:</span>
  <span class="nf">main.main</span><span class="p">()</span>
      <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">bill</span><span class="o">/</span><span class="n">Spaces</span><span class="o">/</span><span class="n">Test</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">test</span><span class="o">/</span><span class="n">main.go</span><span class="o">:</span><span class="m">18</span> <span class="m">+0</span><span class="n">x66</span>
  <span class="nf">runtime.main</span><span class="p">()</span>
      <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">pkg</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">proc.c</span><span class="o">:</span><span class="m">182</span> <span class="m">+0</span><span class="n">x91</span>

        <span class="n">go</span> <span class="nf">Routine</span><span class="p">(</span><span class="n">routine</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>使用一行代码进行增加操作的程序正确地运行了。但为什么代码仍然有一个竞态条件？ 不要被我们用于递增 Counter 变量的一行Go代码所欺骗。让我们看看这一行代码生成的汇编代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="m">0064</span> <span class="p">(</span><span class="n">./main.go</span><span class="o">:</span><span class="m">30</span><span class="p">)</span> <span class="n">MOVQ</span> <span class="n">Counter</span><span class="m">+0</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span><span class="n">BX</span> <span class="p">;</span> <span class="n">Copy</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="n">Counter</span> <span class="n">to</span> <span class="n">BX</span>
<span class="m">0065</span> <span class="p">(</span><span class="n">./main.go</span><span class="o">:</span><span class="m">30</span><span class="p">)</span> <span class="n">INCQ</span> <span class="p">,</span><span class="n">BX</span>              <span class="p">;</span> <span class="n">Increment</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="n">BX</span>
<span class="m">0066</span> <span class="p">(</span><span class="n">./main.go</span><span class="o">:</span><span class="m">30</span><span class="p">)</span> <span class="n">MOVQ</span> <span class="n">BX</span><span class="p">,</span><span class="n">Counter</span><span class="m">+0</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span> <span class="p">;</span> <span class="n">Move</span> <span class="n">the</span> <span class="n">new</span> <span class="n">value</span> <span class="n">to</span> <span class="n">Counter</span>
</code></pre></td></tr></table>
</div>
</div><p>实际上是执行这三行汇编代码增加 counter 变量。他们十分诡异地看起来像最初的 Go 代码。上下文切换可能发生在这三行汇编的中的任意一行后面。尽管这个程序正常工作了，但严格来说，Bug 仍然存在。</p>
<p>尽管我使用的例子非常简单，它还是体现发现这种 Bug 的复杂性。任何一行由 Go 编译器产生的汇编代码都有可能因为下文切换而停止运行。我们的 Go 代码也许看起来能够安全地访问资源，实际上底层汇编代码可能漏洞百出。</p>
<p>为了解决这类问题，我们需要确保读写全局变量 Counter 总是在任何其他协程访问该变量之前完成。管道(channle)能够帮助我们有序地访问资源。这一次，我会使用一个互斥锁(Mutex):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;sync&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">Wait</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="kd">var</span> <span class="nx">Counter</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kd">var</span> <span class="nx">Lock</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="k">for</span> <span class="nx">routine</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">routine</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">routine</span><span class="o">++</span> <span class="p">{</span>

        <span class="nx">Wait</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">go</span> <span class="nf">Routine</span><span class="p">(</span><span class="nx">routine</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">Wait</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Final Counter: %d\n&#34;</span><span class="p">,</span> <span class="nx">Counter</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Routine</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">for</span> <span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">count</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">count</span><span class="o">++</span> <span class="p">{</span>

        <span class="nx">Lock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>

        <span class="nx">value</span> <span class="o">:=</span> <span class="nx">Counter</span>
        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Nanosecond</span><span class="p">)</span>
        <span class="nx">value</span><span class="o">++</span>
        <span class="nx">Counter</span> <span class="p">=</span> <span class="nx">value</span>

        <span class="nx">Lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="nx">Wait</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>以竞态检测的模式，编译程序，查看运行结果:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">race</span>
<span class="n">./test</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">Final</span> <span class="n">Counter</span><span class="o">:</span> <span class="m">4</span>
</code></pre></td></tr></table>
</div>
</div><p>这一次，我们得到了正确的结果，并且没有发现任何竞态条件。这个程序是没有问题的。互斥锁保护了在 Lock 和 Unlock 之间的代码，确保了一次只有一个协程执行该段代码。</p>
<h2 id="单例模式">单例模式<a hidden class="anchor" aria-hidden="true" href="#单例模式">#</a></h2>
<p>下面这个demo就是一个常见的  懒汉式单例模式，依靠go的共享变量不需要担心可见性的问题。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">config</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">count</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
	<span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="nf">getConfig</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">getConfig</span><span class="p">()</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">config</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;init config&#34;</span><span class="p">)</span>
		<span class="nx">config</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{}</span>
		<span class="k">return</span> <span class="nx">config</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">config</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>执行<code>go run -race demo.go 100</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">sgcx015</span><span class="o">@</span><span class="m">172-15-68-151</span><span class="o">:~/</span><span class="n">go</span><span class="o">/</span><span class="n">code</span><span class="o">/</span><span class="n">com.anthony.http</span> % <span class="n">go</span> <span class="n">run</span> <span class="o">-</span><span class="n">race</span> <span class="n">cmd</span><span class="o">/</span><span class="n">once_demo.go</span> <span class="m">100</span>
<span class="n">init</span> <span class="n">config</span> <span class="o">//</span> <span class="n">load</span>
<span class="o">==================</span>
<span class="n">WARNING</span><span class="o">:</span> <span class="n">DATA</span> <span class="n">RACE</span>
<span class="n">init</span> <span class="n">config</span> <span class="o">//</span><span class="n">load</span>
<span class="n">Write</span> <span class="n">at</span> <span class="mh">0x0000012109c0</span> <span class="n">by</span> <span class="n">goroutine</span> <span class="m">7</span><span class="o">:</span> <span class="o">//</span> <span class="n">g7在22行写</span>
  <span class="nf">main.getConfig</span><span class="p">()</span>
      <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">sgcx015</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">code</span><span class="o">/</span><span class="n">com.anthony.http</span><span class="o">/</span><span class="n">cmd</span><span class="o">/</span><span class="n">once_demo.go</span><span class="o">:</span><span class="m">22</span> <span class="m">+0</span><span class="n">xd2</span>

<span class="n">Previous</span> <span class="n">read</span> <span class="n">at</span> <span class="mh">0x0000012109c0</span> <span class="n">by</span> <span class="n">goroutine</span> <span class="m">8</span><span class="o">:</span> <span class="o">//</span><span class="n">g8在20行读</span> （<span class="n">race</span>）
  <span class="nf">main.getConfig</span><span class="p">()</span>
      <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">sgcx015</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">code</span><span class="o">/</span><span class="n">com.anthony.http</span><span class="o">/</span><span class="n">cmd</span><span class="o">/</span><span class="n">once_demo.go</span><span class="o">:</span><span class="m">20</span> <span class="m">+0</span><span class="n">x3e</span>

<span class="n">Goroutine</span> <span class="m">7</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span> <span class="n">created</span> <span class="n">at</span><span class="o">://</span> 这些无效信息
  <span class="nf">main.main</span><span class="p">()</span>
      <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">sgcx015</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">code</span><span class="o">/</span><span class="n">com.anthony.http</span><span class="o">/</span><span class="n">cmd</span><span class="o">/</span><span class="n">once_demo.go</span><span class="o">:</span><span class="m">15</span> <span class="m">+0</span><span class="n">xae</span>

<span class="n">Goroutine</span> <span class="m">8</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span> <span class="n">created</span> <span class="n">at</span><span class="o">:</span>
  <span class="nf">main.main</span><span class="p">()</span>
      <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">sgcx015</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">code</span><span class="o">/</span><span class="n">com.anthony.http</span><span class="o">/</span><span class="n">cmd</span><span class="o">/</span><span class="n">once_demo.go</span><span class="o">:</span><span class="m">15</span> <span class="m">+0</span><span class="n">xae</span>
<span class="o">==================</span>
<span class="n">Found</span> <span class="m">1</span> <span class="n">data</span> <span class="nf">race</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">exit</span> <span class="n">status</span> <span class="m">66</span>
</code></pre></td></tr></table>
</div>
</div><p>发现出现读写竞争了，那么对于我们这种写法来说，确实存在多个线程同时去load，所以加载了两次。那么我们的业务场景是无关紧要的，因为配置加载几次无所谓。</p>
<p>​这里总结一下，race触发的条件不是同时写，而是读写同时发生，这个问题很严重，严重在哪呢，其实看一下tomic.Value就知道了，计算机64位的，8个字节，对于32位的机器，回去读两次。可能会出现一种情况是 a入32位字节，此时b读取了32位。然后a继续写入32位，此时发生的问题，就是读写不一致。所以atomic解决了这个问题。</p>
<p>那么咱们也需要解决问题是让他加载一次。</p>
<p>简单点，就是加个锁。然后双重检测一下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">getConfig</span><span class="p">()</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">config</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">lock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">defer</span> <span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">config</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">config</span>
		<span class="p">}</span>
		<span class="nx">config</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{}</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;init config&#34;</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">config</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">config</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>还是出现了竞争读写的问题，必然的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">sgcx015</span><span class="o">@</span><span class="m">172-15-68-151</span><span class="o">:~/</span><span class="n">go</span><span class="o">/</span><span class="n">code</span><span class="o">/</span><span class="n">com.anthony.http</span> % <span class="n">go</span> <span class="n">run</span> <span class="o">-</span><span class="n">race</span> <span class="n">cmd</span><span class="o">/</span><span class="n">once_demo.go</span> <span class="m">100</span>
<span class="n">init</span> <span class="n">config</span> <span class="o">//</span>加载一次
<span class="o">==================</span>
<span class="n">WARNING</span><span class="o">:</span> <span class="n">DATA</span> <span class="n">RACE</span>
<span class="n">Read</span> <span class="n">at</span> <span class="mh">0x0000012109c0</span> <span class="n">by</span> <span class="n">goroutine</span> <span class="m">8</span><span class="o">:</span>
  <span class="nf">main.getConfig</span><span class="p">()</span>
      <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">sgcx015</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">code</span><span class="o">/</span><span class="n">com.anthony.http</span><span class="o">/</span><span class="n">cmd</span><span class="o">/</span><span class="n">once_demo.go</span><span class="o">:</span><span class="m">24</span> <span class="m">+0</span><span class="n">x5b</span>

<span class="n">Previous</span> <span class="n">write</span> <span class="n">at</span> <span class="mh">0x0000012109c0</span> <span class="n">by</span> <span class="n">goroutine</span> <span class="m">7</span><span class="o">:</span>
  <span class="nf">main.getConfig</span><span class="p">()</span>
      <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">sgcx015</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">code</span><span class="o">/</span><span class="n">com.anthony.http</span><span class="o">/</span><span class="n">cmd</span><span class="o">/</span><span class="n">once_demo.go</span><span class="o">:</span><span class="m">30</span> <span class="m">+0</span><span class="n">xeb</span>
<span class="o">==================</span>
<span class="n">Found</span> <span class="m">1</span> <span class="n">data</span> <span class="nf">race</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如何解决竞争呢，用atomic类。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
	<span class="s">&#34;sync/atomic&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">config</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Value</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">count</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
	<span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="nf">getConfig</span><span class="p">()</span>

	<span class="p">}</span>
	<span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">getConfig</span><span class="p">()</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">config</span><span class="p">.</span><span class="nf">Load</span><span class="p">()</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;init config&#34;</span><span class="p">)</span>
		<span class="nx">config</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{})</span>
		<span class="k">return</span> <span class="nx">config</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">config</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>执行: 发现确实没有竞争，原因很简单，就是atomic原子操作。然后load了两次</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="err">~</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">code</span><span class="o">/</span><span class="nx">com</span><span class="p">.</span><span class="nx">anthony</span><span class="p">.</span><span class="nx">http</span> <span class="o">%</span> <span class="k">go</span> <span class="nx">run</span> <span class="o">-</span><span class="nx">race</span> <span class="nx">cmd</span><span class="o">/</span><span class="nx">demo</span><span class="p">.</span><span class="k">go</span> <span class="mi">1000</span>
<span class="nx">init</span> <span class="nx">config</span>
<span class="nx">init</span> <span class="nx">config</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="结论">结论<a hidden class="anchor" aria-hidden="true" href="#结论">#</a></h2>
<p>竞态检测器是检查并发程序正确性的强大工具。它不会发出误报，因此请认真对待其警告。但这仅与您的测试一样好。您必须确保它们充分利用代码的并发属性，以便竞态检测器能够执行其工作.</p>
<h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<p><a href="https://zhuanlan.zhihu.com/p/96404744">Go 并发编程——Race Condition</a><br>
<a href="https://studygolang.com/articles/15349">在 Go 中发现竞态条件 (Race Conditions)</a><br>
<a href="https://juejin.cn/post/6844903823878651917">Go -race是啥？ atomic解决了啥</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go/">Go</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
