<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>cron库源码剖析 | Forz Blog</title>
<meta name="keywords" content="cron" />
<meta name="description" content="Cron表达式 基本cron格式: 1 2 3 4 5 6 7 8 # cron格式說明 # ┌──分鐘（0 - 59） # │ ┌──小時（0 - 23） # | │ ┌──日（1 - 31">
<meta name="author" content="">
<link rel="canonical" href="/post/cron%E5%BA%93%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="cron库源码剖析" />
<meta property="og:description" content="Cron表达式 基本cron格式: 1 2 3 4 5 6 7 8 # cron格式說明 # ┌──分鐘（0 - 59） # │ ┌──小時（0 - 23） # | │ ┌──日（1 - 31" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/cron%E5%BA%93%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-10-15T11:19:03&#43;00:00" />
<meta property="article:modified_time" content="2019-10-15T11:19:03&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="cron库源码剖析"/>
<meta name="twitter:description" content="Cron表达式 基本cron格式: 1 2 3 4 5 6 7 8 # cron格式說明 # ┌──分鐘（0 - 59） # │ ┌──小時（0 - 23） # | │ ┌──日（1 - 31"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "cron库源码剖析",
      "item": "/post/cron%E5%BA%93%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "cron库源码剖析",
  "name": "cron库源码剖析",
  "description": "Cron表达式 基本cron格式: 1 2 3 4 5 6 7 8 # cron格式說明 # ┌──分鐘（0 - 59） # │ ┌──小時（0 - 23） # | │ ┌──日（1 - 31",
  "keywords": [
    "cron"
  ],
  "articleBody": "Cron表达式 基本cron格式:\n1 2 3 4 5 6 7 8  # cron格式說明 # ┌──分鐘（0 - 59） # │ ┌──小時（0 - 23） # | │ ┌──日（1 - 31） # | | | ┌─月（1 - 12） # | | | | ┌─星期（0 - 7，星期日=0或7） # | | | | | # * * * * * 被執行的命令   注：\n 在“星期域”（第五个域），0和7都被视为星期日。 不很直观的用法：如果日期和星期同时被设置，那么其中的一个条件被满足时，指令便会被运行。 前5个域称之分时日月周，可方便个人记忆。  从第六个域起，指明要运行的命令。\n特殊符号说明:\n  星号(*) 表示 cron 表达式能匹配该字段的所有值。如在第5个字段使用星号(month)，表示每个月\n  斜线(/) 表示增长间隔，如第1个字段(minutes) 值是 3-59/15，表示每小时的第3分钟开始执行一次，之后每隔 15 分钟执行一次（即 3、18、33、48 这些时间点执行），这里也可以表示为：3/15\n  逗号(,) 用于枚举值，如第6个字段值是 MON,WED,FRI，表示 星期一、三、五 执行\n  连字号(-) 表示一个范围，如第3个字段的值为 9-17 表示 9am 到 5pm 直接每个小时（包括9和17）\n  问号(?) 只用于 日(Day of month) 和 星期(Day of week)，表示不指定值，可以用于代替 *\n  总结:\n预定义模式:\n举例:\n每分钟执行一次命令：\n1  * * * * * yourCommand   每小时的第2和第10分钟执行：\n1  2,10 * * * * yourCommand   每天上午9点到12点的第2和第10分钟执行：\n1  2,10 9-12 * * * yourCommand   每隔两天的上午9点到12点的第2和第10分钟执行：\n1  2,10 9-12 */2 * * yourCommand   每周一上午9点到12点的第2和第10分钟执行：\n1  2,10 9-12 * * 1 yourCommand   代码使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  package main import ( \"time\" \"log\" \"github.com/robfig/cron\" \"github.com/EDDYCJY/go-gin-example/models\" ) func main() { log.Println(\"Starting...\") c := cron.New() c.AddFunc(\"* * * * * *\", func() { log.Println(\"Run models.CleanAllTag...\") models.CleanAllTag() }) c.AddFunc(\"* * * * * *\", func() { log.Println(\"Run models.CleanAllArticle...\") models.CleanAllArticle() }) c.Start() t1 := time.NewTimer(time.Second * 10) for { select { case t1.C: t1.Reset(time.Second * 10) } } }   在这段程序中，我们做了如下的事情\n  cron.New() 会根据本地时间创建一个新（空白）的 Cron job runner\n  c.AddFunc()\nAddFunc 会向 Cron job runner 添加一个 func ，以按给定的时间表运行.首先解析时间表，如果填写有问题会直接 err，无误则将 func 添加到 Schedule 队列中等待执行\n  c.Start()\n在当前执行的程序中启动 Cron 调度程序。其实这里的主体是 goroutine + for + select + timer 的调度控制\n  设计思路 基本类型 Cron cron:包含一系列要执行的实体；支持暂停【stop】；添加实体等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // Cron keeps track of any number of entries, invoking the associated func as // specified by the schedule. It may be started, stopped, and the entries may // be inspected while running. // Cron保持任意数量的条目的轨道，调用相关的func时间表指定。它可以被启动，停止和条目，可运行的同时进行检查。 type Cron struct { entries []*Entry chain Chain stop chan struct{}// 控制 Cron 实例暂停 \tadd chan *Entry // 当 Cron 已经运行了，增加新的 Entity 是通过 add 这个 channel 实现的 \tremove chan EntryID snapshot chan chan []Entry // 获取当前所有 entity 的快照 \trunning bool// 当已经运行时为true；否则为false \tlogger Logger //日志 \trunningMu sync.Mutex location *time.Location// 所在地区(新增属性) \tparser Parser nextID EntryID jobWaiter sync.WaitGroup }   注意:\n Cron 结构没有导出任何成员。 有一个成员 stop，类型是 struct{}，即空结构体。  Entry Entry：调度实体\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  type Entry struct { // The schedule on which this job should be run.  // 负责调度当前 Entity 中的 Job 执行  Schedule Schedule // The next time the job will run. This is the zero time if Cron has not been  // started or this entry's schedule is unsatisfiable  // Job 下一次执行的时间  Next time.Time // The last time this job was run. This is the zero time if the job has never  // been run.  // 上一次执行时间  Prev time.Time // The Job to run.  // 要执行的 Job  Job Job } // Entry consists of a schedule and the func to execute on that schedule. type Entry struct { // ID is the cron-assigned ID of this entry, which may be used to look up a \t// snapshot or remove it. \tID EntryID //负责调度当前 Entity 中的 Job 执行 \t// Schedule on which this job should be run. \tSchedule Schedule // Job 下一次执行的时间 \t// Next time the job will run, or the zero time if Cron has not been \t// started or this entry's schedule is unsatisfiable \tNext time.Time // 上一次执行时间 \t// Prev is the last time this job was run, or the zero time if never. \tPrev time.Time // WrappedJob is the thing to run when the Schedule is activated. \tWrappedJob Job // 要执行的 Job \t// Job is the thing that was submitted to cron. \t// It is kept around so that user code that needs to get at the job later, \t// e.g. via Entries() can do so. \tJob Job }   Job Job：每一个实体包含一个需要运行的Job\n这是一个接口，只有一个方法：run\n1 2 3  type Job interface { Run() }   由于 Entity 中需要 Job 类型，因此，我们希望定期运行的任务，就需要实现 Job 接口。同时，由于 Job接口只有一个无参数无返回值的方法，为了使用方便，作者提供了一个类型：\n1 2 3 4 5  // A wrapper that turns a func() into a cron.Job type FuncJob func() func (f FuncJob) Run() { f() }   它通过简单的实现 Run() 方法来实现 Job 接口,这样，任何无参数无返回值的函数，通过强制类型转换为 FuncJob，就可以当作 Job 来使用了，AddFunc 方法 就是这么做的。所以需要修改带参数功能的job时从此处下手\nSchedule Schedule：每个实体包含一个调度器（Schedule）\n负责调度 Job 的执行。它也是一个接口。\n1 2 3 4 5 6 7  // The Schedule describes a job's duty cycle. type Schedule interface { // Return the next activation time, later than the given time.  // Next is invoked initially, and then each time the job is run.  // 返回同一 Entity 中的 Job 下一次执行的时间 \tNext(time.Time) time.Time }   Schedule 的具体实现通过解析 Cron 表达式得到。\n库中提供了 Schedule 的两个具体实现，分别是 SpecSchedule 和 ConstantDelaySchedule。\nSpecSchedule 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  // SpecSchedule specifies a duty cycle (to the second granularity), based on a // traditional crontab specification. It is computed initially and stored as bit sets. type SpecSchedule struct { // 表达式中锁表明的，秒，分，时，日，月，周，每个都是uint64  // Dom:Day of Month,Dow:Day of week  Second, Minute, Hour, Dom, Month, Dow uint64 } // bounds provides a range of acceptable values (plus a map of name to value). // 定义了表达式的结构体 type bounds struct { min, max uint names map[string]uint } // The bounds for each field. // 这样就能看出各个表达式的范围 var ( seconds = bounds{0, 59, nil} minutes = bounds{0, 59, nil} hours = bounds{0, 23, nil} dom = bounds{1, 31, nil} months = bounds{1, 12, map[string]uint{ \"jan\": 1, \"feb\": 2, \"mar\": 3, \"apr\": 4, \"may\": 5, \"jun\": 6, \"jul\": 7, \"aug\": 8, \"sep\": 9, \"oct\": 10, \"nov\": 11, \"dec\": 12, }} dow = bounds{0, 6, map[string]uint{ \"sun\": 0, \"mon\": 1, \"tue\": 2, \"wed\": 3, \"thu\": 4, \"fri\": 5, \"sat\": 6, }} ) const ( // Set the top bit if a star was included in the expression.  starBit = 1  63 )   从开始介绍的 Cron 表达式可以容易得知各个字段的意思，同时，对各种表达式的解析也会最终得到一个 SpecSchedule 的实例。库中的 Parse 返回的其实就是 SpecSchedule 的实例（当然也就实现了 Schedule 接口）。\n看了上面的东西肯定有人疑惑为什么秒分时这些都是定义了unit64,以及定义了一个常量starBit = 1 « 63这种写法，这是逻辑运算符。表示二进制1向左移动63位。原因如下：\ncron表达式是用来表示一系列时间的，而时间是无法逃脱自己的区间的:\n 分，秒 0 - 59 时 0 - 23 天/月 0 - 31 天/周 0 - 6 月0 - 11  这些本质上都是一个点集合，或者说是一个整数区间。 那么对于任意的整数区间 ，可以描述cron的如下部分规则。\n * | ? 任意 ， 对应区间上的所有点。 （ 额外注意 日/周 ， 日 / 月 的相互干扰。） 纯数字 ， 对应一个具体的点。 / 分割的两个数字 a , b， 区间上符合 a + n * b 的所有点 （ n = 0 )。 - 分割的两个数字， 对应这两个数字决定的区间内的所有点。 L | W 需要对于特定的时间特殊判断， 无法通用的对应到区间上的点。  至此， robfig/cron为什么不支持 L | W的原因已经明了了。去除这两条规则后， 其余的规则其实完全可以使用点的穷举来通用表示。 考虑到最大的区间也不过是60个点，那么使用一个uint64的整数的每一位来表示一个点便很合适了。所以定义unit64不为过\n下面是go中cron表达式的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  /* ------------------------------------------------------------ 第64位标记任意 ， 用于 日/周 ， 日 / 月 的相互干扰。 63 - 0 为 表示区间 [63 , 0] 的 每一个点。 ------------------------------------------------------------ 假设区间是 0 - 63 ， 则有如下的例子 ： 比如 0/3 的表示如下 ： (表示每隔两位为1) * / ? +---+--------------------------------------------------------+ | 0 | 1 0 0 1 0 0 1 ~~ ~~ 1 0 0 1 0 0 1 | +---+--------------------------------------------------------+ 63 ~ ~ ~~ 0 比如 2-5 的表示如下 ： (表示从右往左2-5位上都是1) * / ? +---+--------------------------------------------------------+ | 0 | 0 0 0 0 ~ ~ ~~ ~ 0 0 0 1 1 1 1 0 0 | +---+--------------------------------------------------------+ 63 ~ ~ ~~ 0 比如 * 的表示如下 ： (表示所有位置上都为1) * / ? +---+--------------------------------------------------------+ | 1 | 1 1 1 1 1 ~ ~ ~ 1 1 1 1 1 1 1 1 1 | +---+--------------------------------------------------------+ 63 ~ ~ ~~ 0 */   ConstantDelaySchedule 1 2 3 4 5  // ConstantDelaySchedule represents a simple recurring duty cycle, e.g. \"Every 5 minutes\". // It does not support jobs more frequent than once a second. type ConstantDelaySchedule struct { Delay time.Duration }   这是一个简单的循环调度器，如：每 5 分钟。注意，最小单位是秒，不能比秒还小，比如 毫秒。\n通过 Every 函数可以获取该类型的实例，如：\n1  constDelaySchedule := Every(5e9)   得到的是一个每 5 秒执行一次的调度器。\nCron 实例化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func New(opts ...Option) *Cron { c := \u0026Cron{ entries: nil, chain: NewChain(), add: make(chan *Entry), stop: make(chan struct{}), snapshot: make(chan chan []Entry), remove: make(chan EntryID), running: false, runningMu: sync.Mutex{}, logger: DefaultLogger, location: time.Local, parser: standardParser, } for _, opt := range opts { opt(c) } return c } // Option represents a modification to the default behavior of a Cron. type Option func(*Cron)   可见实例化时，成员使用的基本是默认值；\n成员方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 将 job 加入 Cron 中 // 如上所述，该方法只是简单的通过 FuncJob 类型强制转换 cmd，然后调用 AddJob 方法 func (c *Cron) AddFunc(spec string, cmd func()) error // 将 job 加入 Cron 中 // 通过 Parse 函数解析 cron 表达式 spec 的到调度器实例(Schedule)，之后调用 c.Schedule 方法 func (c *Cron) AddJob(spec string, cmd Job) error // 获取当前 Cron 总所有 Entities 的快照 func (c *Cron) Entries() []*Entry // 通过两个参数实例化一个 Entity，然后加入当前 Cron 中 // 注意：如果当前 Cron 未运行，则直接将该 entity 加入 Cron 中； // 否则，通过 add 这个成员 channel 将 entity 加入正在运行的 Cron 中 func (c *Cron) Schedule(schedule Schedule, cmd Job) // 新启动一个 goroutine 运行当前 Cron func (c *Cron) Start() // 通过给 stop 成员发送一个 struct{}{} 来停止当前 Cron，同时将 running 置为 false // 从这里知道，stop 只是通知 Cron 停止，因此往 channel 发一个值即可，而不关心值是多少 // 所以，成员 stop 定义为空 struct func (c *Cron) Stop()   AddFunc 从AddFunc函数说起带参数任务的实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // AddFunc adds a func to the Cron to be run on the given schedule. // The spec is parsed using the time zone of this Cron instance as the default. // An opaque ID is returned that can be used to later remove it. func (c *Cron) AddFunc(spec string, cmd func()) (EntryID, error) { return c.AddJob(spec, FuncJob(cmd)) } // AddJob adds a Job to the Cron to be run on the given schedule. // The spec is parsed using the time zone of this Cron instance as the default. // An opaque ID is returned that can be used to later remove it. func (c *Cron) AddJob(spec string, cmd Job) (EntryID, error) { schedule, err := c.parser.Parse(spec) if err != nil { return 0, err } return c.Schedule(schedule, cmd), nil }   AddFunc 含有两个参数，第一个是 cron表达式，这个不解释，第二个是func()类型参数cmd 即无参数无返回类型函数，下一步中直接将此参数强制转换为FuncJob类型，并调用AddJob函数\nFuncJob类型:\n1 2 3 4 5  // FuncJob is a wrapper that turns a func() into a cron.Job type FuncJob func() func (f FuncJob) Run() { f() }   由上述代码可知FuncJob为自定义类型，真实类型为 func()，此类型实现了一个Run()方法\nAddJob 首先 AddJob 函数的传入参数为一个string类型的cron表达式和一个Job类型的cmd参数，但在AddFunc函数中，我们传入的第二个参数为FuncJob类型，所以Job类型应该是一个接口，在解析了cron表达式无错误以后，调用Schedule方法将cmd添加进了调度器\nJob 类型:\n1 2 3 4  // Job is an interface for submitted cron jobs. type Job interface { Run() }   由此可知，Job是带有一个Run方法的接口类型，经过代码分析可以指定，cron定时调度时间到达时，将调用此方法，也就是意味着，任何实现了Run方法的实例，都可以作为AddJob函数的cmd参数，而Run方法所实现的内容就是你定时调度所需执行的任务(AddFunc函数只能添加无参数无返回的任务，太鸡肋了)，接下来我们就来实现一个带参数的任务添加\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  //定义一个类型 包含一个int类型参数和函数体 type funcIntJob struct { num int function func(int) } //实现这个类型的Run()方法 使得可以传入Job接口 func (this *funcIntJob) Run() { if nil != this.function { this.function(this.num) } } //非必须 返回一个urlServeJob指针 func newfuncIntJob(num int, function funcInt) *urlServeJob { instance := \u0026funcIntJob{ num: num, function: function, } return instance } //示例任务 func shownum(num int){ fmt.Println(num) } func main(){ var c = cron.New() job := newfuncIntJob(3, shownum) spec := \"*/5 * * * * ?\" c.AddJob(spec, job) c.Start() defer c.Stop() select{} }   Parse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286  // 将字符串解析成为SpecSchedule 。 SpecSchedule符合Schedule接口 // Parse returns a new crontab schedule representing the given spec. // It returns a descriptive error if the spec is not valid. // It accepts crontab specs and features configured by NewParser. func (p Parser) Parse(spec string) (Schedule, error) { if len(spec) == 0 { return nil, fmt.Errorf(\"empty spec string\") } // Extract timezone if present \tvar loc = time.Local if strings.HasPrefix(spec, \"TZ=\") || strings.HasPrefix(spec, \"CRON_TZ=\") { var err error i := strings.Index(spec, \" \") eq := strings.Index(spec, \"=\") if loc, err = time.LoadLocation(spec[eq+1 : i]); err != nil { return nil, fmt.Errorf(\"provided bad location %s: %v\", spec[eq+1:i], err) } spec = strings.TrimSpace(spec[i:]) } // Handle named schedules (descriptors), if configured  // 直接处理特殊的特殊的字符串 \tif strings.HasPrefix(spec, \"@\") { if p.options\u0026Descriptor == 0 { return nil, fmt.Errorf(\"parser does not accept descriptors: %v\", spec) } return parseDescriptor(spec, loc) } // Split on whitespace.  // cron利用空白拆解出独立的items。 \tfields := strings.Fields(spec) // Validate \u0026 fill in any omitted or optional fields \tvar err error fields, err = normalizeFields(fields, p.options) if err != nil { return nil, err } // 抽象出filed函数，方便下面调用 \tfield := func(field string, r bounds) uint64 { if err != nil { return 0 } var bits uint64 bits, err = getField(field, r) return bits } var ( second = field(fields[0], seconds) minute = field(fields[1], minutes) hour = field(fields[2], hours) dayofmonth = field(fields[3], dom) month = field(fields[4], months) dayofweek = field(fields[5], dow) ) if err != nil { return nil, err } // 返回所需要的SpecSchedule \treturn \u0026SpecSchedule{ Second: second, Minute: minute, Hour: hour, Dom: dayofmonth, Month: month, Dow: dayofweek, Location: loc, }, nil } // 解析items 。 // getField returns an Int with the bits set representing all of the times that // the field represents or error parsing field value. A \"field\" is a comma-separated // list of \"ranges\". func getField(field string, r bounds) (uint64, error) { var bits uint64 // items利用 \",\" 拆解出 item 。  ranges := strings.FieldsFunc(field, func(r rune) bool { return r == ',' }) for _, expr := range ranges { // 利用穷举法一一检测 \tbit, err := getRange(expr, r) if err != nil { return bits, err } bits |= bit } return bits, nil } // 利用穷举法一一检测 // getRange returns the bits indicated by the given expression: // number | number \"-\" number [ \"/\" number ] // or error parsing range. func getRange(expr string, r bounds) (uint64, error) { var ( start, end, step uint rangeAndStep = strings.Split(expr, \"/\") lowAndHigh = strings.Split(rangeAndStep[0], \"-\") singleDigit = len(lowAndHigh) == 1 err error ) var extra uint64 //是否仅有一个字符是 * 或者 ？。 \tif lowAndHigh[0] == \"*\" || lowAndHigh[0] == \"?\" { start = r.min end = r.max extra = starBit } else { //是否可以\"-\"分解为俩数字 \tstart, err = parseIntOrName(lowAndHigh[0], r.names) if err != nil { return 0, err } switch len(lowAndHigh) { case 1: end = start case 2: end, err = parseIntOrName(lowAndHigh[1], r.names) if err != nil { return 0, err } default: return 0, fmt.Errorf(\"too many hyphens: %s\", expr) } } //是否可以\"/\"分解为俩数字 \tswitch len(rangeAndStep) { case 1: step = 1 case 2: step, err = mustParseInt(rangeAndStep[1]) if err != nil { return 0, err } // Special handling: \"N/step\" means \"N-max/step\". \tif singleDigit { end = r.max } if step  1 { extra = 0 } default: return 0, fmt.Errorf(\"too many slashes: %s\", expr) } //转化为点 。 \tif start  r.min { return 0, fmt.Errorf(\"beginning of range (%d) below minimum (%d): %s\", start, r.min, expr) } if end  r.max { return 0, fmt.Errorf(\"end of range (%d) above maximum (%d): %s\", end, r.max, expr) } if start  end { return 0, fmt.Errorf(\"beginning of range (%d) beyond end of range (%d): %s\", start, end, expr) } if step == 0 { return 0, fmt.Errorf(\"step of range should be a positive number: %s\", expr) } return getBits(start, end, step) | extra, nil } // 辅助函数 。 解析预定义的名字或者数字 // parseIntOrName returns the (possibly-named) integer contained in expr. func parseIntOrName(expr string, names map[string]uint) (uint, error) { if names != nil { if namedInt, ok := names[strings.ToLower(expr)]; ok { return namedInt, nil } } return mustParseInt(expr) } // 辅助函数 。 解析预定义的名字或者数字 // mustParseInt parses the given expression as an int or returns an error. func mustParseInt(expr string) (uint, error) { num, err := strconv.Atoi(expr) if err != nil { return 0, fmt.Errorf(\"failed to parse int from %s: %s\", expr, err) } if num  0 { return 0, fmt.Errorf(\"negative number (%d) not allowed: %s\", num, expr) } return uint(num), nil } // 辅助函数 具体的将每个点设置好 // getBits sets all bits in the range [min, max], modulo the given step size. func getBits(min, max, step uint) uint64 { var bits uint64 // If step is 1, use shifts. \tif step == 1 { return ^(math.MaxUint64  (max + 1)) \u0026 (math.MaxUint64  min) } // Else, use a simple loop. \tfor i := min; i  max; i += step { bits |= 1  i } return bits } // 辅助函数 。 设置区间的点 + 任意标志 // all returns all bits within the given bounds. (plus the star bit) func all(r bounds) uint64 { return getBits(r.min, r.max, 1) | starBit } // 解析预定义的名字 // parseDescriptor returns a predefined schedule for the expression, or error if none matches. func parseDescriptor(descriptor string, loc *time.Location) (Schedule, error) { switch descriptor { case \"@yearly\", \"@annually\": return \u0026SpecSchedule{ Second: 1  seconds.min, Minute: 1  minutes.min, Hour: 1  hours.min, Dom: 1  dom.min, Month: 1  months.min, Dow: all(dow), Location: loc, }, nil case \"@monthly\": return \u0026SpecSchedule{ Second: 1  seconds.min, Minute: 1  minutes.min, Hour: 1  hours.min, Dom: 1  dom.min, Month: all(months), Dow: all(dow), Location: loc, }, nil case \"@weekly\": return \u0026SpecSchedule{ Second: 1  seconds.min, Minute: 1  minutes.min, Hour: 1  hours.min, Dom: all(dom), Month: all(months), Dow: 1  dow.min, Location: loc, }, nil case \"@daily\", \"@midnight\": return \u0026SpecSchedule{ Second: 1  seconds.min, Minute: 1  minutes.min, Hour: 1  hours.min, Dom: all(dom), Month: all(months), Dow: all(dow), Location: loc, }, nil case \"@hourly\": return \u0026SpecSchedule{ Second: 1  seconds.min, Minute: 1  minutes.min, Hour: all(hours), Dom: all(dom), Month: all(months), Dow: all(dow), Location: loc, }, nil } const every = \"@every \" if strings.HasPrefix(descriptor, every) { duration, err := time.ParseDuration(descriptor[len(every):]) if err != nil { return nil, fmt.Errorf(\"failed to parse duration %s: %s\", descriptor, err) } return Every(duration), nil } return nil, fmt.Errorf(\"unrecognized descriptor: %s\", descriptor) }   该函数主要是将cron表达式映射为“Second, Minute, Hour, Dom, Month, Dow”6个时间维度的结构体SpecSchedule。\nSchedule 接下来看Cron类型的Schedule方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // Schedule adds a Job to the Cron to be run on the given schedule. // The job is wrapped with the configured Chain. func (c *Cron) Schedule(schedule Schedule, cmd Job) EntryID { c.runningMu.Lock() defer c.runningMu.Unlock() c.nextID++ entry := \u0026Entry{ ID: c.nextID, Schedule: schedule, WrappedJob: c.chain.Then(cmd), Job: cmd, } if !c.running { c.entries = append(c.entries, entry) } else { c.add  entry } return entry.ID }   这个比较好理解，根据schedule和cmd参数构建了一个Entry变量，并且将这个变量添加进Cron的entries中\n只不过在没有运行的时候直接添加，运行的时候通过chan添加.\nStart 调度的开始实施是从Cron.Start()函数开始的\n1 2 3 4 5 6 7 8 9 10  // Start the cron scheduler in its own go-routine, or no-op if already started. func (c *Cron) Start() { c.runningMu.Lock() defer c.runningMu.Unlock() if c.running { return } c.running = true go c.run() }   东西很少，就是开了一个routine执行任务，这里cron还提供了一个使用当前routine执行的方法Run(),\n1 2 3 4 5 6 7 8 9 10 11  // Run the cron scheduler, or no-op if already running. func (c *Cron) Run() { c.runningMu.Lock() if c.running { c.runningMu.Unlock() return } c.running = true c.runningMu.Unlock() c.run() }   先不管这些，接下来重点到run()方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  // run the scheduler.. this is private just due to the need to synchronize // access to the 'running' state variable. func (c *Cron) run() { c.logger.Info(\"start\") // Figure out the next activation times for each entry. \tnow := c.now() for _, entry := range c.entries { entry.Next = entry.Schedule.Next(now)//得到entries中的每一个entry更新下一次执行时间 \tc.logger.Info(\"schedule\", \"now\", now, \"entry\", entry.ID, \"next\", entry.Next) } // 无限循环 \tfor { //通过对下一个执行时间进行排序，判断那些任务是下一次被执行的，防在队列的前面.sort是用来做排序的 \t// Determine the next entry to run. \tsort.Sort(byTime(c.entries))//排序 得到最先要执行的entry  var timer *time.Timer // 如果没有要执行的任务或者第一个任务的待执行时间为空，则睡眠 \tif len(c.entries) == 0 || c.entries[0].Next.IsZero() { // If there are no entries yet, just sleep - it still handles new entries \t// and stop requests. \ttimer = time.NewTimer(100000 * time.Hour) } else { timer = time.NewTimer(c.entries[0].Next.Sub(now))//时间最近要执行Entry到现在的时间差 下面唤醒select \t} for { select { case now = timer.C://时间到 执行任务 \tnow = now.In(c.location)//更新时间 \tc.logger.Info(\"wake\", \"now\", now) // Run every entry whose next time was less than now \tfor _, e := range c.entries { if e.Next.After(now) || e.Next.IsZero() { break } c.startJob(e.WrappedJob) e.Prev = e.Next e.Next = e.Schedule.Next(now) c.logger.Info(\"run\", \"now\", now, \"entry\", e.ID, \"next\", e.Next)//下一个要执行的时间 \t} case newEntry := c.add://运行中添加Entry \ttimer.Stop() now = c.now() newEntry.Next = newEntry.Schedule.Next(now) c.entries = append(c.entries, newEntry) c.logger.Info(\"added\", \"now\", now, \"entry\", newEntry.ID, \"next\", newEntry.Next) case replyChan := c.snapshot:// 快照 \treplyChan  c.entrySnapshot() continue case c.stop://停止信号 \ttimer.Stop() c.logger.Info(\"stop\") return case id := c.remove: timer.Stop() now = c.now() c.removeEntry(id) c.logger.Info(\"removed\", \"entry\", id) } break } } }   进入该函数，首先遍历所有任务，找到所有任务下一个要执行的时间。然后进入外层for循环，对于各个任务按照执行时间进行排序，保证离当前时间最近的先执行。再对任务列表进行判定，是否有任务如果没有，则休眠，否则初始化一个timer。\n里层的for循环才是重头戏，下面主要分析这个for循环里面的任务加入和执行。\n在此之前，需要了解下go标准库的timer:\n timer用于指定在某个时间间隔后，调用函数或者表达式。 使用NewTimer就可以创建一个Timer，在指定时间间隔到达后，可以通过  有了这个背景之后，我们再来看run函数的里层for循环。\n接收到c.add信道\n1 2 3 4 5  case newEntry := c.add:\t// 添加任务 \ttimer.Stop() now = c.now() newEntry.Next = newEntry.Schedule.Next(now) c.entries = append(c.entries, newEntry)   将timer停掉，清除设置的定时功能，并以当前时间点为起点，设置添加任务的下一次执行时间，并添加到entries任务队列中。\n接收到timer.C信道\n1 2 3 4 5 6 7 8 9 10 11 12 13  case now = timer.C: now = now.In(c.location) c.logger.Info(\"wake\", \"now\", no // Run every entry whose next time was less than now \tfor _, e := range c.entries { if e.Next.After(now) || e.Next.IsZero() { break } c.startJob(e.WrappedJob) e.Prev = e.Next e.Next = e.Schedule.Next(now) c.logger.Info(\"run\", \"now\", now, \"entry\", e.ID, \"next\", e.Next) }   当定时任务到点后，time.C就会接收到值，并新开协程执行真正需要执行的Job，之后再更新下一个要执行的任务列表。\n我们进入startJob函数，该函数从函数名就可以看出，即使出现panic也可以重新recovery，保证其他任务不受影响。\n1 2 3 4 5 6 7 8  // startJob runs the given job in a new goroutine. func (c *Cron) startJob(j Job) { c.jobWaiter.Add(1) go func() { defer c.jobWaiter.Done() j.Run() }() }   追根溯源，我们发现真正执行Job的是j.Run()的执行。进入这个Run函数的实现，我们看到\n1 2 3 4  // Job is an interface for submitted cron jobs. type Job interface { Run() }   没错，我们要执行的任务一直从AddFunc一直往下传递，直到这里，我们通过调用Run函数，将包装的FuncJob类型的函数通过f()的形式进行执行。\nStop 1 2 3 4 5 6 7 8 9  // 结束任务 // Stop stops the cron scheduler if it is running; otherwise it does nothing. func (c *Cron) Stop() { if !c.running { return } c.stop  struct{}{} c.running = false }   entry Schedule.Next 这个函数主要调用了Schedule的Next方法，Schedule是一个接口，在前面我们知道，实际上在解析spec的时 候返回的变量是SpecSchedule类型，所以此处应该调用SpecSchedule的Next方法，这个方法就是上面说的 那个复杂不贴代码的方法,在网上找了个带注释的版本,反正就是得到这个entry下次执行的时间吧\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137  // Next returns the next time this schedule is activated, greater than the given // time. If no time can be found to satisfy the schedule, return the zero time. func (s *SpecSchedule) Next(t time.Time) time.Time { // General approach \t// \t// For Month, Day, Hour, Minute, Second: \t// Check if the time value matches. If yes, continue to the next field. \t// If the field doesn't match the schedule, then increment the field until it matches. \t// While incrementing the field, a wrap-around brings it back to the beginning \t// of the field list (since it is necessary to re-verify previous field \t// values)  // Convert the given time into the schedule's timezone, if one is specified. \t// Save the original timezone so we can convert back after we find a time. \t// Note that schedules without a time zone specified (time.Local) are treated \t// as local to the time provided. \torigLocation := t.Location() loc := s.Location if loc == time.Local { loc = t.Location() } if s.Location != time.Local { t = t.In(s.Location) } // Start at the earliest possible time (the upcoming second).  // 秒级别的取整 \tt = t.Add(1*time.Second - time.Duration(t.Nanosecond())*time.Nanosecond) // 判断一个字段是否被累加，如果是， 那么它的下一级别的字段需要归 0 。 \t// This flag indicates whether a field has been incremented. \tadded := false // If no time is found within five years, return zero. \tyearLimit := t.Year() + 5 // 下一级别的字段累加到重置，需要重新累加上一级别的字段的时候的goto点  // 比如要找每个月的31号的时候， 4月是符合月份字段的规定的，但是4月的没有31号。 遍历尽4月的每一天后，只能请求重新累加月份。 WRAP: if t.Year()  yearLimit { return time.Time{} } // 月 \t// Find the first applicable month. \t// If it's this month, then do nothing. \tfor 1uint(t.Month())\u0026s.Month == 0 { // If we have to add a month, reset the other parts to 0. \tif !added { added = true // Otherwise, set the date at the beginning (since the current time is irrelevant). \tt = time.Date(t.Year(), t.Month(), 1, 0, 0, 0, 0, loc) } t = t.AddDate(0, 1, 0) // Wrapped around. \tif t.Month() == time.January { goto WRAP } } // 天 ， 一次处理 天/月 和 天/周 \t// Now get a day in that month. \t// \t// NOTE: This causes issues for daylight savings regimes where midnight does \t// not exist. For example: Sao Paulo has DST that transforms midnight on \t// 11/3 into 1am. Handle that by noticing when the Hour ends up != 0. \tfor !dayMatches(s, t) { if !added { added = true t = time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, loc) } t = t.AddDate(0, 0, 1) // Notice if the hour is no longer midnight due to DST. \t// Add an hour if it's 23, subtract an hour if it's 1. \tif t.Hour() != 0 { if t.Hour()  12 { t = t.Add(time.Duration(24-t.Hour()) * time.Hour) } else { t = t.Add(time.Duration(-t.Hour()) * time.Hour) } } if t.Day() == 1 { goto WRAP } } // 时 \tfor 1uint(t.Hour())\u0026s.Hour == 0 { if !added { added = true t = time.Date(t.Year(), t.Month(), t.Day(), t.Hour(), 0, 0, 0, loc) } t = t.Add(1 * time.Hour) if t.Hour() == 0 { goto WRAP } } // 分 \tfor 1uint(t.Minute())\u0026s.Minute == 0 { if !added { added = true t = t.Truncate(time.Minute) } t = t.Add(1 * time.Minute) if t.Minute() == 0 { goto WRAP } } // 秒 \tfor 1uint(t.Second())\u0026s.Second == 0 { if !added { added = true t = t.Truncate(time.Second) } t = t.Add(1 * time.Second) if t.Second() == 0 { goto WRAP } } return t.In(origLocation) } //一次处理 天/月 和 天/周 。 如果两者中有任意， 那么必须同时符合另一个才算是匹配 // dayMatches returns true if the schedule's day-of-week and day-of-month // restrictions are satisfied by the given time. func dayMatches(s *SpecSchedule, t time.Time) bool { var ( domMatch bool = 1uint(t.Day())\u0026s.Dom  0 dowMatch bool = 1uint(t.Weekday())\u0026s.Dow  0 ) if s.Dom\u0026starBit  0 || s.Dow\u0026starBit  0 { return domMatch \u0026\u0026 dowMatch } return domMatch || dowMatch }   参考: https://segmentfault.com/a/1190000014666453 http://chuquanl.com/golang-cron%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BFcron%E6%94%AF%E6%8C%81%E5%B8%A6%E5%8F%82%E6%95%B0%E4%BB%BB%E5%8A%A1%E8%B0%83%E7%94%A8/ https://juejin.im/post/5d3d79b9518825378f6cc6df\n",
  "wordCount" : "9034",
  "inLanguage": "zh-cn",
  "datePublished": "2019-10-15T11:19:03Z",
  "dateModified": "2019-10-15T11:19:03Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/cron%E5%BA%93%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      cron库源码剖析
    </h1>
    <div class="post-meta">October 15, 2019
</div>
  </header> 
  <div class="post-content"><h1 id="cron表达式">Cron表达式<a hidden class="anchor" aria-hidden="true" href="#cron表达式">#</a></h1>
<p>基本cron格式:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"># cron格式說明
# ┌──分鐘（0 - 59）
# │ ┌──小時（0 - 23）
# | │ ┌──日（1 - 31）
# | | | ┌─月（1 - 12）
# | | | | ┌─星期（0 - 7，星期日=0或7）
# | | | | |
# * * * * * 被執行的命令
</code></pre></td></tr></table>
</div>
</div><p>注：</p>
<ol>
<li>在“星期域”（第五个域），0和7都被视为星期日。</li>
<li>不很直观的用法：如果日期和星期同时被设置，那么其中的一个条件被满足时，指令便会被运行。</li>
<li>前5个域称之分时日月周，可方便个人记忆。</li>
</ol>
<p>从第六个域起，指明要运行的命令。</p>
<p>特殊符号说明:</p>
<ul>
<li>
<p>星号(*)
表示 cron 表达式能匹配该字段的所有值。如在第5个字段使用星号(month)，表示每个月</p>
</li>
<li>
<p>斜线(/)
表示增长间隔，如第1个字段(minutes) 值是 3-59/15，表示每小时的第3分钟开始执行一次，之后每隔 15 分钟执行一次（即 3、18、33、48 这些时间点执行），这里也可以表示为：3/15</p>
</li>
<li>
<p>逗号(,)
用于枚举值，如第6个字段值是 MON,WED,FRI，表示 星期一、三、五 执行</p>
</li>
<li>
<p>连字号(-)
表示一个范围，如第3个字段的值为 9-17 表示 9am 到 5pm 直接每个小时（包括9和17）</p>
</li>
<li>
<p>问号(?)
只用于 日(Day of month) 和 星期(Day of week)，表示不指定值，可以用于代替 *</p>
</li>
</ul>
<p>总结:</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191015162749.png" alt=""  />
</p>
<p>预定义模式:</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191015163251.jpg" alt=""  />
</p>
<p>举例:</p>
<p>每分钟执行一次命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">* * * * * yourCommand
</code></pre></td></tr></table>
</div>
</div><p>每小时的第2和第10分钟执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">2,10 * * * * yourCommand
</code></pre></td></tr></table>
</div>
</div><p>每天上午9点到12点的第2和第10分钟执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">2,10 9-12 * * * yourCommand
</code></pre></td></tr></table>
</div>
</div><p>每隔两天的上午9点到12点的第2和第10分钟执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">2,10 9-12 */2 * * yourCommand
</code></pre></td></tr></table>
</div>
</div><p>每周一上午9点到12点的第2和第10分钟执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">2,10 9-12 * * 1 yourCommand
</code></pre></td></tr></table>
</div>
</div><h1 id="代码使用">代码使用<a hidden class="anchor" aria-hidden="true" href="#代码使用">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;time&#34;</span>
    <span class="s">&#34;log&#34;</span>

    <span class="s">&#34;github.com/robfig/cron&#34;</span>

    <span class="s">&#34;github.com/EDDYCJY/go-gin-example/models&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Starting...&#34;</span><span class="p">)</span>

    <span class="nx">c</span> <span class="o">:=</span> <span class="nx">cron</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="nx">c</span><span class="p">.</span><span class="nf">AddFunc</span><span class="p">(</span><span class="s">&#34;* * * * * *&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Run models.CleanAllTag...&#34;</span><span class="p">)</span>
        <span class="nx">models</span><span class="p">.</span><span class="nf">CleanAllTag</span><span class="p">()</span>
    <span class="p">})</span>
    <span class="nx">c</span><span class="p">.</span><span class="nf">AddFunc</span><span class="p">(</span><span class="s">&#34;* * * * * *&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Run models.CleanAllArticle...&#34;</span><span class="p">)</span>
        <span class="nx">models</span><span class="p">.</span><span class="nf">CleanAllArticle</span><span class="p">()</span>
    <span class="p">})</span>

    <span class="nx">c</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span>

    <span class="nx">t1</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">t1</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
            <span class="nx">t1</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这段程序中，我们做了如下的事情</p>
<ol>
<li>
<p>cron.New()
会根据本地时间创建一个新（空白）的 Cron job runner</p>
</li>
<li>
<p>c.AddFunc()</p>
<p>AddFunc 会向 Cron job runner 添加一个 func ，以按给定的时间表运行.首先解析时间表，如果填写有问题会直接 err，无误则将 func 添加到 Schedule 队列中等待执行</p>
</li>
<li>
<p>c.Start()</p>
<p>在当前执行的程序中启动 Cron 调度程序。其实这里的主体是 goroutine + for + select + timer 的调度控制</p>
</li>
</ol>
<h1 id="设计思路">设计思路<a hidden class="anchor" aria-hidden="true" href="#设计思路">#</a></h1>
<h2 id="基本类型">基本类型<a hidden class="anchor" aria-hidden="true" href="#基本类型">#</a></h2>
<h3 id="cron">Cron<a hidden class="anchor" aria-hidden="true" href="#cron">#</a></h3>
<p>cron:包含一系列要执行的实体；支持暂停【stop】；添加实体等</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Cron keeps track of any number of entries, invoking the associated func as
</span><span class="c1">// specified by the schedule. It may be started, stopped, and the entries may
</span><span class="c1">// be inspected while running.
</span><span class="c1">// Cron保持任意数量的条目的轨道，调用相关的func时间表指定。它可以被启动，停止和条目，可运行的同时进行检查。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Cron</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">entries</span>   <span class="p">[]</span><span class="o">*</span><span class="nx">Entry</span>
	<span class="nx">chain</span>     <span class="nx">Chain</span>
	<span class="nx">stop</span>      <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span><span class="c1">// 控制 Cron 实例暂停
</span><span class="c1"></span>	<span class="nx">add</span>       <span class="kd">chan</span> <span class="o">*</span><span class="nx">Entry</span> <span class="c1">// 当 Cron 已经运行了，增加新的 Entity 是通过 add 这个 channel 实现的
</span><span class="c1"></span>	<span class="nx">remove</span>    <span class="kd">chan</span> <span class="nx">EntryID</span>
	<span class="nx">snapshot</span>  <span class="kd">chan</span> <span class="kd">chan</span> <span class="p">[]</span><span class="nx">Entry</span> <span class="c1">// 获取当前所有 entity 的快照
</span><span class="c1"></span>	<span class="nx">running</span>   <span class="kt">bool</span><span class="c1">// 当已经运行时为true；否则为false
</span><span class="c1"></span>	<span class="nx">logger</span>    <span class="nx">Logger</span> <span class="c1">//日志
</span><span class="c1"></span>	<span class="nx">runningMu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">location</span>  <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Location</span><span class="c1">// 所在地区(新增属性)
</span><span class="c1"></span>	<span class="nx">parser</span>    <span class="nx">Parser</span>
	<span class="nx">nextID</span>    <span class="nx">EntryID</span>
	<span class="nx">jobWaiter</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意:</p>
<ol>
<li>Cron 结构没有导出任何成员。</li>
<li>有一个成员 stop，类型是 struct{}，即空结构体。</li>
</ol>
<h3 id="entry">Entry<a hidden class="anchor" aria-hidden="true" href="#entry">#</a></h3>
<p>Entry：调度实体</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Entry</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// The schedule on which this job should be run.
</span><span class="c1"></span>    <span class="c1">// 负责调度当前 Entity 中的 Job 执行
</span><span class="c1"></span>    <span class="nx">Schedule</span> <span class="nx">Schedule</span>

    <span class="c1">// The next time the job will run. This is the zero time if Cron has not been
</span><span class="c1"></span>    <span class="c1">// started or this entry&#39;s schedule is unsatisfiable
</span><span class="c1"></span>    <span class="c1">// Job 下一次执行的时间
</span><span class="c1"></span>    <span class="nx">Next</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>

    <span class="c1">// The last time this job was run. This is the zero time if the job has never
</span><span class="c1"></span>    <span class="c1">// been run.
</span><span class="c1"></span>    <span class="c1">// 上一次执行时间
</span><span class="c1"></span>    <span class="nx">Prev</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>

    <span class="c1">// The Job to run.
</span><span class="c1"></span>    <span class="c1">// 要执行的 Job
</span><span class="c1"></span>    <span class="nx">Job</span> <span class="nx">Job</span>
<span class="p">}</span>

<span class="c1">// Entry consists of a schedule and the func to execute on that schedule.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Entry</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// ID is the cron-assigned ID of this entry, which may be used to look up a
</span><span class="c1"></span>	<span class="c1">// snapshot or remove it.
</span><span class="c1"></span>	<span class="nx">ID</span> <span class="nx">EntryID</span>
    <span class="c1">//负责调度当前 Entity 中的 Job 执行
</span><span class="c1"></span>	<span class="c1">// Schedule on which this job should be run.
</span><span class="c1"></span>	<span class="nx">Schedule</span> <span class="nx">Schedule</span>
    <span class="c1">// Job 下一次执行的时间
</span><span class="c1"></span>	<span class="c1">// Next time the job will run, or the zero time if Cron has not been
</span><span class="c1"></span>	<span class="c1">// started or this entry&#39;s schedule is unsatisfiable
</span><span class="c1"></span>	<span class="nx">Next</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
    <span class="c1">// 上一次执行时间
</span><span class="c1"></span>	<span class="c1">// Prev is the last time this job was run, or the zero time if never.
</span><span class="c1"></span>	<span class="nx">Prev</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>

	<span class="c1">// WrappedJob is the thing to run when the Schedule is activated.
</span><span class="c1"></span>	<span class="nx">WrappedJob</span> <span class="nx">Job</span>
    <span class="c1">// 要执行的 Job
</span><span class="c1"></span>	<span class="c1">// Job is the thing that was submitted to cron.
</span><span class="c1"></span>	<span class="c1">// It is kept around so that user code that needs to get at the job later,
</span><span class="c1"></span>	<span class="c1">// e.g. via Entries() can do so.
</span><span class="c1"></span>	<span class="nx">Job</span> <span class="nx">Job</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="job">Job<a hidden class="anchor" aria-hidden="true" href="#job">#</a></h3>
<p>Job：每一个实体包含一个需要运行的Job</p>
<p>这是一个接口，只有一个方法：run</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Job</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Run</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>由于 Entity 中需要 Job 类型，因此，我们希望定期运行的任务，就需要实现 Job 接口。同时，由于
Job接口只有一个无参数无返回值的方法，为了使用方便，作者提供了一个类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A wrapper that turns a func() into a cron.Job
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">FuncJob</span> <span class="kd">func</span><span class="p">()</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">FuncJob</span><span class="p">)</span> <span class="nf">Run</span><span class="p">()</span> <span class="p">{</span> <span class="nf">f</span><span class="p">()</span> <span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>它通过简单的实现 Run() 方法来实现 Job 接口,这样，任何无参数无返回值的函数，通过强制类型转换为 FuncJob，就可以当作 Job 来使用了，AddFunc 方法 就是这么做的。所以需要修改带参数功能的job时从此处下手</p>
<h3 id="schedule">Schedule<a hidden class="anchor" aria-hidden="true" href="#schedule">#</a></h3>
<p>Schedule：每个实体包含一个调度器（Schedule）</p>
<p>负责调度 Job 的执行。它也是一个接口。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// The Schedule describes a job&#39;s duty cycle.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Schedule</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Return the next activation time, later than the given time.
</span><span class="c1"></span>    <span class="c1">// Next is invoked initially, and then each time the job is run.
</span><span class="c1"></span>    <span class="c1">// 返回同一 Entity 中的 Job 下一次执行的时间
</span><span class="c1"></span>	<span class="nf">Next</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Schedule 的具体实现通过解析 Cron 表达式得到。</p>
<p>库中提供了 Schedule 的两个具体实现，分别是 SpecSchedule 和 ConstantDelaySchedule。</p>
<h4 id="specschedule">SpecSchedule<a hidden class="anchor" aria-hidden="true" href="#specschedule">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// SpecSchedule specifies a duty cycle (to the second granularity), based on a
</span><span class="c1">// traditional crontab specification. It is computed initially and stored as bit sets.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SpecSchedule</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 表达式中锁表明的，秒，分，时，日，月，周，每个都是uint64
</span><span class="c1"></span>    <span class="c1">// Dom:Day of Month,Dow:Day of week
</span><span class="c1"></span>    <span class="nx">Second</span><span class="p">,</span> <span class="nx">Minute</span><span class="p">,</span> <span class="nx">Hour</span><span class="p">,</span> <span class="nx">Dom</span><span class="p">,</span> <span class="nx">Month</span><span class="p">,</span> <span class="nx">Dow</span> <span class="kt">uint64</span>
<span class="p">}</span>

<span class="c1">// bounds provides a range of acceptable values (plus a map of name to value).
</span><span class="c1">// 定义了表达式的结构体
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">bounds</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">min</span><span class="p">,</span> <span class="nx">max</span> <span class="kt">uint</span>
    <span class="nx">names</span>    <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">uint</span>
<span class="p">}</span>


<span class="c1">// The bounds for each field.
</span><span class="c1">// 这样就能看出各个表达式的范围
</span><span class="c1"></span><span class="kd">var</span> <span class="p">(</span>
       <span class="nx">seconds</span> <span class="p">=</span> <span class="nx">bounds</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="kc">nil</span><span class="p">}</span>
       <span class="nx">minutes</span> <span class="p">=</span> <span class="nx">bounds</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="kc">nil</span><span class="p">}</span>
       <span class="nx">hours</span>   <span class="p">=</span> <span class="nx">bounds</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="kc">nil</span><span class="p">}</span>
       <span class="nx">dom</span>     <span class="p">=</span> <span class="nx">bounds</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="kc">nil</span><span class="p">}</span>
       <span class="nx">months</span>  <span class="p">=</span> <span class="nx">bounds</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">uint</span><span class="p">{</span>
              <span class="s">&#34;jan&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
              <span class="s">&#34;feb&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
              <span class="s">&#34;mar&#34;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
              <span class="s">&#34;apr&#34;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
              <span class="s">&#34;may&#34;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
              <span class="s">&#34;jun&#34;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
              <span class="s">&#34;jul&#34;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
              <span class="s">&#34;aug&#34;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
              <span class="s">&#34;sep&#34;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span>
              <span class="s">&#34;oct&#34;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
              <span class="s">&#34;nov&#34;</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span>
              <span class="s">&#34;dec&#34;</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span>
       <span class="p">}}</span>
       <span class="nx">dow</span> <span class="p">=</span> <span class="nx">bounds</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">uint</span><span class="p">{</span>
              <span class="s">&#34;sun&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
              <span class="s">&#34;mon&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
              <span class="s">&#34;tue&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
              <span class="s">&#34;wed&#34;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
              <span class="s">&#34;thu&#34;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
              <span class="s">&#34;fri&#34;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
              <span class="s">&#34;sat&#34;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
       <span class="p">}}</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="p">(</span>
       <span class="c1">// Set the top bit if a star was included in the expression.
</span><span class="c1"></span>       <span class="nx">starBit</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>从开始介绍的 Cron 表达式可以容易得知各个字段的意思，同时，对各种表达式的解析也会最终得到一个 SpecSchedule 的实例。库中的 Parse 返回的其实就是 SpecSchedule 的实例（当然也就实现了 Schedule 接口）。</p>
<p>看了上面的东西肯定有人疑惑为什么秒分时这些都是定义了unit64,以及定义了一个常量starBit = 1 &laquo; 63这种写法，这是逻辑运算符。表示二进制1向左移动63位。原因如下：</p>
<p>cron表达式是用来表示一系列时间的，而时间是无法逃脱自己的区间的:</p>
<ul>
<li>分，秒 0 - 59</li>
<li>时 0 - 23</li>
<li>天/月 0 - 31</li>
<li>天/周 0 - 6</li>
<li>月0 - 11</li>
</ul>
<p>这些本质上都是一个点集合，或者说是一个整数区间。 那么对于任意的整数区间 ，可以描述cron的如下部分规则。</p>
<ul>
<li>* | ? 任意 ， 对应区间上的所有点。 （ 额外注意 日/周 ， 日 / 月 的相互干扰。）</li>
<li>纯数字 ， 对应一个具体的点。</li>
<li>/ 分割的两个数字 a , b， 区间上符合 a + n * b 的所有点 （ n &gt;= 0 )。</li>
<li>- 分割的两个数字， 对应这两个数字决定的区间内的所有点。</li>
<li>L | W 需要对于特定的时间特殊判断， 无法通用的对应到区间上的点。</li>
</ul>
<p>至此， robfig/cron为什么不支持 L | W的原因已经明了了。去除这两条规则后， 其余的规则其实完全可以使用点的穷举来通用表示。 考虑到最大的区间也不过是60个点，那么使用一个uint64的整数的每一位来表示一个点便很合适了。所以定义unit64不为过</p>
<p>下面是go中cron表达式的方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">/*
   ------------------------------------------------------------
   第64位标记任意 ， 用于 日/周 ， 日 / 月 的相互干扰。
   63 - 0 为 表示区间 [63 , 0] 的 每一个点。
   ------------------------------------------------------------

   假设区间是 0 - 63 ， 则有如下的例子 ：

   比如  0/3 的表示如下 ： (表示每隔两位为1)
   * / ?
   +---+--------------------------------------------------------+
   | 0 | 1 0 0 1 0 0 1  ~~  ~~                    1 0 0 1 0 0 1 |
   +---+--------------------------------------------------------+
        63 ~ ~                                           ~~ 0

   比如  2-5 的表示如下 ： (表示从右往左2-5位上都是1)
   * / ?
   +---+--------------------------------------------------------+
   | 0 | 0 0 0 0 ~  ~      ~~            ~    0 0 0 1 1 1 1 0 0 |
   +---+--------------------------------------------------------+
        63 ~ ~                                           ~~ 0

  比如  * 的表示如下 ： (表示所有位置上都为1)
   * / ?
   +---+--------------------------------------------------------+
   | 1 | 1 1 1 1 1 ~  ~                  ~    1 1 1 1 1 1 1 1 1 |
   +---+--------------------------------------------------------+
        63 ~ ~                                           ~~ 0
*/
</code></pre></td></tr></table>
</div>
</div><h4 id="constantdelayschedule">ConstantDelaySchedule<a hidden class="anchor" aria-hidden="true" href="#constantdelayschedule">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ConstantDelaySchedule represents a simple recurring duty cycle, e.g. &#34;Every 5 minutes&#34;.
</span><span class="c1">// It does not support jobs more frequent than once a second.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ConstantDelaySchedule</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Delay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这是一个简单的循环调度器，如：每 5 分钟。注意，最小单位是秒，不能比秒还小，比如 毫秒。</p>
<p>通过 Every 函数可以获取该类型的实例，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">constDelaySchedule</span> <span class="o">:=</span> <span class="nf">Every</span><span class="p">(</span><span class="mf">5e9</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>得到的是一个每 5 秒执行一次的调度器。</p>
<h2 id="cron-1">Cron<a hidden class="anchor" aria-hidden="true" href="#cron-1">#</a></h2>
<h3 id="实例化">实例化<a hidden class="anchor" aria-hidden="true" href="#实例化">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">opts</span> <span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="o">*</span><span class="nx">Cron</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Cron</span><span class="p">{</span>
		<span class="nx">entries</span><span class="p">:</span>   <span class="kc">nil</span><span class="p">,</span>
		<span class="nx">chain</span><span class="p">:</span>     <span class="nf">NewChain</span><span class="p">(),</span>
		<span class="nx">add</span><span class="p">:</span>       <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">Entry</span><span class="p">),</span>
		<span class="nx">stop</span><span class="p">:</span>      <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
		<span class="nx">snapshot</span><span class="p">:</span>  <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">chan</span> <span class="p">[]</span><span class="nx">Entry</span><span class="p">),</span>
		<span class="nx">remove</span><span class="p">:</span>    <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">EntryID</span><span class="p">),</span>
		<span class="nx">running</span><span class="p">:</span>   <span class="kc">false</span><span class="p">,</span>
		<span class="nx">runningMu</span><span class="p">:</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">{},</span>
		<span class="nx">logger</span><span class="p">:</span>    <span class="nx">DefaultLogger</span><span class="p">,</span>
		<span class="nx">location</span><span class="p">:</span>  <span class="nx">time</span><span class="p">.</span><span class="nx">Local</span><span class="p">,</span>
		<span class="nx">parser</span><span class="p">:</span>    <span class="nx">standardParser</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">opt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
		<span class="nf">opt</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>

<span class="c1">// Option represents a modification to the default behavior of a Cron.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Option</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Cron</span><span class="p">)</span>

</code></pre></td></tr></table>
</div>
</div><p>可见实例化时，成员使用的基本是默认值；</p>
<h3 id="成员方法">成员方法<a hidden class="anchor" aria-hidden="true" href="#成员方法">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 将 job 加入 Cron 中
</span><span class="c1">// 如上所述，该方法只是简单的通过 FuncJob 类型强制转换 cmd，然后调用 AddJob 方法
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cron</span><span class="p">)</span> <span class="nf">AddFunc</span><span class="p">(</span><span class="nx">spec</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">cmd</span> <span class="kd">func</span><span class="p">())</span> <span class="kt">error</span>

<span class="c1">// 将 job 加入 Cron 中
</span><span class="c1">// 通过 Parse 函数解析 cron 表达式 spec 的到调度器实例(Schedule)，之后调用 c.Schedule 方法
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cron</span><span class="p">)</span> <span class="nf">AddJob</span><span class="p">(</span><span class="nx">spec</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">cmd</span> <span class="nx">Job</span><span class="p">)</span> <span class="kt">error</span>

<span class="c1">// 获取当前 Cron 总所有 Entities 的快照
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cron</span><span class="p">)</span> <span class="nf">Entries</span><span class="p">()</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Entry</span>

<span class="c1">// 通过两个参数实例化一个 Entity，然后加入当前 Cron 中
</span><span class="c1">// 注意：如果当前 Cron 未运行，则直接将该 entity 加入 Cron 中；
</span><span class="c1">// 否则，通过 add 这个成员 channel 将 entity 加入正在运行的 Cron 中
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cron</span><span class="p">)</span> <span class="nf">Schedule</span><span class="p">(</span><span class="nx">schedule</span> <span class="nx">Schedule</span><span class="p">,</span> <span class="nx">cmd</span> <span class="nx">Job</span><span class="p">)</span>

<span class="c1">// 新启动一个 goroutine 运行当前 Cron
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cron</span><span class="p">)</span> <span class="nf">Start</span><span class="p">()</span>

<span class="c1">// 通过给 stop 成员发送一个 struct{}{} 来停止当前 Cron，同时将 running 置为 false
</span><span class="c1">// 从这里知道，stop 只是通知 Cron 停止，因此往 channel 发一个值即可，而不关心值是多少
</span><span class="c1">// 所以，成员 stop 定义为空 struct
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cron</span><span class="p">)</span> <span class="nf">Stop</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="addfunc">AddFunc<a hidden class="anchor" aria-hidden="true" href="#addfunc">#</a></h4>
<p>从AddFunc函数说起带参数任务的实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// AddFunc adds a func to the Cron to be run on the given schedule.
</span><span class="c1">// The spec is parsed using the time zone of this Cron instance as the default.
</span><span class="c1">// An opaque ID is returned that can be used to later remove it.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cron</span><span class="p">)</span> <span class="nf">AddFunc</span><span class="p">(</span><span class="nx">spec</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">cmd</span> <span class="kd">func</span><span class="p">())</span> <span class="p">(</span><span class="nx">EntryID</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">AddJob</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nf">FuncJob</span><span class="p">(</span><span class="nx">cmd</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// AddJob adds a Job to the Cron to be run on the given schedule.
</span><span class="c1">// The spec is parsed using the time zone of this Cron instance as the default.
</span><span class="c1">// An opaque ID is returned that can be used to later remove it.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cron</span><span class="p">)</span> <span class="nf">AddJob</span><span class="p">(</span><span class="nx">spec</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">cmd</span> <span class="nx">Job</span><span class="p">)</span> <span class="p">(</span><span class="nx">EntryID</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">schedule</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">parser</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Schedule</span><span class="p">(</span><span class="nx">schedule</span><span class="p">,</span> <span class="nx">cmd</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>AddFunc 含有两个参数，第一个是 cron表达式，这个不解释，第二个是func()类型参数cmd 即无参数无返回类型函数，下一步中直接将此参数强制转换为FuncJob类型，并调用AddJob函数</p>
<p>FuncJob类型:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// FuncJob is a wrapper that turns a func() into a cron.Job
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">FuncJob</span> <span class="kd">func</span><span class="p">()</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">FuncJob</span><span class="p">)</span> <span class="nf">Run</span><span class="p">()</span> <span class="p">{</span> <span class="nf">f</span><span class="p">()</span> <span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>由上述代码可知FuncJob为自定义类型，真实类型为 func()，此类型实现了一个Run()方法</p>
<h4 id="addjob">AddJob<a hidden class="anchor" aria-hidden="true" href="#addjob">#</a></h4>
<p>首先 AddJob 函数的传入参数为一个string类型的cron表达式和一个Job类型的cmd参数，但在AddFunc函数中，我们传入的第二个参数为FuncJob类型，所以Job类型应该是一个接口，在解析了cron表达式无错误以后，调用Schedule方法将cmd添加进了调度器</p>
<p>Job 类型:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Job is an interface for submitted cron jobs.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Job</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Run</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>由此可知，Job是带有一个Run方法的接口类型，经过代码分析可以指定，cron定时调度时间到达时，将调用此方法，也就是意味着，任何实现了Run方法的实例，都可以作为AddJob函数的cmd参数，而Run方法所实现的内容就是你定时调度所需执行的任务(AddFunc函数只能添加无参数无返回的任务，太鸡肋了)，接下来我们就来实现一个带参数的任务添加</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//定义一个类型 包含一个int类型参数和函数体
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">funcIntJob</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">num</span>   <span class="kt">int</span>
    <span class="nx">function</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//实现这个类型的Run()方法 使得可以传入Job接口
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">funcIntJob</span><span class="p">)</span> <span class="nf">Run</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kc">nil</span> <span class="o">!=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">function</span> <span class="p">{</span>
        <span class="nx">this</span><span class="p">.</span><span class="nf">function</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">num</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//非必须  返回一个urlServeJob指针
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newfuncIntJob</span><span class="p">(</span><span class="nx">num</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">function</span> <span class="nx">funcInt</span><span class="p">)</span> <span class="o">*</span><span class="nx">urlServeJob</span> <span class="p">{</span>
    <span class="nx">instance</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">funcIntJob</span><span class="p">{</span>
        <span class="nx">num</span><span class="p">:</span>   <span class="nx">num</span><span class="p">,</span>
        <span class="nx">function</span><span class="p">:</span> <span class="nx">function</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">instance</span>
<span class="p">}</span>

<span class="c1">//示例任务
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">shownum</span><span class="p">(</span><span class="nx">num</span> <span class="kt">int</span><span class="p">){</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">c</span> <span class="p">=</span> <span class="nx">cron</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
  <span class="nx">job</span> <span class="o">:=</span> <span class="nf">newfuncIntJob</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nx">shownum</span><span class="p">)</span>
  <span class="nx">spec</span> <span class="o">:=</span> <span class="s">&#34;*/5 * * * * ?&#34;</span>
    <span class="nx">c</span><span class="p">.</span><span class="nf">AddJob</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">job</span><span class="p">)</span>
  <span class="nx">c</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
  <span class="k">select</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="parse">Parse<a hidden class="anchor" aria-hidden="true" href="#parse">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 将字符串解析成为SpecSchedule 。 SpecSchedule符合Schedule接口
</span><span class="c1">// Parse returns a new crontab schedule representing the given spec.
</span><span class="c1">// It returns a descriptive error if the spec is not valid.
</span><span class="c1">// It accepts crontab specs and features configured by NewParser.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Parser</span><span class="p">)</span> <span class="nf">Parse</span><span class="p">(</span><span class="nx">spec</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Schedule</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;empty spec string&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Extract timezone if present
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">loc</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Local</span>
	<span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="s">&#34;TZ=&#34;</span><span class="p">)</span> <span class="o">||</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="s">&#34;CRON_TZ=&#34;</span><span class="p">)</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
		<span class="nx">i</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Index</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">)</span>
		<span class="nx">eq</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Index</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="s">&#34;=&#34;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">loc</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">LoadLocation</span><span class="p">(</span><span class="nx">spec</span><span class="p">[</span><span class="nx">eq</span><span class="o">+</span><span class="mi">1</span> <span class="p">:</span> <span class="nx">i</span><span class="p">]);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;provided bad location %s: %v&#34;</span><span class="p">,</span> <span class="nx">spec</span><span class="p">[</span><span class="nx">eq</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="nx">i</span><span class="p">],</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">spec</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">TrimSpace</span><span class="p">(</span><span class="nx">spec</span><span class="p">[</span><span class="nx">i</span><span class="p">:])</span>
	<span class="p">}</span>

    <span class="c1">// Handle named schedules (descriptors), if configured
</span><span class="c1"></span>    <span class="c1">// 直接处理特殊的特殊的字符串
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="s">&#34;@&#34;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">options</span><span class="o">&amp;</span><span class="nx">Descriptor</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;parser does not accept descriptors: %v&#34;</span><span class="p">,</span> <span class="nx">spec</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nf">parseDescriptor</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">loc</span><span class="p">)</span>
	<span class="p">}</span>

    <span class="c1">// Split on whitespace.
</span><span class="c1"></span>    <span class="c1">// cron利用空白拆解出独立的items。
</span><span class="c1"></span>	<span class="nx">fields</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Fields</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span>

	<span class="c1">// Validate &amp; fill in any omitted or optional fields
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="nx">fields</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">normalizeFields</span><span class="p">(</span><span class="nx">fields</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">options</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
    <span class="c1">// 抽象出filed函数，方便下面调用
</span><span class="c1"></span>	<span class="nx">field</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">field</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">r</span> <span class="nx">bounds</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="mi">0</span>
		<span class="p">}</span>
		<span class="kd">var</span> <span class="nx">bits</span> <span class="kt">uint64</span>
		<span class="nx">bits</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">getField</span><span class="p">(</span><span class="nx">field</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">bits</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="p">(</span>
		<span class="nx">second</span>     <span class="p">=</span> <span class="nf">field</span><span class="p">(</span><span class="nx">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">seconds</span><span class="p">)</span>
		<span class="nx">minute</span>     <span class="p">=</span> <span class="nf">field</span><span class="p">(</span><span class="nx">fields</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">minutes</span><span class="p">)</span>
		<span class="nx">hour</span>       <span class="p">=</span> <span class="nf">field</span><span class="p">(</span><span class="nx">fields</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nx">hours</span><span class="p">)</span>
		<span class="nx">dayofmonth</span> <span class="p">=</span> <span class="nf">field</span><span class="p">(</span><span class="nx">fields</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="nx">dom</span><span class="p">)</span>
		<span class="nx">month</span>      <span class="p">=</span> <span class="nf">field</span><span class="p">(</span><span class="nx">fields</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="nx">months</span><span class="p">)</span>
		<span class="nx">dayofweek</span>  <span class="p">=</span> <span class="nf">field</span><span class="p">(</span><span class="nx">fields</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="nx">dow</span><span class="p">)</span>
	<span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
    <span class="c1">// 返回所需要的SpecSchedule
</span><span class="c1"></span>	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">SpecSchedule</span><span class="p">{</span>
		<span class="nx">Second</span><span class="p">:</span>   <span class="nx">second</span><span class="p">,</span>
		<span class="nx">Minute</span><span class="p">:</span>   <span class="nx">minute</span><span class="p">,</span>
		<span class="nx">Hour</span><span class="p">:</span>     <span class="nx">hour</span><span class="p">,</span>
		<span class="nx">Dom</span><span class="p">:</span>      <span class="nx">dayofmonth</span><span class="p">,</span>
		<span class="nx">Month</span><span class="p">:</span>    <span class="nx">month</span><span class="p">,</span>
		<span class="nx">Dow</span><span class="p">:</span>      <span class="nx">dayofweek</span><span class="p">,</span>
		<span class="nx">Location</span><span class="p">:</span> <span class="nx">loc</span><span class="p">,</span>
	<span class="p">},</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 解析items 。
</span><span class="c1">// getField returns an Int with the bits set representing all of the times that
</span><span class="c1">// the field represents or error parsing field value.  A &#34;field&#34; is a comma-separated
</span><span class="c1">// list of &#34;ranges&#34;.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getField</span><span class="p">(</span><span class="nx">field</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">r</span> <span class="nx">bounds</span><span class="p">)</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">bits</span> <span class="kt">uint64</span>
     <span class="c1">// items利用 &#34;,&#34; 拆解出 item 。
</span><span class="c1"></span>    <span class="nx">ranges</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">FieldsFunc</span><span class="p">(</span><span class="nx">field</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">r</span> <span class="kt">rune</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span> <span class="p">})</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">expr</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ranges</span> <span class="p">{</span>
        <span class="c1">// 利用穷举法一一检测
</span><span class="c1"></span>		<span class="nx">bit</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">getRange</span><span class="p">(</span><span class="nx">expr</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">bits</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="nx">bits</span> <span class="o">|=</span> <span class="nx">bit</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">bits</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 利用穷举法一一检测
</span><span class="c1">// getRange returns the bits indicated by the given expression:
</span><span class="c1">//   number | number &#34;-&#34; number [ &#34;/&#34; number ]
</span><span class="c1">// or error parsing range.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getRange</span><span class="p">(</span><span class="nx">expr</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">r</span> <span class="nx">bounds</span><span class="p">)</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="p">(</span>
		<span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">,</span> <span class="nx">step</span> <span class="kt">uint</span>
		<span class="nx">rangeAndStep</span>     <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nx">expr</span><span class="p">,</span> <span class="s">&#34;/&#34;</span><span class="p">)</span>
		<span class="nx">lowAndHigh</span>       <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nx">rangeAndStep</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&#34;-&#34;</span><span class="p">)</span>
		<span class="nx">singleDigit</span>      <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">lowAndHigh</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
		<span class="nx">err</span>              <span class="kt">error</span>
	<span class="p">)</span>

    <span class="kd">var</span> <span class="nx">extra</span> <span class="kt">uint64</span>
    <span class="c1">//是否仅有一个字符是 * 或者 ？。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">lowAndHigh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#34;*&#34;</span> <span class="o">||</span> <span class="nx">lowAndHigh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#34;?&#34;</span> <span class="p">{</span>
		<span class="nx">start</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">min</span>
		<span class="nx">end</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">max</span>
		<span class="nx">extra</span> <span class="p">=</span> <span class="nx">starBit</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">//是否可以&#34;-&#34;分解为俩数字
</span><span class="c1"></span>		<span class="nx">start</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">parseIntOrName</span><span class="p">(</span><span class="nx">lowAndHigh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">r</span><span class="p">.</span><span class="nx">names</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="nb">len</span><span class="p">(</span><span class="nx">lowAndHigh</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
			<span class="nx">end</span> <span class="p">=</span> <span class="nx">start</span>
		<span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
			<span class="nx">end</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">parseIntOrName</span><span class="p">(</span><span class="nx">lowAndHigh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">r</span><span class="p">.</span><span class="nx">names</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
			<span class="p">}</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;too many hyphens: %s&#34;</span><span class="p">,</span> <span class="nx">expr</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="c1">//是否可以&#34;/&#34;分解为俩数字
</span><span class="c1"></span>	<span class="k">switch</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rangeAndStep</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
		<span class="nx">step</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
		<span class="nx">step</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">mustParseInt</span><span class="p">(</span><span class="nx">rangeAndStep</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="c1">// Special handling: &#34;N/step&#34; means &#34;N-max/step&#34;.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">singleDigit</span> <span class="p">{</span>
			<span class="nx">end</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">max</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">step</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="nx">extra</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;too many slashes: %s&#34;</span><span class="p">,</span> <span class="nx">expr</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="c1">//转化为点 。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">start</span> <span class="p">&lt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">min</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;beginning of range (%d) below minimum (%d): %s&#34;</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span> <span class="nx">expr</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">end</span> <span class="p">&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">max</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;end of range (%d) above maximum (%d): %s&#34;</span><span class="p">,</span> <span class="nx">end</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">max</span><span class="p">,</span> <span class="nx">expr</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">start</span> <span class="p">&gt;</span> <span class="nx">end</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;beginning of range (%d) beyond end of range (%d): %s&#34;</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">,</span> <span class="nx">expr</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">step</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;step of range should be a positive number: %s&#34;</span><span class="p">,</span> <span class="nx">expr</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nf">getBits</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">,</span> <span class="nx">step</span><span class="p">)</span> <span class="p">|</span> <span class="nx">extra</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 辅助函数 。 解析预定义的名字或者数字
</span><span class="c1">// parseIntOrName returns the (possibly-named) integer contained in expr.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">parseIntOrName</span><span class="p">(</span><span class="nx">expr</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">names</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">uint</span><span class="p">)</span> <span class="p">(</span><span class="kt">uint</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">names</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">namedInt</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">names</span><span class="p">[</span><span class="nx">strings</span><span class="p">.</span><span class="nf">ToLower</span><span class="p">(</span><span class="nx">expr</span><span class="p">)];</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">namedInt</span><span class="p">,</span> <span class="kc">nil</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">mustParseInt</span><span class="p">(</span><span class="nx">expr</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 辅助函数 。 解析预定义的名字或者数字
</span><span class="c1">// mustParseInt parses the given expression as an int or returns an error.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mustParseInt</span><span class="p">(</span><span class="nx">expr</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">uint</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">num</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">expr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;failed to parse int from %s: %s&#34;</span><span class="p">,</span> <span class="nx">expr</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">num</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;negative number (%d) not allowed: %s&#34;</span><span class="p">,</span> <span class="nx">num</span><span class="p">,</span> <span class="nx">expr</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">num</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 辅助函数 具体的将每个点设置好
</span><span class="c1">// getBits sets all bits in the range [min, max], modulo the given step size.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getBits</span><span class="p">(</span><span class="nx">min</span><span class="p">,</span> <span class="nx">max</span><span class="p">,</span> <span class="nx">step</span> <span class="kt">uint</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">bits</span> <span class="kt">uint64</span>

	<span class="c1">// If step is 1, use shifts.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">step</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">^(</span><span class="nx">math</span><span class="p">.</span><span class="nx">MaxUint64</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nx">max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nx">MaxUint64</span> <span class="o">&lt;&lt;</span> <span class="nx">min</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Else, use a simple loop.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">min</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">max</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="nx">step</span> <span class="p">{</span>
		<span class="nx">bits</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">i</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">bits</span>
<span class="p">}</span>
<span class="c1">// 辅助函数 。 设置区间的点 + 任意标志
</span><span class="c1">// all returns all bits within the given bounds.  (plus the star bit)
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">all</span><span class="p">(</span><span class="nx">r</span> <span class="nx">bounds</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">getBits</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">max</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">|</span> <span class="nx">starBit</span>
<span class="p">}</span>
<span class="c1">// 解析预定义的名字
</span><span class="c1">// parseDescriptor returns a predefined schedule for the expression, or error if none matches.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">parseDescriptor</span><span class="p">(</span><span class="nx">descriptor</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">loc</span> <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Location</span><span class="p">)</span> <span class="p">(</span><span class="nx">Schedule</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">descriptor</span> <span class="p">{</span>
	<span class="k">case</span> <span class="s">&#34;@yearly&#34;</span><span class="p">,</span> <span class="s">&#34;@annually&#34;</span><span class="p">:</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="nx">SpecSchedule</span><span class="p">{</span>
			<span class="nx">Second</span><span class="p">:</span>   <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">seconds</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span>
			<span class="nx">Minute</span><span class="p">:</span>   <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">minutes</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span>
			<span class="nx">Hour</span><span class="p">:</span>     <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">hours</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span>
			<span class="nx">Dom</span><span class="p">:</span>      <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">dom</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span>
			<span class="nx">Month</span><span class="p">:</span>    <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">months</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span>
			<span class="nx">Dow</span><span class="p">:</span>      <span class="nf">all</span><span class="p">(</span><span class="nx">dow</span><span class="p">),</span>
			<span class="nx">Location</span><span class="p">:</span> <span class="nx">loc</span><span class="p">,</span>
		<span class="p">},</span> <span class="kc">nil</span>

	<span class="k">case</span> <span class="s">&#34;@monthly&#34;</span><span class="p">:</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="nx">SpecSchedule</span><span class="p">{</span>
			<span class="nx">Second</span><span class="p">:</span>   <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">seconds</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span>
			<span class="nx">Minute</span><span class="p">:</span>   <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">minutes</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span>
			<span class="nx">Hour</span><span class="p">:</span>     <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">hours</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span>
			<span class="nx">Dom</span><span class="p">:</span>      <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">dom</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span>
			<span class="nx">Month</span><span class="p">:</span>    <span class="nf">all</span><span class="p">(</span><span class="nx">months</span><span class="p">),</span>
			<span class="nx">Dow</span><span class="p">:</span>      <span class="nf">all</span><span class="p">(</span><span class="nx">dow</span><span class="p">),</span>
			<span class="nx">Location</span><span class="p">:</span> <span class="nx">loc</span><span class="p">,</span>
		<span class="p">},</span> <span class="kc">nil</span>

	<span class="k">case</span> <span class="s">&#34;@weekly&#34;</span><span class="p">:</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="nx">SpecSchedule</span><span class="p">{</span>
			<span class="nx">Second</span><span class="p">:</span>   <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">seconds</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span>
			<span class="nx">Minute</span><span class="p">:</span>   <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">minutes</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span>
			<span class="nx">Hour</span><span class="p">:</span>     <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">hours</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span>
			<span class="nx">Dom</span><span class="p">:</span>      <span class="nf">all</span><span class="p">(</span><span class="nx">dom</span><span class="p">),</span>
			<span class="nx">Month</span><span class="p">:</span>    <span class="nf">all</span><span class="p">(</span><span class="nx">months</span><span class="p">),</span>
			<span class="nx">Dow</span><span class="p">:</span>      <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">dow</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span>
			<span class="nx">Location</span><span class="p">:</span> <span class="nx">loc</span><span class="p">,</span>
		<span class="p">},</span> <span class="kc">nil</span>

	<span class="k">case</span> <span class="s">&#34;@daily&#34;</span><span class="p">,</span> <span class="s">&#34;@midnight&#34;</span><span class="p">:</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="nx">SpecSchedule</span><span class="p">{</span>
			<span class="nx">Second</span><span class="p">:</span>   <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">seconds</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span>
			<span class="nx">Minute</span><span class="p">:</span>   <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">minutes</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span>
			<span class="nx">Hour</span><span class="p">:</span>     <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">hours</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span>
			<span class="nx">Dom</span><span class="p">:</span>      <span class="nf">all</span><span class="p">(</span><span class="nx">dom</span><span class="p">),</span>
			<span class="nx">Month</span><span class="p">:</span>    <span class="nf">all</span><span class="p">(</span><span class="nx">months</span><span class="p">),</span>
			<span class="nx">Dow</span><span class="p">:</span>      <span class="nf">all</span><span class="p">(</span><span class="nx">dow</span><span class="p">),</span>
			<span class="nx">Location</span><span class="p">:</span> <span class="nx">loc</span><span class="p">,</span>
		<span class="p">},</span> <span class="kc">nil</span>

	<span class="k">case</span> <span class="s">&#34;@hourly&#34;</span><span class="p">:</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="nx">SpecSchedule</span><span class="p">{</span>
			<span class="nx">Second</span><span class="p">:</span>   <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">seconds</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span>
			<span class="nx">Minute</span><span class="p">:</span>   <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">minutes</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span>
			<span class="nx">Hour</span><span class="p">:</span>     <span class="nf">all</span><span class="p">(</span><span class="nx">hours</span><span class="p">),</span>
			<span class="nx">Dom</span><span class="p">:</span>      <span class="nf">all</span><span class="p">(</span><span class="nx">dom</span><span class="p">),</span>
			<span class="nx">Month</span><span class="p">:</span>    <span class="nf">all</span><span class="p">(</span><span class="nx">months</span><span class="p">),</span>
			<span class="nx">Dow</span><span class="p">:</span>      <span class="nf">all</span><span class="p">(</span><span class="nx">dow</span><span class="p">),</span>
			<span class="nx">Location</span><span class="p">:</span> <span class="nx">loc</span><span class="p">,</span>
		<span class="p">},</span> <span class="kc">nil</span>

	<span class="p">}</span>

	<span class="kd">const</span> <span class="nx">every</span> <span class="p">=</span> <span class="s">&#34;@every &#34;</span>
	<span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">descriptor</span><span class="p">,</span> <span class="nx">every</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">duration</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">ParseDuration</span><span class="p">(</span><span class="nx">descriptor</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">every</span><span class="p">):])</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;failed to parse duration %s: %s&#34;</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nf">Every</span><span class="p">(</span><span class="nx">duration</span><span class="p">),</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;unrecognized descriptor: %s&#34;</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>该函数主要是将cron表达式映射为“Second, Minute, Hour, Dom, Month, Dow”6个时间维度的结构体SpecSchedule。</p>
<h4 id="schedule-1">Schedule<a hidden class="anchor" aria-hidden="true" href="#schedule-1">#</a></h4>
<p>接下来看Cron类型的Schedule方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Schedule adds a Job to the Cron to be run on the given schedule.
</span><span class="c1">// The job is wrapped with the configured Chain.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cron</span><span class="p">)</span> <span class="nf">Schedule</span><span class="p">(</span><span class="nx">schedule</span> <span class="nx">Schedule</span><span class="p">,</span> <span class="nx">cmd</span> <span class="nx">Job</span><span class="p">)</span> <span class="nx">EntryID</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">runningMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">runningMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">nextID</span><span class="o">++</span>
	<span class="nx">entry</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Entry</span><span class="p">{</span>
		<span class="nx">ID</span><span class="p">:</span>         <span class="nx">c</span><span class="p">.</span><span class="nx">nextID</span><span class="p">,</span>
		<span class="nx">Schedule</span><span class="p">:</span>   <span class="nx">schedule</span><span class="p">,</span>
		<span class="nx">WrappedJob</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">chain</span><span class="p">.</span><span class="nf">Then</span><span class="p">(</span><span class="nx">cmd</span><span class="p">),</span>
		<span class="nx">Job</span><span class="p">:</span>        <span class="nx">cmd</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nx">running</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">entries</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">entries</span><span class="p">,</span> <span class="nx">entry</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">add</span> <span class="o">&lt;-</span> <span class="nx">entry</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">ID</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个比较好理解，根据schedule和cmd参数构建了一个Entry变量，并且将这个变量添加进Cron的entries中</p>
<p>只不过在没有运行的时候直接添加，运行的时候通过chan添加.</p>
<h4 id="start">Start<a hidden class="anchor" aria-hidden="true" href="#start">#</a></h4>
<p>调度的开始实施是从Cron.Start()函数开始的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Start the cron scheduler in its own go-routine, or no-op if already started.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cron</span><span class="p">)</span> <span class="nf">Start</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">runningMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">runningMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">running</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">running</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">go</span> <span class="nx">c</span><span class="p">.</span><span class="nf">run</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>东西很少，就是开了一个routine执行任务，这里cron还提供了一个使用当前routine执行的方法Run(),</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Run the cron scheduler, or no-op if already running.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cron</span><span class="p">)</span> <span class="nf">Run</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">runningMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">running</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">runningMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">running</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">runningMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">run</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>先不管这些，接下来重点到run()方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// run the scheduler.. this is private just due to the need to synchronize
</span><span class="c1">// access to the &#39;running&#39; state variable.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cron</span><span class="p">)</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="s">&#34;start&#34;</span><span class="p">)</span>

	<span class="c1">// Figure out the next activation times for each entry.
</span><span class="c1"></span>	<span class="nx">now</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">now</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">entry</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">entries</span> <span class="p">{</span>
		<span class="nx">entry</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">Schedule</span><span class="p">.</span><span class="nf">Next</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span><span class="c1">//得到entries中的每一个entry更新下一次执行时间
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="s">&#34;schedule&#34;</span><span class="p">,</span> <span class="s">&#34;now&#34;</span><span class="p">,</span> <span class="nx">now</span><span class="p">,</span> <span class="s">&#34;entry&#34;</span><span class="p">,</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">ID</span><span class="p">,</span> <span class="s">&#34;next&#34;</span><span class="p">,</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">Next</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="c1">// 无限循环
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
        <span class="c1">//通过对下一个执行时间进行排序，判断那些任务是下一次被执行的，防在队列的前面.sort是用来做排序的
</span><span class="c1"></span>		<span class="c1">// Determine the next entry to run.
</span><span class="c1"></span>		<span class="nx">sort</span><span class="p">.</span><span class="nf">Sort</span><span class="p">(</span><span class="nf">byTime</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">entries</span><span class="p">))</span><span class="c1">//排序  得到最先要执行的entry
</span><span class="c1"></span>
        <span class="kd">var</span> <span class="nx">timer</span> <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Timer</span>
        <span class="c1">// 如果没有要执行的任务或者第一个任务的待执行时间为空，则睡眠
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">entries</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">c</span><span class="p">.</span><span class="nx">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Next</span><span class="p">.</span><span class="nf">IsZero</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// If there are no entries yet, just sleep - it still handles new entries
</span><span class="c1"></span>			<span class="c1">// and stop requests.
</span><span class="c1"></span>			<span class="nx">timer</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="mi">100000</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">timer</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Next</span><span class="p">.</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">now</span><span class="p">))</span><span class="c1">//时间最近要执行Entry到现在的时间差 下面唤醒select
</span><span class="c1"></span>		<span class="p">}</span>

		<span class="k">for</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="nx">now</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span><span class="c1">//时间到  执行任务
</span><span class="c1"></span>				<span class="nx">now</span> <span class="p">=</span> <span class="nx">now</span><span class="p">.</span><span class="nf">In</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">location</span><span class="p">)</span><span class="c1">//更新时间
</span><span class="c1"></span>				<span class="nx">c</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="s">&#34;wake&#34;</span><span class="p">,</span> <span class="s">&#34;now&#34;</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span>

				<span class="c1">// Run every entry whose next time was less than now
</span><span class="c1"></span>				<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">entries</span> <span class="p">{</span>
					<span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span> <span class="o">||</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nf">IsZero</span><span class="p">()</span> <span class="p">{</span>
						<span class="k">break</span>
					<span class="p">}</span>
					<span class="nx">c</span><span class="p">.</span><span class="nf">startJob</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">WrappedJob</span><span class="p">)</span>
					<span class="nx">e</span><span class="p">.</span><span class="nx">Prev</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Next</span>
					<span class="nx">e</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Schedule</span><span class="p">.</span><span class="nf">Next</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span>
					<span class="nx">c</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="s">&#34;run&#34;</span><span class="p">,</span> <span class="s">&#34;now&#34;</span><span class="p">,</span> <span class="nx">now</span><span class="p">,</span> <span class="s">&#34;entry&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ID</span><span class="p">,</span> <span class="s">&#34;next&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Next</span><span class="p">)</span><span class="c1">//下一个要执行的时间
</span><span class="c1"></span>				<span class="p">}</span>

			<span class="k">case</span> <span class="nx">newEntry</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">.</span><span class="nx">add</span><span class="p">:</span><span class="c1">//运行中添加Entry
</span><span class="c1"></span>				<span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
				<span class="nx">now</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">now</span><span class="p">()</span>
				<span class="nx">newEntry</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">newEntry</span><span class="p">.</span><span class="nx">Schedule</span><span class="p">.</span><span class="nf">Next</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">entries</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">entries</span><span class="p">,</span> <span class="nx">newEntry</span><span class="p">)</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="s">&#34;added&#34;</span><span class="p">,</span> <span class="s">&#34;now&#34;</span><span class="p">,</span> <span class="nx">now</span><span class="p">,</span> <span class="s">&#34;entry&#34;</span><span class="p">,</span> <span class="nx">newEntry</span><span class="p">.</span><span class="nx">ID</span><span class="p">,</span> <span class="s">&#34;next&#34;</span><span class="p">,</span> <span class="nx">newEntry</span><span class="p">.</span><span class="nx">Next</span><span class="p">)</span>

			<span class="k">case</span> <span class="nx">replyChan</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">.</span><span class="nx">snapshot</span><span class="p">:</span><span class="c1">// 快照
</span><span class="c1"></span>				<span class="nx">replyChan</span> <span class="o">&lt;-</span> <span class="nx">c</span><span class="p">.</span><span class="nf">entrySnapshot</span><span class="p">()</span>
				<span class="k">continue</span>

			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">.</span><span class="nx">stop</span><span class="p">:</span><span class="c1">//停止信号
</span><span class="c1"></span>				<span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="s">&#34;stop&#34;</span><span class="p">)</span>
				<span class="k">return</span>

			<span class="k">case</span> <span class="nx">id</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">.</span><span class="nx">remove</span><span class="p">:</span>
				<span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
				<span class="nx">now</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">now</span><span class="p">()</span>
				<span class="nx">c</span><span class="p">.</span><span class="nf">removeEntry</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="s">&#34;removed&#34;</span><span class="p">,</span> <span class="s">&#34;entry&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span>
			<span class="p">}</span>

			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>进入该函数，首先遍历所有任务，找到所有任务下一个要执行的时间。然后进入外层for循环，对于各个任务按照执行时间进行排序，保证离当前时间最近的先执行。再对任务列表进行判定，是否有任务如果没有，则休眠，否则初始化一个timer。</p>
<p>里层的for循环才是重头戏，下面主要分析这个for循环里面的任务加入和执行。</p>
<p>在此之前，需要了解下go标准库的timer:</p>
<ul>
<li>timer用于指定在某个时间间隔后，调用函数或者表达式。</li>
<li>使用NewTimer就可以创建一个Timer，在指定时间间隔到达后，可以通过&lt;-timer.C接收值。</li>
</ul>
<p>有了这个背景之后，我们再来看run函数的里层for循环。</p>
<p>接收到c.add信道</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">case</span> <span class="nx">newEntry</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">.</span><span class="nx">add</span><span class="p">:</span>	<span class="c1">// 添加任务
</span><span class="c1"></span>	<span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
	<span class="nx">now</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">now</span><span class="p">()</span>
	<span class="nx">newEntry</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">newEntry</span><span class="p">.</span><span class="nx">Schedule</span><span class="p">.</span><span class="nf">Next</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">entries</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">entries</span><span class="p">,</span> <span class="nx">newEntry</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>将timer停掉，清除设置的定时功能，并以当前时间点为起点，设置添加任务的下一次执行时间，并添加到entries任务队列中。</p>
<p>接收到timer.C信道</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">case</span> <span class="nx">now</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
	<span class="nx">now</span> <span class="p">=</span> <span class="nx">now</span><span class="p">.</span><span class="nf">In</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">location</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="s">&#34;wake&#34;</span><span class="p">,</span> <span class="s">&#34;now&#34;</span><span class="p">,</span> <span class="nx">no</span>
	<span class="c1">// Run every entry whose next time was less than now
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">entries</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span> <span class="o">||</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nf">IsZero</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">startJob</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">WrappedJob</span><span class="p">)</span>
		<span class="nx">e</span><span class="p">.</span><span class="nx">Prev</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Next</span>
		<span class="nx">e</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Schedule</span><span class="p">.</span><span class="nf">Next</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="s">&#34;run&#34;</span><span class="p">,</span> <span class="s">&#34;now&#34;</span><span class="p">,</span> <span class="nx">now</span><span class="p">,</span> <span class="s">&#34;entry&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ID</span><span class="p">,</span> <span class="s">&#34;next&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Next</span><span class="p">)</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当定时任务到点后，time.C就会接收到值，并新开协程执行真正需要执行的Job，之后再更新下一个要执行的任务列表。</p>
<p>我们进入startJob函数，该函数从函数名就可以看出，即使出现panic也可以重新recovery，保证其他任务不受影响。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// startJob runs the given job in a new goroutine.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cron</span><span class="p">)</span> <span class="nf">startJob</span><span class="p">(</span><span class="nx">j</span> <span class="nx">Job</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">jobWaiter</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">jobWaiter</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="nx">j</span><span class="p">.</span><span class="nf">Run</span><span class="p">()</span>
	<span class="p">}()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>追根溯源，我们发现真正执行Job的是j.Run()的执行。进入这个Run函数的实现，我们看到</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Job is an interface for submitted cron jobs.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Job</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Run</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>没错，我们要执行的任务一直从AddFunc一直往下传递，直到这里，我们通过调用Run函数，将包装的FuncJob类型的函数通过f()的形式进行执行。</p>
<h4 id="stop">Stop<a hidden class="anchor" aria-hidden="true" href="#stop">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 结束任务
</span><span class="c1">// Stop stops the cron scheduler if it is running; otherwise it does nothing.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cron</span><span class="p">)</span> <span class="nf">Stop</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nx">running</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">stop</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">running</span> <span class="p">=</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="entry-1">entry<a hidden class="anchor" aria-hidden="true" href="#entry-1">#</a></h2>
<h3 id="schedulenext">Schedule.Next<a hidden class="anchor" aria-hidden="true" href="#schedulenext">#</a></h3>
<p>这个函数主要调用了Schedule的Next方法，Schedule是一个接口，在前面我们知道，实际上在解析spec的时
候返回的变量是SpecSchedule类型，所以此处应该调用SpecSchedule的Next方法，这个方法就是上面说的
那个复杂不贴代码的方法,在网上找了个带注释的版本,反正就是得到这个entry下次执行的时间吧</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Next returns the next time this schedule is activated, greater than the given
</span><span class="c1">// time.  If no time can be found to satisfy the schedule, return the zero time.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">SpecSchedule</span><span class="p">)</span> <span class="nf">Next</span><span class="p">(</span><span class="nx">t</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="p">{</span>
	<span class="c1">// General approach
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For Month, Day, Hour, Minute, Second:
</span><span class="c1"></span>	<span class="c1">// Check if the time value matches.  If yes, continue to the next field.
</span><span class="c1"></span>	<span class="c1">// If the field doesn&#39;t match the schedule, then increment the field until it matches.
</span><span class="c1"></span>	<span class="c1">// While incrementing the field, a wrap-around brings it back to the beginning
</span><span class="c1"></span>	<span class="c1">// of the field list (since it is necessary to re-verify previous field
</span><span class="c1"></span>	<span class="c1">// values)
</span><span class="c1"></span>
	<span class="c1">// Convert the given time into the schedule&#39;s timezone, if one is specified.
</span><span class="c1"></span>	<span class="c1">// Save the original timezone so we can convert back after we find a time.
</span><span class="c1"></span>	<span class="c1">// Note that schedules without a time zone specified (time.Local) are treated
</span><span class="c1"></span>	<span class="c1">// as local to the time provided.
</span><span class="c1"></span>	<span class="nx">origLocation</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Location</span><span class="p">()</span>
	<span class="nx">loc</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Location</span>
	<span class="k">if</span> <span class="nx">loc</span> <span class="o">==</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Local</span> <span class="p">{</span>
		<span class="nx">loc</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Location</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Location</span> <span class="o">!=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Local</span> <span class="p">{</span>
		<span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">In</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Location</span><span class="p">)</span>
	<span class="p">}</span>

    <span class="c1">// Start at the earliest possible time (the upcoming second).
</span><span class="c1"></span>    <span class="c1">// 秒级别的取整
</span><span class="c1"></span>	<span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">-</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">Nanosecond</span><span class="p">())</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Nanosecond</span><span class="p">)</span>
    <span class="c1">// 判断一个字段是否被累加，如果是， 那么它的下一级别的字段需要归 0 。
</span><span class="c1"></span>	<span class="c1">// This flag indicates whether a field has been incremented.
</span><span class="c1"></span>	<span class="nx">added</span> <span class="o">:=</span> <span class="kc">false</span>

	<span class="c1">// If no time is found within five years, return zero.
</span><span class="c1"></span>	<span class="nx">yearLimit</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Year</span><span class="p">()</span> <span class="o">+</span> <span class="mi">5</span>
    <span class="c1">// 下一级别的字段累加到重置，需要重新累加上一级别的字段的时候的goto点
</span><span class="c1"></span>    <span class="c1">// 比如要找每个月的31号的时候， 4月是符合月份字段的规定的，但是4月的没有31号。 遍历尽4月的每一天后，只能请求重新累加月份。
</span><span class="c1"></span><span class="nx">WRAP</span><span class="p">:</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Year</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">yearLimit</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">{}</span>
	<span class="p">}</span>
    <span class="c1">// 月
</span><span class="c1"></span>	<span class="c1">// Find the first applicable month.
</span><span class="c1"></span>	<span class="c1">// If it&#39;s this month, then do nothing.
</span><span class="c1"></span>	<span class="k">for</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nb">uint</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">Month</span><span class="p">())</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">Month</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// If we have to add a month, reset the other parts to 0.
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">added</span> <span class="p">{</span>
			<span class="nx">added</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="c1">// Otherwise, set the date at the beginning (since the current time is irrelevant).
</span><span class="c1"></span>			<span class="nx">t</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Date</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">Year</span><span class="p">(),</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Month</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">loc</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">AddDate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

		<span class="c1">// Wrapped around.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Month</span><span class="p">()</span> <span class="o">==</span> <span class="nx">time</span><span class="p">.</span><span class="nx">January</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="nx">WRAP</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="c1">// 天 ， 一次处理 天/月 和 天/周
</span><span class="c1"></span>	<span class="c1">// Now get a day in that month.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// NOTE: This causes issues for daylight savings regimes where midnight does
</span><span class="c1"></span>	<span class="c1">// not exist.  For example: Sao Paulo has DST that transforms midnight on
</span><span class="c1"></span>	<span class="c1">// 11/3 into 1am. Handle that by noticing when the Hour ends up != 0.
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">!</span><span class="nf">dayMatches</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">added</span> <span class="p">{</span>
			<span class="nx">added</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="nx">t</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Date</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">Year</span><span class="p">(),</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Month</span><span class="p">(),</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Day</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">loc</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">AddDate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="c1">// Notice if the hour is no longer midnight due to DST.
</span><span class="c1"></span>		<span class="c1">// Add an hour if it&#39;s 23, subtract an hour if it&#39;s 1.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Hour</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Hour</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">12</span> <span class="p">{</span>
				<span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="mi">24</span><span class="o">-</span><span class="nx">t</span><span class="p">.</span><span class="nf">Hour</span><span class="p">())</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="o">-</span><span class="nx">t</span><span class="p">.</span><span class="nf">Hour</span><span class="p">())</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Day</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="nx">WRAP</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="c1">// 时
</span><span class="c1"></span>	<span class="k">for</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nb">uint</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">Hour</span><span class="p">())</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">Hour</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">added</span> <span class="p">{</span>
			<span class="nx">added</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="nx">t</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Date</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">Year</span><span class="p">(),</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Month</span><span class="p">(),</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Day</span><span class="p">(),</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Hour</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">loc</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Hour</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="nx">WRAP</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="c1">// 分
</span><span class="c1"></span>	<span class="k">for</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nb">uint</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">Minute</span><span class="p">())</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">Minute</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">added</span> <span class="p">{</span>
			<span class="nx">added</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Truncate</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Minute</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="nx">WRAP</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="c1">// 秒
</span><span class="c1"></span>	<span class="k">for</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nb">uint</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">Second</span><span class="p">())</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">Second</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">added</span> <span class="p">{</span>
			<span class="nx">added</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Truncate</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Second</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="nx">WRAP</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nf">In</span><span class="p">(</span><span class="nx">origLocation</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//一次处理 天/月 和 天/周 。 如果两者中有任意， 那么必须同时符合另一个才算是匹配
</span><span class="c1">// dayMatches returns true if the schedule&#39;s day-of-week and day-of-month
</span><span class="c1">// restrictions are satisfied by the given time.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">dayMatches</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">SpecSchedule</span><span class="p">,</span> <span class="nx">t</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="p">(</span>
		<span class="nx">domMatch</span> <span class="kt">bool</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nb">uint</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">Day</span><span class="p">())</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">Dom</span> <span class="p">&gt;</span> <span class="mi">0</span>
		<span class="nx">dowMatch</span> <span class="kt">bool</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nb">uint</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">Weekday</span><span class="p">())</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">Dow</span> <span class="p">&gt;</span> <span class="mi">0</span>
	<span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Dom</span><span class="o">&amp;</span><span class="nx">starBit</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Dow</span><span class="o">&amp;</span><span class="nx">starBit</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">domMatch</span> <span class="o">&amp;&amp;</span> <span class="nx">dowMatch</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">domMatch</span> <span class="o">||</span> <span class="nx">dowMatch</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>参考:
<a href="https://segmentfault.com/a/1190000014666453">https://segmentfault.com/a/1190000014666453</a>
<a href="http://chuquanl.com/golang-cron%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BFcron%E6%94%AF%E6%8C%81%E5%B8%A6%E5%8F%82%E6%95%B0%E4%BB%BB%E5%8A%A1%E8%B0%83%E7%94%A8/">http://chuquanl.com/golang-cron%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BFcron%E6%94%AF%E6%8C%81%E5%B8%A6%E5%8F%82%E6%95%B0%E4%BB%BB%E5%8A%A1%E8%B0%83%E7%94%A8/</a>
<a href="https://juejin.im/post/5d3d79b9518825378f6cc6df">https://juejin.im/post/5d3d79b9518825378f6cc6df</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/cron/">cron</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
