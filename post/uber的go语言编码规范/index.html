<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Uber的Go语言编码规范 | Forz Blog</title>
<meta name="keywords" content="Go规范" />
<meta name="description" content="Uber Go 语言编码规范 Uber 是一家美国硅谷的科技公司，也是 Go 语言的早期 adopter。其开源了很多 golang 项目，诸如被 Gopher 圈熟知的 zap、jaeger 等。20">
<meta name="author" content="">
<link rel="canonical" href="/post/uber%E7%9A%84go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Uber的Go语言编码规范" />
<meta property="og:description" content="Uber Go 语言编码规范 Uber 是一家美国硅谷的科技公司，也是 Go 语言的早期 adopter。其开源了很多 golang 项目，诸如被 Gopher 圈熟知的 zap、jaeger 等。20" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/uber%E7%9A%84go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-07-28T17:12:51&#43;00:00" />
<meta property="article:modified_time" content="2020-07-28T17:12:51&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Uber的Go语言编码规范"/>
<meta name="twitter:description" content="Uber Go 语言编码规范 Uber 是一家美国硅谷的科技公司，也是 Go 语言的早期 adopter。其开源了很多 golang 项目，诸如被 Gopher 圈熟知的 zap、jaeger 等。20"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Uber的Go语言编码规范",
      "item": "/post/uber%E7%9A%84go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Uber的Go语言编码规范",
  "name": "Uber的Go语言编码规范",
  "description": "Uber Go 语言编码规范 Uber 是一家美国硅谷的科技公司，也是 Go 语言的早期 adopter。其开源了很多 golang 项目，诸如被 Gopher 圈熟知的 zap、jaeger 等。20",
  "keywords": [
    "Go规范"
  ],
  "articleBody": "Uber Go 语言编码规范 Uber 是一家美国硅谷的科技公司，也是 Go 语言的早期 adopter。其开源了很多 golang 项目，诸如被 Gopher 圈熟知的 zap、jaeger 等。2018 年年末 Uber 将内部的 Go 风格规范 开源到 GitHub，经过一年的积累和更新，该规范已经初具规模，并受到广大 Gopher 的关注。本文是该规范的中文版本。本版本会根据原版实时更新。\n版本  当前更新版本：2020-06-17 版本地址：commit:#97 如果您发现任何更新、问题或改进，请随时 fork 和 PR Please feel free to fork and PR if you find any updates, issues or improvement.  目录  Uber Go 语言编码规范  版本 目录 介绍 指导原则  指向 interface 的指针 Interface 合理性验证 接收器 (receiver) 与接口 零值 Mutex 是有效的 在边界处拷贝 Slices 和 Maps  接收 Slices 和 Maps 返回 slices 或 maps   使用 defer 释放资源 Channel 的 size 要么是 1，要么是无缓冲的 枚举从 1 开始 使用 time 处理时间  使用 time.Time 表达瞬时时间 使用 time.Duration 表达时间段 对外部系统使用 time.Time 和 time.Duration   错误类型 错误包装 (Error Wrapping) 处理类型断言失败 不要 panic 使用 go.uber.org/atomic 避免可变全局变量 避免在公共结构中嵌入类型 避免使用内置名称 避免使用 init() 追加时优先指定切片容量   性能  优先使用 strconv 而不是 fmt 避免字符串到字节的转换 指定容器容量  指定Map容量提示 指定切片容量     规范  一致性 相似的声明放在一组 import 分组 包名 函数名 导入别名 函数分组与顺序 减少嵌套 不必要的 else 顶层变量声明 对于未导出的顶层常量和变量，使用_作为前缀 结构体中的嵌入 使用字段名初始化结构体 本地变量声明 nil 是一个有效的 slice 缩小变量作用域 避免参数语义不明确(Avoid Naked Parameters) 使用原始字符串字面值，避免转义 初始化 Struct 引用 初始化 Maps 字符串 string format 命名 Printf 样式的函数   编程模式  表驱动测试 功能选项   Stargazers over time    介绍 样式 (style) 是支配我们代码的惯例。术语样式有点用词不当，因为这些约定涵盖的范围不限于由 gofmt 替我们处理的源文件格式。\n本指南的目的是通过详细描述在 Uber 编写 Go 代码的注意事项来管理这种复杂性。这些规则的存在是为了使代码库易于管理，同时仍然允许工程师更有效地使用 Go 语言功能。\n该指南最初由 Prashant Varanasi 和 Simon Newton 编写，目的是使一些同事能快速使用 Go。多年来，该指南已根据其他人的反馈进行了修改。\n本文档记录了我们在 Uber 遵循的 Go 代码中的惯用约定。其中许多是 Go 的通用准则，而其他扩展准则依赖于下面外部的指南：\n Effective Go The Go common mistakes guide  所有代码都应该通过golint和go vet的检查并无错误。我们建议您将编辑器设置为：\n 保存时运行 goimports 运行 golint 和 go vet 检查错误  您可以在以下 Go 编辑器工具支持页面中找到更为详细的信息： https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins\n指导原则 指向 interface 的指针 您几乎不需要指向接口类型的指针。您应该将接口作为值进行传递，在这样的传递过程中，实质上传递的底层数据仍然可以是指针。\n接口实质上在底层用两个字段表示：\n 一个指向某些特定类型信息的指针。您可以将其视为\"type\"。 数据指针。如果存储的数据是指针，则直接存储。如果存储的数据是一个值，则存储指向该值的指针。  如果希望接口方法修改基础数据，则必须使用指针传递(将对象指针赋值给接口变量)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  type F interface { f() } type S1 struct{} func (s S1) f() {} type S2 struct{} func (s *S2) f() {} // f1.f()无法修改底层数据 // f2.f() 可以修改底层数据,给接口变量f2赋值时使用的是对象指针 var f1 F:= S1{} var f2 F:= \u0026S2{}   Interface 合理性验证 在编译时验证接口的符合性。这包括：\n 将实现特定接口的导出类型作为接口API 的一部分进行检查 实现同一接口的(导出和非导出)类型属于实现类型的集合 任何违反接口合理性检查的场景,都会终止编译,并通知给用户  补充:上面3条是编译器对接口的检查机制, 大体意思是错误使用接口会在编译期报错. 所以可以利用这个机制让部分问题在编译期暴露.\n1 2 3 4 5 6 7 8 9 10  // 如果Handler没有实现http.Handler,会在运行时报错 type Handler struct { // ... } func (h *Handler) ServeHTTP( w http.ResponseWriter, r *http.Request, ) { ... }   1 2 3 4 5 6 7 8 9 10 11 12  type Handler struct { // ... } // 用于触发编译期的接口的合理性检查机制 // 如果Handler没有实现http.Handler,会在编译期报错 var _ http.Handler = (*Handler)(nil) func (h *Handler) ServeHTTP( w http.ResponseWriter, r *http.Request, ) { // ... }   如果 *Handler 与 http.Handler 的接口不匹配, 那么语句 var _ http.Handler = (*Handler)(nil) 将无法编译通过.\n赋值的右边应该是断言类型的零值。 对于指针类型（如 *Handler）、切片和映射，这是 nil； 对于结构类型，这是空结构。\n1 2 3 4 5 6 7 8 9 10 11  type LogHandler struct { h http.Handler log *zap.Logger } var _ http.Handler = LogHandler{} func (h LogHandler) ServeHTTP( w http.ResponseWriter, r *http.Request, ) { // ... }   接收器 (receiver) 与接口 使用值接收器的方法既可以通过值调用，也可以通过指针调用。\n带指针接收器的方法只能通过指针或 addressable values调用.\n例如，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  type S struct { data string } func (s S) Read() string { return s.data } func (s *S) Write(str string) { s.data = str } sVals := map[int]S{1: {\"A\"}} // 你只能通过值调用 Read sVals[1].Read() // 这不能编译通过： // sVals[1].Write(\"test\")  sPtrs := map[int]*S{1: {\"A\"}} // 通过指针既可以调用 Read，也可以调用 Write 方法 sPtrs[1].Read() sPtrs[1].Write(\"test\")   类似的,即使方法有了值接收器,也同样可以用指针接收器来满足接口.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  type F interface { f() } type S1 struct{} func (s S1) f() {} type S2 struct{} func (s *S2) f() {} s1Val := S1{} s1Ptr := \u0026S1{} s2Val := S2{} s2Ptr := \u0026S2{} var i F i = s1Val i = s1Ptr i = s2Ptr // 下面代码无法通过编译。因为 s2Val 是一个值，而 S2 的 f 方法中没有使用值接收器 // i = s2Val   Effective Go 中有一段关于 pointers vs. values 的精彩讲解。\n补充:\n 一个类型可以有值接收器方法集和指针接收器方法集  值接收器方法集是指针接收器方法集的子集,反之不是   规则  值对象只可以使用值接收器方法集 指针对象可以使用 值接收器方法集 + 指针接收器方法集   接口的匹配(或者叫实现)  类型实现了接口的所有方法,叫匹配 具体的讲,要么是类型的值方法集匹配接口,要么是指针方法集匹配接口    具体的匹配分两种:\n 值方法集和接口匹配  给接口变量赋值的不管是值还是指针对象,都ok,因为都包含值方法集   指针方法集和接口匹配  只能将指针对象赋值给接口变量,因为只有指针方法集和接口匹配 如果将值对象赋值给接口变量,会在编译期报错(会触发接口合理性检查机制)    为啥 i = s2Val 会报错,因为值方法集和接口不匹配.\n零值 Mutex 是有效的 零值 sync.Mutex 和 sync.RWMutex 是有效的。所以指向 mutex 的指针基本是不必要的。\n1 2  mu := new(sync.Mutex) mu.Lock()   1 2  var mu sync.Mutex mu.Lock()   如果你使用结构体指针，mutex 可以非指针形式作为结构体的组成字段，或者更好的方式是直接嵌入到结构体中。 如果是私有结构体类型或是要实现 Mutex 接口的类型，我们可以使用嵌入 mutex 的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  type smap struct { sync.Mutex // only for unexported types（仅适用于非导出类型）  data map[string]string } func newSMap() *smap { return \u0026smap{ data: make(map[string]string), } } func (m *smap) Get(k string) string { m.Lock() defer m.Unlock() return m.data[k] }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  type SMap struct { mu sync.Mutex // 对于导出类型，请使用私有锁  data map[string]string } func NewSMap() *SMap { return \u0026SMap{ data: make(map[string]string), } } func (m *SMap) Get(k string) string { m.mu.Lock() defer m.mu.Unlock() return m.data[k] }   在边界处拷贝 Slices 和 Maps slices 和 maps 包含了指向底层数据的指针，因此在需要复制它们时要特别注意。\n接收 Slices 和 Maps 请记住，当 map 或 slice 作为函数参数传入时，如果您存储了对它们的引用，则用户可以对其进行修改。\n1 2 3 4 5 6 7 8 9  func (d *Driver) SetTrips(trips []Trip) { d.trips = trips } trips := ... d1.SetTrips(trips) // 你是要修改 d1.trips 吗？ trips[0] = ...   1 2 3 4 5 6 7 8 9 10  func (d *Driver) SetTrips(trips []Trip) { d.trips = make([]Trip, len(trips)) copy(d.trips, trips) } trips := ... d1.SetTrips(trips) // 这里我们修改 trips[0]，但不会影响到 d1.trips trips[0] = ...   返回 slices 或 maps 同样，请注意用户对暴露内部状态的 map 或 slice 的修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  type Stats struct { mu sync.Mutex counters map[string]int } // Snapshot 返回当前状态。 func (s *Stats) Snapshot() map[string]int { s.mu.Lock() defer s.mu.Unlock() return s.counters } // snapshot 不再受互斥锁保护 // 因此对 snapshot 的任何访问都将受到数据竞争的影响 // 影响 stats.counters snapshot := stats.Snapshot()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  type Stats struct { mu sync.Mutex counters map[string]int } func (s *Stats) Snapshot() map[string]int { s.mu.Lock() defer s.mu.Unlock() result := make(map[string]int, len(s.counters)) for k, v := range s.counters { result[k] = v } return result } // snapshot 现在是一个拷贝 snapshot := stats.Snapshot()   使用 defer 释放资源 使用 defer 释放资源，诸如文件和锁。\n1 2 3 4 5 6 7 8 9 10 11 12 13  p.Lock() if p.count  10 { p.Unlock() return p.count } p.count++ newCount := p.count p.Unlock() return newCount // 当有多个 return 分支时，很容易遗忘 unlock   1 2 3 4 5 6 7 8 9 10 11  p.Lock() defer p.Unlock() if p.count  10 { return p.count } p.count++ return p.count // 更可读   Defer 的开销非常小，只有在您可以证明函数执行时间处于纳秒级的程度时，才应避免这样做。使用 defer 提升可读性是值得的，因为使用它们的成本微不足道。尤其适用于那些不仅仅是简单内存访问的较大的方法，在这些方法中其他计算的资源消耗远超过 defer。\nChannel 的 size 要么是 1，要么是无缓冲的 channel 通常 size 应为 1 或是无缓冲的。默认情况下，channel 是无缓冲的，其 size 为零。任何其他尺寸都必须经过严格的审查。我们需要考虑如何确定大小，考虑是什么阻止了 channel 在高负载下和阻塞写时的写入，以及当这种情况发生时系统逻辑有哪些变化。(翻译解释：按照原文意思是需要界定通道边界，竞态条件，以及逻辑上下文梳理)\n1 2  // 应该足以满足任何情况！ c := make(chan int, 64)   1 2 3 4  // 大小：1 c := make(chan int, 1) // 或者 // 无缓冲 channel，大小为 0 c := make(chan int)   枚举从 1 开始 在 Go 中引入枚举的标准方法是声明一个自定义类型和一个使用了 iota 的 const 组。由于变量的默认值为 0，因此通常应以非零值开头枚举。\n1 2 3 4 5 6 7 8 9  type Operation int const ( Add Operation = iota Subtract Multiply ) // Add=0, Subtract=1, Multiply=2   1 2 3 4 5 6 7 8 9  type Operation int const ( Add Operation = iota + 1 Subtract Multiply ) // Add=1, Subtract=2, Multiply=3   在某些情况下，使用零值是有意义的（枚举从零开始），例如，当零值是理想的默认行为时。\n1 2 3 4 5 6 7 8 9  type LogOutput int const ( LogToStdout LogOutput = iota LogToFile LogToRemote ) // LogToStdout=0, LogToFile=1, LogToRemote=2   使用 time 处理时间 时间处理很复杂。关于时间的错误假设通常包括以下几点。\n 一天有 24 小时 一小时有 60 分钟 一周有七天 一年 365 天 还有更多  例如，1 表示在一个时间点上加上 24 小时并不总是产生一个新的日历日。\n因此，在处理时间时始终使用 \"time\" 包，因为它有助于以更安全、更准确的方式处理这些不正确的假设。\n使用 time.Time 表达瞬时时间 在处理时间的瞬间时使用 time.time，在比较、添加或减去时间时使用 time.Time 中的方法。\n1 2 3  func isActive(now, start, stop int) bool { return start  now \u0026\u0026 now  stop }   1 2 3  func isActive(now, start, stop time.Time) bool { return (start.Before(now) || start.Equal(now)) \u0026\u0026 now.Before(stop) }   使用 time.Duration 表达时间段 在处理时间段时使用 time.Duration .\n1 2 3 4 5 6 7  func poll(delay int) { for { // ...  time.Sleep(time.Duration(delay) * time.Millisecond) } } poll(10) // 是几秒钟还是几毫秒?   1 2 3 4 5 6 7  func poll(delay time.Duration) { for { // ...  time.Sleep(delay) } } poll(10*time.Second)   回到第一个例子，在一个时间瞬间加上 24 小时，我们用于添加时间的方法取决于意图。如果我们想要下一个日历日(当前天的下一天)的同一个时间点，我们应该使用 Time.AddDate。但是，如果我们想保证某一时刻比前一时刻晚 24 小时，我们应该使用 Time.Add。\n1 2  newDay := t.AddDate(0 /* years */, 0, /* months */, 1 /* days */) maybeNewDay := t.Add(24 * time.Hour)   对外部系统使用 time.Time 和 time.Duration 尽可能在与外部系统的交互中使用 time.Duration 和 time.Time 例如 :\n  Command-line 标志: flag 通过 time.ParseDuration 支持 time.Duration\n  JSON: encoding/json 通过其 UnmarshalJSON method 方法支持将 time.Time 编码为 RFC 3339 字符串\n  SQL: database/sql 支持将 DATETIME 或 TIMESTAMP 列转换为 time.Time，如果底层驱动程序支持则返回\n  YAML: gopkg.in/yaml.v2 支持将 time.Time 作为 RFC 3339 字符串，并通过 time.ParseDuration 支持 time.Duration。\n  当不能在这些交互中使用 time.Duration 时，请使用 int 或 float64，并在字段名称中包含单位。\n例如，由于 encoding/json 不支持 time.Duration，因此该单位包含在字段的名称中。\n1 2 3 4  // {\"interval\": 2} type Config struct { Interval int `json:\"interval\"` }   1 2 3 4  // {\"intervalMillis\": 2000} type Config struct { IntervalMillis int `json:\"intervalMillis\"` }   当在这些交互中不能使用 time.Time 时，除非达成一致，否则使用 string 和 RFC 3339 中定义的格式时间戳。默认情况下，Time.UnmarshalText 使用此格式，并可通过 time.RFC3339 在 Time.Format 和 time.Parse 中使用。\n尽管这在实践中并不成问题，但请记住，\"time\" 包不支持解析闰秒时间戳（8728），也不在计算中考虑闰秒（15190）。如果您比较两个时间瞬间，则差异将不包括这两个瞬间之间可能发生的闰秒。\n错误类型 Go 中有多种声明错误（Error) 的选项：\n errors.New 对于简单静态字符串的错误 fmt.Errorf 用于格式化的错误字符串 实现 Error() 方法的自定义类型 用 \"pkg/errors\".Wrap 的 Wrapped errors  返回错误时，请考虑以下因素以确定最佳选择：\n  这是一个不需要额外信息的简单错误吗？如果是这样，errors.New 足够了。\n  客户需要检测并处理此错误吗？如果是这样，则应使用自定义类型并实现该 Error() 方法。\n  您是否正在传播下游函数返回的错误？如果是这样，请查看本文后面有关错误包装 section on error wrapping 部分的内容。\n  否则 fmt.Errorf 就可以了。\n  如果客户端需要检测错误，并且您已使用创建了一个简单的错误 errors.New，请使用一个错误变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // package foo  func Open() error { return errors.New(\"could not open\") } // package bar  func use() { if err := foo.Open(); err != nil { if err.Error() == \"could not open\" { // handle  } else { panic(\"unknown error\") } } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // package foo  var ErrCouldNotOpen = errors.New(\"could not open\") func Open() error { return ErrCouldNotOpen } // package bar  if err := foo.Open(); err != nil { if err == foo.ErrCouldNotOpen { // handle  } else { panic(\"unknown error\") } }   如果您有可能需要客户端检测的错误，并且想向其中添加更多信息（例如，它不是静态字符串），则应使用自定义类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13  func open(file string) error { return fmt.Errorf(\"file %q not found\", file) } func use() { if err := open(\"testfile.txt\"); err != nil { if strings.Contains(err.Error(), \"not found\") { // handle  } else { panic(\"unknown error\") } } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  type errNotFound struct { file string } func (e errNotFound) Error() string { return fmt.Sprintf(\"file %q not found\", e.file) } func open(file string) error { return errNotFound{file: file} } func use() { if err := open(\"testfile.txt\"); err != nil { if _, ok := err.(errNotFound); ok { // handle  } else { panic(\"unknown error\") } } }   直接导出自定义错误类型时要小心，因为它们已成为程序包公共 API 的一部分。最好公开匹配器功能以检查错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // package foo  type errNotFound struct { file string } func (e errNotFound) Error() string { return fmt.Sprintf(\"file %q not found\", e.file) } func IsNotFoundError(err error) bool { _, ok := err.(errNotFound) return ok } func Open(file string) error { return errNotFound{file: file} } // package bar  if err := foo.Open(\"foo\"); err != nil { if foo.IsNotFoundError(err) { // handle  } else { panic(\"unknown error\") } }   错误包装 (Error Wrapping) 一个（函数/方法）调用失败时，有三种主要的错误传播方式：\n 如果没有要添加的其他上下文，并且您想要维护原始错误类型，则返回原始错误。 添加上下文，使用 \"pkg/errors\".Wrap 以便错误消息提供更多上下文 ,\"pkg/errors\".Cause 可用于提取原始错误。 如果调用者不需要检测或处理的特定错误情况，使用 fmt.Errorf。  建议在可能的地方添加上下文，以使您获得诸如“调用服务 foo：连接被拒绝”之类的更有用的错误，而不是诸如“连接被拒绝”之类的模糊错误。\n在将上下文添加到返回的错误时，请避免使用“failed to”之类的短语以保持上下文简洁，这些短语会陈述明显的内容，并随着错误在堆栈中的渗透而逐渐堆积：\n1 2 3 4 5  s, err := store.New() if err != nil { return fmt.Errorf( \"failed to create new store: %s\", err) }   1 2 3 4 5  s, err := store.New() if err != nil { return fmt.Errorf( \"new store: %s\", err) }   1  failed to x: failed to y: failed to create new store: the error   1  x: y: new store: the error   但是，一旦将错误发送到另一个系统，就应该明确消息是错误消息（例如使用err标记，或在日志中以”Failed”为前缀）。\n另请参见 Don’t just check errors, handle them gracefully. 不要只是检查错误，要优雅地处理错误\n处理类型断言失败 type assertion 的单个返回值形式针对不正确的类型将产生 panic。因此，请始终使用“comma ok”的惯用法。\n1  t := i.(string)   1 2 3 4  t, ok := i.(string) if !ok { // 优雅地处理错误 }   不要 panic 在生产环境中运行的代码必须避免出现 panic。panic 是 cascading failures 级联失败的主要根源 。如果发生错误，该函数必须返回错误，并允许调用方决定如何处理它。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  func foo(bar string) { if len(bar) == 0 { panic(\"bar must not be empty\") } // ... } func main() { if len(os.Args) != 2 { fmt.Println(\"USAGE: foo \") os.Exit(1) } foo(os.Args[1]) }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func foo(bar string) error { if len(bar) == 0 { return errors.New(\"bar must not be empty\") } // ...  return nil } func main() { if len(os.Args) != 2 { fmt.Println(\"USAGE: foo \") os.Exit(1) } if err := foo(os.Args[1]); err != nil { panic(err) } }   panic/recover 不是错误处理策略。仅当发生不可恢复的事情（例如：nil 引用）时，程序才必须 panic。程序初始化是一个例外：程序启动时应使程序中止的不良情况可能会引起 panic。\n1  var _statusTemplate = template.Must(template.New(\"name\").Parse(\"_statusHTML\"))   即使在测试代码中，也优先使用t.Fatal或者t.FailNow而不是 panic 来确保失败被标记。\n1 2 3 4 5 6  // func TestFoo(t *testing.T)  f, err := ioutil.TempFile(\"\", \"test\") if err != nil { panic(\"failed to set up test\") }   1 2 3 4 5 6  // func TestFoo(t *testing.T)  f, err := ioutil.TempFile(\"\", \"test\") if err != nil { t.Fatal(\"failed to set up test\") }   使用 go.uber.org/atomic 使用 sync/atomic 包的原子操作对原始类型 (int32, int64等）进行操作，因为很容易忘记使用原子操作来读取或修改变量。\ngo.uber.org/atomic 通过隐藏基础类型为这些操作增加了类型安全性。此外，它包括一个方便的atomic.Bool类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  type foo struct { running int32 // atomic } func (f* foo) start() { if atomic.SwapInt32(\u0026f.running, 1) == 1 { // already running…  return } // start the Foo } func (f *foo) isRunning() bool { return f.running == 1 // race! }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  type foo struct { running atomic.Bool } func (f *foo) start() { if f.running.Swap(true) { // already running…  return } // start the Foo } func (f *foo) isRunning() bool { return f.running.Load() }   避免可变全局变量 使用选择依赖注入方式避免改变全局变量。 既适用于函数指针又适用于其他值类型\n1 2 3 4 5 6  // sign.go var _timeNow = time.Now func sign(msg string) string { now := _timeNow() return signWithTime(msg, now) }   1 2 3 4 5 6 7 8 9 10 11 12 13  // sign.go type signer struct { now func() time.Time } func newSigner() *signer { return \u0026signer{ now: time.Now, } } func (s *signer) Sign(msg string) string { now := s.now() return signWithTime(msg, now) }   1 2 3 4 5 6 7 8 9  // sign_test.go func TestSign(t *testing.T) { oldTimeNow := _timeNow _timeNow = func() time.Time { return someFixedTime } defer func() { _timeNow = oldTimeNow }() assert.Equal(t, want, sign(give)) }   1 2 3 4 5 6 7 8  // sign_test.go func TestSigner(t *testing.T) { s := newSigner() s.now = func() time.Time { return someFixedTime } assert.Equal(t, want, s.Sign(give)) }   避免在公共结构中嵌入类型 这些嵌入的类型泄漏实现细节、禁止类型演化和模糊的文档。\n假设您使用共享的 AbstractList 实现了多种列表类型，请避免在具体的列表实现中嵌入 AbstractList。 相反，只需手动将方法写入具体的列表，该列表将委托给抽象列表。\n1 2 3 4 5 6 7 8 9  type AbstractList struct {} // 添加将实体添加到列表中。 func (l *AbstractList) Add(e Entity) { // ... } // 移除从列表中移除实体。 func (l *AbstractList) Remove(e Entity) { // ... }   1 2 3 4  // ConcreteList 是一个实体列表。 type ConcreteList struct { *AbstractList }   1 2 3 4 5 6 7 8 9 10 11 12  // ConcreteList 是一个实体列表。 type ConcreteList struct { list *AbstractList } // 添加将实体添加到列表中。 func (l *ConcreteList) Add(e Entity) { return l.list.Add(e) } // 移除从列表中移除实体。 func (l *ConcreteList) Remove(e Entity) { return l.list.Remove(e) }   Go 允许 类型嵌入 作为继承和组合之间的折衷。 外部类型获取嵌入类型的方法的隐式副本。 默认情况下，这些方法委托给嵌入实例的同一方法。\n结构还获得与类型同名的字段。 所以，如果嵌入的类型是 public，那么字段是 public。为了保持向后兼容性，外部类型的每个未来版本都必须保留嵌入类型。\n很少需要嵌入类型。 这是一种方便，可以帮助您避免编写冗长的委托方法。\n即使嵌入兼容的抽象列表 interface，而不是结构体，这将为开发人员提供更大的灵活性来改变未来，但仍然泄露了具体列表使用抽象实现的细节。\n1 2 3 4 5 6 7 8 9  // AbstractList 是各种实体列表的通用实现。 type AbstractList interface { Add(Entity) Remove(Entity) } // ConcreteList 是一个实体列表。 type ConcreteList struct { AbstractList }   1 2 3 4 5 6 7 8 9 10 11 12  // ConcreteList 是一个实体列表。 type ConcreteList struct { list *AbstractList } // 添加将实体添加到列表中。 func (l *ConcreteList) Add(e Entity) { return l.list.Add(e) } // 移除从列表中移除实体。 func (l *ConcreteList) Remove(e Entity) { return l.list.Remove(e) }   无论是使用嵌入式结构还是使用嵌入式接口，嵌入式类型都会限制类型的演化.\n 向嵌入式接口添加方法是一个破坏性的改变。 删除嵌入类型是一个破坏性的改变。 即使使用满足相同接口的替代方法替换嵌入类型，也是一个破坏性的改变。  尽管编写这些委托方法是乏味的，但是额外的工作隐藏了实现细节，留下了更多的更改机会，还消除了在文档中发现完整列表接口的间接性操作。\n避免使用内置名称 Go语言规范language specification 概述了几个内置的， 不应在Go项目中使用的名称标识predeclared identifiers。\n根据上下文的不同，将这些标识符作为名称重复使用， 将在当前作用域（或任何嵌套作用域）中隐藏原始标识符，或者混淆代码。 在最好的情况下，编译器会报错；在最坏的情况下，这样的代码可能会引入潜在的、难以恢复的错误。\n1 2 3 4 5 6 7 8  var error string // `error` 作用域隐式覆盖  // or  func handleErrorMessage(error string) { // `error` 作用域隐式覆盖 }   1 2 3 4 5 6 7 8  var errorMessage string // `error` 指向内置的非覆盖  // or  func handleErrorMessage(msg string) { // `error` 指向内置的非覆盖 }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  type Foo struct { // 虽然这些字段在技术上不构成阴影，但`error`或`string`字符串的重映射现在是不明确的。  error error string string } func (f Foo) Error() error { // `error` 和 `f.error` 在视觉上是相似的  return f.error } func (f Foo) String() string { // `string` and `f.string` 在视觉上是相似的  return f.string }   1 2 3 4 5 6 7 8 9 10 11 12 13  type Foo struct { // `error` and `string` 现在是明确的。  err error str string } func (f Foo) Error() error { return f.err } func (f Foo) String() string { return f.str }   注意，编译器在使用预先分隔的标识符时不会生成错误， 但是诸如go vet之类的工具会正确地指出这些和其他情况下的隐式问题。\n避免使用 init() 尽可能避免使用init()。当init()是不可避免或可取的，代码应先尝试：\n 无论程序环境或调用如何，都要完全确定。 避免依赖于其他init()函数的顺序或副作用。虽然init()顺序是明确的，但代码可以更改， 因此init()函数之间的关系可能会使代码变得脆弱和容易出错。 避免访问或操作全局或环境状态，如机器信息、环境变量、工作目录、程序参数/输入等。 避免I/O，包括文件系统、网络和系统调用。  不能满足这些要求的代码可能属于要作为main()调用的一部分（或程序生命周期中的其他地方）， 或者作为main()`本身的一部分写入。特别是，打算由其他程序使用的库应该特别注意完全确定性， 而不是执行“init magic”\n1 2 3 4 5 6 7 8 9  type Foo struct { // ... } var _defaultFoo Foo func init() { _defaultFoo = Foo{ // ...  } }   1 2 3 4 5 6 7 8 9 10  var _defaultFoo = Foo{ // ... } // or, 为了更好的可测试性: var _defaultFoo = defaultFoo() func defaultFoo() Foo { return Foo{ // ...  } }   1 2 3 4 5 6 7 8 9 10 11 12 13  type Config struct { // ... } var _config Config func init() { // Bad: 基于当前目录  cwd, _ := os.Getwd() // Bad: I/O  raw, _ := ioutil.ReadFile( path.Join(cwd, \"config\", \"config.yaml\"), ) yaml.Unmarshal(raw, \u0026_config) }   1 2 3 4 5 6 7 8 9 10 11 12 13 14  type Config struct { // ... } func loadConfig() Config { cwd, err := os.Getwd() // handle err  raw, err := ioutil.ReadFile( path.Join(cwd, \"config\", \"config.yaml\"), ) // handle err  var config Config yaml.Unmarshal(raw, \u0026config) return config }   考虑到上述情况，在某些情况下，init()可能更可取或是必要的，可能包括：\n  不能表示为单个赋值的复杂表达式。\n  可插入的钩子，如database/sql、编码类型注册表等。\n  对Google Cloud Functions和其他形式的确定性预计算的优化。\n  追加时优先指定切片容量 追加时优先指定切片容量\n在尽可能的情况下，在初始化要追加的切片时为make()提供一个容量值。\n1 2 3 4 5 6  for n := 0; n  b.N; n++ { data := make([]int, 0) for k := 0; k  size; k++{ data = append(data, k) } }   1 2 3 4 5 6  for n := 0; n  b.N; n++ { data := make([]int, 0, size) for k := 0; k  size; k++{ data = append(data, k) } }   1  BenchmarkBad-4 100000000 2.48s   1  BenchmarkGood-4 100000000 0.21s   性能 性能方面的特定准则只适用于高频场景。\n优先使用 strconv 而不是 fmt 将原语转换为字符串或从字符串转换时，strconv速度比fmt快。\n1 2 3  for i := 0; i  b.N; i++ { s := fmt.Sprint(rand.Int()) }   1 2 3  for i := 0; i  b.N; i++ { s := strconv.Itoa(rand.Int()) }   1  BenchmarkFmtSprint-4 143 ns/op 2 allocs/op   1  BenchmarkStrconv-4 64.2 ns/op 1 allocs/op   避免字符串到字节的转换 不要反复从固定字符串创建字节 slice。相反，请执行一次转换并捕获结果。\n1 2 3  for i := 0; i  b.N; i++ { w.Write([]byte(\"Hello world\")) }   1 2 3 4  data := []byte(\"Hello world\") for i := 0; i  b.N; i++ { w.Write(data) }   1  BenchmarkBad-4 50000000 22.2 ns/op   1  BenchmarkGood-4 500000000 3.25 ns/op   指定容器容量 尽可能指定容器容量，以便为容器预先分配内存。这将在添加元素时最小化后续分配（通过复制和调整容器大小）。\n指定Map容量提示 在尽可能的情况下，在使用 make() 初始化的时候提供容量信息\n1  make(map[T1]T2, hint)   向make()提供容量提示会在初始化时尝试调整map的大小，这将减少在将元素添加到map时为map重新分配内存。\n注意，与slices不同。map capacity提示并不保证完全的抢占式分配，而是用于估计所需的hashmap bucket的数量。 因此，在将元素添加到map时，甚至在指定map容量时，仍可能发生分配。\n1 2 3 4 5 6  m := make(map[string]os.FileInfo) files, _ := ioutil.ReadDir(\"./files\") for _, f := range files { m[f.Name()] = f }   1 2 3 4 5 6 7  files, _ := ioutil.ReadDir(\"./files\") m := make(map[string]os.FileInfo, len(files)) for _, f := range files { m[f.Name()] = f }   m 是在没有大小提示的情况下创建的； 在运行时可能会有更多分配。\nm 是有大小提示创建的；在运行时可能会有更少的分配。\n指定切片容量 在尽可能的情况下，在使用make()初始化切片时提供容量信息，特别是在追加切片时。\n1  make([]T, length, capacity)   与maps不同，slice capacity不是一个提示：编译器将为提供给make()的slice的容量分配足够的内存， 这意味着后续的append()`操作将导致零分配（直到slice的长度与容量匹配，在此之后，任何append都可能调整大小以容纳其他元素）。\n1 2 3 4 5 6  for n := 0; n  b.N; n++ { data := make([]int, 0) for k := 0; k  size; k++{ data = append(data, k) } }   1 2 3 4 5 6  for n := 0; n  b.N; n++ { data := make([]int, 0, size) for k := 0; k  size; k++{ data = append(data, k) } }   1  BenchmarkBad-4 100000000 2.48s   1  BenchmarkGood-4 100000000 0.21s   规范 一致性 本文中概述的一些标准都是客观性的评估，是根据场景、上下文、或者主观性的判断；\n但是最重要的是，保持一致.\n一致性的代码更容易维护、是更合理的、需要更少的学习成本、并且随着新的约定出现或者出现错误后更容易迁移、更新、修复 bug\n相反，一个单一的代码库会导致维护成本开销、不确定性和认知偏差。所有这些都会直接导致速度降低、 代码审查痛苦、而且增加 bug 数量\n将这些标准应用于代码库时，建议在 package（或更大）级别进行更改，子包级别的应用程序通过将多个样式引入到同一代码中，违反了上述关注点。\n相似的声明放在一组 Go 语言支持将相似的声明放在一个组内。\n1 2  import \"a\" import \"b\"   1 2 3 4  import ( \"a\" \"b\" )   这同样适用于常量、变量和类型声明：\n1 2 3 4 5 6 7 8 9  const a = 1 const b = 2 var a = 1 var b = 2 type Area float64 type Volume float64   1 2 3 4 5 6 7 8 9 10 11 12 13 14  const ( a = 1 b = 2 ) var ( a = 1 b = 2 ) type ( Area float64 Volume float64 )   仅将相关的声明放在一组。不要将不相关的声明放在一组。\n1 2 3 4 5 6 7 8  type Operation int const ( Add Operation = iota + 1 Subtract Multiply ENV_VAR = \"MY_ENV\" )   1 2 3 4 5 6 7 8 9  type Operation int const ( Add Operation = iota + 1 Subtract Multiply ) const ENV_VAR = \"MY_ENV\"   分组使用的位置没有限制，例如：你可以在函数内部使用它们：\n1 2 3 4 5 6 7  func f() string { var red = color.New(0xff0000) var green = color.New(0x00ff00) var blue = color.New(0x0000ff) ... }   1 2 3 4 5 6 7 8 9  func f() string { var ( red = color.New(0xff0000) green = color.New(0x00ff00) blue = color.New(0x0000ff) ) ... }   import 分组 导入应该分为两组：\n 标准库 其他库  默认情况下，这是 goimports 应用的分组。\n1 2 3 4 5 6  import ( \"fmt\" \"os\" \"go.uber.org/atomic\" \"golang.org/x/sync/errgroup\" )   1 2 3 4 5 6 7  import ( \"fmt\" \"os\" \"go.uber.org/atomic\" \"golang.org/x/sync/errgroup\" )   包名 当命名包时，请按下面规则选择一个名称：\n 全部小写。没有大写或下划线。 大多数使用命名导入的情况下，不需要重命名。 简短而简洁。请记住，在每个使用的地方都完整标识了该名称。 不用复数。例如net/url，而不是net/urls。 不要用“common”，“util”，“shared”或“lib”。这些是不好的，信息量不足的名称。  另请参阅 Package Names 和 Go 包样式指南.\n函数名 我们遵循 Go 社区关于使用 MixedCaps 作为函数名 的约定。有一个例外，为了对相关的测试用例进行分组，函数名可能包含下划线，如：TestMyFunction_WhatIsBeingTested.\n导入别名 如果程序包名称与导入路径的最后一个元素不匹配，则必须使用导入别名。\n1 2 3 4 5 6  import ( \"net/http\" client \"example.com/client-go\" trace \"example.com/trace/v2\" )   在所有其他情况下，除非导入之间有直接冲突，否则应避免导入别名。\n1 2 3 4 5 6  import ( \"fmt\" \"os\" nettrace \"golang.net/x/trace\" )   1 2 3 4 5 6 7  import ( \"fmt\" \"os\" \"runtime/trace\" nettrace \"golang.net/x/trace\" )   函数分组与顺序  函数应按粗略的调用顺序排序。 同一文件中的函数应按接收者分组。  因此，导出的函数应先出现在文件中，放在struct, const, var定义的后面。\n在定义类型之后，但在接收者的其余方法之前，可能会出现一个 newXYZ()/NewXYZ()\n由于函数是按接收者分组的，因此普通工具函数应在文件末尾出现。\n1 2 3 4 5 6 7 8 9 10 11 12 13  func (s *something) Cost() { return calcCost(s.weights) } type something struct{ ... } func calcCost(n []int) int {...} func (s *something) Stop() {...} func newSomething() *something { return \u0026something{} }   1 2 3 4 5 6 7 8 9 10 11 12 13  type something struct{ ... } func newSomething() *something { return \u0026something{} } func (s *something) Cost() { return calcCost(s.weights) } func (s *something) Stop() {...} func calcCost(n []int) int {...}   减少嵌套 代码应通过尽可能先处理错误情况/特殊情况并尽早返回或继续循环来减少嵌套。减少嵌套多个级别的代码的代码量。\n1 2 3 4 5 6 7 8 9 10 11 12  for _, v := range data { if v.F1 == 1 { v = process(v) if err := v.Call(); err == nil { v.Send() } else { return err } } else { log.Printf(\"Invalid v: %v\", v) } }   1 2 3 4 5 6 7 8 9 10 11 12  for _, v := range data { if v.F1 != 1 { log.Printf(\"Invalid v: %v\", v) continue } v = process(v) if err := v.Call(); err != nil { return err } v.Send() }   不必要的 else 如果在 if 的两个分支中都设置了变量，则可以将其替换为单个 if。\n1 2 3 4 5 6  var a int if b { a = 100 } else { a = 10 }   1 2 3 4  a := 10 if b { a = 100 }   顶层变量声明 在顶层，使用标准var关键字。请勿指定类型，除非它与表达式的类型不同。\n1 2 3  var _s string = F() func F() string { return \"A\" }   1 2 3 4 5  var _s = F() // 由于 F 已经明确了返回一个字符串类型，因此我们没有必要显式指定_s 的类型 // 还是那种类型  func F() string { return \"A\" }   如果表达式的类型与所需的类型不完全匹配，请指定类型。\n1 2 3 4 5 6 7 8  type myError struct{} func (myError) Error() string { return \"error\" } func F() myError { return myError{} } var _e error = F() // F 返回一个 myError 类型的实例，但是我们要 error 类型   对于未导出的顶层常量和变量，使用_作为前缀 在未导出的顶级vars和consts， 前面加上前缀_，以使它们在使用时明确表示它们是全局符号。\n例外：未导出的错误值，应以err开头。\n基本依据：顶级变量和常量具有包范围作用域。使用通用名称可能很容易在其他文件中意外使用错误的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // foo.go  const ( defaultPort = 8080 defaultUser = \"user\" ) // bar.go  func Bar() { defaultPort := 9090 ... fmt.Println(\"Default port\", defaultPort) // We will not see a compile error if the first line of  // Bar() is deleted. }   1 2 3 4 5 6  // foo.go  const ( _defaultPort = 8080 _defaultUser = \"user\" )   结构体中的嵌入 嵌入式类型（例如 mutex）应位于结构体内的字段列表的顶部，并且必须有一个空行将嵌入式字段与常规字段分隔开。\n1 2 3 4  type Client struct { version int http.Client }   1 2 3 4 5  type Client struct { http.Client version int }   内嵌应该提供切实的好处，比如以语义上合适的方式添加或增强功能。 它应该在对用户不利影响的情况下完成这项工作（另请参见：避免在公共结构中嵌入类型Avoid Embedding Types in Public Structs）。\n嵌入 不应该:\n 纯粹是为了美观或方便。 使外部类型更难构造或使用。 影响外部类型的零值。如果外部类型有一个有用的零值，则在嵌入内部类型之后应该仍然有一个有用的零值。 作为嵌入内部类型的副作用，从外部类型公开不相关的函数或字段。 公开未导出的类型。 影响外部类型的复制形式。 更改外部类型的API或类型语义。 嵌入内部类型的非规范形式。 公开外部类型的实现详细信息。 允许用户观察或控制类型内部。 通过包装的方式改变内部函数的一般行为，这种包装方式会给用户带来一些意料之外情况。  简单地说，有意识地和有意识地嵌入。一种很好的测试体验是， “是否所有这些导出的内部方法/字段都将直接添加到外部类型” 如果答案是some或no，不要嵌入内部类型-而是使用字段。\n1 2 3 4 5  type A struct { // Bad: A.Lock() and A.Unlock() 现在可用  // 不提供任何功能性好处，并允许用户控制有关A的内部细节。  sync.Mutex }   1 2 3 4 5 6 7 8 9 10  type countingWriteCloser struct { // Good: Write() 在外层提供用于特定目的，  // 并且委托工作到内部类型的Write()中。  io.WriteCloser count int } func (w *countingWriteCloser) Write(bs []byte) (int, error) { w.count += len(bs) return w.WriteCloser.Write(bs) }   1 2 3 4 5 6 7 8 9 10  type Book struct { // Bad: 指针更改零值的有用性  io.ReadWriter // other fields } // later var b Book b.Read(...) // panic: nil pointer b.String() // panic: nil pointer b.Write(...) // panic: nil pointer   1 2 3 4 5 6 7 8 9 10  type Book struct { // Good: 有用的零值  bytes.Buffer // other fields } // later var b Book b.Read(...) // ok b.String() // ok b.Write(...) // ok   1 2 3 4 5 6  type Client struct { sync.Mutex sync.WaitGroup bytes.Buffer url.URL }   1 2 3 4 5 6  type Client struct { mtx sync.Mutex wg sync.WaitGroup buf bytes.Buffer url url.URL }   使用字段名初始化结构体 初始化结构体时，应该指定字段名称。现在由 go vet 强制执行。\n1  k := User{\"John\", \"Doe\", true}   1 2 3 4 5  k := User{ FirstName: \"John\", LastName: \"Doe\", Admin: true, }   例外：如果有 3 个或更少的字段，则可以在测试表中省略字段名称。\n1 2 3 4 5 6 7  tests := []struct{ op Operation want string }{ {Add, \"add\"}, {Subtract, \"subtract\"}, }   本地变量声明 如果将变量明确设置为某个值，则应使用短变量声明形式 (:=)。\n1  var s = \"foo\"   1  s := \"foo\"   但是，在某些情况下，var 使用关键字时默认值会更清晰。例如，声明空切片。\n1 2 3 4 5 6 7 8  func f(list []int) { filtered := []int{} for _, v := range list { if v  10 { filtered = append(filtered, v) } } }   1 2 3 4 5 6 7 8  func f(list []int) { var filtered []int for _, v := range list { if v  10 { filtered = append(filtered, v) } } }   nil 是一个有效的 slice nil 是一个有效的长度为 0 的 slice，这意味着，\n  您不应明确返回长度为零的切片。应该返回nil 来代替。\n1 2 3  if x == \"\" { return []int{} }   1 2 3  if x == \"\" { return nil }     要检查切片是否为空，请始终使用len(s) == 0。而非 nil。\n1 2 3  func isEmpty(s []string) bool { return s == nil }   1 2 3  func isEmpty(s []string) bool { return len(s) == 0 }     零值切片（用var声明的切片）可立即使用，无需调用make()创建。\n1 2 3 4 5 6 7 8 9 10  nums := []int{} // or, nums := make([]int)  if add1 { nums = append(nums, 1) } if add2 { nums = append(nums, 2) }   1 2 3 4 5 6 7 8 9  var nums []int if add1 { nums = append(nums, 1) } if add2 { nums = append(nums, 2) }     记住，虽然nil切片是有效的切片，但它不等于长度为0的切片（一个为nil，另一个不是），并且在不同的情况下（例如序列化），这两个切片的处理方式可能不同。\n缩小变量作用域 如果有可能，尽量缩小变量作用范围。除非它与 减少嵌套的规则冲突。\n1 2 3 4  err := ioutil.WriteFile(name, data, 0644) if err != nil { return err }   1 2 3  if err := ioutil.WriteFile(name, data, 0644); err != nil { return err }   如果需要在 if 之外使用函数调用的结果，则不应尝试缩小范围。\n1 2 3 4 5 6 7 8 9 10 11  if data, err := ioutil.ReadFile(name); err == nil { err = cfg.Decode(data) if err != nil { return err } fmt.Println(cfg) return nil } else { return err }   1 2 3 4 5 6 7 8 9 10 11  data, err := ioutil.ReadFile(name) if err != nil { return err } if err := cfg.Decode(data); err != nil { return err } fmt.Println(cfg) return nil   避免参数语义不明确(Avoid Naked Parameters) 函数调用中的意义不明确的参数可能会损害可读性。当参数名称的含义不明显时，请为参数添加 C 样式注释 (/* ... */)\n1 2 3  // func printInfo(name string, isLocal, done bool)  printInfo(\"foo\", true, true)   1 2 3  // func printInfo(name string, isLocal, done bool)  printInfo(\"foo\", true /* isLocal */, true /* done */)   对于上面的示例代码，还有一种更好的处理方式是将上面的 bool 类型换成自定义类型。将来，该参数可以支持不仅仅局限于两个状态（true/false）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  type Region int const ( UnknownRegion Region = iota Local ) type Status int const ( StatusReady Status= iota + 1 StatusDone // Maybe we will have a StatusInProgress in the future. ) func printInfo(name string, region Region, status Status)   使用原始字符串字面值，避免转义 Go 支持使用 原始字符串字面值，也就是 \" ` \" 来表示原生字符串，在需要转义的场景下，我们应该尽量使用这种方案来替换。\n可以跨越多行并包含引号。使用这些字符串可以避免更难阅读的手工转义的字符串。\n1  wantError := \"unknown name:\\\"test\\\"\"   1  wantError := `unknown error:\"test\"`   初始化 Struct 引用 在初始化结构引用时，请使用\u0026T{}代替new(T)，以使其与结构体初始化一致。\n1 2 3 4 5  sval := T{Name: \"foo\"} // inconsistent sptr := new(T) sptr.Name = \"bar\"   1 2 3  sval := T{Name: \"foo\"} sptr := \u0026T{Name: \"bar\"}   初始化 Maps 对于空 map 请使用 make(..) 初始化， 并且 map 是通过编程方式填充的。 这使得 map 初始化在表现上不同于声明，并且它还可以方便地在 make 后添加大小提示。\n1 2 3 4 5 6  var ( // m1 读写安全;  // m2 在写入时会 panic  m1 = map[T1]T2{} m2 map[T1]T2 )   1 2 3 4 5 6  var ( // m1 读写安全;  // m2 在写入时会 panic  m1 = make(map[T1]T2) m2 map[T1]T2 )   声明和初始化看起来非常相似的。\n声明和初始化看起来差别非常大。\n在尽可能的情况下，请在初始化时提供 map 容量大小，详细请看 指定Map容量提示。\n另外，如果 map 包含固定的元素列表，则使用 map literals(map 初始化列表) 初始化映射。\n1 2 3 4  m := make(map[T1]T2, 3) m[k1] = v1 m[k2] = v2 m[k3] = v3   1 2 3 4 5  m := map[T1]T2{ k1: v1, k2: v2, k3: v3, }   基本准则是：在初始化时使用 map 初始化列表 来添加一组固定的元素。否则使用 make (如果可以，请尽量指定 map 容量)。\n字符串 string format 如果你在函数外声明Printf-style 函数的格式字符串，请将其设置为const常量。\n这有助于go vet对格式字符串执行静态分析。\n1 2  msg := \"unexpected values %v, %v\\n\" fmt.Printf(msg, 1, 2)   1 2  const msg = \"unexpected values %v, %v\\n\" fmt.Printf(msg, 1, 2)   命名 Printf 样式的函数 声明Printf-style 函数时，请确保go vet可以检测到它并检查格式字符串。\n这意味着您应尽可能使用预定义的Printf-style 函数名称。go vet将默认检查这些。有关更多信息，请参见 Printf 系列。\n如果不能使用预定义的名称，请以 f 结束选择的名称：Wrapf，而不是Wrap。go vet可以要求检查特定的 Printf 样式名称，但名称必须以f结尾。\n1  go vet -printfuncs=wrapf,statusf   另请参阅 go vet: Printf family check.\n编程模式 表驱动测试 当测试逻辑是重复的时候，通过 subtests 使用 table 驱动的方式编写 case 代码看上去会更简洁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // func TestSplitHostPort(t *testing.T)  host, port, err := net.SplitHostPort(\"192.0.2.0:8000\") require.NoError(t, err) assert.Equal(t, \"192.0.2.0\", host) assert.Equal(t, \"8000\", port) host, port, err = net.SplitHostPort(\"192.0.2.0:http\") require.NoError(t, err) assert.Equal(t, \"192.0.2.0\", host) assert.Equal(t, \"http\", port) host, port, err = net.SplitHostPort(\":8000\") require.NoError(t, err) assert.Equal(t, \"\", host) assert.Equal(t, \"8000\", port) host, port, err = net.SplitHostPort(\"1:8\") require.NoError(t, err) assert.Equal(t, \"1\", host) assert.Equal(t, \"8\", port)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // func TestSplitHostPort(t *testing.T)  tests := []struct{ give string wantHost string wantPort string }{ { give: \"192.0.2.0:8000\", wantHost: \"192.0.2.0\", wantPort: \"8000\", }, { give: \"192.0.2.0:http\", wantHost: \"192.0.2.0\", wantPort: \"http\", }, { give: \":8000\", wantHost: \"\", wantPort: \"8000\", }, { give: \"1:8\", wantHost: \"1\", wantPort: \"8\", }, } for _, tt := range tests { t.Run(tt.give, func(t *testing.T) { host, port, err := net.SplitHostPort(tt.give) require.NoError(t, err) assert.Equal(t, tt.wantHost, host) assert.Equal(t, tt.wantPort, port) }) }   很明显，使用 test table 的方式在代码逻辑扩展的时候，比如新增 test case，都会显得更加的清晰。\n我们遵循这样的约定：将结构体切片称为tests。 每个测试用例称为tt。此外，我们鼓励使用give和want前缀说明每个测试用例的输入和输出值。\n1 2 3 4 5 6 7 8 9 10 11  tests := []struct{ give string wantHost string wantPort string }{ // ... } for _, tt := range tests { // ... }   功能选项 功能选项是一种模式，您可以在其中声明一个不透明 Option 类型，该类型在某些内部结构中记录信息。您接受这些选项的可变编号，并根据内部结构上的选项记录的全部信息采取行动。\n将此模式用于您需要扩展的构造函数和其他公共 API 中的可选参数，尤其是在这些功能上已经具有三个或更多参数的情况下。\n1 2 3 4 5 6 7 8 9  // package db  func Open( addr string, cache bool, logger *zap.Logger ) (*Connection, error) { // ... }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // package db  type Option interface { // ... } func WithCache(c bool) Option { // ... } func WithLogger(log *zap.Logger) Option { // ... } // Open creates a connection. func Open( addr string, opts ...Option, ) (*Connection, error) { // ... }   必须始终提供缓存和记录器参数，即使用户希望使用默认值。\n1 2 3 4  db.Open(addr, db.DefaultCache, zap.NewNop()) db.Open(addr, db.DefaultCache, log) db.Open(addr, false /* cache */, zap.NewNop()) db.Open(addr, false /* cache */, log)   只有在需要时才提供选项。\n1 2 3 4 5 6 7 8  db.Open(addr) db.Open(addr, db.WithLogger(log)) db.Open(addr, db.WithCache(false)) db.Open( addr, db.WithCache(false), db.WithLogger(log), )   Our suggested way of implementing this pattern is with an Option interface that holds an unexported method, recording options on an unexported options struct.\n我们建议实现此模式的方法是使用一个 Option 接口，该接口保存一个未导出的方法，在一个未导出的 options 结构上记录选项。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  type options struct { cache bool logger *zap.Logger } type Option interface { apply(*options) } type cacheOption bool func (c cacheOption) apply(opts *options) { opts.cache = bool(c) } func WithCache(c bool) Option { return cacheOption(c) } type loggerOption struct { Log *zap.Logger } func (l loggerOption) apply(opts *options) { opts.logger = l.Log } func WithLogger(log *zap.Logger) Option { return loggerOption{Log: log} } // Open creates a connection. func Open( addr string, opts ...Option, ) (*Connection, error) { options := options{ cache: defaultCache, logger: zap.NewNop(), } for _, o := range opts { o.apply(\u0026options) } // ... }   注意: 还有一种使用闭包实现这个模式的方法，但是我们相信上面的模式为作者提供了更多的灵活性，并且更容易对用户进行调试和测试。特别是，在不可能进行比较的情况下它允许在测试和模拟中对选项进行比较。此外，它还允许选项实现其他接口，包括 fmt.Stringer，允许用户读取选项的字符串表示形式。\n还可以参考下面资料：\n  Self-referential functions and the design of options\n  Functional options for friendly APIs\n  Stargazers over time \n",
  "wordCount" : "14594",
  "inLanguage": "zh-cn",
  "datePublished": "2020-07-28T17:12:51Z",
  "dateModified": "2020-07-28T17:12:51Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/uber%E7%9A%84go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Uber的Go语言编码规范
    </h1>
    <div class="post-meta">July 28, 2020
</div>
  </header> 
  <div class="post-content"><h1 id="uber-go-语言编码规范">Uber Go 语言编码规范<a hidden class="anchor" aria-hidden="true" href="#uber-go-语言编码规范">#</a></h1>
<p><a href="https://www.uber.com/">Uber</a> 是一家美国硅谷的科技公司，也是 Go 语言的早期 adopter。其开源了很多 golang 项目，诸如被 Gopher 圈熟知的 <a href="https://github.com/uber-go/zap">zap</a>、<a href="https://github.com/jaegertracing/jaeger">jaeger</a> 等。2018 年年末 Uber 将内部的 <a href="https://github.com/uber-go/guide">Go 风格规范</a> 开源到 GitHub，经过一年的积累和更新，该规范已经初具规模，并受到广大 Gopher 的关注。本文是该规范的中文版本。本版本会根据原版实时更新。</p>
<h2 id="版本">版本<a hidden class="anchor" aria-hidden="true" href="#版本">#</a></h2>
<ul>
<li>当前更新版本：2020-06-17 版本地址：<a href="https://github.com/uber-go/guide/commit/fdb233143f1276f33ccba1372588c3b9290d00f1">commit:#97</a></li>
<li>如果您发现任何更新、问题或改进，请随时 fork 和 PR</li>
<li>Please feel free to fork and PR if you find any updates, issues or improvement.</li>
</ul>
<h2 id="目录">目录<a hidden class="anchor" aria-hidden="true" href="#目录">#</a></h2>
<ul>
<li><a href="#uber-go-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83">Uber Go 语言编码规范</a>
<ul>
<li><a href="#%E7%89%88%E6%9C%AC">版本</a></li>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li>
<li><a href="#%E6%8C%87%E5%AF%BC%E5%8E%9F%E5%88%99">指导原则</a>
<ul>
<li><a href="#%E6%8C%87%E5%90%91-interface-%E7%9A%84%E6%8C%87%E9%92%88">指向 interface 的指针</a></li>
<li><a href="#interface-%E5%90%88%E7%90%86%E6%80%A7%E9%AA%8C%E8%AF%81">Interface 合理性验证</a></li>
<li><a href="#%E6%8E%A5%E6%94%B6%E5%99%A8-receiver-%E4%B8%8E%E6%8E%A5%E5%8F%A3">接收器 (receiver) 与接口</a></li>
<li><a href="#%E9%9B%B6%E5%80%BC-mutex-%E6%98%AF%E6%9C%89%E6%95%88%E7%9A%84">零值 Mutex 是有效的</a></li>
<li><a href="#%E5%9C%A8%E8%BE%B9%E7%95%8C%E5%A4%84%E6%8B%B7%E8%B4%9D-slices-%E5%92%8C-maps">在边界处拷贝 Slices 和 Maps</a>
<ul>
<li><a href="#%E6%8E%A5%E6%94%B6-slices-%E5%92%8C-maps">接收 Slices 和 Maps</a></li>
<li><a href="#%E8%BF%94%E5%9B%9E-slices-%E6%88%96-maps">返回 slices 或 maps</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8-defer-%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90">使用 defer 释放资源</a></li>
<li><a href="#channel-%E7%9A%84-size-%E8%A6%81%E4%B9%88%E6%98%AF-1%E8%A6%81%E4%B9%88%E6%98%AF%E6%97%A0%E7%BC%93%E5%86%B2%E7%9A%84">Channel 的 size 要么是 1，要么是无缓冲的</a></li>
<li><a href="#%E6%9E%9A%E4%B8%BE%E4%BB%8E-1-%E5%BC%80%E5%A7%8B">枚举从 1 开始</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-time-%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4">使用 time 处理时间</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8-timetime-%E8%A1%A8%E8%BE%BE%E7%9E%AC%E6%97%B6%E6%97%B6%E9%97%B4">使用 <code>time.Time</code> 表达瞬时时间</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-timeduration-%E8%A1%A8%E8%BE%BE%E6%97%B6%E9%97%B4%E6%AE%B5">使用 <code>time.Duration</code> 表达时间段</a></li>
<li><a href="#%E5%AF%B9%E5%A4%96%E9%83%A8%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8-timetime-%E5%92%8C-timeduration">对外部系统使用 <code>time.Time</code> 和 <code>time.Duration</code></a></li>
</ul>
</li>
<li><a href="#%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B">错误类型</a></li>
<li><a href="#%E9%94%99%E8%AF%AF%E5%8C%85%E8%A3%85-error-wrapping">错误包装 (Error Wrapping)</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%A4%B1%E8%B4%A5">处理类型断言失败</a></li>
<li><a href="#%E4%B8%8D%E8%A6%81-panic">不要 panic</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-gouberorgatomic">使用 go.uber.org/atomic</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E5%8F%AF%E5%8F%98%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">避免可变全局变量</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E5%9C%A8%E5%85%AC%E5%85%B1%E7%BB%93%E6%9E%84%E4%B8%AD%E5%B5%8C%E5%85%A5%E7%B1%BB%E5%9E%8B">避免在公共结构中嵌入类型</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E5%90%8D%E7%A7%B0">避免使用内置名称</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-init">避免使用 <code>init()</code></a></li>
<li><a href="#%E8%BF%BD%E5%8A%A0%E6%97%B6%E4%BC%98%E5%85%88%E6%8C%87%E5%AE%9A%E5%88%87%E7%89%87%E5%AE%B9%E9%87%8F">追加时优先指定切片容量</a></li>
</ul>
</li>
<li><a href="#%E6%80%A7%E8%83%BD">性能</a>
<ul>
<li><a href="#%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8-strconv-%E8%80%8C%E4%B8%8D%E6%98%AF-fmt">优先使用 strconv 而不是 fmt</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%B0%E5%AD%97%E8%8A%82%E7%9A%84%E8%BD%AC%E6%8D%A2">避免字符串到字节的转换</a></li>
<li><a href="#%E6%8C%87%E5%AE%9A%E5%AE%B9%E5%99%A8%E5%AE%B9%E9%87%8F">指定容器容量</a>
<ul>
<li><a href="#%E6%8C%87%E5%AE%9Amap%E5%AE%B9%E9%87%8F%E6%8F%90%E7%A4%BA">指定Map容量提示</a></li>
<li><a href="#%E6%8C%87%E5%AE%9A%E5%88%87%E7%89%87%E5%AE%B9%E9%87%8F">指定切片容量</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%A7%84%E8%8C%83">规范</a>
<ul>
<li><a href="#%E4%B8%80%E8%87%B4%E6%80%A7">一致性</a></li>
<li><a href="#%E7%9B%B8%E4%BC%BC%E7%9A%84%E5%A3%B0%E6%98%8E%E6%94%BE%E5%9C%A8%E4%B8%80%E7%BB%84">相似的声明放在一组</a></li>
<li><a href="#import-%E5%88%86%E7%BB%84">import 分组</a></li>
<li><a href="#%E5%8C%85%E5%90%8D">包名</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%90%8D">函数名</a></li>
<li><a href="#%E5%AF%BC%E5%85%A5%E5%88%AB%E5%90%8D">导入别名</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%88%86%E7%BB%84%E4%B8%8E%E9%A1%BA%E5%BA%8F">函数分组与顺序</a></li>
<li><a href="#%E5%87%8F%E5%B0%91%E5%B5%8C%E5%A5%97">减少嵌套</a></li>
<li><a href="#%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84-else">不必要的 else</a></li>
<li><a href="#%E9%A1%B6%E5%B1%82%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E">顶层变量声明</a></li>
<li><a href="#%E5%AF%B9%E4%BA%8E%E6%9C%AA%E5%AF%BC%E5%87%BA%E7%9A%84%E9%A1%B6%E5%B1%82%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8_%E4%BD%9C%E4%B8%BA%E5%89%8D%E7%BC%80">对于未导出的顶层常量和变量，使用_作为前缀</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E5%B5%8C%E5%85%A5">结构体中的嵌入</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E6%AE%B5%E5%90%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93">使用字段名初始化结构体</a></li>
<li><a href="#%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E">本地变量声明</a></li>
<li><a href="#nil-%E6%98%AF%E4%B8%80%E4%B8%AA%E6%9C%89%E6%95%88%E7%9A%84-slice">nil 是一个有效的 slice</a></li>
<li><a href="#%E7%BC%A9%E5%B0%8F%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F">缩小变量作用域</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E5%8F%82%E6%95%B0%E8%AF%AD%E4%B9%89%E4%B8%8D%E6%98%8E%E7%A1%AEavoid-naked-parameters">避免参数语义不明确(Avoid Naked Parameters)</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC%E9%81%BF%E5%85%8D%E8%BD%AC%E4%B9%89">使用原始字符串字面值，避免转义</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96-struct-%E5%BC%95%E7%94%A8">初始化 Struct 引用</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96-maps">初始化 Maps</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-string-format">字符串 string format</a></li>
<li><a href="#%E5%91%BD%E5%90%8D-printf-%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%87%BD%E6%95%B0">命名 Printf 样式的函数</a></li>
</ul>
</li>
<li><a href="#%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F">编程模式</a>
<ul>
<li><a href="#%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B5%8B%E8%AF%95">表驱动测试</a></li>
<li><a href="#%E5%8A%9F%E8%83%BD%E9%80%89%E9%A1%B9">功能选项</a></li>
</ul>
</li>
<li><a href="#stargazers-over-time">Stargazers over time</a></li>
</ul>
</li>
</ul>
<h2 id="介绍">介绍<a hidden class="anchor" aria-hidden="true" href="#介绍">#</a></h2>
<p>样式 (style) 是支配我们代码的惯例。术语<code>样式</code>有点用词不当，因为这些约定涵盖的范围不限于由 gofmt 替我们处理的源文件格式。</p>
<p>本指南的目的是通过详细描述在 Uber 编写 Go 代码的注意事项来管理这种复杂性。这些规则的存在是为了使代码库易于管理，同时仍然允许工程师更有效地使用 Go 语言功能。</p>
<p>该指南最初由 <a href="https://github.com/prashantv">Prashant Varanasi</a> 和 <a href="https://github.com/nomis52">Simon Newton</a> 编写，目的是使一些同事能快速使用 Go。多年来，该指南已根据其他人的反馈进行了修改。</p>
<p>本文档记录了我们在 Uber 遵循的 Go 代码中的惯用约定。其中许多是 Go 的通用准则，而其他扩展准则依赖于下面外部的指南：</p>
<ol>
<li><a href="https://golang.org/doc/effective_go.html">Effective Go</a></li>
<li><a href="https://github.com/golang/go/wiki/CodeReviewComments">The Go common mistakes guide</a></li>
</ol>
<p>所有代码都应该通过<code>golint</code>和<code>go vet</code>的检查并无错误。我们建议您将编辑器设置为：</p>
<ul>
<li>保存时运行 <code>goimports</code></li>
<li>运行 <code>golint</code> 和 <code>go vet</code> 检查错误</li>
</ul>
<p>您可以在以下 Go 编辑器工具支持页面中找到更为详细的信息：
<a href="https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins">https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins</a></p>
<h2 id="指导原则">指导原则<a hidden class="anchor" aria-hidden="true" href="#指导原则">#</a></h2>
<h3 id="指向-interface-的指针">指向 interface 的指针<a hidden class="anchor" aria-hidden="true" href="#指向-interface-的指针">#</a></h3>
<p>您几乎不需要指向接口类型的指针。您应该将接口作为值进行传递，在这样的传递过程中，实质上传递的底层数据仍然可以是指针。</p>
<p>接口实质上在底层用两个字段表示：</p>
<ol>
<li>一个指向某些特定类型信息的指针。您可以将其视为&quot;type&quot;。</li>
<li>数据指针。如果存储的数据是指针，则直接存储。如果存储的数据是一个值，则存储指向该值的指针。</li>
</ol>
<p>如果希望接口方法修改基础数据，则必须使用指针传递(将对象指针赋值给接口变量)。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">F</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nf">f</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">S1</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">S1</span><span class="p">)</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">S2</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">S2</span><span class="p">)</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span>

<span class="c1">// f1.f()无法修改底层数据
</span><span class="c1">// f2.f() 可以修改底层数据,给接口变量f2赋值时使用的是对象指针
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">f1</span> <span class="nx">F</span><span class="o">:=</span> <span class="nx">S1</span><span class="p">{}</span>
<span class="kd">var</span> <span class="nx">f2</span> <span class="nx">F</span><span class="o">:=</span> <span class="o">&amp;</span><span class="nx">S2</span><span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="interface-合理性验证">Interface 合理性验证<a hidden class="anchor" aria-hidden="true" href="#interface-合理性验证">#</a></h3>
<p>在编译时验证接口的符合性。这包括：</p>
<ul>
<li>将实现特定接口的导出类型作为接口API 的一部分进行检查</li>
<li>实现同一接口的(导出和非导出)类型属于实现类型的集合</li>
<li>任何违反接口合理性检查的场景,都会终止编译,并通知给用户</li>
</ul>
<p>补充:上面3条是编译器对接口的检查机制,
大体意思是错误使用接口会在编译期报错.
所以可以利用这个机制让部分问题在编译期暴露.</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 如果Handler没有实现http.Handler,会在运行时报错
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Handler</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">Handler</span><span class="p">)</span> <span class="nf">ServeHTTP</span><span class="p">(</span>
  <span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span>
  <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Handler</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// 用于触发编译期的接口的合理性检查机制
</span><span class="c1">// 如果Handler没有实现http.Handler,会在编译期报错
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">_</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">Handler</span><span class="p">)(</span><span class="kc">nil</span><span class="p">)</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">Handler</span><span class="p">)</span> <span class="nf">ServeHTTP</span><span class="p">(</span>
  <span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span>
  <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>如果 <code>*Handler</code> 与 <code>http.Handler</code> 的接口不匹配,
那么语句 <code>var _ http.Handler = (*Handler)(nil)</code> 将无法编译通过.</p>
<p>赋值的右边应该是断言类型的零值。
对于指针类型（如 <code>*Handler</code>）、切片和映射，这是 <code>nil</code>；
对于结构类型，这是空结构。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">LogHandler</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">h</span>   <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span>
  <span class="nx">log</span> <span class="o">*</span><span class="nx">zap</span><span class="p">.</span><span class="nx">Logger</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">_</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span> <span class="p">=</span> <span class="nx">LogHandler</span><span class="p">{}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="nx">LogHandler</span><span class="p">)</span> <span class="nf">ServeHTTP</span><span class="p">(</span>
  <span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span>
  <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="接收器-receiver-与接口">接收器 (receiver) 与接口<a hidden class="anchor" aria-hidden="true" href="#接收器-receiver-与接口">#</a></h3>
<p>使用值接收器的方法既可以通过值调用，也可以通过指针调用。</p>
<p>带指针接收器的方法只能通过指针或 <a href="https://golang.org/ref/spec#Method_values">addressable values</a>调用.</p>
<p>例如，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">S</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">data</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">S</span><span class="p">)</span> <span class="nf">Read</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">data</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">S</span><span class="p">)</span> <span class="nf">Write</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">s</span><span class="p">.</span><span class="nx">data</span> <span class="p">=</span> <span class="nx">str</span>
<span class="p">}</span>

<span class="nx">sVals</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="nx">S</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s">&#34;A&#34;</span><span class="p">}}</span>

<span class="c1">// 你只能通过值调用 Read
</span><span class="c1"></span><span class="nx">sVals</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">Read</span><span class="p">()</span>

<span class="c1">// 这不能编译通过：
</span><span class="c1">//  sVals[1].Write(&#34;test&#34;)
</span><span class="c1"></span>
<span class="nx">sPtrs</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="nx">S</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s">&#34;A&#34;</span><span class="p">}}</span>

<span class="c1">// 通过指针既可以调用 Read，也可以调用 Write 方法
</span><span class="c1"></span><span class="nx">sPtrs</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">Read</span><span class="p">()</span>
<span class="nx">sPtrs</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">Write</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>类似的,即使方法有了值接收器,也同样可以用指针接收器来满足接口.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">F</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nf">f</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">S1</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">S1</span><span class="p">)</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">S2</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">S2</span><span class="p">)</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span>

<span class="nx">s1Val</span> <span class="o">:=</span> <span class="nx">S1</span><span class="p">{}</span>
<span class="nx">s1Ptr</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">S1</span><span class="p">{}</span>
<span class="nx">s2Val</span> <span class="o">:=</span> <span class="nx">S2</span><span class="p">{}</span>
<span class="nx">s2Ptr</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">S2</span><span class="p">{}</span>

<span class="kd">var</span> <span class="nx">i</span> <span class="nx">F</span>
<span class="nx">i</span> <span class="p">=</span> <span class="nx">s1Val</span>
<span class="nx">i</span> <span class="p">=</span> <span class="nx">s1Ptr</span>
<span class="nx">i</span> <span class="p">=</span> <span class="nx">s2Ptr</span>

<span class="c1">//  下面代码无法通过编译。因为 s2Val 是一个值，而 S2 的 f 方法中没有使用值接收器
</span><span class="c1">//   i = s2Val
</span></code></pre></td></tr></table>
</div>
</div><p><a href="https://golang.org/doc/effective_go.html">Effective Go</a> 中有一段关于 <a href="https://golang.org/doc/effective_go.html#pointers_vs_values">pointers vs. values</a> 的精彩讲解。</p>
<p>补充:</p>
<ul>
<li>一个类型可以有值接收器方法集和指针接收器方法集
<ul>
<li>值接收器方法集是指针接收器方法集的子集,反之不是</li>
</ul>
</li>
<li>规则
<ul>
<li>值对象只可以使用值接收器方法集</li>
<li>指针对象可以使用 值接收器方法集 + 指针接收器方法集</li>
</ul>
</li>
<li>接口的匹配(或者叫实现)
<ul>
<li>类型实现了接口的所有方法,叫匹配</li>
<li>具体的讲,要么是类型的值方法集匹配接口,要么是指针方法集匹配接口</li>
</ul>
</li>
</ul>
<p>具体的匹配分两种:</p>
<ul>
<li>值方法集和接口匹配
<ul>
<li>给接口变量赋值的不管是值还是指针对象,都ok,因为都包含值方法集</li>
</ul>
</li>
<li>指针方法集和接口匹配
<ul>
<li>只能将指针对象赋值给接口变量,因为只有指针方法集和接口匹配</li>
<li>如果将值对象赋值给接口变量,会在编译期报错(会触发接口合理性检查机制)</li>
</ul>
</li>
</ul>
<p>为啥 i = s2Val 会报错,因为值方法集和接口不匹配.</p>
<h3 id="零值-mutex-是有效的">零值 Mutex 是有效的<a hidden class="anchor" aria-hidden="true" href="#零值-mutex-是有效的">#</a></h3>
<p>零值 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code> 是有效的。所以指向 mutex 的指针基本是不必要的。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">mu</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">)</span>
<span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>如果你使用结构体指针，mutex 可以非指针形式作为结构体的组成字段，或者更好的方式是直接嵌入到结构体中。
如果是私有结构体类型或是要实现 Mutex 接口的类型，我们可以使用嵌入 mutex 的方法：</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">smap</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// only for unexported types（仅适用于非导出类型）
</span><span class="c1"></span>
  <span class="nx">data</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newSMap</span><span class="p">()</span> <span class="o">*</span><span class="nx">smap</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">smap</span><span class="p">{</span>
    <span class="nx">data</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">smap</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">k</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">m</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

  <span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SMap</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// 对于导出类型，请使用私有锁
</span><span class="c1"></span>
  <span class="nx">data</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewSMap</span><span class="p">()</span> <span class="o">*</span><span class="nx">SMap</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">SMap</span><span class="p">{</span>
    <span class="nx">data</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">SMap</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">k</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

  <span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="在边界处拷贝-slices-和-maps">在边界处拷贝 Slices 和 Maps<a hidden class="anchor" aria-hidden="true" href="#在边界处拷贝-slices-和-maps">#</a></h3>
<p>slices 和 maps 包含了指向底层数据的指针，因此在需要复制它们时要特别注意。</p>
<h4 id="接收-slices-和-maps">接收 Slices 和 Maps<a hidden class="anchor" aria-hidden="true" href="#接收-slices-和-maps">#</a></h4>
<p>请记住，当 map 或 slice 作为函数参数传入时，如果您存储了对它们的引用，则用户可以对其进行修改。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Driver</span><span class="p">)</span> <span class="nf">SetTrips</span><span class="p">(</span><span class="nx">trips</span> <span class="p">[]</span><span class="nx">Trip</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">d</span><span class="p">.</span><span class="nx">trips</span> <span class="p">=</span> <span class="nx">trips</span>
<span class="p">}</span>

<span class="nx">trips</span> <span class="o">:=</span> <span class="o">...</span>
<span class="nx">d1</span><span class="p">.</span><span class="nf">SetTrips</span><span class="p">(</span><span class="nx">trips</span><span class="p">)</span>

<span class="c1">// 你是要修改 d1.trips 吗？
</span><span class="c1"></span><span class="nx">trips</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Driver</span><span class="p">)</span> <span class="nf">SetTrips</span><span class="p">(</span><span class="nx">trips</span> <span class="p">[]</span><span class="nx">Trip</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">d</span><span class="p">.</span><span class="nx">trips</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">Trip</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">trips</span><span class="p">))</span>
  <span class="nb">copy</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">trips</span><span class="p">,</span> <span class="nx">trips</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">trips</span> <span class="o">:=</span> <span class="o">...</span>
<span class="nx">d1</span><span class="p">.</span><span class="nf">SetTrips</span><span class="p">(</span><span class="nx">trips</span><span class="p">)</span>

<span class="c1">// 这里我们修改 trips[0]，但不会影响到 d1.trips
</span><span class="c1"></span><span class="nx">trips</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="返回-slices-或-maps">返回 slices 或 maps<a hidden class="anchor" aria-hidden="true" href="#返回-slices-或-maps">#</a></h4>
<p>同样，请注意用户对暴露内部状态的 map 或 slice 的修改。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Stats</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>

  <span class="nx">counters</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// Snapshot 返回当前状态。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Stats</span><span class="p">)</span> <span class="nf">Snapshot</span><span class="p">()</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span>
  <span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

  <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">counters</span>
<span class="p">}</span>

<span class="c1">// snapshot 不再受互斥锁保护
</span><span class="c1">// 因此对 snapshot 的任何访问都将受到数据竞争的影响
</span><span class="c1">// 影响 stats.counters
</span><span class="c1"></span><span class="nx">snapshot</span> <span class="o">:=</span> <span class="nx">stats</span><span class="p">.</span><span class="nf">Snapshot</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Stats</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>

  <span class="nx">counters</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Stats</span><span class="p">)</span> <span class="nf">Snapshot</span><span class="p">()</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span>
  <span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

  <span class="nx">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">counters</span><span class="p">))</span>
  <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">counters</span> <span class="p">{</span>
    <span class="nx">result</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// snapshot 现在是一个拷贝
</span><span class="c1"></span><span class="nx">snapshot</span> <span class="o">:=</span> <span class="nx">stats</span><span class="p">.</span><span class="nf">Snapshot</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h3 id="使用-defer-释放资源">使用 defer 释放资源<a hidden class="anchor" aria-hidden="true" href="#使用-defer-释放资源">#</a></h3>
<p>使用 defer 释放资源，诸如文件和锁。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">p</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">count</span> <span class="p">&lt;</span> <span class="mi">10</span> <span class="p">{</span>
  <span class="nx">p</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">count</span>
<span class="p">}</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>
<span class="nx">newCount</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">count</span>
<span class="nx">p</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

<span class="k">return</span> <span class="nx">newCount</span>

<span class="c1">// 当有多个 return 分支时，很容易遗忘 unlock
</span></code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">p</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
<span class="k">defer</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">count</span> <span class="p">&lt;</span> <span class="mi">10</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">count</span>
<span class="p">}</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>
<span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">count</span>

<span class="c1">// 更可读
</span></code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>Defer 的开销非常小，只有在您可以证明函数执行时间处于纳秒级的程度时，才应避免这样做。使用 defer 提升可读性是值得的，因为使用它们的成本微不足道。尤其适用于那些不仅仅是简单内存访问的较大的方法，在这些方法中其他计算的资源消耗远超过 <code>defer</code>。</p>
<h3 id="channel-的-size-要么是-1要么是无缓冲的">Channel 的 size 要么是 1，要么是无缓冲的<a hidden class="anchor" aria-hidden="true" href="#channel-的-size-要么是-1要么是无缓冲的">#</a></h3>
<p>channel 通常 size 应为 1 或是无缓冲的。默认情况下，channel 是无缓冲的，其 size 为零。任何其他尺寸都必须经过严格的审查。我们需要考虑如何确定大小，考虑是什么阻止了 channel 在高负载下和阻塞写时的写入，以及当这种情况发生时系统逻辑有哪些变化。(翻译解释：按照原文意思是需要界定通道边界，竞态条件，以及逻辑上下文梳理)</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 应该足以满足任何情况！
</span><span class="c1"></span><span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 大小：1
</span><span class="c1"></span><span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 或者
</span><span class="c1">// 无缓冲 channel，大小为 0
</span><span class="c1"></span><span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h3 id="枚举从-1-开始">枚举从 1 开始<a hidden class="anchor" aria-hidden="true" href="#枚举从-1-开始">#</a></h3>
<p>在 Go 中引入枚举的标准方法是声明一个自定义类型和一个使用了 iota 的 const 组。由于变量的默认值为 0，因此通常应以非零值开头枚举。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Operation</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">Add</span> <span class="nx">Operation</span> <span class="p">=</span> <span class="kc">iota</span>
  <span class="nx">Subtract</span>
  <span class="nx">Multiply</span>
<span class="p">)</span>

<span class="c1">// Add=0, Subtract=1, Multiply=2
</span></code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Operation</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">Add</span> <span class="nx">Operation</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="nx">Subtract</span>
  <span class="nx">Multiply</span>
<span class="p">)</span>

<span class="c1">// Add=1, Subtract=2, Multiply=3
</span></code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>在某些情况下，使用零值是有意义的（枚举从零开始），例如，当零值是理想的默认行为时。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">LogOutput</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">LogToStdout</span> <span class="nx">LogOutput</span> <span class="p">=</span> <span class="kc">iota</span>
  <span class="nx">LogToFile</span>
  <span class="nx">LogToRemote</span>
<span class="p">)</span>

<span class="c1">// LogToStdout=0, LogToFile=1, LogToRemote=2
</span></code></pre></td></tr></table>
</div>
</div><h3 id="使用-time-处理时间">使用 time 处理时间<a hidden class="anchor" aria-hidden="true" href="#使用-time-处理时间">#</a></h3>
<p>时间处理很复杂。关于时间的错误假设通常包括以下几点。</p>
<ol>
<li>一天有 24 小时</li>
<li>一小时有 60 分钟</li>
<li>一周有七天</li>
<li>一年 365 天</li>
<li><a href="https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time">还有更多</a></li>
</ol>
<p>例如，<em>1</em> 表示在一个时间点上加上 24 小时并不总是产生一个新的日历日。</p>
<p>因此，在处理时间时始终使用 <a href="https://golang.org/pkg/time/"><code>&quot;time&quot;</code></a> 包，因为它有助于以更安全、更准确的方式处理这些不正确的假设。</p>
<h4 id="使用-timetime-表达瞬时时间">使用 <code>time.Time</code> 表达瞬时时间<a hidden class="anchor" aria-hidden="true" href="#使用-timetime-表达瞬时时间">#</a></h4>
<p>在处理时间的瞬间时使用 <a href="https://golang.org/pkg/time/#Time"><code>time.time</code></a>，在比较、添加或减去时间时使用 <code>time.Time</code> 中的方法。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">isActive</span><span class="p">(</span><span class="nx">now</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">stop</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">start</span> <span class="o">&lt;=</span> <span class="nx">now</span> <span class="o">&amp;&amp;</span> <span class="nx">now</span> <span class="p">&lt;</span> <span class="nx">stop</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">isActive</span><span class="p">(</span><span class="nx">now</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">stop</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">start</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span> <span class="o">||</span> <span class="nx">start</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">now</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="nx">now</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">stop</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h4 id="使用-timeduration-表达时间段">使用 <code>time.Duration</code> 表达时间段<a hidden class="anchor" aria-hidden="true" href="#使用-timeduration-表达时间段">#</a></h4>
<p>在处理时间段时使用 <a href="https://golang.org/pkg/time/#Duration"><code>time.Duration</code></a> .</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">poll</span><span class="p">(</span><span class="nx">delay</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nf">poll</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1">// 是几秒钟还是几毫秒?
</span></code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">poll</span><span class="p">(</span><span class="nx">delay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nf">poll</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>回到第一个例子，在一个时间瞬间加上 24 小时，我们用于添加时间的方法取决于意图。如果我们想要下一个日历日(当前天的下一天)的同一个时间点，我们应该使用 <a href="https://golang.org/pkg/time/#Time.AddDate"><code>Time.AddDate</code></a>。但是，如果我们想保证某一时刻比前一时刻晚 24 小时，我们应该使用 <a href="https://golang.org/pkg/time/#Time.Add"><code>Time.Add</code></a>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">newDay</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">AddDate</span><span class="p">(</span><span class="mi">0</span> <span class="cm">/* years */</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* months */</span><span class="p">,</span> <span class="mi">1</span> <span class="cm">/* days */</span><span class="p">)</span>
<span class="nx">maybeNewDay</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">24</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="对外部系统使用-timetime-和-timeduration">对外部系统使用 <code>time.Time</code> 和 <code>time.Duration</code><a hidden class="anchor" aria-hidden="true" href="#对外部系统使用-timetime-和-timeduration">#</a></h4>
<p>尽可能在与外部系统的交互中使用 <code>time.Duration</code> 和 <code>time.Time</code> 例如 :</p>
<ul>
<li>
<p>Command-line 标志: <a href="https://golang.org/pkg/flag/"><code>flag</code></a> 通过 <a href="https://golang.org/pkg/time/#ParseDuration"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code></p>
</li>
<li>
<p>JSON: <a href="https://golang.org/pkg/encoding/json/"><code>encoding/json</code></a> 通过其 <a href="https://golang.org/pkg/time/#Time.UnmarshalJSON"><code>UnmarshalJSON</code> method</a> 方法支持将 <code>time.Time</code> 编码为 <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> 字符串</p>
</li>
<li>
<p>SQL: <a href="https://golang.org/pkg/database/sql/"><code>database/sql</code></a> 支持将 <code>DATETIME</code> 或 <code>TIMESTAMP</code> 列转换为 <code>time.Time</code>，如果底层驱动程序支持则返回</p>
</li>
<li>
<p>YAML: <a href="https://godoc.org/gopkg.in/yaml.v2"><code>gopkg.in/yaml.v2</code></a> 支持将 <code>time.Time</code> 作为 <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> 字符串，并通过 <a href="https://golang.org/pkg/time/#ParseDuration"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code>。</p>
</li>
</ul>
<p>当不能在这些交互中使用 <code>time.Duration</code> 时，请使用 <code>int</code> 或 <code>float64</code>，并在字段名称中包含单位。</p>
<p>例如，由于 <code>encoding/json</code> 不支持 <code>time.Duration</code>，因此该单位包含在字段的名称中。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// {&#34;interval&#34;: 2}
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Config</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Interval</span> <span class="kt">int</span> <span class="s">`json:&#34;interval&#34;`</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// {&#34;intervalMillis&#34;: 2000}
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Config</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">IntervalMillis</span> <span class="kt">int</span> <span class="s">`json:&#34;intervalMillis&#34;`</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>当在这些交互中不能使用 <code>time.Time</code> 时，除非达成一致，否则使用 <code>string</code> 和 <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> 中定义的格式时间戳。默认情况下，<a href="https://golang.org/pkg/time/#Time.UnmarshalText"><code>Time.UnmarshalText</code></a> 使用此格式，并可通过 <a href="https://golang.org/pkg/time/#RFC3339"><code>time.RFC3339</code></a> 在 <code>Time.Format</code> 和 <code>time.Parse</code> 中使用。</p>
<p>尽管这在实践中并不成问题，但请记住，<code>&quot;time&quot;</code> 包不支持解析闰秒时间戳（<a href="https://github.com/golang/go/issues/8728">8728</a>），也不在计算中考虑闰秒（<a href="https://github.com/golang/go/issues/15190">15190</a>）。如果您比较两个时间瞬间，则差异将不包括这两个瞬间之间可能发生的闰秒。</p>
<!-- raw HTML omitted -->
<h3 id="错误类型">错误类型<a hidden class="anchor" aria-hidden="true" href="#错误类型">#</a></h3>
<p>Go 中有多种声明错误（Error) 的选项：</p>
<ul>
<li><a href="https://golang.org/pkg/errors/#New"><code>errors.New</code></a> 对于简单静态字符串的错误</li>
<li><a href="https://golang.org/pkg/fmt/#Errorf"><code>fmt.Errorf</code></a> 用于格式化的错误字符串</li>
<li>实现 <code>Error()</code> 方法的自定义类型</li>
<li>用 <a href="https://godoc.org/github.com/pkg/errors#Wrap"><code>&quot;pkg/errors&quot;.Wrap</code></a> 的 Wrapped errors</li>
</ul>
<p>返回错误时，请考虑以下因素以确定最佳选择：</p>
<ul>
<li>
<p>这是一个不需要额外信息的简单错误吗？如果是这样，<a href="https://golang.org/pkg/errors/#New"><code>errors.New</code></a> 足够了。</p>
</li>
<li>
<p>客户需要检测并处理此错误吗？如果是这样，则应使用自定义类型并实现该 <code>Error()</code> 方法。</p>
</li>
<li>
<p>您是否正在传播下游函数返回的错误？如果是这样，请查看本文后面有关错误包装 <a href="#%E9%94%99%E8%AF%AF%E5%8C%85%E8%A3%85" title="Error-Wrapping">section on error wrapping</a> 部分的内容。</p>
</li>
<li>
<p>否则 <a href="https://golang.org/pkg/fmt/#Errorf"><code>fmt.Errorf</code></a> 就可以了。</p>
</li>
</ul>
<p>如果客户端需要检测错误，并且您已使用创建了一个简单的错误 <a href="https://golang.org/pkg/errors/#New"><code>errors.New</code></a>，请使用一个错误变量。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// package foo
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">Open</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;could not open&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// package bar
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">use</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">foo</span><span class="p">.</span><span class="nf">Open</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#34;could not open&#34;</span> <span class="p">{</span>
      <span class="c1">// handle
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;unknown error&#34;</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// package foo
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">ErrCouldNotOpen</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;could not open&#34;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">Open</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">ErrCouldNotOpen</span>
<span class="p">}</span>

<span class="c1">// package bar
</span><span class="c1"></span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">foo</span><span class="p">.</span><span class="nf">Open</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">foo</span><span class="p">.</span><span class="nx">ErrCouldNotOpen</span> <span class="p">{</span>
    <span class="c1">// handle
</span><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;unknown error&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>如果您有可能需要客户端检测的错误，并且想向其中添加更多信息（例如，它不是静态字符串），则应使用自定义类型。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">open</span><span class="p">(</span><span class="nx">file</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;file %q not found&#34;</span><span class="p">,</span> <span class="nx">file</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">use</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">open</span><span class="p">(</span><span class="s">&#34;testfile.txt&#34;</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">(),</span> <span class="s">&#34;not found&#34;</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// handle
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;unknown error&#34;</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">errNotFound</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">file</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="nx">errNotFound</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;file %q not found&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">file</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">open</span><span class="p">(</span><span class="nx">file</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">errNotFound</span><span class="p">{</span><span class="nx">file</span><span class="p">:</span> <span class="nx">file</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">use</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">open</span><span class="p">(</span><span class="s">&#34;testfile.txt&#34;</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">errNotFound</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
      <span class="c1">// handle
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;unknown error&#34;</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>直接导出自定义错误类型时要小心，因为它们已成为程序包公共 API 的一部分。最好公开匹配器功能以检查错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// package foo
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">errNotFound</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">file</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="nx">errNotFound</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;file %q not found&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">file</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">IsNotFoundError</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">errNotFound</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">ok</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Open</span><span class="p">(</span><span class="nx">file</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">errNotFound</span><span class="p">{</span><span class="nx">file</span><span class="p">:</span> <span class="nx">file</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// package bar
</span><span class="c1"></span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">foo</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">foo</span><span class="p">.</span><span class="nf">IsNotFoundError</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// handle
</span><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;unknown error&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h3 id="错误包装-error-wrapping">错误包装 (Error Wrapping)<a hidden class="anchor" aria-hidden="true" href="#错误包装-error-wrapping">#</a></h3>
<p>一个（函数/方法）调用失败时，有三种主要的错误传播方式：</p>
<ul>
<li>如果没有要添加的其他上下文，并且您想要维护原始错误类型，则返回原始错误。</li>
<li>添加上下文，使用 <a href="https://godoc.org/github.com/pkg/errors#Wrap"><code>&quot;pkg/errors&quot;.Wrap</code></a> 以便错误消息提供更多上下文 ,<a href="https://godoc.org/github.com/pkg/errors#Cause"><code>&quot;pkg/errors&quot;.Cause</code></a> 可用于提取原始错误。</li>
<li>如果调用者不需要检测或处理的特定错误情况，使用 <a href="https://golang.org/pkg/fmt/#Errorf"><code>fmt.Errorf</code></a>。</li>
</ul>
<p>建议在可能的地方添加上下文，以使您获得诸如“调用服务 foo：连接被拒绝”之类的更有用的错误，而不是诸如“连接被拒绝”之类的模糊错误。</p>
<p>在将上下文添加到返回的错误时，请避免使用“failed to”之类的短语以保持上下文简洁，这些短语会陈述明显的内容，并随着错误在堆栈中的渗透而逐渐堆积：</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">store</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span>
        <span class="s">&#34;failed to create new store: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">store</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span>
        <span class="s">&#34;new store: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">failed to x: failed to y: failed to create new store: the error
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">x: y: new store: the error
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>但是，一旦将错误发送到另一个系统，就应该明确消息是错误消息（例如使用<code>err</code>标记，或在日志中以”Failed”为前缀）。</p>
<p>另请参见 <a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">Don&rsquo;t just check errors, handle them gracefully</a>. 不要只是检查错误，要优雅地处理错误</p>
<h3 id="处理类型断言失败">处理类型断言失败<a hidden class="anchor" aria-hidden="true" href="#处理类型断言失败">#</a></h3>
<p><a href="https://golang.org/ref/spec#Type_assertions">type assertion</a> 的单个返回值形式针对不正确的类型将产生 panic。因此，请始终使用“comma ok”的惯用法。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">t</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">t</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
  <span class="c1">// 优雅地处理错误
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="不要-panic">不要 panic<a hidden class="anchor" aria-hidden="true" href="#不要-panic">#</a></h3>
<p>在生产环境中运行的代码必须避免出现 panic。panic 是 <a href="https://en.wikipedia.org/wiki/Cascading_failure">cascading failures</a> 级联失败的主要根源 。如果发生错误，该函数必须返回错误，并允许调用方决定如何处理它。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">bar</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">bar</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;bar must not be empty&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;USAGE: foo &lt;bar&gt;&#34;</span><span class="p">)</span>
    <span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nf">foo</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">bar</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">bar</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;bar must not be empty&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;USAGE: foo &lt;bar&gt;&#34;</span><span class="p">)</span>
    <span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>panic/recover 不是错误处理策略。仅当发生不可恢复的事情（例如：nil 引用）时，程序才必须 panic。程序初始化是一个例外：程序启动时应使程序中止的不良情况可能会引起 panic。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">_statusTemplate</span> <span class="p">=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">Must</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">).</span><span class="nf">Parse</span><span class="p">(</span><span class="s">&#34;_statusHTML&#34;</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>即使在测试代码中，也优先使用<code>t.Fatal</code>或者<code>t.FailNow</code>而不是 panic 来确保失败被标记。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// func TestFoo(t *testing.T)
</span><span class="c1"></span>
<span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">TempFile</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;test&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;failed to set up test&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// func TestFoo(t *testing.T)
</span><span class="c1"></span>
<span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">TempFile</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;test&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;failed to set up test&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="使用-gouberorgatomic">使用 go.uber.org/atomic<a hidden class="anchor" aria-hidden="true" href="#使用-gouberorgatomic">#</a></h3>
<p>使用 <a href="https://golang.org/pkg/sync/atomic/">sync/atomic</a> 包的原子操作对原始类型 (<code>int32</code>, <code>int64</code>等）进行操作，因为很容易忘记使用原子操作来读取或修改变量。</p>
<p><a href="https://godoc.org/go.uber.org/atomic">go.uber.org/atomic</a> 通过隐藏基础类型为这些操作增加了类型安全性。此外，它包括一个方便的<code>atomic.Bool</code>类型。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">foo</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">running</span> <span class="kt">int32</span>  <span class="c1">// atomic
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span><span class="o">*</span> <span class="nx">foo</span><span class="p">)</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">SwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">f</span><span class="p">.</span><span class="nx">running</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
     <span class="c1">// already running…
</span><span class="c1"></span>     <span class="k">return</span>
  <span class="p">}</span>
  <span class="c1">// start the Foo
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">foo</span><span class="p">)</span> <span class="nf">isRunning</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">f</span><span class="p">.</span><span class="nx">running</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1">// race!
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">foo</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">running</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Bool</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">foo</span><span class="p">)</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">f</span><span class="p">.</span><span class="nx">running</span><span class="p">.</span><span class="nf">Swap</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
     <span class="c1">// already running…
</span><span class="c1"></span>     <span class="k">return</span>
  <span class="p">}</span>
  <span class="c1">// start the Foo
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">foo</span><span class="p">)</span> <span class="nf">isRunning</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">f</span><span class="p">.</span><span class="nx">running</span><span class="p">.</span><span class="nf">Load</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h3 id="避免可变全局变量">避免可变全局变量<a hidden class="anchor" aria-hidden="true" href="#避免可变全局变量">#</a></h3>
<p>使用选择依赖注入方式避免改变全局变量。
既适用于函数指针又适用于其他值类型</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// sign.go
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">_timeNow</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span>
<span class="kd">func</span> <span class="nf">sign</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="nx">now</span> <span class="o">:=</span> <span class="nf">_timeNow</span><span class="p">()</span>
  <span class="k">return</span> <span class="nf">signWithTime</span><span class="p">(</span><span class="nx">msg</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// sign.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">signer</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">now</span> <span class="kd">func</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">newSigner</span><span class="p">()</span> <span class="o">*</span><span class="nx">signer</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">signer</span><span class="p">{</span>
    <span class="nx">now</span><span class="p">:</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">signer</span><span class="p">)</span> <span class="nf">Sign</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="nx">now</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">now</span><span class="p">()</span>
  <span class="k">return</span> <span class="nf">signWithTime</span><span class="p">(</span><span class="nx">msg</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// sign_test.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TestSign</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">oldTimeNow</span> <span class="o">:=</span> <span class="nx">_timeNow</span>
  <span class="nx">_timeNow</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">someFixedTime</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">_timeNow</span> <span class="p">=</span> <span class="nx">oldTimeNow</span> <span class="p">}()</span>
  <span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">want</span><span class="p">,</span> <span class="nf">sign</span><span class="p">(</span><span class="nx">give</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// sign_test.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TestSigner</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">s</span> <span class="o">:=</span> <span class="nf">newSigner</span><span class="p">()</span>
  <span class="nx">s</span><span class="p">.</span><span class="nx">now</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">someFixedTime</span>
  <span class="p">}</span>
  <span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">want</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Sign</span><span class="p">(</span><span class="nx">give</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h3 id="避免在公共结构中嵌入类型">避免在公共结构中嵌入类型<a hidden class="anchor" aria-hidden="true" href="#避免在公共结构中嵌入类型">#</a></h3>
<p>这些嵌入的类型泄漏实现细节、禁止类型演化和模糊的文档。</p>
<p>假设您使用共享的 <code>AbstractList</code> 实现了多种列表类型，请避免在具体的列表实现中嵌入 <code>AbstractList</code>。
相反，只需手动将方法写入具体的列表，该列表将委托给抽象列表。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">AbstractList</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="c1">// 添加将实体添加到列表中。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">AbstractList</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">e</span> <span class="nx">Entity</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// 移除从列表中移除实体。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">AbstractList</span><span class="p">)</span> <span class="nf">Remove</span><span class="p">(</span><span class="nx">e</span> <span class="nx">Entity</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ConcreteList 是一个实体列表。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ConcreteList</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="o">*</span><span class="nx">AbstractList</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ConcreteList 是一个实体列表。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ConcreteList</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">list</span> <span class="o">*</span><span class="nx">AbstractList</span>
<span class="p">}</span>
<span class="c1">// 添加将实体添加到列表中。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">ConcreteList</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">e</span> <span class="nx">Entity</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">l</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 移除从列表中移除实体。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">ConcreteList</span><span class="p">)</span> <span class="nf">Remove</span><span class="p">(</span><span class="nx">e</span> <span class="nx">Entity</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">l</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>Go 允许 <a href="https://golang.org/doc/effective_go.html#embedding">类型嵌入</a> 作为继承和组合之间的折衷。
外部类型获取嵌入类型的方法的隐式副本。
默认情况下，这些方法委托给嵌入实例的同一方法。</p>
<p>结构还获得与类型同名的字段。
所以，如果嵌入的类型是 public，那么字段是 public。为了保持向后兼容性，外部类型的每个未来版本都必须保留嵌入类型。</p>
<p>很少需要嵌入类型。
这是一种方便，可以帮助您避免编写冗长的委托方法。</p>
<p>即使嵌入兼容的抽象列表 <em>interface</em>，而不是结构体，这将为开发人员提供更大的灵活性来改变未来，但仍然泄露了具体列表使用抽象实现的细节。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// AbstractList 是各种实体列表的通用实现。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">AbstractList</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nf">Add</span><span class="p">(</span><span class="nx">Entity</span><span class="p">)</span>
  <span class="nf">Remove</span><span class="p">(</span><span class="nx">Entity</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// ConcreteList 是一个实体列表。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ConcreteList</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">AbstractList</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ConcreteList 是一个实体列表。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ConcreteList</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">list</span> <span class="o">*</span><span class="nx">AbstractList</span>
<span class="p">}</span>
<span class="c1">// 添加将实体添加到列表中。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">ConcreteList</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">e</span> <span class="nx">Entity</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">l</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 移除从列表中移除实体。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">ConcreteList</span><span class="p">)</span> <span class="nf">Remove</span><span class="p">(</span><span class="nx">e</span> <span class="nx">Entity</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">l</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>无论是使用嵌入式结构还是使用嵌入式接口，嵌入式类型都会限制类型的演化.</p>
<ul>
<li>向嵌入式接口添加方法是一个破坏性的改变。</li>
<li>删除嵌入类型是一个破坏性的改变。</li>
<li>即使使用满足相同接口的替代方法替换嵌入类型，也是一个破坏性的改变。</li>
</ul>
<p>尽管编写这些委托方法是乏味的，但是额外的工作隐藏了实现细节，留下了更多的更改机会，还消除了在文档中发现完整列表接口的间接性操作。</p>
<h3 id="避免使用内置名称">避免使用内置名称<a hidden class="anchor" aria-hidden="true" href="#避免使用内置名称">#</a></h3>
<p>Go语言规范<a href="https://golang.org/ref/spec">language specification</a> 概述了几个内置的，
不应在Go项目中使用的名称标识<a href="https://golang.org/ref/spec#Predeclared_identifiers">predeclared identifiers</a>。</p>
<p>根据上下文的不同，将这些标识符作为名称重复使用，
将在当前作用域（或任何嵌套作用域）中隐藏原始标识符，或者混淆代码。
在最好的情况下，编译器会报错；在最坏的情况下，这样的代码可能会引入潜在的、难以恢复的错误。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="kt">error</span> <span class="kt">string</span>
<span class="c1">// `error` 作用域隐式覆盖
</span><span class="c1"></span>
<span class="c1">// or
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">handleErrorMessage</span><span class="p">(</span><span class="kt">error</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// `error` 作用域隐式覆盖
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">errorMessage</span> <span class="kt">string</span>
<span class="c1">// `error` 指向内置的非覆盖
</span><span class="c1"></span>
<span class="c1">// or
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">handleErrorMessage</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// `error` 指向内置的非覆盖
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Foo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 虽然这些字段在技术上不构成阴影，但`error`或`string`字符串的重映射现在是不明确的。
</span><span class="c1"></span>    <span class="kt">error</span>  <span class="kt">error</span>
    <span class="kt">string</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Foo</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="c1">// `error` 和 `f.error` 在视觉上是相似的
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">f</span><span class="p">.</span><span class="kt">error</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Foo</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="c1">// `string` and `f.string` 在视觉上是相似的
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">f</span><span class="p">.</span><span class="kt">string</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Foo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// `error` and `string` 现在是明确的。
</span><span class="c1"></span>    <span class="nx">err</span> <span class="kt">error</span>
    <span class="nx">str</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Foo</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">f</span><span class="p">.</span><span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Foo</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">f</span><span class="p">.</span><span class="nx">str</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>注意，编译器在使用预先分隔的标识符时不会生成错误，
但是诸如<code>go vet</code>之类的工具会正确地指出这些和其他情况下的隐式问题。</p>
<h3 id="避免使用-init">避免使用 <code>init()</code><a hidden class="anchor" aria-hidden="true" href="#避免使用-init">#</a></h3>
<p>尽可能避免使用<code>init()</code>。当<code>init()</code>是不可避免或可取的，代码应先尝试：</p>
<ol>
<li>无论程序环境或调用如何，都要完全确定。</li>
<li>避免依赖于其他<code>init()</code>函数的顺序或副作用。虽然<code>init()</code>顺序是明确的，但代码可以更改，
因此<code>init()</code>函数之间的关系可能会使代码变得脆弱和容易出错。</li>
<li>避免访问或操作全局或环境状态，如机器信息、环境变量、工作目录、程序参数/输入等。</li>
<li>避免<code>I/O</code>，包括文件系统、网络和系统调用。</li>
</ol>
<p>不能满足这些要求的代码可能属于要作为<code>main()</code>调用的一部分<code>（或程序生命周期中的其他地方）， 或者作为</code>main()`本身的一部分写入。特别是，打算由其他程序使用的库应该特别注意完全确定性，
而不是执行“init magic”</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Foo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">_defaultFoo</span> <span class="nx">Foo</span>
<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">_defaultFoo</span> <span class="p">=</span> <span class="nx">Foo</span><span class="p">{</span>
        <span class="c1">// ...
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">_defaultFoo</span> <span class="p">=</span> <span class="nx">Foo</span><span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// or, 为了更好的可测试性:
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">_defaultFoo</span> <span class="p">=</span> <span class="nf">defaultFoo</span><span class="p">()</span>
<span class="kd">func</span> <span class="nf">defaultFoo</span><span class="p">()</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Foo</span><span class="p">{</span>
        <span class="c1">// ...
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Config</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">_config</span> <span class="nx">Config</span>
<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Bad: 基于当前目录
</span><span class="c1"></span>    <span class="nx">cwd</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getwd</span><span class="p">()</span>
    <span class="c1">// Bad: I/O
</span><span class="c1"></span>    <span class="nx">raw</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span>
        <span class="nx">path</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">cwd</span><span class="p">,</span> <span class="s">&#34;config&#34;</span><span class="p">,</span> <span class="s">&#34;config.yaml&#34;</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="nx">yaml</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">raw</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">_config</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Config</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">func</span> <span class="nf">loadConfig</span><span class="p">()</span> <span class="nx">Config</span> <span class="p">{</span>
    <span class="nx">cwd</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getwd</span><span class="p">()</span>
    <span class="c1">// handle err
</span><span class="c1"></span>    <span class="nx">raw</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span>
        <span class="nx">path</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">cwd</span><span class="p">,</span> <span class="s">&#34;config&#34;</span><span class="p">,</span> <span class="s">&#34;config.yaml&#34;</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="c1">// handle err
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">config</span> <span class="nx">Config</span>
    <span class="nx">yaml</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">raw</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">config</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">config</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>考虑到上述情况，在某些情况下，<code>init()</code>可能更可取或是必要的，可能包括：</p>
<ul>
<li>
<p>不能表示为单个赋值的复杂表达式。</p>
</li>
<li>
<p>可插入的钩子，如<code>database/sql</code>、编码类型注册表等。</p>
</li>
<li>
<p>对<a href="https://cloud.google.com/functions/docs/bestpractices/tips#use_global_variables_to_reuse_objects_in_future_invocations">Google Cloud Functions</a>和其他形式的确定性预计算的优化。</p>
</li>
</ul>
<h3 id="追加时优先指定切片容量">追加时优先指定切片容量<a hidden class="anchor" aria-hidden="true" href="#追加时优先指定切片容量">#</a></h3>
<p>追加时优先指定切片容量</p>
<p>在尽可能的情况下，在初始化要追加的切片时为<code>make()</code>提供一个容量值。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nx">size</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span><span class="p">{</span>
    <span class="nx">data</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nx">size</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span><span class="p">{</span>
    <span class="nx">data</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">BenchmarkBad-4    100000000    2.48s
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">BenchmarkGood-4   100000000    0.21s
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h2 id="性能">性能<a hidden class="anchor" aria-hidden="true" href="#性能">#</a></h2>
<p>性能方面的特定准则只适用于高频场景。</p>
<h3 id="优先使用-strconv-而不是-fmt">优先使用 strconv 而不是 fmt<a hidden class="anchor" aria-hidden="true" href="#优先使用-strconv-而不是-fmt">#</a></h3>
<p>将原语转换为字符串或从字符串转换时，<code>strconv</code>速度比<code>fmt</code>快。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">s</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Int</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">s</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Int</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">BenchmarkFmtSprint-4    143 ns/op    2 allocs/op
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">BenchmarkStrconv-4    64.2 ns/op    1 allocs/op
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h3 id="避免字符串到字节的转换">避免字符串到字节的转换<a hidden class="anchor" aria-hidden="true" href="#避免字符串到字节的转换">#</a></h3>
<p>不要反复从固定字符串创建字节 slice。相反，请执行一次转换并捕获结果。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;Hello world&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;Hello world&#34;</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">BenchmarkBad-4   50000000   22.2 ns/op
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">BenchmarkGood-4  500000000   3.25 ns/op
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h3 id="指定容器容量">指定容器容量<a hidden class="anchor" aria-hidden="true" href="#指定容器容量">#</a></h3>
<p>尽可能指定容器容量，以便为容器预先分配内存。这将在添加元素时最小化后续分配（通过复制和调整容器大小）。</p>
<h4 id="指定map容量提示">指定Map容量提示<a hidden class="anchor" aria-hidden="true" href="#指定map容量提示">#</a></h4>
<p>在尽可能的情况下，在使用 <code>make()</code> 初始化的时候提供容量信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">T1</span><span class="p">]</span><span class="nx">T2</span><span class="p">,</span> <span class="nx">hint</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>向<code>make()</code>提供容量提示会在初始化时尝试调整map的大小，这将减少在将元素添加到map时为map重新分配内存。</p>
<p>注意，与slices不同。map capacity提示并不保证完全的抢占式分配，而是用于估计所需的hashmap bucket的数量。
因此，在将元素添加到map时，甚至在指定map容量时，仍可能发生分配。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">os</span><span class="p">.</span><span class="nx">FileInfo</span><span class="p">)</span>

<span class="nx">files</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadDir</span><span class="p">(</span><span class="s">&#34;./files&#34;</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">files</span> <span class="p">{</span>
    <span class="nx">m</span><span class="p">[</span><span class="nx">f</span><span class="p">.</span><span class="nf">Name</span><span class="p">()]</span> <span class="p">=</span> <span class="nx">f</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="nx">files</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadDir</span><span class="p">(</span><span class="s">&#34;./files&#34;</span><span class="p">)</span>

<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">os</span><span class="p">.</span><span class="nx">FileInfo</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">files</span><span class="p">))</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">files</span> <span class="p">{</span>
    <span class="nx">m</span><span class="p">[</span><span class="nx">f</span><span class="p">.</span><span class="nf">Name</span><span class="p">()]</span> <span class="p">=</span> <span class="nx">f</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p><code>m</code> 是在没有大小提示的情况下创建的； 在运行时可能会有更多分配。</p>
<!-- raw HTML omitted -->
<p><code>m</code> 是有大小提示创建的；在运行时可能会有更少的分配。</p>
<!-- raw HTML omitted -->
<h4 id="指定切片容量">指定切片容量<a hidden class="anchor" aria-hidden="true" href="#指定切片容量">#</a></h4>
<p>在尽可能的情况下，在使用<code>make()</code>初始化切片时提供容量信息，特别是在追加切片时。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">length</span><span class="p">,</span> <span class="nx">capacity</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>与maps不同，slice capacity不是一个提示：编译器将为提供给<code>make()</code>的slice的容量分配足够的内存，
这意味着后续的append()`操作将导致零分配（直到slice的长度与容量匹配，在此之后，任何append都可能调整大小以容纳其他元素）。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nx">size</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span><span class="p">{</span>
    <span class="nx">data</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nx">size</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span><span class="p">{</span>
    <span class="nx">data</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">BenchmarkBad-4    100000000    2.48s
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">BenchmarkGood-4   100000000    0.21s
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h2 id="规范">规范<a hidden class="anchor" aria-hidden="true" href="#规范">#</a></h2>
<h3 id="一致性">一致性<a hidden class="anchor" aria-hidden="true" href="#一致性">#</a></h3>
<p>本文中概述的一些标准都是客观性的评估，是根据场景、上下文、或者主观性的判断；</p>
<p>但是最重要的是，<strong>保持一致</strong>.</p>
<p>一致性的代码更容易维护、是更合理的、需要更少的学习成本、并且随着新的约定出现或者出现错误后更容易迁移、更新、修复 bug</p>
<p>相反，一个单一的代码库会导致维护成本开销、不确定性和认知偏差。所有这些都会直接导致速度降低、
代码审查痛苦、而且增加 bug 数量</p>
<p>将这些标准应用于代码库时，建议在 package（或更大）级别进行更改，子包级别的应用程序通过将多个样式引入到同一代码中，违反了上述关注点。</p>
<h3 id="相似的声明放在一组">相似的声明放在一组<a hidden class="anchor" aria-hidden="true" href="#相似的声明放在一组">#</a></h3>
<p>Go 语言支持将相似的声明放在一个组内。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;a&#34;</span>
<span class="kn">import</span> <span class="s">&#34;b&#34;</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;a&#34;</span>
  <span class="s">&#34;b&#34;</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>这同样适用于常量、变量和类型声明：</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="kd">const</span> <span class="nx">a</span> <span class="p">=</span> <span class="mi">1</span>
<span class="kd">const</span> <span class="nx">b</span> <span class="p">=</span> <span class="mi">2</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="mi">1</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="p">=</span> <span class="mi">2</span>

<span class="kd">type</span> <span class="nx">Area</span> <span class="kt">float64</span>
<span class="kd">type</span> <span class="nx">Volume</span> <span class="kt">float64</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
  <span class="nx">a</span> <span class="p">=</span> <span class="mi">1</span>
  <span class="nx">b</span> <span class="p">=</span> <span class="mi">2</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
  <span class="nx">a</span> <span class="p">=</span> <span class="mi">1</span>
  <span class="nx">b</span> <span class="p">=</span> <span class="mi">2</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="p">(</span>
  <span class="nx">Area</span> <span class="kt">float64</span>
  <span class="nx">Volume</span> <span class="kt">float64</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>仅将相关的声明放在一组。不要将不相关的声明放在一组。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Operation</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">Add</span> <span class="nx">Operation</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="nx">Subtract</span>
  <span class="nx">Multiply</span>
  <span class="nx">ENV_VAR</span> <span class="p">=</span> <span class="s">&#34;MY_ENV&#34;</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Operation</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">Add</span> <span class="nx">Operation</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="nx">Subtract</span>
  <span class="nx">Multiply</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">ENV_VAR</span> <span class="p">=</span> <span class="s">&#34;MY_ENV&#34;</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>分组使用的位置没有限制，例如：你可以在函数内部使用它们：</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">f</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">red</span> <span class="p">=</span> <span class="nx">color</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="mh">0xff0000</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">green</span> <span class="p">=</span> <span class="nx">color</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="mh">0x00ff00</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">blue</span> <span class="p">=</span> <span class="nx">color</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="mh">0x0000ff</span><span class="p">)</span>

  <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">f</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="p">(</span>
    <span class="nx">red</span>   <span class="p">=</span> <span class="nx">color</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="mh">0xff0000</span><span class="p">)</span>
    <span class="nx">green</span> <span class="p">=</span> <span class="nx">color</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="mh">0x00ff00</span><span class="p">)</span>
    <span class="nx">blue</span>  <span class="p">=</span> <span class="nx">color</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="mh">0x0000ff</span><span class="p">)</span>
  <span class="p">)</span>

  <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h3 id="import-分组">import 分组<a hidden class="anchor" aria-hidden="true" href="#import-分组">#</a></h3>
<p>导入应该分为两组：</p>
<ul>
<li>标准库</li>
<li>其他库</li>
</ul>
<p>默认情况下，这是 goimports 应用的分组。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;os&#34;</span>
  <span class="s">&#34;go.uber.org/atomic&#34;</span>
  <span class="s">&#34;golang.org/x/sync/errgroup&#34;</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;os&#34;</span>

  <span class="s">&#34;go.uber.org/atomic&#34;</span>
  <span class="s">&#34;golang.org/x/sync/errgroup&#34;</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h3 id="包名">包名<a hidden class="anchor" aria-hidden="true" href="#包名">#</a></h3>
<p>当命名包时，请按下面规则选择一个名称：</p>
<ul>
<li>全部小写。没有大写或下划线。</li>
<li>大多数使用命名导入的情况下，不需要重命名。</li>
<li>简短而简洁。请记住，在每个使用的地方都完整标识了该名称。</li>
<li>不用复数。例如<code>net/url</code>，而不是<code>net/urls</code>。</li>
<li>不要用“common”，“util”，“shared”或“lib”。这些是不好的，信息量不足的名称。</li>
</ul>
<p>另请参阅 <a href="https://blog.golang.org/package-names">Package Names</a> 和 <a href="https://rakyll.org/style-packages/">Go 包样式指南</a>.</p>
<h3 id="函数名">函数名<a hidden class="anchor" aria-hidden="true" href="#函数名">#</a></h3>
<p>我们遵循 Go 社区关于使用 <a href="https://golang.org/doc/effective_go.html#mixed-caps">MixedCaps 作为函数名</a> 的约定。有一个例外，为了对相关的测试用例进行分组，函数名可能包含下划线，如：<code>TestMyFunction_WhatIsBeingTested</code>.</p>
<h3 id="导入别名">导入别名<a hidden class="anchor" aria-hidden="true" href="#导入别名">#</a></h3>
<p>如果程序包名称与导入路径的最后一个元素不匹配，则必须使用导入别名。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;net/http&#34;</span>

  <span class="nx">client</span> <span class="s">&#34;example.com/client-go&#34;</span>
  <span class="nx">trace</span> <span class="s">&#34;example.com/trace/v2&#34;</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>在所有其他情况下，除非导入之间有直接冲突，否则应避免导入别名。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;os&#34;</span>

  <span class="nx">nettrace</span> <span class="s">&#34;golang.net/x/trace&#34;</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;os&#34;</span>
  <span class="s">&#34;runtime/trace&#34;</span>

  <span class="nx">nettrace</span> <span class="s">&#34;golang.net/x/trace&#34;</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h3 id="函数分组与顺序">函数分组与顺序<a hidden class="anchor" aria-hidden="true" href="#函数分组与顺序">#</a></h3>
<ul>
<li>函数应按粗略的调用顺序排序。</li>
<li>同一文件中的函数应按接收者分组。</li>
</ul>
<p>因此，导出的函数应先出现在文件中，放在<code>struct</code>, <code>const</code>, <code>var</code>定义的后面。</p>
<p>在定义类型之后，但在接收者的其余方法之前，可能会出现一个 <code>newXYZ()</code>/<code>NewXYZ()</code></p>
<p>由于函数是按接收者分组的，因此普通工具函数应在文件末尾出现。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">something</span><span class="p">)</span> <span class="nf">Cost</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">calcCost</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">weights</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">something</span> <span class="kd">struct</span><span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">calcCost</span><span class="p">(</span><span class="nx">n</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">something</span><span class="p">)</span> <span class="nf">Stop</span><span class="p">()</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">newSomething</span><span class="p">()</span> <span class="o">*</span><span class="nx">something</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">something</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">something</span> <span class="kd">struct</span><span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">newSomething</span><span class="p">()</span> <span class="o">*</span><span class="nx">something</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">something</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">something</span><span class="p">)</span> <span class="nf">Cost</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">calcCost</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">weights</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">something</span><span class="p">)</span> <span class="nf">Stop</span><span class="p">()</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">calcCost</span><span class="p">(</span><span class="nx">n</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h3 id="减少嵌套">减少嵌套<a hidden class="anchor" aria-hidden="true" href="#减少嵌套">#</a></h3>
<p>代码应通过尽可能先处理错误情况/特殊情况并尽早返回或继续循环来减少嵌套。减少嵌套多个级别的代码的代码量。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">data</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nx">F1</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
    <span class="nx">v</span> <span class="p">=</span> <span class="nf">process</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Call</span><span class="p">();</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">v</span><span class="p">.</span><span class="nf">Send</span><span class="p">()</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Invalid v: %v&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">data</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nx">F1</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Invalid v: %v&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="k">continue</span>
  <span class="p">}</span>

  <span class="nx">v</span> <span class="p">=</span> <span class="nf">process</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Call</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="nx">v</span><span class="p">.</span><span class="nf">Send</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h3 id="不必要的-else">不必要的 else<a hidden class="anchor" aria-hidden="true" href="#不必要的-else">#</a></h3>
<p>如果在 if 的两个分支中都设置了变量，则可以将其替换为单个 if。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">a</span> <span class="kt">int</span>
<span class="k">if</span> <span class="nx">b</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="p">=</span> <span class="mi">100</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="p">=</span> <span class="mi">10</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">a</span> <span class="o">:=</span> <span class="mi">10</span>
<span class="k">if</span> <span class="nx">b</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="p">=</span> <span class="mi">100</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h3 id="顶层变量声明">顶层变量声明<a hidden class="anchor" aria-hidden="true" href="#顶层变量声明">#</a></h3>
<p>在顶层，使用标准<code>var</code>关键字。请勿指定类型，除非它与表达式的类型不同。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">_s</span> <span class="kt">string</span> <span class="p">=</span> <span class="nf">F</span><span class="p">()</span>

<span class="kd">func</span> <span class="nf">F</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;A&#34;</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">_s</span> <span class="p">=</span> <span class="nf">F</span><span class="p">()</span>
<span class="c1">// 由于 F 已经明确了返回一个字符串类型，因此我们没有必要显式指定_s 的类型
</span><span class="c1">// 还是那种类型
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">F</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;A&#34;</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>如果表达式的类型与所需的类型不完全匹配，请指定类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">myError</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">myError</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;error&#34;</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">F</span><span class="p">()</span> <span class="nx">myError</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">myError</span><span class="p">{}</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nx">_e</span> <span class="kt">error</span> <span class="p">=</span> <span class="nf">F</span><span class="p">()</span>
<span class="c1">// F 返回一个 myError 类型的实例，但是我们要 error 类型
</span></code></pre></td></tr></table>
</div>
</div><h3 id="对于未导出的顶层常量和变量使用_作为前缀">对于未导出的顶层常量和变量，使用_作为前缀<a hidden class="anchor" aria-hidden="true" href="#对于未导出的顶层常量和变量使用_作为前缀">#</a></h3>
<p>在未导出的顶级<code>vars</code>和<code>consts</code>， 前面加上前缀_，以使它们在使用时明确表示它们是全局符号。</p>
<p>例外：未导出的错误值，应以<code>err</code>开头。</p>
<p>基本依据：顶级变量和常量具有包范围作用域。使用通用名称可能很容易在其他文件中意外使用错误的值。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// foo.go
</span><span class="c1"></span>
<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">defaultPort</span> <span class="p">=</span> <span class="mi">8080</span>
  <span class="nx">defaultUser</span> <span class="p">=</span> <span class="s">&#34;user&#34;</span>
<span class="p">)</span>

<span class="c1">// bar.go
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">Bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">defaultPort</span> <span class="o">:=</span> <span class="mi">9090</span>
  <span class="o">...</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Default port&#34;</span><span class="p">,</span> <span class="nx">defaultPort</span><span class="p">)</span>

  <span class="c1">// We will not see a compile error if the first line of
</span><span class="c1"></span>  <span class="c1">// Bar() is deleted.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// foo.go
</span><span class="c1"></span>
<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">_defaultPort</span> <span class="p">=</span> <span class="mi">8080</span>
  <span class="nx">_defaultUser</span> <span class="p">=</span> <span class="s">&#34;user&#34;</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h3 id="结构体中的嵌入">结构体中的嵌入<a hidden class="anchor" aria-hidden="true" href="#结构体中的嵌入">#</a></h3>
<p>嵌入式类型（例如 mutex）应位于结构体内的字段列表的顶部，并且必须有一个空行将嵌入式字段与常规字段分隔开。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Client</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">version</span> <span class="kt">int</span>
  <span class="nx">http</span><span class="p">.</span><span class="nx">Client</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Client</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">http</span><span class="p">.</span><span class="nx">Client</span>

  <span class="nx">version</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>内嵌应该提供切实的好处，比如以语义上合适的方式添加或增强功能。
它应该在对用户不利影响的情况下完成这项工作（另请参见：<code>避免在公共结构中嵌入类型</code><a href="#avoid-embedding-types-in-public-structs">Avoid Embedding Types in Public Structs</a>）。</p>
<p>嵌入 <strong>不应该</strong>:</p>
<ul>
<li>纯粹是为了美观或方便。</li>
<li>使外部类型更难构造或使用。</li>
<li>影响外部类型的零值。如果外部类型有一个有用的零值，则在嵌入内部类型之后应该仍然有一个有用的零值。</li>
<li>作为嵌入内部类型的副作用，从外部类型公开不相关的函数或字段。</li>
<li>公开未导出的类型。</li>
<li>影响外部类型的复制形式。</li>
<li>更改外部类型的API或类型语义。</li>
<li>嵌入内部类型的非规范形式。</li>
<li>公开外部类型的实现详细信息。</li>
<li>允许用户观察或控制类型内部。</li>
<li>通过包装的方式改变内部函数的一般行为，这种包装方式会给用户带来一些意料之外情况。</li>
</ul>
<p>简单地说，有意识地和有意识地嵌入。一种很好的测试体验是，
&ldquo;是否所有这些导出的内部方法/字段都将直接添加到外部类型&rdquo;
如果答案是<code>some</code>或<code>no</code>，不要嵌入内部类型-而是使用字段。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">A</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Bad: A.Lock() and A.Unlock() 现在可用
</span><span class="c1"></span>    <span class="c1">// 不提供任何功能性好处，并允许用户控制有关A的内部细节。
</span><span class="c1"></span>    <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">countingWriteCloser</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Good: Write() 在外层提供用于特定目的，
</span><span class="c1"></span>    <span class="c1">// 并且委托工作到内部类型的Write()中。
</span><span class="c1"></span>    <span class="nx">io</span><span class="p">.</span><span class="nx">WriteCloser</span>
    <span class="nx">count</span> <span class="kt">int</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">countingWriteCloser</span><span class="p">)</span> <span class="nf">Write</span><span class="p">(</span><span class="nx">bs</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">w</span><span class="p">.</span><span class="nx">count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">bs</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">w</span><span class="p">.</span><span class="nx">WriteCloser</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">bs</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Book</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Bad: 指针更改零值的有用性
</span><span class="c1"></span>    <span class="nx">io</span><span class="p">.</span><span class="nx">ReadWriter</span>
    <span class="c1">// other fields
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// later
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">b</span> <span class="nx">Book</span>
<span class="nx">b</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>  <span class="c1">// panic: nil pointer
</span><span class="c1"></span><span class="nx">b</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span>   <span class="c1">// panic: nil pointer
</span><span class="c1"></span><span class="nx">b</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="c1">// panic: nil pointer
</span></code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Book</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Good: 有用的零值
</span><span class="c1"></span>    <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
    <span class="c1">// other fields
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// later
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">b</span> <span class="nx">Book</span>
<span class="nx">b</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>  <span class="c1">// ok
</span><span class="c1"></span><span class="nx">b</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span>   <span class="c1">// ok
</span><span class="c1"></span><span class="nx">b</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="c1">// ok
</span></code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Client</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
    <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
    <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
    <span class="nx">url</span><span class="p">.</span><span class="nx">URL</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Client</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">mtx</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
    <span class="nx">wg</span>  <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
    <span class="nx">buf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
    <span class="nx">url</span> <span class="nx">url</span><span class="p">.</span><span class="nx">URL</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h3 id="使用字段名初始化结构体">使用字段名初始化结构体<a hidden class="anchor" aria-hidden="true" href="#使用字段名初始化结构体">#</a></h3>
<p>初始化结构体时，应该指定字段名称。现在由 <a href="https://golang.org/cmd/vet/"><code>go vet</code></a> 强制执行。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">k</span> <span class="o">:=</span> <span class="nx">User</span><span class="p">{</span><span class="s">&#34;John&#34;</span><span class="p">,</span> <span class="s">&#34;Doe&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">k</span> <span class="o">:=</span> <span class="nx">User</span><span class="p">{</span>
    <span class="nx">FirstName</span><span class="p">:</span> <span class="s">&#34;John&#34;</span><span class="p">,</span>
    <span class="nx">LastName</span><span class="p">:</span> <span class="s">&#34;Doe&#34;</span><span class="p">,</span>
    <span class="nx">Admin</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>例外：如果有 3 个或更少的字段，则可以在测试表中省略字段名称。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">tests</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">struct</span><span class="p">{</span>
  <span class="nx">op</span> <span class="nx">Operation</span>
  <span class="nx">want</span> <span class="kt">string</span>
<span class="p">}{</span>
  <span class="p">{</span><span class="nx">Add</span><span class="p">,</span> <span class="s">&#34;add&#34;</span><span class="p">},</span>
  <span class="p">{</span><span class="nx">Subtract</span><span class="p">,</span> <span class="s">&#34;subtract&#34;</span><span class="p">},</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="本地变量声明">本地变量声明<a hidden class="anchor" aria-hidden="true" href="#本地变量声明">#</a></h3>
<p>如果将变量明确设置为某个值，则应使用短变量声明形式 (<code>:=</code>)。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">s</span> <span class="p">=</span> <span class="s">&#34;foo&#34;</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="s">&#34;foo&#34;</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>但是，在某些情况下，<code>var</code> 使用关键字时默认值会更清晰。例如，声明空切片。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">f</span><span class="p">(</span><span class="nx">list</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">filtered</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">list</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">v</span> <span class="p">&gt;</span> <span class="mi">10</span> <span class="p">{</span>
      <span class="nx">filtered</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">filtered</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">f</span><span class="p">(</span><span class="nx">list</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">filtered</span> <span class="p">[]</span><span class="kt">int</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">list</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">v</span> <span class="p">&gt;</span> <span class="mi">10</span> <span class="p">{</span>
      <span class="nx">filtered</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">filtered</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h3 id="nil-是一个有效的-slice">nil 是一个有效的 slice<a hidden class="anchor" aria-hidden="true" href="#nil-是一个有效的-slice">#</a></h3>
<p><code>nil</code> 是一个有效的长度为 0 的 slice，这意味着，</p>
<ul>
<li>
<p>您不应明确返回长度为零的切片。应该返回<code>nil</code> 来代替。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
</li>
<li>
<p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>。而非 <code>nil</code>。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
</li>
<li>
<p>零值切片（用<code>var</code>声明的切片）可立即使用，无需调用<code>make()</code>创建。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">nums</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
<span class="c1">// or, nums := make([]int)
</span><span class="c1"></span>
<span class="k">if</span> <span class="nx">add1</span> <span class="p">{</span>
  <span class="nx">nums</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">add2</span> <span class="p">{</span>
  <span class="nx">nums</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span>

<span class="k">if</span> <span class="nx">add1</span> <span class="p">{</span>
  <span class="nx">nums</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">add2</span> <span class="p">{</span>
  <span class="nx">nums</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
</li>
</ul>
<p>记住，虽然nil切片是有效的切片，但它不等于长度为0的切片（一个为nil，另一个不是），并且在不同的情况下（例如序列化），这两个切片的处理方式可能不同。</p>
<h3 id="缩小变量作用域">缩小变量作用域<a hidden class="anchor" aria-hidden="true" href="#缩小变量作用域">#</a></h3>
<p>如果有可能，尽量缩小变量作用范围。除非它与 <a href="#%E5%87%8F%E5%B0%91%E5%B5%8C%E5%A5%97">减少嵌套</a>的规则冲突。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">WriteFile</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">data</span><span class="p">,</span> <span class="mo">0644</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
 <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">WriteFile</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">data</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
 <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>如果需要在 if 之外使用函数调用的结果，则不应尝试缩小范围。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">err</span> <span class="p">=</span> <span class="nx">cfg</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">cfg</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cfg</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">cfg</span><span class="p">)</span>
<span class="k">return</span> <span class="kc">nil</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h3 id="避免参数语义不明确avoid-naked-parameters">避免参数语义不明确(Avoid Naked Parameters)<a hidden class="anchor" aria-hidden="true" href="#避免参数语义不明确avoid-naked-parameters">#</a></h3>
<p>函数调用中的<code>意义不明确的参数</code>可能会损害可读性。当参数名称的含义不明显时，请为参数添加 C 样式注释 (<code>/* ... */</code>)</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// func printInfo(name string, isLocal, done bool)
</span><span class="c1"></span>
<span class="nf">printInfo</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// func printInfo(name string, isLocal, done bool)
</span><span class="c1"></span>
<span class="nf">printInfo</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">,</span> <span class="kc">true</span> <span class="cm">/* isLocal */</span><span class="p">,</span> <span class="kc">true</span> <span class="cm">/* done */</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>对于上面的示例代码，还有一种更好的处理方式是将上面的 <code>bool</code> 类型换成自定义类型。将来，该参数可以支持不仅仅局限于两个状态（true/false）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Region</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">UnknownRegion</span> <span class="nx">Region</span> <span class="p">=</span> <span class="kc">iota</span>
  <span class="nx">Local</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Status</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">StatusReady</span> <span class="nx">Status</span><span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="nx">StatusDone</span>
  <span class="c1">// Maybe we will have a StatusInProgress in the future.
</span><span class="c1"></span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">printInfo</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">region</span> <span class="nx">Region</span><span class="p">,</span> <span class="nx">status</span> <span class="nx">Status</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="使用原始字符串字面值避免转义">使用原始字符串字面值，避免转义<a hidden class="anchor" aria-hidden="true" href="#使用原始字符串字面值避免转义">#</a></h3>
<p>Go 支持使用 <a href="https://golang.org/ref/spec#raw_string_lit">原始字符串字面值</a>，也就是 &quot; ` &quot; 来表示原生字符串，在需要转义的场景下，我们应该尽量使用这种方案来替换。</p>
<p>可以跨越多行并包含引号。使用这些字符串可以避免更难阅读的手工转义的字符串。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">wantError</span> <span class="o">:=</span> <span class="s">&#34;unknown name:\&#34;test\&#34;&#34;</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">wantError</span> <span class="o">:=</span> <span class="s">`unknown error:&#34;test&#34;`</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h3 id="初始化-struct-引用">初始化 Struct 引用<a hidden class="anchor" aria-hidden="true" href="#初始化-struct-引用">#</a></h3>
<p>在初始化结构引用时，请使用<code>&amp;T{}</code>代替<code>new(T)</code>，以使其与结构体初始化一致。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">sval</span> <span class="o">:=</span> <span class="nx">T</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;foo&#34;</span><span class="p">}</span>

<span class="c1">// inconsistent
</span><span class="c1"></span><span class="nx">sptr</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>
<span class="nx">sptr</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="s">&#34;bar&#34;</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">sval</span> <span class="o">:=</span> <span class="nx">T</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;foo&#34;</span><span class="p">}</span>

<span class="nx">sptr</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">T</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;bar&#34;</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h3 id="初始化-maps">初始化 Maps<a hidden class="anchor" aria-hidden="true" href="#初始化-maps">#</a></h3>
<p>对于空 map 请使用 <code>make(..)</code> 初始化， 并且 map 是通过编程方式填充的。
这使得 map 初始化在表现上不同于声明，并且它还可以方便地在 make 后添加大小提示。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
  <span class="c1">// m1 读写安全;
</span><span class="c1"></span>  <span class="c1">// m2 在写入时会 panic
</span><span class="c1"></span>  <span class="nx">m1</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="nx">T1</span><span class="p">]</span><span class="nx">T2</span><span class="p">{}</span>
  <span class="nx">m2</span> <span class="kd">map</span><span class="p">[</span><span class="nx">T1</span><span class="p">]</span><span class="nx">T2</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
  <span class="c1">// m1 读写安全;
</span><span class="c1"></span>  <span class="c1">// m2 在写入时会 panic
</span><span class="c1"></span>  <span class="nx">m1</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">T1</span><span class="p">]</span><span class="nx">T2</span><span class="p">)</span>
  <span class="nx">m2</span> <span class="kd">map</span><span class="p">[</span><span class="nx">T1</span><span class="p">]</span><span class="nx">T2</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>声明和初始化看起来非常相似的。</p>
<!-- raw HTML omitted -->
<p>声明和初始化看起来差别非常大。</p>
<!-- raw HTML omitted -->
<p>在尽可能的情况下，请在初始化时提供 map 容量大小，详细请看 <a href="#%E6%8C%87%E5%AE%9AMap%E5%AE%B9%E9%87%8F%E6%8F%90%E7%A4%BA">指定Map容量提示</a>。</p>
<p>另外，如果 map 包含固定的元素列表，则使用 map literals(map 初始化列表) 初始化映射。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">T1</span><span class="p">]</span><span class="nx">T2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nx">m</span><span class="p">[</span><span class="nx">k1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v1</span>
<span class="nx">m</span><span class="p">[</span><span class="nx">k2</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v2</span>
<span class="nx">m</span><span class="p">[</span><span class="nx">k3</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v3</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="nx">T1</span><span class="p">]</span><span class="nx">T2</span><span class="p">{</span>
  <span class="nx">k1</span><span class="p">:</span> <span class="nx">v1</span><span class="p">,</span>
  <span class="nx">k2</span><span class="p">:</span> <span class="nx">v2</span><span class="p">,</span>
  <span class="nx">k3</span><span class="p">:</span> <span class="nx">v3</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>基本准则是：在初始化时使用 map 初始化列表 来添加一组固定的元素。否则使用 <code>make</code> (如果可以，请尽量指定 map 容量)。</p>
<h3 id="字符串-string-format">字符串 string format<a hidden class="anchor" aria-hidden="true" href="#字符串-string-format">#</a></h3>
<p>如果你在函数外声明<code>Printf</code>-style 函数的格式字符串，请将其设置为<code>const</code>常量。</p>
<p>这有助于<code>go vet</code>对格式字符串执行静态分析。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">msg</span> <span class="o">:=</span> <span class="s">&#34;unexpected values %v, %v\n&#34;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="nx">msg</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">msg</span> <span class="p">=</span> <span class="s">&#34;unexpected values %v, %v\n&#34;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="nx">msg</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h3 id="命名-printf-样式的函数">命名 Printf 样式的函数<a hidden class="anchor" aria-hidden="true" href="#命名-printf-样式的函数">#</a></h3>
<p>声明<code>Printf</code>-style 函数时，请确保<code>go vet</code>可以检测到它并检查格式字符串。</p>
<p>这意味着您应尽可能使用预定义的<code>Printf</code>-style 函数名称。<code>go vet</code>将默认检查这些。有关更多信息，请参见 <a href="https://golang.org/cmd/vet/#hdr-Printf_family">Printf 系列</a>。</p>
<p>如果不能使用预定义的名称，请以 f 结束选择的名称：<code>Wrapf</code>，而不是<code>Wrap</code>。<code>go vet</code>可以要求检查特定的 Printf 样式名称，但名称必须以<code>f</code>结尾。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">go vet -printfuncs<span class="o">=</span>wrapf,statusf
</code></pre></td></tr></table>
</div>
</div><p>另请参阅 <a href="https://kuzminva.wordpress.com/2017/11/07/go-vet-printf-family-check/">go vet: Printf family check</a>.</p>
<h2 id="编程模式">编程模式<a hidden class="anchor" aria-hidden="true" href="#编程模式">#</a></h2>
<h3 id="表驱动测试">表驱动测试<a hidden class="anchor" aria-hidden="true" href="#表驱动测试">#</a></h3>
<p>当测试逻辑是重复的时候，通过  <a href="https://blog.golang.org/subtests">subtests</a> 使用 table 驱动的方式编写 case 代码看上去会更简洁。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// func TestSplitHostPort(t *testing.T)
</span><span class="c1"></span>
<span class="nx">host</span><span class="p">,</span> <span class="nx">port</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">SplitHostPort</span><span class="p">(</span><span class="s">&#34;192.0.2.0:8000&#34;</span><span class="p">)</span>
<span class="nx">require</span><span class="p">.</span><span class="nf">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="s">&#34;192.0.2.0&#34;</span><span class="p">,</span> <span class="nx">host</span><span class="p">)</span>
<span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="s">&#34;8000&#34;</span><span class="p">,</span> <span class="nx">port</span><span class="p">)</span>

<span class="nx">host</span><span class="p">,</span> <span class="nx">port</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">SplitHostPort</span><span class="p">(</span><span class="s">&#34;192.0.2.0:http&#34;</span><span class="p">)</span>
<span class="nx">require</span><span class="p">.</span><span class="nf">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="s">&#34;192.0.2.0&#34;</span><span class="p">,</span> <span class="nx">host</span><span class="p">)</span>
<span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="s">&#34;http&#34;</span><span class="p">,</span> <span class="nx">port</span><span class="p">)</span>

<span class="nx">host</span><span class="p">,</span> <span class="nx">port</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">SplitHostPort</span><span class="p">(</span><span class="s">&#34;:8000&#34;</span><span class="p">)</span>
<span class="nx">require</span><span class="p">.</span><span class="nf">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">host</span><span class="p">)</span>
<span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="s">&#34;8000&#34;</span><span class="p">,</span> <span class="nx">port</span><span class="p">)</span>

<span class="nx">host</span><span class="p">,</span> <span class="nx">port</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">SplitHostPort</span><span class="p">(</span><span class="s">&#34;1:8&#34;</span><span class="p">)</span>
<span class="nx">require</span><span class="p">.</span><span class="nf">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="nx">host</span><span class="p">)</span>
<span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="s">&#34;8&#34;</span><span class="p">,</span> <span class="nx">port</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// func TestSplitHostPort(t *testing.T)
</span><span class="c1"></span>
<span class="nx">tests</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">struct</span><span class="p">{</span>
  <span class="nx">give</span>     <span class="kt">string</span>
  <span class="nx">wantHost</span> <span class="kt">string</span>
  <span class="nx">wantPort</span> <span class="kt">string</span>
<span class="p">}{</span>
  <span class="p">{</span>
    <span class="nx">give</span><span class="p">:</span>     <span class="s">&#34;192.0.2.0:8000&#34;</span><span class="p">,</span>
    <span class="nx">wantHost</span><span class="p">:</span> <span class="s">&#34;192.0.2.0&#34;</span><span class="p">,</span>
    <span class="nx">wantPort</span><span class="p">:</span> <span class="s">&#34;8000&#34;</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="p">{</span>
    <span class="nx">give</span><span class="p">:</span>     <span class="s">&#34;192.0.2.0:http&#34;</span><span class="p">,</span>
    <span class="nx">wantHost</span><span class="p">:</span> <span class="s">&#34;192.0.2.0&#34;</span><span class="p">,</span>
    <span class="nx">wantPort</span><span class="p">:</span> <span class="s">&#34;http&#34;</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="p">{</span>
    <span class="nx">give</span><span class="p">:</span>     <span class="s">&#34;:8000&#34;</span><span class="p">,</span>
    <span class="nx">wantHost</span><span class="p">:</span> <span class="s">&#34;&#34;</span><span class="p">,</span>
    <span class="nx">wantPort</span><span class="p">:</span> <span class="s">&#34;8000&#34;</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="p">{</span>
    <span class="nx">give</span><span class="p">:</span>     <span class="s">&#34;1:8&#34;</span><span class="p">,</span>
    <span class="nx">wantHost</span><span class="p">:</span> <span class="s">&#34;1&#34;</span><span class="p">,</span>
    <span class="nx">wantPort</span><span class="p">:</span> <span class="s">&#34;8&#34;</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">}</span>

<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">tt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="nx">tt</span><span class="p">.</span><span class="nx">give</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">host</span><span class="p">,</span> <span class="nx">port</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">SplitHostPort</span><span class="p">(</span><span class="nx">tt</span><span class="p">.</span><span class="nx">give</span><span class="p">)</span>
    <span class="nx">require</span><span class="p">.</span><span class="nf">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">tt</span><span class="p">.</span><span class="nx">wantHost</span><span class="p">,</span> <span class="nx">host</span><span class="p">)</span>
    <span class="nx">assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">tt</span><span class="p">.</span><span class="nx">wantPort</span><span class="p">,</span> <span class="nx">port</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>很明显，使用 test table 的方式在代码逻辑扩展的时候，比如新增 test case，都会显得更加的清晰。</p>
<p>我们遵循这样的约定：将结构体切片称为<code>tests</code>。 每个测试用例称为<code>tt</code>。此外，我们鼓励使用<code>give</code>和<code>want</code>前缀说明每个测试用例的输入和输出值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">tests</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">struct</span><span class="p">{</span>
  <span class="nx">give</span>     <span class="kt">string</span>
  <span class="nx">wantHost</span> <span class="kt">string</span>
  <span class="nx">wantPort</span> <span class="kt">string</span>
<span class="p">}{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>

<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">tt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="功能选项">功能选项<a hidden class="anchor" aria-hidden="true" href="#功能选项">#</a></h3>
<p>功能选项是一种模式，您可以在其中声明一个不透明 Option 类型，该类型在某些内部结构中记录信息。您接受这些选项的可变编号，并根据内部结构上的选项记录的全部信息采取行动。</p>
<p>将此模式用于您需要扩展的构造函数和其他公共 API 中的可选参数，尤其是在这些功能上已经具有三个或更多参数的情况下。</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// package db
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">Open</span><span class="p">(</span>
  <span class="nx">addr</span> <span class="kt">string</span><span class="p">,</span>
  <span class="nx">cache</span> <span class="kt">bool</span><span class="p">,</span>
  <span class="nx">logger</span> <span class="o">*</span><span class="nx">zap</span><span class="p">.</span><span class="nx">Logger</span>
<span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Connection</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// package db
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">Option</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">WithCache</span><span class="p">(</span><span class="nx">c</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">Option</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">WithLogger</span><span class="p">(</span><span class="nx">log</span> <span class="o">*</span><span class="nx">zap</span><span class="p">.</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">Option</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Open creates a connection.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Open</span><span class="p">(</span>
  <span class="nx">addr</span> <span class="kt">string</span><span class="p">,</span>
  <span class="nx">opts</span> <span class="o">...</span><span class="nx">Option</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Connection</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>必须始终提供缓存和记录器参数，即使用户希望使用默认值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">db</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">db</span><span class="p">.</span><span class="nx">DefaultCache</span><span class="p">,</span> <span class="nx">zap</span><span class="p">.</span><span class="nf">NewNop</span><span class="p">())</span>
<span class="nx">db</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">db</span><span class="p">.</span><span class="nx">DefaultCache</span><span class="p">,</span> <span class="nx">log</span><span class="p">)</span>
<span class="nx">db</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="kc">false</span> <span class="cm">/* cache */</span><span class="p">,</span> <span class="nx">zap</span><span class="p">.</span><span class="nf">NewNop</span><span class="p">())</span>
<span class="nx">db</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="kc">false</span> <span class="cm">/* cache */</span><span class="p">,</span> <span class="nx">log</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>只有在需要时才提供选项。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">db</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span>
<span class="nx">db</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">db</span><span class="p">.</span><span class="nf">WithLogger</span><span class="p">(</span><span class="nx">log</span><span class="p">))</span>
<span class="nx">db</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">db</span><span class="p">.</span><span class="nf">WithCache</span><span class="p">(</span><span class="kc">false</span><span class="p">))</span>
<span class="nx">db</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span>
  <span class="nx">addr</span><span class="p">,</span>
  <span class="nx">db</span><span class="p">.</span><span class="nf">WithCache</span><span class="p">(</span><span class="kc">false</span><span class="p">),</span>
  <span class="nx">db</span><span class="p">.</span><span class="nf">WithLogger</span><span class="p">(</span><span class="nx">log</span><span class="p">),</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<p>Our suggested way of implementing this pattern is with an <code>Option</code> interface
that holds an unexported method, recording options on an unexported <code>options</code>
struct.</p>
<p>我们建议实现此模式的方法是使用一个 <code>Option</code> 接口，该接口保存一个未导出的方法，在一个未导出的 <code>options</code> 结构上记录选项。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">options</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">cache</span>  <span class="kt">bool</span>
  <span class="nx">logger</span> <span class="o">*</span><span class="nx">zap</span><span class="p">.</span><span class="nx">Logger</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Option</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nf">apply</span><span class="p">(</span><span class="o">*</span><span class="nx">options</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">cacheOption</span> <span class="kt">bool</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">cacheOption</span><span class="p">)</span> <span class="nf">apply</span><span class="p">(</span><span class="nx">opts</span> <span class="o">*</span><span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">opts</span><span class="p">.</span><span class="nx">cache</span> <span class="p">=</span> <span class="nb">bool</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">WithCache</span><span class="p">(</span><span class="nx">c</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">Option</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">cacheOption</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">loggerOption</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Log</span> <span class="o">*</span><span class="nx">zap</span><span class="p">.</span><span class="nx">Logger</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="nx">loggerOption</span><span class="p">)</span> <span class="nf">apply</span><span class="p">(</span><span class="nx">opts</span> <span class="o">*</span><span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">opts</span><span class="p">.</span><span class="nx">logger</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">Log</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">WithLogger</span><span class="p">(</span><span class="nx">log</span> <span class="o">*</span><span class="nx">zap</span><span class="p">.</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">Option</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">loggerOption</span><span class="p">{</span><span class="nx">Log</span><span class="p">:</span> <span class="nx">log</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Open creates a connection.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Open</span><span class="p">(</span>
  <span class="nx">addr</span> <span class="kt">string</span><span class="p">,</span>
  <span class="nx">opts</span> <span class="o">...</span><span class="nx">Option</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Connection</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">options</span> <span class="o">:=</span> <span class="nx">options</span><span class="p">{</span>
    <span class="nx">cache</span><span class="p">:</span>  <span class="nx">defaultCache</span><span class="p">,</span>
    <span class="nx">logger</span><span class="p">:</span> <span class="nx">zap</span><span class="p">.</span><span class="nf">NewNop</span><span class="p">(),</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">o</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
    <span class="nx">o</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">options</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意: 还有一种使用闭包实现这个模式的方法，但是我们相信上面的模式为作者提供了更多的灵活性，并且更容易对用户进行调试和测试。特别是，在不可能进行比较的情况下它允许在测试和模拟中对选项进行比较。此外，它还允许选项实现其他接口，包括 <code>fmt.Stringer</code>，允许用户读取选项的字符串表示形式。</p>
<p>还可以参考下面资料：</p>
<ul>
<li>
<p><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html">Self-referential functions and the design of options</a></p>
</li>
<li>
<p><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis">Functional options for friendly APIs</a></p>
</li>
</ul>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="stargazers-over-time">Stargazers over time<a hidden class="anchor" aria-hidden="true" href="#stargazers-over-time">#</a></h2>
<p><a href="https://starchart.cc/xxjwxc/uber_go_guide_cn"><img loading="lazy" src="https://starchart.cc/xxjwxc/uber_go_guide_cn.svg" alt="Stargazers over time"  />
</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go%E8%A7%84%E8%8C%83/">Go规范</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
