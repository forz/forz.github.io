<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>探索Prometheus的Go客户端指标 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="前言 让我们从一个简单的程序开始，注册prom处理程序并监听8080端口： 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;github.com/prometheus/client_golang/prometheus/promhttp&amp;#34; ) func main() { http.Handle(&amp;#34;/metrics&amp;#34;, promhttp.Handler()) log.Fatal( http.ListenAndServe(&amp;#34;:8080&amp;#34;, nil)) } 当你点击" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.91.2 with theme even" />


<link rel="canonical" href="/post/%E6%8E%A2%E7%B4%A2prometheus%E7%9A%84go%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8C%87%E6%A0%87/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="探索Prometheus的Go客户端指标" />
<meta property="og:description" content="前言 让我们从一个简单的程序开始，注册prom处理程序并监听8080端口： 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( &#34;log&#34; &#34;net/http&#34; &#34;github.com/prometheus/client_golang/prometheus/promhttp&#34; ) func main() { http.Handle(&#34;/metrics&#34;, promhttp.Handler()) log.Fatal( http.ListenAndServe(&#34;:8080&#34;, nil)) } 当你点击" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E6%8E%A2%E7%B4%A2prometheus%E7%9A%84go%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8C%87%E6%A0%87/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-09-07T23:19:44+00:00" />
<meta property="article:modified_time" content="2021-09-07T23:19:44+00:00" />

<meta itemprop="name" content="探索Prometheus的Go客户端指标">
<meta itemprop="description" content="前言 让我们从一个简单的程序开始，注册prom处理程序并监听8080端口： 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( &#34;log&#34; &#34;net/http&#34; &#34;github.com/prometheus/client_golang/prometheus/promhttp&#34; ) func main() { http.Handle(&#34;/metrics&#34;, promhttp.Handler()) log.Fatal( http.ListenAndServe(&#34;:8080&#34;, nil)) } 当你点击"><meta itemprop="datePublished" content="2021-09-07T23:19:44+00:00" />
<meta itemprop="dateModified" content="2021-09-07T23:19:44+00:00" />
<meta itemprop="wordCount" content="6427">
<meta itemprop="keywords" content="prometheus," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="探索Prometheus的Go客户端指标"/>
<meta name="twitter:description" content="前言 让我们从一个简单的程序开始，注册prom处理程序并监听8080端口： 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( &#34;log&#34; &#34;net/http&#34; &#34;github.com/prometheus/client_golang/prometheus/promhttp&#34; ) func main() { http.Handle(&#34;/metrics&#34;, promhttp.Handler()) log.Fatal( http.ListenAndServe(&#34;:8080&#34;, nil)) } 当你点击"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">探索Prometheus的Go客户端指标</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-09-07 </span>
        <div class="post-category">
            <a href="/categories/prometheus/"> prometheus </a>
            </div>
          <span class="more-meta"> 约 6427 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#进程收集器">进程收集器</a></li>
    <li><a href="#go收集器">Go收集器</a></li>
    <li><a href="#内存">内存</a></li>
    <li><a href="#堆内存度量">堆内存度量</a></li>
    <li><a href="#堆栈内存度量">堆栈内存度量</a></li>
    <li><a href="#堆外内存指标">堆外内存指标</a></li>
    <li><a href="#玩转数字">玩转数字</a></li>
    <li><a href="#memstats--gcstats">MemStats &amp; GCStats</a></li>
    <li><a href="#总结">总结</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="前言">前言</h2>
<p>让我们从一个简单的程序开始，注册prom处理程序并监听8080端口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;log&#34;</span>
    <span class="s">&#34;net/http&#34;</span>

    <span class="s">&#34;github.com/prometheus/client_golang/prometheus/promhttp&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/metrics&#34;</span><span class="p">,</span> <span class="nx">promhttp</span><span class="p">.</span><span class="nf">Handler</span><span class="p">())</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span> <span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当你点击你的metrics端点时，你会得到类似的东西：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="c1"># HELP go_gc_duration_seconds A summary of the GC invocation durations</span>

<span class="c1"># TYPE go_gc_duration_seconds summary</span>

<span class="n">go_gc_duration_seconds</span><span class="p">{</span><span class="n">quantile</span><span class="o">=</span><span class="s">&#34;0&#34;</span><span class="p">}</span> <span class="m">3.5101e-05</span>

<span class="c1"># HELP go_goroutines Number of goroutines that currently exist</span>

<span class="c1"># TYPE go_goroutines gauge</span>

<span class="n">go_goroutines</span> <span class="m">6</span>
<span class="kc">...</span>
<span class="n">process_open_fds</span> <span class="m">12</span>

<span class="c1"># HELP process_resident_memory_bytes Resident memory size in bytes</span>

<span class="c1"># TYPE process_resident_memory_bytes gauge</span>

<span class="n">process_resident_memory_bytes</span> <span class="m">1.1272192e+07</span>

<span class="c1"># HELP process_virtual_memory_bytes Virtual memory size in bytes</span>

<span class="c1"># TYPE process_virtual_memory_bytes gauge</span>

<span class="n">process_virtual_memory_bytes</span> <span class="m">4.74484736e+08</span>
</code></pre></td></tr></table>
</div>
</div><p>在初始化时client_golang注册了2个Prometheus收集器。</p>
<ul>
<li>进程收集器 - 收集基本的Linux进程信息，如CPU、内存、文件描述符的使用和启动时间。</li>
<li>Go收集器&ndash;收集有关Go运行时的信息，如GC的细节、gouroutines的数量和OS线程。</li>
</ul>
<h2 id="进程收集器">进程收集器</h2>
<p>这个收集器所做的是读取proc文件系统。proc文件系统暴露了内部的内核数据结构，用来获取系统的信息。</p>
<p>所以普罗米修斯客户端读取/proc/PID/stat文件，它看起来像这样。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="m">1</span> <span class="p">(</span><span class="n">sh</span><span class="p">)</span> <span class="n">S</span> <span class="m">0</span> <span class="m">1</span> <span class="m">1</span> <span class="m">34816</span> <span class="m">8</span> <span class="m">4194560</span> <span class="m">674</span> <span class="m">43</span> <span class="m">9</span> <span class="m">1</span> <span class="m">5</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">20</span> <span class="m">0</span> <span class="m">1</span> <span class="m">0</span> <span class="m">89724</span> <span class="m">1581056</span> <span class="m">209</span> <span class="m">18446744073709551615</span> <span class="m">94672542621696</span> <span class="m">94672543427732</span> <span class="m">140730737801568</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">2637828</span> <span class="m">65538</span> <span class="m">1</span> <span class="m">0</span> <span class="m">0</span> <span class="m">17</span> <span class="m">3</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">94672545527192</span> <span class="m">94672545542787</span> <span class="m">94672557428736</span> <span class="m">140730737807231</span> <span class="m">140730737807234</span> <span class="m">140730737807234</span> <span class="m">140730737807344</span> <span class="m">0</span>
</code></pre></td></tr></table>
</div>
</div><p>你可以使用<code>cat /proc/PID/status</code>来获得这些信息的人类可读变体。</p>
<p>process_cpu_seconds_total - 它使用utime - 在用户模式下执行代码的次数，以jiffies衡量，stime - 在系统模式下花费的jiffies，代表进程执行代码（比如做系统调用）。一个jiffy是系统定时器中断的两个ticks之间的时间。</p>
<p>process_cpu_seconds_total 等于utime和stime的总和，并除以USER_HZ。这是有道理的，因为用调度器的刻度数除以Hz（每秒的刻度数）可以得出操作系统运行进程的总时间（秒）。</p>
<p>process_virtual_memory_bytes - 使用vsize - 虚拟内存大小是一个进程所管理的地址空间的数量。这包括所有类型的内存，包括RAM中的和换出的。</p>
<p>process_resident_memory_bytes - 乘以rss - 驻留集内存大小是进程在真实内存中的内存页数，页数为4。这导致了专门属于该进程的内存量，单位是字节。这不包括被交换出去的内存页。</p>
<p>process_start_time_seconds - 使用start_time - 进程在系统启动后开始的时间，以jiffies表示，btime来自<code>/proc/stat</code>，显示系统自Unix epoch以来启动的时间，以秒为单位。</p>
<p>process_open_fds - 计算<code>/proc/PID/fd</code>目录下的文件数量。它显示当前打开的常规文件、套接字、伪终端等。</p>
<p>process_max_fds - 读取<code>/proc/{PID}/limits</code>，并使用 &ldquo;Max Open Files &ldquo;行的Soft Limit。这里有趣的一点是，/limits列出了软限制和硬限制。</p>
<p>事实证明，软限制是内核对相应资源强制执行的值，而硬限制则作为软限制的上限。</p>
<p>一个没有特权的进程只能把它的软限制设置为一个不超过硬限制的值，并且（不可逆转地）降低它的硬限制。</p>
<p>在Go中，你可以使用<code>err = syscall.Setrlimit(syscall.RLIMIT_NOFILE, &amp;syscall.Rlimit{Cur: 9, Max: 10})</code>来设置限制。</p>
<h2 id="go收集器">Go收集器</h2>
<p>Go Collector的大部分指标都取自runtime、runtime/debug包。</p>
<p>go_goroutines - 调用 <code>runtime.NumGoroutine()</code>，它根据调度器结构和全局 allglen 变量计算出数值。由于调度器结构中的所有值都可以同时改变，所以有一个有趣的检查，如果计算值小于1，就变成1。</p>
<p>go_threads - 调用<code>runtime.CreateThreadProfile()</code>，它读取全局allm变量。</p>
<p>go_gc_duration_seconds - 调用<code>debug.ReadGCStats()</code>，PauseQuantile设置为5，它返回我们最小、25%、50%、75%和最大的暂停时间。然后它从暂停量值、NumGC var和PauseTotal seconds手动创建一个Summary类型。GCStats结构很适合prom的Summary类型，这很酷。</p>
<p>go_info - 这为我们提供了Go版本。这很聪明，它调用runtime.Version()并将其设置为版本标签，然后总是为这个度量指标返回1的值。</p>
<h2 id="内存">内存</h2>
<p>Go Collector为我们提供了很多关于内存和GC的指标。</p>
<p>所有这些指标都来自<code>runtime.ReadMemStats()</code>，它从MemStats结构中为我们提供指标。</p>
<p>有一件事让我很担心，那就是<code>runtime.ReadMemStats()</code>有一个明确的调用，让世界暂停。</p>
<p>所以我想知道这个暂停会带来多少实际成本？</p>
<p>因为在stop-the-world暂停期间，所有的goroutines都暂停了，所以GC可以运行。我可能会在以后的文章中对有和没有监控的应用程序做一个比较。</p>
<p>我们已经看到Linux为我们提供了rss/vsize的内存统计指标，那么问题自然就来了，到底是使用MemStats中提供的指标还是rss/vsize？</p>
<p>关于驻留集大小和虚拟内存大小的好处是，它是基于Linux原语的，并且与编程语言无关。</p>
<p>所以在理论上，你可以对任何程序进行检测，你会知道它消耗了多少内存（只要你的指标名称一致，即process_virtual_memory_bytes和process_resident_memory_bytes）。</p>
<p>然而，在实践中，当Go进程启动时，它事先需要大量的虚拟内存，像上面这样一个简单的程序在我的机器（x86_64 Ubuntu）上需要高达544MiB的vsize，这有点令人困惑。RSS显示大约7mib，这更接近实际使用情况。</p>
<p>另一方面，使用基于Go运行时的指标可以提供更细化的信息，了解正在运行的应用程序中发生了什么。</p>
<p>你应该能够更容易地发现你的程序是否有内存泄漏，GC花了多长时间，它回收了多少。</p>
<p>另外，当你优化程序的内存分配时，它应该为你指出正确的方向。</p>
<p>我还没有详细研究过Go的GC和内存模型是如何工作的，它的并发模型8的一部分，所以这一点对我来说还是很新鲜的。</p>
<p>那么让我们来看看这些指标：</p>
<p>go_memstats_alloc_bytes - 一个显示在堆上为对象分配多少字节内存的指标。其值与go_memstats_heap_alloc_bytes相同。这个指标计算所有可到达的堆对象加上不可到达的对象，GC还没有释放。</p>
<p>go_memstats_alloc_bytes_total - 这个指标随着对象在堆中的分配而增加，但当它们被释放时并没有减少。我认为它非常有用，因为它只是一个增加的数字，并且具有和Prometheus Counter一样的良好特性。对它进行rate()处理，应该可以显示出应用程序消耗了多少字节/秒的内存，并且在重启和读取指标失败时是 &ldquo;持久 &ldquo;的。</p>
<p>go_memstats_sys_bytes - 这是一个指标，用来衡量Go从系统中占用了多少字节的内存。它总结了下面描述的所有系统指标。</p>
<p>go_memstats_lookups_total - 计算发生了多少次指针解除引用。这是一个计数器值，所以你可以使用rate()来查找/s。</p>
<p>go_memstats_mallocs_total - 显示有多少个堆对象被分配。这是一个计数器的值，所以你可以使用rate()来计算分配的对象/s。</p>
<p>go_memstats_frees_total - 显示有多少堆对象被释放。这是一个计数器的值，所以你可以使用rate()来计算分配的对象。注意你可以用go_memstats_mallocs_total - go_memstats_frees_total来获得活对象的数量。</p>
<p>事实证明，Go将内存组织成span，即8K或更大的连续内存区域。有3种类型的span。</p>
<ol>
<li>idle - span，没有对象，可以释放回操作系统，或重新用于堆分配，或重新用于堆栈内存。
2）in use - span，至少有一个堆对象，可能有更多空间。
3）stack – span，用于goroutine堆栈。这个跨度可以存在于堆栈或堆中，但不能同时存在。</li>
</ol>
<h2 id="堆内存度量">堆内存度量</h2>
<p>go_memstats_heap_alloc_bytes - 与go_memstats_alloc_bytes相同。显示在堆上为对象分配多少字节内存的指标。这个指标计算所有可到达的堆对象加上不可到达的对象，GC还没有释放。</p>
<p>go_memstats_heap_sys_bytes - 从操作系统获得的堆内存的字节数。这包括已被重发但尚未使用的虚拟地址空间，以及在未使用后被退回给操作系统的虚拟地址空间。这个指标估计了堆的最大尺寸。</p>
<p>go_memstats_heap_idle_bytes - 显示有多少字节处于空闲span。</p>
<p>go_memstats_heap_idle_bytes 减去 go_memstats_heap_released_bytes 估计有多少字节的内存可以被释放，但被运行时保留，所以运行时可以在堆上分配对象而不向操作系统索取更多的内存。</p>
<p>go_memstats_heap_inuse_bytes - 显示有多少字节在in-use spans.</p>
<p>go_memstats_heap_inuse_bytes 减去 go_memstats_heap_alloc_bytes 显示有多少字节的内存已经分配给堆，但当前没有使用。</p>
<p>go_memstats_heap_released_bytes - 显示有多少字节的闲置跨度被返回给操作系统。</p>
<p>go_memstats_heap_objects - 显示有多少对象被分配在堆上。这随着GC的执行和新对象的分配而变化。</p>
<h2 id="堆栈内存度量">堆栈内存度量</h2>
<p>go_memstats_stack_inuse_bytes - 显示堆栈内存跨度使用了多少字节的内存，其中至少有一个对象。Go文档说，堆栈内存跨度只能用于其他堆栈跨度，也就是说，在一个内存跨度中不能混合使用堆对象和堆栈对象。</p>
<p>go_memstats_stack_sys_bytes - 显示从操作系统获得多少字节的堆栈内存。它是go_memstats_stack_inuse_bytes加上为操作系统线程堆栈获得的任何内存。</p>
<p>没有go_memstats_stack_idle_bytes，因为未使用的堆栈跨度被计入go_memstats_heap_idle_bytes。</p>
<h2 id="堆外内存指标">堆外内存指标</h2>
<p>这些指标是分配给运行时内部结构的字节，这些结构没有在堆上分配，因为它们实现了堆。</p>
<p>go_memstats_mspan_inuse_bytes - 显示mspan结构使用了多少字节。</p>
<p>go_memstats_mspan_sys_bytes - 显示mspan结构从操作系统获得的字节数。</p>
<p>go_memstats_mcache_inuse_bytes - 显示有多少字节被mcache结构使用。</p>
<p>go_memstats_mcache_sys_bytes - 显示mcache结构从操作系统获得的字节数。</p>
<p>go_memstats_buck_hash_sys_bytes - 显示有多少字节的内存在bucket哈希表中，用于分析。</p>
<p>go_memstats_gc_sys_bytes - 显示在垃圾收集元数据中的数量。</p>
<p>go_memstats_other_sys_bytes - go_memstats_other_sys_bytes 显示有多少字节的内存被用于其他运行时分配。</p>
<p>go_memstats_next_gc_bytes - 显示下一个GC周期的目标堆大小。GC的目标是保持go_memstats_heap_alloc_bytes小于这个值。</p>
<p>go_memstats_last_gc_time_seconds - 包含上次GC结束的unix时间戳。</p>
<p>go_memstats_last_gc_cpu_fraction - 显示自程序开始以来，GC所使用的CPU时间占该程序可用时间的比例。</p>
<p>这个指标也在GODEBUG=gctrace=1中提供。</p>
<h2 id="玩转数字">玩转数字</h2>
<p>因此，这是一个很多的指标和很多的信息。</p>
<p>我认为学习的最好方法就是玩一玩，所以在这一部分我就这么做。</p>
<p>所以我将使用上面的同一个程序。</p>
<p>下面是来自/metrics的转储信息（为节省空间而编辑），我将使用这些信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">process_resident_memory_bytes</span> <span class="m">1.09568e+07</span>

<span class="n">process_virtual_memory_bytes</span> <span class="m">6.46668288e+08</span>

<span class="n">go_memstats_heap_alloc_bytes</span> <span class="m">2.24344e+06</span>

<span class="n">go_memstats_heap_idle_bytes</span> <span class="m">6.3643648e+07</span>

<span class="n">go_memstats_heap_inuse_bytes</span> <span class="m">3.039232e+06</span>

<span class="n">go_memstats_heap_objects</span> <span class="m">6498</span>

<span class="n">go_memstats_heap_released_bytes</span> <span class="m">0</span>

<span class="n">go_memstats_heap_sys_bytes</span> <span class="m">6.668288e+07</span>

<span class="n">go_memstats_lookups_total</span> <span class="m">0</span>

<span class="n">go_memstats_frees_total</span> <span class="m">12209</span>

<span class="n">go_memstats_mallocs_total</span> <span class="m">18707</span>

<span class="n">go_memstats_buck_hash_sys_bytes</span> <span class="m">1.443899e+06</span>

<span class="n">go_memstats_mcache_inuse_bytes</span> <span class="m">6912</span>

<span class="n">go_memstats_mcache_sys_bytes</span> <span class="m">16384</span>

<span class="n">go_memstats_mspan_inuse_bytes</span> <span class="m">25840</span>

<span class="n">go_memstats_mspan_sys_bytes</span> <span class="m">32768</span>

<span class="n">go_memstats_other_sys_bytes</span> <span class="m">1.310909e+06</span>

<span class="n">go_memstats_stack_inuse_bytes</span> <span class="m">425984</span>

<span class="n">go_memstats_stack_sys_bytes</span> <span class="m">425984</span>

<span class="n">go_memstats_sys_bytes</span> <span class="m">7.2284408e+07</span>

<span class="n">go_memstats_next_gc_bytes</span> <span class="m">4.194304e+06</span>

<span class="n">go_memstats_gc_cpu_fraction</span> <span class="m">1.421928536233557e-06</span>

<span class="n">go_memstats_gc_sys_bytes</span> <span class="m">2.371584e+06</span>

<span class="n">go_memstats_last_gc_time_seconds</span> <span class="m">1.5235057190167596e+09</span>
<span class="n">rss</span> <span class="o">=</span> <span class="m">1.09568e+07</span> <span class="o">=</span> <span class="m">10956800</span> <span class="n">bytes</span> <span class="o">=</span> <span class="m">10700</span> <span class="n">KiB</span> <span class="o">=</span> <span class="m">10.4</span> <span class="n">MiB</span>

<span class="n">vsize</span> <span class="o">=</span> <span class="m">6.46668288e+08</span> <span class="o">=</span> <span class="m">646668288</span> <span class="n">bytes</span> <span class="o">=</span> <span class="m">631512</span> <span class="n">KiB</span> <span class="o">=</span> <span class="m">616.7</span> <span class="n">MiB</span>

<span class="n">heap_alloc_bytes</span> <span class="o">=</span> <span class="m">2.24344e+06</span> <span class="o">=</span> <span class="m">2243440</span> <span class="o">=</span> <span class="m">2190</span> <span class="n">KiB</span> <span class="o">=</span> <span class="m">2.1</span> <span class="n">MiB</span>

<span class="n">heap_inuse_bytes</span> <span class="o">=</span> <span class="m">3.039232e+06</span> <span class="o">=</span> <span class="m">3039232</span> <span class="o">=</span> <span class="m">2968</span> <span class="n">KiB</span> <span class="o">=</span> <span class="m">2</span><span class="p">,</span><span class="m">9</span> <span class="n">MiB</span>

<span class="n">heap_idle_bytes</span> <span class="o">=</span> <span class="m">6.3643648e+07</span> <span class="o">=</span> <span class="m">63643648</span> <span class="o">=</span> <span class="m">62152</span> <span class="n">KiB</span> <span class="o">=</span> <span class="m">60.6</span> <span class="n">MiB</span>

<span class="n">heap_released_bytes</span> <span class="o">=</span> <span class="m">0</span>

<span class="n">heap_sys_bytes</span> <span class="o">=</span> <span class="m">6.668288e+07</span> <span class="o">=</span> <span class="m">66682880</span> <span class="o">=</span> <span class="m">65120</span> <span class="n">KiB</span> <span class="o">=</span> <span class="m">63.6</span> <span class="n">MiB</span>

<span class="n">frees_total</span> <span class="o">=</span> <span class="m">12209</span>

<span class="n">mallocs_total</span> <span class="o">=</span> <span class="m">18707</span>

<span class="n">mspan_inuse_bytes</span> <span class="o">=</span> <span class="m">25840</span> <span class="o">=</span> <span class="m">25.2</span> <span class="n">KiB</span>

<span class="n">mspan_sys_bytes</span> <span class="o">=</span> <span class="m">32768</span> <span class="o">=</span> <span class="m">32</span> <span class="n">KiB</span>

<span class="n">mcache_inuse_bytes</span> <span class="o">=</span> <span class="m">6912</span> <span class="o">=</span> <span class="m">6.8</span> <span class="n">KiB</span>

<span class="n">mcache_sys_bytes</span> <span class="o">=</span> <span class="m">16384</span> <span class="o">=</span> <span class="m">12</span> <span class="n">KiB</span>

<span class="n">buck_hash_sys_bytes</span> <span class="o">=</span> <span class="m">1.443899e+06</span> <span class="o">=</span> <span class="m">1443899</span> <span class="o">=</span> <span class="m">1410</span> <span class="n">KiB</span> <span class="o">=</span> <span class="m">1.4</span> <span class="n">MiB</span>

<span class="n">gc_sys_bytes</span> <span class="o">=</span> <span class="m">2.371584e+06</span> <span class="o">=</span> <span class="m">2371584</span> <span class="o">=</span> <span class="m">2316</span> <span class="n">KiB</span> <span class="o">=</span> <span class="m">2.3</span> <span class="n">MiB</span>

<span class="n">other_sys_bytes</span> <span class="o">=</span> <span class="m">1.310909e+06</span> <span class="o">=</span> <span class="m">1310909</span> <span class="o">=</span> <span class="m">1280</span><span class="p">,</span><span class="m">2</span> <span class="n">KiB</span> <span class="o">=</span> <span class="m">1.3</span><span class="n">MiB</span>

<span class="n">stack_inuse_bytes</span> <span class="o">=</span> <span class="m">425984</span> <span class="o">=</span> <span class="m">416</span> <span class="n">KiB</span>

<span class="n">stack_sys_bytes</span> <span class="o">=</span> <span class="m">425984</span> <span class="o">=</span> <span class="m">416</span> <span class="n">KiB</span>

<span class="n">sys_bytes</span> <span class="o">=</span> <span class="m">7.2284408e+07</span> <span class="o">=</span> <span class="m">72284408</span> <span class="o">=</span> <span class="m">70590.2</span> <span class="n">KiB</span> <span class="o">=</span> <span class="m">68.9</span> <span class="n">MiB</span>

<span class="n">next_gc_bytes</span> <span class="o">=</span> <span class="m">4.194304e+06</span> <span class="o">=</span> <span class="m">4194304</span> <span class="o">=</span> <span class="m">4096</span> <span class="n">KiB</span> <span class="o">=</span> <span class="m">4</span> <span class="n">MiB</span>

<span class="n">gc_cpu_fraction</span> <span class="o">=</span> <span class="m">1.421928536233557e-06</span> <span class="o">=</span> <span class="m">0.000001</span>

<span class="n">last_gc_time_seconds</span> <span class="o">=</span> <span class="m">1.5235057190167596e+09</span> <span class="o">=</span> <span class="n">Thu</span><span class="p">,</span> <span class="m">12</span> <span class="n">Apr</span> <span class="m">2018</span> <span class="m">05</span><span class="o">:</span><span class="m">47</span><span class="o">:</span><span class="m">59</span> <span class="n">GMT</span>
</code></pre></td></tr></table>
</div>
</div><p>有趣的一点是，heap_inuse_bytes比heap_alloc_bytes多。
我认为heap_alloc_bytes显示的是对象方面的字节数，heap_inuse_bytes显示的是跨度方面的内存字节数。</p>
<p>用heap_inuse_bytes除以span的大小，可以得到。3039232 / 8192 = 371 span。</p>
<p>heap_inuse_bytes减去heap_alloc_bytes，应该显示我们在使用跨度中的自由空间数量，即2,9 MiB - 2.1 MiB = 0.8 MiB。</p>
<p>这大概意味着我们可以在堆上分配0.8 MiB的对象而不使用新的内存跨度。</p>
<p>但是，我们应该记住内存碎片的问题。</p>
<p>想象一下，如果你有一个10K字节的新字节片，内存可能处于这样的位置，它没有一个10K字节+片头的连续块，所以它需要使用一个新的跨度，而不是重复使用</p>
<p>heap_idle_bytes减去heap_released_byte表明，我们有大约60.6 MiB的未使用跨度，这些跨度是由操作系统保留的，可以返回给操作系统。这是63643648/8192 = 7769个跨度。</p>
<p>heap_sys_bytes，估计是63.6MB，是堆的最大尺寸。它是66682880/8192=8140跨度。</p>
<p>mallocs_total显示，我们分配了18707个对象，释放了12209个。因此，目前我们有18707-12209=6498个对象。我们可以找到对象的平均大小，将heap_alloc_bytes除以实时对象，即6498。结果是2243440 / 6498 = 345.3字节。</p>
<p>(这可能是一个愚蠢的指标，因为对象的大小变化很大，我们应该做直方图来代替。)</p>
<p>所以sys_bytes应该是所有*sys指标的总和。所以我们来检查一下。
<code>sys_bytes == mspan_sys_bytes + mcache_sys_bytes + buck_hash_sys_bytes + gc_sys_bytes + other_sys_bytes + stack_sys_bytes + heap_sys_bytes</code>。
因此，我们有<code>72284408 == 32768 + 16384 + 1443899 + 2371584 + 1310909 + 425984 + 66682880</code>，这就是<code>72284408 == 72284408</code>，这是正确的。</p>
<p>关于sys_bytes，有趣的细节是，它是68,9 MiB，它是来自操作系统的总共多少个字节的内存。同时，操作系统的vsize给了你616,7 MiB，rss给了你10.4 MiB。因此，所有这些数字并不完全吻合。</p>
<p>根据我的理解，我们的部分内存可能在操作系统的内存页中，这些内存页在交换或文件系统中（而不是在RAM中），所以这可以解释为什么rss比sys_bytes小。</p>
<p>而vsize包含了很多东西，比如映射的libc、pthreads libs等。你可以浏览/proc/PID/maps和/proc/PID/smaps文件，看看当前被映射的是什么。</p>
<p>gc_cpu_fraction运行得很低，0.000001的CPU时间被用于GC。这真的是非常非常酷。(虽然这个程序并没有产生多少垃圾)</p>
<p>next_gc_bytes显示GC的目标是将heap_alloc_bytes保持在4 MiB以下，因为heap_alloc_bytes目前是2.1 MiB，目标已经实现。</p>
<h2 id="memstats--gcstats">MemStats &amp; GCStats</h2>
<p>关于内存分配的情况，最简单的方式是利用 runtime 包的 MemStats。</p>
<p>上面这种是不修改一行代码的情况下，完全使用外部工具/参数，无侵入式的 GC 监控。</p>
<p>另一种办法是直接读取 runtime.MemStats (runtime/mstats.go) 的内容。其实上面这种办法也是读取了 runtime.memstats (跟 runtime.MemStats 是同一个东西，一个对内，一个对外)。这也意味着要修改我们的程序代码。</p>
<p>代码基本都是这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">    <span class="nx">memStats</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">runtime</span><span class="p">.</span><span class="nx">MemStats</span><span class="p">{}</span>
    <span class="nx">runtime</span><span class="p">.</span><span class="nf">ReadMemStats</span><span class="p">(</span><span class="nx">memStats</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如果希望获取 gcstats:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">  <span class="nx">gcstats</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">debug</span><span class="p">.</span><span class="nx">GCStats</span><span class="p">{</span><span class="nx">PauseQuantiles</span><span class="p">:</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span> <span class="mi">100</span><span class="p">)}</span>
  <span class="nx">debug</span><span class="p">.</span><span class="nf">ReadGCStats</span><span class="p">(</span><span class="nx">gcstats</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如果你用了 open-falcon 作为监控工具的话，还可以用 <code>github.com/niean/goperfcounter</code>, 配置一下即可使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;bases&#34;</span><span class="p">:</span> <span class="p">[</span><span class="err">“runtime”</span><span class="p">,</span> <span class="err">“debug”</span><span class="p">],</span> <span class="c1">// 分别对应 runtime.MemStats, debug.GCStats
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果读者看过 ReadMemStats 的实现的话，应该知道里面调用了 stopTheWorld。</p>
<p>Russ Cox 说:</p>
<p>We use ReadMemStats internally at Google. I am not sure of the period but it’s something like what you’re talking about (maybe up to once a minute, I forget).</p>
<p>Stopping the world is not a huge problem; stopping the world for a long time is. ReadMemStats stops the world for only a fixed, very short amount of time. So calling it every 10-20 seconds should be fine.</p>
<p>Don’t take my word for it: measure how long it takes and decide whether you’re willing to give up that much of every 10-20 seconds. I expect it would be under 1/1000th of that time (10 ms).
refer: <code>https://groups.google.com/forum/#!searchin/golang-nuts/ReadMemStats/golang-nuts/mTnw5k4pZdo/rpK69Fns2MsJ</code></p>
<p>另外， <code>https://github.com/rcrowley/go-metrics</code> 也提到了(go-metrics/runtime.go L:68)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">runtime</span><span class="p">.</span><span class="nf">ReadMemStats</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memStats</span><span class="p">)</span> <span class="c1">// This takes 50-200us.
</span></code></pre></td></tr></table>
</div>
</div><p>我觉得一般业务，只要对性能没有很变态的要求，1毫秒内都还能接受吧，也看你读取的频率有多高。</p>
<h2 id="总结">总结</h2>
<p>我喜欢Go，喜欢它在它的包中公开了这么多有用的信息，像你我这样的用户只需调用一个函数就可以获得这些信息。另外，Prometheus确实是一个监控应用程序的好工具。</p>
<p>你想在普罗米修斯方面做得更好吗？看看《用普罗米修斯监控系统和服务》。我绝对推荐这个模块。</p>
<p>玩耍和阅读关于Linux和Go的文章真的很爽，所以我想做这篇文章的第二部分。也许可以研究一下cAdvisor提供的指标，或者展示如何在Prometheus的仪表盘/警报中使用这里描述的一些指标。</p>
<p>另外，一旦vgo被集成（我真的非常希望它被集成，因为它是我使用过的最好的软件包管理器）。然后，我们应该能够从一些go运行时包中检查依赖关系，这将是非常酷的! 想象一下，写一个自定义的prom收集器，它可以检查你所有的依赖关系，检查新的版本，如果发现会给你一个过时的pkgs的数量，类似go_num_outdated_pkgs的指标。</p>
<p>这样，如果你的服务严重过时，你可以写一个警报。或者检查你的实时依赖性哈希值是否与当前的哈希值不一致？</p>
<h2 id="参考">参考</h2>
<p><a href="https://povilasv.me/prometheus-go-metrics/">EXPLORING PROMETHEUS GO CLIENT METRICS</a></p>
<p><a href="https://toutiao.io/posts/p8iu03/preview">https://toutiao.io/posts/p8iu03/preview</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-09-07
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/prometheus/">prometheus</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go%E8%AF%AD%E8%A8%80%E8%A7%82%E5%AF%9Fgc%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go语言观察GC的几种方式</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/go%E8%AF%AD%E8%A8%80%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%8C%87%E5%8D%97/">
            <span class="next-text nav-default">Go语言性能调优指南</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
