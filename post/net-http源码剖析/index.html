<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>net-http源码剖析 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="HTTP 超文本传输协议（Hypertext Transfer Protocol、HTTP 协议）是今天使用最广泛的应用层协议，1989 年由 Tim Berners-Lee 在 CERN 起草的协议已经成为了" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.91.2 with theme even" />


<link rel="canonical" href="/post/net-http%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="net-http源码剖析" />
<meta property="og:description" content="HTTP 超文本传输协议（Hypertext Transfer Protocol、HTTP 协议）是今天使用最广泛的应用层协议，1989 年由 Tim Berners-Lee 在 CERN 起草的协议已经成为了" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/net-http%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-01-29T14:12:01+00:00" />
<meta property="article:modified_time" content="2021-01-29T14:12:01+00:00" />

<meta itemprop="name" content="net-http源码剖析">
<meta itemprop="description" content="HTTP 超文本传输协议（Hypertext Transfer Protocol、HTTP 协议）是今天使用最广泛的应用层协议，1989 年由 Tim Berners-Lee 在 CERN 起草的协议已经成为了"><meta itemprop="datePublished" content="2021-01-29T14:12:01+00:00" />
<meta itemprop="dateModified" content="2021-01-29T14:12:01+00:00" />
<meta itemprop="wordCount" content="33160">
<meta itemprop="keywords" content="Go," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="net-http源码剖析"/>
<meta name="twitter:description" content="HTTP 超文本传输协议（Hypertext Transfer Protocol、HTTP 协议）是今天使用最广泛的应用层协议，1989 年由 Tim Berners-Lee 在 CERN 起草的协议已经成为了"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">net-http源码剖析</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-01-29 </span>
        <div class="post-category">
            <a href="/categories/go%E6%BA%90%E7%A0%81/"> Go源码 </a>
            </div>
          <span class="more-meta"> 约 33160 字 </span>
          <span class="more-meta"> 预计阅读 67 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#http">HTTP</a>
      <ul>
        <li><a href="#请求和响应">请求和响应</a></li>
        <li><a href="#消息边界">消息边界</a></li>
        <li><a href="#层级结构">层级结构</a></li>
      </ul>
    </li>
    <li><a href="#客户端">客户端</a>
      <ul>
        <li><a href="#request">Request</a></li>
        <li><a href="#client">Client</a></li>
        <li><a href="#transport">Transport</a></li>
        <li><a href="#persistconn">persistConn</a></li>
        <li><a href="#response">Response</a></li>
      </ul>
    </li>
    <li><a href="#服务器">服务器</a>
      <ul>
        <li><a href="#注册处理器">注册处理器</a></li>
        <li><a href="#处理请求">处理请求</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="http">HTTP</h2>
<p>超文本传输协议（Hypertext Transfer Protocol、HTTP 协议）是今天使用最广泛的应用层协议，1989 年由 Tim Berners-Lee 在 CERN 起草的协议已经成为了互联网的数据传输的核心1。在过去几年的时间里，HTTP/2 和 HTTP/3 也对现有的协议进行了更新，提供更加安全和快速的传输功能。多数的编程语言都会在标准库中实现 HTTP/1.1 和 HTTP/2.0 已满足工程师的日常开发需求，今天要介绍的 Go 语言的网络库也实现了这两个大版本的 HTTP 协议。</p>
<p>HTTP 协议是应用层协议，在通常情况下我们都会使用 TCP 作为底层的传输层协议传输数据包，但是 HTTP/3 在 UDP 协议上实现了新的传输层协议 QUIC 并使用 QUIC 传输数据，这也意味着 HTTP 既可以跑在 TCP 上，也可以跑在 UDP 上。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210129141426.png" alt=""></p>
<p>Go 语言标准库通过 net/http 包提供 HTTP 的客户端和服务端实现，在分析内部的实现原理之前，我们先来了解一下 HTTP 协议相关的一些设计以及标准库内部的层级结构和模块之间的关系。</p>
<h3 id="请求和响应">请求和响应</h3>
<p>HTTP 协议中最常见的概念是 HTTP 请求与响应，我们可以将它们理解成客户端和服务端之间传递的消息，客户端向服务端发送 HTTP 请求，服务端收到 HTTP 请求后会做出计算后以 HTTP 响应的形式发送给客户端。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210129141502.png" alt=""></p>
<p>与其他的二进制协议不同，作为文本传输协议，HTTP 协议的协议头都是文本数据，HTTP 请求头的首行会包含请求的方法、路径和协议版本，接下来是多个 HTTP 协议头以及携带的负载。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">GET</span> <span class="o">/</span> <span class="n">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="n">User</span><span class="o">-</span><span class="n">Agent</span><span class="o">:</span> <span class="n">Mozilla</span><span class="o">/</span><span class="m">4.0</span> <span class="p">(</span><span class="n">compatible</span><span class="p">;</span> <span class="n">MSIE5.01</span><span class="p">;</span> <span class="n">Windows</span> <span class="n">NT</span><span class="p">)</span>
<span class="n">Host</span><span class="o">:</span> <span class="n">draveness.me</span>
<span class="n">Accept</span><span class="o">-</span><span class="n">Language</span><span class="o">:</span> <span class="n">en</span><span class="o">-</span><span class="n">us</span>
<span class="n">Accept</span><span class="o">-</span><span class="n">Encoding</span><span class="o">:</span> <span class="n">gzip</span><span class="p">,</span> <span class="n">deflate</span>
<span class="n">Content</span><span class="o">-</span><span class="n">Length</span><span class="o">:</span> <span class="o">&lt;</span><span class="n">length</span><span class="o">&gt;</span>
<span class="n">Connection</span><span class="o">:</span> <span class="n">Keep</span><span class="o">-</span><span class="n">Alive</span>

<span class="o">&lt;</span><span class="n">html</span><span class="o">&gt;</span>
    <span class="kc">...</span>
<span class="o">&lt;/</span><span class="n">html</span><span class="o">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>对于HTTP协议，有一个header值”Connections”, 这个值的作用就是client向server端发请求的时候，告诉server是否要保持连接。具体的可以参考rfc2616。 这个协议头的值有两种可能(参考MDN文档):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">Connection</span><span class="o">:</span> <span class="n">keep</span><span class="o">-</span><span class="n">alive</span>
<span class="n">Connection</span><span class="o">:</span> <span class="n">close</span>
</code></pre></td></tr></table>
</div>
</div><p>当值为keep-alive时，server端会保持连接，一直到连接超时。当值为close时,server端会在传输完response后主动断掉TCP连接。在HTTP/1.1之前，这个值默认是close, 之后是默认keep-alive, 而net/http默认的协议是HTTP/1.1也就是默认keep-alive, 这个值可以通过DisableKeepAlives来设置。</p>
<h3 id="消息边界">消息边界</h3>
<p>HTTP 协议目前主要还是跑在 TCP 协议上的，TCP 协议是面向连接的、可靠的、基于字节流的传输层通信协议，应用层交给 TCP 协议的数据并不会以消息为单位向目的主机传输，这些数据在某些情况下会被组合成一个数据段发送给目标的主机。因为 TCP 协议是基于字节流的，所以基于 TCP 协议的应用层协议都需要自己划分消息的边界。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210129142516.png" alt=""></p>
<p>在应用层协议中，最常见的两种解决方案是基于长度或者基于终结符（Delimiter）。HTTP 协议其实同时实现了上述两种方案，在多数情况下 HTTP 协议都会在协议头中加入 Content-Length 表示负载的长度，消息的接收者解析到该协议头之后就可以确定当前 HTTP 请求/响应结束的位置，分离不同的 HTTP 消息，下面就是一个使用 Content-Length 划分消息边界的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">200</span> <span class="n">OK</span>
<span class="n">Content</span><span class="o">-</span><span class="n">Type</span><span class="o">:</span> <span class="n">text</span><span class="o">/</span><span class="n">html</span><span class="p">;</span> <span class="n">charset</span><span class="o">=</span><span class="n">UTF</span><span class="m">-8</span>
<span class="n">Content</span><span class="o">-</span><span class="n">Length</span><span class="o">:</span> <span class="m">138</span>
<span class="kc">...</span>
<span class="n">Connection</span><span class="o">:</span> <span class="n">close</span>

<span class="o">&lt;</span><span class="n">html</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">head</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">title</span><span class="o">&gt;</span><span class="n">An</span> <span class="n">Example</span> <span class="n">Page</span><span class="o">&lt;/</span><span class="n">title</span><span class="o">&gt;</span>
  <span class="o">&lt;/</span><span class="n">head</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">body</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">Hello</span> <span class="n">World</span><span class="p">,</span> <span class="n">this</span> <span class="n">is</span> <span class="n">a</span> <span class="n">very</span> <span class="n">simple</span> <span class="n">HTML</span> <span class="n">document.</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
  <span class="o">&lt;/</span><span class="n">body</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">html</span><span class="o">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>不过 HTTP 协议除了使用基于长度的方式实现边界，也会使用基于终结符的策略，当 HTTP 使用块传输（Chunked Transfer）机制时，HTTP 头中就不再包含 Content-Length 了，它会使用负载大小为 0 的 HTTP 消息作为终结符表示消息的边界。</p>
<h3 id="层级结构">层级结构</h3>
<p>Go 语言的 net/http 中同时包好了 HTTP 客户端和服务端的实现，为了支持更好的扩展性，它引入了 net/http.RoundTripper 和 net/http.Handler 两个接口。net/http.RoundTripper 是用来表示执行 HTTP 请求的接口，调用方将请求作为参数可以获取请求对应的响应，而 net/http.Handler 主要用于 HTTP 服务器响应客户端的请求：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">RoundTripper</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">RoundTrip</span><span class="p">(</span><span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Response</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>HTTP 请求的接收方可以实现 net/http.Handler 接口，其中实现了处理 HTTP 请求的逻辑，处理的过程中会调用 net/http.ResponseWriter 接口的方法构造 HTTP 响应，它提供的三个接口 Header、Write 和 WriteHeader 分别会获取 HTTP 响应、将数据写入负载以及写入响应头：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Handler</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ResponseWriter</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Header</span><span class="p">()</span> <span class="nx">Header</span>
	<span class="nf">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="nf">WriteHeader</span><span class="p">(</span><span class="nx">statusCode</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>客户端和服务端面对的都是双向的 HTTP 请求与响应，客户端构建请求并等待响应，服务端处理请求并返回响应。HTTP 请求和响应在标准库中不止有一种实现，它们都包含了层级结构，标准库中的 net/http.RoundTripper 包含如下所示的层级结构：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210129155549.png" alt=""></p>
<p>每个 net/http.RoundTripper 接口的实现都包含了一种向远程发出请求的过程；标准库中也提供了 net/http.Handler 的多种实现为客户端的 HTTP 请求提供不同的服务。</p>
<h2 id="客户端">客户端</h2>
<p>http请求示例代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">url</span> <span class="o">:=</span> <span class="s">&#34;http://localhost:8080/login?name=zhouwei1&amp;password=123456&#34;</span>

	<span class="c1">// 1.创建client, 这里使用的默认值
</span><span class="c1"></span>	<span class="nx">client</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">DefaultClient</span>

	<span class="c1">// 2.创建请求
</span><span class="c1"></span>	<span class="nx">req</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewRequest</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">MethodGet</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 3.发送请求
</span><span class="c1"></span>	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 4.关闭
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">resp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;请求成功, data: %s\n&#34;</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>http请求流程</p>
<ol>
<li>创建http.Client对象client</li>
<li>创建http.Request对象req</li>
<li>发送请求client.do(req)</li>
<li>关闭resp.Body.Close()</li>
</ol>
<p>即使直接调用client.Get()或client.Post(), 内部同样创建了request, 且最终总是通过client.Do()方法调用私有的client.do()方法, 执行请求;</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210201134632.png" alt=""></p>
<p>HTTP 的客户端中包含几个比较重要的结构体，它们分别是 net/http.Client、net/http.Transport 和 net/http.persistConn：</p>
<ul>
<li>net/http.Client 是 HTTP 客户端，它的默认值是使用 net/http.DefaultTransport 的 HTTP 客户端；</li>
<li>net/http.Transport 是 net/http.RoundTripper 接口的实现，它的主要作用就是支持 HTTP/HTTPS 请求和 HTTP 代理；</li>
<li>net/http.persistConn 封装了一个 TCP 的持久连接，是我们与远程交换消息的句柄（Handle）；</li>
</ul>
<p>客户端 net/http.Client 是级别较高的抽象，它提供了 HTTP 的一些细节，包括 Cookies 和重定向；而 net/http.Transport 会处理 HTTP/HTTPS 协议的底层实现细节，其中会包含连接重用、构建请求以及发送请求等功能。</p>
<h3 id="request">Request</h3>
<p>net/http.Request 表示 HTTP 服务接收到的请求或者 HTTP 客户端发出的请求，其中包含 HTTP 请求的方法、URL、协议版本、协议头以及请求体等字段，除了这些字段之外，它还会持有一个指向 HTTP 响应的引用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A Request represents an HTTP request received by a server
</span><span class="c1">// or to be sent by a client.
</span><span class="c1">//
</span><span class="c1">// The field semantics differ slightly between client and server
</span><span class="c1">// usage. In addition to the notes on the fields below, see the
</span><span class="c1">// documentation for Request.Write and RoundTripper.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Request</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Method specifies the HTTP method (GET, POST, PUT, etc.).
</span><span class="c1"></span>	<span class="c1">// For client requests, an empty string means GET.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Go&#39;s HTTP client does not support sending a request with
</span><span class="c1"></span>	<span class="c1">// the CONNECT method. See the documentation on Transport for
</span><span class="c1"></span>	<span class="c1">// details.
</span><span class="c1"></span>	<span class="nx">Method</span> <span class="kt">string</span>

	<span class="c1">// URL specifies either the URI being requested (for server
</span><span class="c1"></span>	<span class="c1">// requests) or the URL to access (for client requests).
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For server requests, the URL is parsed from the URI
</span><span class="c1"></span>	<span class="c1">// supplied on the Request-Line as stored in RequestURI.  For
</span><span class="c1"></span>	<span class="c1">// most requests, fields other than Path and RawQuery will be
</span><span class="c1"></span>	<span class="c1">// empty. (See RFC 7230, Section 5.3)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For client requests, the URL&#39;s Host specifies the server to
</span><span class="c1"></span>	<span class="c1">// connect to, while the Request&#39;s Host field optionally
</span><span class="c1"></span>	<span class="c1">// specifies the Host header value to send in the HTTP
</span><span class="c1"></span>	<span class="c1">// request.
</span><span class="c1"></span>	<span class="nx">URL</span> <span class="o">*</span><span class="nx">url</span><span class="p">.</span><span class="nx">URL</span>

	<span class="c1">// The protocol version for incoming server requests.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For client requests, these fields are ignored. The HTTP
</span><span class="c1"></span>	<span class="c1">// client code always uses either HTTP/1.1 or HTTP/2.
</span><span class="c1"></span>	<span class="c1">// See the docs on Transport for details.
</span><span class="c1"></span>	<span class="nx">Proto</span>      <span class="kt">string</span> <span class="c1">// &#34;HTTP/1.0&#34;
</span><span class="c1"></span>	<span class="nx">ProtoMajor</span> <span class="kt">int</span>    <span class="c1">// 1
</span><span class="c1"></span>	<span class="nx">ProtoMinor</span> <span class="kt">int</span>    <span class="c1">// 0
</span><span class="c1"></span>
	<span class="c1">// Header contains the request header fields either received
</span><span class="c1"></span>	<span class="c1">// by the server or to be sent by the client.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If a server received a request with header lines,
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//	Host: example.com
</span><span class="c1"></span>	<span class="c1">//	accept-encoding: gzip, deflate
</span><span class="c1"></span>	<span class="c1">//	Accept-Language: en-us
</span><span class="c1"></span>	<span class="c1">//	fOO: Bar
</span><span class="c1"></span>	<span class="c1">//	foo: two
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// then
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//	Header = map[string][]string{
</span><span class="c1"></span>	<span class="c1">//		&#34;Accept-Encoding&#34;: {&#34;gzip, deflate&#34;},
</span><span class="c1"></span>	<span class="c1">//		&#34;Accept-Language&#34;: {&#34;en-us&#34;},
</span><span class="c1"></span>	<span class="c1">//		&#34;Foo&#34;: {&#34;Bar&#34;, &#34;two&#34;},
</span><span class="c1"></span>	<span class="c1">//	}
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For incoming requests, the Host header is promoted to the
</span><span class="c1"></span>	<span class="c1">// Request.Host field and removed from the Header map.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// HTTP defines that header names are case-insensitive. The
</span><span class="c1"></span>	<span class="c1">// request parser implements this by using CanonicalHeaderKey,
</span><span class="c1"></span>	<span class="c1">// making the first character and any characters following a
</span><span class="c1"></span>	<span class="c1">// hyphen uppercase and the rest lowercase.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For client requests, certain headers such as Content-Length
</span><span class="c1"></span>	<span class="c1">// and Connection are automatically written when needed and
</span><span class="c1"></span>	<span class="c1">// values in Header may be ignored. See the documentation
</span><span class="c1"></span>	<span class="c1">// for the Request.Write method.
</span><span class="c1"></span>	<span class="nx">Header</span> <span class="nx">Header</span>

	<span class="c1">// Body is the request&#39;s body.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For client requests, a nil body means the request has no
</span><span class="c1"></span>	<span class="c1">// body, such as a GET request. The HTTP Client&#39;s Transport
</span><span class="c1"></span>	<span class="c1">// is responsible for calling the Close method.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For server requests, the Request Body is always non-nil
</span><span class="c1"></span>	<span class="c1">// but will return EOF immediately when no body is present.
</span><span class="c1"></span>	<span class="c1">// The Server will close the request body. The ServeHTTP
</span><span class="c1"></span>	<span class="c1">// Handler does not need to.
</span><span class="c1"></span>	<span class="nx">Body</span> <span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span>

	<span class="c1">// GetBody defines an optional func to return a new copy of
</span><span class="c1"></span>	<span class="c1">// Body. It is used for client requests when a redirect requires
</span><span class="c1"></span>	<span class="c1">// reading the body more than once. Use of GetBody still
</span><span class="c1"></span>	<span class="c1">// requires setting Body.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For server requests, it is unused.
</span><span class="c1"></span>	<span class="nx">GetBody</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

	<span class="c1">// ContentLength records the length of the associated content.
</span><span class="c1"></span>	<span class="c1">// The value -1 indicates that the length is unknown.
</span><span class="c1"></span>	<span class="c1">// Values &gt;= 0 indicate that the given number of bytes may
</span><span class="c1"></span>	<span class="c1">// be read from Body.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For client requests, a value of 0 with a non-nil Body is
</span><span class="c1"></span>	<span class="c1">// also treated as unknown.
</span><span class="c1"></span>	<span class="nx">ContentLength</span> <span class="kt">int64</span>

	<span class="c1">// TransferEncoding lists the transfer encodings from outermost to
</span><span class="c1"></span>	<span class="c1">// innermost. An empty list denotes the &#34;identity&#34; encoding.
</span><span class="c1"></span>	<span class="c1">// TransferEncoding can usually be ignored; chunked encoding is
</span><span class="c1"></span>	<span class="c1">// automatically added and removed as necessary when sending and
</span><span class="c1"></span>	<span class="c1">// receiving requests.
</span><span class="c1"></span>	<span class="nx">TransferEncoding</span> <span class="p">[]</span><span class="kt">string</span>

	<span class="c1">// Close indicates whether to close the connection after
</span><span class="c1"></span>	<span class="c1">// replying to this request (for servers) or after sending this
</span><span class="c1"></span>	<span class="c1">// request and reading its response (for clients).
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For server requests, the HTTP server handles this automatically
</span><span class="c1"></span>	<span class="c1">// and this field is not needed by Handlers.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For client requests, setting this field prevents re-use of
</span><span class="c1"></span>	<span class="c1">// TCP connections between requests to the same hosts, as if
</span><span class="c1"></span>	<span class="c1">// Transport.DisableKeepAlives were set.
</span><span class="c1"></span>	<span class="nx">Close</span> <span class="kt">bool</span>

	<span class="c1">// For server requests, Host specifies the host on which the
</span><span class="c1"></span>	<span class="c1">// URL is sought. For HTTP/1 (per RFC 7230, section 5.4), this
</span><span class="c1"></span>	<span class="c1">// is either the value of the &#34;Host&#34; header or the host name
</span><span class="c1"></span>	<span class="c1">// given in the URL itself. For HTTP/2, it is the value of the
</span><span class="c1"></span>	<span class="c1">// &#34;:authority&#34; pseudo-header field.
</span><span class="c1"></span>	<span class="c1">// It may be of the form &#34;host:port&#34;. For international domain
</span><span class="c1"></span>	<span class="c1">// names, Host may be in Punycode or Unicode form. Use
</span><span class="c1"></span>	<span class="c1">// golang.org/x/net/idna to convert it to either format if
</span><span class="c1"></span>	<span class="c1">// needed.
</span><span class="c1"></span>	<span class="c1">// To prevent DNS rebinding attacks, server Handlers should
</span><span class="c1"></span>	<span class="c1">// validate that the Host header has a value for which the
</span><span class="c1"></span>	<span class="c1">// Handler considers itself authoritative. The included
</span><span class="c1"></span>	<span class="c1">// ServeMux supports patterns registered to particular host
</span><span class="c1"></span>	<span class="c1">// names and thus protects its registered Handlers.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For client requests, Host optionally overrides the Host
</span><span class="c1"></span>	<span class="c1">// header to send. If empty, the Request.Write method uses
</span><span class="c1"></span>	<span class="c1">// the value of URL.Host. Host may contain an international
</span><span class="c1"></span>	<span class="c1">// domain name.
</span><span class="c1"></span>	<span class="nx">Host</span> <span class="kt">string</span>

	<span class="c1">// Form contains the parsed form data, including both the URL
</span><span class="c1"></span>	<span class="c1">// field&#39;s query parameters and the PATCH, POST, or PUT form data.
</span><span class="c1"></span>	<span class="c1">// This field is only available after ParseForm is called.
</span><span class="c1"></span>	<span class="c1">// The HTTP client ignores Form and uses Body instead.
</span><span class="c1"></span>	<span class="nx">Form</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span>

	<span class="c1">// PostForm contains the parsed form data from PATCH, POST
</span><span class="c1"></span>	<span class="c1">// or PUT body parameters.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This field is only available after ParseForm is called.
</span><span class="c1"></span>	<span class="c1">// The HTTP client ignores PostForm and uses Body instead.
</span><span class="c1"></span>	<span class="nx">PostForm</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span>

	<span class="c1">// MultipartForm is the parsed multipart form, including file uploads.
</span><span class="c1"></span>	<span class="c1">// This field is only available after ParseMultipartForm is called.
</span><span class="c1"></span>	<span class="c1">// The HTTP client ignores MultipartForm and uses Body instead.
</span><span class="c1"></span>	<span class="nx">MultipartForm</span> <span class="o">*</span><span class="nx">multipart</span><span class="p">.</span><span class="nx">Form</span>

	<span class="c1">// Trailer specifies additional headers that are sent after the request
</span><span class="c1"></span>	<span class="c1">// body.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For server requests, the Trailer map initially contains only the
</span><span class="c1"></span>	<span class="c1">// trailer keys, with nil values. (The client declares which trailers it
</span><span class="c1"></span>	<span class="c1">// will later send.)  While the handler is reading from Body, it must
</span><span class="c1"></span>	<span class="c1">// not reference Trailer. After reading from Body returns EOF, Trailer
</span><span class="c1"></span>	<span class="c1">// can be read again and will contain non-nil values, if they were sent
</span><span class="c1"></span>	<span class="c1">// by the client.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For client requests, Trailer must be initialized to a map containing
</span><span class="c1"></span>	<span class="c1">// the trailer keys to later send. The values may be nil or their final
</span><span class="c1"></span>	<span class="c1">// values. The ContentLength must be 0 or -1, to send a chunked request.
</span><span class="c1"></span>	<span class="c1">// After the HTTP request is sent the map values can be updated while
</span><span class="c1"></span>	<span class="c1">// the request body is read. Once the body returns EOF, the caller must
</span><span class="c1"></span>	<span class="c1">// not mutate Trailer.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Few HTTP clients, servers, or proxies support HTTP trailers.
</span><span class="c1"></span>	<span class="nx">Trailer</span> <span class="nx">Header</span>

	<span class="c1">// RemoteAddr allows HTTP servers and other software to record
</span><span class="c1"></span>	<span class="c1">// the network address that sent the request, usually for
</span><span class="c1"></span>	<span class="c1">// logging. This field is not filled in by ReadRequest and
</span><span class="c1"></span>	<span class="c1">// has no defined format. The HTTP server in this package
</span><span class="c1"></span>	<span class="c1">// sets RemoteAddr to an &#34;IP:port&#34; address before invoking a
</span><span class="c1"></span>	<span class="c1">// handler.
</span><span class="c1"></span>	<span class="c1">// This field is ignored by the HTTP client.
</span><span class="c1"></span>	<span class="nx">RemoteAddr</span> <span class="kt">string</span>

	<span class="c1">// RequestURI is the unmodified request-target of the
</span><span class="c1"></span>	<span class="c1">// Request-Line (RFC 7230, Section 3.1.1) as sent by the client
</span><span class="c1"></span>	<span class="c1">// to a server. Usually the URL field should be used instead.
</span><span class="c1"></span>	<span class="c1">// It is an error to set this field in an HTTP client request.
</span><span class="c1"></span>	<span class="nx">RequestURI</span> <span class="kt">string</span>

	<span class="c1">// TLS allows HTTP servers and other software to record
</span><span class="c1"></span>	<span class="c1">// information about the TLS connection on which the request
</span><span class="c1"></span>	<span class="c1">// was received. This field is not filled in by ReadRequest.
</span><span class="c1"></span>	<span class="c1">// The HTTP server in this package sets the field for
</span><span class="c1"></span>	<span class="c1">// TLS-enabled connections before invoking a handler;
</span><span class="c1"></span>	<span class="c1">// otherwise it leaves the field nil.
</span><span class="c1"></span>	<span class="c1">// This field is ignored by the HTTP client.
</span><span class="c1"></span>	<span class="nx">TLS</span> <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">ConnectionState</span>

	<span class="c1">// Cancel is an optional channel whose closure indicates that the client
</span><span class="c1"></span>	<span class="c1">// request should be regarded as canceled. Not all implementations of
</span><span class="c1"></span>	<span class="c1">// RoundTripper may support Cancel.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For server requests, this field is not applicable.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Deprecated: Set the Request&#39;s context with NewRequestWithContext
</span><span class="c1"></span>	<span class="c1">// instead. If a Request&#39;s Cancel field and context are both
</span><span class="c1"></span>	<span class="c1">// set, it is undefined whether Cancel is respected.
</span><span class="c1"></span>	<span class="nx">Cancel</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>

	<span class="c1">// Response is the redirect response which caused this request
</span><span class="c1"></span>	<span class="c1">// to be created. This field is only populated during client
</span><span class="c1"></span>	<span class="c1">// redirects.
</span><span class="c1"></span>	<span class="nx">Response</span> <span class="o">*</span><span class="nx">Response</span>

	<span class="c1">// ctx is either the client or server context. It should only
</span><span class="c1"></span>	<span class="c1">// be modified via copying the whole Request using WithContext.
</span><span class="c1"></span>	<span class="c1">// It is unexported to prevent people from using Context wrong
</span><span class="c1"></span>	<span class="c1">// and mutating the contexts held by callers of the same request.
</span><span class="c1"></span>	<span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>net/http.NewRequest 是标准库提供的用于创建请求的方法，这个方法会校验 HTTP 请求的字段并根据输入的参数拼装成新的请求结构体。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NewRequestWithContext returns a new Request given a method, URL, and
</span><span class="c1">// optional body.
</span><span class="c1">//
</span><span class="c1">// If the provided body is also an io.Closer, the returned
</span><span class="c1">// Request.Body is set to body and will be closed by the Client
</span><span class="c1">// methods Do, Post, and PostForm, and Transport.RoundTrip.
</span><span class="c1">//
</span><span class="c1">// NewRequestWithContext returns a Request suitable for use with
</span><span class="c1">// Client.Do or Transport.RoundTrip. To create a request for use with
</span><span class="c1">// testing a Server Handler, either use the NewRequest function in the
</span><span class="c1">// net/http/httptest package, use ReadRequest, or manually update the
</span><span class="c1">// Request fields. For an outgoing client request, the context
</span><span class="c1">// controls the entire lifetime of a request and its response:
</span><span class="c1">// obtaining a connection, sending the request, and reading the
</span><span class="c1">// response headers and body. See the Request type&#39;s documentation for
</span><span class="c1">// the difference between inbound and outbound request fields.
</span><span class="c1">//
</span><span class="c1">// If body is of type *bytes.Buffer, *bytes.Reader, or
</span><span class="c1">// *strings.Reader, the returned request&#39;s ContentLength is set to its
</span><span class="c1">// exact value (instead of -1), GetBody is populated (so 307 and 308
</span><span class="c1">// redirects can replay the body), and Body is set to NoBody if the
</span><span class="c1">// ContentLength is 0.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewRequestWithContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">url</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">body</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Request</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">method</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="c1">// We document that &#34;&#34; means &#34;GET&#34; for Request.Method, and people have
</span><span class="c1"></span>		<span class="c1">// relied on that from NewRequest, so keep that working.
</span><span class="c1"></span>		<span class="c1">// We still enforce validMethod for non-empty methods.
</span><span class="c1"></span>		<span class="nx">method</span> <span class="p">=</span> <span class="s">&#34;GET&#34;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nf">validMethod</span><span class="p">(</span><span class="nx">method</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;net/http: invalid method %q&#34;</span><span class="p">,</span> <span class="nx">method</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">ctx</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;net/http: nil Context&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">u</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">urlpkg</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">rc</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">body</span><span class="p">.(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">body</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">rc</span> <span class="p">=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">NopCloser</span><span class="p">(</span><span class="nx">body</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// The host&#39;s colon:port should be normalized. See Issue 14836.
</span><span class="c1"></span>	<span class="nx">u</span><span class="p">.</span><span class="nx">Host</span> <span class="p">=</span> <span class="nf">removeEmptyPort</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nx">Host</span><span class="p">)</span>
	<span class="nx">req</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Request</span><span class="p">{</span>
		<span class="nx">ctx</span><span class="p">:</span>        <span class="nx">ctx</span><span class="p">,</span>
		<span class="nx">Method</span><span class="p">:</span>     <span class="nx">method</span><span class="p">,</span>
		<span class="nx">URL</span><span class="p">:</span>        <span class="nx">u</span><span class="p">,</span>
		<span class="nx">Proto</span><span class="p">:</span>      <span class="s">&#34;HTTP/1.1&#34;</span><span class="p">,</span>
		<span class="nx">ProtoMajor</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
		<span class="nx">ProtoMinor</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
		<span class="nx">Header</span><span class="p">:</span>     <span class="nb">make</span><span class="p">(</span><span class="nx">Header</span><span class="p">),</span>
		<span class="nx">Body</span><span class="p">:</span>       <span class="nx">rc</span><span class="p">,</span>
		<span class="nx">Host</span><span class="p">:</span>       <span class="nx">u</span><span class="p">.</span><span class="nx">Host</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">body</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="nx">v</span> <span class="o">:=</span> <span class="nx">body</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">:</span>
			<span class="nx">req</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nf">Len</span><span class="p">())</span>
			<span class="nx">buf</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">()</span>
			<span class="nx">req</span><span class="p">.</span><span class="nx">GetBody</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">r</span> <span class="o">:=</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
				<span class="k">return</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">NopCloser</span><span class="p">(</span><span class="nx">r</span><span class="p">),</span> <span class="kc">nil</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Reader</span><span class="p">:</span>
			<span class="nx">req</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nf">Len</span><span class="p">())</span>
			<span class="nx">snapshot</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">v</span>
			<span class="nx">req</span><span class="p">.</span><span class="nx">GetBody</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">r</span> <span class="o">:=</span> <span class="nx">snapshot</span>
				<span class="k">return</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">NopCloser</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">r</span><span class="p">),</span> <span class="kc">nil</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="o">*</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Reader</span><span class="p">:</span>
			<span class="nx">req</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nf">Len</span><span class="p">())</span>
			<span class="nx">snapshot</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">v</span>
			<span class="nx">req</span><span class="p">.</span><span class="nx">GetBody</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">r</span> <span class="o">:=</span> <span class="nx">snapshot</span>
				<span class="k">return</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">NopCloser</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">r</span><span class="p">),</span> <span class="kc">nil</span>
			<span class="p">}</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="c1">// This is where we&#39;d set it to -1 (at least
</span><span class="c1"></span>			<span class="c1">// if body != NoBody) to mean unknown, but
</span><span class="c1"></span>			<span class="c1">// that broke people during the Go 1.8 testing
</span><span class="c1"></span>			<span class="c1">// period. People depend on it being 0 I
</span><span class="c1"></span>			<span class="c1">// guess. Maybe retry later. See Issue 18117.
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="c1">// For client requests, Request.ContentLength of 0
</span><span class="c1"></span>		<span class="c1">// means either actually 0, or unknown. The only way
</span><span class="c1"></span>		<span class="c1">// to explicitly say that the ContentLength is zero is
</span><span class="c1"></span>		<span class="c1">// to set the Body to nil. But turns out too much code
</span><span class="c1"></span>		<span class="c1">// depends on NewRequest returning a non-nil Body,
</span><span class="c1"></span>		<span class="c1">// so we use a well-known ReadCloser variable instead
</span><span class="c1"></span>		<span class="c1">// and have the http package also treat that sentinel
</span><span class="c1"></span>		<span class="c1">// variable to mean explicitly zero.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">GetBody</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">req</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">req</span><span class="p">.</span><span class="nx">Body</span> <span class="p">=</span> <span class="nx">NoBody</span>
			<span class="nx">req</span><span class="p">.</span><span class="nx">GetBody</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">NoBody</span><span class="p">,</span> <span class="kc">nil</span> <span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">req</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>请求拼装的过程比较简单，它会检查并校验输入的方法、URL 以及负载，然而初始化了新的 net/http.Request 结构，处理负载的过程稍微有一些复杂，我们会根据负载的类型不同，使用不同的方法将它们包装成 io.ReadCloser 类型。</p>
<h3 id="client">Client</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Client</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Transport specifies the mechanism by which individual
</span><span class="c1"></span>	<span class="c1">// HTTP requests are made.
</span><span class="c1"></span>	<span class="c1">// If nil, DefaultTransport is used.
</span><span class="c1"></span>	<span class="nx">Transport</span> <span class="nx">RoundTripper</span>

	<span class="c1">// CheckRedirect specifies the policy for handling redirects.
</span><span class="c1"></span>	<span class="c1">// If CheckRedirect is not nil, the client calls it before
</span><span class="c1"></span>	<span class="c1">// following an HTTP redirect. The arguments req and via are
</span><span class="c1"></span>	<span class="c1">// the upcoming request and the requests made already, oldest
</span><span class="c1"></span>	<span class="c1">// first. If CheckRedirect returns an error, the Client&#39;s Get
</span><span class="c1"></span>	<span class="c1">// method returns both the previous Response (with its Body
</span><span class="c1"></span>	<span class="c1">// closed) and CheckRedirect&#39;s error (wrapped in a url.Error)
</span><span class="c1"></span>	<span class="c1">// instead of issuing the Request req.
</span><span class="c1"></span>	<span class="c1">// As a special case, if CheckRedirect returns ErrUseLastResponse,
</span><span class="c1"></span>	<span class="c1">// then the most recent response is returned with its body
</span><span class="c1"></span>	<span class="c1">// unclosed, along with a nil error.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If CheckRedirect is nil, the Client uses its default policy,
</span><span class="c1"></span>	<span class="c1">// which is to stop after 10 consecutive requests.
</span><span class="c1"></span>	<span class="nx">CheckRedirect</span> <span class="kd">func</span><span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">via</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="kt">error</span>

	<span class="c1">// Jar specifies the cookie jar.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The Jar is used to insert relevant cookies into every
</span><span class="c1"></span>	<span class="c1">// outbound Request and is updated with the cookie values
</span><span class="c1"></span>	<span class="c1">// of every inbound Response. The Jar is consulted for every
</span><span class="c1"></span>	<span class="c1">// redirect that the Client follows.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If Jar is nil, cookies are only sent if they are explicitly
</span><span class="c1"></span>	<span class="c1">// set on the Request.
</span><span class="c1"></span>	<span class="nx">Jar</span> <span class="nx">CookieJar</span>

	<span class="c1">// Timeout specifies a time limit for requests made by this
</span><span class="c1"></span>	<span class="c1">// Client. The timeout includes connection time, any
</span><span class="c1"></span>	<span class="c1">// redirects, and reading the response body. The timer remains
</span><span class="c1"></span>	<span class="c1">// running after Get, Head, Post, or Do return and will
</span><span class="c1"></span>	<span class="c1">// interrupt reading of the Response.Body.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// A Timeout of zero means no timeout.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The Client cancels requests to the underlying Transport
</span><span class="c1"></span>	<span class="c1">// as if the Request&#39;s Context ended.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For compatibility, the Client will also use the deprecated
</span><span class="c1"></span>	<span class="c1">// CancelRequest method on Transport if found. New
</span><span class="c1"></span>	<span class="c1">// RoundTripper implementations should use the Request&#39;s Context
</span><span class="c1"></span>	<span class="c1">// for cancellation instead of implementing CancelRequest.
</span><span class="c1"></span>	<span class="c1">// 它涵盖整个交互过程，从发起连接到接收响应报文结束
</span><span class="c1"></span>	<span class="nx">Timeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h4 id="do">Do</h4>
<p>当我们使用标准库构建了 HTTP 请求之后，会开启 HTTP 事务发送 HTTP 请求并等待远程的响应，</p>
<ol>
<li>参数检查</li>
<li>默认值设置</li>
<li>多跳请求</li>
<li>计算超时时间点deadline</li>
<li>调用c.send(req, deadline)</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// Do sends an HTTP request and returns an HTTP response, following
</span><span class="c1">// policy (such as redirects, cookies, auth) as configured on the
</span><span class="c1">// client.
</span><span class="c1">//
</span><span class="c1">// An error is returned if caused by client policy (such as
</span><span class="c1">// CheckRedirect), or failure to speak HTTP (such as a network
</span><span class="c1">// connectivity problem). A non-2xx status code doesn&#39;t cause an
</span><span class="c1">// error.
</span><span class="c1">//
</span><span class="c1">// If the returned error is nil, the Response will contain a non-nil
</span><span class="c1">// Body which the user is expected to close. If the Body is not both
</span><span class="c1">// read to EOF and closed, the Client&#39;s underlying RoundTripper
</span><span class="c1">// (typically Transport) may not be able to re-use a persistent TCP
</span><span class="c1">// connection to the server for a subsequent &#34;keep-alive&#34; request.
</span><span class="c1">//
</span><span class="c1">// The request Body, if non-nil, will be closed by the underlying
</span><span class="c1">// Transport, even on errors.
</span><span class="c1">//
</span><span class="c1">// On error, any Response can be ignored. A non-nil Response with a
</span><span class="c1">// non-nil error only occurs when CheckRedirect fails, and even then
</span><span class="c1">// the returned Response.Body is already closed.
</span><span class="c1">//
</span><span class="c1">// Generally Get, Post, or PostForm will be used instead of Do.
</span><span class="c1">//
</span><span class="c1">// If the server replies with a redirect, the Client first uses the
</span><span class="c1">// CheckRedirect function to determine whether the redirect should be
</span><span class="c1">// followed. If permitted, a 301, 302, or 303 redirect causes
</span><span class="c1">// subsequent requests to use HTTP method GET
</span><span class="c1">// (or HEAD if the original request was HEAD), with no body.
</span><span class="c1">// A 307 or 308 redirect preserves the original HTTP method and body,
</span><span class="c1">// provided that the Request.GetBody function is defined.
</span><span class="c1">// The NewRequest function automatically sets GetBody for common
</span><span class="c1">// standard library body types.
</span><span class="c1">//
</span><span class="c1">// Any returned error will be of type *url.Error. The url.Error
</span><span class="c1">// value&#39;s Timeout method will report true if request timed out or was
</span><span class="c1">// canceled.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Client</span><span class="p">)</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Response</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">do</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">testHookClientDoResult</span> <span class="kd">func</span><span class="p">(</span><span class="nx">retres</span> <span class="o">*</span><span class="nx">Response</span><span class="p">,</span> <span class="nx">reterr</span> <span class="kt">error</span><span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Client</span><span class="p">)</span> <span class="nf">do</span><span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="nx">retres</span> <span class="o">*</span><span class="nx">Response</span><span class="p">,</span> <span class="nx">reterr</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">testHookClientDoResult</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">testHookClientDoResult</span><span class="p">(</span><span class="nx">retres</span><span class="p">,</span> <span class="nx">reterr</span><span class="p">)</span> <span class="p">}()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">url</span><span class="p">.</span><span class="nx">Error</span><span class="p">{</span>
			<span class="nx">Op</span><span class="p">:</span>  <span class="nf">urlErrorOp</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Method</span><span class="p">),</span>
			<span class="nx">Err</span><span class="p">:</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: nil Request.URL&#34;</span><span class="p">),</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="p">(</span>
		<span class="nx">deadline</span>      <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">deadline</span><span class="p">()</span>
		<span class="nx">reqs</span>          <span class="p">[]</span><span class="o">*</span><span class="nx">Request</span>
		<span class="nx">resp</span>          <span class="o">*</span><span class="nx">Response</span>
		<span class="nx">copyHeaders</span>   <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">makeHeadersCopier</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
		<span class="nx">reqBodyClosed</span> <span class="p">=</span> <span class="kc">false</span> <span class="c1">// have we closed the current req.Body?
</span><span class="c1"></span>
		<span class="c1">// Redirect behavior:
</span><span class="c1"></span>		<span class="nx">redirectMethod</span> <span class="kt">string</span>
		<span class="nx">includeBody</span>    <span class="kt">bool</span>
	<span class="p">)</span>
	<span class="nx">uerr</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="c1">// the body may have been closed already by c.send()
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">reqBodyClosed</span> <span class="p">{</span>
			<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="kd">var</span> <span class="nx">urlStr</span> <span class="kt">string</span>
		<span class="k">if</span> <span class="nx">resp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Request</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">urlStr</span> <span class="p">=</span> <span class="nf">stripPassword</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">URL</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">urlStr</span> <span class="p">=</span> <span class="nf">stripPassword</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="nx">url</span><span class="p">.</span><span class="nx">Error</span><span class="p">{</span>
			<span class="nx">Op</span><span class="p">:</span>  <span class="nf">urlErrorOp</span><span class="p">(</span><span class="nx">reqs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Method</span><span class="p">),</span>
			<span class="nx">URL</span><span class="p">:</span> <span class="nx">urlStr</span><span class="p">,</span>
			<span class="nx">Err</span><span class="p">:</span> <span class="nx">err</span><span class="p">,</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// For all but the first request, create the next
</span><span class="c1"></span>		<span class="c1">// request hop and replace req.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">reqs</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">loc</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;Location&#34;</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">loc</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
				<span class="nx">resp</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">uerr</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;%d response missing Location header&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="nx">u</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">loc</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">resp</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">uerr</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;failed to parse Location header %q: %v&#34;</span><span class="p">,</span> <span class="nx">loc</span><span class="p">,</span> <span class="nx">err</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="nx">host</span> <span class="o">:=</span> <span class="s">&#34;&#34;</span>
			<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Host</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Host</span> <span class="o">!=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Host</span> <span class="p">{</span>
				<span class="c1">// If the caller specified a custom Host header and the
</span><span class="c1"></span>				<span class="c1">// redirect location is relative, preserve the Host header
</span><span class="c1"></span>				<span class="c1">// through the redirect. See issue #22233.
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">u</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">loc</span><span class="p">);</span> <span class="nx">u</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">u</span><span class="p">.</span><span class="nf">IsAbs</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">host</span> <span class="p">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Host</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="nx">ireq</span> <span class="o">:=</span> <span class="nx">reqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="nx">req</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Request</span><span class="p">{</span>
				<span class="nx">Method</span><span class="p">:</span>   <span class="nx">redirectMethod</span><span class="p">,</span>
				<span class="nx">Response</span><span class="p">:</span> <span class="nx">resp</span><span class="p">,</span>
				<span class="nx">URL</span><span class="p">:</span>      <span class="nx">u</span><span class="p">,</span>
				<span class="nx">Header</span><span class="p">:</span>   <span class="nb">make</span><span class="p">(</span><span class="nx">Header</span><span class="p">),</span>
				<span class="nx">Host</span><span class="p">:</span>     <span class="nx">host</span><span class="p">,</span>
				<span class="nx">Cancel</span><span class="p">:</span>   <span class="nx">ireq</span><span class="p">.</span><span class="nx">Cancel</span><span class="p">,</span>
				<span class="nx">ctx</span><span class="p">:</span>      <span class="nx">ireq</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">includeBody</span> <span class="o">&amp;&amp;</span> <span class="nx">ireq</span><span class="p">.</span><span class="nx">GetBody</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">ireq</span><span class="p">.</span><span class="nf">GetBody</span><span class="p">()</span>
				<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">resp</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
					<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">uerr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nx">req</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="p">=</span> <span class="nx">ireq</span><span class="p">.</span><span class="nx">ContentLength</span>
			<span class="p">}</span>

			<span class="c1">// Copy original headers before setting the Referer,
</span><span class="c1"></span>			<span class="c1">// in case the user set Referer on their first request.
</span><span class="c1"></span>			<span class="c1">// If they really want to override, they can do it in
</span><span class="c1"></span>			<span class="c1">// their CheckRedirect func.
</span><span class="c1"></span>			<span class="nf">copyHeaders</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>

			<span class="c1">// Add the Referer header from the most recent
</span><span class="c1"></span>			<span class="c1">// request URL to the new one, if it&#39;s not https-&gt;http:
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">ref</span> <span class="o">:=</span> <span class="nf">refererForURL</span><span class="p">(</span><span class="nx">reqs</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">reqs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nx">URL</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">);</span> <span class="nx">ref</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
				<span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Referer&#34;</span><span class="p">,</span> <span class="nx">ref</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">checkRedirect</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">reqs</span><span class="p">)</span>

			<span class="c1">// Sentinel error to let users select the
</span><span class="c1"></span>			<span class="c1">// previous response, without closing its
</span><span class="c1"></span>			<span class="c1">// body. See Issue 10069.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">ErrUseLastResponse</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">resp</span><span class="p">,</span> <span class="kc">nil</span>
			<span class="p">}</span>

			<span class="c1">// Close the previous response&#39;s body. But
</span><span class="c1"></span>			<span class="c1">// read at least some of the body so if it&#39;s
</span><span class="c1"></span>			<span class="c1">// small the underlying TCP connection will be
</span><span class="c1"></span>			<span class="c1">// re-used. No need to check for errors: if it
</span><span class="c1"></span>			<span class="c1">// fails, the Transport won&#39;t reuse it anyway.
</span><span class="c1"></span>			<span class="kd">const</span> <span class="nx">maxBodySlurpSize</span> <span class="p">=</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span>
			<span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="o">&lt;=</span> <span class="nx">maxBodySlurpSize</span> <span class="p">{</span>
				<span class="nx">io</span><span class="p">.</span><span class="nf">CopyN</span><span class="p">(</span><span class="nx">ioutil</span><span class="p">.</span><span class="nx">Discard</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span> <span class="nx">maxBodySlurpSize</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="c1">// Special case for Go 1 compatibility: return both the response
</span><span class="c1"></span>				<span class="c1">// and an error if the CheckRedirect function failed.
</span><span class="c1"></span>				<span class="c1">// See https://golang.org/issue/3795
</span><span class="c1"></span>				<span class="c1">// The resp.Body has already been closed.
</span><span class="c1"></span>				<span class="nx">ue</span> <span class="o">:=</span> <span class="nf">uerr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
				<span class="nx">ue</span><span class="p">.(</span><span class="o">*</span><span class="nx">url</span><span class="p">.</span><span class="nx">Error</span><span class="p">).</span><span class="nx">URL</span> <span class="p">=</span> <span class="nx">loc</span>
				<span class="k">return</span> <span class="nx">resp</span><span class="p">,</span> <span class="nx">ue</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="nx">reqs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">reqs</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>
		<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
		<span class="kd">var</span> <span class="nx">didTimeout</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">bool</span>
		<span class="k">if</span> <span class="nx">resp</span><span class="p">,</span> <span class="nx">didTimeout</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">deadline</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// c.send() always closes req.Body
</span><span class="c1"></span>			<span class="nx">reqBodyClosed</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">deadline</span><span class="p">.</span><span class="nf">IsZero</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nf">didTimeout</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">httpError</span><span class="p">{</span>
					<span class="c1">// TODO: early in cycle: s/Client.Timeout exceeded/timeout or context cancellation/
</span><span class="c1"></span>					<span class="nx">err</span><span class="p">:</span>     <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34; (Client.Timeout exceeded while awaiting headers)&#34;</span><span class="p">,</span>
					<span class="nx">timeout</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">uerr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="kd">var</span> <span class="nx">shouldRedirect</span> <span class="kt">bool</span>
		<span class="nx">redirectMethod</span><span class="p">,</span> <span class="nx">shouldRedirect</span><span class="p">,</span> <span class="nx">includeBody</span> <span class="p">=</span> <span class="nf">redirectBehavior</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nx">resp</span><span class="p">,</span> <span class="nx">reqs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">shouldRedirect</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">resp</span><span class="p">,</span> <span class="kc">nil</span>
		<span class="p">}</span>

		<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="send">send</h4>
<p>该方法主要实现了:</p>
<ol>
<li>Cookie的装载</li>
<li>Transport对象的获取</li>
<li>调用send(req, c.transport(), deadline)</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// didTimeout is non-nil only if err != nil.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Client</span><span class="p">)</span> <span class="nf">send</span><span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="nx">resp</span> <span class="o">*</span><span class="nx">Response</span><span class="p">,</span> <span class="nx">didTimeout</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Jar</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">cookie</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Jar</span><span class="p">.</span><span class="nf">Cookies</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">req</span><span class="p">.</span><span class="nf">AddCookie</span><span class="p">(</span><span class="nx">cookie</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">resp</span><span class="p">,</span> <span class="nx">didTimeout</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">send</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">transport</span><span class="p">(),</span> <span class="nx">deadline</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">didTimeout</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Jar</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">rc</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.</span><span class="nf">Cookies</span><span class="p">();</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rc</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">Jar</span><span class="p">.</span><span class="nf">SetCookies</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">,</span> <span class="nx">rc</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">resp</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
<span class="c1">// send issues an HTTP request.
</span><span class="c1">// Caller should close resp.Body when done reading from it.
</span></code></pre></td></tr></table>
</div>
</div><h4 id="httpsend">http.send</h4>
<p>该方法主要实现了:</p>
<ol>
<li>参数校验: URL, header, RoundTripper</li>
<li>超时取消: setRequestCancel(req, rt, deadline)</li>
<li>请求事务: rt.RoundTrip(req)</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">send</span><span class="p">(</span><span class="nx">ireq</span> <span class="o">*</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">rt</span> <span class="nx">RoundTripper</span><span class="p">,</span> <span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="nx">resp</span> <span class="o">*</span><span class="nx">Response</span><span class="p">,</span> <span class="nx">didTimeout</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">req</span> <span class="o">:=</span> <span class="nx">ireq</span> <span class="c1">// req is either the original request, or a modified fork
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nx">rt</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">alwaysFalse</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: no Client.Transport or DefaultTransport&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">alwaysFalse</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: nil Request.URL&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">RequestURI</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">alwaysFalse</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: Request.RequestURI can&#39;t be set in client requests&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// forkReq forks req into a shallow clone of ireq the first
</span><span class="c1"></span>	<span class="c1">// time it&#39;s called.
</span><span class="c1"></span>	<span class="nx">forkReq</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">ireq</span> <span class="o">==</span> <span class="nx">req</span> <span class="p">{</span>
			<span class="nx">req</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Request</span><span class="p">)</span>
			<span class="o">*</span><span class="nx">req</span> <span class="p">=</span> <span class="o">*</span><span class="nx">ireq</span> <span class="c1">// shallow clone
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Most the callers of send (Get, Post, et al) don&#39;t need
</span><span class="c1"></span>	<span class="c1">// Headers, leaving it uninitialized. We guarantee to the
</span><span class="c1"></span>	<span class="c1">// Transport that this has been initialized, though.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">forkReq</span><span class="p">()</span>
		<span class="nx">req</span><span class="p">.</span><span class="nx">Header</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">Header</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">u</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">User</span><span class="p">;</span> <span class="nx">u</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;Authorization&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">username</span> <span class="o">:=</span> <span class="nx">u</span><span class="p">.</span><span class="nf">Username</span><span class="p">()</span>
		<span class="nx">password</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">u</span><span class="p">.</span><span class="nf">Password</span><span class="p">()</span>
		<span class="nf">forkReq</span><span class="p">()</span>
		<span class="nx">req</span><span class="p">.</span><span class="nx">Header</span> <span class="p">=</span> <span class="nf">cloneOrMakeHeader</span><span class="p">(</span><span class="nx">ireq</span><span class="p">.</span><span class="nx">Header</span><span class="p">)</span>
		<span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Authorization&#34;</span><span class="p">,</span> <span class="s">&#34;Basic &#34;</span><span class="o">+</span><span class="nf">basicAuth</span><span class="p">(</span><span class="nx">username</span><span class="p">,</span> <span class="nx">password</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">deadline</span><span class="p">.</span><span class="nf">IsZero</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">forkReq</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 请求是否超时的监控
</span><span class="c1"></span>	<span class="nx">stopTimer</span><span class="p">,</span> <span class="nx">didTimeout</span> <span class="o">:=</span> <span class="nf">setRequestCancel</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">rt</span><span class="p">,</span> <span class="nx">deadline</span><span class="p">)</span>
	<span class="c1">// 真正发送请求
</span><span class="c1"></span>	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">RoundTrip</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">stopTimer</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">resp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;RoundTripper returned a response &amp; error; ignoring response&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">tlsErr</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">tls</span><span class="p">.</span><span class="nx">RecordHeaderError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="c1">// If we get a bad TLS record header, check to see if the
</span><span class="c1"></span>			<span class="c1">// response looks like HTTP and give a more helpful error.
</span><span class="c1"></span>			<span class="c1">// See golang.org/issue/11111.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nb">string</span><span class="p">(</span><span class="nx">tlsErr</span><span class="p">.</span><span class="nx">RecordHeader</span><span class="p">[:])</span> <span class="o">==</span> <span class="s">&#34;HTTP/&#34;</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: server gave HTTP response to HTTPS client&#34;</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">didTimeout</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">resp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">didTimeout</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;http: RoundTripper implementation (%T) returned a nil *Response with a nil error&#34;</span><span class="p">,</span> <span class="nx">rt</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// The documentation on the Body field says “The http Client and Transport
</span><span class="c1"></span>		<span class="c1">// guarantee that Body is always non-nil, even on responses without a body
</span><span class="c1"></span>		<span class="c1">// or responses with a zero-length body.” Unfortunately, we didn&#39;t document
</span><span class="c1"></span>		<span class="c1">// that same constraint for arbitrary RoundTripper implementations, and
</span><span class="c1"></span>		<span class="c1">// RoundTripper implementations in the wild (mostly in tests) assume that
</span><span class="c1"></span>		<span class="c1">// they can use a nil Body to mean an empty one (similar to Request.Body).
</span><span class="c1"></span>		<span class="c1">// (See https://golang.org/issue/38095.)
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// If the ContentLength allows the Body to be empty, fill in an empty one
</span><span class="c1"></span>		<span class="c1">// here to ensure that it is non-nil.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Method</span> <span class="o">!=</span> <span class="s">&#34;HEAD&#34;</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">didTimeout</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;http: RoundTripper implementation (%T) returned a *Response with content length %d but a nil Body&#34;</span><span class="p">,</span> <span class="nx">rt</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">ContentLength</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span> <span class="p">=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">NopCloser</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">deadline</span><span class="p">.</span><span class="nf">IsZero</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">cancelTimerBody</span><span class="p">{</span>
			<span class="nx">stop</span><span class="p">:</span>          <span class="nx">stopTimer</span><span class="p">,</span>
			<span class="nx">rc</span><span class="p">:</span>            <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span>
			<span class="nx">reqDidTimeout</span><span class="p">:</span> <span class="nx">didTimeout</span><span class="p">,</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">resp</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="httpsetrequestcancel">http.setRequestCancel</h4>
<p>该方法主要实现了:</p>
<p>创建一个协程利用select chan机制阻塞等待取消请求</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// setRequestCancel sets req.Cancel and adds a deadline context to req
</span><span class="c1">// if deadline is non-zero. The RoundTripper&#39;s type is used to
</span><span class="c1">// determine whether the legacy CancelRequest behavior should be used.
</span><span class="c1">//
</span><span class="c1">// As background, there are three ways to cancel a request:
</span><span class="c1">// First was Transport.CancelRequest. (deprecated)
</span><span class="c1">// Second was Request.Cancel.
</span><span class="c1">// Third was Request.Context.
</span><span class="c1">// This function populates the second and third, and uses the first if it really needs to.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">setRequestCancel</span><span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">rt</span> <span class="nx">RoundTripper</span><span class="p">,</span> <span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="nx">stopTimer</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">didTimeout</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">deadline</span><span class="p">.</span><span class="nf">IsZero</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">nop</span><span class="p">,</span> <span class="nx">alwaysFalse</span>
	<span class="p">}</span>
	<span class="nx">knownTransport</span> <span class="o">:=</span> <span class="nf">knownRoundTripperImpl</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>
	<span class="nx">oldCtx</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Cancel</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">knownTransport</span> <span class="p">{</span>
		<span class="c1">// If they already had a Request.Context that&#39;s
</span><span class="c1"></span>		<span class="c1">// expiring sooner, do nothing:
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nf">timeBeforeContextDeadline</span><span class="p">(</span><span class="nx">deadline</span><span class="p">,</span> <span class="nx">oldCtx</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">nop</span><span class="p">,</span> <span class="nx">alwaysFalse</span>
		<span class="p">}</span>

		<span class="kd">var</span> <span class="nx">cancelCtx</span> <span class="kd">func</span><span class="p">()</span>
		<span class="nx">req</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancelCtx</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">oldCtx</span><span class="p">,</span> <span class="nx">deadline</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">cancelCtx</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">After</span><span class="p">(</span><span class="nx">deadline</span><span class="p">)</span> <span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">initialReqCancel</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Cancel</span> <span class="c1">// the user&#39;s original Request.Cancel, if any
</span><span class="c1"></span>
	<span class="kd">var</span> <span class="nx">cancelCtx</span> <span class="kd">func</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">oldCtx</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">();</span> <span class="nf">timeBeforeContextDeadline</span><span class="p">(</span><span class="nx">deadline</span><span class="p">,</span> <span class="nx">oldCtx</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancelCtx</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">oldCtx</span><span class="p">,</span> <span class="nx">deadline</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">cancel</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
	<span class="nx">req</span><span class="p">.</span><span class="nx">Cancel</span> <span class="p">=</span> <span class="nx">cancel</span>

	<span class="nx">doCancel</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// The second way in the func comment above:
</span><span class="c1"></span>		<span class="nb">close</span><span class="p">(</span><span class="nx">cancel</span><span class="p">)</span>
		<span class="c1">// The first way, used only for RoundTripper
</span><span class="c1"></span>		<span class="c1">// implementations written before Go 1.5 or Go 1.6.
</span><span class="c1"></span>		<span class="kd">type</span> <span class="nx">canceler</span> <span class="kd">interface</span><span class="p">{</span> <span class="nf">CancelRequest</span><span class="p">(</span><span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">}</span>
		<span class="k">if</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.(</span><span class="nx">canceler</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">v</span><span class="p">.</span><span class="nf">CancelRequest</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">stopTimerCh</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
	<span class="kd">var</span> <span class="nx">once</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
	<span class="nx">stopTimer</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nb">close</span><span class="p">(</span><span class="nx">stopTimerCh</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">cancelCtx</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">cancelCtx</span><span class="p">()</span>
			<span class="p">}</span>
		<span class="p">})</span>
	<span class="p">}</span>

	<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Until</span><span class="p">(</span><span class="nx">deadline</span><span class="p">))</span>
	<span class="kd">var</span> <span class="nx">timedOut</span> <span class="nx">atomicBool</span>

	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">initialReqCancel</span><span class="p">:</span>	<span class="c1">// 用户传来的取消请求
</span><span class="c1"></span>			<span class="nf">doCancel</span><span class="p">()</span>
			<span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>	<span class="c1">// 超时取消请求
</span><span class="c1"></span>			<span class="nx">timedOut</span><span class="p">.</span><span class="nf">setTrue</span><span class="p">()</span>
			<span class="nf">doCancel</span><span class="p">()</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">stopTimerCh</span><span class="p">:</span>
			<span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="k">return</span> <span class="nx">stopTimer</span><span class="p">,</span> <span class="nx">timedOut</span><span class="p">.</span><span class="nx">isSet</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="transport">Transport</h3>
<p>经过上面一连串的调用，我们最终来到了标准库实现底层 HTTP 协议的结构体 — net/http.Transport</p>
<ol>
<li>Transport用来缓存连接, 以供将来重用, 而不是根据需要创建</li>
<li>Transport是并发安全的</li>
<li>Transport仅是用来发送HTTP或HTTPS的低级功能, 像cookie和redirect等高级功能是http.Client实现的</li>
</ol>
<h4 id="defaulttransport">DefaultTransport</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// DefaultTransport is the default implementation of Transport and is
</span><span class="c1">// used by DefaultClient. It establishes network connections as needed
</span><span class="c1">// and caches them for reuse by subsequent calls. It uses HTTP proxies
</span><span class="c1">// as directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and
</span><span class="c1">// $no_proxy) environment variables.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">DefaultTransport</span> <span class="nx">RoundTripper</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Transport</span><span class="p">{</span>
	<span class="nx">Proxy</span><span class="p">:</span> <span class="nx">ProxyFromEnvironment</span><span class="p">,</span>
	<span class="nx">DialContext</span><span class="p">:</span> <span class="p">(</span><span class="o">&amp;</span><span class="nx">net</span><span class="p">.</span><span class="nx">Dialer</span><span class="p">{</span>
		<span class="nx">Timeout</span><span class="p">:</span>   <span class="mi">30</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
		<span class="nx">KeepAlive</span><span class="p">:</span> <span class="mi">30</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
		<span class="nx">DualStack</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
	<span class="p">}).</span><span class="nx">DialContext</span><span class="p">,</span>
	<span class="nx">ForceAttemptHTTP2</span><span class="p">:</span>     <span class="kc">true</span><span class="p">,</span>
	<span class="nx">MaxIdleConns</span><span class="p">:</span>          <span class="mi">100</span><span class="p">,</span>
	<span class="nx">IdleConnTimeout</span><span class="p">:</span>       <span class="mi">90</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
	<span class="nx">TLSHandshakeTimeout</span><span class="p">:</span>   <span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
	<span class="nx">ExpectContinueTimeout</span><span class="p">:</span> <span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>net.Dialer.Timeout 限制创建一个TCP连接使用的时间（如果需要一个新的链接）</li>
<li>net.Dialer.KeepAlive：开启长连接（说明默认http client是默认开启长连接的）。</li>
<li>http.Transport.MaxIdleConns 最大空闲连接数是100</li>
<li>http.Transport.IdleConnTimeout IdleConnTimeout它用于控制一个闲置连接在连接池中的保留时间，而不考虑一个客户端请求被阻塞在哪个阶段。</li>
<li>http.Transport.TLSHandshakeTimeout TLS握手超时时间</li>
<li>http.Transport.ExpectContinueTimeout：限制客户端在发送一个包含：100-continue的http报文头后，等待收到一个go-ahead响应报文所用的时间。</li>
</ul>
<p>http client发起请求一般是由Do(req *Request) (*Response, error)方法开始，而真正处理请求分发的是transport的RoundTrip(*Request) (*Response, error)方法。那么Transport 到底应该怎么设置才合理呢？</p>
<p>IdleConn不仅受到MaxIdleConn的限制，也受到MaxIdleConnsPerHost的限制，DefaultTranspor中是没有设置该参数的，而默认的参数为2这是 RFC2616 建议的单个客户端发起的持久连接数，不过在大部分情况下，这个值有是不够用的。</p>
<p>MaxIdleConnsPerHost限制的是相同connectMethodKey（代表着不同的协议 不同的host，也就是不同的请求）到 persistConn 的映射的空闲连接数量.</p>
<p>需要特别注意的是，MaxIdleConnsPerHost默认等于2，即与目标主机最多只维护两个空闲连接。这会导致什么呢？</p>
<p>如果遇到突发流量，瞬间建立大量连接，但是回收连接时，由于最大空闲连接数的限制，该联机不能进入空闲连接池，只能直接关闭。结果是，一直新建大量连接，又关闭大量连，业务机器的TIME_WAIT连接数随之突增。</p>
<p>线上有些业务架构是这样的：客户端 ===&gt; LVS ===&gt; Nginx ===&gt; 服务。LVS负载均衡方案采用DR模式，LVS与Nginx配置统一VIP。此时在客户端看来，只有一个IP地址，只有一个Host。上述问题更为明显。</p>
<p>如果我们想设置为短连接，有几种方法:</p>
<ul>
<li>设置DisableKeepAlives = true: 这时就会发送Connections:close给server端，在server端响应后就会主动关闭连接,导致大量的TIME_WAIT出现，</li>
<li>设置MaxIdleConnsPerHost &lt; 0: 当MaxIdleConnsPerHost &lt; 0时，连接池是无法放置空闲连接的，所以无法复用,连接直接会在client端被关闭。这样每次请求后都会由client发起主动关闭连接的请求，server端就不会出现大量的TIME_WAIT.</li>
</ul>
<h4 id="roundtripper">RoundTripper</h4>
<p>transport实现了RoundTripper接口，该接口只有一个方法RoundTrip()，故transport的入口函数就是RoundTrip()。transport的主要功能其实就是缓存了长连接，用于大量http请求场景下的连接复用，减少发送请求时TCP(TLS)连接建立的时间损耗，同时transport还能对连接做一些限制，如连接超时时间，每个host的最大连接数等。transport对长连接的缓存和控制仅限于TCP+(TLS)+HTTP1，不对HTTP2做缓存和限制。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// RoundTripper is an interface representing the ability to execute a
</span><span class="c1">// single HTTP transaction, obtaining the Response for a given Request.
</span><span class="c1">//
</span><span class="c1">// A RoundTripper must be safe for concurrent use by multiple
</span><span class="c1">// goroutines.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RoundTripper</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// RoundTrip executes a single HTTP transaction, returning
</span><span class="c1"></span>	<span class="c1">// a Response for the provided Request.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// RoundTrip should not attempt to interpret the response. In
</span><span class="c1"></span>	<span class="c1">// particular, RoundTrip must return err == nil if it obtained
</span><span class="c1"></span>	<span class="c1">// a response, regardless of the response&#39;s HTTP status code.
</span><span class="c1"></span>	<span class="c1">// A non-nil err should be reserved for failure to obtain a
</span><span class="c1"></span>	<span class="c1">// response. Similarly, RoundTrip should not attempt to
</span><span class="c1"></span>	<span class="c1">// handle higher-level protocol details such as redirects,
</span><span class="c1"></span>	<span class="c1">// authentication, or cookies.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// RoundTrip should not modify the request, except for
</span><span class="c1"></span>	<span class="c1">// consuming and closing the Request&#39;s Body. RoundTrip may
</span><span class="c1"></span>	<span class="c1">// read fields of the request in a separate goroutine. Callers
</span><span class="c1"></span>	<span class="c1">// should not mutate or reuse the request until the Response&#39;s
</span><span class="c1"></span>	<span class="c1">// Body has been closed.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// RoundTrip must always close the body, including on errors,
</span><span class="c1"></span>	<span class="c1">// but depending on the implementation may do so in a separate
</span><span class="c1"></span>	<span class="c1">// goroutine even after RoundTrip returns. This means that
</span><span class="c1"></span>	<span class="c1">// callers wanting to reuse the body for subsequent requests
</span><span class="c1"></span>	<span class="c1">// must arrange to wait for the Close call before doing so.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The Request&#39;s URL and Header fields must be initialized.
</span><span class="c1"></span>	<span class="nf">RoundTrip</span><span class="p">(</span><span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Response</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// RoundTrip implements the RoundTripper interface.
</span><span class="c1">//
</span><span class="c1">// For higher-level HTTP client support (such as handling of cookies
</span><span class="c1">// and redirects), see Get, Post, and the Client type.
</span><span class="c1">//
</span><span class="c1">// Like the RoundTripper interface, the error types returned
</span><span class="c1">// by RoundTrip are unspecified.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transport</span><span class="p">)</span> <span class="nf">RoundTrip</span><span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Response</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nf">roundTrip</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h4 id="tranport">tranport</h4>
<p>tranport包含如下几个主要概念：</p>
<ul>
<li>连接池：在idleConn中保存了不同类型(connectMethodKey)的请求连接(persistConn)。当发生请求时，首先会尝试从连接池中取一条符合其请求类型的连接使用</li>
<li>readLoop/writeLoop：连接之上的功能，循环处理该类型的请求(发送request，返回response)</li>
<li>roundTrip：请求的真正入口，接收到一个请求后会交给writeLoop和readLoop处理。
一对readLoop/writeLoop只能处理一条连接，如果这条连接上没有更多的请求，则关闭连接，退出循环，释放系统资源</li>
</ul>
<p>net/http.Transport 实现了 net/http.RoundTripper 接口，也是整个请求过程中最重要并且最复杂的结构体.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Transport is an implementation of RoundTripper that supports HTTP,
</span><span class="c1">// HTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).
</span><span class="c1">//
</span><span class="c1">// By default, Transport caches connections for future re-use.
</span><span class="c1">// This may leave many open connections when accessing many hosts.
</span><span class="c1">// This behavior can be managed using Transport&#39;s CloseIdleConnections method
</span><span class="c1">// and the MaxIdleConnsPerHost and DisableKeepAlives fields.
</span><span class="c1">//
</span><span class="c1">// Transports should be reused instead of created as needed.
</span><span class="c1">// Transports are safe for concurrent use by multiple goroutines.
</span><span class="c1">//
</span><span class="c1">// A Transport is a low-level primitive for making HTTP and HTTPS requests.
</span><span class="c1">// For high-level functionality, such as cookies and redirects, see Client.
</span><span class="c1">//
</span><span class="c1">// Transport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2
</span><span class="c1">// for HTTPS URLs, depending on whether the server supports HTTP/2,
</span><span class="c1">// and how the Transport is configured. The DefaultTransport supports HTTP/2.
</span><span class="c1">// To explicitly enable HTTP/2 on a transport, use golang.org/x/net/http2
</span><span class="c1">// and call ConfigureTransport. See the package docs for more about HTTP/2.
</span><span class="c1">//
</span><span class="c1">// Responses with status codes in the 1xx range are either handled
</span><span class="c1">// automatically (100 expect-continue) or ignored. The one
</span><span class="c1">// exception is HTTP status code 101 (Switching Protocols), which is
</span><span class="c1">// considered a terminal status and returned by RoundTrip. To see the
</span><span class="c1">// ignored 1xx responses, use the httptrace trace package&#39;s
</span><span class="c1">// ClientTrace.Got1xxResponse.
</span><span class="c1">//
</span><span class="c1">// Transport only retries a request upon encountering a network error
</span><span class="c1">// if the request is idempotent and either has no body or has its
</span><span class="c1">// Request.GetBody defined. HTTP requests are considered idempotent if
</span><span class="c1">// they have HTTP methods GET, HEAD, OPTIONS, or TRACE; or if their
</span><span class="c1">// Header map contains an &#34;Idempotency-Key&#34; or &#34;X-Idempotency-Key&#34;
</span><span class="c1">// entry. If the idempotency key value is a zero-length slice, the
</span><span class="c1">// request is treated as idempotent but the header is not sent on the
</span><span class="c1">// wire.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Transport</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">//操作空闲连接需要获取锁
</span><span class="c1"></span>	<span class="nx">idleMu</span>       <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
    <span class="nx">closeIdle</span>    <span class="kt">bool</span>                                <span class="c1">// user has requested to close all idle conns
</span><span class="c1"></span>    <span class="c1">// idle状态的persistConn连接池，最大值受maxIdleConnsPerHost限制
</span><span class="c1"></span>	<span class="nx">idleConn</span>     <span class="kd">map</span><span class="p">[</span><span class="nx">connectMethodKey</span><span class="p">][]</span><span class="o">*</span><span class="nx">persistConn</span> <span class="c1">// most recently used at end
</span><span class="c1"></span>	<span class="c1">//等待空闲连接的队列，基于切片实现，队列大小无限制
</span><span class="c1"></span>    <span class="nx">idleConnWait</span> <span class="kd">map</span><span class="p">[</span><span class="nx">connectMethodKey</span><span class="p">]</span><span class="nx">wantConnQueue</span>  <span class="c1">// waiting getConns
</span><span class="c1"></span>    <span class="c1">// 长度受MaxIdleConns限制，队列方式保存所有idle的pconn
</span><span class="c1"></span>	<span class="nx">idleLRU</span>      <span class="nx">connLRU</span>

    <span class="nx">reqMu</span>       <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
    <span class="c1">// 请求取消器(如: 超时取消)
</span><span class="c1"></span>	<span class="nx">reqCanceler</span> <span class="kd">map</span><span class="p">[</span><span class="nx">cancelKey</span><span class="p">]</span><span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">)</span>

    <span class="nx">altMu</span>    <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>   <span class="c1">// guards changing altProto only
</span><span class="c1"></span>    <span class="c1">//nil or map[string]RoundTripper，key为URI scheme，表示处理该scheme的RoundTripper实现。注意与TLSNextProto的不同，前者表示URI的scheme，后者表示tls之上的协议。如前者不会体现http2，后者会体现http2
</span><span class="c1"></span>	<span class="nx">altProto</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Value</span> <span class="c1">// of nil or map[string]RoundTripper, key is URI scheme
</span><span class="c1"></span>	<span class="c1">//排队等待建立连接需要获取锁
</span><span class="c1"></span>	<span class="nx">connsPerHostMu</span>   <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="c1">//每个host建立的连接数
</span><span class="c1"></span>	<span class="nx">connsPerHost</span>     <span class="kd">map</span><span class="p">[</span><span class="nx">connectMethodKey</span><span class="p">]</span><span class="kt">int</span>
	<span class="c1">//等待建立连接的队列，同样基于切片实现，队列大小无限制
</span><span class="c1"></span>	<span class="nx">connsPerHostWait</span> <span class="kd">map</span><span class="p">[</span><span class="nx">connectMethodKey</span><span class="p">]</span><span class="nx">wantConnQueue</span> <span class="c1">// waiting getConns
</span><span class="c1"></span>
	<span class="c1">// Proxy specifies a function to return a proxy for a given
</span><span class="c1"></span>	<span class="c1">// Request. If the function returns a non-nil error, the
</span><span class="c1"></span>	<span class="c1">// request is aborted with the provided error.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The proxy type is determined by the URL scheme. &#34;http&#34;,
</span><span class="c1"></span>	<span class="c1">// &#34;https&#34;, and &#34;socks5&#34; are supported. If the scheme is empty,
</span><span class="c1"></span>	<span class="c1">// &#34;http&#34; is assumed.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>    <span class="c1">// If Proxy is nil or returns a nil *URL, no proxy is used.
</span><span class="c1"></span>	<span class="c1">// 为request返回一个代理的url
</span><span class="c1"></span>	<span class="c1">// Proxy指定一个函数来返回给定Request的代理
</span><span class="c1"></span>	<span class="c1">// 代理类型由URL scheme确定。支持http, https等。 默认为http
</span><span class="c1"></span>    <span class="c1">// 如果Proxy为空或返回空的url，则不使用任何代理。
</span><span class="c1"></span>	<span class="nx">Proxy</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">url</span><span class="p">.</span><span class="nx">URL</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

	<span class="c1">// DialContext specifies the dial function for creating unencrypted TCP connections.
</span><span class="c1"></span>	<span class="c1">// If DialContext is nil (and the deprecated Dial below is also nil),
</span><span class="c1"></span>	<span class="c1">// then the transport dials using package net.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// DialContext runs concurrently with calls to RoundTrip.
</span><span class="c1"></span>	<span class="c1">// A RoundTrip call that initiates a dial may end up using
</span><span class="c1"></span>	<span class="c1">// a connection dialed previously when the earlier connection
</span><span class="c1"></span>    <span class="c1">// becomes idle before the later DialContext completes.
</span><span class="c1"></span>	<span class="c1">// 创建未加密的tcp连接，比Dial函数增加了context控制
</span><span class="c1"></span>	<span class="c1">// DialContext指定用于创建未加密的TCP连接的拨号功能。
</span><span class="c1"></span>    <span class="c1">// 如果DialContext为nil（并且下面不建议使用的Dial也为nil），则传输使用程序包net进行拨号。
</span><span class="c1"></span>	<span class="c1">// DialContext与RoundTrip的调用同时运行。
</span><span class="c1"></span>    <span class="c1">// 当较早的连接在以后的DialContext完成之前处于空闲状态时，
</span><span class="c1"></span>    <span class="c1">// 发起拨号的RoundTrip调用可能会使用先前拨打的连接结束。
</span><span class="c1"></span>	<span class="nx">DialContext</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">network</span><span class="p">,</span> <span class="nx">addr</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

	<span class="c1">// Dial specifies the dial function for creating unencrypted TCP connections.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Dial runs concurrently with calls to RoundTrip.
</span><span class="c1"></span>	<span class="c1">// A RoundTrip call that initiates a dial may end up using
</span><span class="c1"></span>	<span class="c1">// a connection dialed previously when the earlier connection
</span><span class="c1"></span>	<span class="c1">// becomes idle before the later Dial completes.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Deprecated: Use DialContext instead, which allows the transport
</span><span class="c1"></span>	<span class="c1">// to cancel dials as soon as they are no longer needed.
</span><span class="c1"></span>    <span class="c1">// If both are set, DialContext takes priority.
</span><span class="c1"></span>	<span class="c1">// 创建未加密的tcp连接，废弃，使用DialContext
</span><span class="c1"></span>	<span class="c1">// Dial指定用于创建未加密的TCP连接的拨号功能。
</span><span class="c1"></span>    <span class="c1">// 拨号与RoundTrip的呼叫同时运行。
</span><span class="c1"></span>    <span class="c1">// 当较早的连接在之后的拨号完成之前变为空闲时，发起拨号的RoundTrip呼叫可能会使用先前拨打的连接结束。
</span><span class="c1"></span>	<span class="c1">// 不推荐使用：改用DialContext，它使传输器在不再需要拨号时立即取消它们。
</span><span class="c1"></span>    <span class="c1">// 如果两者都设置，则DialContext优先。
</span><span class="c1"></span>	<span class="nx">Dial</span> <span class="kd">func</span><span class="p">(</span><span class="nx">network</span><span class="p">,</span> <span class="nx">addr</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

	<span class="c1">// DialTLSContext specifies an optional dial function for creating
</span><span class="c1"></span>	<span class="c1">// TLS connections for non-proxied HTTPS requests.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If DialTLSContext is nil (and the deprecated DialTLS below is also nil),
</span><span class="c1"></span>	<span class="c1">// DialContext and TLSClientConfig are used.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If DialTLSContext is set, the Dial and DialContext hooks are not used for HTTPS
</span><span class="c1"></span>	<span class="c1">// requests and the TLSClientConfig and TLSHandshakeTimeout
</span><span class="c1"></span>	<span class="c1">// are ignored. The returned net.Conn is assumed to already be
</span><span class="c1"></span>	<span class="c1">// past the TLS handshake.
</span><span class="c1"></span>	<span class="nx">DialTLSContext</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">network</span><span class="p">,</span> <span class="nx">addr</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

	<span class="c1">// DialTLS specifies an optional dial function for creating
</span><span class="c1"></span>	<span class="c1">// TLS connections for non-proxied HTTPS requests.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Deprecated: Use DialTLSContext instead, which allows the transport
</span><span class="c1"></span>	<span class="c1">// to cancel dials as soon as they are no longer needed.
</span><span class="c1"></span>    <span class="c1">// If both are set, DialTLSContext takes priority.
</span><span class="c1"></span>	<span class="c1">// 为非代理模式的https创建连接的函数，如果该函数非空，则不会使用Dial函数，且忽略TLSClientConfig和TLSHandshakeTimeout；反之使用Dila和TLSClientConfig。即有限使用DialTLS进行tls协商
</span><span class="c1"></span>	<span class="c1">// DialTLS指定用于为非代理HTTPS请求创建TLS连接的可选拨号功能。
</span><span class="c1"></span>	<span class="c1">// 如果DialTLS为nil，则使用Dial和TLSClientConfig。
</span><span class="c1"></span>	<span class="c1">// 如果设置了DialTLS，则Dial Hook不用于HTTPS请求，
</span><span class="c1"></span>    <span class="c1">// 并且TLSClientConfig和TLSHandshakeTimeout将被忽略。
</span><span class="c1"></span>    <span class="c1">// 假定返回的net.Conn已通过TLS握手。
</span><span class="c1"></span>	<span class="nx">DialTLS</span> <span class="kd">func</span><span class="p">(</span><span class="nx">network</span><span class="p">,</span> <span class="nx">addr</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

	<span class="c1">// TLSClientConfig specifies the TLS configuration to use with
</span><span class="c1"></span>	<span class="c1">// tls.Client.
</span><span class="c1"></span>	<span class="c1">// If nil, the default configuration is used.
</span><span class="c1"></span>    <span class="c1">// If non-nil, HTTP/2 support may not be enabled by default.
</span><span class="c1"></span>	<span class="c1">// tls client用于tls协商的配置
</span><span class="c1"></span>	<span class="c1">// TLSClientConfig指定要与tls.Client一起使用的TLS配置。
</span><span class="c1"></span>	<span class="c1">// 如果为nil，则使用默认配置。
</span><span class="c1"></span>    <span class="c1">// 如果为非nil，则默认情况下可能不会启用HTTP / 2支持。
</span><span class="c1"></span>	<span class="nx">TLSClientConfig</span> <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span>

	<span class="c1">// TLSHandshakeTimeout specifies the maximum amount of time waiting to
</span><span class="c1"></span>    <span class="c1">// wait for a TLS handshake. Zero means no timeout.
</span><span class="c1"></span>    <span class="c1">// 限制TLS握手使用的时间
</span><span class="c1"></span>	<span class="nx">TLSHandshakeTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
	<span class="c1">// DisableKeepAlives, if true, disables HTTP keep-alives and
</span><span class="c1"></span>	<span class="c1">// will only use the connection to the server for a single
</span><span class="c1"></span>	<span class="c1">// HTTP request.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>    <span class="c1">// This is unrelated to the similarly named TCP keep-alives.
</span><span class="c1"></span>	<span class="c1">// 是否取消长连接
</span><span class="c1"></span>	<span class="c1">// 默认为false，如果设为true,那么所有连接复用的优化选项都无效
</span><span class="c1"></span>	<span class="c1">// true: 将禁用HTTP保持活动状态，并且仅将与服务器的连接用于单个HTTP请求。
</span><span class="c1"></span>	<span class="c1">// 这与类似命名的TCP保持活动无关。
</span><span class="c1"></span>	<span class="nx">DisableKeepAlives</span> <span class="kt">bool</span>

	<span class="c1">// DisableCompression, if true, prevents the Transport from
</span><span class="c1"></span>	<span class="c1">// requesting compression with an &#34;Accept-Encoding: gzip&#34;
</span><span class="c1"></span>	<span class="c1">// request header when the Request contains no existing
</span><span class="c1"></span>	<span class="c1">// Accept-Encoding value. If the Transport requests gzip on
</span><span class="c1"></span>	<span class="c1">// its own and gets a gzipped response, it&#39;s transparently
</span><span class="c1"></span>	<span class="c1">// decoded in the Response.Body. However, if the user
</span><span class="c1"></span>	<span class="c1">// explicitly requested gzip it is not automatically
</span><span class="c1"></span>    <span class="c1">// uncompressed.
</span><span class="c1"></span>	<span class="c1">// 是否取消HTTP压缩
</span><span class="c1"></span>	<span class="c1">// true: 当请求不包含现有的Accept-Encoding值时，
</span><span class="c1"></span>    <span class="c1">// 阻止传输使用“ Accept-Encoding：gzip”请求标头请求压缩。
</span><span class="c1"></span>    <span class="c1">// 如果传输本身请求gzip并获得gzip压缩的响应，则会在Response.Body中对其进行透明解码。
</span><span class="c1"></span>    <span class="c1">// 但是，如果用户明确请求gzip，则不会自动将其解压缩。
</span><span class="c1"></span>	<span class="nx">DisableCompression</span> <span class="kt">bool</span>

	<span class="c1">// MaxIdleConns controls the maximum number of idle (keep-alive)
</span><span class="c1"></span>    <span class="c1">// connections across all hosts. Zero means no limit.
</span><span class="c1"></span>	<span class="c1">// 所有host的idle状态的最大连接数目，即idleConn中所有连接数
</span><span class="c1"></span>	<span class="c1">// 最大空闲连接数，该Transport可以维护最大这么多的空闲连接，用于连接复用, 为0时表示无限制
</span><span class="c1"></span>	<span class="c1">// 表示连接池对所有host的最大链接数量，host也即dest-ip，默认为无穷大（0），但是通常情况下为了性能考虑都要严格限制该数目（实际使用中通常利用压测 二分得到该参数的最佳近似值）。 太大容易导致客户端和服务端的socket数量剧增，导致内存吃满，文件描述符不足等问题；太小则限制了连接池的socket数量，资源利用率较低。
</span><span class="c1"></span>	<span class="c1">// MaxIdleConns控制所有主机之间的最大空闲（保持活动）连接数。 零表示无限制。
</span><span class="c1"></span>	<span class="nx">MaxIdleConns</span> <span class="kt">int</span>

	<span class="c1">// MaxIdleConnsPerHost, if non-zero, controls the maximum idle
</span><span class="c1"></span>	<span class="c1">// (keep-alive) connections to keep per-host. If zero,
</span><span class="c1"></span>    <span class="c1">// DefaultMaxIdleConnsPerHost is used.
</span><span class="c1"></span>	<span class="c1">// 每个host的idle状态的最大连接数目，即idleConn中的key对应的连接数
</span><span class="c1"></span>	<span class="c1">// 每个目标host最大空闲连接数；默认为2（注意默认值）
</span><span class="c1"></span>	<span class="c1">// 如果客户端只需要访问一个host，那么最好将MaxIdleConnsPerHost与MaxIdleConns设置为相同，这样逻辑更加清晰。
</span><span class="c1"></span>	<span class="c1">// MaxIdleConnsPerHost控制最大空闲（保持活动）连接以保留每个主机。
</span><span class="c1"></span>    <span class="c1">// 如果为零，则使用DefaultMaxIdleConnsPerHost=2。
</span><span class="c1"></span>	<span class="nx">MaxIdleConnsPerHost</span> <span class="kt">int</span>

	<span class="c1">// MaxConnsPerHost optionally limits the total number of
</span><span class="c1"></span>	<span class="c1">// connections per host, including connections in the dialing,
</span><span class="c1"></span>	<span class="c1">// active, and idle states. On limit violation, dials will block.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Zero means no limit.
</span><span class="c1"></span>	<span class="c1">// 每个host上的最大连接数目，含dialing/active/idle状态的connections。http2时，每个host只允许有一条idle的conneciton
</span><span class="c1"></span>	<span class="c1">// MaxConnsPerHost可以选择限制每个主机的连接总数，包括处于拨号，活动和空闲状态的连接。
</span><span class="c1"></span>    <span class="c1">// 超出限制时，拨号将阻塞。
</span><span class="c1"></span>	<span class="c1">// 零表示无限制。
</span><span class="c1"></span>    <span class="c1">// 对于HTTP / 2，当前仅控制一次创建的新连接数，而不是总数。
</span><span class="c1"></span>    <span class="c1">// 实际上，使用HTTP / 2的主机只有大约一个空闲连接。
</span><span class="c1"></span>	<span class="nx">MaxConnsPerHost</span> <span class="kt">int</span>

	<span class="c1">// IdleConnTimeout is the maximum amount of time an idle
</span><span class="c1"></span>	<span class="c1">// (keep-alive) connection will remain idle before closing
</span><span class="c1"></span>	<span class="c1">// itself.
</span><span class="c1"></span>    <span class="c1">// Zero means no limit.
</span><span class="c1"></span>	<span class="c1">// 连接保持idle状态的最大时间，超时关闭pconn
</span><span class="c1"></span>	<span class="c1">// 空闲timeout设置，也即socket在该时间内没有交互则自动关闭连接（注意：该timeout起点是从每次空闲开始计时，若有交互则重置为0）,该参数通常设置为分钟级别，例如：90秒。
</span><span class="c1"></span>	<span class="nx">IdleConnTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>

	<span class="c1">// ResponseHeaderTimeout, if non-zero, specifies the amount of
</span><span class="c1"></span>	<span class="c1">// time to wait for a server&#39;s response headers after fully
</span><span class="c1"></span>	<span class="c1">// writing the request (including its body, if any). This
</span><span class="c1"></span>	<span class="c1">// time does not include the time to read the response body.
</span><span class="c1"></span>	<span class="c1">// 限制读取响应报文头使用的时间
</span><span class="c1"></span>	<span class="nx">ResponseHeaderTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>

	<span class="c1">// ExpectContinueTimeout, if non-zero, specifies the amount of
</span><span class="c1"></span>	<span class="c1">// time to wait for a server&#39;s first response headers after fully
</span><span class="c1"></span>	<span class="c1">// writing the request headers if the request has an
</span><span class="c1"></span>	<span class="c1">// &#34;Expect: 100-continue&#34; header. Zero means no timeout and
</span><span class="c1"></span>	<span class="c1">// causes the body to be sent immediately, without
</span><span class="c1"></span>	<span class="c1">// waiting for the server to approve.
</span><span class="c1"></span>	<span class="c1">// This time does not include the time to send the request header.
</span><span class="c1"></span>	<span class="c1">// 等待服务器的第一个响应headers的时间，0表示没有超时，则body会立刻发送，无需等待服务器批准，这个时间不包括发送请求header的时间
</span><span class="c1"></span>	<span class="c1">//（如果非零）指定如果请求具有“期望：100-连续”标头，
</span><span class="c1"></span>    <span class="c1">// 则在完全写入请求标头之后等待服务器的第一个响应标头的时间。
</span><span class="c1"></span>    <span class="c1">// 零表示没有超时，并导致正文立即发送，而无需等待服务器批准。
</span><span class="c1"></span>	<span class="c1">// 此时间不包括发送请求标头的时间。
</span><span class="c1"></span>	<span class="nx">ExpectContinueTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>

	<span class="c1">// TLSNextProto specifies how the Transport switches to an
</span><span class="c1"></span>	<span class="c1">// alternate protocol (such as HTTP/2) after a TLS ALPN
</span><span class="c1"></span>	<span class="c1">// protocol negotiation. If Transport dials an TLS connection
</span><span class="c1"></span>	<span class="c1">// with a non-empty protocol name and TLSNextProto contains a
</span><span class="c1"></span>	<span class="c1">// map entry for that key (such as &#34;h2&#34;), then the func is
</span><span class="c1"></span>	<span class="c1">// called with the request&#39;s authority (such as &#34;example.com&#34;
</span><span class="c1"></span>	<span class="c1">// or &#34;example.com:1234&#34;) and the TLS connection. The function
</span><span class="c1"></span>	<span class="c1">// must return a RoundTripper that then handles the request.
</span><span class="c1"></span>	<span class="c1">// If TLSNextProto is not nil, HTTP/2 support is not enabled
</span><span class="c1"></span>    <span class="c1">// automatically.
</span><span class="c1"></span>	<span class="c1">// RoundTripper 在tls协商带NPN/ALPN的扩展后，transport如何切换到其他协议。指tls之上的协议(next指的就是tls之上的意思)
</span><span class="c1"></span>	<span class="c1">// TLSNextProto指定在TLS NPN / ALPN协议协商之后，传输方式如何切换到备用协议（例如HTTP / 2）。
</span><span class="c1"></span>    <span class="c1">// 如果传输使用非空协议名称拨打TLS连接，并且TLSNextProto包含该键的映射条目（例如“ h2”），
</span><span class="c1"></span>    <span class="c1">// 则将以请求的权限（例如“ example.com”或“ example .com：1234“）和TLS连接。
</span><span class="c1"></span>    <span class="c1">// 该函数必须返回RoundTripper，然后再处理请求。
</span><span class="c1"></span>    <span class="c1">// 如果TLSNextProto不为nil，则不会自动启用HTTP / 2支持。
</span><span class="c1"></span>	<span class="nx">TLSNextProto</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">func</span><span class="p">(</span><span class="nx">authority</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="nx">RoundTripper</span>

	<span class="c1">// ProxyConnectHeader optionally specifies headers to send to
</span><span class="c1"></span>	<span class="c1">// proxies during CONNECT requests.
</span><span class="c1"></span>	<span class="c1">// 可以选择指定在CONNECT请求期间发送到代理的header。
</span><span class="c1"></span>	<span class="nx">ProxyConnectHeader</span> <span class="nx">Header</span>

	<span class="c1">// MaxResponseHeaderBytes specifies a limit on how many
</span><span class="c1"></span>	<span class="c1">// response bytes are allowed in the server&#39;s response
</span><span class="c1"></span>	<span class="c1">// header.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Zero means to use a default limit.
</span><span class="c1"></span>	<span class="c1">// 指定对服务器的响应标头中允许的响应字节数的限制。
</span><span class="c1"></span>	<span class="c1">// 零表示使用默认限制。
</span><span class="c1"></span>	<span class="nx">MaxResponseHeaderBytes</span> <span class="kt">int64</span>

	<span class="c1">// WriteBufferSize specifies the size of the write buffer used
</span><span class="c1"></span>	<span class="c1">// when writing to the transport.
</span><span class="c1"></span>	<span class="c1">// If zero, a default (currently 4KB) is used.
</span><span class="c1"></span>	<span class="nx">WriteBufferSize</span> <span class="kt">int</span>

	<span class="c1">// ReadBufferSize specifies the size of the read buffer used
</span><span class="c1"></span>	<span class="c1">// when reading from the transport.
</span><span class="c1"></span>	<span class="c1">// If zero, a default (currently 4KB) is used.
</span><span class="c1"></span>	<span class="nx">ReadBufferSize</span> <span class="kt">int</span>

	<span class="c1">// nextProtoOnce guards initialization of TLSNextProto and
</span><span class="c1"></span>	<span class="c1">// h2transport (via onceSetNextProtoDefaults)
</span><span class="c1"></span>	<span class="c1">// nextProtoOnce防止TLSNextProto和h2transport的初始化（通过OnceSetNextProtoDefaults）
</span><span class="c1"></span>	<span class="nx">nextProtoOnce</span>      <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
	<span class="c1">// 如果http2已连接，则为非null
</span><span class="c1"></span>	<span class="nx">h2transport</span>        <span class="nx">h2Transport</span> <span class="c1">// non-nil if http2 wired up
</span><span class="c1"></span>	<span class="nx">tlsNextProtoWasNil</span> <span class="kt">bool</span>        <span class="c1">// whether TLSNextProto was nil when the Once fired
</span><span class="c1"></span>
	<span class="c1">// ForceAttemptHTTP2 controls whether HTTP/2 is enabled when a non-zero
</span><span class="c1"></span>	<span class="c1">// Dial, DialTLS, or DialContext func or TLSClientConfig is provided.
</span><span class="c1"></span>	<span class="c1">// By default, use of any those fields conservatively disables HTTP/2.
</span><span class="c1"></span>	<span class="c1">// To use a custom dialer or TLS config and still attempt HTTP/2
</span><span class="c1"></span>	<span class="c1">// upgrades, set this to true.
</span><span class="c1"></span>	<span class="nx">ForceAttemptHTTP2</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="connectmethodkey">connectMethodKey</h5>
<p>connectMethodKey的值就是client连接的server的host值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// connectMethodKey is the map key version of connectMethod, with a
</span><span class="c1">// stringified proxy URL (or the empty string) instead of a pointer to
</span><span class="c1">// a URL.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">connectMethodKey</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">proxy</span><span class="p">,</span> <span class="nx">scheme</span><span class="p">,</span> <span class="nx">addr</span> <span class="kt">string</span>
	<span class="nx">onlyH1</span>              <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">k</span> <span class="nx">connectMethodKey</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="c1">// Only used by tests.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">h1</span> <span class="kt">string</span>
	<span class="k">if</span> <span class="nx">k</span><span class="p">.</span><span class="nx">onlyH1</span> <span class="p">{</span>
		<span class="nx">h1</span> <span class="p">=</span> <span class="s">&#34;,h1&#34;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s|%s%s|%s&#34;</span><span class="p">,</span> <span class="nx">k</span><span class="p">.</span><span class="nx">proxy</span><span class="p">,</span> <span class="nx">k</span><span class="p">.</span><span class="nx">scheme</span><span class="p">,</span> <span class="nx">h1</span><span class="p">,</span> <span class="nx">k</span><span class="p">.</span><span class="nx">addr</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="roundtrip">roundTrip</h4>
<p>我们可以在标准库的 net/http.Transport 中调用 net/http.Transport.RegisterProtocol 为不同的协议注册 net/http.RoundTripper 的实现，在下面的这段代码中就会根据 URL 中的协议选择对应的实现来替代默认的逻辑：</p>
<p>在默认情况下，我们都会使用 net/http.persistConn 持久连接处理 HTTP 请求，该方法会先获取用于发送请求的连接，随后调用 net/http.persistConn.roundTrip：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// RegisterProtocol registers a new protocol with scheme.
</span><span class="c1">// The Transport will pass requests using the given scheme to rt.
</span><span class="c1">// It is rt&#39;s responsibility to simulate HTTP request semantics.
</span><span class="c1">//
</span><span class="c1">// RegisterProtocol can be used by other packages to provide
</span><span class="c1">// implementations of protocol schemes like &#34;ftp&#34; or &#34;file&#34;.
</span><span class="c1">//
</span><span class="c1">// If rt.RoundTrip returns ErrSkipAltProtocol, the Transport will
</span><span class="c1">// handle the RoundTrip itself for that one request, as if the
</span><span class="c1">// protocol were not registered.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transport</span><span class="p">)</span> <span class="nf">RegisterProtocol</span><span class="p">(</span><span class="nx">scheme</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">rt</span> <span class="nx">RoundTripper</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">altMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">t</span><span class="p">.</span><span class="nx">altMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">oldMap</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">altProto</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">RoundTripper</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">exists</span> <span class="o">:=</span> <span class="nx">oldMap</span><span class="p">[</span><span class="nx">scheme</span><span class="p">];</span> <span class="nx">exists</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;protocol &#34;</span> <span class="o">+</span> <span class="nx">scheme</span> <span class="o">+</span> <span class="s">&#34; already registered&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">newMap</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">RoundTripper</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">oldMap</span> <span class="p">{</span>
		<span class="nx">newMap</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span>
	<span class="p">}</span>
	<span class="nx">newMap</span><span class="p">[</span><span class="nx">scheme</span><span class="p">]</span> <span class="p">=</span> <span class="nx">rt</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">altProto</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">newMap</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Transport.roundTrip是主入口，它通过传入一个request参数，由此选择一个合适的长连接来发送该request并返回response。整个流程主要分为两步：</p>
<p>使用getConn函数来获得底层TCP(TLS)连接；调用roundTrip函数进行上层协议(HTTP)处理。</p>
<p>该方法主要实现了</p>
<ol>
<li>参数校验: scheme, host, method, protocol&hellip;</li>
<li>获取缓存的或新建的连接</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// roundTrip implements a RoundTripper over HTTP.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transport</span><span class="p">)</span> <span class="nf">roundTrip</span><span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Response</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">nextProtoOnce</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">onceSetNextProtoDefaults</span><span class="p">)</span>
	<span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">()</span>
	<span class="nx">trace</span> <span class="o">:=</span> <span class="nx">httptrace</span><span class="p">.</span><span class="nf">ContextClientTrace</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: nil Request.URL&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: nil Request.Header&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">scheme</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Scheme</span>
    <span class="nx">isHTTP</span> <span class="o">:=</span> <span class="nx">scheme</span> <span class="o">==</span> <span class="s">&#34;http&#34;</span> <span class="o">||</span> <span class="nx">scheme</span> <span class="o">==</span> <span class="s">&#34;https&#34;</span>
    <span class="c1">// 下面判断request首部的有效性
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">isHTTP</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">vv</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">httpguts</span><span class="p">.</span><span class="nf">ValidHeaderFieldName</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;net/http: invalid header field name %q&#34;</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vv</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">!</span><span class="nx">httpguts</span><span class="p">.</span><span class="nf">ValidHeaderFieldValue</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
					<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
					<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;net/http: invalid header field value %q for key %v&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">origReq</span> <span class="o">:=</span> <span class="nx">req</span>
	<span class="nx">cancelKey</span> <span class="o">:=</span> <span class="nx">cancelKey</span><span class="p">{</span><span class="nx">origReq</span><span class="p">}</span>
	<span class="nx">req</span> <span class="p">=</span> <span class="nf">setupRewindBody</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
    <span class="c1">// 判断是否使用注册的RoundTrip来处理对应的scheme。对于使用tcp+tls+http1(wss协议升级)的场景
</span><span class="c1"></span>    <span class="c1">// 不能使用注册的roundTrip。后续代码对tcp+tls+http1或tcp+http1进行了roundTrip处理
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">altRT</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">alternateRoundTripper</span><span class="p">(</span><span class="nx">req</span><span class="p">);</span> <span class="nx">altRT</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">altRT</span><span class="p">.</span><span class="nf">RoundTrip</span><span class="p">(</span><span class="nx">req</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">ErrSkipAltProtocol</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
		<span class="nx">req</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">rewindBody</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 后续仅处理URL scheme为http或https的连接
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">isHTTP</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">badStringError</span><span class="p">(</span><span class="s">&#34;unsupported protocol scheme&#34;</span><span class="p">,</span> <span class="nx">scheme</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Method</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">validMethod</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Method</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;net/http: invalid method %q&#34;</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Method</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Host</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: no Host in request URL&#34;</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="c1">// 下面for循环用于在request出现错误的时候进行请求重试。但不是所有的请求失败都会被尝试，如请求被取消(errRequestCanceled)
</span><span class="c1"></span>    <span class="c1">// 的情况是不会进行重试的。具体参见shouldRetryRequest函数
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
			<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span>
		<span class="k">default</span><span class="p">:</span>
		<span class="p">}</span>

		<span class="c1">// treq gets modified by roundTrip, so we need to recreate for each retry.
</span><span class="c1"></span>        <span class="nx">treq</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">transportRequest</span><span class="p">{</span><span class="nx">Request</span><span class="p">:</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">trace</span><span class="p">:</span> <span class="nx">trace</span><span class="p">,</span> <span class="nx">cancelKey</span><span class="p">:</span> <span class="nx">cancelKey</span><span class="p">}</span>
        <span class="c1">// connectMethodForRequest函数通过输入一个request返回一个connectMethod(简称cm)，该类型通过
</span><span class="c1"></span>        <span class="c1">// {proxyURL,targetScheme,tartgetAddr,onlyH1},即{代理URL，server端的scheme，server的地址，是否HTTP1}
</span><span class="c1"></span>        <span class="c1">// 来表示一个请求。一个符合connectMethod描述的request将会在Transport.idleConn中匹配到一类长连接。
</span><span class="c1"></span>		<span class="nx">cm</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">connectMethodForRequest</span><span class="p">(</span><span class="nx">treq</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="c1">// Get the cached or newly-created connection to either the
</span><span class="c1"></span>		<span class="c1">// host (for http or https), the http proxy, or the http proxy
</span><span class="c1"></span>		<span class="c1">// pre-CONNECTed to https server. In any case, we&#39;ll be ready
</span><span class="c1"></span>        <span class="c1">// to send it requests.
</span><span class="c1"></span>        <span class="c1">// 获取一条长连接，如果连接池中有现成的连接则直接返回，否则返回一条新建的连接。该连接可能是HTTP2格式的，存放在persistCnn.alt中,
</span><span class="c1"></span>        <span class="c1">// 使用其自注册的RoundTrip处理。该函数描述参见下面内容。
</span><span class="c1"></span>        <span class="c1">// 从getConn的实现中可以看到，一个请求只能在idle的连接上执行，反之一条连接只能同时处理一个请求。
</span><span class="c1"></span>        <span class="nx">pconn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">getConn</span><span class="p">(</span><span class="nx">treq</span><span class="p">,</span> <span class="nx">cm</span><span class="p">)</span>
        <span class="c1">// 如果获取底层连接失败，无法继续上层协议的请求，直接返回错误
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="c1">// 每个request都会在getConn中设置reqCanceler，获取连接失败，清空设置
</span><span class="c1"></span>			<span class="nx">t</span><span class="p">.</span><span class="nf">setReqCanceler</span><span class="p">(</span><span class="nx">cancelKey</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
			<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>

        <span class="kd">var</span> <span class="nx">resp</span> <span class="o">*</span><span class="nx">Response</span>
        <span class="c1">// pconn.alt就是从Transport.TLSNextProto中获取的，它表示TLS之上的协议，如HTTP2。从persistConn.alt的注释中可以看出
</span><span class="c1"></span>        <span class="c1">// 目前alt仅支持HTTP2协议，后续可能会支持更多协议。
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">alt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="c1">// HTTP/2 path.
</span><span class="c1"></span>            <span class="c1">// 清除getConn中设置的标记。具体参见getConn
</span><span class="c1"></span>			<span class="nx">t</span><span class="p">.</span><span class="nf">setReqCanceler</span><span class="p">(</span><span class="nx">cancelKey</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span> <span class="c1">// not cancelable with CancelRequest
</span><span class="c1"></span>			<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">alt</span><span class="p">.</span><span class="nf">RoundTrip</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
             <span class="c1">// pconn.roundTrip中做了比较复杂的处理，该函数用于发送request并返回response。
</span><span class="c1"></span>            <span class="c1">// 通过writeLoop发送request，通过readLoop返回response
</span><span class="c1"></span>			<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">pconn</span><span class="p">.</span><span class="nf">roundTrip</span><span class="p">(</span><span class="nx">treq</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">// 如果成功返回response，则整个处理结束.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">resp</span><span class="p">.</span><span class="nx">Request</span> <span class="p">=</span> <span class="nx">origReq</span>
			<span class="k">return</span> <span class="nx">resp</span><span class="p">,</span> <span class="kc">nil</span>
		<span class="p">}</span>

		<span class="c1">// Failed. Clean up and determine whether to retry.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nf">http2isNoCachedConnError</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">removeIdleConn</span><span class="p">(</span><span class="nx">pconn</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">t</span><span class="p">.</span><span class="nf">decConnsPerHost</span><span class="p">(</span><span class="nx">pconn</span><span class="p">.</span><span class="nx">cacheKey</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">!</span><span class="nx">pconn</span><span class="p">.</span><span class="nf">shouldRetryRequest</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Issue 16465: return underlying net.Conn.Read error from peek,
</span><span class="c1"></span>			<span class="c1">// as we&#39;ve historically done.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">transportReadFromServerError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">err</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="nf">testHookRoundTripRetried</span><span class="p">()</span>

		<span class="c1">// Rewind the body if we&#39;re able to.
</span><span class="c1"></span>		<span class="nx">req</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">rewindBody</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transport</span><span class="p">)</span> <span class="nf">connectMethodForRequest</span><span class="p">(</span><span class="nx">treq</span> <span class="o">*</span><span class="nx">transportRequest</span><span class="p">)</span> <span class="p">(</span><span class="nx">cm</span> <span class="nx">connectMethod</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">cm</span><span class="p">.</span><span class="nx">targetScheme</span> <span class="p">=</span> <span class="nx">treq</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Scheme</span>
	<span class="nx">cm</span><span class="p">.</span><span class="nx">targetAddr</span> <span class="p">=</span> <span class="nf">canonicalAddr</span><span class="p">(</span><span class="nx">treq</span><span class="p">.</span><span class="nx">URL</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Proxy</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cm</span><span class="p">.</span><span class="nx">proxyURL</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Proxy</span><span class="p">(</span><span class="nx">treq</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">cm</span><span class="p">.</span><span class="nx">onlyH1</span> <span class="p">=</span> <span class="nx">treq</span><span class="p">.</span><span class="nf">requiresHTTP1</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">cm</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="persistconn">persistConn</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// persistConn wraps a connection, usually a persistent one
</span><span class="c1">// (but may be used for non-keep-alive requests as well)
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">persistConn</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// alt optionally specifies the TLS NextProto RoundTripper.
</span><span class="c1"></span>	<span class="c1">// This is used for HTTP/2 today and future protocols later.
</span><span class="c1"></span>	<span class="c1">// If it&#39;s non-nil, the rest of the fields are unused.
</span><span class="c1"></span>	<span class="nx">alt</span> <span class="nx">RoundTripper</span>

	<span class="nx">t</span>         <span class="o">*</span><span class="nx">Transport</span>
	<span class="nx">cacheKey</span>  <span class="nx">connectMethodKey</span>
	<span class="nx">conn</span>      <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span>
	<span class="nx">tlsState</span>  <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">ConnectionState</span>
	<span class="nx">br</span>        <span class="o">*</span><span class="nx">bufio</span><span class="p">.</span><span class="nx">Reader</span>       <span class="c1">// from conn
</span><span class="c1"></span>	<span class="nx">bw</span>        <span class="o">*</span><span class="nx">bufio</span><span class="p">.</span><span class="nx">Writer</span>       <span class="c1">// to conn
</span><span class="c1"></span>	<span class="nx">nwrite</span>    <span class="kt">int64</span>               <span class="c1">// bytes written
</span><span class="c1"></span>	<span class="nx">reqch</span>     <span class="kd">chan</span> <span class="nx">requestAndChan</span> <span class="c1">// written by roundTrip; read by readLoop
</span><span class="c1"></span>	<span class="nx">writech</span>   <span class="kd">chan</span> <span class="nx">writeRequest</span>   <span class="c1">// written by roundTrip; read by writeLoop
</span><span class="c1"></span>	<span class="nx">closech</span>   <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>       <span class="c1">// closed when conn closed
</span><span class="c1"></span>	<span class="nx">isProxy</span>   <span class="kt">bool</span>
	<span class="nx">sawEOF</span>    <span class="kt">bool</span>  <span class="c1">// whether we&#39;ve seen EOF from conn; owned by readLoop
</span><span class="c1"></span>	<span class="nx">readLimit</span> <span class="kt">int64</span> <span class="c1">// bytes allowed to be read; owned by readLoop
</span><span class="c1"></span>	<span class="c1">// writeErrCh passes the request write error (usually nil)
</span><span class="c1"></span>	<span class="c1">// from the writeLoop goroutine to the readLoop which passes
</span><span class="c1"></span>	<span class="c1">// it off to the res.Body reader, which then uses it to decide
</span><span class="c1"></span>	<span class="c1">// whether or not a connection can be reused. Issue 7569.
</span><span class="c1"></span>	<span class="nx">writeErrCh</span> <span class="kd">chan</span> <span class="kt">error</span>

	<span class="nx">writeLoopDone</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span> <span class="c1">// closed when write loop ends
</span><span class="c1"></span>
	<span class="c1">// Both guarded by Transport.idleMu:
</span><span class="c1"></span>	<span class="nx">idleAt</span>    <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>   <span class="c1">// time it last become idle
</span><span class="c1"></span>	<span class="nx">idleTimer</span> <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Timer</span> <span class="c1">// holding an AfterFunc to close it
</span><span class="c1"></span>
	<span class="nx">mu</span>                   <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// guards following fields
</span><span class="c1"></span>	<span class="nx">numExpectedResponses</span> <span class="kt">int</span>
	<span class="nx">closed</span>               <span class="kt">error</span> <span class="c1">// set non-nil when conn is closed, before closech is closed
</span><span class="c1"></span>	<span class="nx">canceledErr</span>          <span class="kt">error</span> <span class="c1">// set non-nil if conn is canceled
</span><span class="c1"></span>	<span class="nx">broken</span>               <span class="kt">bool</span>  <span class="c1">// an error has happened on this connection; marked broken so it&#39;s not reused.
</span><span class="c1"></span>	<span class="nx">reused</span>               <span class="kt">bool</span>  <span class="c1">// whether conn has had successful request/response and is being reused.
</span><span class="c1"></span>	<span class="c1">// mutateHeaderFunc is an optional func to modify extra
</span><span class="c1"></span>	<span class="c1">// headers on each outbound request before it&#39;s written. (the
</span><span class="c1"></span>	<span class="c1">// original Request given to RoundTrip is not modified)
</span><span class="c1"></span>	<span class="nx">mutateHeaderFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">Header</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h4 id="getconn">getConn</h4>
<p>getConn用于返回一条长连接。长连接的来源有2种路径：</p>
<ol>
<li>调用 net/http.Transport.queueForIdleConn 在队列中等待闲置的连接；</li>
<li>调用 net/http.Transport.queueForDial 在队列中等待建立新的连接；</li>
</ol>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210203180148.png" alt=""></p>
<p>连接是一种相对比较昂贵的资源，如果在每次发出 HTTP 请求之前都建立新的连接，可能会消耗比较多的时间，带来较大的额外开销，通过连接池对资源进行分配和复用可以有效地提高 HTTP 请求的整体性能，多数的网络库客户端都会采取类似的策略来复用资源。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// getConn dials and creates a new persistConn to the target as
</span><span class="c1">// specified in the connectMethod. This includes doing a proxy CONNECT
</span><span class="c1">// and/or setting up TLS.  If this doesn&#39;t return an error, the persistConn
</span><span class="c1">// is ready to write requests to.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transport</span><span class="p">)</span> <span class="nf">getConn</span><span class="p">(</span><span class="nx">treq</span> <span class="o">*</span><span class="nx">transportRequest</span><span class="p">,</span> <span class="nx">cm</span> <span class="nx">connectMethod</span><span class="p">)</span> <span class="p">(</span><span class="nx">pc</span> <span class="o">*</span><span class="nx">persistConn</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">req</span> <span class="o">:=</span> <span class="nx">treq</span><span class="p">.</span><span class="nx">Request</span>
	<span class="nx">trace</span> <span class="o">:=</span> <span class="nx">treq</span><span class="p">.</span><span class="nx">trace</span>
	<span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">GetConn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">trace</span><span class="p">.</span><span class="nf">GetConn</span><span class="p">(</span><span class="nx">cm</span><span class="p">.</span><span class="nf">addr</span><span class="p">())</span>
	<span class="p">}</span>

	<span class="nx">w</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">wantConn</span><span class="p">{</span>
		<span class="nx">cm</span><span class="p">:</span>         <span class="nx">cm</span><span class="p">,</span>
		<span class="nx">key</span><span class="p">:</span>        <span class="nx">cm</span><span class="p">.</span><span class="nf">key</span><span class="p">(),</span>
		<span class="nx">ctx</span><span class="p">:</span>        <span class="nx">ctx</span><span class="p">,</span>
		<span class="nx">ready</span><span class="p">:</span>      <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">1</span><span class="p">),</span>
		<span class="nx">beforeDial</span><span class="p">:</span> <span class="nx">testHookPrePendingDial</span><span class="p">,</span>
		<span class="nx">afterDial</span><span class="p">:</span>  <span class="nx">testHookPostPendingDial</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">w</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>

    <span class="c1">// Queue for idle connection.
</span><span class="c1"></span>    <span class="c1">// 从连接池中找一条合适的连接，如果找到则返回该连接，否则新建连接
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">delivered</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">queueForIdleConn</span><span class="p">(</span><span class="nx">w</span><span class="p">);</span> <span class="nx">delivered</span> <span class="p">{</span>
		<span class="nx">pc</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">pc</span>
		<span class="c1">// Trace only for HTTP/1.
</span><span class="c1"></span>		<span class="c1">// HTTP/2 calls trace.GotConn itself.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">alt</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">GotConn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">trace</span><span class="p">.</span><span class="nf">GotConn</span><span class="p">(</span><span class="nx">pc</span><span class="p">.</span><span class="nf">gotIdleConnTrace</span><span class="p">(</span><span class="nx">pc</span><span class="p">.</span><span class="nx">idleAt</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="c1">// set request canceler to some non-nil function so we
</span><span class="c1"></span>		<span class="c1">// can detect whether it was cleared between now and when
</span><span class="c1"></span>        <span class="c1">// we enter roundTrip
</span><span class="c1"></span>        <span class="c1">// 此处设置transport.reqCanceler比较难理解，主要功能是做一个标记，用于判断当前到执行pconn.roundTrip
</span><span class="c1"></span>        <span class="c1">// 期间，request有没有被(如Request.Cancel，Request.Context().Done())取消，被取消的request将无需继续roundTrip处理
</span><span class="c1"></span>		<span class="nx">t</span><span class="p">.</span><span class="nf">setReqCanceler</span><span class="p">(</span><span class="nx">treq</span><span class="p">.</span><span class="nx">cancelKey</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">)</span> <span class="p">{})</span>
		<span class="k">return</span> <span class="nx">pc</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="nx">cancelc</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">t</span><span class="p">.</span><span class="nf">setReqCanceler</span><span class="p">(</span><span class="nx">treq</span><span class="p">.</span><span class="nx">cancelKey</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span> <span class="nx">cancelc</span> <span class="o">&lt;-</span> <span class="nx">err</span> <span class="p">})</span>

	<span class="c1">// Queue for permission to dial.
</span><span class="c1"></span>	<span class="nx">t</span><span class="p">.</span><span class="nf">queueForDial</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>

	<span class="c1">// Wait for completion or cancellation.
</span><span class="c1"></span>	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">w</span><span class="p">.</span><span class="nx">ready</span><span class="p">:</span>
		<span class="c1">// Trace success but only for HTTP/1.
</span><span class="c1"></span>		<span class="c1">// HTTP/2 calls trace.GotConn itself.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">w</span><span class="p">.</span><span class="nx">pc</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">w</span><span class="p">.</span><span class="nx">pc</span><span class="p">.</span><span class="nx">alt</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">GotConn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">trace</span><span class="p">.</span><span class="nf">GotConn</span><span class="p">(</span><span class="nx">httptrace</span><span class="p">.</span><span class="nx">GotConnInfo</span><span class="p">{</span><span class="nx">Conn</span><span class="p">:</span> <span class="nx">w</span><span class="p">.</span><span class="nx">pc</span><span class="p">.</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">Reused</span><span class="p">:</span> <span class="nx">w</span><span class="p">.</span><span class="nx">pc</span><span class="p">.</span><span class="nf">isReused</span><span class="p">()})</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">w</span><span class="p">.</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// If the request has been cancelled, that&#39;s probably
</span><span class="c1"></span>			<span class="c1">// what caused w.err; if so, prefer to return the
</span><span class="c1"></span>			<span class="c1">// cancellation error (see golang.org/issue/16049).
</span><span class="c1"></span>			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">req</span><span class="p">.</span><span class="nx">Cancel</span><span class="p">:</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errRequestCanceledConn</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">().</span><span class="nf">Done</span><span class="p">():</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">().</span><span class="nf">Err</span><span class="p">()</span>
			<span class="k">case</span> <span class="nx">err</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">cancelc</span><span class="p">:</span>
				<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">errRequestCanceled</span> <span class="p">{</span>
					<span class="nx">err</span> <span class="p">=</span> <span class="nx">errRequestCanceledConn</span>
				<span class="p">}</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
			<span class="k">default</span><span class="p">:</span>
				<span class="c1">// return below
</span><span class="c1"></span>			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">w</span><span class="p">.</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">err</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">req</span><span class="p">.</span><span class="nx">Cancel</span><span class="p">:</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errRequestCanceledConn</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">().</span><span class="nf">Done</span><span class="p">():</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">().</span><span class="nf">Err</span><span class="p">()</span>
	<span class="k">case</span> <span class="nx">err</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">cancelc</span><span class="p">:</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">errRequestCanceled</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">errRequestCanceledConn</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="queueforidleconn">queueForIdleConn</h5>
<p>从连接池中找一条合适的连接</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// queueForIdleConn queues w to receive the next idle connection for w.cm.
</span><span class="c1">// As an optimization hint to the caller, queueForIdleConn reports whether
</span><span class="c1">// it successfully delivered an already-idle connection.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transport</span><span class="p">)</span> <span class="nf">queueForIdleConn</span><span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">wantConn</span><span class="p">)</span> <span class="p">(</span><span class="nx">delivered</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 可以看出当不使用长连接时，Transport不从连接池读取
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">DisableKeepAlives</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="nx">t</span><span class="p">.</span><span class="nx">idleMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">t</span><span class="p">.</span><span class="nx">idleMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="c1">// Stop closing connections that become idle - we might want one.
</span><span class="c1"></span>	<span class="c1">// (That is, undo the effect of t.CloseIdleConnections.)
</span><span class="c1"></span>	<span class="nx">t</span><span class="p">.</span><span class="nx">closeIdle</span> <span class="p">=</span> <span class="kc">false</span>

	<span class="k">if</span> <span class="nx">w</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Happens in test hook.
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// If IdleConnTimeout is set, calculate the oldest
</span><span class="c1"></span>	<span class="c1">// persistConn.idleAt time we&#39;re willing to use a cached idle
</span><span class="c1"></span>	<span class="c1">// conn.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">oldTime</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
	<span class="c1">// 如果配置了空闲超时时间，获取到连接需要检测，超时则关闭连接
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">IdleConnTimeout</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">oldTime</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="o">-</span><span class="nx">t</span><span class="p">.</span><span class="nx">IdleConnTimeout</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Look for most recently-used idle connection.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">list</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">idleConn</span><span class="p">[</span><span class="nx">w</span><span class="p">.</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">stop</span> <span class="o">:=</span> <span class="kc">false</span>
		<span class="nx">delivered</span> <span class="o">:=</span> <span class="kc">false</span>
		<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">stop</span> <span class="p">{</span>
			<span class="nx">pconn</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

			<span class="c1">// See whether this connection has been idle too long, considering
</span><span class="c1"></span>			<span class="c1">// only the wall time (the Round(0)), in case this is a laptop or VM
</span><span class="c1"></span>			<span class="c1">// coming out of suspend with previously cached idle connections.
</span><span class="c1"></span>			<span class="nx">tooOld</span> <span class="o">:=</span> <span class="p">!</span><span class="nx">oldTime</span><span class="p">.</span><span class="nf">IsZero</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">idleAt</span><span class="p">.</span><span class="nf">Round</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nf">Before</span><span class="p">(</span><span class="nx">oldTime</span><span class="p">)</span>
			<span class="c1">//超时了，关闭连接
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">tooOld</span> <span class="p">{</span>
				<span class="c1">// Async cleanup. Launch in its own goroutine (as if a
</span><span class="c1"></span>				<span class="c1">// time.AfterFunc called it); it acquires idleMu, which we&#39;re
</span><span class="c1"></span>				<span class="c1">// holding, and does a synchronous net.Conn.Close.
</span><span class="c1"></span>				<span class="k">go</span> <span class="nx">pconn</span><span class="p">.</span><span class="nf">closeConnIfStillIdle</span><span class="p">()</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">pconn</span><span class="p">.</span><span class="nf">isBroken</span><span class="p">()</span> <span class="o">||</span> <span class="nx">tooOld</span> <span class="p">{</span>
				<span class="c1">// If either persistConn.readLoop has marked the connection
</span><span class="c1"></span>				<span class="c1">// broken, but Transport.removeIdleConn has not yet removed it
</span><span class="c1"></span>				<span class="c1">// from the idle list, or if this persistConn is too old (it was
</span><span class="c1"></span>				<span class="c1">// idle too long), then ignore it and look for another. In both
</span><span class="c1"></span>				<span class="c1">// cases it&#39;s already in the process of being closed.
</span><span class="c1"></span>				<span class="nx">list</span> <span class="p">=</span> <span class="nx">list</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">//分发连接到wantConn
</span><span class="c1"></span>			<span class="nx">delivered</span> <span class="p">=</span> <span class="nx">w</span><span class="p">.</span><span class="nf">tryDeliver</span><span class="p">(</span><span class="nx">pconn</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">delivered</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">alt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="c1">// HTTP/2: multiple clients can share pconn.
</span><span class="c1"></span>					<span class="c1">// Leave it in the list.
</span><span class="c1"></span>				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="c1">// HTTP/1: only one client can use pconn.
</span><span class="c1"></span>					<span class="c1">// Remove it from the list.
</span><span class="c1"></span>					<span class="nx">t</span><span class="p">.</span><span class="nx">idleLRU</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">pconn</span><span class="p">)</span>
					<span class="nx">list</span> <span class="p">=</span> <span class="nx">list</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="nx">stop</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nx">idleConn</span><span class="p">[</span><span class="nx">w</span><span class="p">.</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">list</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nb">delete</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">idleConn</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">stop</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">delivered</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Register to receive next connection that becomes idle.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">idleConnWait</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">idleConnWait</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">connectMethodKey</span><span class="p">]</span><span class="nx">wantConnQueue</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">q</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">idleConnWait</span><span class="p">[</span><span class="nx">w</span><span class="p">.</span><span class="nx">key</span><span class="p">]</span>
	<span class="nx">q</span><span class="p">.</span><span class="nf">cleanFront</span><span class="p">()</span>
	<span class="nx">q</span><span class="p">.</span><span class="nf">pushBack</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">idleConnWait</span><span class="p">[</span><span class="nx">w</span><span class="p">.</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">q</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="queuefordial">queueForDial</h5>
<p>当我们调用 net/http.Transport.queueForDial 尝试与远程建立连接时，标准库会在内部启动新的 Goroutine 执行 net/http.Transport.dialConnFor 用于建连，从最终调用的 net/http.Transport.dialConn 中我们能找到 TCP 连接和 net 库的身影：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// queueForDial queues w to wait for permission to begin dialing.
</span><span class="c1">// Once w receives permission to dial, it will do so in a separate goroutine.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transport</span><span class="p">)</span> <span class="nf">queueForDial</span><span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">wantConn</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">beforeDial</span><span class="p">()</span>
	<span class="c1">//如果没有限制最大连接数，直接建立连接
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">MaxConnsPerHost</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">go</span> <span class="nx">t</span><span class="p">.</span><span class="nf">dialConnFor</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">t</span><span class="p">.</span><span class="nx">connsPerHostMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">t</span><span class="p">.</span><span class="nx">connsPerHostMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="c1">//如果没超过连接数限制，直接建立连接
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">connsPerHost</span><span class="p">[</span><span class="nx">w</span><span class="p">.</span><span class="nx">key</span><span class="p">];</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">MaxConnsPerHost</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">connsPerHost</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nx">connsPerHost</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">connectMethodKey</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">connsPerHost</span><span class="p">[</span><span class="nx">w</span><span class="p">.</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="k">go</span> <span class="nx">t</span><span class="p">.</span><span class="nf">dialConnFor</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">connsPerHostWait</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">connsPerHostWait</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">connectMethodKey</span><span class="p">]</span><span class="nx">wantConnQueue</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">//排队等待连接建立
</span><span class="c1"></span>	<span class="nx">q</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">connsPerHostWait</span><span class="p">[</span><span class="nx">w</span><span class="p">.</span><span class="nx">key</span><span class="p">]</span>
	<span class="nx">q</span><span class="p">.</span><span class="nf">cleanFront</span><span class="p">()</span>
	<span class="nx">q</span><span class="p">.</span><span class="nf">pushBack</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">connsPerHostWait</span><span class="p">[</span><span class="nx">w</span><span class="p">.</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">q</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// dialConnFor dials on behalf of w and delivers the result to w.
</span><span class="c1">// dialConnFor has received permission to dial w.cm and is counted in t.connCount[w.cm.key()].
</span><span class="c1">// If the dial is cancelled or unsuccessful, dialConnFor decrements t.connCount[w.cm.key()].
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transport</span><span class="p">)</span> <span class="nf">dialConnFor</span><span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">wantConn</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">w</span><span class="p">.</span><span class="nf">afterDial</span><span class="p">()</span>

	<span class="nx">pc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">dialConn</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">cm</span><span class="p">)</span>
	<span class="nx">delivered</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nf">tryDeliver</span><span class="p">(</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="p">(!</span><span class="nx">delivered</span> <span class="o">||</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">alt</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// pconn was not passed to w,
</span><span class="c1"></span>		<span class="c1">// or it is HTTP/2 and can be shared.
</span><span class="c1"></span>		<span class="c1">// Add to the idle connection pool.
</span><span class="c1"></span>		<span class="nx">t</span><span class="p">.</span><span class="nf">putOrCloseIdleConn</span><span class="p">(</span><span class="nx">pc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">decConnsPerHost</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transport</span><span class="p">)</span> <span class="nf">dialConn</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">cm</span> <span class="nx">connectMethod</span><span class="p">)</span> <span class="p">(</span><span class="nx">pconn</span> <span class="o">*</span><span class="nx">persistConn</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">pconn</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">persistConn</span><span class="p">{</span>
		<span class="nx">t</span><span class="p">:</span>             <span class="nx">t</span><span class="p">,</span>
		<span class="nx">cacheKey</span><span class="p">:</span>      <span class="nx">cm</span><span class="p">.</span><span class="nf">key</span><span class="p">(),</span>
		<span class="nx">reqch</span><span class="p">:</span>         <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">requestAndChan</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="nx">writech</span><span class="p">:</span>       <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">writeRequest</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="nx">closech</span><span class="p">:</span>       <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
		<span class="nx">writeErrCh</span><span class="p">:</span>    <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="nx">writeLoopDone</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
	<span class="p">}</span>
	<span class="nx">trace</span> <span class="o">:=</span> <span class="nx">httptrace</span><span class="p">.</span><span class="nf">ContextClientTrace</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
	<span class="nx">wrapErr</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">cm</span><span class="p">.</span><span class="nx">proxyURL</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// Return a typed error, per Issue 16997
</span><span class="c1"></span>			<span class="k">return</span> <span class="o">&amp;</span><span class="nx">net</span><span class="p">.</span><span class="nx">OpError</span><span class="p">{</span><span class="nx">Op</span><span class="p">:</span> <span class="s">&#34;proxyconnect&#34;</span><span class="p">,</span> <span class="nx">Net</span><span class="p">:</span> <span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">Err</span><span class="p">:</span> <span class="nx">err</span><span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="c1">// 调用注册的DialTLS处理tls。使用自注册的TLS处理函数时，transport的TLSClientConfig和TLSHandshakeTimeout
</span><span class="c1"></span>    <span class="c1">// 参数会被忽略
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">cm</span><span class="p">.</span><span class="nf">scheme</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#34;https&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasCustomTLSDialer</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
        <span class="c1">// 调用注册的连接函数创建一条连接，注意cm.addr()的实现，如果该连接存在proxy，则此处是与proxy建立TLS连接；否则直接连server。
</span><span class="c1"></span>        <span class="c1">// 存在proxy时，与server建立连接分为2步：与proxy建立TLP(TLS)连接；与server建立HTTP(HTTPS)连接
</span><span class="c1"></span>		<span class="nx">pconn</span><span class="p">.</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">customDialTLS</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">cm</span><span class="p">.</span><span class="nf">addr</span><span class="p">())</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">wrapErr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">// 如果连接类型是TLS的，则需要处理TLS协商
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">tc</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">conn</span><span class="p">.(</span><span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Conn</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="c1">// Handshake here, in case DialTLS didn&#39;t. TLSNextProto below
</span><span class="c1"></span>			<span class="c1">// depends on it for knowing the connection state.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">TLSHandshakeStart</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">trace</span><span class="p">.</span><span class="nf">TLSHandshakeStart</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="c1">// 启动TLS协商，如果协商失败需要关闭连接
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tc</span><span class="p">.</span><span class="nf">Handshake</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">go</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
				<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">TLSHandshakeDone</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">trace</span><span class="p">.</span><span class="nf">TLSHandshakeDone</span><span class="p">(</span><span class="nx">tls</span><span class="p">.</span><span class="nx">ConnectionState</span><span class="p">{},</span> <span class="nx">err</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
			<span class="p">}</span>
			<span class="nx">cs</span> <span class="o">:=</span> <span class="nx">tc</span><span class="p">.</span><span class="nf">ConnectionState</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">TLSHandshakeDone</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">trace</span><span class="p">.</span><span class="nf">TLSHandshakeDone</span><span class="p">(</span><span class="nx">cs</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="c1">// 保存TLS协商结果
</span><span class="c1"></span>			<span class="nx">pconn</span><span class="p">.</span><span class="nx">tlsState</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">cs</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 使用默认方式创建连接,此时会用到transport的TLSClientConfig和TLSHandshakeTimeout参数。同样注意cm.addr()
</span><span class="c1"></span>		<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">dial</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">cm</span><span class="p">.</span><span class="nf">addr</span><span class="p">())</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">wrapErr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
        <span class="nx">pconn</span><span class="p">.</span><span class="nx">conn</span> <span class="p">=</span> <span class="nx">conn</span>
        <span class="c1">// 如果scheme是需要TLS协商的，则处理TLS协商，否则为普通的HTTP连接
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">cm</span><span class="p">.</span><span class="nf">scheme</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#34;https&#34;</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="nx">firstTLSHost</span> <span class="kt">string</span>
			<span class="k">if</span> <span class="nx">firstTLSHost</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">SplitHostPort</span><span class="p">(</span><span class="nx">cm</span><span class="p">.</span><span class="nf">addr</span><span class="p">());</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">wrapErr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="c1">// 进行TLS协商，具体参见下文addTLS
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">pconn</span><span class="p">.</span><span class="nf">addTLS</span><span class="p">(</span><span class="nx">firstTLSHost</span><span class="p">,</span> <span class="nx">trace</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">wrapErr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

    <span class="c1">// Proxy setup.
</span><span class="c1"></span>    <span class="c1">// 处理proxy的情况
</span><span class="c1"></span>	<span class="k">switch</span> <span class="p">{</span>
    <span class="c1">// 不存在proxy 直接跳过
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">cm</span><span class="p">.</span><span class="nx">proxyURL</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">:</span>
		<span class="c1">// Do nothing. Not using a proxy.
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">cm</span><span class="p">.</span><span class="nx">proxyURL</span><span class="p">.</span><span class="nx">Scheme</span> <span class="o">==</span> <span class="s">&#34;socks5&#34;</span><span class="p">:</span>
		<span class="nx">conn</span> <span class="o">:=</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">conn</span>
		<span class="nx">d</span> <span class="o">:=</span> <span class="nf">socksNewDialer</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">RemoteAddr</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
		<span class="k">if</span> <span class="nx">u</span> <span class="o">:=</span> <span class="nx">cm</span><span class="p">.</span><span class="nx">proxyURL</span><span class="p">.</span><span class="nx">User</span><span class="p">;</span> <span class="nx">u</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">auth</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">socksUsernamePassword</span><span class="p">{</span>
				<span class="nx">Username</span><span class="p">:</span> <span class="nx">u</span><span class="p">.</span><span class="nf">Username</span><span class="p">(),</span>
			<span class="p">}</span>
			<span class="nx">auth</span><span class="p">.</span><span class="nx">Password</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">u</span><span class="p">.</span><span class="nf">Password</span><span class="p">()</span>
			<span class="nx">d</span><span class="p">.</span><span class="nx">AuthMethods</span> <span class="p">=</span> <span class="p">[]</span><span class="nx">socksAuthMethod</span><span class="p">{</span>
				<span class="nx">socksAuthMethodNotRequired</span><span class="p">,</span>
				<span class="nx">socksAuthMethodUsernamePassword</span><span class="p">,</span>
			<span class="p">}</span>
			<span class="nx">d</span><span class="p">.</span><span class="nx">Authenticate</span> <span class="p">=</span> <span class="nx">auth</span><span class="p">.</span><span class="nx">Authenticate</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">DialWithConn</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">conn</span><span class="p">,</span> <span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">cm</span><span class="p">.</span><span class="nx">targetAddr</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
        <span class="p">}</span>
    <span class="c1">// 如果存在proxy，且server的scheme为&#34;http&#34;，如果需要代理认证，则设置认证信息
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">cm</span><span class="p">.</span><span class="nx">targetScheme</span> <span class="o">==</span> <span class="s">&#34;http&#34;</span><span class="p">:</span>
		<span class="nx">pconn</span><span class="p">.</span><span class="nx">isProxy</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="k">if</span> <span class="nx">pa</span> <span class="o">:=</span> <span class="nx">cm</span><span class="p">.</span><span class="nf">proxyAuth</span><span class="p">();</span> <span class="nx">pa</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="nx">pconn</span><span class="p">.</span><span class="nx">mutateHeaderFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">h</span> <span class="nx">Header</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">h</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Proxy-Authorization&#34;</span><span class="p">,</span> <span class="nx">pa</span><span class="p">)</span>
			<span class="p">}</span>
        <span class="p">}</span>
    <span class="c1">// 如果存在proxy，且server的scheme为&#34;https&#34;。与&#34;http&#34;不同，在与server进行tls协商前，会给proxy
</span><span class="c1"></span>   <span class="c1">// 发送一个method为&#34;CONNECT&#34;的HTTP请求,如果请求通过(返回200),则可以继续与server进行TLS协商
</span><span class="c1"></span>    <span class="k">case</span> <span class="nx">cm</span><span class="p">.</span><span class="nx">targetScheme</span> <span class="o">==</span> <span class="s">&#34;https&#34;</span><span class="p">:</span>
        <span class="c1">// 该conn表示与proxy建立的连接
</span><span class="c1"></span>		<span class="nx">conn</span> <span class="o">:=</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">conn</span>
		<span class="nx">hdr</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">ProxyConnectHeader</span>
		<span class="k">if</span> <span class="nx">hdr</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">hdr</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">Header</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">pa</span> <span class="o">:=</span> <span class="nx">cm</span><span class="p">.</span><span class="nf">proxyAuth</span><span class="p">();</span> <span class="nx">pa</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="nx">hdr</span> <span class="p">=</span> <span class="nx">hdr</span><span class="p">.</span><span class="nf">Clone</span><span class="p">()</span>
			<span class="nx">hdr</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Proxy-Authorization&#34;</span><span class="p">,</span> <span class="nx">pa</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">connectReq</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Request</span><span class="p">{</span>
			<span class="nx">Method</span><span class="p">:</span> <span class="s">&#34;CONNECT&#34;</span><span class="p">,</span>
			<span class="nx">URL</span><span class="p">:</span>    <span class="o">&amp;</span><span class="nx">url</span><span class="p">.</span><span class="nx">URL</span><span class="p">{</span><span class="nx">Opaque</span><span class="p">:</span> <span class="nx">cm</span><span class="p">.</span><span class="nx">targetAddr</span><span class="p">},</span>
			<span class="nx">Host</span><span class="p">:</span>   <span class="nx">cm</span><span class="p">.</span><span class="nx">targetAddr</span><span class="p">,</span>
			<span class="nx">Header</span><span class="p">:</span> <span class="nx">hdr</span><span class="p">,</span>
		<span class="p">}</span>

		<span class="c1">// If there&#39;s no done channel (no deadline or cancellation
</span><span class="c1"></span>		<span class="c1">// from the caller possible), at least set some (long)
</span><span class="c1"></span>		<span class="c1">// timeout here. This will make sure we don&#39;t block forever
</span><span class="c1"></span>		<span class="c1">// and leak a goroutine if the connection stops replying
</span><span class="c1"></span>		<span class="c1">// after the TCP connect.
</span><span class="c1"></span>		<span class="nx">connectCtx</span> <span class="o">:=</span> <span class="nx">ctx</span>
		<span class="k">if</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">newCtx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span><span class="p">)</span>
			<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
			<span class="nx">connectCtx</span> <span class="p">=</span> <span class="nx">newCtx</span>
		<span class="p">}</span>

		<span class="nx">didReadResponse</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span> <span class="c1">// closed after CONNECT write+read is done or fails
</span><span class="c1"></span>		<span class="kd">var</span> <span class="p">(</span>
			<span class="nx">resp</span> <span class="o">*</span><span class="nx">Response</span>
			<span class="nx">err</span>  <span class="kt">error</span> <span class="c1">// write or read error
</span><span class="c1"></span>		<span class="p">)</span>
		<span class="c1">// Write the CONNECT request &amp; read the response.
</span><span class="c1"></span>		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">didReadResponse</span><span class="p">)</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">connectReq</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="c1">// Okay to use and discard buffered reader here, because
</span><span class="c1"></span>			<span class="c1">// TLS server will not speak until spoken to.
</span><span class="c1"></span>			<span class="nx">br</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
			<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">ReadResponse</span><span class="p">(</span><span class="nx">br</span><span class="p">,</span> <span class="nx">connectReq</span><span class="p">)</span>
		<span class="p">}()</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">connectCtx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
			<span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="o">&lt;-</span><span class="nx">didReadResponse</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">connectCtx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">didReadResponse</span><span class="p">:</span>
			<span class="c1">// resp or err now set
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
        <span class="p">}</span>
        <span class="c1">// proxy返回非200，表示无法建立连接，可能情况如proxy认证失败
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">!=</span> <span class="mi">200</span> <span class="p">{</span>
			<span class="nx">f</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">SplitN</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Status</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
			<span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;unknown status code&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">f</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="c1">// 与proxy建立连接后，再与server进行TLS协商
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">cm</span><span class="p">.</span><span class="nx">proxyURL</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">cm</span><span class="p">.</span><span class="nx">targetScheme</span> <span class="o">==</span> <span class="s">&#34;https&#34;</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">pconn</span><span class="p">.</span><span class="nf">addTLS</span><span class="p">(</span><span class="nx">cm</span><span class="p">.</span><span class="nf">tlsHost</span><span class="p">(),</span> <span class="nx">trace</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="c1">// 后续进行TLS之上的协议处理,如果TLS之上的协议为注册协议，则使用注册的roundTrip进行处理
</span><span class="c1"></span>    <span class="c1">// TLS之上的协议为TLS协商过程中使用NPN/ALPN扩展协商出的协议，如HTTP2(参见golang.org/x/net/http2)
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">s</span> <span class="o">:=</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">tlsState</span><span class="p">;</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">NegotiatedProtocolIsMutual</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">NegotiatedProtocol</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">next</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">TLSNextProto</span><span class="p">[</span><span class="nx">s</span><span class="p">.</span><span class="nx">NegotiatedProtocol</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">alt</span> <span class="o">:=</span> <span class="nf">next</span><span class="p">(</span><span class="nx">cm</span><span class="p">.</span><span class="nx">targetAddr</span><span class="p">,</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">conn</span><span class="p">.(</span><span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Conn</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">alt</span><span class="p">.(</span><span class="nx">http2erringRoundTripper</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="c1">// pconn.conn was closed by next (http2configureTransport.upgradeFn).
</span><span class="c1"></span>				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">err</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="nx">persistConn</span><span class="p">{</span><span class="nx">t</span><span class="p">:</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">cacheKey</span><span class="p">:</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">cacheKey</span><span class="p">,</span> <span class="nx">alt</span><span class="p">:</span> <span class="nx">alt</span><span class="p">},</span> <span class="kc">nil</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">pconn</span><span class="p">.</span><span class="nx">br</span> <span class="p">=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewReaderSize</span><span class="p">(</span><span class="nx">pconn</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nf">readBufferSize</span><span class="p">())</span>
	<span class="nx">pconn</span><span class="p">.</span><span class="nx">bw</span> <span class="p">=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewWriterSize</span><span class="p">(</span><span class="nx">persistConnWriter</span><span class="p">{</span><span class="nx">pconn</span><span class="p">},</span> <span class="nx">t</span><span class="p">.</span><span class="nf">writeBufferSize</span><span class="p">())</span>
    <span class="c1">// 创建读写通道，writeLoop用于发送request，readLoop用于接收响应。roundTrip函数中会通过chan给writeLoop发送
</span><span class="c1"></span>    <span class="c1">// request，通过chan从readLoop接口response。每个连接都有一个readLoop和writeLoop，连接关闭后，这2个Loop也会退出。
</span><span class="c1"></span>    <span class="c1">// pconn.br给readLoop使用，pconn.bw给writeLoop使用，注意此时已经建立了tcp连接。
</span><span class="c1"></span>	<span class="k">go</span> <span class="nx">pconn</span><span class="p">.</span><span class="nf">readLoop</span><span class="p">()</span>
	<span class="k">go</span> <span class="nx">pconn</span><span class="p">.</span><span class="nf">writeLoop</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">pconn</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在创建新的 TCP 连接后，我们还会在后台为当前的连接创建两个 Goroutine，分别从 TCP 连接中读取数据或者向 TCP 连接写入数据，从建立连接的过程我们可以发现，如果我们为每一个 HTTP 请求都创建新的连接并启动 Goroutine 处理读写数据，会占用很多的资源。</p>
<h5 id="addtls">addTLS</h5>
<p>addTLS用于进行非注册协议下的TLS协商</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Add TLS to a persistent connection, i.e. negotiate a TLS session. If pconn is already a TLS
</span><span class="c1">// tunnel, this function establishes a nested TLS session inside the encrypted channel.
</span><span class="c1">// The remote endpoint&#39;s name may be overridden by TLSClientConfig.ServerName.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">pconn</span> <span class="o">*</span><span class="nx">persistConn</span><span class="p">)</span> <span class="nf">addTLS</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">trace</span> <span class="o">*</span><span class="nx">httptrace</span><span class="p">.</span><span class="nx">ClientTrace</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">// Initiate TLS and check remote host name against certificate.
</span><span class="c1"></span>	<span class="nx">cfg</span> <span class="o">:=</span> <span class="nf">cloneTLSConfig</span><span class="p">(</span><span class="nx">pconn</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nx">TLSClientConfig</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">cfg</span><span class="p">.</span><span class="nx">ServerName</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">cfg</span><span class="p">.</span><span class="nx">ServerName</span> <span class="p">=</span> <span class="nx">name</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">cacheKey</span><span class="p">.</span><span class="nx">onlyH1</span> <span class="p">{</span>
		<span class="nx">cfg</span><span class="p">.</span><span class="nx">NextProtos</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">plainConn</span> <span class="o">:=</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">conn</span>
	<span class="c1">// 配置TLS client，包含一个TCP连接和TLC配置
</span><span class="c1"></span>	<span class="nx">tlsConn</span> <span class="o">:=</span> <span class="nx">tls</span><span class="p">.</span><span class="nf">Client</span><span class="p">(</span><span class="nx">plainConn</span><span class="p">,</span> <span class="nx">cfg</span><span class="p">)</span>
	<span class="nx">errc</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">timer</span> <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Timer</span> <span class="c1">// for canceling TLS handshake
</span><span class="c1"></span>	<span class="c1">// 设置TLS超时时间，并在超时后往errc中写入一个tlsHandshakeTimeoutError{}
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">d</span> <span class="o">:=</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nx">TLSHandshakeTimeout</span><span class="p">;</span> <span class="nx">d</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">timer</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">AfterFunc</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">errc</span> <span class="o">&lt;-</span> <span class="nx">tlsHandshakeTimeoutError</span><span class="p">{}</span>
		<span class="p">})</span>
	<span class="p">}</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">TLSHandshakeStart</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">trace</span><span class="p">.</span><span class="nf">TLSHandshakeStart</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="c1">// 执行TLS协商，如果协商没有超时，则将协商结果err放入errc中
</span><span class="c1"></span>		<span class="nx">err</span> <span class="o">:=</span> <span class="nx">tlsConn</span><span class="p">.</span><span class="nf">Handshake</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">timer</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nx">errc</span> <span class="o">&lt;-</span> <span class="nx">err</span>
	<span class="p">}()</span>
	<span class="c1">// 阻塞等待TLS协商结果，如果协商失败或协商超时，关闭底层连接
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">errc</span><span class="p">;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">plainConn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">TLSHandshakeDone</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">trace</span><span class="p">.</span><span class="nf">TLSHandshakeDone</span><span class="p">(</span><span class="nx">tls</span><span class="p">.</span><span class="nx">ConnectionState</span><span class="p">{},</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="c1">// 获取协商结果并设置到pconn.tlsState
</span><span class="c1"></span>	<span class="nx">cs</span> <span class="o">:=</span> <span class="nx">tlsConn</span><span class="p">.</span><span class="nf">ConnectionState</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">TLSHandshakeDone</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">trace</span><span class="p">.</span><span class="nf">TLSHandshakeDone</span><span class="p">(</span><span class="nx">cs</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">pconn</span><span class="p">.</span><span class="nx">tlsState</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">cs</span>
	<span class="nx">pconn</span><span class="p">.</span><span class="nx">conn</span> <span class="p">=</span> <span class="nx">tlsConn</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="wantconn">wantConn</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A wantConn records state about a wanted connection
</span><span class="c1">// (that is, an active call to getConn).
</span><span class="c1">// The conn may be gotten by dialing or by finding an idle connection,
</span><span class="c1">// or a cancellation may make the conn no longer wanted.
</span><span class="c1">// These three options are racing against each other and use
</span><span class="c1">// wantConn to coordinate and agree about the winning outcome.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">wantConn</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">cm</span>    <span class="nx">connectMethod</span>
	<span class="nx">key</span>   <span class="nx">connectMethodKey</span> <span class="c1">// cm.key()
</span><span class="c1"></span>	<span class="nx">ctx</span>   <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span>  <span class="c1">// context for dial
</span><span class="c1"></span>	<span class="nx">ready</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>    <span class="c1">// closed when pc, err pair is delivered
</span><span class="c1"></span>
	<span class="c1">// hooks for testing to know when dials are done
</span><span class="c1"></span>	<span class="c1">// beforeDial is called in the getConn goroutine when the dial is queued.
</span><span class="c1"></span>	<span class="c1">// afterDial is called when the dial is completed or cancelled.
</span><span class="c1"></span>	<span class="nx">beforeDial</span> <span class="kd">func</span><span class="p">()</span>
	<span class="nx">afterDial</span>  <span class="kd">func</span><span class="p">()</span>

	<span class="nx">mu</span>  <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// protects pc, err, close(ready)
</span><span class="c1"></span>	<span class="nx">pc</span>  <span class="o">*</span><span class="nx">persistConn</span>
	<span class="nx">err</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="trydeliver">tryDeliver</h5>
<p>连接建立完成后，同样会调用tryDeliver分发连接到wantConn，同时关闭通道w.ready，这样主协程就解除阻塞了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// tryDeliver attempts to deliver pc, err to w and reports whether it succeeded.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">wantConn</span><span class="p">)</span> <span class="nf">tryDeliver</span><span class="p">(</span><span class="nx">pc</span> <span class="o">*</span><span class="nx">persistConn</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">w</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">w</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">w</span><span class="p">.</span><span class="nx">pc</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">w</span><span class="p">.</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="nx">w</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nx">pc</span>
	<span class="nx">w</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">err</span>
	<span class="k">if</span> <span class="nx">w</span><span class="p">.</span><span class="nx">pc</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">w</span><span class="p">.</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;net/http: internal error: misuse of tryDeliver&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">ready</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="wantconnqueue">wantConnQueue</h4>
<p>Golang在实现队列时，使用了两个切片head和tail；head切片用于出队操作，tail切片用于入队操作；出队时，如果head切片为空，则交换head与tail。通过这种方式，Golang实现了底层数组空间的复用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A wantConnQueue is a queue of wantConns.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">wantConnQueue</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// This is a queue, not a deque.
</span><span class="c1"></span>	<span class="c1">// It is split into two stages - head[headPos:] and tail.
</span><span class="c1"></span>	<span class="c1">// popFront is trivial (headPos++) on the first stage, and
</span><span class="c1"></span>	<span class="c1">// pushBack is trivial (append) on the second stage.
</span><span class="c1"></span>	<span class="c1">// If the first stage is empty, popFront can swap the
</span><span class="c1"></span>	<span class="c1">// first and second stages to remedy the situation.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This two-stage split is analogous to the use of two lists
</span><span class="c1"></span>	<span class="c1">// in Okasaki&#39;s purely functional queue but without the
</span><span class="c1"></span>	<span class="c1">// overhead of reversing the list when swapping stages.
</span><span class="c1"></span>	<span class="nx">head</span>    <span class="p">[]</span><span class="o">*</span><span class="nx">wantConn</span>
	<span class="nx">headPos</span> <span class="kt">int</span>
	<span class="nx">tail</span>    <span class="p">[]</span><span class="o">*</span><span class="nx">wantConn</span>
<span class="p">}</span>

<span class="c1">// len returns the number of items in the queue.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">wantConnQueue</span><span class="p">)</span> <span class="nb">len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">head</span><span class="p">)</span> <span class="o">-</span> <span class="nx">q</span><span class="p">.</span><span class="nx">headPos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">tail</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// pushBack adds w to the back of the queue.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">wantConnQueue</span><span class="p">)</span> <span class="nf">pushBack</span><span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">wantConn</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">q</span><span class="p">.</span><span class="nx">tail</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">tail</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// popFront removes and returns the wantConn at the front of the queue.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">wantConnQueue</span><span class="p">)</span> <span class="nf">popFront</span><span class="p">()</span> <span class="o">*</span><span class="nx">wantConn</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">q</span><span class="p">.</span><span class="nx">headPos</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">tail</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="c1">// Pick up tail as new head, clear tail.
</span><span class="c1"></span>		<span class="nx">q</span><span class="p">.</span><span class="nx">head</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">headPos</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">tail</span> <span class="p">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">tail</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">head</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nx">w</span> <span class="o">:=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">head</span><span class="p">[</span><span class="nx">q</span><span class="p">.</span><span class="nx">headPos</span><span class="p">]</span>
	<span class="nx">q</span><span class="p">.</span><span class="nx">head</span><span class="p">[</span><span class="nx">q</span><span class="p">.</span><span class="nx">headPos</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">q</span><span class="p">.</span><span class="nx">headPos</span><span class="o">++</span>
	<span class="k">return</span> <span class="nx">w</span>
<span class="p">}</span>

<span class="c1">// peekFront returns the wantConn at the front of the queue without removing it.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">wantConnQueue</span><span class="p">)</span> <span class="nf">peekFront</span><span class="p">()</span> <span class="o">*</span><span class="nx">wantConn</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">q</span><span class="p">.</span><span class="nx">headPos</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">q</span><span class="p">.</span><span class="nx">head</span><span class="p">[</span><span class="nx">q</span><span class="p">.</span><span class="nx">headPos</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">tail</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">q</span><span class="p">.</span><span class="nx">tail</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// cleanFront pops any wantConns that are no longer waiting from the head of the
</span><span class="c1">// queue, reporting whether any were popped.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">wantConnQueue</span><span class="p">)</span> <span class="nf">cleanFront</span><span class="p">()</span> <span class="p">(</span><span class="nx">cleaned</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">w</span> <span class="o">:=</span> <span class="nx">q</span><span class="p">.</span><span class="nf">peekFront</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">w</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">w</span><span class="p">.</span><span class="nf">waiting</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">cleaned</span>
		<span class="p">}</span>
		<span class="nx">q</span><span class="p">.</span><span class="nf">popFront</span><span class="p">()</span>
		<span class="nx">cleaned</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="roundtrip-1">roundTrip</h4>
<p>持久的 TCP 连接会实现 net/http.persistConn.roundTrip 处理写入 HTTP 请求并在 select 语句中等待响应的返回：</p>
<p>在获取到底层TCP(TLS)连接后在roundTrip中处理上层协议：即发送HTTP request，返回HTTP response。roundTrip给writeLoop提供request，从readLoop获取response。</p>
<p>一个roundTrip用于处理一类request。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">pc</span> <span class="o">*</span><span class="nx">persistConn</span><span class="p">)</span> <span class="nf">roundTrip</span><span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">transportRequest</span><span class="p">)</span> <span class="p">(</span><span class="nx">resp</span> <span class="o">*</span><span class="nx">Response</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">testHookEnterRoundTrip</span><span class="p">()</span>
	<span class="c1">// 此处与getConn中的&#34;t.setReqCanceler(req, func(error) {})&#34;相对应，用于判断request是否被取消
</span><span class="c1"></span>    <span class="c1">// 返回false表示request被取消，不必继续后续请求，关闭连接并返回错误
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">replaceReqCanceler</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">cancelKey</span><span class="p">,</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">cancelRequest</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">putOrCloseIdleConn</span><span class="p">(</span><span class="nx">pc</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errRequestCanceled</span>
	<span class="p">}</span>
	<span class="nx">pc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="c1">// 与readLoop配合使用,表示期望的响应的个数
</span><span class="c1"></span>	<span class="nx">pc</span><span class="p">.</span><span class="nx">numExpectedResponses</span><span class="o">++</span>
	<span class="c1">// dialConn中定义的函数，设置了proxy的认证信息
</span><span class="c1"></span>	<span class="nx">headerFn</span> <span class="o">:=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">mutateHeaderFunc</span>
	<span class="nx">pc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">headerFn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">headerFn</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nf">extraHeaders</span><span class="p">())</span>
	<span class="p">}</span>

	<span class="c1">// Ask for a compressed version if the caller didn&#39;t set their
</span><span class="c1"></span>	<span class="c1">// own value for Accept-Encoding. We only attempt to
</span><span class="c1"></span>	<span class="c1">// uncompress the gzip stream if we were the layer that
</span><span class="c1"></span>	<span class="c1">// requested it.
</span><span class="c1"></span>	<span class="nx">requestedGzip</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="c1">// 如果需要在request中设置可接受的解码方法，则在request中添加对应的首部。仅支持gzip方式且
</span><span class="c1"></span>    <span class="c1">// 仅在调用者没有设置这些首部时设置
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nx">DisableCompression</span> <span class="o">&amp;&amp;</span>
		<span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;Accept-Encoding&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="o">&amp;&amp;</span>
		<span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;Range&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="o">&amp;&amp;</span>
		<span class="nx">req</span><span class="p">.</span><span class="nx">Method</span> <span class="o">!=</span> <span class="s">&#34;HEAD&#34;</span> <span class="p">{</span>
		<span class="c1">// Request gzip only, not deflate. Deflate is ambiguous and
</span><span class="c1"></span>		<span class="c1">// not as universally supported anyway.
</span><span class="c1"></span>		<span class="c1">// See: https://zlib.net/zlib_faq.html#faq39
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// Note that we don&#39;t request this for HEAD requests,
</span><span class="c1"></span>		<span class="c1">// due to a bug in nginx:
</span><span class="c1"></span>		<span class="c1">//   https://trac.nginx.org/nginx/ticket/358
</span><span class="c1"></span>		<span class="c1">//   https://golang.org/issue/5522
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// We don&#39;t request gzip if the request is for a range, since
</span><span class="c1"></span>		<span class="c1">// auto-decoding a portion of a gzipped document will just fail
</span><span class="c1"></span>		<span class="c1">// anyway. See https://golang.org/issue/8923
</span><span class="c1"></span>		<span class="nx">requestedGzip</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">extraHeaders</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Accept-Encoding&#34;</span><span class="p">,</span> <span class="s">&#34;gzip&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 用于处理首部含&#34;Expect: 100-continue&#34;的request，客户端使用该首部探测服务器是否能够
</span><span class="c1"></span>    <span class="c1">// 处理request首部中的规格要求(如长度过大的request)。
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">continueCh</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nf">ProtoAtLeast</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Body</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">req</span><span class="p">.</span><span class="nf">expectsContinue</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">continueCh</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// HTTP1.1默认使用长连接，当transport设置DisableKeepAlives时会导致处理每个request时都会
</span><span class="c1"></span>    <span class="c1">// 新建一个连接。此处的处理逻辑是：如果transport设置了DisableKeepAlives，而request没有设置
</span><span class="c1"></span>    <span class="c1">// &#34;Connection: close&#34;,则为request设置该首部。将底层表现与上层协议保持一致。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nx">DisableKeepAlives</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">req</span><span class="p">.</span><span class="nf">wantsClose</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">extraHeaders</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Connection&#34;</span><span class="p">,</span> <span class="s">&#34;close&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 用于在异常场景(如request取消)下通知readLoop，roundTrip是否已经退出，防止ReadLoop发送response阻塞
</span><span class="c1"></span>	<span class="nx">gone</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">gone</span><span class="p">)</span>

	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">setReqCanceler</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">cancelKey</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="kd">const</span> <span class="nx">debugRoundTrip</span> <span class="p">=</span> <span class="kc">false</span>

	<span class="c1">// Write the request concurrently with waiting for a response,
</span><span class="c1"></span>	<span class="c1">// in case the server decides to reply before reading our full
</span><span class="c1"></span>	<span class="c1">// request body.
</span><span class="c1"></span>    <span class="c1">// 表示发送了多少个字节的request，debug使用
</span><span class="c1"></span>	<span class="nx">startBytesWritten</span> <span class="o">:=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">nwrite</span>
	<span class="c1">// 给writeLoop封装并发送信息，注意此处的先后顺序。首先给writeLoop发送数据，阻塞等待writeLoop
</span><span class="c1"></span>    <span class="c1">// 接收，待writeLoop接收后才能发送数据给readLoop,因此发送request总会优先接收response
</span><span class="c1"></span>	<span class="nx">writeErrCh</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">pc</span><span class="p">.</span><span class="nx">writech</span> <span class="o">&lt;-</span> <span class="nx">writeRequest</span><span class="p">{</span><span class="nx">req</span><span class="p">,</span> <span class="nx">writeErrCh</span><span class="p">,</span> <span class="nx">continueCh</span><span class="p">}</span>
	<span class="c1">// 给readLoop封装并发送信息
</span><span class="c1"></span>	<span class="nx">resc</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">responseAndError</span><span class="p">)</span>
	<span class="nx">pc</span><span class="p">.</span><span class="nx">reqch</span> <span class="o">&lt;-</span> <span class="nx">requestAndChan</span><span class="p">{</span>
		<span class="nx">req</span><span class="p">:</span>        <span class="nx">req</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span>
		<span class="nx">cancelKey</span><span class="p">:</span>  <span class="nx">req</span><span class="p">.</span><span class="nx">cancelKey</span><span class="p">,</span>
		<span class="nx">ch</span><span class="p">:</span>         <span class="nx">resc</span><span class="p">,</span>
		<span class="nx">addedGzip</span><span class="p">:</span>  <span class="nx">requestedGzip</span><span class="p">,</span>
		<span class="nx">continueCh</span><span class="p">:</span> <span class="nx">continueCh</span><span class="p">,</span>
		<span class="nx">callerGone</span><span class="p">:</span> <span class="nx">gone</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">respHeaderTimer</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
	<span class="nx">cancelChan</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Cancel</span>
	<span class="nx">ctxDoneChan</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">().</span><span class="nf">Done</span><span class="p">()</span>
	<span class="c1">// 该循环主要用于处理获取response超时和request取消时的条件跳转。正常情况下收到reponse
</span><span class="c1"></span>    <span class="c1">// 退出roundtrip函数
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="nf">testHookWaitResLoop</span><span class="p">()</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="c1">// writeLoop返回发送request后的结果
</span><span class="c1"></span>		<span class="k">case</span> <span class="nx">err</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">writeErrCh</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">debugRoundTrip</span> <span class="p">{</span>
				<span class="nx">req</span><span class="p">.</span><span class="nf">logf</span><span class="p">(</span><span class="s">&#34;writeErrCh resv: %T/%#v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">pc</span><span class="p">.</span><span class="nb">close</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;write error: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">))</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">mapRoundTripError</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">startBytesWritten</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 设置一个接收response的定时器，如果在这段时间内没有接收到response(即没有进入下面代码
</span><span class="c1"></span>            <span class="c1">// 的&#34;case re := &lt;-resc:&#34;分支)，超时后进入&#34;&#34;case &lt;-respHeaderTimer:分支，关闭连接，
</span><span class="c1"></span>            <span class="c1">// 防止readLoop一直等待读取response，导致处理阻塞;没有超时则关闭定时器
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">d</span> <span class="o">:=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nx">ResponseHeaderTimeout</span><span class="p">;</span> <span class="nx">d</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">debugRoundTrip</span> <span class="p">{</span>
					<span class="nx">req</span><span class="p">.</span><span class="nf">logf</span><span class="p">(</span><span class="s">&#34;starting timer for %v&#34;</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
				<span class="k">defer</span> <span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span> <span class="c1">// prevent leaks
</span><span class="c1"></span>				<span class="nx">respHeaderTimer</span> <span class="p">=</span> <span class="nx">timer</span><span class="p">.</span><span class="nx">C</span>
			<span class="p">}</span>
			<span class="c1">// 处理底层连接关闭。&#34;case &lt;-cancelChan:&#34;和”case &lt;-ctxDoneChan:“为request关闭，request
</span><span class="c1"></span>        	<span class="c1">// 关闭也会导致底层连接关闭，但必须处理非上层协议导致底层连接关闭的情况。
</span><span class="c1"></span>		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">pc</span><span class="p">.</span><span class="nx">closech</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">debugRoundTrip</span> <span class="p">{</span>
				<span class="nx">req</span><span class="p">.</span><span class="nf">logf</span><span class="p">(</span><span class="s">&#34;closech recv: %T %#v&#34;</span><span class="p">,</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">closed</span><span class="p">,</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">closed</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">mapRoundTripError</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">startBytesWritten</span><span class="p">,</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">closed</span><span class="p">)</span>
			 <span class="c1">// 等待获取response超时,关闭连接
</span><span class="c1"></span>		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">respHeaderTimer</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">debugRoundTrip</span> <span class="p">{</span>
				<span class="nx">req</span><span class="p">.</span><span class="nf">logf</span><span class="p">(</span><span class="s">&#34;timeout waiting for response headers.&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nb">close</span><span class="p">(</span><span class="nx">errTimeout</span><span class="p">)</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errTimeout</span>
			<span class="c1">// 接收到readLoop返回的response结果
</span><span class="c1"></span>		<span class="k">case</span> <span class="nx">re</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">resc</span><span class="p">:</span>
			<span class="c1">// 极异常情况,直接程序panic
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="nx">re</span><span class="p">.</span><span class="nx">res</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="nx">re</span><span class="p">.</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
				<span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;internal error: exactly one of res or err should be set; nil=%v&#34;</span><span class="p">,</span> <span class="nx">re</span><span class="p">.</span><span class="nx">res</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">debugRoundTrip</span> <span class="p">{</span>
				<span class="nx">req</span><span class="p">.</span><span class="nf">logf</span><span class="p">(</span><span class="s">&#34;resc recv: %p, %T/%#v&#34;</span><span class="p">,</span> <span class="nx">re</span><span class="p">.</span><span class="nx">res</span><span class="p">,</span> <span class="nx">re</span><span class="p">.</span><span class="nx">err</span><span class="p">,</span> <span class="nx">re</span><span class="p">.</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">re</span><span class="p">.</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">mapRoundTripError</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">startBytesWritten</span><span class="p">,</span> <span class="nx">re</span><span class="p">.</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nx">re</span><span class="p">.</span><span class="nx">res</span><span class="p">,</span> <span class="kc">nil</span>
		<span class="c1">// request取消
</span><span class="c1"></span>		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">cancelChan</span><span class="p">:</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">cancelRequest</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">cancelKey</span><span class="p">,</span> <span class="nx">errRequestCanceled</span><span class="p">)</span>
			<span class="c1">// 将关闭之后的chan置为nil,用来防止select一直进入该case(close的chan不会阻塞读，读取的数据为0)
</span><span class="c1"></span>			<span class="nx">cancelChan</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctxDoneChan</span><span class="p">:</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">cancelRequest</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">cancelKey</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">().</span><span class="nf">Err</span><span class="p">())</span>
			<span class="nx">cancelChan</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="nx">ctxDoneChan</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="writeloop">writeLoop</h4>
<p>每个 HTTP 请求都由另一个 Goroutine 中的 net/http.persistConn.writeLoop 循环写入的，这两个 Goroutine 独立执行并通过 Channel 进行通信。net/http.Request.write 会根据 net/http.Request 结构中的字段按照 HTTP 协议组成 TCP 数据段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">pc</span> <span class="o">*</span><span class="nx">persistConn</span><span class="p">)</span> <span class="nf">writeLoop</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">pc</span><span class="p">.</span><span class="nx">writeLoopDone</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// writeLoop会阻塞等待两个IO case:
</span><span class="c1"></span>        <span class="c1">//   循环等待并处理roundTrip发来的writeRequest数据，此时需要发送request；
</span><span class="c1"></span>        <span class="c1">//   如果底层连接关闭，则退出writeLoop
</span><span class="c1"></span>		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">wr</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">pc</span><span class="p">.</span><span class="nx">writech</span><span class="p">:</span>
			<span class="nx">startBytesWritten</span> <span class="o">:=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">nwrite</span>
			<span class="c1">// 构造request并发送request请求。waitForContinue用于处理首部含&#34;Expect: 100-continue&#34;的request
</span><span class="c1"></span>			<span class="nx">err</span> <span class="o">:=</span> <span class="nx">wr</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nx">pc</span><span class="p">.</span><span class="nx">bw</span><span class="p">,</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">isProxy</span><span class="p">,</span> <span class="nx">wr</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nx">extra</span><span class="p">,</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">waitForContinue</span><span class="p">(</span><span class="nx">wr</span><span class="p">.</span><span class="nx">continueCh</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">bre</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">requestBodyReadError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">bre</span><span class="p">.</span><span class="kt">error</span>
				<span class="c1">// Errors reading from the user&#39;s
</span><span class="c1"></span>				<span class="c1">// Request.Body are high priority.
</span><span class="c1"></span>				<span class="c1">// Set it here before sending on the
</span><span class="c1"></span>				<span class="c1">// channels below or calling
</span><span class="c1"></span>				<span class="c1">// pc.close() which tears town
</span><span class="c1"></span>				<span class="c1">// connections and causes other
</span><span class="c1"></span>				<span class="c1">// errors.
</span><span class="c1"></span>				<span class="nx">wr</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nf">setError</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">bw</span><span class="p">.</span><span class="nf">Flush</span><span class="p">()</span>
			<span class="p">}</span>
			<span class="c1">// 请求失败时，需要关闭request和底层连接
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">wr</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
				<span class="k">if</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">nwrite</span> <span class="o">==</span> <span class="nx">startBytesWritten</span> <span class="p">{</span>
					<span class="nx">err</span> <span class="p">=</span> <span class="nx">nothingWrittenError</span><span class="p">{</span><span class="nx">err</span><span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="c1">// 将结果发送给readLoop的pc.wroteRequest()函数处理
</span><span class="c1"></span>			<span class="nx">pc</span><span class="p">.</span><span class="nx">writeErrCh</span> <span class="o">&lt;-</span> <span class="nx">err</span> <span class="c1">// to the body reader, which might recycle us
</span><span class="c1"></span>			<span class="c1">// 将结果返回给roundTrip处理，防止响应超时
</span><span class="c1"></span>			<span class="nx">wr</span><span class="p">.</span><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">err</span>         <span class="c1">// to the roundTrip function
</span><span class="c1"></span>			<span class="c1">// 如果发送request失败，需要关闭连接。writeLoop退出时会关闭pc.conn和pc.closech,
</span><span class="c1"></span>            <span class="c1">// 同时会导致readLoop退出
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">pc</span><span class="p">.</span><span class="nb">close</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">pc</span><span class="p">.</span><span class="nx">closech</span><span class="p">:</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当我们调用 net/http.Request.write 向请求中写入数据时，实际上直接写入了 net/http.persistConnWriter 中的 TCP 连接中，TCP 协议栈会负责将 HTTP 请求中的内容发送到目标服务器上：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">persistConnWriter</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">pc</span> <span class="o">*</span><span class="nx">persistConn</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="nx">persistConnWriter</span><span class="p">)</span> <span class="nf">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">pc</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
	<span class="nx">w</span><span class="p">.</span><span class="nx">pc</span><span class="p">.</span><span class="nx">nwrite</span> <span class="o">+=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="readloop">readLoop</h4>
<p>readLoop循环接收response响应，成功获得response后会将连接返回连接池，便于后续复用。当readLoop正常处理完一个response之后，会将连接重新放入到连接池中；</p>
<p>当readloop退出后，该连接会被关闭移除。</p>
<p>持久连接中的另一个读循环 net/http.persistConn.readLoop 会负责从 TCP 连接中读取数据并将数据发送会 HTTP 请求的调用方，真正负责解析 HTTP 协议的还是 net/http.ReadResponse：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="p">(</span><span class="nx">pc</span> <span class="o">*</span><span class="nx">persistConn</span><span class="p">)</span> <span class="nf">readLoop</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">closeErr</span> <span class="o">:=</span> <span class="nx">errReadLoopExiting</span> <span class="c1">// default value, if not changed below
</span><span class="c1"></span>	<span class="c1">// 当writeLoop或readLoop(异常)跳出循环后，都需要关闭底层连接。即一条连接包含writeLoop和readLoop两个
</span><span class="c1"></span>    <span class="c1">// 处理，任何一个loop退出(协议升级除外)则该连接不可用
</span><span class="c1"></span>    <span class="c1">// readLoo跳出循环的正常原因是连接上没有待处理的请求，此时关闭连接，释放资源
</span><span class="c1"></span>	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">pc</span><span class="p">.</span><span class="nb">close</span><span class="p">(</span><span class="nx">closeErr</span><span class="p">)</span>	<span class="c1">// 关闭连接
</span><span class="c1"></span>		<span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">removeIdleConn</span><span class="p">(</span><span class="nx">pc</span><span class="p">)</span>	<span class="c1">// 从连接池中删除
</span><span class="c1"></span>	<span class="p">}()</span>
	<span class="c1">// 尝试将连接放回连接池
</span><span class="c1"></span>	<span class="nx">tryPutIdleConn</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">trace</span> <span class="o">*</span><span class="nx">httptrace</span><span class="p">.</span><span class="nx">ClientTrace</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">tryPutIdleConn</span><span class="p">(</span><span class="nx">pc</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">closeErr</span> <span class="p">=</span> <span class="nx">err</span>
			<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">PutIdleConn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">errKeepAlivesDisabled</span> <span class="p">{</span>
				<span class="nx">trace</span><span class="p">.</span><span class="nf">PutIdleConn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">PutIdleConn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">trace</span><span class="p">.</span><span class="nf">PutIdleConn</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="c1">// eofc is used to block caller goroutines reading from Response.Body
</span><span class="c1"></span>	<span class="c1">// at EOF until this goroutines has (potentially) added the connection
</span><span class="c1"></span>	<span class="c1">// back to the idle pool.
</span><span class="c1"></span>	<span class="c1">// 从上面注释可以看出该变量主要用于阻塞调用者协程读取EOF的resp.body，
</span><span class="c1"></span>    <span class="c1">// 直到该连接重新放入连接池中。处理逻辑与上面先尝试放入连接池，然后返回response一样，
</span><span class="c1"></span>    <span class="c1">// 便于连接快速重用
</span><span class="c1"></span>	<span class="nx">eofc</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
	<span class="c1">// 出现错误时也需要释放读取resp.Body的协程,防止调用者协程挂死
</span><span class="c1"></span>	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">eofc</span><span class="p">)</span> <span class="c1">// unblock reader on errors
</span><span class="c1"></span>
	<span class="c1">// Read this once, before loop starts. (to avoid races in tests)
</span><span class="c1"></span>	<span class="nx">testHookMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">testHookReadLoopBeforeNextRead</span> <span class="o">:=</span> <span class="nx">testHookReadLoopBeforeNextRead</span>
	<span class="nx">testHookMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="nx">alive</span> <span class="o">:=</span> <span class="kc">true</span>
	<span class="k">for</span> <span class="nx">alive</span> <span class="p">{</span>
		<span class="c1">// 获取允许的response首部的最大字节数
</span><span class="c1"></span>		<span class="nx">pc</span><span class="p">.</span><span class="nx">readLimit</span> <span class="p">=</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">maxHeaderResponseSize</span><span class="p">()</span>
		<span class="c1">// 从接收buffer中peek一个字节来判断底层是否接收到response。roundTrip保证了request先于response发送。
</span><span class="c1"></span>       	<span class="c1">// 此处peek会阻塞等待response(这也是roundtrip中设置response超时定时器的原因)。goroutine中的read/write
</span><span class="c1"></span>       	<span class="c1">// 操作都是阻塞模式。
</span><span class="c1"></span>		<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">br</span><span class="p">.</span><span class="nf">Peek</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

		<span class="nx">pc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="c1">// 如果期望的response为0，则直接退出readLoop并关闭连接，此时连接上没有需要处理的数据，
</span><span class="c1"></span>        <span class="c1">// 关闭连接，释放系统资源。
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">numExpectedResponses</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nf">readLoopPeekFailLocked</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">pc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="c1">// 阻塞等待roundTrip发来的数据
</span><span class="c1"></span>		<span class="nx">rc</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">pc</span><span class="p">.</span><span class="nx">reqch</span>	<span class="c1">// 从管道中拿到请求，roundTrip 对该管道进行输入
</span><span class="c1"></span>		<span class="nx">trace</span> <span class="o">:=</span> <span class="nx">httptrace</span><span class="p">.</span><span class="nf">ContextClientTrace</span><span class="p">(</span><span class="nx">rc</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">())</span>

		<span class="kd">var</span> <span class="nx">resp</span> <span class="o">*</span><span class="nx">Response</span>
		<span class="c1">// 如果有response数据，则读取并解析为Response格式
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">readResponse</span><span class="p">(</span><span class="nx">rc</span><span class="p">,</span> <span class="nx">trace</span><span class="p">)</span><span class="c1">// 更多的是解析 header
</span><span class="c1"></span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 可能的错误如server端关闭，发送EOF
</span><span class="c1"></span>			<span class="nx">err</span> <span class="p">=</span> <span class="nx">transportReadFromServerError</span><span class="p">{</span><span class="nx">err</span><span class="p">}</span>
			<span class="nx">closeErr</span> <span class="p">=</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="c1">// 底层没有接收到server的任何数据，断开该连接,可能原因是在client发出request的同时，server关闭
</span><span class="c1"></span>        <span class="c1">// 了连接。参见transportReadFromServerError的注释。
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">readLimit</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;net/http: server response headers exceeded %d bytes; aborted&#34;</span><span class="p">,</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">maxHeaderResponseSize</span><span class="p">())</span>
			<span class="p">}</span>
			<span class="c1">// 传递错误信息给roundTrip并退出loop
</span><span class="c1"></span>			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">responseAndError</span><span class="p">{</span><span class="nx">err</span><span class="p">:</span> <span class="nx">err</span><span class="p">}:</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">rc</span><span class="p">.</span><span class="nx">callerGone</span><span class="p">:</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">pc</span><span class="p">.</span><span class="nx">readLimit</span> <span class="p">=</span> <span class="nx">maxInt64</span> <span class="c1">// effectively no limit for response bodies
</span><span class="c1"></span>
		<span class="nx">pc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="nx">pc</span><span class="p">.</span><span class="nx">numExpectedResponses</span><span class="o">--</span>
		<span class="nx">pc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="c1">// 判断response是否可写，在使用101 Switching Protocol进行协议升级时需要返回一个可写的resp.body
</span><span class="c1"></span>        <span class="c1">// 如果使用了101 Switching Protocol，升级完成后就与transport没有关系了(后续使用http2或websocket等)
</span><span class="c1"></span>		<span class="nx">bodyWritable</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.</span><span class="nf">bodyIsWritable</span><span class="p">()</span>
		<span class="c1">// 判断response的body是否为空，如果body为空，则不必读取body内容(HEAD的resp.body没有数据)
</span><span class="c1"></span>		<span class="nx">hasBody</span> <span class="o">:=</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nx">Method</span> <span class="o">!=</span> <span class="s">&#34;HEAD&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="o">!=</span> <span class="mi">0</span>
		<span class="c1">// 如果server关闭连接或client关闭连接或非预期的响应码或使用了协议升级，这几种情况下不能在该连接上继续
</span><span class="c1"></span>        <span class="c1">// 接收响应，退出readLoop
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Close</span> <span class="o">||</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nx">Close</span> <span class="o">||</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">&lt;=</span> <span class="mi">199</span> <span class="o">||</span> <span class="nx">bodyWritable</span> <span class="p">{</span>
			<span class="c1">// Don&#39;t do keep-alive on error if either party requested a close
</span><span class="c1"></span>			<span class="c1">// or we get an unexpected informational (1xx) response.
</span><span class="c1"></span>			<span class="c1">// StatusCode 100 is already handled above.
</span><span class="c1"></span>			<span class="nx">alive</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="p">}</span>
		<span class="c1">// 此处用于处理body为空或协议升级场景,会尝试将连接放回连接池，对于后者，连接由调用者管理，退出readLoop
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">hasBody</span> <span class="o">||</span> <span class="nx">bodyWritable</span> <span class="p">{</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">setReqCanceler</span><span class="p">(</span><span class="nx">rc</span><span class="p">.</span><span class="nx">cancelKey</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>

			<span class="c1">// Put the idle conn back into the pool before we send the response
</span><span class="c1"></span>			<span class="c1">// so if they process it quickly and make another request, they&#39;ll
</span><span class="c1"></span>			<span class="c1">// get this same conn. But we use the unbuffered channel &#39;rc&#39;
</span><span class="c1"></span>			<span class="c1">// to guarantee that persistConn.roundTrip got out of its select
</span><span class="c1"></span>			<span class="c1">// potentially waiting for this persistConn to close.
</span><span class="c1"></span>			<span class="c1">// but after
</span><span class="c1"></span>			<span class="c1">// 在返回response前将连接放回连接池，快速回收利用。回收连接需要按顺序满足：
</span><span class="c1"></span>            <span class="c1">// 1.alive 为true
</span><span class="c1"></span>            <span class="c1">// 2.接收到EOF错误，此时底层连接关闭，该连接不可用
</span><span class="c1"></span>            <span class="c1">// 3.成功发送request；
</span><span class="c1"></span>            <span class="c1">// 此处的执行顺序很重要，将连接返回连接池的操作放到最后，即在协议升级的场景，服务端不再
</span><span class="c1"></span>            <span class="c1">// 发送数据的场景，以及request发送失败的场景下都不会将连接放回连接池，这些情况会导致
</span><span class="c1"></span>            <span class="c1">// alive为false，readLoop退出并关闭该连接(协议升级后的连接不能关闭)
</span><span class="c1"></span>			<span class="nx">alive</span> <span class="p">=</span> <span class="nx">alive</span> <span class="o">&amp;&amp;</span>
				<span class="p">!</span><span class="nx">pc</span><span class="p">.</span><span class="nx">sawEOF</span> <span class="o">&amp;&amp;</span>
				<span class="nx">pc</span><span class="p">.</span><span class="nf">wroteRequest</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
				<span class="nf">tryPutIdleConn</span><span class="p">(</span><span class="nx">trace</span><span class="p">)</span>

			<span class="k">if</span> <span class="nx">bodyWritable</span> <span class="p">{</span>
				<span class="c1">// 协议升级之后还是会使用同一条连接，设置closeErr为errCallerOwnsConn，这样在readLoop
</span><span class="c1"></span>                <span class="c1">// return后不会被pc.close(closeErr)关闭连接
</span><span class="c1"></span>				<span class="nx">closeErr</span> <span class="p">=</span> <span class="nx">errCallerOwnsConn</span>
			<span class="p">}</span>

			<span class="k">select</span> <span class="p">{</span>
			<span class="c1">// 1:将response成功返回后继续等待下一个response；
</span><span class="c1"></span>            <span class="c1">// 2:如果roundTrip退出，(此时无法返回给roundTrip response)则退出readLoop。
</span><span class="c1"></span>            <span class="c1">// 即roundTrip接收完response后退出不会影响readLoop继续运行
</span><span class="c1"></span>			<span class="k">case</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">responseAndError</span><span class="p">{</span><span class="nx">res</span><span class="p">:</span> <span class="nx">resp</span><span class="p">}:</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">rc</span><span class="p">.</span><span class="nx">callerGone</span><span class="p">:</span>
				<span class="k">return</span>
			<span class="p">}</span>

			<span class="c1">// Now that they&#39;ve read from the unbuffered channel, they&#39;re safely
</span><span class="c1"></span>			<span class="c1">// out of the select that also waits on this goroutine to die, so
</span><span class="c1"></span>			<span class="c1">// we&#39;re allowed to exit now if needed (if alive is false)
</span><span class="c1"></span>			<span class="nf">testHookReadLoopBeforeNextRead</span><span class="p">()</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// 下面处理response body存在数据的场景，逻辑与body不存在数据的场景类似
</span><span class="c1"></span>		<span class="nx">waitForBodyRead</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
		<span class="c1">// 初始化body的处理函数,读取完response会返回EOF，这类连接是可重用的
</span><span class="c1"></span>		<span class="nx">body</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">bodyEOFSignal</span><span class="p">{</span>
			<span class="nx">body</span><span class="p">:</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span>
			<span class="c1">// 提前关闭 !!! 输出false
</span><span class="c1"></span>			<span class="nx">earlyCloseFn</span><span class="p">:</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
				<span class="nx">waitForBodyRead</span> <span class="o">&lt;-</span> <span class="kc">false</span>
				<span class="o">&lt;-</span><span class="nx">eofc</span> <span class="c1">// will be closed by deferred call at the end of the function
</span><span class="c1"></span>				<span class="k">return</span> <span class="kc">nil</span>

			<span class="p">},</span>
			<span class="c1">// 正常收尾 !!!
</span><span class="c1"></span>			<span class="nx">fn</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
				<span class="nx">isEOF</span> <span class="o">:=</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span>
				<span class="nx">waitForBodyRead</span> <span class="o">&lt;-</span> <span class="nx">isEOF</span>
				<span class="k">if</span> <span class="nx">isEOF</span> <span class="p">{</span>
					<span class="o">&lt;-</span><span class="nx">eofc</span> <span class="c1">// see comment above eofc declaration
</span><span class="c1"></span>				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="k">if</span> <span class="nx">cerr</span> <span class="o">:=</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">canceled</span><span class="p">();</span> <span class="nx">cerr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
						<span class="k">return</span> <span class="nx">cerr</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="k">return</span> <span class="nx">err</span>
			<span class="p">},</span>
		<span class="p">}</span>
		<span class="c1">//返回的resp.Body类型变为了bodyEOFSignal，如果调用者在读取resp.Body后没有关闭，会导致
</span><span class="c1"></span>        <span class="c1">// readLoop阻塞在下面&#34;case bodyEOF := &lt;-waitForBodyRead:&#34;中
</span><span class="c1"></span>		<span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span> <span class="p">=</span> <span class="nx">body</span>
		<span class="k">if</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">addedGzip</span> <span class="o">&amp;&amp;</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">EqualFold</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;Content-Encoding&#34;</span><span class="p">),</span> <span class="s">&#34;gzip&#34;</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">gzipReader</span><span class="p">{</span><span class="nx">body</span><span class="p">:</span> <span class="nx">body</span><span class="p">}</span>
			<span class="nx">resp</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Del</span><span class="p">(</span><span class="s">&#34;Content-Encoding&#34;</span><span class="p">)</span>
			<span class="nx">resp</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Del</span><span class="p">(</span><span class="s">&#34;Content-Length&#34;</span><span class="p">)</span>
			<span class="nx">resp</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
			<span class="nx">resp</span><span class="p">.</span><span class="nx">Uncompressed</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="c1">// 此处与处理不带resp.body的场景相同
</span><span class="c1"></span>		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">responseAndError</span><span class="p">{</span><span class="nx">res</span><span class="p">:</span> <span class="nx">resp</span><span class="p">}:</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">rc</span><span class="p">.</span><span class="nx">callerGone</span><span class="p">:</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="c1">// Before looping back to the top of this function and peeking on
</span><span class="c1"></span>		<span class="c1">// the bufio.Reader, wait for the caller goroutine to finish
</span><span class="c1"></span>		<span class="c1">// reading the response body. (or for cancellation or death)
</span><span class="c1"></span>		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">bodyEOF</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">waitForBodyRead</span><span class="p">:</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">setReqCanceler</span><span class="p">(</span><span class="nx">rc</span><span class="p">.</span><span class="nx">cancelKey</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span> <span class="c1">// before pc might return to idle pool
</span><span class="c1"></span>				<span class="c1">// alive 为 false, 不能继续 continue
</span><span class="c1"></span>				<span class="c1">// 如果读取完response的数据，则该连接可以被重用，否则直接释放。释放一个未读取完数据的连接会导致数据丢失。
</span><span class="c1"></span>				<span class="c1">//注意区分bodyEOF和pc.sawEOF的区别，一个是上层通道(http response.Body)关闭，一个是底层通道(TCP)关闭。
</span><span class="c1"></span>				<span class="c1">//只有符合以下条件的前提下，才能尝试将连接回收放入连接池：
</span><span class="c1"></span>				<span class="c1">//1. 开启KeepAlive
</span><span class="c1"></span>				<span class="c1">//2. Body读取到EOF
</span><span class="c1"></span>				<span class="c1">//3. TCP连接没有被关闭(pc.sawEOF)
</span><span class="c1"></span>				<span class="c1">//4. 请求已经彻底发送并成功
</span><span class="c1"></span>			<span class="nx">alive</span> <span class="p">=</span> <span class="nx">alive</span> <span class="o">&amp;&amp;</span>
				<span class="nx">bodyEOF</span> <span class="o">&amp;&amp;</span>
				<span class="p">!</span><span class="nx">pc</span><span class="p">.</span><span class="nx">sawEOF</span> <span class="o">&amp;&amp;</span>
				<span class="nx">pc</span><span class="p">.</span><span class="nf">wroteRequest</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
				<span class="nf">tryPutIdleConn</span><span class="p">(</span><span class="nx">trace</span><span class="p">)</span>
			<span class="c1">// 释放阻塞的读操作
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">bodyEOF</span> <span class="p">{</span>
				<span class="nx">eofc</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">rc</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nx">Cancel</span><span class="p">:</span>
			<span class="nx">alive</span> <span class="p">=</span> <span class="kc">false</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">CancelRequest</span><span class="p">(</span><span class="nx">rc</span><span class="p">.</span><span class="nx">req</span><span class="p">)</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">rc</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">().</span><span class="nf">Done</span><span class="p">():</span>
			<span class="nx">alive</span> <span class="p">=</span> <span class="kc">false</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">cancelRequest</span><span class="p">(</span><span class="nx">rc</span><span class="p">.</span><span class="nx">cancelKey</span><span class="p">,</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">().</span><span class="nf">Err</span><span class="p">())</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">pc</span><span class="p">.</span><span class="nx">closech</span><span class="p">:</span>
			<span class="nx">alive</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="p">}</span>

		<span class="nf">testHookReadLoopBeforeNextRead</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>resp.body实际上是bodyEOFSignal结构体:</p>
<p>httpclient 每个连接会创建读写协程两个协程，分别使用 reqch 和 writech 来跟 roundTrip 通信。上层使用的response.Body 其实是经过多次封装的，一次封装的 body 是直接跟 net.conn 进行交互读取，二次封装的 body 则是加强了 close 和 eof 处理的 bodyEOFSignal。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// bodyEOFSignal is used by the HTTP/1 transport when reading response
</span><span class="c1">// bodies to make sure we see the end of a response body before
</span><span class="c1">// proceeding and reading on the connection again.
</span><span class="c1">//
</span><span class="c1">// It wraps a ReadCloser but runs fn (if non-nil) at most
</span><span class="c1">// once, right before its final (error-producing) Read or Close call
</span><span class="c1">// returns. fn should return the new error to return from Read or Close.
</span><span class="c1">//
</span><span class="c1">// If earlyCloseFn is non-nil and Close is called before io.EOF is
</span><span class="c1">// seen, earlyCloseFn is called instead of fn, and its return value is
</span><span class="c1">// the return value from Close.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">bodyEOFSignal</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">body</span>         <span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span>
	<span class="nx">mu</span>           <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>        <span class="c1">// guards following 4 fields
</span><span class="c1"></span>	<span class="nx">closed</span>       <span class="kt">bool</span>              <span class="c1">// whether Close has been called
</span><span class="c1"></span>	<span class="nx">rerr</span>         <span class="kt">error</span>             <span class="c1">// sticky Read error
</span><span class="c1"></span>	<span class="nx">fn</span>           <span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="c1">// err will be nil on Read io.EOF
</span><span class="c1"></span>	<span class="nx">earlyCloseFn</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">error</span>      <span class="c1">// optional alt Close func used if io.EOF not seen
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">var</span> <span class="nx">errReadOnClosedResBody</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: read on closed response body&#34;</span><span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">es</span> <span class="o">*</span><span class="nx">bodyEOFSignal</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">es</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">closed</span><span class="p">,</span> <span class="nx">rerr</span> <span class="o">:=</span> <span class="nx">es</span><span class="p">.</span><span class="nx">closed</span><span class="p">,</span> <span class="nx">es</span><span class="p">.</span><span class="nx">rerr</span>
	<span class="nx">es</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">closed</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">errReadOnClosedResBody</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">rerr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">rerr</span>
	<span class="p">}</span>

	<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">es</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">es</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">defer</span> <span class="nx">es</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">es</span><span class="p">.</span><span class="nx">rerr</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">es</span><span class="p">.</span><span class="nx">rerr</span> <span class="p">=</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="nx">err</span> <span class="p">=</span> <span class="nx">es</span><span class="p">.</span><span class="nf">condfn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当未读取 body 就进行 close 时，会触发 earlyCloseFn() 回调，看 earlyCloseFn 的函数定义，在 close 未见 io.EOF 时才调用。</p>
<p>自定义的 earlyCloseFn 方法会给 readLoop 监听的 waitForBodyRead 传入 false,  这样引发 alive 为 false 不能继续循环的接收新请求，只能是退出调用注册过的 defer 方法，关闭连接和清理连接池。</p>
<p>众所周知，golang httpclient 要注意 response Body 关闭问题，但当 http client 返回值不为空，只读取 response header，但不读 body 内容就执行 response.Body.Close()，那么连接会被主动关闭，得不到复用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">es</span> <span class="o">*</span><span class="nx">bodyEOFSignal</span><span class="p">)</span> <span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">es</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">es</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">es</span><span class="p">.</span><span class="nx">closed</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">es</span><span class="p">.</span><span class="nx">closed</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">if</span> <span class="nx">es</span><span class="p">.</span><span class="nx">earlyCloseFn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">es</span><span class="p">.</span><span class="nx">rerr</span> <span class="o">!=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">es</span><span class="p">.</span><span class="nf">earlyCloseFn</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">es</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">es</span><span class="p">.</span><span class="nf">condfn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>最终会调用 persistConn 的 close(), 连接关闭并关闭closech：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// close closes the underlying TCP connection and closes
</span><span class="c1">// the pc.closech channel.
</span><span class="c1">//
</span><span class="c1">// The provided err is only for testing and debugging; in normal
</span><span class="c1">// circumstances it should never be seen by users.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">pc</span> <span class="o">*</span><span class="nx">persistConn</span><span class="p">)</span> <span class="nb">close</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">pc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">pc</span><span class="p">.</span><span class="nf">closeLocked</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">pc</span> <span class="o">*</span><span class="nx">persistConn</span><span class="p">)</span> <span class="nf">closeLocked</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;nil error&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">pc</span><span class="p">.</span><span class="nx">broken</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">if</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">pc</span><span class="p">.</span><span class="nx">closed</span> <span class="p">=</span> <span class="nx">err</span>
		<span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">decConnsPerHost</span><span class="p">(</span><span class="nx">pc</span><span class="p">.</span><span class="nx">cacheKey</span><span class="p">)</span>
		<span class="c1">// Close HTTP/1 (pc.alt == nil) connection.
</span><span class="c1"></span>		<span class="c1">// HTTP/2 closes its connection itself.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">alt</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">errCallerOwnsConn</span> <span class="p">{</span>
				<span class="nx">pc</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span><span class="c1">// 关闭连接
</span><span class="c1"></span>			<span class="p">}</span>
			<span class="nb">close</span><span class="p">(</span><span class="nx">pc</span><span class="p">.</span><span class="nx">closech</span><span class="p">)</span><span class="c1">// 通知读写协程
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">pc</span><span class="p">.</span><span class="nx">mutateHeaderFunc</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="tryputidleconn">tryPutIdleConn</h4>
<p>请求处理完成后，通过tryPutIdleConn将连接放回连接池；这时候如果存在等待空闲连接的协程，则需要分发复用该连接。另外，在回收连接时，还需要校验空闲连接数目是否超过限制：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210203182740.png" alt=""></p>
<p>如果DisableKeepAlives为true表示不使用连接复用，所以请求完后会把连接关掉，但是这里需要注意的是，同时发请求的时候我们会设置Connections: close, 所以server端发送完数据后就会自动断开，所以这种情况的连接其实是server端发起的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// tryPutIdleConn adds pconn to the list of idle persistent connections awaiting
</span><span class="c1">// a new request.
</span><span class="c1">// If pconn is no longer needed or not in a good state, tryPutIdleConn returns
</span><span class="c1">// an error explaining why it wasn&#39;t registered.
</span><span class="c1">// tryPutIdleConn does not close pconn. Use putOrCloseIdleConn instead for that.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transport</span><span class="p">)</span> <span class="nf">tryPutIdleConn</span><span class="p">(</span><span class="nx">pconn</span> <span class="o">*</span><span class="nx">persistConn</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">// 禁用长连接；或者最大空闲连接数不合法
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">DisableKeepAlives</span> <span class="o">||</span> <span class="nx">t</span><span class="p">.</span><span class="nx">MaxIdleConnsPerHost</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">errKeepAlivesDisabled</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">pconn</span><span class="p">.</span><span class="nf">isBroken</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">errConnBroken</span>
	<span class="p">}</span>
	<span class="nx">pconn</span><span class="p">.</span><span class="nf">markReused</span><span class="p">()</span>

	<span class="nx">t</span><span class="p">.</span><span class="nx">idleMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">t</span><span class="p">.</span><span class="nx">idleMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="c1">// HTTP/2 (pconn.alt != nil) connections do not come out of the idle list,
</span><span class="c1"></span>	<span class="c1">// because multiple goroutines can use them simultaneously.
</span><span class="c1"></span>	<span class="c1">// If this is an HTTP/2 connection being “returned,” we&#39;re done.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">alt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">idleLRU</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">pconn</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="c1">// Deliver pconn to goroutine waiting for idle connection, if any.
</span><span class="c1"></span>	<span class="c1">// (They may be actively dialing, but this conn is ready first.
</span><span class="c1"></span>	<span class="c1">// Chrome calls this socket late binding.
</span><span class="c1"></span>	<span class="c1">// See https://www.chromium.org/developers/design-documents/network-stack#TOC-Connection-Management.)
</span><span class="c1"></span>	<span class="nx">key</span> <span class="o">:=</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">cacheKey</span>
	<span class="k">if</span> <span class="nx">q</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">idleConnWait</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">done</span> <span class="o">:=</span> <span class="kc">false</span>
		<span class="k">if</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">alt</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// HTTP/1.
</span><span class="c1"></span>			<span class="c1">// Loop over the waiting list until we find a w that isn&#39;t done already, and hand it pconn.
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">q</span><span class="p">.</span><span class="nb">len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">w</span> <span class="o">:=</span> <span class="nx">q</span><span class="p">.</span><span class="nf">popFront</span><span class="p">()</span>
				<span class="k">if</span> <span class="nx">w</span><span class="p">.</span><span class="nf">tryDeliver</span><span class="p">(</span><span class="nx">pconn</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
					<span class="nx">done</span> <span class="p">=</span> <span class="kc">true</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// HTTP/2.
</span><span class="c1"></span>			<span class="c1">// Can hand the same pconn to everyone in the waiting list,
</span><span class="c1"></span>			<span class="c1">// and we still won&#39;t be done: we want to put it in the idle
</span><span class="c1"></span>			<span class="c1">// list unconditionally, for any future clients too.
</span><span class="c1"></span>			<span class="c1">//如果等待队列不为空，分发连接
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">q</span><span class="p">.</span><span class="nb">len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">w</span> <span class="o">:=</span> <span class="nx">q</span><span class="p">.</span><span class="nf">popFront</span><span class="p">()</span>
				<span class="nx">w</span><span class="p">.</span><span class="nf">tryDeliver</span><span class="p">(</span><span class="nx">pconn</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">q</span><span class="p">.</span><span class="nb">len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nb">delete</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">idleConnWait</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nx">idleConnWait</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">q</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">done</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">closeIdle</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">errCloseIdle</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">idleConn</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">idleConn</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">connectMethodKey</span><span class="p">][]</span><span class="o">*</span><span class="nx">persistConn</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">idles</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">idleConn</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
	<span class="c1">// 空闲连接数目超过限制，默认为DefaultMaxIdleConnsPerHost=2
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">idles</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">maxIdleConnsPerHost</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">errTooManyIdleHost</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">exist</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">idles</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">exist</span> <span class="o">==</span> <span class="nx">pconn</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;dup idle pconn %p in freelist&#34;</span><span class="p">,</span> <span class="nx">pconn</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">idleConn</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">idles</span><span class="p">,</span> <span class="nx">pconn</span><span class="p">)</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">idleLRU</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">pconn</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">MaxIdleConns</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">idleLRU</span><span class="p">.</span><span class="nb">len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">MaxIdleConns</span> <span class="p">{</span>
		<span class="nx">oldest</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">idleLRU</span><span class="p">.</span><span class="nf">removeOldest</span><span class="p">()</span>
		<span class="nx">oldest</span><span class="p">.</span><span class="nb">close</span><span class="p">(</span><span class="nx">errTooManyIdle</span><span class="p">)</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">removeIdleConnLocked</span><span class="p">(</span><span class="nx">oldest</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Set idle timer, but only for HTTP/1 (pconn.alt == nil).
</span><span class="c1"></span>	<span class="c1">// The HTTP/2 implementation manages the idle timer itself
</span><span class="c1"></span>	<span class="c1">// (see idleConnTimeout in h2_bundle.go).
</span><span class="c1"></span>	<span class="c1">// 在将空闲连接添加到连接池时，Golang同时还设置了定时器，定时器到期后，自然会关闭该连接。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">IdleConnTimeout</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">alt</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">idleTimer</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">pconn</span><span class="p">.</span><span class="nx">idleTimer</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">IdleConnTimeout</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">pconn</span><span class="p">.</span><span class="nx">idleTimer</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">AfterFunc</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">IdleConnTimeout</span><span class="p">,</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">closeConnIfStillIdle</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">pconn</span><span class="p">.</span><span class="nx">idleAt</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="response">Response</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Response represents the response from an HTTP request.
</span><span class="c1">//
</span><span class="c1">// The Client and Transport return Responses from servers once
</span><span class="c1">// the response headers have been received. The response body
</span><span class="c1">// is streamed on demand as the Body field is read.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Response</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Status</span>     <span class="kt">string</span> <span class="c1">// e.g. &#34;200 OK&#34;
</span><span class="c1"></span>	<span class="nx">StatusCode</span> <span class="kt">int</span>    <span class="c1">// e.g. 200
</span><span class="c1"></span>	<span class="nx">Proto</span>      <span class="kt">string</span> <span class="c1">// e.g. &#34;HTTP/1.0&#34;
</span><span class="c1"></span>	<span class="nx">ProtoMajor</span> <span class="kt">int</span>    <span class="c1">// e.g. 1
</span><span class="c1"></span>	<span class="nx">ProtoMinor</span> <span class="kt">int</span>    <span class="c1">// e.g. 0
</span><span class="c1"></span>
	<span class="c1">// Header maps header keys to values. If the response had multiple
</span><span class="c1"></span>	<span class="c1">// headers with the same key, they may be concatenated, with comma
</span><span class="c1"></span>	<span class="c1">// delimiters.  (RFC 7230, section 3.2.2 requires that multiple headers
</span><span class="c1"></span>	<span class="c1">// be semantically equivalent to a comma-delimited sequence.) When
</span><span class="c1"></span>	<span class="c1">// Header values are duplicated by other fields in this struct (e.g.,
</span><span class="c1"></span>	<span class="c1">// ContentLength, TransferEncoding, Trailer), the field values are
</span><span class="c1"></span>	<span class="c1">// authoritative.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Keys in the map are canonicalized (see CanonicalHeaderKey).
</span><span class="c1"></span>	<span class="nx">Header</span> <span class="nx">Header</span>

	<span class="c1">// Body represents the response body.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The response body is streamed on demand as the Body field
</span><span class="c1"></span>	<span class="c1">// is read. If the network connection fails or the server
</span><span class="c1"></span>	<span class="c1">// terminates the response, Body.Read calls return an error.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The http Client and Transport guarantee that Body is always
</span><span class="c1"></span>	<span class="c1">// non-nil, even on responses without a body or responses with
</span><span class="c1"></span>	<span class="c1">// a zero-length body. It is the caller&#39;s responsibility to
</span><span class="c1"></span>	<span class="c1">// close Body. The default HTTP client&#39;s Transport may not
</span><span class="c1"></span>	<span class="c1">// reuse HTTP/1.x &#34;keep-alive&#34; TCP connections if the Body is
</span><span class="c1"></span>	<span class="c1">// not read to completion and closed.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The Body is automatically dechunked if the server replied
</span><span class="c1"></span>	<span class="c1">// with a &#34;chunked&#34; Transfer-Encoding.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// As of Go 1.12, the Body will also implement io.Writer
</span><span class="c1"></span>	<span class="c1">// on a successful &#34;101 Switching Protocols&#34; response,
</span><span class="c1"></span>	<span class="c1">// as used by WebSockets and HTTP/2&#39;s &#34;h2c&#34; mode.
</span><span class="c1"></span>	<span class="nx">Body</span> <span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span>

	<span class="c1">// ContentLength records the length of the associated content. The
</span><span class="c1"></span>	<span class="c1">// value -1 indicates that the length is unknown. Unless Request.Method
</span><span class="c1"></span>	<span class="c1">// is &#34;HEAD&#34;, values &gt;= 0 indicate that the given number of bytes may
</span><span class="c1"></span>	<span class="c1">// be read from Body.
</span><span class="c1"></span>	<span class="nx">ContentLength</span> <span class="kt">int64</span>

	<span class="c1">// Contains transfer encodings from outer-most to inner-most. Value is
</span><span class="c1"></span>	<span class="c1">// nil, means that &#34;identity&#34; encoding is used.
</span><span class="c1"></span>	<span class="nx">TransferEncoding</span> <span class="p">[]</span><span class="kt">string</span>

	<span class="c1">// Close records whether the header directed that the connection be
</span><span class="c1"></span>	<span class="c1">// closed after reading Body. The value is advice for clients: neither
</span><span class="c1"></span>	<span class="c1">// ReadResponse nor Response.Write ever closes a connection.
</span><span class="c1"></span>	<span class="nx">Close</span> <span class="kt">bool</span>

	<span class="c1">// Uncompressed reports whether the response was sent compressed but
</span><span class="c1"></span>	<span class="c1">// was decompressed by the http package. When true, reading from
</span><span class="c1"></span>	<span class="c1">// Body yields the uncompressed content instead of the compressed
</span><span class="c1"></span>	<span class="c1">// content actually set from the server, ContentLength is set to -1,
</span><span class="c1"></span>	<span class="c1">// and the &#34;Content-Length&#34; and &#34;Content-Encoding&#34; fields are deleted
</span><span class="c1"></span>	<span class="c1">// from the responseHeader. To get the original response from
</span><span class="c1"></span>	<span class="c1">// the server, set Transport.DisableCompression to true.
</span><span class="c1"></span>	<span class="nx">Uncompressed</span> <span class="kt">bool</span>

	<span class="c1">// Trailer maps trailer keys to values in the same
</span><span class="c1"></span>	<span class="c1">// format as Header.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The Trailer initially contains only nil values, one for
</span><span class="c1"></span>	<span class="c1">// each key specified in the server&#39;s &#34;Trailer&#34; header
</span><span class="c1"></span>	<span class="c1">// value. Those values are not added to Header.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Trailer must not be accessed concurrently with Read calls
</span><span class="c1"></span>	<span class="c1">// on the Body.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// After Body.Read has returned io.EOF, Trailer will contain
</span><span class="c1"></span>	<span class="c1">// any trailer values sent by the server.
</span><span class="c1"></span>	<span class="nx">Trailer</span> <span class="nx">Header</span>

	<span class="c1">// Request is the request that was sent to obtain this Response.
</span><span class="c1"></span>	<span class="c1">// Request&#39;s Body is nil (having already been consumed).
</span><span class="c1"></span>	<span class="c1">// This is only populated for Client requests.
</span><span class="c1"></span>	<span class="nx">Request</span> <span class="o">*</span><span class="nx">Request</span>

	<span class="c1">// TLS contains information about the TLS connection on which the
</span><span class="c1"></span>	<span class="c1">// response was received. It is nil for unencrypted responses.
</span><span class="c1"></span>	<span class="c1">// The pointer is shared between responses and should not be
</span><span class="c1"></span>	<span class="c1">// modified.
</span><span class="c1"></span>	<span class="nx">TLS</span> <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">ConnectionState</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="readresponse">readResponse</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// readResponse reads an HTTP response (or two, in the case of &#34;Expect:
</span><span class="c1">// 100-continue&#34;) from the server. It returns the final non-100 one.
</span><span class="c1">// trace is optional.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">pc</span> <span class="o">*</span><span class="nx">persistConn</span><span class="p">)</span> <span class="nf">readResponse</span><span class="p">(</span><span class="nx">rc</span> <span class="nx">requestAndChan</span><span class="p">,</span> <span class="nx">trace</span> <span class="o">*</span><span class="nx">httptrace</span><span class="p">.</span><span class="nx">ClientTrace</span><span class="p">)</span> <span class="p">(</span><span class="nx">resp</span> <span class="o">*</span><span class="nx">Response</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">GotFirstResponseByte</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">peek</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">br</span><span class="p">.</span><span class="nf">Peek</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">peek</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="nx">trace</span><span class="p">.</span><span class="nf">GotFirstResponseByte</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">num1xx</span> <span class="o">:=</span> <span class="mi">0</span>               <span class="c1">// number of informational 1xx headers received
</span><span class="c1"></span>	<span class="kd">const</span> <span class="nx">max1xxResponses</span> <span class="p">=</span> <span class="mi">5</span> <span class="c1">// arbitrary bound on number of informational responses
</span><span class="c1"></span>
	<span class="nx">continueCh</span> <span class="o">:=</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">continueCh</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">ReadResponse</span><span class="p">(</span><span class="nx">pc</span><span class="p">.</span><span class="nx">br</span><span class="p">,</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">req</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">resCode</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span>
		<span class="k">if</span> <span class="nx">continueCh</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">resCode</span> <span class="o">==</span> <span class="mi">100</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">Got100Continue</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">trace</span><span class="p">.</span><span class="nf">Got100Continue</span><span class="p">()</span>
				<span class="p">}</span>
				<span class="nx">continueCh</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
				<span class="nx">continueCh</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">resCode</span> <span class="o">&gt;=</span> <span class="mi">200</span> <span class="p">{</span>
				<span class="nb">close</span><span class="p">(</span><span class="nx">continueCh</span><span class="p">)</span>
				<span class="nx">continueCh</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">is1xx</span> <span class="o">:=</span> <span class="mi">100</span> <span class="o">&lt;=</span> <span class="nx">resCode</span> <span class="o">&amp;&amp;</span> <span class="nx">resCode</span> <span class="o">&lt;=</span> <span class="mi">199</span>
		<span class="c1">// treat 101 as a terminal status, see issue 26161
</span><span class="c1"></span>		<span class="nx">is1xxNonTerminal</span> <span class="o">:=</span> <span class="nx">is1xx</span> <span class="o">&amp;&amp;</span> <span class="nx">resCode</span> <span class="o">!=</span> <span class="nx">StatusSwitchingProtocols</span>
		<span class="k">if</span> <span class="nx">is1xxNonTerminal</span> <span class="p">{</span>
			<span class="nx">num1xx</span><span class="o">++</span>
			<span class="k">if</span> <span class="nx">num1xx</span> <span class="p">&gt;</span> <span class="nx">max1xxResponses</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;net/http: too many 1xx informational responses&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">readLimit</span> <span class="p">=</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">maxHeaderResponseSize</span><span class="p">()</span> <span class="c1">// reset the limit
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">Got1xxResponse</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">trace</span><span class="p">.</span><span class="nf">Got1xxResponse</span><span class="p">(</span><span class="nx">resCode</span><span class="p">,</span> <span class="nx">textproto</span><span class="p">.</span><span class="nf">MIMEHeader</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Header</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">break</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nf">isProtocolSwitch</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span> <span class="p">=</span> <span class="nf">newReadWriteCloserBody</span><span class="p">(</span><span class="nx">pc</span><span class="p">.</span><span class="nx">br</span><span class="p">,</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">conn</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">resp</span><span class="p">.</span><span class="nx">TLS</span> <span class="p">=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">tlsState</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们在上述方法中可以看到 HTTP 响应结构的大致框架，其中包含状态码、协议版本、请求头等内容，响应体还是在读取循环 net/http.persistConn.readLoop 中根据 HTTP 协议头进行解析的。</p>
<h2 id="服务器">服务器</h2>
<p>Go 语言标准库 net/http 包提供了非常易用的接口，如下所示，我们可以利用标准库提供的功能快速搭建新的 HTTP 服务：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">handler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;Hi there, I love %s!&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Path</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述的 main 函数只调用了两个标准库提供的函数，它们分别是用于注册处理器的 net/http.HandleFunc 函数和用于监听和处理器请求的 net/http.ListenAndServe，多数的服务器框架都会包含这两类接口，分别负责注册处理器和处理外部请求，这一种非常常见的模式，我们在这里也会按照这两个维度介绍标准库如何支持 HTTP 服务器的实现。</p>
<h3 id="注册处理器">注册处理器</h3>
<p>HTTP 服务是由一组实现了 net/http.Handler 接口的处理器组成的，处理 HTTP 请求时会根据请求的路由选择合适的处理器：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210129173918.png" alt=""></p>
<p>当我们直接调用 net/http.HandleFunc 注册处理器时，标准库会使用默认的 HTTP 服务器 net/http.DefaultServeMux 处理请求，该方法会直接调用 net/http.ServeMux.HandleFunc：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">mux</span> <span class="o">*</span><span class="nx">ServeMux</span><span class="p">)</span> <span class="nf">HandleFunc</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ResponseWriter</span><span class="p">,</span><span class="o">*</span><span class="nx">Request</span><span class="p">))</span> <span class="p">{</span>
	<span class="nx">mux</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="nx">pattern</span><span class="p">,</span> <span class="nf">HandlerFunc</span><span class="p">(</span><span class="nx">handler</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述方法会将处理器转换成 net/http.Handler 接口类型调用 net/http.ServeMux.Handle 注册处理器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">mux</span> <span class="o">*</span><span class="nx">ServeMux</span><span class="p">)</span> <span class="nf">Handle</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">Handler</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">exist</span> <span class="o">:=</span> <span class="nx">mux</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">pattern</span><span class="p">];</span> <span class="nx">exist</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;http: multiple registrations for &#34;</span> <span class="o">+</span> <span class="nx">pattern</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">muxEntry</span><span class="p">{</span><span class="nx">h</span><span class="p">:</span> <span class="nx">handler</span><span class="p">,</span> <span class="nx">pattern</span><span class="p">:</span> <span class="nx">pattern</span><span class="p">}</span>
	<span class="nx">mux</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">pattern</span><span class="p">]</span> <span class="p">=</span> <span class="nx">e</span>
	<span class="k">if</span> <span class="nx">pattern</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">pattern</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span> <span class="p">{</span>
		<span class="nx">mux</span><span class="p">.</span><span class="nx">es</span> <span class="p">=</span> <span class="nf">appendSorted</span><span class="p">(</span><span class="nx">mux</span><span class="p">.</span><span class="nx">es</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;/&#39;</span> <span class="p">{</span>
		<span class="nx">mux</span><span class="p">.</span><span class="nx">hosts</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>路由和对应的处理器会被组成 net/http.DefaultServeMux，该结构会持有一个 net/http.muxEntry 哈希，其中存储了从 URL 到处理器的映射关系，HTTP 服务器在处理请求时就会使用该哈希查找处理器。</p>
<h3 id="处理请求">处理请求</h3>
<p>标准库提供的 net/http.ListenAndServe 可以用来监听 TCP 连接并处理请求，该函数会使用传入的监听地址和处理器初始化一个 HTTP 服务器 net/http.Server，调用该服务器的 net/http.Server.ListenAndServe 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ListenAndServe</span><span class="p">(</span><span class="nx">addr</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">Handler</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">server</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Server</span><span class="p">{</span><span class="nx">Addr</span><span class="p">:</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">Handler</span><span class="p">:</span> <span class="nx">handler</span><span class="p">}</span>
	<span class="k">return</span> <span class="nx">server</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>net/http.Server.ListenAndServe 会使用网络库提供的 net.Listen 监听对应地址上的 TCP 连接并通过 net/http.Server.Serve 处理客户端的请求：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">srv</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">ListenAndServe</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">addr</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">addr</span> <span class="p">=</span> <span class="s">&#34;:http&#34;</span>
	<span class="p">}</span>
	<span class="nx">ln</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">addr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">srv</span><span class="p">.</span><span class="nf">Serve</span><span class="p">(</span><span class="nx">ln</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>net/http.Server.Serve 会在循环中监听外部的 TCP 连接并为每个连接调用 net/http.Server.newConn 创建新的 net/http.conn，它是 HTTP 连接的服务端表示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">srv</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">Serve</span><span class="p">(</span><span class="nx">l</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Listener</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">l</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">onceCloseListener</span><span class="p">{</span><span class="nx">Listener</span><span class="p">:</span> <span class="nx">l</span><span class="p">}</span>
	<span class="k">defer</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="nx">baseCtx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">()</span>
	<span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithValue</span><span class="p">(</span><span class="nx">baseCtx</span><span class="p">,</span> <span class="nx">ServerContextKey</span><span class="p">,</span> <span class="nx">srv</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">rw</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">srv</span><span class="p">.</span><span class="nf">getDoneChan</span><span class="p">():</span>
				<span class="k">return</span> <span class="nx">ErrServerClosed</span>
			<span class="k">default</span><span class="p">:</span>
			<span class="p">}</span>
			<span class="o">...</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="nx">connCtx</span> <span class="o">:=</span> <span class="nx">ctx</span>
		<span class="nx">c</span> <span class="o">:=</span> <span class="nx">srv</span><span class="p">.</span><span class="nf">newConn</span><span class="p">(</span><span class="nx">rw</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">setState</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">,</span> <span class="nx">StateNew</span><span class="p">)</span> <span class="c1">// before Serve can return
</span><span class="c1"></span>		<span class="k">go</span> <span class="nx">c</span><span class="p">.</span><span class="nf">serve</span><span class="p">(</span><span class="nx">connCtx</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>创建了服务端的连接之后，标准库中的实现会为每个 HTTP 请求创建单独的 Goroutine 并在其中调用 net/http.Conn.serve 方法，如果当前 HTTP 服务接收到了海量的请求，会在内部创建大量的 Goroutine，这可能会使整个服务质量明显降低无法处理请求。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Serve a new connection.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">conn</span><span class="p">)</span> <span class="nf">serve</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">remoteAddr</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">.</span><span class="nf">RemoteAddr</span><span class="p">().</span><span class="nf">String</span><span class="p">()</span>
	<span class="nx">ctx</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithValue</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">LocalAddrContextKey</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">.</span><span class="nf">LocalAddr</span><span class="p">())</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">ErrAbortHandler</span> <span class="p">{</span>
			<span class="kd">const</span> <span class="nx">size</span> <span class="p">=</span> <span class="mi">64</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span>
			<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
			<span class="nx">buf</span> <span class="p">=</span> <span class="nx">buf</span><span class="p">[:</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">Stack</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="kc">false</span><span class="p">)]</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">logf</span><span class="p">(</span><span class="s">&#34;http: panic serving %v: %v\n%s&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">remoteAddr</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">buf</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nf">hijacked</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nb">close</span><span class="p">()</span>
			<span class="nx">c</span><span class="p">.</span><span class="nf">setState</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">,</span> <span class="nx">StateClosed</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="k">if</span> <span class="nx">tlsConn</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">.(</span><span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Conn</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">d</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nx">ReadTimeout</span><span class="p">;</span> <span class="nx">d</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">.</span><span class="nf">SetReadDeadline</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">d</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nx">WriteTimeout</span><span class="p">;</span> <span class="nx">d</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">.</span><span class="nf">SetWriteDeadline</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tlsConn</span><span class="p">.</span><span class="nf">Handshake</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// If the handshake failed due to the client not speaking
</span><span class="c1"></span>			<span class="c1">// TLS, assume they&#39;re speaking plaintext HTTP and write a
</span><span class="c1"></span>			<span class="c1">// 400 response on the TLS conn&#39;s underlying net.Conn.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">re</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">tls</span><span class="p">.</span><span class="nx">RecordHeaderError</span><span class="p">);</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">re</span><span class="p">.</span><span class="nx">Conn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nf">tlsRecordHeaderLooksLikeHTTP</span><span class="p">(</span><span class="nx">re</span><span class="p">.</span><span class="nx">RecordHeader</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">re</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="s">&#34;HTTP/1.0 400 Bad Request\r\n\r\nClient sent an HTTP request to an HTTPS server.\n&#34;</span><span class="p">)</span>
				<span class="nx">re</span><span class="p">.</span><span class="nx">Conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">logf</span><span class="p">(</span><span class="s">&#34;http: TLS handshake error from %s: %v&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">.</span><span class="nf">RemoteAddr</span><span class="p">(),</span> <span class="nx">err</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">tlsState</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">tls</span><span class="p">.</span><span class="nx">ConnectionState</span><span class="p">)</span>
		<span class="o">*</span><span class="nx">c</span><span class="p">.</span><span class="nx">tlsState</span> <span class="p">=</span> <span class="nx">tlsConn</span><span class="p">.</span><span class="nf">ConnectionState</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">proto</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tlsState</span><span class="p">.</span><span class="nx">NegotiatedProtocol</span><span class="p">;</span> <span class="nf">validNextProto</span><span class="p">(</span><span class="nx">proto</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nx">TLSNextProto</span><span class="p">[</span><span class="nx">proto</span><span class="p">];</span> <span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">h</span> <span class="o">:=</span> <span class="nx">initALPNRequest</span><span class="p">{</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">tlsConn</span><span class="p">,</span> <span class="nx">serverHandler</span><span class="p">{</span><span class="nx">c</span><span class="p">.</span><span class="nx">server</span><span class="p">}}</span>
				<span class="nf">fn</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">server</span><span class="p">,</span> <span class="nx">tlsConn</span><span class="p">,</span> <span class="nx">h</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// HTTP/1.x from here on.
</span><span class="c1"></span>
	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancelCtx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">cancelCtx</span> <span class="p">=</span> <span class="nx">cancelCtx</span>
	<span class="k">defer</span> <span class="nf">cancelCtx</span><span class="p">()</span>

	<span class="nx">c</span><span class="p">.</span><span class="nx">r</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">connReader</span><span class="p">{</span><span class="nx">conn</span><span class="p">:</span> <span class="nx">c</span><span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">bufr</span> <span class="p">=</span> <span class="nf">newBufioReader</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">bufw</span> <span class="p">=</span> <span class="nf">newBufioWriterSize</span><span class="p">(</span><span class="nx">checkConnErrorWriter</span><span class="p">{</span><span class="nx">c</span><span class="p">},</span> <span class="mi">4</span><span class="o">&lt;&lt;</span><span class="mi">10</span><span class="p">)</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">w</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">readRequest</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nx">remain</span> <span class="o">!=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">initialReadLimitSize</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// If we read any bytes off the wire, we&#39;re active.
</span><span class="c1"></span>			<span class="nx">c</span><span class="p">.</span><span class="nf">setState</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">,</span> <span class="nx">StateActive</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="kd">const</span> <span class="nx">errorHeaders</span> <span class="p">=</span> <span class="s">&#34;\r\nContent-Type: text/plain; charset=utf-8\r\nConnection: close\r\n\r\n&#34;</span>

			<span class="k">switch</span> <span class="p">{</span>
			<span class="k">case</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">errTooLarge</span><span class="p">:</span>
				<span class="c1">// Their HTTP client may or may not be
</span><span class="c1"></span>				<span class="c1">// able to read this if we&#39;re
</span><span class="c1"></span>				<span class="c1">// responding to them and hanging up
</span><span class="c1"></span>				<span class="c1">// while they&#39;re still writing their
</span><span class="c1"></span>				<span class="c1">// request. Undefined behavior.
</span><span class="c1"></span>				<span class="kd">const</span> <span class="nx">publicErr</span> <span class="p">=</span> <span class="s">&#34;431 Request Header Fields Too Large&#34;</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">,</span> <span class="s">&#34;HTTP/1.1 &#34;</span><span class="o">+</span><span class="nx">publicErr</span><span class="o">+</span><span class="nx">errorHeaders</span><span class="o">+</span><span class="nx">publicErr</span><span class="p">)</span>
				<span class="nx">c</span><span class="p">.</span><span class="nf">closeWriteAndWait</span><span class="p">()</span>
				<span class="k">return</span>

			<span class="k">case</span> <span class="nf">isUnsupportedTEError</span><span class="p">(</span><span class="nx">err</span><span class="p">):</span>
				<span class="c1">// Respond as per RFC 7230 Section 3.3.1 which says,
</span><span class="c1"></span>				<span class="c1">//      A server that receives a request message with a
</span><span class="c1"></span>				<span class="c1">//      transfer coding it does not understand SHOULD
</span><span class="c1"></span>				<span class="c1">//      respond with 501 (Unimplemented).
</span><span class="c1"></span>				<span class="nx">code</span> <span class="o">:=</span> <span class="nx">StatusNotImplemented</span>

				<span class="c1">// We purposefully aren&#39;t echoing back the transfer-encoding&#39;s value,
</span><span class="c1"></span>				<span class="c1">// so as to mitigate the risk of cross side scripting by an attacker.
</span><span class="c1"></span>				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">,</span> <span class="s">&#34;HTTP/1.1 %d %s%sUnsupported transfer encoding&#34;</span><span class="p">,</span> <span class="nx">code</span><span class="p">,</span> <span class="nf">StatusText</span><span class="p">(</span><span class="nx">code</span><span class="p">),</span> <span class="nx">errorHeaders</span><span class="p">)</span>
				<span class="k">return</span>

			<span class="k">case</span> <span class="nf">isCommonNetReadError</span><span class="p">(</span><span class="nx">err</span><span class="p">):</span>
				<span class="k">return</span> <span class="c1">// don&#39;t reply
</span><span class="c1"></span>
			<span class="k">default</span><span class="p">:</span>
				<span class="nx">publicErr</span> <span class="o">:=</span> <span class="s">&#34;400 Bad Request&#34;</span>
				<span class="k">if</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">badRequestError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
					<span class="nx">publicErr</span> <span class="p">=</span> <span class="nx">publicErr</span> <span class="o">+</span> <span class="s">&#34;: &#34;</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
				<span class="p">}</span>

				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">,</span> <span class="s">&#34;HTTP/1.1 &#34;</span><span class="o">+</span><span class="nx">publicErr</span><span class="o">+</span><span class="nx">errorHeaders</span><span class="o">+</span><span class="nx">publicErr</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// Expect 100 Continue support
</span><span class="c1"></span>		<span class="nx">req</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">req</span>
		<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nf">expectsContinue</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nf">ProtoAtLeast</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">req</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// Wrap the Body reader with one that replies on the connection
</span><span class="c1"></span>				<span class="nx">req</span><span class="p">.</span><span class="nx">Body</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">expectContinueReader</span><span class="p">{</span><span class="nx">readCloser</span><span class="p">:</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span> <span class="nx">resp</span><span class="p">:</span> <span class="nx">w</span><span class="p">}</span>
				<span class="nx">w</span><span class="p">.</span><span class="nx">canWriteContinue</span><span class="p">.</span><span class="nf">setTrue</span><span class="p">()</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s">&#34;Expect&#34;</span><span class="p">)</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="nx">w</span><span class="p">.</span><span class="nf">sendExpectationFailed</span><span class="p">()</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="nx">c</span><span class="p">.</span><span class="nx">curReq</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>

		<span class="k">if</span> <span class="nf">requestBodyRemains</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">registerOnHitEOF</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nx">startBackgroundRead</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">w</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nf">startBackgroundRead</span><span class="p">()</span>
		<span class="p">}</span>

		<span class="c1">// HTTP cannot have multiple simultaneous active requests.[*]
</span><span class="c1"></span>		<span class="c1">// Until the server replies to this request, it can&#39;t read another,
</span><span class="c1"></span>		<span class="c1">// so we might as well run the handler in this goroutine.
</span><span class="c1"></span>		<span class="c1">// [*] Not strictly true: HTTP pipelining. We could let them all process
</span><span class="c1"></span>		<span class="c1">// in parallel even if their responses need to be serialized.
</span><span class="c1"></span>		<span class="c1">// But we&#39;re not going to implement HTTP pipelining because it
</span><span class="c1"></span>		<span class="c1">// was never deployed in the wild and the answer is HTTP/2.
</span><span class="c1"></span>		<span class="nx">serverHandler</span><span class="p">{</span><span class="nx">c</span><span class="p">.</span><span class="nx">server</span><span class="p">}.</span><span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">req</span><span class="p">)</span>
		<span class="nx">w</span><span class="p">.</span><span class="nf">cancelCtx</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nf">hijacked</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">w</span><span class="p">.</span><span class="nf">finishRequest</span><span class="p">()</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">w</span><span class="p">.</span><span class="nf">shouldReuseConnection</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">w</span><span class="p">.</span><span class="nx">requestBodyLimitHit</span> <span class="o">||</span> <span class="nx">w</span><span class="p">.</span><span class="nf">closedRequestBodyEarly</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">c</span><span class="p">.</span><span class="nf">closeWriteAndWait</span><span class="p">()</span>
			<span class="p">}</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">setState</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">,</span> <span class="nx">StateIdle</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">curReq</span><span class="p">.</span><span class="nf">Store</span><span class="p">((</span><span class="o">*</span><span class="nx">response</span><span class="p">)(</span><span class="kc">nil</span><span class="p">))</span>

		<span class="k">if</span> <span class="p">!</span><span class="nx">w</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">doKeepAlives</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// We&#39;re in shutdown mode. We might&#39;ve replied
</span><span class="c1"></span>			<span class="c1">// to the user without &#34;Connection: close&#34; and
</span><span class="c1"></span>			<span class="c1">// they might think they can send another
</span><span class="c1"></span>			<span class="c1">// request, but such is life with HTTP/1.1.
</span><span class="c1"></span>			<span class="k">return</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">d</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">idleTimeout</span><span class="p">();</span> <span class="nx">d</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">.</span><span class="nf">SetReadDeadline</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">bufr</span><span class="p">.</span><span class="nf">Peek</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">.</span><span class="nf">SetReadDeadline</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">{})</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码片段包含读取 HTTP 请求、调用 Handler 处理 HTTP 请求以及调用完成该请求。读取 HTTP 请求会调用 net/http.Conn.readRequest，该方法会从连接中获取 HTTP 请求并构建一个实现了 net/http.ResponseWriter 接口的变量 net/http.response，向该结构体写入的数据都会被转发到它持有的缓冲区中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// either dataB or dataS is non-zero.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">response</span><span class="p">)</span> <span class="nf">write</span><span class="p">(</span><span class="nx">lenData</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">dataB</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">dataS</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">w</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nf">hijacked</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">lenData</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">caller</span> <span class="o">:=</span> <span class="nf">relevantCaller</span><span class="p">()</span>
			<span class="nx">w</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">logf</span><span class="p">(</span><span class="s">&#34;http: response.Write on hijacked connection from %s (%s:%d)&#34;</span><span class="p">,</span> <span class="nx">caller</span><span class="p">.</span><span class="nx">Function</span><span class="p">,</span> <span class="nx">path</span><span class="p">.</span><span class="nf">Base</span><span class="p">(</span><span class="nx">caller</span><span class="p">.</span><span class="nx">File</span><span class="p">),</span> <span class="nx">caller</span><span class="p">.</span><span class="nx">Line</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">ErrHijacked</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">w</span><span class="p">.</span><span class="nx">canWriteContinue</span><span class="p">.</span><span class="nf">isSet</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// Body reader wants to write 100 Continue but hasn&#39;t yet.
</span><span class="c1"></span>		<span class="c1">// Tell it not to. The store must be done while holding the lock
</span><span class="c1"></span>		<span class="c1">// because the lock makes sure that there is not an active write
</span><span class="c1"></span>		<span class="c1">// this very moment.
</span><span class="c1"></span>		<span class="nx">w</span><span class="p">.</span><span class="nx">writeContinueMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="nx">w</span><span class="p">.</span><span class="nx">canWriteContinue</span><span class="p">.</span><span class="nf">setFalse</span><span class="p">()</span>
		<span class="nx">w</span><span class="p">.</span><span class="nx">writeContinueMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">w</span><span class="p">.</span><span class="nx">wroteHeader</span> <span class="p">{</span>
		<span class="nx">w</span><span class="p">.</span><span class="nf">WriteHeader</span><span class="p">(</span><span class="nx">StatusOK</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">lenData</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">w</span><span class="p">.</span><span class="nf">bodyAllowed</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">ErrBodyNotAllowed</span>
	<span class="p">}</span>

	<span class="nx">w</span><span class="p">.</span><span class="nx">written</span> <span class="o">+=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">lenData</span><span class="p">)</span> <span class="c1">// ignoring errors, for errorKludge
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">w</span><span class="p">.</span><span class="nx">contentLength</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">w</span><span class="p">.</span><span class="nx">written</span> <span class="p">&gt;</span> <span class="nx">w</span><span class="p">.</span><span class="nx">contentLength</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">ErrContentLength</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">dataB</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">w</span><span class="p">.</span><span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">dataB</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">w</span><span class="p">.</span><span class="nx">w</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">dataS</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>解析了 HTTP 请求并初始化 net/http.ResponseWriter 之后，我们就可以调用 net/http.serverHandler.ServeHTTP 查找处理器来处理 HTTP 请求了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">serverHandler</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">srv</span> <span class="o">*</span><span class="nx">Server</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sh</span> <span class="nx">serverHandler</span><span class="p">)</span> <span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">rw</span> <span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">handler</span> <span class="o">:=</span> <span class="nx">sh</span><span class="p">.</span><span class="nx">srv</span><span class="p">.</span><span class="nx">Handler</span>
	<span class="k">if</span> <span class="nx">handler</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">handler</span> <span class="p">=</span> <span class="nx">DefaultServeMux</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">RequestURI</span> <span class="o">==</span> <span class="s">&#34;*&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Method</span> <span class="o">==</span> <span class="s">&#34;OPTIONS&#34;</span> <span class="p">{</span>
		<span class="nx">handler</span> <span class="p">=</span> <span class="nx">globalOptionsHandler</span><span class="p">{}</span>
	<span class="p">}</span>
	<span class="nx">handler</span><span class="p">.</span><span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">rw</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果当前的 HTTP 服务器中不包含任何处理器，我们会使用默认的 net/http.DefaultServeMux 处理外部的 HTTP 请求。</p>
<p>net/http.ServeMux 是一个 HTTP 请求的多路复用器，它可以接收外部的 HTTP 请求、根据请求的 URL 匹配并调用最合适的处理器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">mux</span> <span class="o">*</span><span class="nx">ServeMux</span><span class="p">)</span> <span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span><span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">mux</span><span class="p">.</span><span class="nf">Handler</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>经过一系列的函数调用，上述过程最终会调用 HTTP 服务器的 net/http.ServerMux.match，该方法会遍历前面注册过的路由表并根据特定规则进行匹配：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">mux</span> <span class="o">*</span><span class="nx">ServeMux</span><span class="p">)</span> <span class="nf">match</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">h</span> <span class="nx">Handler</span><span class="p">,</span> <span class="nx">pattern</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">mux</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">path</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">v</span><span class="p">.</span><span class="nx">h</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">pattern</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">mux</span><span class="p">.</span><span class="nx">es</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">pattern</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">h</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">pattern</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果请求的路径和路由中的表项匹配成功，我们会调用表项中对应的处理器，处理器中包含的业务逻辑会通过 net/http.ResponseWriter 构建 HTTP 请求对应的响应并通过 TCP 连接发送回客户端。</p>
<h2 id="总结">总结</h2>
<p>Go 语言的 HTTP 标准库提供了非常丰富的功能，很多语言的标准库只提供了最基本的功能，实现 HTTP 客户端和服务器往往都需要借助其他开源的框架，但是 Go 语言的很多项目都会直接使用标准库实现 HTTP 服务器，这也从侧面说明了 Go 语言标准库的价值。</p>
<h2 id="参考">参考</h2>
<p><a href="https://draveness.me/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/#922-%E5%AE%A2%E6%88%B7%E7%AB%AF">9.2 HTTP</a>
<a href="https://www.cnblogs.com/charlieroro/p/11409153.html">详解golang net之transport</a>
<a href="https://segmentfault.com/a/1190000023676010">Golang 你一定要懂的连接池</a>
<a href="https://www.debugger.wiki/article/html/1599821640367863">go http请求流程分析</a>
<a href="https://blog.csdn.net/qq_21514303/article/details/87794750">golang http client 连接池</a>
<a href="https://cloud.tencent.com/developer/article/1768496">Go http client 连接池不复用的问题</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-01-29
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go/">Go</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/vscode%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95go%E4%BB%A3%E7%A0%81/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Vscode如何调试Go代码</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E4%BC%AA%E5%85%B1%E4%BA%AB/">
            <span class="next-text nav-default">内存模型与伪共享</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
