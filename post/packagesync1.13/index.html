<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>package:sync(1.13) | Forz Blog</title>
<meta name="keywords" content="Go标准库" />
<meta name="description" content="type Cond Cond实现了一个条件变量，一个等待或宣布事件发生的goroutines的集合点。 每个Cond都有一个相关的Locker L（通常是* Mu">
<meta name="author" content="">
<link rel="canonical" href="/post/packagesync1.13/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="package:sync(1.13)" />
<meta property="og:description" content="type Cond Cond实现了一个条件变量，一个等待或宣布事件发生的goroutines的集合点。 每个Cond都有一个相关的Locker L（通常是* Mu" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/packagesync1.13/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-01-09T20:06:49&#43;00:00" />
<meta property="article:modified_time" content="2019-11-06T14:21:25&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="package:sync(1.13)"/>
<meta name="twitter:description" content="type Cond Cond实现了一个条件变量，一个等待或宣布事件发生的goroutines的集合点。 每个Cond都有一个相关的Locker L（通常是* Mu"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "package:sync(1.13)",
      "item": "/post/packagesync1.13/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "package:sync(1.13)",
  "name": "package:sync(1.13)",
  "description": "type Cond Cond实现了一个条件变量，一个等待或宣布事件发生的goroutines的集合点。 每个Cond都有一个相关的Locker L（通常是* Mu",
  "keywords": [
    "Go标准库"
  ],
  "articleBody": "type Cond Cond实现了一个条件变量，一个等待或宣布事件发生的goroutines的集合点。\n每个Cond都有一个相关的Locker L（通常是* Mutex或* RWMutex），它必须在改变条件时或者调用Wait方法时保持锁定。Cond可以创建为其他结构体的字段.\nCond在第一次使用后不能被拷贝。\n1 2 3 4 5 6  type Cond struct { // 在观测或更改条件时L会冻结  L Locker // 包含隐藏或非导出字段 }   func NewCond 1  func NewCond（l Locker）* Cond   NewCond用Locker l返回一个新的Cond。\nfunc (*Cond) Broadcast 1  func (c *Cond) Broadcast()   Broadcast唤醒所有等待c的goroutine。\n调用者在调用本方法时，建议（但并非必须）保持c.L的锁定。\nfunc (*Cond) Signal 1  func (c *Cond) Signal()   Signal唤醒等待c的一个线程（如果存在）。调用者在调用本方法时，建议（但并非必须）保持c.L的锁定。\nfunc (*Cond) Wait 1  func (c *Cond) Wait()   Wait自行解锁c.L并阻塞当前线程，在之后线程恢复执行时，Wait方法会在返回前锁定c.L。如果锁定成功，它就会唤醒那个被它阻塞的Goroutine。否则，该方法会等待下一个通知，那个Goroutine也会继续被阻塞。\n和其他系统不同，Wait除非被Broadcast或者Signal唤醒，不会主动返回。\n因为线程中Wait方法是第一个恢复执行的，而此时c.L未加锁。调用者不应假设Wait恢复时条件已满足，可能生产者还没有将条件满足,所以,调用者应在循环中等待：\n1 2 3 4 5 6  c.L.Lock() for !condition() { c.Wait() } ... make use of condition ... c.L.Unlock()   type Locker Locker接口代表一个可以加锁和解锁的对象。\n1 2 3 4  type Locker interface { Lock() Unlock() }   type Map Map类似于Go map [interface {}] interface {}，但对于多个goroutine并发使用而没有额外的锁定或协调是安全的。加载，存储和删除以分摊的常量时间运行。\nMap类型是专门的。大多数代码应该使用普通的Go映射，使用单独的锁定或协调，以获得更好的类型安全性，并使其更容易维护其他不变量以及map内容。\nMap类型针对两种常见用例进行了优化：（1）当给定键的条目只写入一次但是多次读取时，如仅在增长的缓存中，或者（2）当多个goroutine读取，写入和覆盖不相交的密钥集的条目。在这两种情况下，与使用单独的互斥锁或RWMutex配对的Gomap相比，使用Map可以显着减少锁争用。\n零值map是空的，可以直接使用。首次使用后不得复制map。\n1 2 3  type Map struct { // contains filtered or unexported fields }   func (*Map) Delete 1.9 1  func (m *Map) Delete(key interface{})   Delete 删除键的值。\nfunc (*Map) Load 1.9 1  func (m *Map) Load(key interface{}) (value interface{}, ok bool)   Load返回存储在映射中的值的值，如果没有值，则返回nil。ok结果表明是否在map中找到了值。\nfunc (*Map) LoadOrStore 1.9 1  func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)   LoadOrStore返回键的现有值（如果存在）。否则，它将存储并返回给定的值。如果已加载该值，则加载的结果为true；如果已存储，则为false。\nfunc (*Map) Range 1.9 1  func (m *Map) Range(f func(key, value interface{}) bool)   Range对映射中存在的每个键和值按顺序调用f。如果f返回false，则range将停止迭代。\nRange不一定对应于Map内容的任何一致快照：任何key不会被多次访问，但如果同时存储或删除任何key的值，Range可以反映Range调用期间任何点的该key的任何映射。\n即使f在常数调用之后返回false，Range的时间复杂度也是map中元素数量的O（N）。\nfunc (*Map) Store 1.9 1  func (m *Map) Store(key, value interface{})   Store设置key的value。\ntype Mutex 互斥锁是一种互斥锁。互斥锁的零值是解锁的互斥锁。\n首次使用后，不得复制互斥锁。\n1 2 3  type Mutex struct { // contains filtered or unexported fields }   func (*Mutex) Lock 1  func (m *Mutex) Lock()   Lock为m上锁。如果锁已被使用，则调用goroutine将阻塞，直到互斥锁可用。\nfunc (*Mutex) Unlock 1  func (m *Mutex) Unlock()   Lock为m解锁。如果在进入解锁时未锁定m，则为运行时错误。\n锁定的互斥锁与特定的goroutine无关。允许一个goroutine锁定互斥锁，然后安排另一个goroutine解锁它。\ntype Once Once是一个只执行一个动作的对象。\n1 2 3  type Once struct { // contains filtered or unexported fields }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  package main import ( \"fmt\" \"sync\" ) func main() { var once sync.Once onceBody := func() { fmt.Println(\"Only once\") } done := make(chan bool) for i := 0; i  10; i++ { go func() { once.Do(onceBody) done  true }() } for i := 0; i  10; i++ { done } }   func (*Once) Do 1  func (o *Once) Do(f func())   当且仅当第一次为此实例一次调用Do时，才调用函数f。换句话说，给定\n1  var once Once   如果once.Do(f)被多次调用，只有第一次调用会执行f，即使f每次调用Do 提供的f值不同。需要给每个要执行仅一次的函数都建立一个Once类型的实例。\nDo用于必须刚好运行一次的初始化。因为f是没有参数的，因此可能需要使用闭包来提供给Do方法调用：\n1  config.once.Do(func() { config.init(filename) })   因为只有f返回后Do方法才会返回，f若引起了Do的调用，会导致死锁。\n如果出现panic，Do认为它已返回；Do的未来调用将不调用而返回。\ntype Pool 1.3 Pool是一个可以分别存取的临时对象的集合。\nPool中保存的任何item都可能随时不做通告的释放掉。如果Pool持有该对象的唯一引用，这个item就可能被回收。\nPool可以安全的被多个线程同时使用。\nPool的目的是缓存申请但未使用的item用于之后的重用，以减轻GC的压力。也就是说，让创建高效而线程安全的空闲列表更容易。但Pool并不适用于所有空闲列表。\nPool的合理用法是用于管理一组静静的被多个独立并发线程共享并可能重用的临时item。Pool提供了让多个线程分摊内存申请消耗的方法。\nPool的一个好例子在fmt包里。该Pool维护一个动态大小的临时输出缓存仓库。该仓库会在过载（许多线程活跃的打印时）增大，在沉寂时缩小。\n另一方面，管理着短寿命对象的空闲列表不适合使用Pool，因为这种情况下内存申请消耗不能很好的分配。这时应该由这些对象自己实现空闲列表。\n首次使用后不得复制池。\n1 2 3 4 5 6  type Pool struct { // 可选参数New指定一个函数在Get方法可能返回nil时来生成一个值  // 该参数不能在调用Get方法时被修改  New func() interface{} // 包含隐藏或非导出字段 }   示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  package main import ( \"bytes\" \"io\" \"os\" \"sync\" \"time\" ) var bufPool = sync.Pool{ New: func() interface{} { // The Pool's New function should generally only return pointer \t// types, since a pointer can be put into the return interface \t// value without an allocation: \treturn new(bytes.Buffer) }, } // timeNow is a fake version of time.Now for tests. func timeNow() time.Time { return time.Unix(1136214245, 0) } func Log(w io.Writer, key, val string) { b := bufPool.Get().(*bytes.Buffer) b.Reset() // Replace this with time.Now() in a real logger. \tb.WriteString(timeNow().UTC().Format(time.RFC3339)) b.WriteByte(' ') b.WriteString(key) b.WriteByte('=') b.WriteString(val) w.Write(b.Bytes()) bufPool.Put(b) } func main() { Log(os.Stdout, \"path\", \"/search?q=flowers\") }   func (*Pool) Get 1  func (p *Pool) Get() interface{}   Get方法从池中选择任意一个item，删除其在池中的引用计数，并提供给调用者。Get方法也可能选择无视内存池，将其当作空的。调用者不应认为Get的返回这和传递给Put的值之间有任何关系。\n假使Get方法没有取得item：如p.New非nil，Get返回调用p.New的结果；否则返回nil。\nfunc (*Pool) Put 1  func (p *Pool) Put(x interface{})   Put将x添加到池中。\ntype RWMutex 1 2 3  type RWMutex struct { // 包含隐藏或非导出字段 }   RWMutex是读/写互斥锁。锁可以由任意数量的读者或单个作者持有。RWMutex的零值是解锁的互斥锁。\n首次使用后，不得复制RWMutex。\n如果goroutine持有RWMutex进行读取而另一个goroutine可能会调用Lock，那么在释放初始读锁之前，goroutine不应该期望能够获取读锁定。特别是，这禁止递归读锁定。这是为了确保锁最终变得可用; 阻止的锁定呼叫会阻止新读者获取锁定。\nfunc (*RWMutex) Lock 1  func (rw *RWMutex) Lock()   锁定锁定用于写入。如果锁已经锁定以进行读取或写入，则锁定将锁定，直到锁定可用。\nfunc (*RWMutex) RLock 1  func (rw *RWMutex) RLock()   RLock锁定rw进行阅读。\n它不应该用于递归读锁定; 阻止的锁定呼叫会阻止新读者获取锁定。请参阅RWMutex类型的文档。\nfunc (*RWMutex) RLocker 1  func (rw *RWMutex) RLocker() Locker   RLocker返回一个Locker接口，通过调用rw.RLock和rw.RUnlock来实现Lock和Unlock方法。\nfunc (*RWMutex) RUnlock 1  func (rw *RWMutex) RUnlock()   RUnlock撤消单个RLock调用; 它不会影响其他同时读者。如果在进入RUnlock时没有锁定rw进行读取，则会出现运行时错误。\nfunc (*RWMutex) Unlock 1  func (rw *RWMutex) Unlock()   Unlock 解锁rw进行写。如果在解锁时没有锁定rw以进行写入，则会出现运行时错误。\n与互斥锁一样，锁定的RWMutex与特定的goroutine无关。一个goroutine可以RLock（锁定）RWMutex，然后安排另一个goroutine到RUnlock（解锁）它。\ntype WaitGroup WaitGroup等待完成goroutine的集合。主goroutine调用Add来设置要等待的goroutines的数量。然后每个goroutine运行并在完成后调用Done。同时，Wait可以用来阻止所有goroutine完成。\n首次使用后，不得复制WaitGroup。\n1 2 3  type WaitGroup struct { // contains filtered or unexported fields }   示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  package main import ( \"sync\" ) type httpPkg struct{} func (httpPkg) Get(url string) {} var http httpPkg func main() { var wg sync.WaitGroup var urls = []string{ \"http://www.golang.org/\", \"http://www.google.com/\", \"http://www.somestupidname.com/\", } for _, url := range urls { // Increment the WaitGroup counter. \twg.Add(1) // Launch a goroutine to fetch the URL. \tgo func(url string) { // Decrement the counter when the goroutine completes. \tdefer wg.Done() // Fetch the URL. \thttp.Get(url) }(url) } // Wait for all HTTP fetches to complete. \twg.Wait() }   func (*WaitGroup) Add 1  func (wg *WaitGroup) Add(delta int)   添加将可能为负的delta添加到WaitGroup计数器。如果计数器变为零，则释放在等待时阻止的所有goroutine。如果计数器变为负数，则添加恐慌。\nAdd方法向内部计数加上delta，delta可以是负数；如果内部计数器变为0，Wait方法阻塞等待的所有线程都会释放，如果计数器小于0，方法panic。注意Add加上正数的调用应在Wait之前，否则Wait可能只会等待很少的线程。一般来说本方法应在创建新的线程或者其他应等待的事件之前调用。\nfunc (*WaitGroup) Done 1  func (wg *WaitGroup) Done()   Done方法减少WaitGroup计数器的值，应在线程的最后执行\nfunc (*WaitGroup) Wait 1  func (wg *WaitGroup) Wait()   Wait方法阻塞直到WaitGroup计数器减为0。\n使用场景 Cond 条件变量sync.Cond本质上是一些正在等待某个条件的线程的同步机制。条件变量的作用并不是保证在同一时刻仅有一个线程访问某一个共享数据，而是在对应的共享数据的状态发生变化时，通知其他因此而被阻塞的线程。\nsync.Cond 主要实现一个条件变量，假如 goroutine A 执行前需要等待另外的goroutine B 的通知，那边处于等待的goroutine A 会保存在一个通知列表，当某个时刻状态改变时负责通知的goroutine B 通过对条件变量通知的方式（Broadcast，Signal）来通知处于等待条件变量的goroutine A, 这样便可实现一种“消息通知”的同步机制。\n下面这个例子，可以比较好的说明Cond的使用方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  package main import ( \"fmt\" \"sync\" \"time\" ) var sharedRsc = false func main() { var wg sync.WaitGroup wg.Add(2) m := sync.Mutex{} c := sync.NewCond(\u0026m) go func() { // this go routine wait for changes to the sharedRsc \tc.L.Lock() for sharedRsc == false { fmt.Println(\"goroutine1 wait\") c.Wait() } fmt.Println(\"goroutine1\", sharedRsc) c.L.Unlock() wg.Done() }() go func() { // this go routine wait for changes to the sharedRsc \tc.L.Lock() for sharedRsc == false { fmt.Println(\"goroutine2 wait\") c.Wait() } fmt.Println(\"goroutine2\", sharedRsc) c.L.Unlock() wg.Done() }() // this one writes changes to sharedRsc \ttime.Sleep(2 * time.Second) c.L.Lock() fmt.Println(\"main goroutine ready\") sharedRsc = true c.Broadcast() fmt.Println(\"main goroutine broadcast\") c.L.Unlock() wg.Wait() }   执行结果如下。\n1 2 3 4 5 6  goroutine1 wait goroutine2 wait main goroutine ready main goroutine broadcast goroutine2 true goroutine1 true   goroutine1和goroutine2进入Wait状态，在main goroutine在2s后资源满足，发出broadcast信号后，从Wait中恢复并判断条件是否确实已经满足(sharedRsc不为空)，满足则消费条件，并解锁wg.Done()。\n如果我们删除main goroutine中的2s延时。执行结果如下。\n1 2 3 4  main goroutine ready main goroutine broadcast goroutine2 true goroutine1 true   很有意思，两个goroutine都没有进入Wait状态。\n原因是，main goroutine执行的更快，在goroutine1/goroutine2加锁之前就已经获得了锁，并完成了修改sharedRsc、发出Broadcast信号。当子goroutine调用Wait之前检验condition时，条件已经满足，因此就没有必要再去调用Wait了。\n如果我们在子goroutine中不做校验呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  package main import ( \"fmt\" \"sync\" ) var sharedRsc = false func main() { var wg sync.WaitGroup wg.Add(2) m := sync.Mutex{} c := sync.NewCond(\u0026m) go func() { // this go routine wait for changes to the sharedRsc \tc.L.Lock() for sharedRsc == false { fmt.Println(\"goroutine1 wait\") c.Wait() } fmt.Println(\"goroutine1\", sharedRsc) c.L.Unlock() wg.Done() }() go func() { // this go routine wait for changes to the sharedRsc \tc.L.Lock() fmt.Println(\"goroutine2 wait\") c.Wait() fmt.Println(\"goroutine2\", sharedRsc) c.L.Unlock() wg.Done() }() // this one writes changes to sharedRsc \tc.L.Lock() fmt.Println(\"main goroutine ready\") sharedRsc = true c.Broadcast() fmt.Println(\"main goroutine broadcast\") c.L.Unlock() wg.Wait() }   我们会得到1个死锁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  main goroutine ready main goroutine broadcast goroutine2 wait goroutine1 true fatal error: all goroutines are asleep - deadlock! goroutine 1 [semacquire]: sync.runtime_Semacquire(0x414028, 0x19) /usr/local/go/src/runtime/sema.go:56 +0x40 sync.(*WaitGroup).Wait(0x414020, 0x40c108) /usr/local/go/src/sync/waitgroup.go:130 +0x60 main.main() /tmp/sandbox947808816/prog.go:44 +0x2c0 goroutine 6 [sync.Cond.Wait]: runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:307 sync.runtime_notifyListWait(0x43e268, 0x0) /usr/local/go/src/runtime/sema.go:510 +0x120 sync.(*Cond).Wait(0x43e260, 0x40c108) /usr/local/go/src/sync/cond.go:56 +0xe0 main.main.func2(0x43e260, 0x414020) /tmp/sandbox947808816/prog.go:31 +0xc0 created by main.main /tmp/sandbox947808816/prog.go:27 +0x140   为什么呢？\nmain goroutine（goroutine 1）先执行，并停留在 wg.Wait()中，等待子goroutine的wg.Done()；而子goroutine（goroutine 6）没有判断条件直接调用了cond.Wait。\n我们知道cond.Wait会释放锁并等待其他goroutine调用Broadcast或者Signal来通知其恢复执行，除此之外没有其他的恢复途径。但此时main goroutine已经调用了Broadcast并进入了等待状态，没有任何goroutine会去拯救还在cond.Wait中的子goroutine了，而该子goroutine也没有机会调用wg.Done()去恢复main goroutine，造成了死锁。\n因此，一定要注意，Broadcast必须要在所有的Wait之后（当然了，可以通过条件判断来决定要不要进Wait）。\n我们来看看k8s中使用Cond实现的FIFO，它是如何处理条件的消费的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  func (f *FIFO) Pop(process PopProcessFunc) (interface{}, error) { f.lock.Lock() defer f.lock.Unlock() for { for len(f.queue) == 0 { // When the queue is empty, invocation of Pop() is blocked until new item is enqueued. \t// When Close() is called, the f.closed is set and the condition is broadcasted. \t// Which causes this loop to continue and return from the Pop(). \tif f.IsClosed() { return nil, FIFOClosedError } f.cond.Wait() } id := f.queue[0] f.queue = f.queue[1:] ... } } func NewFIFO(keyFunc KeyFunc) *FIFO { f := \u0026FIFO{ items: map[string]interface{}{}, queue: []string{}, keyFunc: keyFunc, } f.cond.L = \u0026f.lock return f }   Cond共用了FIFO的lock，在Pop时，会先加锁 f.lock.Lock()，而在f.cond.Wait()前，会先检查len(f.queue)是否为0，防止2种情况：\n 如果wait晚于broadcast/signal,此时条件已经满足，不需要wait 唤醒时满足，但被其他goroutine捷足先登，阻塞在f.lock的加锁中；当获得了锁，加锁成功以后，f.queue已经被消费为空，直接访问f.queue[0]会访问越界。  总结 当使用sync.Cond的时候有以下几点要注意的：\n 一定要在调用cond.Wait方法前，锁定与之关联的读写锁,不然会panic 一定不要忘记在cond.Wait后，若数据已经处理完毕，在返回前要对与之关联的读写锁进行解锁。否则其它被唤醒的 gouroutine 将没法继续执行。 一定要通过条件判断来决定要不要进Wait, 唤醒是从等待队列中按照顺序唤醒，先进入等待队列，先被唤醒。  wait与sleep 可能你会说,那我这样写不也可以吗\n1 2 3 4  for !condition{ continue //time.sleep(time.second*3) }   但是你这样实际上cpu还是被当前的goroutine占据执行.但是wait会暂停当前的goroutine直到条件满足时发送一个signal或者broadcast给它。\n参考:\nhttps://ieevee.com/tech/2019/06/15/cond.html#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90\nhttps://www.kancloud.cn/digest/batu-go/153536\nhttps://www.dazhuanlan.com/2019/10/05/5d97f700bd748/\n",
  "wordCount" : "6021",
  "inLanguage": "zh-cn",
  "datePublished": "2019-01-09T20:06:49Z",
  "dateModified": "2019-11-06T14:21:25+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/packagesync1.13/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      package:sync(1.13)
    </h1>
    <div class="post-meta">January 9, 2019
</div>
  </header> 
  <div class="post-content"><h1 id="type-cond">type Cond<a hidden class="anchor" aria-hidden="true" href="#type-cond">#</a></h1>
<p>Cond实现了一个条件变量，一个等待或宣布事件发生的goroutines的集合点。</p>
<p>每个Cond都有一个相关的Locker L（通常是* Mutex或* RWMutex），它必须在改变条件时或者调用Wait方法时保持锁定。Cond可以创建为其他结构体的字段.</p>
<p>Cond在第一次使用后不能被拷贝。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Cond</span> <span class="kd">struct</span> <span class="p">{</span>

        <span class="c1">// 在观测或更改条件时L会冻结
</span><span class="c1"></span>        <span class="nx">L</span> <span class="nx">Locker</span>
        <span class="c1">// 包含隐藏或非导出字段
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-newcond">func NewCond<a hidden class="anchor" aria-hidden="true" href="#func-newcond">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nx">NewCond</span><span class="err">（</span><span class="nx">l</span> <span class="nx">Locker</span><span class="err">）</span><span class="o">*</span> <span class="nx">Cond</span>
</code></pre></td></tr></table>
</div>
</div><p>NewCond用Locker l返回一个新的Cond。</p>
<h2 id="func-cond-broadcast">func (*Cond) Broadcast<a hidden class="anchor" aria-hidden="true" href="#func-cond-broadcast">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cond</span><span class="p">)</span> <span class="nf">Broadcast</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>Broadcast唤醒所有等待c的goroutine。</p>
<p>调用者在调用本方法时，建议（但并非必须）保持c.L的锁定。</p>
<h2 id="func-cond-signal">func (*Cond) Signal<a hidden class="anchor" aria-hidden="true" href="#func-cond-signal">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cond</span><span class="p">)</span> <span class="nf">Signal</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>Signal唤醒等待c的一个线程（如果存在）。调用者在调用本方法时，建议（但并非必须）保持c.L的锁定。</p>
<h2 id="func-cond-wait">func (*Cond) Wait<a hidden class="anchor" aria-hidden="true" href="#func-cond-wait">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cond</span><span class="p">)</span> <span class="nf">Wait</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>Wait自行解锁c.L并阻塞当前线程，在之后线程恢复执行时，Wait方法会在返回前锁定c.L。如果锁定成功，它就会唤醒那个被它阻塞的Goroutine。否则，该方法会等待下一个通知，那个Goroutine也会继续被阻塞。</p>
<p>和其他系统不同，Wait除非被Broadcast或者Signal唤醒，不会主动返回。</p>
<p>因为线程中Wait方法是第一个恢复执行的，而此时c.L未加锁。调用者不应假设Wait恢复时条件已满足，可能生产者还没有将条件满足,所以,调用者应在循环中等待：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
<span class="k">for</span> <span class="p">!</span><span class="nf">condition</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">c</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
<span class="o">...</span> <span class="nx">make</span> <span class="nx">use</span> <span class="nx">of</span> <span class="nx">condition</span> <span class="o">...</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="type-locker">type Locker<a hidden class="anchor" aria-hidden="true" href="#type-locker">#</a></h1>
<p>Locker接口代表一个可以加锁和解锁的对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Locker</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Lock</span><span class="p">()</span>
    <span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="type-map">type Map<a hidden class="anchor" aria-hidden="true" href="#type-map">#</a></h1>
<p>Map类似于Go map [interface {}] interface {}，但对于多个goroutine并发使用而没有额外的锁定或协调是安全的。加载，存储和删除以分摊的常量时间运行。</p>
<p>Map类型是专门的。大多数代码应该使用普通的Go映射，使用单独的锁定或协调，以获得更好的类型安全性，并使其更容易维护其他不变量以及map内容。</p>
<p>Map类型针对两种常见用例进行了优化：（1）当给定键的条目只写入一次但是多次读取时，如仅在增长的缓存中，或者（2）当多个goroutine读取，写入和覆盖不相交的密钥集的条目。在这两种情况下，与使用单独的互斥锁或RWMutex配对的Gomap相比，使用Map可以显着减少锁争用。</p>
<p>零值map是空的，可以直接使用。首次使用后不得复制map。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Map</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-map-delete-19">func (*Map) Delete 1.9<a hidden class="anchor" aria-hidden="true" href="#func-map-delete-19">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span>
</code></pre></td></tr></table>
</div>
</div><p>Delete 删除键的值。</p>
<h2 id="func-map-load-19">func (*Map) Load 1.9<a hidden class="anchor" aria-hidden="true" href="#func-map-load-19">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Load</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">value</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Load返回存储在映射中的值的值，如果没有值，则返回nil。ok结果表明是否在map中找到了值。</p>
<h2 id="func-map-loadorstore-19">func (*Map) LoadOrStore 1.9<a hidden class="anchor" aria-hidden="true" href="#func-map-loadorstore-19">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">LoadOrStore</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">actual</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">loaded</span> <span class="kt">bool</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>LoadOrStore返回键的现有值（如果存在）。否则，它将存储并返回给定的值。如果已加载该值，则加载的结果为true；如果已存储，则为false。</p>
<h2 id="func-map-range-19">func (*Map) Range 1.9<a hidden class="anchor" aria-hidden="true" href="#func-map-range-19">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Range</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Range对映射中存在的每个键和值按顺序调用f。如果f返回false，则range将停止迭代。</p>
<p>Range不一定对应于Map内容的任何一致快照：任何key不会被多次访问，但如果同时存储或删除任何key的值，Range可以反映Range调用期间任何点的该key的任何映射。</p>
<p>即使f在常数调用之后返回false，Range的时间复杂度也是map中元素数量的O（N）。</p>
<h2 id="func-map-store-19">func (*Map) Store 1.9<a hidden class="anchor" aria-hidden="true" href="#func-map-store-19">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Store</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span>
</code></pre></td></tr></table>
</div>
</div><p>Store设置key的value。</p>
<h1 id="type-mutex">type Mutex<a hidden class="anchor" aria-hidden="true" href="#type-mutex">#</a></h1>
<p>互斥锁是一种互斥锁。互斥锁的零值是解锁的互斥锁。</p>
<p>首次使用后，不得复制互斥锁。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Mutex</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-mutex-lock">func (*Mutex) Lock<a hidden class="anchor" aria-hidden="true" href="#func-mutex-lock">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">Lock</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>Lock为m上锁。如果锁已被使用，则调用goroutine将阻塞，直到互斥锁可用。</p>
<h2 id="func-mutex-unlock">func (*Mutex) Unlock<a hidden class="anchor" aria-hidden="true" href="#func-mutex-unlock">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">Unlock</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>Lock为m解锁。如果在进入解锁时未锁定m，则为运行时错误。</p>
<p>锁定的互斥锁与特定的goroutine无关。允许一个goroutine锁定互斥锁，然后安排另一个goroutine解锁它。</p>
<h1 id="type-once">type Once<a hidden class="anchor" aria-hidden="true" href="#type-once">#</a></h1>
<p>Once是一个只执行一个动作的对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Once</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">once</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
	<span class="nx">onceBody</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Only once&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">onceBody</span><span class="p">)</span>
			<span class="nx">done</span> <span class="o">&lt;-</span> <span class="kc">true</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="o">&lt;-</span><span class="nx">done</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-once-do">func (*Once) Do<a hidden class="anchor" aria-hidden="true" href="#func-once-do">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span>
</code></pre></td></tr></table>
</div>
</div><p>当且仅当第一次为此实例一次调用Do时，才调用函数f。换句话说，给定</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">once</span> <span class="nx">Once</span>
</code></pre></td></tr></table>
</div>
</div><p>如果once.Do(f)被多次调用，只有第一次调用会执行f，即使f每次调用Do 提供的f值不同。需要给每个要执行仅一次的函数都建立一个Once类型的实例。</p>
<p>Do用于必须刚好运行一次的初始化。因为f是没有参数的，因此可能需要使用闭包来提供给Do方法调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">config</span><span class="p">.</span><span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">config</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span> <span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>因为只有f返回后Do方法才会返回，f若引起了Do的调用，会导致死锁。</p>
<p>如果出现panic，Do认为它已返回；Do的未来调用将不调用而返回。</p>
<h1 id="type-pool-13">type Pool 1.3<a hidden class="anchor" aria-hidden="true" href="#type-pool-13">#</a></h1>
<p>Pool是一个可以分别存取的临时对象的集合。</p>
<p>Pool中保存的任何item都可能随时不做通告的释放掉。如果Pool持有该对象的唯一引用，这个item就可能被回收。</p>
<p>Pool可以安全的被多个线程同时使用。</p>
<p>Pool的目的是缓存申请但未使用的item用于之后的重用，以减轻GC的压力。也就是说，让创建高效而线程安全的空闲列表更容易。但Pool并不适用于所有空闲列表。</p>
<p>Pool的合理用法是用于管理一组静静的被多个独立并发线程共享并可能重用的临时item。Pool提供了让多个线程分摊内存申请消耗的方法。</p>
<p>Pool的一个好例子在fmt包里。该Pool维护一个动态大小的临时输出缓存仓库。该仓库会在过载（许多线程活跃的打印时）增大，在沉寂时缩小。</p>
<p>另一方面，管理着短寿命对象的空闲列表不适合使用Pool，因为这种情况下内存申请消耗不能很好的分配。这时应该由这些对象自己实现空闲列表。</p>
<p>首次使用后不得复制池。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Pool</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 可选参数New指定一个函数在Get方法可能返回nil时来生成一个值
</span><span class="c1"></span>    <span class="c1">// 该参数不能在调用Get方法时被修改
</span><span class="c1"></span>    <span class="nx">New</span> <span class="kd">func</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span>
    <span class="c1">// 包含隐藏或非导出字段
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>示例:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;bytes&#34;</span>
	<span class="s">&#34;io&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">bufPool</span> <span class="p">=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Pool</span><span class="p">{</span>
	<span class="nx">New</span><span class="p">:</span> <span class="kd">func</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
		<span class="c1">// The Pool&#39;s New function should generally only return pointer
</span><span class="c1"></span>		<span class="c1">// types, since a pointer can be put into the return interface
</span><span class="c1"></span>		<span class="c1">// value without an allocation:
</span><span class="c1"></span>		<span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
	<span class="p">},</span>
<span class="p">}</span>

<span class="c1">// timeNow is a fake version of time.Now for tests.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">timeNow</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Unix</span><span class="p">(</span><span class="mi">1136214245</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Log</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="nx">bufPool</span><span class="p">.</span><span class="nf">Get</span><span class="p">().(</span><span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
	<span class="nx">b</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
	<span class="c1">// Replace this with time.Now() in a real logger.
</span><span class="c1"></span>	<span class="nx">b</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nf">timeNow</span><span class="p">().</span><span class="nf">UTC</span><span class="p">().</span><span class="nf">Format</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">RFC3339</span><span class="p">))</span>
	<span class="nx">b</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">)</span>
	<span class="nx">b</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="nx">b</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;=&#39;</span><span class="p">)</span>
	<span class="nx">b</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">())</span>
	<span class="nx">bufPool</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">Log</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="s">&#34;path&#34;</span><span class="p">,</span> <span class="s">&#34;/search?q=flowers&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-pool-get">func (*Pool) Get<a hidden class="anchor" aria-hidden="true" href="#func-pool-get">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">Get</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><p>Get方法从池中选择任意一个item，删除其在池中的引用计数，并提供给调用者。Get方法也可能选择无视内存池，将其当作空的。调用者不应认为Get的返回这和传递给Put的值之间有任何关系。</p>
<p>假使Get方法没有取得item：如p.New非nil，Get返回调用p.New的结果；否则返回nil。</p>
<h2 id="func-pool-put">func (*Pool) Put<a hidden class="anchor" aria-hidden="true" href="#func-pool-put">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span>
</code></pre></td></tr></table>
</div>
</div><p>Put将x添加到池中。</p>
<h1 id="type-rwmutex">type RWMutex<a hidden class="anchor" aria-hidden="true" href="#type-rwmutex">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">RWMutex</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 包含隐藏或非导出字段
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>RWMutex是读/写互斥锁。锁可以由任意数量的读者或单个作者持有。RWMutex的零值是解锁的互斥锁。</p>
<p>首次使用后，不得复制RWMutex。</p>
<p>如果goroutine持有RWMutex进行读取而另一个goroutine可能会调用Lock，那么在释放初始读锁之前，goroutine不应该期望能够获取读锁定。特别是，这禁止递归读锁定。这是为了确保锁最终变得可用; 阻止的锁定呼叫会阻止新读者获取锁定。</p>
<h2 id="func-rwmutex-lock">func (*RWMutex) Lock<a hidden class="anchor" aria-hidden="true" href="#func-rwmutex-lock">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rw</span> <span class="o">*</span><span class="nx">RWMutex</span><span class="p">)</span> <span class="nf">Lock</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>锁定锁定用于写入。如果锁已经锁定以进行读取或写入，则锁定将锁定，直到锁定可用。</p>
<h2 id="func-rwmutex-rlock">func (*RWMutex) RLock<a hidden class="anchor" aria-hidden="true" href="#func-rwmutex-rlock">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rw</span> <span class="o">*</span><span class="nx">RWMutex</span><span class="p">)</span> <span class="nf">RLock</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>RLock锁定rw进行阅读。</p>
<p>它不应该用于递归读锁定; 阻止的锁定呼叫会阻止新读者获取锁定。请参阅RWMutex类型的文档。</p>
<h2 id="func-rwmutex-rlocker">func (*RWMutex) RLocker<a hidden class="anchor" aria-hidden="true" href="#func-rwmutex-rlocker">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rw</span> <span class="o">*</span><span class="nx">RWMutex</span><span class="p">)</span> <span class="nf">RLocker</span><span class="p">()</span> <span class="nx">Locker</span>
</code></pre></td></tr></table>
</div>
</div><p>RLocker返回一个Locker接口，通过调用rw.RLock和rw.RUnlock来实现Lock和Unlock方法。</p>
<h2 id="func-rwmutex-runlock">func (*RWMutex) RUnlock<a hidden class="anchor" aria-hidden="true" href="#func-rwmutex-runlock">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rw</span> <span class="o">*</span><span class="nx">RWMutex</span><span class="p">)</span> <span class="nf">RUnlock</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>RUnlock撤消单个RLock调用; 它不会影响其他同时读者。如果在进入RUnlock时没有锁定rw进行读取，则会出现运行时错误。</p>
<h2 id="func-rwmutex-unlock">func (*RWMutex) Unlock<a hidden class="anchor" aria-hidden="true" href="#func-rwmutex-unlock">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rw</span> <span class="o">*</span><span class="nx">RWMutex</span><span class="p">)</span> <span class="nf">Unlock</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>Unlock 解锁rw进行写。如果在解锁时没有锁定rw以进行写入，则会出现运行时错误。</p>
<p>与互斥锁一样，锁定的RWMutex与特定的goroutine无关。一个goroutine可以RLock（锁定）RWMutex，然后安排另一个goroutine到RUnlock（解锁）它。</p>
<h1 id="type-waitgroup">type WaitGroup<a hidden class="anchor" aria-hidden="true" href="#type-waitgroup">#</a></h1>
<p>WaitGroup等待完成goroutine的集合。主goroutine调用Add来设置要等待的goroutines的数量。然后每个goroutine运行并在完成后调用Done。同时，Wait可以用来阻止所有goroutine完成。</p>
<p>首次使用后，不得复制WaitGroup。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">WaitGroup</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">httpPkg</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">httpPkg</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{}</span>

<span class="kd">var</span> <span class="nx">http</span> <span class="nx">httpPkg</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="kd">var</span> <span class="nx">urls</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
		<span class="s">&#34;http://www.golang.org/&#34;</span><span class="p">,</span>
		<span class="s">&#34;http://www.google.com/&#34;</span><span class="p">,</span>
		<span class="s">&#34;http://www.somestupidname.com/&#34;</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">url</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">urls</span> <span class="p">{</span>
		<span class="c1">// Increment the WaitGroup counter.
</span><span class="c1"></span>		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="c1">// Launch a goroutine to fetch the URL.
</span><span class="c1"></span>		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Decrement the counter when the goroutine completes.
</span><span class="c1"></span>			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="c1">// Fetch the URL.
</span><span class="c1"></span>			<span class="nx">http</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
		<span class="p">}(</span><span class="nx">url</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// Wait for all HTTP fetches to complete.
</span><span class="c1"></span>	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="func-waitgroup-add">func (*WaitGroup) Add<a hidden class="anchor" aria-hidden="true" href="#func-waitgroup-add">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">delta</span> <span class="kt">int</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>添加将可能为负的delta添加到WaitGroup计数器。如果计数器变为零，则释放在等待时阻止的所有goroutine。如果计数器变为负数，则添加恐慌。</p>
<p>Add方法向内部计数加上delta，delta可以是负数；如果内部计数器变为0，Wait方法阻塞等待的所有线程都会释放，如果计数器小于0，方法panic。注意Add加上正数的调用应在Wait之前，否则Wait可能只会等待很少的线程。一般来说本方法应在创建新的线程或者其他应等待的事件之前调用。</p>
<h2 id="func-waitgroup-done">func (*WaitGroup) Done<a hidden class="anchor" aria-hidden="true" href="#func-waitgroup-done">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Done</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>Done方法减少WaitGroup计数器的值，应在线程的最后执行</p>
<h2 id="func-waitgroup-wait">func (*WaitGroup) Wait<a hidden class="anchor" aria-hidden="true" href="#func-waitgroup-wait">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Wait</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>Wait方法阻塞直到WaitGroup计数器减为0。</p>
<h1 id="使用场景">使用场景<a hidden class="anchor" aria-hidden="true" href="#使用场景">#</a></h1>
<h2 id="cond">Cond<a hidden class="anchor" aria-hidden="true" href="#cond">#</a></h2>
<p>条件变量sync.Cond本质上是一些正在等待某个条件的线程的同步机制。条件变量的作用并不是保证在同一时刻仅有一个线程访问某一个共享数据，而是在对应的共享数据的状态发生变化时，通知其他因此而被阻塞的线程。</p>
<p>sync.Cond 主要实现一个条件变量，假如 goroutine A 执行前需要等待另外的goroutine B 的通知，那边处于等待的goroutine A 会保存在一个通知列表，当某个时刻状态改变时负责通知的goroutine B 通过对条件变量通知的方式（Broadcast，Signal）来通知处于等待条件变量的goroutine A, 这样便可实现一种“消息通知”的同步机制。</p>
<p>下面这个例子，可以比较好的说明Cond的使用方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">sharedRsc</span> <span class="p">=</span> <span class="kc">false</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">{}</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nf">NewCond</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// this go routine wait for changes to the sharedRsc
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">for</span> <span class="nx">sharedRsc</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;goroutine1 wait&#34;</span><span class="p">)</span>
			<span class="nx">c</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;goroutine1&#34;</span><span class="p">,</span> <span class="nx">sharedRsc</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="p">}()</span>

	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// this go routine wait for changes to the sharedRsc
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">for</span> <span class="nx">sharedRsc</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;goroutine2 wait&#34;</span><span class="p">)</span>
			<span class="nx">c</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;goroutine2&#34;</span><span class="p">,</span> <span class="nx">sharedRsc</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="p">}()</span>

	<span class="c1">// this one writes changes to sharedRsc
</span><span class="c1"></span>	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main goroutine ready&#34;</span><span class="p">)</span>
	<span class="nx">sharedRsc</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Broadcast</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main goroutine broadcast&#34;</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>执行结果如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">goroutine1 wait
goroutine2 wait
main goroutine ready
main goroutine broadcast
goroutine2 true
goroutine1 true
</code></pre></td></tr></table>
</div>
</div><p>goroutine1和goroutine2进入Wait状态，在main goroutine在2s后资源满足，发出broadcast信号后，从Wait中恢复并判断条件是否确实已经满足(sharedRsc不为空)，满足则消费条件，并解锁wg.Done()。</p>
<p>如果我们删除main goroutine中的2s延时。执行结果如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">main goroutine ready
main goroutine broadcast
goroutine2 true
goroutine1 true
</code></pre></td></tr></table>
</div>
</div><p>很有意思，两个goroutine都没有进入Wait状态。</p>
<p>原因是，main goroutine执行的更快，在goroutine1/goroutine2加锁之前就已经获得了锁，并完成了修改sharedRsc、发出Broadcast信号。当子goroutine调用Wait之前检验condition时，条件已经满足，因此就没有必要再去调用Wait了。</p>
<p>如果我们在子goroutine中不做校验呢？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">sharedRsc</span> <span class="p">=</span> <span class="kc">false</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">{}</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nf">NewCond</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// this go routine wait for changes to the sharedRsc
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">for</span> <span class="nx">sharedRsc</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;goroutine1 wait&#34;</span><span class="p">)</span>
			<span class="nx">c</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;goroutine1&#34;</span><span class="p">,</span> <span class="nx">sharedRsc</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="p">}()</span>

	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// this go routine wait for changes to the sharedRsc
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;goroutine2 wait&#34;</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;goroutine2&#34;</span><span class="p">,</span> <span class="nx">sharedRsc</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="p">}()</span>

	<span class="c1">// this one writes changes to sharedRsc
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main goroutine ready&#34;</span><span class="p">)</span>
	<span class="nx">sharedRsc</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Broadcast</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main goroutine broadcast&#34;</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们会得到1个死锁。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">main goroutine ready
main goroutine broadcast
goroutine2 wait
goroutine1 true
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [semacquire]:
sync.runtime_Semacquire(0x414028, 0x19)
	/usr/local/go/src/runtime/sema.go:56 +0x40
sync.(*WaitGroup).Wait(0x414020, 0x40c108)
	/usr/local/go/src/sync/waitgroup.go:130 +0x60
main.main()
	/tmp/sandbox947808816/prog.go:44 +0x2c0

goroutine 6 [sync.Cond.Wait]:
runtime.goparkunlock(...)
	/usr/local/go/src/runtime/proc.go:307
sync.runtime_notifyListWait(0x43e268, 0x0)
	/usr/local/go/src/runtime/sema.go:510 +0x120
sync.(*Cond).Wait(0x43e260, 0x40c108)
	/usr/local/go/src/sync/cond.go:56 +0xe0
main.main.func2(0x43e260, 0x414020)
	/tmp/sandbox947808816/prog.go:31 +0xc0
created by main.main
	/tmp/sandbox947808816/prog.go:27 +0x140
</code></pre></td></tr></table>
</div>
</div><p>为什么呢？</p>
<p>main goroutine（goroutine 1）先执行，并停留在 wg.Wait()中，等待子goroutine的wg.Done()；而子goroutine（goroutine 6）没有判断条件直接调用了cond.Wait。</p>
<p>我们知道cond.Wait会释放锁并等待其他goroutine调用Broadcast或者Signal来通知其恢复执行，除此之外没有其他的恢复途径。但此时main goroutine已经调用了Broadcast并进入了等待状态，没有任何goroutine会去拯救还在cond.Wait中的子goroutine了，而该子goroutine也没有机会调用wg.Done()去恢复main goroutine，造成了死锁。</p>
<p>因此，一定要注意，Broadcast必须要在所有的Wait之后（当然了，可以通过条件判断来决定要不要进Wait）。</p>
<p>我们来看看k8s中使用Cond实现的FIFO，它是如何处理条件的消费的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">FIFO</span><span class="p">)</span> <span class="nf">Pop</span><span class="p">(</span><span class="nx">process</span> <span class="nx">PopProcessFunc</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">queue</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// When the queue is empty, invocation of Pop() is blocked until new item is enqueued.
</span><span class="c1"></span>			<span class="c1">// When Close() is called, the f.closed is set and the condition is broadcasted.
</span><span class="c1"></span>			<span class="c1">// Which causes this loop to continue and return from the Pop().
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">f</span><span class="p">.</span><span class="nf">IsClosed</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">FIFOClosedError</span>
			<span class="p">}</span>

			<span class="nx">f</span><span class="p">.</span><span class="nx">cond</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nx">id</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">queue</span> <span class="p">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">queue</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="o">...</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewFIFO</span><span class="p">(</span><span class="nx">keyFunc</span> <span class="nx">KeyFunc</span><span class="p">)</span> <span class="o">*</span><span class="nx">FIFO</span> <span class="p">{</span>
	<span class="nx">f</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">FIFO</span><span class="p">{</span>
		<span class="nx">items</span><span class="p">:</span>   <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{},</span>
		<span class="nx">queue</span><span class="p">:</span>   <span class="p">[]</span><span class="kt">string</span><span class="p">{},</span>
		<span class="nx">keyFunc</span><span class="p">:</span> <span class="nx">keyFunc</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">cond</span><span class="p">.</span><span class="nx">L</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">f</span><span class="p">.</span><span class="nx">lock</span>
	<span class="k">return</span> <span class="nx">f</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Cond共用了FIFO的lock，在Pop时，会先加锁 f.lock.Lock()，而在f.cond.Wait()前，会先检查len(f.queue)是否为0，防止2种情况：</p>
<ul>
<li>如果wait晚于broadcast/signal,此时条件已经满足，不需要wait</li>
<li>唤醒时满足，但被其他goroutine捷足先登，阻塞在f.lock的加锁中；当获得了锁，加锁成功以后，f.queue已经被消费为空，直接访问f.queue[0]会访问越界。</li>
</ul>
<h3 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h3>
<p>当使用sync.Cond的时候有以下几点要注意的：</p>
<ul>
<li>一定要在调用cond.Wait方法前，锁定与之关联的读写锁,不然会panic</li>
<li>一定不要忘记在cond.Wait后，若数据已经处理完毕，在返回前要对与之关联的读写锁进行解锁。否则其它被唤醒的 gouroutine 将没法继续执行。</li>
<li>一定要通过条件判断来决定要不要进Wait,</li>
<li>唤醒是从等待队列中按照顺序唤醒，先进入等待队列，先被唤醒。</li>
</ul>
<h3 id="wait与sleep">wait与sleep<a hidden class="anchor" aria-hidden="true" href="#wait与sleep">#</a></h3>
<p>可能你会说,那我这样写不也可以吗</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="p">!</span><span class="nx">condition</span><span class="p">{</span>
    <span class="k">continue</span>
    <span class="c1">//time.sleep(time.second*3)
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>但是你这样实际上cpu还是被当前的goroutine占据执行.但是wait会暂停当前的goroutine直到条件满足时发送一个signal或者broadcast给它。</p>
<p>参考:<br>
<a href="https://ieevee.com/tech/2019/06/15/cond.html#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90">https://ieevee.com/tech/2019/06/15/cond.html#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90</a><br>
<a href="https://www.kancloud.cn/digest/batu-go/153536">https://www.kancloud.cn/digest/batu-go/153536</a><br>
<a href="https://www.dazhuanlan.com/2019/10/05/5d97f700bd748/">https://www.dazhuanlan.com/2019/10/05/5d97f700bd748/</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go%E6%A0%87%E5%87%86%E5%BA%93/">Go标准库</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
