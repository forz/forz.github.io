<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go的并行编程 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author"
  content="Forz" /><meta name="description" content="Goroutine Processes and Threads 操作系统会为该应用程序创建一个进程。作为一个应用程序，它像一个为所有资源而运行的容器。这些资源包括内存地址空间、文件句柄、设备和线程" /><meta name="keywords"
  content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.68.1 with theme even" />


<link rel="canonical" href="/post/go%E7%9A%84%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link rel="stylesheet" href="/css/search.css" />


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go的并行编程" />
<meta property="og:description" content="Goroutine Processes and Threads 操作系统会为该应用程序创建一个进程。作为一个应用程序，它像一个为所有资源而运行的容器。这些资源包括内存地址空间、文件句柄、设备和线程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E7%9A%84%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/" />
<meta property="article:published_time" content="2020-12-06T12:49:30+00:00" />
<meta property="article:modified_time" content="2020-12-06T12:49:30+00:00" />
<meta itemprop="name" content="Go的并行编程">
<meta itemprop="description" content="Goroutine Processes and Threads 操作系统会为该应用程序创建一个进程。作为一个应用程序，它像一个为所有资源而运行的容器。这些资源包括内存地址空间、文件句柄、设备和线程">
<meta itemprop="datePublished" content="2020-12-06T12:49:30&#43;00:00" />
<meta itemprop="dateModified" content="2020-12-06T12:49:30&#43;00:00" />
<meta itemprop="wordCount" content="10820">



<meta itemprop="keywords" content="," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go的并行编程"/>
<meta name="twitter:description" content="Goroutine Processes and Threads 操作系统会为该应用程序创建一个进程。作为一个应用程序，它像一个为所有资源而运行的容器。这些资源包括内存地址空间、文件句柄、设备和线程"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="clearfix">
  <div class="logo-wrapper">
    <a href="/" class="logo">Forz Blog</a>
  </div>

  <nav class="site-navbar">
    <ul id="menu" class="menu">
      <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
    </ul>
  </nav>
</div>


<div class="search-container">
  <div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="Search for titles or URIs..."
        name="search" autocomplete="off" />
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path
            d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js"></script>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js"></script>
<script>
    var client = algoliasearch("IAR2EF5L65", "b4b9da2eba53aa6dabe4b8ac9e8676e1");
    var index = client.initIndex('forz.forzvina.com');
    autocomplete('#aa-search-input',
        { hint: false }, {
        source: autocomplete.sources.hits(index, { hitsPerPage: 8 }),
        displayKey: 'name',
        templates: {
            suggestion: function (suggestion) {
                var reg = /([A-Z]+)/ig
                var title = suggestion.uri.replace(reg, function (m) {
                    return m.toLowerCase()
                })
                return '<span class="search-item">' + '<a href="\/' + title + '">' +
                    suggestion._highlightResult.title.value + '</a></span>';
            }
        }
    });
</script>
</div>


    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go的并行编程</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-12-06 </span>
        
          <span class="more-meta"> 约 10820 字 </span>
          <span class="more-meta"> 预计阅读 22 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#goroutine">Goroutine</a>
      <ul>
        <li><a href="#processes-and-threads">Processes and Threads</a></li>
        <li><a href="#goroutines-and-parallelism">Goroutines and Parallelism</a></li>
        <li><a href="#goroutine的使用">goroutine的使用</a></li>
      </ul>
    </li>
    <li><a href="#memory-model">Memory model</a>
      <ul>
        <li><a href="#memory-reordering">Memory Reordering</a></li>
      </ul>
    </li>
    <li><a href="#package-sync">Package sync</a>
      <ul>
        <li><a href="#share-memory-by-communicating">Share Memory By Communicating</a></li>
        <li><a href="#detecting-race-conditions-with-go">Detecting Race Conditions With Go</a></li>
        <li><a href="#syncatomic">sync.atomic</a></li>
        <li><a href="#mutex">Mutex</a></li>
        <li><a href="#errgroup">errgroup</a></li>
        <li><a href="#syncpool">sync.Pool</a></li>
      </ul>
    </li>
    <li><a href="#context">context</a>
      <ul>
        <li><a href="#do-not-store-contexts-inside-a-struct-type">Do not store Contexts inside a struct type</a></li>
        <li><a href="#contextwithvalue">context.WithValue</a></li>
        <li><a href="#debugging-or-tracing-data-is-safe-to-pass-in-a-context">Debugging or tracing data is safe to pass in a Context</a></li>
        <li><a href="#when-a-context-is-canceled-all-contexts-derived-from-it-are-also-canceled">When a Context is canceled, all Contexts derived from it are also canceled</a></li>
        <li><a href="#all-blockinglong-operations-should-be-cancelable">All blocking/long operations should be cancelable</a></li>
        <li><a href="#final-notes">Final Notes</a></li>
      </ul>
    </li>
    <li><a href="#channel">channel</a>
      <ul>
        <li><a href="#unbuffered-channels">Unbuffered Channels</a></li>
        <li><a href="#buffered-channels">Buffered Channels</a></li>
        <li><a href="#latencies-due-to-under-sized-buffer">Latencies due to under-sized buffer</a></li>
        <li><a href="#go-concurrency-patterns">Go Concurrency Patterns</a></li>
        <li><a href="#design-philosophy">Design Philosophy</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="goroutine">Goroutine</h2>
<h3 id="processes-and-threads">Processes and Threads</h3>
<p>操作系统会为该应用程序创建一个进程。作为一个应用程序，它像一个为所有资源而运行的容器。这些资源包括内存地址空间、文件句柄、设备和线程。</p>
<p>线程是操作系统调度的一种执行路径，用于在处理器执行我们在函数中编写的代码。一个进程从一个线程开始，即主线程，当该线程终止时，进程终止。这是因为主线程是应用程序的原点。然后，主线程可以依次启动更多的线程，而这些线程可以启动更多的线程。</p>
<p>无论线程属于哪个进程，操作系统都会安排线程在可用处理器上运行。每个操作系统都有自己的算法来做出这些决定。</p>
<h3 id="goroutines-and-parallelism">Goroutines and Parallelism</h3>
<p>Go 语言层面支持的 go 关键字，可以快速的让一个函数创建为 goroutine，我们可以认为 main 函数就是作为 goroutine 执行的。操作系统调度线程在可用处理器上运行，Go运行时调度 goroutines 在绑定到单个操作系统线程的逻辑处理器中运行(P)。即使使用这个单一的逻辑处理器和操作系统线程，也可以调度数十万 goroutine 以惊人的效率和性能并发运行。</p>
<p>Concurrency is not Parallelism.</p>
<p>并发不是并行。并行是指两个或多个线程同时在不同的处理器执行代码。如果将运行时配置为使用多个逻辑处理器，则调度程序将在这些逻辑处理器之间分配 goroutine，这将导致 goroutine 在不同的操作系统线程上运行。但是，要获得真正的并行性，您需要在具有多个物理处理器的计算机上运行程序。否则，goroutines 将针对单个物理处理器并发运行，即使 Go 运行时使用多个逻辑处理器。</p>
<h3 id="goroutine的使用">goroutine的使用</h3>
<p>goroutine的使用遵循3个原则</p>
<ol>
<li>将并发交给调用者,调用者决定后台执行还是前台执行.</li>
<li>管控goroutine生命周期.
<ol>
<li>搞清楚goroutine什么时候退出,能获取到goroutine退出的事件.</li>
<li>能控制goroutine什么时候退出,利用channel或者context.</li>
</ol>
</li>
</ol>
<h4 id="keep-yourself-busy-or-do-the-work-yourself">Keep yourself busy or do the work yourself</h4>
<p>空的 select 语句将永远阻塞。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206131610.png" alt=""></p>
<p>如果你的 goroutine 在从另一个 goroutine 获得结果之前无法取得进展，那么通常情况下，你自己去做这项工作比委托它( go func() )更简单。</p>
<p>这通常消除了将结果从 goroutine 返回到其启动器所需的大量状态跟踪和 chan 操作。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206132101.png" alt=""></p>
<p>log.Fatal直接调用os.exit(),会导致defer无法执行.</p>
<h4 id="never-start-a-goroutine-without-knowning-when-it-will-stop">Never start a goroutine without knowning when it will stop</h4>
<h5 id="main函数的端口监听">main函数的端口监听</h5>
<p>这个简单的应用程序在两个不同的端口上提供 http 流量，端口8080用于应用程序流量，端口8001用于访问 /debug/pprof 端点。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206132640.png" alt=""></p>
<p>Any time you start a Goroutine you must ask yourself:</p>
<ul>
<li>When will it terminate?</li>
<li>What could prevent it from terminating?</li>
</ul>
<p>通过将 serveApp 和 serveDebug 处理程序分解为各自的函数，我们将它们与main.main 解耦，我们还遵循了上面的建议，并确保 serveApp 和 serveDebug 将它们的并发性留给调用者。</p>
<p>如果 serveApp 返回，则 main.main 将返回导致程序关闭，只能靠类似 supervisor 进程管理来重新启动。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206133004.png" alt=""></p>
<p>然而，serveDebug 是在一个单独的 goroutine 中运行的，如果它返回，那么所在的 goroutine 将退出，而程序的其余部分继续运行。由于 /debug 处理程序很久以前就停止工作了，所以其他同学会很不高兴地发现他们无法在需要时从您的应用程序中获取统计信息。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206133156.png" alt=""></p>
<p>ListenAndServer 返回 nil error，最终 main.main 无法退出。</p>
<p>log.Fatal 调用了 os.Exit，会无条件终止程序；defers 不会被调用到。</p>
<p>Only use log.Fatal from main.main or init functions.</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206133302.png" alt=""></p>
<p>goroutine有两个原则:</p>
<ol>
<li>调用者来决定是否需要后台执行.</li>
<li>goroutine的生命周期需要用户进行管理.</li>
</ol>
<p>我们可以通过两个channel来进行管理.</p>
<ul>
<li>stop:控制内部,相互通知两个协程可以退出.</li>
<li>done:知道对方什么时候退出.</li>
</ul>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206151321.png" alt=""></p>
<p>当我们向stop发送信号后,执行Shutdown,这时候ListenAndServe就会退出.</p>
<p>为什么在serve里面可以再开一个go func呢,因为Shutdown和ListenAndServe存在关联关系,只要shutdown执行,整个协程就会退出,两者生命周期存在关联.</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206151525.png" alt=""></p>
<p>只要有一个协程退出,就会发送done信号,for循环会关闭stop channel,让另外一个协程安全退出.</p>
<p>我们for循环循环两次,就是在等待两个协程都退出,然后退出main函数.</p>
<h5 id="channel为局部变量">channel为局部变量</h5>
<p>在这个例子中，goroutine 泄漏可以在 code review 快速识别出来。不幸的是，生产代码中的 goroutine 泄漏通常更难找到。我无法说明 goroutine 泄漏可能发生的所有可能方式，您可能会遇到：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206155936.png" alt=""></p>
<p>当leak执行完后,内部的go func()永远无法退出,因为ch是局部变量,没有任何办法在leak函数外发信号,让其退出.</p>
<h5 id="超时控制">超时控制</h5>
<p>search 函数是一个模拟实现，用于模拟长时间运行的操作，如数据库查询或 rpc 调用。在本例中，硬编码为200ms。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206160319.png" alt=""></p>
<p>定义了一个名为 process 的函数，接受字符串参数，传递给 search。对于某些应用程序，顺序调用产生的延迟可能是不可接受的。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206160327.png" alt=""></p>
<p>我们需要开协程进行处理,一定要做代码的超时控制.</p>
<p>我们利用go的context定义100ms超时,然后make一个channel.注意,并发执行search的行为是交给调用者process函数,当search执行完毕后,我们利用channel拿到执行结果.</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206161237.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206161749.png" alt=""></p>
<p>在调用者函数中,我们可以利用context处理超时,要不就ctx.Done完毕.要不就获取到结果.</p>
<p>但go func()中确实会阻塞很久,后续再进行优化.</p>
<h5 id="incomplete-work">Incomplete Work</h5>
<p>我们使用服务端埋点来跟踪记录一些事件。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206162252.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206162300.png" alt=""></p>
<p>无法保证创建的 goroutine 生命周期管理，会导致最场景的问题，就是在服务关闭时候，有一些事件丢失。</p>
<p>使用 sync.WaitGroup 来追踪每一个创建的 goroutine。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206162322.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206162329.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206162337.png" alt=""></p>
<p>shutdown还会有一个问题,如果event阻塞时间太久,会导致无法执行.我们需要加入超时限制.</p>
<p>将 wg.Wait() 操作托管到其他 goroutine，owner goroutine 使用 context 处理超时。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206162723.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206162648.png" alt=""></p>
<p>但是这个 demo，大量创建goroutine 来处理任务，代价高。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206163602.png" alt="">
<img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206162935.png" alt=""></p>
<p>在Event函数中加入context,做超时控制.</p>
<p>在Event函数中,不直接进行埋点处理,而是将data发送到t.ch,由Run方法进行埋点.在main函数中调用Run.</p>
<p>如果调用shutdown,会关闭t.ch.Run函数发送发送stop信号,shutdown继续执行.</p>
<h4 id="leave-concurrency-to-the-caller">Leave concurrency to the caller</h4>
<p>这两个 API 有什么区别？</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206154628.png" alt=""></p>
<ul>
<li>
<p>将目录读取到一个 slice 中，然后返回整个切片，或者如果出现错误，则返回错误。这是同步调用的，ListDirectory 的调用方会阻塞，直到读取所有目录条目。根据目录的大小，这可能需要很长时间，并且可能会分配大量内存来构建目录条目名称的 slice。</p>
</li>
<li>
<p>ListDirectory 返回一个 chan string，将通过该 chan 传递目录。当通道关闭时，这表示不再有目录。由于在 ListDirectory 返回后发生通道的填充，ListDirectory 可能内部启动 goroutine 来填充通道。</p>
</li>
</ul>
<p>ListDirectory chan 版本还有两个问题：</p>
<ul>
<li>
<p>通过使用一个关闭的通道作为不再需要处理的项目的信号，ListDirectory 无法告诉调用者通过通道返回的项目集不完整，因为中途遇到了错误。调用方无法区分空目录与完全从目录读取的错误之间的区别。这两种方法都会导致从 ListDirectory 返回的通道会立即关闭。</p>
</li>
<li>
<p>调用者必须继续从通道读取，直到它关闭，因为这是调用者知道开始填充通道的 goroutine 已经停止的唯一方法。这对 ListDirectory 的使用是一个严重的限制，调用者必须花时间从通道读取数据，即使它可能已经收到了它想要的答案。对于大中型目录，它可能在内存使用方面更为高效，但这种方法并不比原始的基于 slice 的方法快。</p>
</li>
</ul>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206155343.png" alt=""></p>
<p>filepath.WalkDir 也是类似的模型，如果函数启动 goroutine，则必须向调用方提供显式停止该goroutine 的方法。通常，将异步执行函数的决定权交给该函数的调用方通常更容易。</p>
<h2 id="memory-model">Memory model</h2>
<p><a href="https://golang.org/ref/mem">https://golang.org/ref/mem</a></p>
<p>如何保证在一个 goroutine 中看到在另一个 goroutine 修改的变量的值，如果程序中修改数据时有其他 goroutine 同时读取，那么必须将读取串行化。为了串行化访问，请使用 channel 或其他同步原语，例如 sync 和 sync/atomic 来保护数据。</p>
<p>Happen-Before</p>
<p>在一个 goroutine 中，读和写一定是按照程序中的顺序执行的。即编译器和处理器只有在不会改变这个 goroutine 的行为时才可能修改读和写的执行顺序。由于重排，不同的goroutine 可能会看到不同的执行顺序。例如，一个goroutine 执行 a = 1;b = 2;，另一个 goroutine 可能看到 b 在 a 之前更新。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206182848.png" alt=""></p>
<h3 id="memory-reordering">Memory Reordering</h3>
<p>用户写下的代码，先要编译成汇编代码，也就是各种指令，包括读写内存的指令。CPU 的设计者们，为了榨干 CPU 的性能，无所不用其极，各种手段都用上了，你可能听过不少，像流水线、分支预测等等。其中，为了提高读写内存的效率，会对读写指令进行重新排列，这就是所谓的 内存重排，英文为 MemoryReordering。
这一部分说的是 CPU 重排，其实还有编译器重排。比如:</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206182948.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206183010.png" alt=""></p>
<p>但是，编译器无法感知到多个线程同时访问同一变量,所以编译器做的指令重排可能会带来BUG.</p>
<p>如果这时有另外一个线程同时干了这么一件事：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206183019.png" alt=""></p>
<p>上述两段代码的输出结果就会出现不同,出现了&quot;BUG&rdquo;.</p>
<p>在多核心场景下,没有办法轻易地判断两段程序是“等价”的。</p>
<p>现代 CPU 为了“抚平” 内核、内存、硬盘之间的速度差异，搞出了各种策略，例如三级缓存等。为了让 (2) 不必等待 (1) 的执行“效果”可见之后才能执行，我们可以把 (1) 的效果保存到 store buffer：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206183857.png" alt=""></p>
<p>store buffer 对单线程是完美的</p>
<p>先执行 (1) 和 (3)，将他们直接写入 store buffer，接着执行 (2) 和 (4)。“奇迹”要发生了：(2) 看了下 store buffer，并没有发现有 B 的值，于是从 Memory 读出了 0，(4) 同样从 Memory 读出了 0。最后，打印出了 00。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206203328.png" alt=""></p>
<p>因此，对于多线程的程序，所有的 CPU 都会提供“锁”支持，称之为 barrier，或者 fence。它要求：barrier 指令要求所有对内存的操作都必须要“扩散”到 memory 之后才能继续执行其他对 memory 的操作。因此，我们可以用高级点的 atomic compare-and-swap，或者直接用更高级的锁，通常是标准库提供。</p>
<p>为了说明读和写的必要条件，我们定义了先行发生(Happens Before)。如果事件 e1 发生在 e2 前，我们可以说 e2 发生在 e1 后。如果 e1不发生在 e2 前也不发生在 e2 后，我们就说 e1 和 e2 是并发的。</p>
<p>在单一的独立的 goroutine 中先行发生的顺序即是程序中表达的顺序。</p>
<p>当下面条件满足时，对变量 v 的读操作 r 是被允许看到对 v 的写操作 w 的：</p>
<ol>
<li>r 不先行发生于 w</li>
<li>在 w 后 r 前没有对 v 的其他写操作</li>
</ol>
<p>为了保证对变量 v 的读操作 r 看到对 v 的写操作 w，要确保 w 是 r 允许看到的唯一写操作。即当下面条件满足时，r 被保证看到 w：</p>
<ol>
<li>w 先行发生于 r</li>
<li>其他对共享变量 v 的写操作要么在 w 前，要么在 r 后。</li>
</ol>
<p>这一对条件比前面的条件更严格，需要没有其他写操作与 w 或 r 并发发生。</p>
<p>单个 goroutine 中没有并发，所以上面两个定义是相同的：</p>
<p>读操作 r 看到最近一次的写操作 w 写入 v 的值。</p>
<p>当多个 goroutine 访问共享变量 v 时，它们必须使用同步事件来建立先行发生这一条件来保证读操作能看到需要的写操作。</p>
<ul>
<li>对变量 v 的零值初始化在内存模型中表现的与写操作相同。</li>
<li>对大于 single machine word 的变量的读写操作表现的像以不确定顺序对多个 single machine word的变量的操作。</li>
</ul>
<p>64位机器的machine word为8byte(64位),对于小于等于single machine word 的变量的写操作是原子性的.</p>
<p><a href="https://www.jianshu.com/p/5e44168f47a3">https://www.jianshu.com/p/5e44168f47a3</a></p>
<h2 id="package-sync">Package sync</h2>
<h3 id="share-memory-by-communicating">Share Memory By Communicating</h3>
<p>传统的线程模型(通常在编写 Java、C++ 和Python 程序时使用)程序员在线程之间通信需要使用共享内存。通常，共享数据结构由锁保护，线程将争用这些锁来访问数据。在某些情况下，通过使用线程安全的数据结构(如Python的Queue)，这会变得更容易。</p>
<p>Go 的并发原语 goroutines 和 channels 为构造并发软件提供了一种优雅而独特的方法。Go 没有显式地使用锁来协调对共享数据的访问，而是鼓励使用 chan 在 goroutine 之间传递对数据的引用。这种方法确保在给定的时间只有一个goroutine 可以访问数据。</p>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
<h3 id="detecting-race-conditions-with-go">Detecting Race Conditions With Go</h3>
<p>data race 是两个或多个 goroutine 访问同一个资源(如变量或数据结构)，并尝试对该资源进行读写而不考虑其他 goroutine。这种类型的代码可以创建您见过的最疯狂和最随机的 bug。通常需要大量的日志记录和运气才能找到这些类型的bug。</p>
<p>早在6月份的Go 1.1中，Go 工具引入了一个 race detector。竞争检测器是在构建过程中内置到程序中的代码。然后，一旦你的程序运行，它就能够检测并报告它发现的任何竞争条件。它非常酷，并且在识别罪魁祸首的代码方面做了令人难以置信的工作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nx">build</span> <span class="o">-</span><span class="nx">race</span>
<span class="k">go</span> <span class="nx">test</span> <span class="o">-</span><span class="nx">race</span>
</code></pre></td></tr></table>
</div>
</div><p>-race对程序负载较高,线上环境不建议使用.</p>
<p>工具似乎检测到代码的争用条件。如果您查看race condition 报告下面，您可以看到程序的输出: 全局计数器变量的值为4。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206214021.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206214546.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206214621.png" alt=""></p>
<p>试图通过 i++ 方式来解决原子赋值的问题，但是我们通过查看底层汇编:</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206214646.png" alt=""></p>
<p>实际上有三行汇编代码在执行以增加计数器。这三行汇编代码看起来很像原始的Go代码。在这三行汇编代码之后可能有一个上下文切换。尽管程序现在正在运行，但从技术上讲，这个bug 仍然存在。我们的 Go 代码看起来像是在安全地访问资源，而实际上底层的程序集代码根本就不安全。</p>
<p>我们应该使用 Go 同步语义: Mutex</p>
<h4 id="不存在安全的data-race">不存在安全的data race</h4>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206215405.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206215358.png" alt=""></p>
<p>这看起来是一个串行化无限调用loop0和loop1的过程,但因为go关键字,我们不知道什么时候会产生调度,这个过程中会创建很多goroutine,先后执行顺序不知道.所以会出现race.</p>
<p>但因为是指针赋值,我们第一感觉是 single machine word 应该是原子赋值，为啥 -race 会乱报。我们执行这个代码看看会发生什么。</p>
<p>Type 指向实现了接口的 struct，Data 指向了实际的值。Data 作为通过 interface 中任何方法调用的接收方传递。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206220616.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206220622.png" alt=""></p>
<p>对于语句 var maker IceCreamMaker=ben，编译器将生成执行以下操作的代码。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206220557.png" alt=""></p>
<p>当 loop1() 执行 maker=jerry 语句时，必须更新接口值的两个字段。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206220629.png" alt=""></p>
<p>表示写入单个 machine word 将是原子的，但 interface 内部是是两个 machine word 的值。另一个goroutine 可能在更改接口值时观察到它的内容。</p>
<p>在这个例子中，Ben 和 Jerry 内存结构布局是相同的，因此它们在某种意义上是兼容的。想象一下，如果他们有不同的内存布局会发生什么混乱？</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206221438.png" alt=""></p>
<p>因为赋值过程不是原子性的,所以在赋值过程中因为两个变量内存布局不同,会panic.</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206221531.png" alt=""></p>
<p>如果是一个普通的指针、map、slice 可以安全的更新吗？</p>
<p>没有安全的 data race(safe data race)。您的程序要么没有 data race，要么其操作未定义,不要假定任何无同步原语的写入操作是原子性的.</p>
<ul>
<li>原子性</li>
<li>可见行</li>
</ul>
<h3 id="syncatomic">sync.atomic</h3>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206224539.png" alt=""></p>
<p>cfg 作为包级全局对象，在这个例子中被多个 goroutine 同时访问，因此这里存在 data race，会看到不连续的内存输出。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206222309.png" alt=""></p>
<p>我们想到使用 Go 同步语义解决:</p>
<ul>
<li>Mutex:锁粒度很大,不适合读多写少场景</li>
<li>RWMutex:适合读多写少场景,性能依旧不够.</li>
<li>Atomic:性能最好.</li>
</ul>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206225724.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206225656.png" alt=""></p>
<p>Benchmark 是出结果真相的真理，即便我们知道可能 Mutex vs Atomic 的情况里，Mutex 相对更重。因为涉及到更多的 goroutine 之间的上下文切换 pack blocking goroutine，以及唤醒 goroutine。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nx">test</span> <span class="o">-</span><span class="nx">bench</span><span class="p">=.</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206225753.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206225818.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206225827.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201206225835.png" alt=""></p>
<h4 id="配置中心">配置中心</h4>
<p>Copy-On-Write 思路在微服务降级或者 local cache 场景中经常使用。写时复制指的是，写操作时候复制全量老数据到一个新的对象中，携带上本次新写的数据，之后利用原子替换(atomic.Value)，更新调用者的变量。来完成无锁访问共享数据。</p>
<p>因为COW策略会将原始数据复制一份,写入性能很低,适合读极多写少的场景.</p>
<p>看如下代码,我们定期(每10s)利用loadconfig读取配置,然后存入config.在使用的时候,利用load读出来,再进行处理.</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201207215749.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201207220246.png" alt=""></p>
<h3 id="mutex">Mutex</h3>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201207222339.png" alt=""></p>
<p>这个案例基于两个 goroutine:</p>
<ul>
<li>goroutine 1 每次持锁100ms</li>
<li>goroutine 2 每100ms 持有一次锁</li>
</ul>
<p>都是100ms 的周期，但是由于 goroutine 1 不断的请求锁，可预期它会更频繁的持续到锁。我们基于 Go 1.8 循环了10次，下面是锁的请求占用分布:</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201207222331.png" alt=""></p>
<p>Mutex 被 g1 获取了700多万次，而 g2 只获取了10次。</p>
<p>首先，goroutine1 将获得锁并休眠100ms。当goroutine2 试图获取锁时，它将被添加到锁的队列中- FIFO 顺序，goroutine 将进入等待状态。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201207223051.png" alt=""></p>
<p>然后，当 goroutine1 完成它的工作时，它将释放锁。此版本将通知队列唤醒 goroutine2。goroutine2 将被标记为可运行的，并且正在等待 Go 调度程序在线程上运行.</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201207223210.png" alt=""></p>
<p>然而，当 goroutine2 等待运行时，goroutine1将再次请求锁。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201207223228.png" alt=""></p>
<p>goroutine2 尝试去获取锁，结果悲剧的发现锁又被人持有了，它自己继续进入到等待模式。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201207223237.png" alt=""></p>
<p>我们看看几种 Mutex 锁的实现:</p>
<ul>
<li>Barging. 这种模式是为了提高吞吐量，当锁被释放时，它会唤醒第一个等待者，然后把锁给第一个等待者或者给第一个请求锁的人。
<img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201207223656.png" alt=""></li>
<li>Handsoff. 当锁释放时候，锁会一直持有直到第一个等待者准备好获取锁。它降低了吞吐量，因为锁被持有，即使另一个 goroutine 准备获取它。
<img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201207223752.png" alt="">
一个互斥锁的 handsoff 会完美地平衡两个goroutine 之间的锁分配，但是会降低性能，因为它会迫使第一个 goroutine 等待锁。</li>
<li>Spinning. 自旋在等待队列为空或者应用程序重度使用锁时效果不错。Parking 和 Unparking goroutines 有不低的性能成本开销，相比自旋来说要慢得多。</li>
</ul>
<p>Go 1.8 使用了 Barging 和 Spining 的结合实现。当试图获取已经被持有的锁时，如果本地队列为空并且 P 的数量大于1，goroutine 将自旋几次(用一个 P 旋转会阻塞程序)。自旋后，goroutine park。在程序高频使用锁的情况下，它充当了一个快速路径。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201207224110.png" alt=""></p>
<p>Go 1.9 通过添加一个新的饥饿模式来解决先前解释的问题，该模式将会在释放时候触发 handsoff。所有等待锁超过一毫秒的 goroutine(也称为有界等待)将被诊断为饥饿。当被标记为饥饿状态时，unlock 方法会 handsoff 把锁直接扔给第一个等待者。</p>
<p>在饥饿模式下，自旋也被停用，因为传入的goroutines 将没有机会获取为下一个等待者保留的锁。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201207224127.png" alt=""></p>
<h3 id="errgroup">errgroup</h3>
<p>我们把一个复杂的任务，尤其是依赖多个微服务 rpc 需要聚合数据的任务，分解为依赖和并行，依赖的意思为: 需要上游 a 的数据才能访问下游 b 的数据进行组合。但是并行的意思为: 分解为多个小任务并行执行，最终等全部执行完毕。
<a href="https://pkg.go.dev/golang.org/x/sync/errgroup">https://pkg.go.dev/golang.org/x/sync/errgroup</a>
核心原理: 利用 sync.Waitgroup 管理并行执行的 goroutine。 3/10.go</p>
<ul>
<li>并行工作流</li>
<li>错误处理 或者 优雅降级</li>
<li>context 传播和取消</li>
<li>利用局部变量+闭包</li>
</ul>
<p><a href="https://github.com/go-kratos/kratos/tree/master/pkg/sync/errgroup">https://github.com/go-kratos/kratos/tree/master/pkg/sync/errgroup</a></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201207224846.png" alt=""></p>
<h3 id="syncpool">sync.Pool</h3>
<p>sync.Pool 的场景是用来保存和复用临时对象，以减少内存分配，降低 GC 压力(Request-Driven 特别合适)。</p>
<p>Get 返回 Pool 中的任意一个对象。如果 Pool 为空，则调用 New 返回一个新创建的对象。</p>
<p>放进 Pool 中的对象，会在说不准什么时候被回收掉。所以如果事先 Put 进去 100 个对象，下次 Get 的时候发现 Pool 是空也是有可能的。不过这个特性的一个好处就在于不用担心 Pool 会一直增长，因为 Go 已经帮你在 Pool 中做了回收机制。</p>
<p>这个清理过程是在每次垃圾回收之前做的。之前每次GC 时都会清空 pool，而在1.13版本中引入了 victim cache，会将 pool 内数据拷贝一份，避免 GC 将其清空，即使没有引用的内容也可以保留最多两轮 GC。</p>
<h2 id="context">context</h2>
<p>在 Go 服务中，每个传入的请求都在其自己的goroutine 中处理。请求处理程序通常启动额外的 goroutine 来访问其他后端，如数据库和 RPC服务。处理请求的 goroutine 通常需要访问特定于请求(request-specific context)的值，例如最终用户的身份、授权令牌和请求的截止日期(deadline)。当一个请求被取消或超时时，处理该请求的所有 goroutine 都应该快速退出(fail fast)，这样系统就可以回收它们正在使用的任何资源。</p>
<p>Go 1.7 引入一个 context 包，它使得跨 API 边界的请求范围元数据、取消信号和截止日期很容易传递给处理请求所涉及的所有 goroutine(显式传递)。</p>
<p>其他语言: Thread Local Storage(TLS)，XXXContext</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201207231724.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201207231733.png" alt=""></p>
<p>如何将 context 集成到 API 中？</p>
<p>在将 context 集成到 API 中时，要记住的最重要的一点是，它的作用域是请求级别	的。例如，沿单个数据库查询存在是有意义的，但沿数据库对象存在则没有意义。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201208001105.png" alt=""></p>
<p>目前有两种方法可以将 context 对象集成到 API 中：</p>
<ul>
<li>
<p>The first parameter of a function call
首参数传递 context 对象，比如，参考  net 包 Dialer.DialContext。此函数执行正常的 Dial 操作，但可以通过 context 对象取消函数调用。
<img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201208001006.png" alt=""></p>
</li>
<li>
<p>Optional config on a request structure
在第一个 request 对象中携带一个可选的 context 对象。例如 net/http 库的 Request.WithContext，通过携带给定的 context 对象，返回一个新的 Request 对象。
<img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201208001032.png" alt=""></p>
</li>
</ul>
<h3 id="do-not-store-contexts-inside-a-struct-type">Do not store Contexts inside a struct type</h3>
<p>Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it. The Context should be the first parameter, typically named ctx:</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201208001210.png" alt=""></p>
<p>Incoming requests to a server should create a Context.</p>
<p>使用 context 的一个很好的心智模型是它应该在程序中流动，应该贯穿你的代码。这通常意味着您不希望将其存储在结构体之中。它从一个函数传递到另一个函数，并根据需要进行扩展。理想情况下，每个请求都会创建一个 context 对象，并在请求结束时过期。</p>
<p>不存储上下文的一个例外是，当您需要将它放入一个结构中时，该结构纯粹用作通过通道传递的消息。如下例所示。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201208001232.png" alt=""></p>
<h3 id="contextwithvalue">context.WithValue</h3>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201208001401.png" alt=""></p>
<p>context.WithValue 内部基于 valueCtx 实现:</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201208001341.png" alt=""></p>
<p>为了实现不断的 WithValue，构建新的 context，内部在查找 key 时候，使用递归方式不断从当前，从父节点寻找匹配的 key，直到 root context(Backgrond 和 TODO Value 函数会返回 nil)。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201208001353.png" alt=""></p>
<p>比如我们新建了一个基于 context.Background() 的 ctx1，携带了一个 map 的数据，map 中包含了 “k1”: “v1” 的一个键值对，ctx1 被两个 goroutine 同时使用作为函数签名传入，如果我们修改了 这个map，会导致另外进行读 context.Value 的 goroutine 和修改 map 的 goroutine，在 map 对象上产生 data race。因此我们要使用 copy-on-write 的思路，解决跨多个 goroutine 使用数据、修改数据的场景。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201208002458.png" alt=""></p>
<p>Replace a Context using WithCancel, WithDeadline, WithTimeout, or WithValue.</p>
<p>COW: 从 ctx1 中获取 map1(可以理解为 v1 版本的 map 数据)。构建一个新的 map 对象 map2，复制所有 map1 数据，同时追加新的数据 “k2”: “v2” 键值对，使用 context.WithValue 创建新的 ctx2，ctx2 会传递到其他的 goroutine 中。这样各自读取的副本都是自己的数据，写行为追加的数据，在 ctx2 中也能完整读取到，同时也不会污染 ctx1 中的数据。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201208002536.png" alt=""></p>
<p>The chain of function calls between them must propagate the Context.</p>
<h3 id="debugging-or-tracing-data-is-safe-to-pass-in-a-context">Debugging or tracing data is safe to pass in a Context</h3>
<p>context.WithValue 方法允许上下文携带请求范围的数据。这些数据必须是安全的，以便多个 goroutine 同时使用。这里的数据，更多是面向请求的元数据，不应该作为函数的可选参数来使用(比如 context 里面挂了一个sql.Tx 对象，传递到 Dao 层使用)，因为元数据相对函数参数更加是隐含的，面向请求的。而参数是更加显式的。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201208002050.png" alt=""></p>
<p>同一个 context 对象可以传递给在不同 goroutine 中运行的函数；上下文对于多个 goroutine 同时使用是安全的。对于值类型最容易犯错的地方，在于 context value 应该是 immutable 的，每次重新赋值应该是新的 context，即: <code>context.WithValue(ctx, oldvalue)</code></p>
<p><a href="https://pkg.go.dev/google.golang.org/grpc/metadata">https://pkg.go.dev/google.golang.org/grpc/metadata</a></p>
<p>Context.Value should inform, not control</p>
<p>Use context values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.</p>
<p>比如 染色，API 重要性，Trace</p>
<p><a href="https://github.com/go-kratos/kratos/blob/master/pkg/net/metadata/key.go">https://github.com/go-kratos/kratos/blob/master/pkg/net/metadata/key.go</a></p>
<h3 id="when-a-context-is-canceled-all-contexts-derived-from-it-are-also-canceled">When a Context is canceled, all Contexts derived from it are also canceled</h3>
<p>当一个 context 被取消时，从它派生的所有 context 也将被取消。WithCancel(ctx) 参数 ctx 认为是 parent ctx，在内部会进行一个传播关系链的关联。Done() 返回 一个 chan，当我们取消某个parent context, 实际上上会递归层层 cancel 掉自己的 child context 的 done chan 从而让整个调用链中所有监听 cancel 的 goroutine退出。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201208003741.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201208003813.png" alt=""></p>
<h3 id="all-blockinglong-operations-should-be-cancelable">All blocking/long operations should be cancelable</h3>
<p>如果要实现一个超时控制，通过上面的context 的parent/child 机制，其实我们只需要启动一个定时器，然后在超时的时候，直接将当前的 context 给 cancel 掉，就可以实现监听在当前和下层的额context.Done() 的 goroutine 的退出。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201208004036.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201208004044.png" alt=""></p>
<h3 id="final-notes">Final Notes</h3>
<ul>
<li>Incoming requests to a server should create a Context.
<ul>
<li>一个RPC服务,当有请求进来时,第一个要做的事情就是创建一个context
<ul>
<li>如果设定超时就用withtimeout.</li>
<li>如果没有设定超时,就用withcanncel.</li>
<li>一般建议一定要设置超时.</li>
</ul>
</li>
</ul>
</li>
<li>Outgoing calls to servers should accept a Context.
<ul>
<li>调用其他服务的时候,一定要显式传递context.</li>
</ul>
</li>
<li>Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it.
<ul>
<li>我们要用函数参数传递,而不是存到结构体中</li>
</ul>
</li>
<li>The chain of function calls between them must propagate the Context.
<ul>
<li>如果使用context.withvalue,可以在context内部创建级联关系,一个取消,就全部取消.</li>
</ul>
</li>
<li>Replace a Context using WithCancel, WithDeadline, WithTimeout, or WithValue.
<ul>
<li>只能替换context,而不能更改context.每次使用with的时候,都是创建新context.value里面的数据是不可变更的.包括断言出来拿的结构体,把里面的字段改值,也不会变更</li>
</ul>
</li>
<li>When a Context is canceled, all Contexts derived from it are also canceled.
<ul>
<li>如果一个context取消,级联context取消.</li>
</ul>
</li>
<li>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines.
<ul>
<li>context是并发安全的</li>
</ul>
</li>
<li>Do not pass a nil Context, even if a function permits it. Pass a TODO context if you are unsure about which Context to use.
<ul>
<li>不要传nil到context中,如果不知道要传什么,请传context.todo.</li>
</ul>
</li>
<li>Use context values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.
<ul>
<li>不要在context中带和业务逻辑相关的数据,如果是业务逻辑相关的内容,建议显式传递.</li>
</ul>
</li>
<li>All blocking/long operations should be cancelable.
<ul>
<li>所有耗时很长,会阻塞的操作一定要传递context,让其可以被取消.</li>
<li>计算密集型,系统调用,网络消息.</li>
</ul>
</li>
<li>Context.Value obscures your program’s flow.
<ul>
<li>context的value的值不应该影响你的业务逻辑.</li>
</ul>
</li>
<li>Context.Value should inform, not control.
<ul>
<li>context只是一个信号,而不是控制逻辑.</li>
</ul>
</li>
<li>Try not to use context.Value.
<ul>
<li>最好不用context.Value,而是显式传递参数.</li>
</ul>
</li>
</ul>
<p><a href="https://talks.golang.org/2014/gotham-context.slide#1">https://talks.golang.org/2014/gotham-context.slide#1</a></p>
<h2 id="channel">channel</h2>
<p>channels 是一种类型安全的消息队列，充当两个 goroutine 之间的管道，将通过它同步的进行任意资源的交换。chan 控制 goroutines 交互的能力从而创建了 Go 同步机制。当创建的 chan 没有容量时，称为无缓冲通道。反过来，使用容量创建的 chan 称为缓冲通道。</p>
<p>要了解通过 chan 交互的 goroutine 的同步行为是什么，我们需要知道通道的类型和状态。根据我们使用的是无缓冲通道还是缓冲通道，场景会有所不同，所以让我们单独讨论每个场景。</p>
<h3 id="unbuffered-channels">Unbuffered Channels</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
</code></pre></td></tr></table>
</div>
</div><p>无缓冲 chan 没有容量，因此进行任何交换前需要两个 goroutine 同时准备好。当 goroutine 试图将一个资源发送到一个无缓冲的通道并且没有goroutine 等待接收该资源时，该通道将锁住发送 goroutine 并使其等待。当 goroutine 尝试从无缓冲通道接收，并且没有 goroutine 等待发送资源时，该通道将锁住接收 goroutine 并使其等待。</p>
<p>无缓冲信道的本质是保证同步。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201208223304.png" alt=""></p>
<p>第一个 goroutine 在发送消息 foo 之后被阻塞，因为还没有接收者准备好。规范中对这种行为进行了很好的解释：<a href="https://golang.org/ref/spec#Channel_types">https://golang.org/ref/spec#Channel_types</a></p>
<p>“If the capacity is zero or absent, the channel is unbuffered and communication succeeds only when both a sender and receiver are ready.”</p>
<p><a href="https://golang.org/doc/effective_go.html#channels">https://golang.org/doc/effective_go.html#channels</a></p>
<p>“If the channel is unbuffered, the sender blocks until the receiver has received the value”</p>
<ul>
<li>Receive 先于 Send 发生。</li>
<li>好处: 100% 保证能收到。</li>
<li>代价: 延迟时间未知。</li>
</ul>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201208223508.png" alt=""></p>
<h3 id="buffered-channels">Buffered Channels</h3>
<p>buffered channel 具有容量，因此其行为可能有点不同。当 goroutine 试图将资源发送到缓冲通道，而该通道已满时，该通道将锁住 goroutine并使其等待缓冲区可用。如果通道中有空间，发送可以立即进行，goroutine 可以继续。当goroutine 试图从缓冲通道接收数据，而缓冲通道为空时，该通道将锁住 goroutine 并使其等待资源被发送。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201208223541.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201208223552.png" alt=""></p>
<h3 id="latencies-due-to-under-sized-buffer">Latencies due to under-sized buffer</h3>
<p>我们在 chan 创建过程中定义的缓冲区大小可能会极大地影响性能。我将使用密集使用 chan 的扇出模式来查看不同缓冲区大小的影响。在我们的基准测试中，一个 producer 将在通道中注入百万个整数元素，而5个 worker 将读取并将它们追加到一个名为 total 的结果变量中。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201208223639.png" alt=""></p>
<ul>
<li>Send 先于 Receive 发生。</li>
<li>好处: 延迟更小。</li>
<li>代价: 不保证数据到达，越大的 buffer，越小的保障到达。buffer = 1 时，给你延迟一个消息的保障。</li>
</ul>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201208223649.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201208223700.png" alt=""></p>
<h3 id="go-concurrency-patterns">Go Concurrency Patterns</h3>
<ul>
<li>Timing out</li>
<li>Moving on</li>
<li>Pipeline</li>
<li>Fan-out, Fan-in</li>
<li>Cancellation
<ul>
<li>Close 先于 Receive 发生(类似 Buffered)。</li>
<li>不需要传递数据，或者传递 nil。</li>
<li>非常适合取消和超时控制。</li>
</ul>
</li>
<li>Contex</li>
</ul>
<p><a href="https://blog.golang.org/concurrency-timeouts">https://blog.golang.org/concurrency-timeouts</a>
<a href="https://blog.golang.org/pipelines">https://blog.golang.org/pipelines</a>
<a href="https://talks.golang.org/2013/advconc.slide#1">https://talks.golang.org/2013/advconc.slide#1</a>
<a href="https://github.com/go-kratos/kratos/tree/master/pkg/sync">https://github.com/go-kratos/kratos/tree/master/pkg/sync</a></p>
<h3 id="design-philosophy">Design Philosophy</h3>
<ul>
<li>If any given Send on a channel CAN cause the sending goroutine to block:
<ul>
<li>Not allowed to use a Buffered channel larger than 1.
<ul>
<li>Buffers larger than 1 must have reason/measurements.</li>
</ul>
</li>
<li>Must know what happens when the sending goroutine blocks.</li>
</ul>
</li>
<li>If any given Send on a channel WON’T cause the sending goroutine to block:
<ul>
<li>You have the exact number of buffers for each send.
<ul>
<li>Fan Out pattern</li>
</ul>
</li>
<li>You have the buffer measured for max capacity.
<ul>
<li>Drop pattern
<ul>
<li>丢弃数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Less is more with buffers.
<ul>
<li>Don’t think about performance when thinking about buffers.
<ul>
<li>不要把channel buffer 的size大小当做性能提升,它只是缓冲的变多了,阻塞延迟变小了.吞吐量依靠多个goroutine来消费</li>
</ul>
</li>
<li>Buffers can help to reduce blocking latency between signaling.
<ul>
<li>buffer只能减少阻塞延迟.</li>
<li>Reducing blocking latency towards zero does not necessarily mean better throughput.
<ul>
<li>阻塞延迟变少不意味吞吐提升</li>
</ul>
</li>
<li>If a buffer of one is giving you good enough throughput then keep it.
<ul>
<li>channel的size,最好依据压测来得出.</li>
</ul>
</li>
<li>Question buffers that are larger than one and measure for size.</li>
<li>Find the smallest buffer possible that provides good enough throughput.</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-12-06
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags//"></a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go%E4%B8%AD%E7%9A%84data-race/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go中的Data-Race</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/go%E7%9A%84error%E5%A4%84%E7%90%86/">
            <span class="next-text nav-default">Go的error处理</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Forz</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
