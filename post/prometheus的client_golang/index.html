<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Prometheus的client_golang | Forz Blog</title>
<meta name="keywords" content="Prometheus, Go" />
<meta name="description" content="prometheus包 概述 普罗米修斯软件包是仪器仪表的核心。它为度量代码提供度量原语以进行监视。它还提供了Metric注册表。子包允许通过H">
<meta name="author" content="">
<link rel="canonical" href="/post/prometheus%E7%9A%84client_golang/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Prometheus的client_golang" />
<meta property="og:description" content="prometheus包 概述 普罗米修斯软件包是仪器仪表的核心。它为度量代码提供度量原语以进行监视。它还提供了Metric注册表。子包允许通过H" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/prometheus%E7%9A%84client_golang/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-07-14T17:21:00&#43;00:00" />
<meta property="article:modified_time" content="2020-07-14T17:21:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Prometheus的client_golang"/>
<meta name="twitter:description" content="prometheus包 概述 普罗米修斯软件包是仪器仪表的核心。它为度量代码提供度量原语以进行监视。它还提供了Metric注册表。子包允许通过H"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Prometheus的client_golang",
      "item": "/post/prometheus%E7%9A%84client_golang/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Prometheus的client_golang",
  "name": "Prometheus的client_golang",
  "description": "prometheus包 概述 普罗米修斯软件包是仪器仪表的核心。它为度量代码提供度量原语以进行监视。它还提供了Metric注册表。子包允许通过H",
  "keywords": [
    "Prometheus", "Go"
  ],
  "articleBody": "prometheus包 概述 普罗米修斯软件包是仪器仪表的核心。它为度量代码提供度量原语以进行监视。它还提供了Metric注册表。子包允许通过HTTP（包promhttp）公开已注册的指标，或将其推送到Pushgateway（包推送）。还有一个子包promauto，它为Metric构造函数提供自动注册。\n除非另有说明，否则所有导出的函数和方法都可以安全地并发使用。\n一个基本的例子 首先，给出一个非常基本的用法示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  package main import ( \"log\" \"net/http\" \"github.com/prometheus/client_golang/prometheus\" \"github.com/prometheus/client_golang/prometheus/promhttp\" ) var ( cpuTemp = prometheus.NewGauge(prometheus.GaugeOpts{ Name: \"cpu_temperature_celsius\", Help: \"Current temperature of the CPU.\", }) hdFailures = prometheus.NewCounterVec( prometheus.CounterOpts{ Name: \"hd_errors_total\", Help: \"Number of hard-disk errors.\", }, []string{\"device\"}, ) ) func init() { // Metrics have to be registered to be exposed: \tprometheus.MustRegister(cpuTemp) prometheus.MustRegister(hdFailures) } func main() { cpuTemp.Set(65.3) hdFailures.With(prometheus.Labels{\"device\":\"/dev/sda\"}).Inc() // The Handler function provides a default handler to expose metrics \t// via an HTTP server. \"/metrics\" is the usual endpoint for that. \thttp.Handle(\"/metrics\", promhttp.Handler()) log.Fatal(http.ListenAndServe(\":8080\", nil)) }   这是一个完整的程序，可以导出两个指标，一个量规和一个计数器，后者带有标签，可以将其转换为（一维）向量。\n指标 该软件包中导出的标识符的数量可能看起来有点不堪重负。但是，除了上面示例中显示的基本管道外，您仅需要了解不同的Metric类型及其向量版本即可基本使用。此外，如果您不关心何时以及如何在注册表中注册度量的精细控制，请查看promauto软件包，该软件包将有效地使您在简单情况下完全忽略注册。\n在上方，您已经触摸了计数器和仪表。有两种更高级的Metric类型：“摘要”和“直方图”。可以在Prometheus docs中找到对这四种Metric类型的更详尽的描述：https://prometheus.io/docs/concepts/metric_types/\n除了基本的Metric类型“量规”，“计数器”，“摘要”和“直方图”之外，Prometheus数据模型的一个非常重要的部分是沿称为标签的维度对样本进行划分，这将导致度量向量。基本类型是GaugeVec，CounterVec，SummaryVec和HistogramVec。\n虽然仅基本Metric类型实现Metric接口，但Metric及其向量版本均实现了Collector接口。收集器管理许多Metric的收集，但为方便起见，Metric也可以“自行收集”。注意，Gauge，Counter，Summary和Histogram本身是接口，而GaugeVec，CounterVec，SummaryVec和HistogramVec不是接口。\n要创建Metric及其向量版本的实例，您需要一个合适的…Opts结构，即GaugeOpts，CounterOpts，SummaryOpts或HistogramOpts。\n自定义收集器和常量指标 尽管您可以创建自己的Metric实现，但很可能仅会自己实现Collector接口。乍一看，自定义收集器似乎很方便将Metric捆绑在一起以进行通用注册（以上述不同Metric向量的主要示例为例，该Metric捆绑了所有相同名称但具有不同标签的Metric）。\n还有一个更复杂的用例：如果您已经有在Prometheus上下文之外创建的度量，则不需要各种Metric类型的接口。本质上，您希望在收集过程中将现有数字镜像到PrometheusMetric中。收集器接口的自己实现非常适合此操作。您可以使用NewConstMetric，NewConstHistogram和NewConstSummary（以及它们各自的Must…版本）“动态”创建Metric实例。 NewConstMetric用于仅以float64作为其值的所有Metric类型：Counter，Gauge和称为Untyped的特殊“类型”。如果不确定镜像指标是计数器还是量表，请使用后者。 Metric实例的创建在Collect方法中进行。 Describe方法必须返回单独的Desc实例，以代表稍后将创建的“丢弃”Metric。 NewDesc可以方便地创建这些Desc实例。或者，您可以根本不返回任何Desc，这会将收集器标记为“未选中”。在注册时不会执行任何检查，但是在刮刮时仍将确保Metric一致性，即任何不一致都会导致刮刮错误。因此，对于未经检查的收集器，不收集导致总刮除结果不一致的度量的责任在于收集器的实施者。虽然这不是理想的状态，但有时是必需的。典型的用例是在注册时无法预测要由收集器返回的确切度量的情况，但是实现者对整个系统有足够的知识以保证度量的一致性。\n收集器示例说明了用例。您还可以查看processCollector（镜像流程指标），goCollector（镜像Go指标）或expvarCollector（镜像expvar指标）的源代码，作为在此包本身中使用的示例。\n如果只需要调用一个函数来获取单个浮点值以作为度量收集，GaugeFunc，CounterFunc或UntypedFunc可能是有趣的快捷方式。\n注册表的高级用法 虽然MustRegister是注册收集器的最常用方法，但有时您可能希望处理注册可能导致的错误。顾名思义，如果发生错误，MustRegister会出现混乱。使用Register方法，可以返回错误并可以处理。\n如果注册的收集器与已注册的Metric不兼容或不一致，则返回错误。该注册表旨在根据Prometheus数据模型来确保所收集指标的一致性。理想情况下，在注册时而不是在收集时检测到不一致。通常，前者通常在程序启动时被检测到，而后者只会在抓取时发生，如果不一致仅在以后变得很重要，则可能甚至不会在第一次抓取时发生。这就是收集器和Metric必须向注册表描述自己的主要原因。\n到目前为止，我们所做的一切都在所谓的默认注册表上进行，因为可以在全局DefaultRegisterer变量中找到它。使用NewRegistry，您可以创建自定义注册表，甚至可以自己实现Registerer或Gatherer接口。注册和注销方法在自定义注册表上的工作方式与默认注册表上的全局函数注册和注销的工作方式相同。\n自定义注册表有多种用途：您可以使用具有特殊属性的注册表，请参阅NewPedanticRegistry。您可以避免由DefaultRegisterer施加的全局状态。您可以同时使用多个注册表，以不同的方式公开不同的指标。您可以将单独的注册表用于测试目的。\n还请注意，DefaultRegisterer已注册了Go运行时Metric的收集器（通过NewGoCollector）和过程度量的收集器（通过NewProcessCollector）。使用自定义注册表，您可以控制并自行决定要注册的收集器。\nHTTP解释 注册表实现了Gatherer接口。然后，Gather方法的调用者可以以某种方式公开收集的指标。通常，度量是通过/metrics端点上的HTTP提供的。在上面的示例中就是这种情况。通过HTTP公开指标的工具位于promhttp子软件包中。\n推到Pushgateway 在push子包中可以找到用于推送到Pushgateway的功能。\nGraphite Bridge 在Graphite Bridge子包中可以找到将度量从采集器推向Graphite的函数和示例。\n通过遵循现有实现的方法，可以轻松添加更多公开指标的方法。\n常量 1 2 3 4 5 6 7 8 9 10  const ( // DefMaxAge is the default duration for which observations stay \t// relevant. \tDefMaxAge time.Duration = 10 * time.Minute // DefAgeBuckets is the default number of buckets used to calculate the \t// age of observations. \tDefAgeBuckets = 5 // DefBufCap is the standard buffer size for collecting Summary observations. \tDefBufCap = 500 )   SummaryOpts的默认值。\n1  const ExemplarMaxRunes = 64   ExemplarMaxRunes是示例标签中允许的最大符文总数。\n变量 1 2 3 4  var ( DefaultRegisterer Registerer = defaultRegistry DefaultGatherer Gatherer = defaultRegistry )   DefaultRegisterer和DefaultGatherer是Registerer和Gatherer接口的实现，此包中的许多便捷功能都作用于该接口。最初，这两个变量都指向同一个注册表，该注册表具有一个进程收集器（当前仅在Linux上，请参阅NewProcessCollector）和一个Go收集器（请参阅NewGoCollector，尤其是有关1.9之前的Go版本的停止世界的注释）已经登记了。这种将默认实例保持为全局状态的方法反映了Go标准库中其他软件包的方法。请注意，有一些警告。仅当您了解后果后，才应谨慎更改变量。希望完全避免全局状态的用户不应使用便捷功能，而应对自定义实例进行操作。\n1 2 3  var ( DefBuckets = []float64{.005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10} )   DefBuckets是默认的直方图存储桶。定制了默认存储桶，以广泛地衡量网络服务的响应时间（以秒为单位）。但是，很可能需要您定义针对用例定制的存储桶。\nfunc BuildFQName 1  func BuildFQName(namespace, subsystem, name string) string   BuildFQName通过“_”连接给定的三个名称组件。空名称组件将被忽略。如果name参数本身为空，则无论如何都将返回一个空字符串。该库中包含的Metric实现在内部使用此函数从其Opts中的名称组件生成完全限定的Metric名称。库的用户仅在实现自己的Metric或直接实例化Desc（使用NewDesc）时才需要此功能。\nfunc DescribeByCollect 1  func DescribeByCollect(c Collector, descs chan *Desc)   DescribeByCollect是实现自定义收集器的Describe方法的助手。它从提供的收集器收集度量，并将其描述符发送到提供的通道。\n如果收集器在其整个生命周期内收集相同的指标，则其Describe方法可以简单地实现为：\n1 2 3  func (c customCollector) Describe(ch chan *Desc) { DescribeByCollect(c, ch) }   但是，如果收集的指标在收集器的整个生命周期中以其描述符组合的集合也发生变化的方式动态变化，则这将不起作用。然后，快捷方式实现将违反Describe方法的约定。如果收集器有时根本不收集任何指标（例如，CounterVec，GaugeVec等向量，它们仅在访问具有完全指定的标签集的指标后才收集指标），它甚至可能注册为未经检查的收集器（参见。Registerer接口的Register方法）。因此，如果您确定要履行合同，请仅使用Describe的此快捷方式实现。\n收集器示例演示了DescribeByCollect的用法。\nfunc ExponentialBuckets 1  func ExponentialBuckets(start, factor float64, count int) []float64   ExponentialBuckets创建“计数”存储桶，其中最低存储桶的上限为“start”，随后每个存储桶的上限为“factor”乘以上一个存储桶的上限。最终的+ Inf存储桶不计算在内，也不包含在返回的切片中。返回的切片应用于HistogramOpts的Buckets字段。\n如果’count’为0或负数，如果’start’为0或负数，或者’factor’小于或等于1，则函数将发生错误。\nfunc LinearBuckets 1  func LinearBuckets(start, width float64, count int) []float64   LinearBuckets创建“计数”存储区，每个“宽度”宽，其中最低存储区的上限为“start”。最终的+ Inf存储桶不计算在内，也不包含在返回的切片中。返回的切片应用于HistogramOpts的Buckets字段。\n如果“count”为零或负数，该函数将出现panic。\nfunc MustRegister 1  func MustRegister(cs ...Collector)   MustRegister会使用DefaultRegisterer注册提供的收集器，如果发生任何错误，则会出现恐慌。\nMustRegister是DefaultRegisterer.MustRegister（cs …）的快捷方式。请参阅此处以获取更多详细信息。\nfunc Register\n1  func Register(c Collector) error   Register向DefaultRegisterer注册提供的收集器。\nRegister是DefaultRegisterer.Register(c)的快捷方式。\n例子\nCode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133  // Imagine you have a worker pool and want to count the tasks completed. taskCounter := prometheus.NewCounter(prometheus.CounterOpts{ Subsystem: \"worker_pool\", Name: \"completed_tasks_total\", Help: \"Total number of tasks completed.\", }) // This will register fine. if err := prometheus.Register(taskCounter); err != nil { fmt.Println(err) } else { fmt.Println(\"taskCounter registered.\") } // Don't forget to tell the HTTP server about the Prometheus handler. // (In a real program, you still need to start the HTTP server...) http.Handle(\"/metrics\", promhttp.Handler()) // Now you can start workers and give every one of them a pointer to // taskCounter and let it increment it whenever it completes a task. taskCounter.Inc() // This has to happen somewhere in the worker code.  // But wait, you want to see how individual workers perform. So you need // a vector of counters, with one element for each worker. taskCounterVec := prometheus.NewCounterVec( prometheus.CounterOpts{ Subsystem: \"worker_pool\", Name: \"completed_tasks_total\", Help: \"Total number of tasks completed.\", }, []string{\"worker_id\"}, ) // Registering will fail because we already have a metric of that name. if err := prometheus.Register(taskCounterVec); err != nil { fmt.Println(\"taskCounterVec not registered:\", err) } else { fmt.Println(\"taskCounterVec registered.\") } // To fix, first unregister the old taskCounter. if prometheus.Unregister(taskCounter) { fmt.Println(\"taskCounter unregistered.\") } // Try registering taskCounterVec again. if err := prometheus.Register(taskCounterVec); err != nil { fmt.Println(\"taskCounterVec not registered:\", err) } else { fmt.Println(\"taskCounterVec registered.\") } // Bummer! Still doesn't work.  // Prometheus will not allow you to ever export metrics with // inconsistent help strings or label names. After unregistering, the // unregistered metrics will cease to show up in the /metrics HTTP // response, but the registry still remembers that those metrics had // been exported before. For this example, we will now choose a // different name. (In a real program, you would obviously not export // the obsolete metric in the first place.) taskCounterVec = prometheus.NewCounterVec( prometheus.CounterOpts{ Subsystem: \"worker_pool\", Name: \"completed_tasks_by_id\", Help: \"Total number of tasks completed.\", }, []string{\"worker_id\"}, ) if err := prometheus.Register(taskCounterVec); err != nil { fmt.Println(\"taskCounterVec not registered:\", err) } else { fmt.Println(\"taskCounterVec registered.\") } // Finally it worked!  // The workers have to tell taskCounterVec their id to increment the // right element in the metric vector. taskCounterVec.WithLabelValues(\"42\").Inc() // Code from worker 42.  // Each worker could also keep a reference to their own counter element // around. Pick the counter at initialization time of the worker. myCounter := taskCounterVec.WithLabelValues(\"42\") // From worker 42 initialization code. myCounter.Inc() // Somewhere in the code of that worker.  // Note that something like WithLabelValues(\"42\", \"spurious arg\") would // panic (because you have provided too many label values). If you want // to get an error instead, use GetMetricWithLabelValues(...) instead. notMyCounter, err := taskCounterVec.GetMetricWithLabelValues(\"42\", \"spurious arg\") if err != nil { fmt.Println(\"Worker initialization failed:\", err) } if notMyCounter == nil { fmt.Println(\"notMyCounter is nil.\") } // A different (and somewhat tricky) approach is to use // ConstLabels. ConstLabels are pairs of label names and label values // that never change. Each worker creates and registers an own Counter // instance where the only difference is in the value of the // ConstLabels. Those Counters can all be registered because the // different ConstLabel values guarantee that each worker will increment // a different Counter metric. counterOpts := prometheus.CounterOpts{ Subsystem: \"worker_pool\", Name: \"completed_tasks\", Help: \"Total number of tasks completed.\", ConstLabels: prometheus.Labels{\"worker_id\": \"42\"}, } taskCounterForWorker42 := prometheus.NewCounter(counterOpts) if err := prometheus.Register(taskCounterForWorker42); err != nil { fmt.Println(\"taskCounterVForWorker42 not registered:\", err) } else { fmt.Println(\"taskCounterForWorker42 registered.\") } // Obviously, in real code, taskCounterForWorker42 would be a member // variable of a worker struct, and the \"42\" would be retrieved with a // GetId() method or something. The Counter would be created and // registered in the initialization code of the worker.  // For the creation of the next Counter, we can recycle // counterOpts. Just change the ConstLabels. counterOpts.ConstLabels = prometheus.Labels{\"worker_id\": \"2001\"} taskCounterForWorker2001 := prometheus.NewCounter(counterOpts) if err := prometheus.Register(taskCounterForWorker2001); err != nil { fmt.Println(\"taskCounterVForWorker2001 not registered:\", err) } else { fmt.Println(\"taskCounterForWorker2001 registered.\") } taskCounterForWorker2001.Inc() taskCounterForWorker42.Inc() taskCounterForWorker2001.Inc() // Yet another approach would be to turn the workers themselves into // Collectors and register them. See the Collector example for details.   Output:\n1 2 3 4 5 6 7 8 9  taskCounter registered. taskCounterVec not registered: a previously registered descriptor with the same fully-qualified name as Desc{fqName: \"worker_pool_completed_tasks_total\", help: \"Total number of tasks completed.\", constLabels: {}, variableLabels: [worker_id]} has different label names or a different help string taskCounter unregistered. taskCounterVec not registered: a previously registered descriptor with the same fully-qualified name as Desc{fqName: \"worker_pool_completed_tasks_total\", help: \"Total number of tasks completed.\", constLabels: {}, variableLabels: [worker_id]} has different label names or a different help string taskCounterVec registered. Worker initialization failed: inconsistent label cardinality: expected 1 label values but got 2 in []string{\"42\", \"spurious arg\"} notMyCounter is nil. taskCounterForWorker42 registered. taskCounterForWorker2001 registered.   func Unregister 1  func Unregister(c Collector) bool   Unregister将从DefaultRegisterer中删除提供的收集器的注册。\nUnregister是DefaultRegisterer.Unregister(c)的快捷方式。\nfunc WriteToTextfile 1  func WriteToTextfile(filename string, g Gatherer) error   WriteToTextfile在提供的Gatherer上调用Gather，将结果编码为Prometheus文本格式，并将其写入临时文件。成功后，临时文件将重命名为提供的文件名。\n这旨在与节点导出器的文本文件收集器一起使用。请注意，节点导出器期望文件名后缀为“ .prom”。\ntype AlreadyRegisteredError 1 2 3  type AlreadyRegisteredError struct { ExistingCollector, NewCollector Collector }   如果以前已经注册了要注册的收集器，或者之前已经注册了收集相同度量的其他收集器，则Register方法将返回AlreadyRegisteredError。在这种情况下，注册失败，但是您可以从错误类型中检测出发生了什么。该错误包含现有收集器和与现有收集器相等的（被拒绝）新收集器的字段。如示例所示，这可用于查找是否已注册了相等的收集器，然后切换到使用旧的收集器。\n例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  reqCounter := prometheus.NewCounter(prometheus.CounterOpts{ Name: \"requests_total\", Help: \"The total number of requests served.\", }) if err := prometheus.Register(reqCounter); err != nil { if are, ok := err.(prometheus.AlreadyRegisteredError); ok { // A counter for that metric has been registered before. \t// Use the old counter from now on. \treqCounter = are.ExistingCollector.(prometheus.Counter) } else { // Something else went wrong! \tpanic(err) } } reqCounter.Inc()   func (AlreadyRegisteredError) Error 1  func (err AlreadyRegisteredError) Error() string   type Collector 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  type Collector interface { // Describe sends the super-set of all possible descriptors of metrics \t// collected by this Collector to the provided channel and returns once \t// the last descriptor has been sent. The sent descriptors fulfill the \t// consistency and uniqueness requirements described in the Desc \t// documentation. \t// \t// It is valid if one and the same Collector sends duplicate \t// descriptors. Those duplicates are simply ignored. However, two \t// different Collectors must not send duplicate descriptors. \t// \t// Sending no descriptor at all marks the Collector as “unchecked”, \t// i.e. no checks will be performed at registration time, and the \t// Collector may yield any Metric it sees fit in its Collect method. \t// \t// This method idempotently sends the same descriptors throughout the \t// lifetime of the Collector. It may be called concurrently and \t// therefore must be implemented in a concurrency safe way. \t// \t// If a Collector encounters an error while executing this method, it \t// must send an invalid descriptor (created with NewInvalidDesc) to \t// signal the error to the registry. \tDescribe(chan *Desc) // Collect is called by the Prometheus registry when collecting \t// metrics. The implementation sends each collected metric via the \t// provided channel and returns once the last metric has been sent. The \t// descriptor of each sent metric is one of those returned by Describe \t// (unless the Collector is unchecked, see above). Returned metrics that \t// share the same descriptor must differ in their variable label \t// values. \t// \t// This method may be called concurrently and must therefore be \t// implemented in a concurrency safe way. Blocking occurs at the expense \t// of total performance of rendering all registered metrics. Ideally, \t// Collector implementations support concurrent readers. \tCollect(chan Metric) }   收集器是由Prometheus可以用来收集Metric的任何东西实现的接口。必须为收集器注册收集器。请参阅Registerer.Register。\n此程序包提供的库存指标（量规，计数器，汇总，直方图，无类型）也是收集器（仅收集一个指标，即本身）。但是，收集器的实现者可以以协调的方式收集多个指标和/或即时创建指标。已经在该库中实现的收集器的示例是度量向量（即，同一Metric但具有不同标签值的多个实例的集合），例如GaugeVec或SummaryVec，以及ExpvarCollector。\n例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129  package prometheus_test import ( \"log\" \"net/http\" \"github.com/prometheus/client_golang/prometheus\" \"github.com/prometheus/client_golang/prometheus/promhttp\" ) // ClusterManager is an example for a system that might have been built without // Prometheus in mind. It models a central manager of jobs running in a // cluster. Thus, we implement a custom Collector called // ClusterManagerCollector, which collects information from a ClusterManager // using its provided methods and turns them into Prometheus Metrics for // collection. // // An additional challenge is that multiple instances of the ClusterManager are // run within the same binary, each in charge of a different zone. We need to // make use of wrapping Registerers to be able to register each // ClusterManagerCollector instance with Prometheus. type ClusterManager struct { Zone string // Contains many more fields not listed in this example. } // ReallyExpensiveAssessmentOfTheSystemState is a mock for the data gathering a // real cluster manager would have to do. Since it may actually be really // expensive, it must only be called once per collection. This implementation, // obviously, only returns some made-up data. func (c *ClusterManager) ReallyExpensiveAssessmentOfTheSystemState() ( oomCountByHost map[string]int, ramUsageByHost map[string]float64, ) { // Just example fake data. \toomCountByHost = map[string]int{ \"foo.example.org\": 42, \"bar.example.org\": 2001, } ramUsageByHost = map[string]float64{ \"foo.example.org\": 6.023e23, \"bar.example.org\": 3.14, } return } // ClusterManagerCollector implements the Collector interface. type ClusterManagerCollector struct { ClusterManager *ClusterManager } // Descriptors used by the ClusterManagerCollector below. var ( oomCountDesc = prometheus.NewDesc( \"clustermanager_oom_crashes_total\", \"Number of OOM crashes.\", []string{\"host\"}, nil, ) ramUsageDesc = prometheus.NewDesc( \"clustermanager_ram_usage_bytes\", \"RAM usage as reported to the cluster manager.\", []string{\"host\"}, nil, ) ) // Describe is implemented with DescribeByCollect. That's possible because the // Collect method will always return the same two metrics with the same two // descriptors. func (cc ClusterManagerCollector) Describe(ch chan *prometheus.Desc) { prometheus.DescribeByCollect(cc, ch) } // Collect first triggers the ReallyExpensiveAssessmentOfTheSystemState. Then it // creates constant metrics for each host on the fly based on the returned data. // // Note that Collect could be called concurrently, so we depend on // ReallyExpensiveAssessmentOfTheSystemState to be concurrency-safe. func (cc ClusterManagerCollector) Collect(ch chan prometheus.Metric) { oomCountByHost, ramUsageByHost := cc.ClusterManager.ReallyExpensiveAssessmentOfTheSystemState() for host, oomCount := range oomCountByHost { ch  prometheus.MustNewConstMetric( oomCountDesc, prometheus.CounterValue, float64(oomCount), host, ) } for host, ramUsage := range ramUsageByHost { ch  prometheus.MustNewConstMetric( ramUsageDesc, prometheus.GaugeValue, ramUsage, host, ) } } // NewClusterManager first creates a Prometheus-ignorant ClusterManager // instance. Then, it creates a ClusterManagerCollector for the just created // ClusterManager. Finally, it registers the ClusterManagerCollector with a // wrapping Registerer that adds the zone as a label. In this way, the metrics // collected by different ClusterManagerCollectors do not collide. func NewClusterManager(zone string, reg prometheus.Registerer) *ClusterManager { c := \u0026ClusterManager{ Zone: zone, } cc := ClusterManagerCollector{ClusterManager: c} prometheus.WrapRegistererWith(prometheus.Labels{\"zone\": zone}, reg).MustRegister(cc) return c } func ExampleCollector() { // Since we are dealing with custom Collector implementations, it might \t// be a good idea to try it out with a pedantic registry. \treg := prometheus.NewPedanticRegistry() // Construct cluster managers. In real code, we would assign them to \t// variables to then do something with them. \tNewClusterManager(\"db\", reg) NewClusterManager(\"ca\", reg) // Add the standard process and Go metrics to the custom registry. \treg.MustRegister( prometheus.NewProcessCollector(prometheus.ProcessCollectorOpts{}), prometheus.NewGoCollector(), ) http.Handle(\"/metrics\", promhttp.HandlerFor(reg, promhttp.HandlerOpts{})) log.Fatal(http.ListenAndServe(\":8080\", nil)) }   func NewBuildInfoCollector 1  func NewBuildInfoCollector() Collector   NewBuildInfoCollector返回一个收集器，该收集器收集具有恒定值1和三个标签“ path”，“version”和“checksum”的单个度量“ go_build_info”。它们的标签值分别包含主模块路径，版本和校验和。如果二进制文件是通过Go模块支持并从从源存储库（而不是本地文件系统）检索的源代码构建的，则标签将只有有意义的值。通常，这可以通过从GOPATH外部进行构建来完成，并指定主软件包的完整地址，例如“ GO111MODULE = on go run github.com/prometheus/client_golang/examples/random”。如果构建时不支持Go模块，则所有标签值将为“未知”。如果使用Go模块支持构建，但使用本地文件系统的源代码，“path”将被适当设置，但“checksum”将为空，“version”将为“（devel）”。\n该收集器仅将构建信息用于主模块。有关模块依赖项的收集器示例，请参见 https://github.com/povilasv/prommod。\nfunc NewExpvarCollector 1  func NewExpvarCollector(exports map[string]*Desc) Collector   NewExpvarCollector返回一个新分配的expvar收集器，该收集器仍必须在Prometheus注册表中进行注册。\nexpvar收集器从expvar接口收集指标。它提供了一种快速的方法来公开已经通过expvar导出为Prometheus指标的数值。请注意，expvar和Prometheus的数据模型本质上是不同的，并且expvar Collector本质上比本地Prometheus指标慢。因此，expvar Collector可能非常适合进行实验和原型制作，但是您应该认真考虑更直接地实现PrometheusMetric以监视生产系统。\nexports map具有以下含义：\n映射中的键对应于expvar键，即对于要导出为PrometheusMetric的每个expvar键，在导出映射中都需要一个条目。映射到每个键的描述符描述了如何导出expvar值。它定义PrometheusMetric的名称和帮助字符串，以替代expvar值。该类型将始终为“无类型”。\n对于没有变量标签的描述符，expvar值必须是数字或布尔值。然后将数字直接导出为Prometheus样本值。（对于布尔值，“false”表示0，“ true”表示1）。不是数字或布尔值的Expvar值将被静默忽略。\n如果描述符具有一个变量标签，则expvar值必须是一个expvar映射。expvar映射中的键成为一个Prometheus标签的各种值。如上所述，expvar映射中的值必须再次为数字或布尔值。\n对于具有多个变量标签的描述符，expvar必须是嵌套的expvar映射，即，最顶部映射的值再次是映射等，直到达到与标签数量相对应的深度。该结构的叶子必须是上面的数字或布尔值，才能用作样本值。\n任何不适合上述方案的内容都会被忽略。\n例子\nCode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  expvarCollector := prometheus.NewExpvarCollector(map[string]*prometheus.Desc{ \"memstats\": prometheus.NewDesc( \"expvar_memstats\", \"All numeric memstats as one metric family. Not a good role-model, actually... ;-)\", []string{\"type\"}, nil, ), \"lone-int\": prometheus.NewDesc( \"expvar_lone_int\", \"Just an expvar int as an example.\", nil, nil, ), \"http-request-map\": prometheus.NewDesc( \"expvar_http_request_total\", \"How many http requests processed, partitioned by status code and http method.\", []string{\"code\", \"method\"}, nil, ), }) prometheus.MustRegister(expvarCollector) // The Prometheus part is done here. But to show that this example is // doing anything, we have to manually export something via expvar. In // real-life use-cases, some library would already have exported via // expvar what we want to re-export as Prometheus metrics. expvar.NewInt(\"lone-int\").Set(42) expvarMap := expvar.NewMap(\"http-request-map\") var ( expvarMap1, expvarMap2 expvar.Map expvarInt11, expvarInt12, expvarInt21, expvarInt22 expvar.Int ) expvarMap1.Init() expvarMap2.Init() expvarInt11.Set(3) expvarInt12.Set(13) expvarInt21.Set(11) expvarInt22.Set(212) expvarMap1.Set(\"POST\", \u0026expvarInt11) expvarMap1.Set(\"GET\", \u0026expvarInt12) expvarMap2.Set(\"POST\", \u0026expvarInt21) expvarMap2.Set(\"GET\", \u0026expvarInt22) expvarMap.Set(\"404\", \u0026expvarMap1) expvarMap.Set(\"200\", \u0026expvarMap2) // Results in the following expvar map: // \"http-request-count\": {\"200\": {\"POST\": 11, \"GET\": 212}, \"404\": {\"POST\": 3, \"GET\": 13}}  // Let's see what the scrape would yield, but exclude the memstats metrics. metricStrings := []string{} metric := dto.Metric{} metricChan := make(chan prometheus.Metric) go func() { expvarCollector.Collect(metricChan) close(metricChan) }() for m := range metricChan { if !strings.Contains(m.Desc().String(), \"expvar_memstats\") { metric.Reset() m.Write(\u0026metric) metricStrings = append(metricStrings, metric.String()) } } sort.Strings(metricStrings) for _, s := range metricStrings { fmt.Println(strings.TrimRight(s, \" \")) }   Output:\n1 2 3 4 5  label:name:\"code\" value:\"200\"  label:name:\"method\" value:\"GET\"  untyped:value:212  label:name:\"code\" value:\"200\"  label:name:\"method\" value:\"POST\"  untyped:value:11  label:name:\"code\" value:\"404\"  label:name:\"method\" value:\"GET\"  untyped:value:13  label:name:\"code\" value:\"404\"  label:name:\"method\" value:\"POST\"  untyped:value:3  untyped:value:42    func NewGoCollector 1  func NewGoCollector() Collector   NewGoCollector返回一个收集器，该收集器导出有关当前Go流程的指标。这包括内存统计信息。要收集这些内容，将调用runtime.ReadMemStats。这需要“停止世界”，通常仅在垃圾回收（GC）中发生。在决定是否使用Go收集器时，请考虑以下含义：\n1.停止世界对性能的影响越重要，收集指标的频率就越高。但是，使用Go1.9或更高版本时，每个指标收集的世界停止时间非常短（〜25µs），因此对性能的影响仅在极少数情况下才重要。但是，对于较旧的Go版本，“停下世界”的持续时间取决于堆的大小，并且可能相当长（根据https://go-review.googlesource.com/c/go/+/，约为1.7 ms / GiB 34937）。\n2.在进行中的GC期间，没有其他事情可以阻止世界。因此，如果指标收集恰好与GC一致，则只有在GC完成后才能完成。通常，GC足够快，不会引起问题。但是，对于非常大的堆，GC可能需要花费几秒钟的时间，这足以在常规设置中引起scrape超时。为避免此问题，如果runtime.ReadMemStats花费的时间超过1s，则Go收集器将使用先前集合中的memstats。但是，如果以前没有收集过memstats，或者它们的收集时间超过5m，则收集将阻塞，直到runtime.ReadMemStats成功。（该问题可能会在Go1.13中解决，有关相关的Go问题，请参见https://github.com/golang/go/issues/19812。）\nfunc NewProcessCollector 1  func NewProcessCollector(opts ProcessCollectorOpts) Collector   NewProcessCollector返回一个收集器，该收集器导出过程度量的当前状态，包括CPU，内存和文件描述符的使用情况以及过程开始时间。详细行为由提供的ProcessCollectorOpts定义。ProcessCollectorOpts的零值将为当前进程创建一个收集器，该收集器具有空的名称空间字符串，并且没有错误报告。\n收集器仅适用于具有Linux样式proc文件系统的操作系统以及Microsoft Windows。在其他操作系统上，它将不收集任何指标。\ntype Counter 1 2 3 4 5 6 7 8 9 10 11  type Counter interface { Metric Collector // Inc increments the counter by 1. Use Add to increment it by arbitrary \t// non-negative values. \tInc() // Add adds the given value to the counter. It panics if the value is \t// 0. \tAdd(float64) }   计数器是一种Metric，它表示只会递增的单个数值。这意味着它不能用于计数数量也可能下降的项目，例如当前正在运行的goroutines的数量。这些“计数器”由量规代表。\n计数器通常用于对服务的请求，完成的任务，发生的错误等进行计数。\n若要创建Counter实例，请使用NewCounter。\nfunc NewCounter 1  func NewCounter(opts CounterOpts) Counter   NewCounter基于提供的CounterOpts创建一个新的Counter。\n返回的实现还实现ExemplarAdder。执行相应的类型声明是安全的。\n返回的实现在两个单独的变量float64和uint64中跟踪计数器值。后者用于跟踪Inc方法的调用和具有可以表示为uint64的值的Add方法的调用。这使得计数器的原子增量具有最佳性能。（通常在非常热的执行路径中进行Inc调用。）这两个内部跟踪值都在Write方法中相加。当涉及到精度和溢出行为时，必须考虑到这一点。\ntype CounterFunc 1 2 3 4  type CounterFunc interface { Metric Collector }   CounterFunc是一个Counter，其值在收集时通过调用提供的函数确定。\n若要创建CounterFunc实例，请使用NewCounterFunc。\nfunc NewCounterFunc 1  func NewCounterFunc(opts CounterOpts, function func() float64) CounterFunc   NewCounterFunc基于提供的CounterOpts创建一个新的CounterFunc。报告的值是通过在Write方法中调用给定的函数确定的。考虑到指标收集可能会同时发生。如果这导致对Write的并发调用，例如将CounterFunc直接注册到Prometheus的情况，则提供的函数必须是并发安全的。该功能还应遵守计数器合同（值只会上升，不会下降），但不会检查合规性。\n查看类似的GaugeFunc的ExampleGaugeFunc示例。\ntype CounterOpts 1  type CounterOpts Opts   CounterOpts是Opts的别名。请参阅此处以获取文档注释。\ntype CounterVec 1 2 3  type CounterVec struct { // contains filtered or unexported fields }   CounterVec是一个收集器，捆绑了一组共享相同Desc，但其变量标签具有不同值的Counter。如果您要计算按不同维度划分的同一事物（例如，HTTP请求的数量，按响应代码和方法划分的），则使用此方法。使用NewCounterVec创建实例。\n例子\nCode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  httpReqs := prometheus.NewCounterVec( prometheus.CounterOpts{ Name: \"http_requests_total\", Help: \"How many HTTP requests processed, partitioned by status code and HTTP method.\", }, []string{\"code\", \"method\"}, ) prometheus.MustRegister(httpReqs) httpReqs.WithLabelValues(\"404\", \"POST\").Add(42) // If you have to access the same set of labels very frequently, it // might be good to retrieve the metric only once and keep a handle to // it. But beware of deletion of that metric, see below! m := httpReqs.WithLabelValues(\"200\", \"GET\") for i := 0; i  1000000; i++ { m.Inc() } // Delete a metric from the vector. If you have previously kept a handle // to that metric (as above), future updates via that handle will go // unseen (even if you re-create a metric with the same label set // later). httpReqs.DeleteLabelValues(\"200\", \"GET\") // Same thing with the more verbose Labels syntax. httpReqs.Delete(prometheus.Labels{\"method\": \"GET\", \"code\": \"200\"})   func NewCounterVec 1  func NewCounterVec(opts CounterOpts, labelNames []string) *CounterVec   NewCounterVec基于提供的CounterOpts创建新的CounterVec，并按给定的标签名称进行分区。\nfunc (CounterVec) Collect 1  func (m CounterVec) Collect(ch chan Metric)   Collect 实现 Collector.\nfunc (*CounterVec) CurryWith 1  func (v *CounterVec) CurryWith(labels Labels) (*CounterVec, error)   CurryWith返回使用提供的标签进行咖喱处理的向量，即返回的向量具有针对其执行的所有标记操作预先设置的那些标签。相应地减小了咖喱矢量的基数。其余标签的顺序保持不变（只是将咖喱标签从序列中取出，这与（GetMetric）WithLabelValues方法有关）。可以咖喱咖喱的矢量，但只能使用之前尚未用于咖喱的标签。\nCounterVec中包含的度量在已管理和未已管理向量之间共享。只是以不同的方式访问它们。在集合方面，咖喱和非咖喱向量的行为相同。必须在给定的注册表中注册一个（通常是未更新的版本）。即使对当前向量调用了Reset方法，Reset方法也会删除所有指标。\nfunc (CounterVec) Delete 1  func (m CounterVec) Delete(labels Labels) bool   Delete会删除指标，其中变量标签与作为标签传入的标签相同。如果删除了指标，则返回true。\n如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致，则不是错误。但是，此类不一致的标签永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。\n此方法与DeleteLabelValues（… string）的用途相同。有关两种方法的优缺点，请参见此处。\nfunc (CounterVec) DeleteLabelValues 1  func (m CounterVec) DeleteLabelValues(lvs ...string) bool   DeleteLabelValues删除Metric，其中变量标签与作为标签传入的变量相同（与Desc中的VariableLabel顺序相同）。如果删除了指标，则返回true。\n如果标签值的数量与Desc中的VariableLabels的数量不同，这不是错误。但是，这种不一致的标签计数永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。\n请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用Delete（Labels）来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。另请参见CounterVec示例。\nfunc (CounterVec) Describe 1  func (m CounterVec) Describe(ch chan *Desc)   Describe 实现 Collector.\nfunc (*CounterVec) GetMetricWith 1  func (v *CounterVec) GetMetricWith(labels Labels) (Counter, error)   GetMetricWith返回给定Labels映射的Counter（标签名称必须与Desc中的VariableLabels的名称匹配）。如果是第一次访问该标签映射，则会创建一个新的计数器。不使用计数器创建计数器并保留该计数器供以后使用的含义与GetMetricWithLabelValues相同。\n如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致（减去任何已处理的标签），则会返回错误。\n此方法与GetMetricWithLabelValues（… string）的用途相同。有关两种方法的优缺点，请参见此处。\nfunc (*CounterVec) GetMetricWithLabelValues 1  func (v *CounterVec) GetMetricWithLabelValues(lvs ...string) (Counter, error)   GetMetricWithLabelValues返回给定标签值切片的计数器（与Desc中的VariableLabels顺序相同）。如果是第一次访问标签值的组合，则会创建一个新的计数器。\n可以调用此方法而无需使用返回的Counter来仅创建新的Counter，而将其保留为起始值0。另请参见SummaryVec示例。\n可以保留Counter以便以后使用（如果性能至关重要，则应考虑使用），但是请记住，可以使用Reset，DeleteLabelValues和Delete从CounterVec删除Counter。在这种情况下，即使以后创建具有相同标签值的计数器，该计数器仍将存在，但不再导出。\n如果标签值的数量与Desc中的VariableLabels的数量（减去任何已固化的标签）不同，则返回错误。\n请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用GetMetricWith（Labels）作为替代方案来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。另请参见GaugeVec示例。\nfunc (*CounterVec) MustCurryWith 1  func (v *CounterVec) MustCurryWith(labels Labels) *CounterVec   MustCurryWith可以作为CurryWith使用，但在CurryWith会返回错误的情况下会出现panic。\nfunc (CounterVec) Reset 1  func (m CounterVec) Reset()   重置将删除此向量中的所有指标。\nfunc (*CounterVec) With 1  func (v *CounterVec) With(labels Labels) Counter   With与GetMetricWith一样工作，但在GetMetricWithLabels会返回错误的地方感到慌张。不返回错误允许使用以下快捷方式\n1  myVec.WithLabelValues(\"404\", \"GET\").Add(42)   func (*CounterVec) WithLabelValues 1  func (v *CounterVec) WithLabelValues(lvs ...string) Counter   WithLabelValues可以用作GetMetricWithLabelValues，但是在GetMetricWithLabelValues会返回错误的地方出现混乱。不返回错误允许使用以下快捷方式\n1  myVec.WithLabelValues(\"404\", \"GET\").Add(42)   type Gauge 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  type Gauge interface { Metric Collector // Set sets the Gauge to an arbitrary value. \tSet(float64) // Inc increments the Gauge by 1. Use Add to increment it by arbitrary \t// values. \tInc() // Dec decrements the Gauge by 1. Use Sub to decrement it by arbitrary \t// values. \tDec() // Add adds the given value to the Gauge. (The value can be negative, \t// resulting in a decrease of the Gauge.) \tAdd(float64) // Sub subtracts the given value from the Gauge. (The value can be \t// negative, resulting in an increase of the Gauge.) \tSub(float64) // SetToCurrentTime sets the Gauge to the current Unix time in seconds. \tSetToCurrentTime() }   Gauge是一种Metric，代表可以任意增加和减少的单个数值。\n仪表通常用于测量值，例如温度或当前的内存使用情况，还用于可能上升和下降的“计数”，例如正在运行的goroutine的数量。\n要创建仪表实例，请使用NewGauge。\n例子\nCode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  opsQueued := prometheus.NewGauge(prometheus.GaugeOpts{ Namespace: \"our_company\", Subsystem: \"blob_storage\", Name: \"ops_queued\", Help: \"Number of blob storage operations waiting to be processed.\", }) prometheus.MustRegister(opsQueued) // 10 operations queued by the goroutine managing incoming requests. opsQueued.Add(10) // A worker goroutine has picked up a waiting operation. opsQueued.Dec() // And once more... opsQueued.Dec()   func NewGauge 1  func NewGauge(opts GaugeOpts) Gauge   NewGauge根据提供的GaugeOpts创建一个新的Gauge。\n返回的实现针对快速Set方法进行了优化。如果您可以选择通过Set vs.Inc/Dec/Add/Sub来管理仪表的值，请选择前者。例如，返回的仪表的Inc方法比NewCounter返回的Counter的Inc方法慢。这与“Gauges”和“Counters”的典型方案相符，前者倾向于“重置类重载”，而后者倾向于“增加类重载”。\ntype GaugeFunc 1 2 3 4  type GaugeFunc interface { Metric Collector }   GaugeFunc是一个Gauge，其值是在收集时通过调用提供的函数确定的。\n要创建GaugeFunc实例，请使用NewGaugeFunc。\n示例（ConstLabels）\nCode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // primaryDB and secondaryDB represent two example *sql.DB connections we want to instrument. var primaryDB, secondaryDB interface { Stats() struct{ OpenConnections int } } if err := prometheus.Register(prometheus.NewGaugeFunc( prometheus.GaugeOpts{ Namespace: \"mysql\", Name: \"connections_open\", Help: \"Number of mysql connections open.\", ConstLabels: prometheus.Labels{\"destination\": \"primary\"}, }, func() float64 { return float64(primaryDB.Stats().OpenConnections) }, )); err == nil { fmt.Println(`GaugeFunc 'connections_open' for primary DB connection registered with labels {destination=\"primary\"}`) } if err := prometheus.Register(prometheus.NewGaugeFunc( prometheus.GaugeOpts{ Namespace: \"mysql\", Name: \"connections_open\", Help: \"Number of mysql connections open.\", ConstLabels: prometheus.Labels{\"destination\": \"secondary\"}, }, func() float64 { return float64(secondaryDB.Stats().OpenConnections) }, )); err == nil { fmt.Println(`GaugeFunc 'connections_open' for secondary DB connection registered with labels {destination=\"secondary\"}`) } // Note that we can register more than once GaugeFunc with same metric name // as long as their const labels are consistent.   Output:\n1 2  GaugeFunc 'connections_open' for primary DB connection registered with labels {destination=\"primary\"} GaugeFunc 'connections_open' for secondary DB connection registered with labels {destination=\"secondary\"}   示例（简单）\nCode:\n1 2 3 4 5 6 7 8 9 10 11 12  if err := prometheus.Register(prometheus.NewGaugeFunc( prometheus.GaugeOpts{ Subsystem: \"runtime\", Name: \"goroutines_count\", Help: \"Number of goroutines that currently exist.\", }, func() float64 { return float64(runtime.NumGoroutine()) }, )); err == nil { fmt.Println(\"GaugeFunc 'goroutines_count' registered.\") } // Note that the count of goroutines is a gauge (and not a counter) as // it can go up and down.   Output:\n1  GaugeFunc 'goroutines_count' registered.   func NewGaugeFunc 1  func NewGaugeFunc(opts GaugeOpts, function func() float64) GaugeFunc   NewGaugeFunc基于提供的GaugeOpts创建一个新的GaugeFunc。报告的值是通过在Write方法中调用给定的函数确定的。考虑到指标收集可能会同时发生。因此，必须安全地同时调用提供的函数。\nNewGaugeFunc是创建常量值为1的“信息”风格指标的好方法。示例：https://github.com/prometheus/common/blob/8558a5b7db3c84fa38b4766966059a7bd5bfa2ee/version/info.go#L36-L56\ntype GaugeOpts 1  type GaugeOpts Opts   GaugeOpts是Opts的别名。请参阅此处以获取文档注释。\ntype GaugeVec 1 2 3  type GaugeVec struct { // contains filtered or unexported fields }   GaugeVec是一个收集器，它捆绑了一组共享相同Desc，但其变量标签具有不同值的Gauge。如果要统计按不同维度划分的同一事物（例如，排队的操作数，按用户和操作类型划分的分区），则使用此方法。使用NewGaugeVec创建实例。\n例子\nCode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  opsQueued := prometheus.NewGaugeVec( prometheus.GaugeOpts{ Namespace: \"our_company\", Subsystem: \"blob_storage\", Name: \"ops_queued\", Help: \"Number of blob storage operations waiting to be processed, partitioned by user and type.\", }, []string{ // Which user has requested the operation? \t\"user\", // Of what type is the operation? \t\"type\", }, ) prometheus.MustRegister(opsQueued) // Increase a value using compact (but order-sensitive!) WithLabelValues(). opsQueued.WithLabelValues(\"bob\", \"put\").Add(4) // Increase a value with a map using WithLabels. More verbose, but order // doesn't matter anymore. opsQueued.With(prometheus.Labels{\"type\": \"delete\", \"user\": \"alice\"}).Inc()   func NewGaugeVec 1  func NewGaugeVec(opts GaugeOpts, labelNames []string) *GaugeVec   NewGaugeVec基于提供的GaugeOpts创建新的GaugeVec，并按给定的标签名称进行分区。\nfunc (GaugeVec) Collect 1  func (m GaugeVec) Collect(ch chan Metric)   Collect 实现 Collector.\nfunc (*GaugeVec) CurryWith 1  func (v *GaugeVec) CurryWith(labels Labels) (*GaugeVec, error)   CurryWith返回使用提供的标签进行咖喱处理的向量，即返回的向量具有针对其执行的所有标记操作预先设置的那些标签。相应地减小了咖喱矢量的基数。其余标签的顺序保持不变（只是将咖喱标签从序列中取出，这与（GetMetric）WithLabelValues方法有关）。可以咖喱咖喱的矢量，但只能使用之前尚未用于咖喱的标签。\nGaugeVec中包含的Metric在已固化和未固化向量之间共享。只是以不同的方式访问它们。在集合方面，咖喱和非咖喱向量的行为相同。必须在给定的注册表中注册一个（通常是未更新的版本）。即使对当前向量调用了Reset方法，Reset方法也会删除所有指标。\nfunc (GaugeVec) Delete 1  func (m GaugeVec) Delete(labels Labels) bool   删除会删除指标，其中变量标签与作为标签传入的标签相同。如果删除了指标，则返回true。\n如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致，则不是错误。但是，此类不一致的标签永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。\n此方法与DeleteLabelValues（… string）的用途相同。有关两种方法的优缺点，请参见此处。\nfunc (GaugeVec) DeleteLabelValues 1  func (m GaugeVec) DeleteLabelValues(lvs ...string) bool   DeleteLabelValues删除Metric，其中变量标签与作为标签传入的变量相同（与Desc中的VariableLabel顺序相同）。如果删除了指标，则返回true。\n如果标签值的数量与Desc中的VariableLabels的数量不同，这不是错误。但是，这种不一致的标签计数永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。\n请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用Delete（Labels）来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。另请参见CounterVec示例。\nfunc (GaugeVec) Describe 1  func (m GaugeVec) Describe(ch chan *Desc   Describe 实现 Collector.\nfunc (*GaugeVec) GetMetricWith 1  func (v *GaugeVec) GetMetricWith(labels Labels) (Gauge, error)   GetMetricWith返回给定Labels映射的Gauge（标签名称必须与Desc中的VariableLabels的名称匹配）。如果是第一次访问该标签图，则会创建一个新的Gauge。不使用仪表创建仪表并保留仪表以备后用的含义与GetMetricWithLabelValues相同。\n如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致（减去任何已处理的标签），则会返回错误。\n此方法与GetMetricWithLabelValues（… string）的用途相同。有关两种方法的优缺点，请参见此处。\nfunc (*GaugeVec) GetMetricWithLabelValues 1  func (v *GaugeVec) GetMetricWithLabelValues(lvs ...string) (Gauge, error)   GetMetricWithLabelValues返回给定标签值切片的量规（与Desc中的VariableLabels顺序相同）。如果是第一次访问标签值的组合，则会创建一个新的仪表。\n可以在不使用返回的Gauge的情况下调用此方法，仅创建新的Gauge，而将其保留为初始值0。另请参见SummaryVec示例。\n可以保留仪表以备后用（如果性能至关重要，则应考虑使用），但请记住，可以使用Reset，DeleteLabelValues和Delete从GaugeVec删除仪表。在这种情况下，即使以后创建具有相同标签值的仪表，该仪表仍将存在，但将不再导出。另请参见CounterVec示例。\n如果标签值的数量与Desc中的VariableLabels的数量（减去任何已固化的标签）不同，则返回错误。\n请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用GetMetricWith（Labels）作为替代方案来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。\nfunc (*GaugeVec) MustCurryWith 1  func (v *GaugeVec) MustCurryWith(labels Labels) *GaugeVec   MustCurryWith可以作为CurryWith使用，但在CurryWith会返回错误的情况下会出现混乱。\nfunc (GaugeVec) Reset 1  func (m GaugeVec) Reset()   重置将删除此向量中的所有指标。\nfunc (*GaugeVec) With 1  func (v *GaugeVec) With(labels Labels) Gauge   With与GetMetricWith一样工作，但在GetMetricWithLabels会返回错误的地方感到慌张。不返回错误允许使用以下快捷方式\n1  myVec.With(prometheus.Labels{\"code\": \"404\", \"method\": \"GET\"}).Add(42)   func (*GaugeVec) WithLabelValues 1  func (v *GaugeVec) WithLabelValues(lvs ...string) Gauge   WithLabelValues可以用作GetMetricWithLabelValues，但是在GetMetricWithLabelValues会返回错误的地方出现混乱。不返回错误允许使用以下快捷方式\n1  myVec.WithLabelValues(\"404\", \"GET\").Add(42)   type Histogram 1 2 3 4 5 6 7  type Histogram interface { Metric Collector // Observe adds a single observation to the histogram. \tObserve(float64) }   直方图计算来自事件或样本流的可配置存储桶中的单个观察值。与摘要类似，它也提供观察值的总和和观察值。\n在Prometheus服务器上，可以使用查询语言中的histogram_quantile函数从直方图计算分位数。\n请注意，与摘要相比，直方图可以与Prometheus查询语言进行汇总（有关详细过程，请参见文档）。但是，直方图要求用户预先定义合适的bucket，并且通常精度较低。与摘要的Observe方法相比，直方图的Observe方法具有非常低的性能开销。\n要创建直方图实例，请使用NewHistogram。\n例子\nCode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  temps := prometheus.NewHistogram(prometheus.HistogramOpts{ Name: \"pond_temperature_celsius\", Help: \"The temperature of the frog pond.\", // Sorry, we can't measure how badly it smells. \tBuckets: prometheus.LinearBuckets(20, 5, 5), // 5 buckets, each 5 centigrade wide. }) // Simulate some observations. for i := 0; i  1000; i++ { temps.Observe(30 + math.Floor(120*math.Sin(float64(i)*0.1))/10) } // Just for demonstration, let's check the state of the histogram by // (ab)using its Write method (which is usually only used by Prometheus // internally). metric := \u0026dto.Metric{} temps.Write(metric) fmt.Println(proto.MarshalTextString(metric))   Output:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  histogram: bucket: bucket: bucket: bucket:    func NewHistogram 1  func NewHistogram(opts HistogramOpts) Histogram   NewHistogram基于提供的HistogramOpts创建新的直方图。如果HistogramOpts中的存储桶未严格按升序排序，则会感到恐慌。\n返回的实现还实现ExemplarObserver。执行相应的类型声明是安全的。分别跟踪每个存储桶的示例。\ntype HistogramOpts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  type HistogramOpts struct { // Namespace, Subsystem, and Name are components of the fully-qualified \t// name of the Histogram (created by joining these components with \t// \"_\"). Only Name is mandatory, the others merely help structuring the \t// name. Note that the fully-qualified name of the Histogram must be a \t// valid Prometheus metric name. \tNamespace string Subsystem string Name string // Help provides information about this Histogram. \t// \t// Metrics with the same fully-qualified name must have the same Help \t// string. \tHelp string // ConstLabels are used to attach fixed labels to this metric. Metrics \t// with the same fully-qualified name must have the same label names in \t// their ConstLabels. \t// \t// ConstLabels are only used rarely. In particular, do not use them to \t// attach the same labels to all your metrics. Those use cases are \t// better covered by target labels set by the scraping Prometheus \t// server, or by one specific metric (e.g. a build_info or a \t// machine_role metric). See also \t// https://prometheus.io/docs/instrumenting/writing_exporters/#target-labels-not-static-scraped-labels \tConstLabels Labels // Buckets defines the buckets into which observations are counted. Each \t// element in the slice is the upper inclusive bound of a bucket. The \t// values must be sorted in strictly increasing order. There is no need \t// to add a highest bucket with +Inf bound, it will be added \t// implicitly. The default value is DefBuckets. \tBuckets []float64 }   HistogramOpts捆绑了用于创建直方图度量的选项。必须将Name设置为非空字符串。尽管强烈建议您设置帮助字符串，但所有其他字段都是可选的，可以安全地保留其零值。\ntype HistogramVec 1 2 3  type HistogramVec struct { // contains filtered or unexported fields }   HistogramVec是一个收集器，它捆绑一组直方图，这些直方图共享相同的Desc，但是其变量标签具有不同的值。如果要计算按不同维度划分的同一事物（例如，HTTP请求等待时间，按状态代码和方法划分的分区），则使用此方法。使用NewHistogramVec创建实例。\nfunc NewHistogramVec 1  func NewHistogramVec(opts HistogramOpts, labelNames []string) *HistogramVec   NewHistogramVec基于提供的HistogramOpts创建一个新的HistogramVec，并按给定的标签名称进行分区。\nfunc (HistogramVec) Collect 1  func (m HistogramVec) Collect(ch chan Metric)   Collect 实现 Collector.\nfunc (*HistogramVec) CurryWith 1  func (v *HistogramVec) CurryWith(labels Labels) (ObserverVec, error)   CurryWith返回使用提供的标签进行咖喱处理的向量，即返回的向量具有针对其执行的所有标记操作预先设置的那些标签。相应地减小了咖喱矢量的基数。其余标签的顺序保持不变（只是将咖喱标签从序列中取出，这与（GetMetric）WithLabelValues方法有关）。可以咖喱咖喱的矢量，但只能使用之前尚未用于咖喱的标签。\nHistogramVec中包含的度量在已固化和未固化向量之间共享。只是以不同的方式访问它们。在集合方面，咖喱和非咖喱向量的行为相同。必须在给定的注册表中注册一个（通常是未更新的版本）。即使对当前向量调用了Reset方法，Reset方法也会删除所有指标。\nfunc (HistogramVec) Delete 1  func (m HistogramVec) Delete(labels Labels) bool   删除会删除指标，其中变量标签与作为标签传入的标签相同。如果删除了指标，则返回true。\n如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致，则不是错误。但是，此类不一致的标签永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。\n此方法与DeleteLabelValues（… string）的用途相同。有关两种方法的优缺点，请参见此处。\nfunc (HistogramVec) DeleteLabelValues 1  func (m HistogramVec) DeleteLabelValues(lvs ...string) bool   DeleteLabelValues删除Metric，其中变量标签与作为标签传入的变量相同（与Desc中的VariableLabel顺序相同）。如果删除了指标，则返回true。\n如果标签值的数量与Desc中的VariableLabels的数量不同，这不是错误。但是，这种不一致的标签计数永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。\n请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用Delete（Labels）来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。另请参见CounterVec示例。\nfunc (HistogramVec) Describe 1  func (m HistogramVec) Describe(ch chan *Desc)   Describe 实现 Collector.\nfunc (*HistogramVec) GetMetricWith 1  func (v *HistogramVec) GetMetricWith(labels Labels) (Observer, error)   GetMetricWith返回给定Labels映射的直方图（标签名称必须与Desc中的VariableLabel的名称匹配）。如果是第一次访问该标签图，则会创建一个新的直方图。不使用直方图创建直方图并保留直方图供以后使用的含义与GetMetricWithLabelValues相同。\n如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致（减去任何已处理的标签），则会返回错误。\n此方法与GetMetricWithLabelValues（… string）的用途相同。有关两种方法的优缺点，请参见此处。\nfunc (*HistogramVec) GetMetricWithLabelValues 1  func (v *HistogramVec) GetMetricWithLabelValues(lvs ...string) (Observer, error)   GetMetricWithLabelValues返回给定标签值切片的直方图（与Desc中的VariableLabels顺序相同）。如果第一次访问标签值的组合，则会创建一个新的直方图。\n可以在不使用返回的直方图的情况下调用此方法，仅创建新的直方图，而将其保留为初始值，即没有任何观察值的直方图。\n可以保留直方图供以后使用（如果性能至关重要，则应考虑使用），但请记住，可以使用Reset，DeleteLabelValues和Delete从HistogramVec中删除直方图。在这种情况下，即使以后创建具有相同标签值的直方图，直方图仍将存在，但将不再导出。另请参见CounterVec示例。\n如果标签值的数量与Desc中的VariableLabels的数量（减去任何已固化的标签）不同，则返回错误。\n请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用GetMetricWith（Labels）作为替代方案来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。另请参见GaugeVec示例。\nfunc (*HistogramVec) MustCurryWith 1  func (v *HistogramVec) MustCurryWith(labels Labels) ObserverVec   MustCurryWith可以作为CurryWith使用，但在CurryWith会返回错误的情况下会出现混乱。\nfunc (HistogramVec) Reset 1  func (m HistogramVec) Reset()   重置将删除此向量中的所有指标。\nfunc (*HistogramVec) With 1  func (v *HistogramVec) With(labels Labels) Observer   With与GetMetricWith一样工作，但在GetMetricWithLabels会返回错误的地方感到慌张。不返回错误允许使用以下快捷方式\n1  myVec.With(prometheus.Labels{\"code\": \"404\", \"method\": \"GET\"}).Observe(42.21)   func (*HistogramVec) WithLabelValues 1  func (v *HistogramVec) WithLabelValues(lvs ...string) Observer   WithLabelValues可以用作GetMetricWithLabelValues，但是在GetMetricWithLabelValues会返回错误的地方出现混乱。不返回错误允许使用以下快捷方式\n1  myVec.WithLabelValues(\"404\", \"GET\").Observe(42.21)   type Summary 1 2 3 4 5 6 7  type Summary interface { Metric Collector // Observe adds a single observation to the summary. \tObserve(float64) }   摘要可从事件或样本流中捕获单个观察值，并以类似于传统摘要统计的方式对其进行摘要：1.观察值总和，2。观察值，3。排名估计。\n一个典型的用例是观察请求延迟。默认情况下，摘要提供延迟的中位数，第90％和第99％作为等级估计。但是，默认行为将在即将发布的库v1.0.0中更改。默认情况下，将不会有任何排名估计。对于合理的过渡，建议明确设置所需的排名估计。\n请注意，排名估计不能使用Prometheus查询语言以有意义的方式进行汇总（即，您不能对它们进行平均或相加）。如果您需要可汇总的分位数（例如，您希望跨服务的所有实例进行的所有查询的第99个百分位数的延迟），请考虑直方图度量类型。有关更多详细信息，请参见Prometheus文档。\n若要创建摘要实例，请使用NewSummary。\nCode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  temps := prometheus.NewSummary(prometheus.SummaryOpts{ Name: \"pond_temperature_celsius\", Help: \"The temperature of the frog pond.\", Objectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001}, }) // Simulate some observations. for i := 0; i  1000; i++ { temps.Observe(30 + math.Floor(120*math.Sin(float64(i)*0.1))/10) } // Just for demonstration, let's check the state of the summary by // (ab)using its Write method (which is usually only used by Prometheus // internally). metric := \u0026dto.Metric{} temps.Write(metric) fmt.Println(proto.MarshalTextString(metric))   Output:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  summary: quantile: quantile:   func NewSummary 1  func NewSummary(opts SummaryOpts) Summary   NewSummary基于提供的SummaryOpts创建一个新的Summary。\ntype SummaryOpts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  type SummaryOpts struct { // Namespace, Subsystem, and Name are components of the fully-qualified \t// name of the Summary (created by joining these components with \t// \"_\"). Only Name is mandatory, the others merely help structuring the \t// name. Note that the fully-qualified name of the Summary must be a \t// valid Prometheus metric name. \tNamespace string Subsystem string Name string // Help provides information about this Summary. \t// \t// Metrics with the same fully-qualified name must have the same Help \t// string. \tHelp string // ConstLabels are used to attach fixed labels to this metric. Metrics \t// with the same fully-qualified name must have the same label names in \t// their ConstLabels. \t// \t// Due to the way a Summary is represented in the Prometheus text format \t// and how it is handled by the Prometheus server internally, “quantile” \t// is an illegal label name. Construction of a Summary or SummaryVec \t// will panic if this label name is used in ConstLabels. \t// \t// ConstLabels are only used rarely. In particular, do not use them to \t// attach the same labels to all your metrics. Those use cases are \t// better covered by target labels set by the scraping Prometheus \t// server, or by one specific metric (e.g. a build_info or a \t// machine_role metric). See also \t// https://prometheus.io/docs/instrumenting/writing_exporters/#target-labels,-not-static-scraped-labels \tConstLabels Labels // Objectives defines the quantile rank estimates with their respective \t// absolute error. If Objectives[q] = e, then the value reported for q \t// will be the φ-quantile value for some φ between q-e and q+e. The \t// default value is an empty map, resulting in a summary without \t// quantiles. \tObjectives map[float64]float64 // MaxAge defines the duration for which an observation stays relevant \t// for the summary. Must be positive. The default value is DefMaxAge. \tMaxAge time.Duration // AgeBuckets is the number of buckets used to exclude observations that \t// are older than MaxAge from the summary. A higher number has a \t// resource penalty, so only increase it if the higher resolution is \t// really required. For very high observation rates, you might want to \t// reduce the number of age buckets. With only one age bucket, you will \t// effectively see a complete reset of the summary each time MaxAge has \t// passed. The default value is DefAgeBuckets. \tAgeBuckets uint32 // BufCap defines the default sample stream buffer size. The default \t// value of DefBufCap should suffice for most uses. If there is a need \t// to increase the value, a multiple of 500 is recommended (because that \t// is the internal buffer size of the underlying package \t// \"github.com/bmizerany/perks/quantile\"). \tBufCap uint32 }   SummaryOpts捆绑了用于创建“摘要”指标的选项。必须将Name设置为非空字符串。尽管所有其他字段都是可选的，并且可以安全地保留为零值，但是建议设置帮助字符串并将“ Objectives”字段明确设置为所需值，因为默认值将在库的即将发布的v1.0.0中更改。\ntype SummaryVec 1 2 3  type SummaryVec struct { // contains filtered or unexported fields }   SummaryVec是一个收集器，捆绑了一组共享相同的Desc，但其变量标签具有不同值的摘要。如果要计算按不同维度划分的同一事物（例如，HTTP请求等待时间，按状态代码和方法划分的分区），则使用此方法。使用NewSummaryVec创建实例。\n例子\nCode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  temps := prometheus.NewSummaryVec( prometheus.SummaryOpts{ Name: \"pond_temperature_celsius\", Help: \"The temperature of the frog pond.\", Objectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001}, }, []string{\"species\"}, ) // Simulate some observations. for i := 0; i  1000; i++ { temps.WithLabelValues(\"litoria-caerulea\").Observe(30 + math.Floor(120*math.Sin(float64(i)*0.1))/10) temps.WithLabelValues(\"lithobates-catesbeianus\").Observe(32 + math.Floor(100*math.Cos(float64(i)*0.11))/10) } // Create a Summary without any observations. temps.WithLabelValues(\"leiopelma-hochstetteri\") // Just for demonstration, let's check the state of the summary vector // by registering it with a custom registry and then let it collect the // metrics. reg := prometheus.NewRegistry() reg.MustRegister(temps) metricFamilies, err := reg.Gather() if err != nil || len(metricFamilies) != 1 { panic(\"unexpected behavior of custom test registry\") } fmt.Println(proto.MarshalTextString(metricFamilies[0]))   Output:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  name: \"pond_temperature_celsius\" help: \"The temperature of the frog pond.\" type: SUMMARY metric: summary: quantile: quantile:   metric: summary: quantile: quantile:   metric: summary: quantile: quantile:     func NewSummaryVec 1  func NewSummaryVec(opts SummaryOpts, labelNames []string) *SummaryVec   NewSummaryVec基于提供的SummaryOpts创建一个新的SummaryVec，并按给定的标签名称进行分区。\n由于摘要以Prometheus文本格式表示的方式以及Prometheus服务器在内部如何处理摘要，因此“quantile”是非法的标签名称。如果使用此标签名称，NewSummaryVec将惊慌。\nfunc (SummaryVec) Collect 1  func (m SummaryVec) Collect(ch chan Metric)   收集器收集器。\nfunc (*SummaryVec) CurryWith 1  func (v *SummaryVec) CurryWith(labels Labels) (ObserverVec, error)   CurryWith返回使用提供的标签进行咖喱处理的向量，即返回的向量具有针对其执行的所有标记操作预先设置的那些标签。相应地减小了咖喱矢量的基数。其余标签的顺序保持不变（只是将咖喱标签从序列中取出，这与（GetMetric）WithLabelValues方法有关）。可以咖喱咖喱的矢量，但只能使用之前尚未用于咖喱的标签。\nSummaryVec中包含的度量在已管理和未已管理向量之间共享。只是以不同的方式访问它们。在集合方面，咖喱和非咖喱向量的行为相同。必须在给定的注册表中注册一个（通常是未更新的版本）。即使对当前向量调用了Reset方法，Reset方法也会删除所有指标。\nfunc (SummaryVec) Delete 1  func (m SummaryVec) Delete(labels Labels) bool   删除会删除指标，其中变量标签与作为标签传入的标签相同。如果删除了指标，则返回true。\n如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致，则不是错误。但是，此类不一致的标签永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。\n此方法与DeleteLabelValues（… string）的用途相同。有关两种方法的优缺点，请参见此处。\nfunc (SummaryVec) DeleteLabelValues 1  func (m SummaryVec) DeleteLabelValues(lvs ...string) bool   DeleteLabelValues删除Metric，其中变量标签与作为标签传入的变量相同（与Desc中的VariableLabel顺序相同）。如果删除了指标，则返回true。\n如果标签值的数量与Desc中的VariableLabels的数量不同，这不是错误。但是，这种不一致的标签计数永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。\n请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用Delete（Labels）来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。另请参见CounterVec示例。\nfunc (SummaryVec) Describe 1  func (m SummaryVec) Describe(ch chan *Desc)   描述工具收集器。\nfunc (*SummaryVec) GetMetricWith 1  func (v *SummaryVec) GetMetricWith(labels Labels) (Observer, error)   GetMetricWith返回给定标签映射的摘要（标签名称必须与Desc中的VariableLabel的名称匹配）。如果是第一次访问该标签图，则会创建一个新的摘要。不使用摘要创建摘要并保留摘要供以后使用的含义与GetMetricWithLabelValues相同。\n如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致（减去任何已处理的标签），则会返回错误。\n此方法与GetMetricWithLabelValues（… string）的用途相同。有关两种方法的优缺点，请参见此处。\nfunc (*SummaryVec) GetMetricWithLabelValues 1  func (v *SummaryVec) GetMetricWithLabelValues(lvs ...string) (Observer, error)   GetMetricWithLabelValues返回给定标签值切片的摘要（与Desc中的VariableLabels顺序相同）。如果是第一次访问标签值的组合，则会创建一个新的摘要。\n可以在不使用返回的Summary的情况下调用此方法，仅创建新的Summary，而将其保留为初始值，即没有任何观察值的Summary。\n保留摘要以备后用是可能的（如果性能至关重要，则应考虑使用），但请记住，可以使用Reset，DeleteLabelValues和Delete从SummaryVec中删除摘要。在这种情况下，即使稍后创建具有相同标签值的摘要，摘要仍将存在，但不再导出。另请参见CounterVec示例。\n如果标签值的数量与Desc中的VariableLabels的数量（减去任何已固化的标签）不同，则返回错误。\n请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用GetMetricWith（Labels）作为替代方案来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。另请参见GaugeVec示例。\nfunc (*SummaryVec) MustCurryWith 1  func (v *SummaryVec) MustCurryWith(labels Labels) ObserverVec   MustCurryWith可以作为CurryWith使用，但在CurryWith会返回错误的情况下会出现混乱。\nfunc (SummaryVec) Reset 1  func (m SummaryVec) Reset()   重置将删除此向量中的所有指标。\nfunc (*SummaryVec) With 1  func (v *SummaryVec) With(labels Labels) Observer   With与GetMetricWith一样工作，但在GetMetricWithLabels会返回错误的地方感到慌张。不返回错误允许使用以下快捷方式\n1  myVec.With(prometheus.Labels{\"code\": \"404\", \"method\": \"GET\"}).Observe(42.21)   func (*SummaryVec) WithLabelValues 1  func (v *SummaryVec) WithLabelValues(lvs ...string) Observer   WithLabelValues可以用作GetMetricWithLabelValues，但是在GetMetricWithLabelValues会返回错误的地方出现混乱。不返回错误允许使用以下快捷方式\n1  myVec.WithLabelValues(\"404\", \"GET\").Observe(42.21)   type Desc 1 2 3  type Desc struct { // contains filtered or unexported fields }   Desc是每个Prometheus指标使用的描述符。它本质上是Metric的不可变元数据。此程序包中包含的常规Metric实现在后台管理其Desc。如果用户使用诸​​如ExpvarCollector或自定义收集器和Metric之类的高级功能，则仅需处理Desc。\n如果在相同的注册表中注册的描述符共享相同的完全限定名称，则它们必须满足某些一致性和唯一性条件：constLabels和variableLabels的描述符必须具有相同的帮助字符串和相同的标签名称（即标签尺寸），但是constLabels的值必须不同。\n共享相同常量名称和constLabel相同标签值的描述符被视为相等。\n使用NewDesc创建新的Desc实例。\nfunc NewDesc 1  func NewDesc(fqName, help string, variableLabels []string, constLabels Labels) *Desc   NewDesc分配并初始化新的Desc。错误记录在Desc中，并将在注册时间报告。如果不应该设置这样的标签，variableLabels和constLabels可以为nil。fqName不能为空。\nvariableLabels仅包含标签名称。它们的标签值是可变的，因此不是Desc的一部分。（它们在Metric内管理。）\n对于constLabels，标签值是恒定的。因此，它们在“描述”中已完全指定。有关用法模式，请参见收集器示例。\nfunc NewInvalidDesc 1  func NewInvalidDesc(err error) *Desc   NewInvalidDesc返回无效的描述符，即具有提供的错误集的描述符。如果注册了返回此类描述符的收集器，则注册将失败，并显示所提供的错误。收集器可以使用NewInvalidDesc来表示无法描述自己。\nfunc (*Desc) String 1  func (d *Desc) String() string   type ExemplarAdder 1 2 3  type ExemplarAdder interface { AddWithExemplar(value float64, exemplar Labels) }   ExemplarAdder由Counters实现，Counter提供了与示例一起向Counter添加值的选项。它的AddWithExemplar方法的工作方式与Counter接口的Add方法类似，但是也用新的（由提供的值，当前时间作为时间戳记和提供的标签）创建的新示例替换了当前保存的示例（如果有）。空标签将导致有效的（无标签）示例。但是，如果Labels为nil，则当前示例保留不变。如果值type ExemplarObserver 1 2 3  type ExemplarObserver interface { ObserveWithExemplar(value float64, exemplar Labels) }   ExemplarObserver由观察者实现，该观察者提供了与示例一起观察值的选项。它的ObserveWithExemplar方法的工作方式类似于Observer的Observe方法，但也用新的（由提供的值，当前时间作为时间戳记和提供的Label）创建的新示例替换了当前保存的示例（如果有）。空标签将导致有效的（无标签）示例。但是，如果Labels为nil，则当前示例保留不变。如果提供的任何标签无效或提供的标签总共包含64个以上符文，则ObserveWithExemplar会发生混乱。\ntype Gatherer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  type Gatherer interface { // Gather calls the Collect method of the registered Collectors and then \t// gathers the collected metrics into a lexicographically sorted slice \t// of uniquely named MetricFamily protobufs. Gather ensures that the \t// returned slice is valid and self-consistent so that it can be used \t// for valid exposition. As an exception to the strict consistency \t// requirements described for metric.Desc, Gather will tolerate \t// different sets of label names for metrics of the same metric family. \t// \t// Even if an error occurs, Gather attempts to gather as many metrics as \t// possible. Hence, if a non-nil error is returned, the returned \t// MetricFamily slice could be nil (in case of a fatal error that \t// prevented any meaningful metric collection) or contain a number of \t// MetricFamily protobufs, some of which might be incomplete, and some \t// might be missing altogether. The returned error (which might be a \t// MultiError) explains the details. Note that this is mostly useful for \t// debugging purposes. If the gathered protobufs are to be used for \t// exposition in actual monitoring, it is almost always better to not \t// expose an incomplete result and instead disregard the returned \t// MetricFamily protobufs in case the returned error is non-nil. \tGather() ([]*dto.MetricFamily, error) }   Gatherer是注册表的一部分，负责将收集的指标收集到许多MetricFamilies中。Gatherer interface具有与Registerer interface 相同的一般含义。\ntype GathererFunc 1  type GathererFunc func() ([]*dto.MetricFamily, error)   GathererFunc将功能转换为Gatherer。\nfunc (GathererFunc) Gather 1  func (gf GathererFunc) Gather() ([]*dto.MetricFamily, error)   Gather实现Gatherer。\ntype Gatherers 1  type Gatherers []Gatherer   Gatherers是实现Gatherer接口本身的Gatherer实例的一部分。它的Gather方法按顺序在切片中的所有Gatherer上调用Gather并返回合并的结果。从Gather调用返回的错误全部以扁平化的MultiError返回。跳过重复和不一致的Metric（以分片顺序获胜的方式首次出现），并在返回的错误中报告。\n收集器可用于合并来自多个注册表的收集结果。它还提供了一种通过使用Gather方法创建自定义Gatherer的方法，将现有的MetricFamily原型直接注入到集合中，该方法仅返回现有的MetricFamily原型。请注意，不涉及注册（与收集器注册相反），因此显然无法进行注册时检查。收集的MetricFamilies之间的任何不一致都会通过Gather方法报告为错误，并且会删除不一致的Metric。MetricFamilies的无效部分（例如，语法上无效的Metric或标签名称）将不会被检测到。\nCode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82  reg := prometheus.NewRegistry() temp := prometheus.NewGaugeVec( prometheus.GaugeOpts{ Name: \"temperature_kelvin\", Help: \"Temperature in Kelvin.\", }, []string{\"location\"}, ) reg.MustRegister(temp) temp.WithLabelValues(\"outside\").Set(273.14) temp.WithLabelValues(\"inside\").Set(298.44) var parser expfmt.TextParser text := ` ## TYPE humidity_percent gauge ## HELP humidity_percent Humidity in %. humidity_percent{location=\"outside\"} 45.4 humidity_percent{location=\"inside\"} 33.2 ## TYPE temperature_kelvin gauge ## HELP temperature_kelvin Temperature in Kelvin. temperature_kelvin{location=\"somewhere else\"} 4.5 ` parseText := func() ([]*dto.MetricFamily, error) { parsed, err := parser.TextToMetricFamilies(strings.NewReader(text)) if err != nil { return nil, err } var result []*dto.MetricFamily for _, mf := range parsed { result = append(result, mf) } return result, nil } gatherers := prometheus.Gatherers{ reg, prometheus.GathererFunc(parseText), } gathering, err := gatherers.Gather() if err != nil { fmt.Println(err) } out := \u0026bytes.Buffer{} for _, mf := range gathering { if _, err := expfmt.MetricFamilyToText(out, mf); err != nil { panic(err) } } fmt.Print(out.String()) fmt.Println(\"----------\") // Note how the temperature_kelvin metric family has been merged from // different sources. Now try text = ` ## TYPE humidity_percent gauge ## HELP humidity_percent Humidity in %. humidity_percent{location=\"outside\"} 45.4 humidity_percent{location=\"inside\"} 33.2 ## TYPE temperature_kelvin gauge ## HELP temperature_kelvin Temperature in Kelvin. ## Duplicate metric: temperature_kelvin{location=\"outside\"} 265.3 ## Missing location label (note that this is undesirable but valid): temperature_kelvin 4.5 ` gathering, err = gatherers.Gather() if err != nil { fmt.Println(err) } // Note that still as many metrics as possible are returned: out.Reset() for _, mf := range gathering { if _, err := expfmt.MetricFamilyToText(out, mf); err != nil { panic(err) } } fmt.Print(out.String())   Output:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  ## HELP humidity_percent Humidity in %. ## TYPE humidity_percent gauge humidity_percent{location=\"inside\"} 33.2 humidity_percent{location=\"outside\"} 45.4 ## HELP temperature_kelvin Temperature in Kelvin. ## TYPE temperature_kelvin gauge temperature_kelvin{location=\"inside\"} 298.44 temperature_kelvin{location=\"outside\"} 273.14 temperature_kelvin{location=\"somewhere else\"} 4.5 ---------- collected metric \"temperature_kelvin\" { label:gauge:} was collected before with the same name and label values ## HELP humidity_percent Humidity in %. ## TYPE humidity_percent gauge humidity_percent{location=\"inside\"} 33.2 humidity_percent{location=\"outside\"} 45.4 ## HELP temperature_kelvin Temperature in Kelvin. ## TYPE temperature_kelvin gauge temperature_kelvin 4.5 temperature_kelvin{location=\"inside\"} 298.44 temperature_kelvin{location=\"outside\"} 273.14   func (Gatherers) Gather 1  func (gs Gatherers) Gather() ([]*dto.MetricFamily, error)   type Labels 1  type Labels map[string]string   标签代表标签名称-值映射的集合。此类型通常与度量矢量收集器的With（Labels）和GetMetricWith（Labels）方法一起使用，例如：\n1  myVec.With(Labels{\"code\": \"404\", \"method\": \"GET\"}).Add(42)   另一个用例是在Opts中或创建Desc中指定常量标签对。\ntype Metric 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  type Metric interface { // Desc returns the descriptor for the Metric. This method idempotently \t// returns the same descriptor throughout the lifetime of the \t// Metric. The returned descriptor is immutable by contract. A Metric \t// unable to describe itself must return an invalid descriptor (created \t// with NewInvalidDesc). \tDesc() *Desc // Write encodes the Metric into a \"Metric\" Protocol Buffer data \t// transmission object. \t// \t// Metric implementations must observe concurrency safety as reads of \t// this metric may occur at any time, and any blocking occurs at the \t// expense of total performance of rendering all registered \t// metrics. Ideally, Metric implementations should support concurrent \t// readers. \t// \t// While populating dto.Metric, it is the responsibility of the \t// implementation to ensure validity of the Metric protobuf (like valid \t// UTF-8 strings or syntactically valid metric and label names). It is \t// recommended to sort labels lexicographically. Callers of Write should \t// still make sure of sorting if they depend on it. \tWrite(*dto.Metric) error }   Metric将单个样本值建模，并将其元数据导出到Prometheus。此程序包中Metric的实现是仪表，计数器，直方图，摘要和无类型的。\nfunc MustNewConstHistogram 1 2 3 4 5 6 7  func MustNewConstHistogram( desc *Desc, count uint64, sum float64, buckets map[float64]uint64, labelValues ...string, ) Metric   MustNewConstHistogram是NewConstHistogram的一个版本，它会惊慌于NewConstHistogram返回错误的地方。\nfunc MustNewConstMetric 1  func MustNewConstMetric(desc *Desc, valueType ValueType, value float64, labelValues ...string) Metric   MustNewConstMetric是NewConstMetric的一个版本，它会惊慌于NewConstMetric返回错误的地方。\nfunc MustNewConstSummary 1 2 3 4 5 6 7  func MustNewConstSummary( desc *Desc, count uint64, sum float64, quantiles map[float64]float64, labelValues ...string, ) Metric   MustNewConstSummary是NewConstSummary的一个版本，它会惊慌，NewConstMetric将返回错误。\nfunc NewConstHistogram 1 2 3 4 5 6 7  func NewConstHistogram( desc *Desc, count uint64, sum float64, buckets map[float64]uint64, labelValues ...string, ) (Metric, error)   NewConstHistogram返回一个表示Prometheus直方图的度量，该度量具有用于计数，总和和存储桶计数的固定值。由于无法更改这些参数，因此返回的值不会实现直方图接口（而只能实现公制接口）。使用此软件包的用户在常规操作中将不会使用太多。但是，在实现自定义收集器时，它是一种即用即弃的Metric，可以即时生成以用Collect方法将其发送给Prometheus。\nbuckets是上限到累积计数的映射，不包括+ Inf buckets。\n如果labelValues的长度与Desc中的变量标签不一致，或者Desc无效，则NewConstHistogram返回错误。\n例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  desc := prometheus.NewDesc( \"http_request_duration_seconds\", \"A histogram of the HTTP request durations.\", []string{\"code\", \"method\"}, prometheus.Labels{\"owner\": \"example\"}, ) // Create a constant histogram from values we got from a 3rd party telemetry system. h := prometheus.MustNewConstHistogram( desc, 4711, 403.34, map[float64]uint64{25: 121, 50: 2403, 100: 3221, 200: 4233}, \"200\", \"get\", ) // Just for demonstration, let's check the state of the histogram by // (ab)using its Write method (which is usually only used by Prometheus // internally). metric := \u0026dto.Metric{} h.Write(metric) fmt.Println(proto.MarshalTextString(metric))   Output:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  label: label: label: histogram: bucket: bucket: bucket:    func NewConstMetric 1  func NewConstMetric(desc *Desc, valueType ValueType, value float64, labelValues ...string) (Metric, error)   NewConstMetric返回具有一个固定值且无法更改的度量。使用此软件包的用户在常规操作中将不会使用太多。但是，在实现自定义收集器时，它是一种即时生成的一次性指标，可以通过Collect方法将其发送给Prometheus。如果labelValues的长度与Desc中的变量标签不一致，或者Desc无效，则NewConstMetric返回错误。\nfunc NewConstSummary 1 2 3 4 5 6 7  func NewConstSummary( desc *Desc, count uint64, sum float64, quantiles map[float64]float64, labelValues ...string, ) (Metric, error)   NewConstSummary返回一个Metric，该Metric表示Prometheus摘要，其计数，总和和分位数具有固定值。由于无法更改这些参数，因此返回的值不会实现Summary接口（而只能实现Metric接口）。使用此软件包的用户在常规操作中将不会使用太多。但是，在实现自定义收集器时，它是一种即时生成的一次性指标，可以通过Collect方法将其发送给Prometheus。\n分位数图将等级排名为分位数。例如，中值等待时间为0.23s，第99个百分位等待时间为0.56s表示为：\n1  map[float64]float64{0.5: 0.23, 0.99: 0.56}   如果labelValues的长度与Desc中的变量标签不一致，或者Desc无效，则NewConstSummary返回错误。\n例子\nCode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  desc := prometheus.NewDesc( \"http_request_duration_seconds\", \"A summary of the HTTP request durations.\", []string{\"code\", \"method\"}, prometheus.Labels{\"owner\": \"example\"}, ) // Create a constant summary from values we got from a 3rd party telemetry system. s := prometheus.MustNewConstSummary( desc, 4711, 403.34, map[float64]float64{0.5: 42.3, 0.9: 323.3}, \"200\", \"get\", ) // Just for demonstration, let's check the state of the summary by // (ab)using its Write method (which is usually only used by Prometheus // internally). metric := \u0026dto.Metric{} s.Write(metric) fmt.Println(proto.MarshalTextString(metric))   Output:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  label: label: label: summary: quantile:    func NewInvalidMetric 1  func NewInvalidMetric(desc *Desc, err error) Metric   NewInvalidMetric返回一个指标，该指标的Write方法始终返回提供的错误。如果收集器发现自己无法收集Metric并希望向注册表报告错误，这将很有用。\nfunc NewMetricWithTimestamp 1  func NewMetricWithTimestamp(t time.Time, m Metric) Metric   NewMetricWithTimestamp返回一个新的Metric，该Metric以将显式时间戳记设置为所提供的Time的方式包装所提供的Metric。这仅在极少数情况下有用，因为PrometheusMetric的时间戳通常应由Prometheus服务器在抓取期间设置。例外情况包括具有来自其他Metric来源的给定时间戳的镜像Metric。\nNewMetricWithTimestamp与MustNewConstMetric，MustNewConstHistogram和MustNewConstSummary一起使用效果最佳，请参见示例。\n当前，Prometheus使用的展示格式仅限于毫秒分辨率。因此，提供的时间将舍入到下一个完整的毫秒值。\n例子\nCode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  desc := prometheus.NewDesc( \"temperature_kelvin\", \"Current temperature in Kelvin.\", nil, nil, ) // Create a constant gauge from values we got from an external // temperature reporting system. Those values are reported with a slight // delay, so we want to add the timestamp of the actual measurement. temperatureReportedByExternalSystem := 298.15 timeReportedByExternalSystem := time.Date(2009, time.November, 10, 23, 0, 0, 12345678, time.UTC) s := prometheus.NewMetricWithTimestamp( timeReportedByExternalSystem, prometheus.MustNewConstMetric( desc, prometheus.GaugeValue, temperatureReportedByExternalSystem, ), ) // Just for demonstration, let's check the state of the gauge by // (ab)using its Write method (which is usually only used by Prometheus // internally). metric := \u0026dto.Metric{} s.Write(metric) fmt.Println(proto.MarshalTextString(metric))   Output:\n1 2 3 4  gauge: timestamp_ms: 1257894000012   type MultiError 1  type MultiError []error   MultiError是实现错误接口的错误片段。收集器使用它来报告MetricFamily收集期间的多个错误。\nfunc (*MultiError) Append 1  func (errs *MultiError) Append(err error)   如果错误不是nil，则追加会附加提供的错误。\nfunc (MultiError) Error 1  func (errs MultiError) Error() string   func (MultiError) MaybeUnwrap 1  func (errs MultiError) MaybeUnwrap() error   如果len（errs）为0，则MaybeUnwrap返回nil。如果len（errs）为1，则返回第一个且仅包含错误的错误。在所有其他情况下，它直接返回MultiError。这对于以仅在需要时使用MultiError的方式返回MultiError很有帮助。\ntype Observer 1 2 3  type Observer interface { Observe(float64) }   Observer是包装Observe方法的接口，直方图和摘要用于添加观察值。\ntype ObserverFunc 1  type ObserverFunc func(float64)   ObserverFunc类型是一个适配器，允许将普通功能用作Observers。如果f是具有适当签名的函数，则ObserverFunc（f）是调用f的Observer。\n此适配器通常与Timer类型结合使用，并且有两种常规使用情况：\n最常见的一种是将仪表用作计时器的观察器。请参见“仪表”计时器示例。\n更高级的用例是创建一个功能，该功能可动态决定使用哪个观察者来观察持续时间。请参见“复杂”计时器示例。\nfunc (ObserverFunc) Observe 1  func (f ObserverFunc) Observe(value float64)   Observe 调用 f(value)。它实现了observer。\ntype ObserverVec 1 2 3 4 5 6 7 8 9 10  type ObserverVec interface { GetMetricWith(Labels) (Observer, error) GetMetricWithLabelValues(lvs ...string) (Observer, error) With(Labels) Observer WithLabelValues(...string) Observer CurryWith(Labels) (ObserverVec, error) MustCurryWith(Labels) ObserverVec Collector }   ObserverVec是由“HistogramVec”和“SummaryVec”实现的接口。\ntype Opts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  type Opts struct { // Namespace, Subsystem, and Name are components of the fully-qualified \t// name of the Metric (created by joining these components with \t// \"_\"). Only Name is mandatory, the others merely help structuring the \t// name. Note that the fully-qualified name of the metric must be a \t// valid Prometheus metric name. \tNamespace string Subsystem string Name string // Help provides information about this metric. \t// \t// Metrics with the same fully-qualified name must have the same Help \t// string. \tHelp string // ConstLabels are used to attach fixed labels to this metric. Metrics \t// with the same fully-qualified name must have the same label names in \t// their ConstLabels. \t// \t// ConstLabels are only used rarely. In particular, do not use them to \t// attach the same labels to all your metrics. Those use cases are \t// better covered by target labels set by the scraping Prometheus \t// server, or by one specific metric (e.g. a build_info or a \t// machine_role metric). See also \t// https://prometheus.io/docs/instrumenting/writing_exporters/#target-labels,-not-static-scraped-labels \tConstLabels Labels }   Opts捆绑了用于创建大多数指标类型的选项。每个度量实现XXX都有其自己的XXXOpts类型，但在大多数情况下，它只是该类型的别名（可能在需求出现时更改）。\n必须将Name设置为非空字符串。尽管强烈建议您设置帮助字符串，但所有其他字段都是可选的，可以安全地保留其零值。\ntype ProcessCollectorOpts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  type ProcessCollectorOpts struct { // PidFn returns the PID of the process the collector collects metrics \t// for. It is called upon each collection. By default, the PID of the \t// current process is used, as determined on construction time by \t// calling os.Getpid(). \tPidFn func() (int, error) // If non-empty, each of the collected metrics is prefixed by the \t// provided string and an underscore (\"_\"). \tNamespace string // If true, any error encountered during collection is reported as an \t// invalid metric (see NewInvalidMetric). Otherwise, errors are ignored \t// and the collected metrics will be incomplete. (Possibly, no metrics \t// will be collected at all.) While that's usually not desired, it is \t// appropriate for the common \"mix-in\" of process metrics, where process \t// metrics are nice to have, but failing to collect them should not \t// disrupt the collection of the remaining metrics. \tReportErrors bool }   ProcessCollectorOpts定义使用NewProcessCollector创建的过程指标收集器的行为。\ntype Registerer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  type Registerer interface { // Register registers a new Collector to be included in metrics \t// collection. It returns an error if the descriptors provided by the \t// Collector are invalid or if they — in combination with descriptors of \t// already registered Collectors — do not fulfill the consistency and \t// uniqueness criteria described in the documentation of metric.Desc. \t// \t// If the provided Collector is equal to a Collector already registered \t// (which includes the case of re-registering the same Collector), the \t// returned error is an instance of AlreadyRegisteredError, which \t// contains the previously registered Collector. \t// \t// A Collector whose Describe method does not yield any Desc is treated \t// as unchecked. Registration will always succeed. No check for \t// re-registering (see previous paragraph) is performed. Thus, the \t// caller is responsible for not double-registering the same unchecked \t// Collector, and for providing a Collector that will not cause \t// inconsistent metrics on collection. (This would lead to scrape \t// errors.) \tRegister(Collector) error // MustRegister works like Register but registers any number of \t// Collectors and panics upon the first registration that causes an \t// error. \tMustRegister(...Collector) // Unregister unregisters the Collector that equals the Collector passed \t// in as an argument. (Two Collectors are considered equal if their \t// Describe method yields the same set of descriptors.) The function \t// returns whether a Collector was unregistered. Note that an unchecked \t// Collector cannot be unregistered (as its Describe method does not \t// yield any descriptor). \t// \t// Note that even after unregistering, it will not be possible to \t// register a new Collector that is inconsistent with the unregistered \t// Collector, e.g. a Collector collecting metrics with the same name but \t// a different help string. The rationale here is that the same registry \t// instance must only collect consistent metrics throughout its \t// lifetime. \tUnregister(Collector) bool }   注册器是注册表中负责注册和注销的部分的接口。定制注册表的用户应将Registerer用作注册的类型（而不是直接使用Registry类型）。这样，他们可以自由使用自定义的Registerer实现（例如，出于测试目的）。\nfunc WrapRegistererWith 1  func WrapRegistererWith(labels Labels, reg Registerer) Registerer   WrapRegistererWith返回包装提供的注册器的注册器。在返回的注册器中注册的收集器将以修改后的方式在包装的注册器中注册。修改后的收集器会将提供的标签添加到它收集的所有Metric中（作为ConstLabels）。未经修改的收集器收集的Metric不得重复任何这些标签。包装一个nil值是有效的，导致没有操作的register。\nWrapRegistererWith提供了一种向收集器的子集添加固定标签的方法。不应将其用于向所有公开的指标添加固定标签。\n仍将检测到通过原始注册器注册的收集器与通过包装注册器注册的收集器之间的冲突。由任一注册器的Register方法返回的任何AlreadyRegisteredError都将包含ExistingCollector，其形式已提供给相应的注册表。\n收集器示例演示了WrapRegistererWith的用法。\nfunc WrapRegistererWithPrefix 1  func WrapRegistererWithPrefix(prefix string, reg Registerer) Registerer   WrapRegistererWithPrefix返回包装提供的注册器的注册器。在返回的注册器中注册的收集器将以修改后的方式在包装的注册器中注册。修改后的收集器会将提供的前缀添加到它收集的所有Metric的名称中。包装一个nil值是有效的，导致没有操作寄存器。\nWrapRegistererWithPrefix对于在一个子系统前面放置所有度量的前缀很有用。为此，请使用WrapRegistererWithPrefix返回的包装注册器注册子系统的度量。对于所有公开的指标，使用相同的前缀很少有用。特别是，不要在跨应用程序标准化的Metric名称前添加前缀，因为这会破坏水平监视，例如Go收集器（请参阅NewGoCollector）和流程收集器（请参阅NewProcessCollector）提供的Metric。（实际上，这些指标已经分别以“ go_”或“ process_”为前缀。）\n仍将检测到通过原始注册器注册的收集器与通过包装注册器注册的收集器之间的冲突。由任一注册器的Register方法返回的任何AlreadyRegisteredError都将包含ExistingCollector，其形式已提供给相应的注册表。\ntype Registry 1 2 3  type Registry struct { // contains filtered or unexported fields }   注册表注册Prometheus收集器，收集其度量，然后将其收集到MetricFamilies中进行说明。它同时实现了Registerer和Gatherer。零值不可用。使用NewRegistry或NewPedanticRegistry创建实例。\nfunc NewPedanticRegistry 1  func NewPedanticRegistry() *Registry   NewPedanticRegistry返回一个注册表，该注册表在收集期间检查每个收集的指标是否与其报告的Desc一致，以及Desc是否实际上已在注册表中注册。未检查的收集器（其Describe方法不产生任何描述符的收集器）从检查中排除。\n通常，只要所有收集的Metric的并集一致且有效，即使某些Metric与其自己的Desc或由其注册收集者提供的Desc不一致，注册管理机构也会很高兴。行为良好的收集器和指标只会提供一致的描述。该注册表对于测试收集器和Metric的实现很有用。\nfunc NewRegistry 1  func NewRegistry() *Registry   NewRegistry会创建一个新的普通注册表，而无需预先注册任何收集器。\nfunc (*Registry) Gather 1  func (r *Registry) Gather() ([]*dto.MetricFamily, error)   Gather实现Gatherer。\nfunc (*Registry) MustRegister 1  func (r *Registry) MustRegister(cs ...Collector)   MustRegister实现Registerer。\nfunc (*Registry) Register 1  func (r *Registry) Register(c Collector) error   Register实现Registerer。\nfunc (*Registry) Unregister 1  func (r *Registry) Unregister(c Collector) bool   Unregister 实现 Registerer.\ntype Timer 1 2 3  type Timer struct { // contains filtered or unexported fields }   计时器是计时功能的辅助类型。使用NewTimer创建新实例。\n例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  Code: package prometheus_test import ( \"math/rand\" \"time\" \"github.com/prometheus/client_golang/prometheus\" ) var ( requestDuration = prometheus.NewHistogram(prometheus.HistogramOpts{ Name: \"example_request_duration_seconds\", Help: \"Histogram for the runtime of a simple example function.\", Buckets: prometheus.LinearBuckets(0.01, 0.01, 10), }) ) func ExampleTimer() { // timer times this example function. It uses a Histogram, but a Summary \t// would also work, as both implement Observer. Check out \t// https://prometheus.io/docs/practices/histograms/ for differences. \ttimer := prometheus.NewTimer(requestDuration) defer timer.ObserveDuration() // Do something here that takes time. \ttime.Sleep(time.Duration(rand.NormFloat64()*10000+50000) * time.Microsecond) }   示例（复杂）\nCode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  package prometheus_test import ( \"net/http\" \"github.com/prometheus/client_golang/prometheus\" ) var ( // apiRequestDuration tracks the duration separate for each HTTP status \t// class (1xx, 2xx, ...). This creates a fair amount of time series on \t// the Prometheus server. Usually, you would track the duration of \t// serving HTTP request without partitioning by outcome. Do something \t// like this only if needed. Also note how only status classes are \t// tracked, not every single status code. The latter would create an \t// even larger amount of time series. Request counters partitioned by \t// status code are usually OK as each counter only creates one time \t// series. Histograms are way more expensive, so partition with care and \t// only where you really need separate latency tracking. Partitioning by \t// status class is only an example. In concrete cases, other partitions \t// might make more sense. \tapiRequestDuration = prometheus.NewHistogramVec( prometheus.HistogramOpts{ Name: \"api_request_duration_seconds\", Help: \"Histogram for the request duration of the public API, partitioned by status class.\", Buckets: prometheus.ExponentialBuckets(0.1, 1.5, 5), }, []string{\"status_class\"}, ) ) func handler(w http.ResponseWriter, r *http.Request) { status := http.StatusOK // The ObserverFunc gets called by the deferred ObserveDuration and \t// decides which Histogram's Observe method is called. \ttimer := prometheus.NewTimer(prometheus.ObserverFunc(func(v float64) { switch { case status = 500: // Server error. \tapiRequestDuration.WithLabelValues(\"5xx\").Observe(v) case status = 400: // Client error. \tapiRequestDuration.WithLabelValues(\"4xx\").Observe(v) case status = 300: // Redirection. \tapiRequestDuration.WithLabelValues(\"3xx\").Observe(v) case status = 200: // Success. \tapiRequestDuration.WithLabelValues(\"2xx\").Observe(v) default: // Informational. \tapiRequestDuration.WithLabelValues(\"1xx\").Observe(v) } })) defer timer.ObserveDuration() // Handle the request. Set status accordingly. \t// ... } func ExampleTimer_complex() { http.HandleFunc(\"/api\", handler) }   示例（量规）\nCode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  package prometheus_test import ( \"os\" \"github.com/prometheus/client_golang/prometheus\" ) var ( // If a function is called rarely (i.e. not more often than scrapes \t// happen) or ideally only once (like in a batch job), it can make sense \t// to use a Gauge for timing the function call. For timing a batch job \t// and pushing the result to a Pushgateway, see also the comprehensive \t// example in the push package. \tfuncDuration = prometheus.NewGauge(prometheus.GaugeOpts{ Name: \"example_function_duration_seconds\", Help: \"Duration of the last call of an example function.\", }) ) func run() error { // The Set method of the Gauge is used to observe the duration. \ttimer := prometheus.NewTimer(prometheus.ObserverFunc(funcDuration.Set)) defer timer.ObserveDuration() // Do something. Return errors as encountered. The use of 'defer' above \t// makes sure the function is still timed properly. \treturn nil } func ExampleTimer_gauge() { if err := run(); err != nil { os.Exit(1) } }   func NewTimer 1  func NewTimer(o Observer) *Timer   NewTimer创建一个新的计时器。提供的观察者用于观察持续时间（以秒为单位）。计时器通常用于通过以下方式为函数调用计时：\n1 2 3 4 5  func TimeMe() { timer := NewTimer(myHistogram) defer timer.ObserveDuration() // Do actual work. }   func (*Timer) ObserveDuration 1  func (t *Timer) ObserveDuration() time.Duration   ObserveDuration记录自使用NewTimer创建计时器以来经过的持续时间。它调用构造期间提供的Observer的Observe方法，以持续时间（以秒为单位）作为参数。观察到的持续时间也将返回。通常使用defer语句调用ObserveDuration。\n请注意，只有与Go1.9+一起使用时，才能保证此方法永远不会观察到负持续时间。\ntype UntypedFunc 1 2 3 4  type UntypedFunc interface { Metric Collector }   UntypedFunc的作用类似于GaugeFunc，但收集的指标类型为“Untyped”。UntypedFunc可用于镜像未知类型的外部指标。\n要创建UntypedFunc实例，请使用NewUntypedFunc。\nfunc NewUntypedFunc 1  func NewUntypedFunc(opts UntypedOpts, function func() float64) UntypedFunc   NewUntypedFunc基于提供的UntypedOpts创建一个新的UntypedFunc。报告的值是通过在Write方法中调用给定的函数确定的。考虑到指标收集可能会同时发生。如果这导致对Write的并发调用，例如在UntypedFunc直接向Prometheus注册的情况下，则提供的函数必须是并发安全的。\ntype UntypedOpts  1  type UntypedOpts Opts   UntypedOpts是Opts的别名。请参阅此处以获取文档注释。\ntype ValueType 1  type ValueType int   ValueType是代表简单值的指标类型的枚举。\n1 2 3 4 5  const ( CounterValue ValueType GaugeValue UntypedValue )   ValueType枚举的可能值。使用UntypedValue可以将指标标记为未知类型。\npromhttp包 概述 软件包promhttp提供了围绕HTTP服务器和客户端的工具。\n首先，该包允许创建http.Handler实例以通过HTTP公开Prometheus指标。promhttp.Handler作用于prometheus.DefaultGatherer。使用HandlerFor，您可以为自定义注册表或实现Gatherer接口的任何内容创建处理程序。它还允许创建对错误采取不同行动或允许记录错误的处理程序。\n其次，该软件包提供了通过中间件来检测http.Handler实例的工具。中间件包装器遵循命名方案InstrumentHandlerX，其中X描述了中间件的预期用途。有关详细信息，请参见每个函数的文档注释。\n最后，该程序包允许通过中间件检测http.RoundTripper。中间件包装器遵循InstrumentRoundTripperX的命名方案，其中X描述了中间件的预期用途。有关详细信息，请参见每个函数的文档注释。\nfunc Handler 1  func Handler() http.Handler   处理程序使用默认的HandlerOpts返回prometheus.DefaultGatherer的http.Handler，即，它将第一个错误报告为HTTP错误，没有错误日志记录，并且如果客户端请求，则应用压缩。\n返回的http.Handler已经使用InstrumentMetricHandler函数和prometheus.DefaultRegisterer进行了检测。如果通过分别调用Handler函数创建多个http.Handlers，则用于检测的度量将在它们之间共享，从而提供全局的scrape计数。\n此func旨在涵盖大部分基本用例。如果您要执行需要更多自定义的操作（包括使用非默认的Gatherer，不同的instrumentation和非默认的HandlerOpts），请使用HandlerFor函数。有关详细信息，请参见此处。\nfunc HandlerFor 1  func HandlerFor(reg prometheus.Gatherer, opts HandlerOpts) http.Handler   HandlerFor为提供的Gatherer返回一个非instrumentation化的http.Handler。处理程序的行为由提供的HandlerOpts定义。因此，HandlerFor对于使用非默认HandlerOpts和/或使用自定义（或没有自定义）instrumentation的自定义收集器创建http.Handlers很有用。使用InstrumentMetricHandler函数可以应用与Handler函数所使用的相同类型的检测。\nfunc InstrumentHandlerCounter 1  func InstrumentHandlerCounter(counter *prometheus.CounterVec, next http.Handler) http.HandlerFunc   InstrumentHandlerCounter是一个中间件，包装了提供的http.Handler以使用提供的CounterVec观察请求结果。CounterVec必须具有零，一或两个非const非咖喱标签。对于这些标签，唯一允许的标签名称是“代码”和“方法”。否则，该功能会出现问题。如果CounterVec中存在相应的实例标签名称，则可以通过HTTP状态代码和/或HTTP方法对CounterVec进行分区。对于未分区的计数，请使用带有零标签的CounterVec。\n如果包装的Handler未设置状态码，则假定状态码为200。\n如果包装的处理程序出现紧急情况，则计数器不会增加。\n有关用法示例，请参见InstrumentHandlerDuration的示例。\nfunc InstrumentHandlerDuration 1  func InstrumentHandlerDuration(obs prometheus.ObserverVec, next http.Handler) http.HandlerFunc   InstrumentHandlerDuration是一个中间件，该中间件包装提供的http.Handler以观察提供的ObserverVec的请求持续时间。ObserverVec必须具有零，一或两个非const非咖喱标签。对于这些标签，唯一允许的标签名称是“code”和“method”。否则，该功能会出现问题。调用ObserverVec中的Observer的Observe方法时，请求持续时间以秒为单位。如果ObserverVec中存在相应的实例标签名称，则通过HTTP状态代码和/或HTTP方法进行分区。对于未分区的观察，请使用带有零标签的ObserverVec。请注意，直方图的划分是昂贵的，应谨慎使用。\n如果包装的Handler未设置状态码，则假定状态码为200。\n如果包装的处理程序出现紧急情况，则不会报告任何值。\n请注意，只有与Go1.9 +一起使用时，才能保证此方法永远不会观察到负持续时间。\n例子\nCode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  inFlightGauge := prometheus.NewGauge(prometheus.GaugeOpts{ Name: \"in_flight_requests\", Help: \"A gauge of requests currently being served by the wrapped handler.\", }) counter := prometheus.NewCounterVec( prometheus.CounterOpts{ Name: \"api_requests_total\", Help: \"A counter for requests to the wrapped handler.\", }, []string{\"code\", \"method\"}, ) // duration is partitioned by the HTTP method and handler. It uses custom // buckets based on the expected request duration. duration := prometheus.NewHistogramVec( prometheus.HistogramOpts{ Name: \"request_duration_seconds\", Help: \"A histogram of latencies for requests.\", Buckets: []float64{.25, .5, 1, 2.5, 5, 10}, }, []string{\"handler\", \"method\"}, ) // responseSize has no labels, making it a zero-dimensional // ObserverVec. responseSize := prometheus.NewHistogramVec( prometheus.HistogramOpts{ Name: \"response_size_bytes\", Help: \"A histogram of response sizes for requests.\", Buckets: []float64{200, 500, 900, 1500}, }, []string{}, ) // Create the handlers that will be wrapped by the middleware. pushHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"Push\")) }) pullHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"Pull\")) }) // Register all of the metrics in the standard registry. prometheus.MustRegister(inFlightGauge, counter, duration, responseSize) // Instrument the handlers with all the metrics, injecting the \"handler\" // label by currying. pushChain := InstrumentHandlerInFlight(inFlightGauge, InstrumentHandlerDuration(duration.MustCurryWith(prometheus.Labels{\"handler\": \"push\"}), InstrumentHandlerCounter(counter, InstrumentHandlerResponseSize(responseSize, pushHandler), ), ), ) pullChain := InstrumentHandlerInFlight(inFlightGauge, InstrumentHandlerDuration(duration.MustCurryWith(prometheus.Labels{\"handler\": \"pull\"}), InstrumentHandlerCounter(counter, InstrumentHandlerResponseSize(responseSize, pullHandler), ), ), ) http.Handle(\"/metrics\", Handler()) http.Handle(\"/push\", pushChain) http.Handle(\"/pull\", pullChain) if err := http.ListenAndServe(\":3000\", nil); err != nil { log.Fatal(err) }   func InstrumentHandlerInFlight 1  func InstrumentHandlerInFlight(g prometheus.Gauge, next http.Handler) http.Handler   InstrumentHandlerInFlight是包装提供的http.Handler的中间件。它将提供的prometheus.Gauge设置为当前由包装的http.Handler处理的请求数。\n有关用法示例，请参见InstrumentHandlerDuration的示例。\nfunc InstrumentHandlerRequestSize 1  func InstrumentHandlerRequestSize(obs prometheus.ObserverVec, next http.Handler) http.HandlerFunc   InstrumentHandlerRequestSize是一个中间件，该中间件包装提供的http.Handler以观察提供的ObserverVec的请求大小。ObserverVec必须具有零，一或两个非const非咖喱标签。对于这些标签，唯一允许的标签名称是“code”和“method”。否则，该功能会出现问题。调用ObserverVec中的Observer的Observe方法时，请求大小以字节为单位。如果ObserverVec中存在相应的实例标签名称，则通过HTTP状态代码和/或HTTP方法进行分区。对于未分区的观察，请使用带有零标签的ObserverVec。请注意，直方图的划分是昂贵的，应谨慎使用。\n如果包装的Handler未设置状态码，则假定状态码为200。\n如果包装的处理程序出现紧急情况，则不会报告任何值。\n有关用法示例，请参见InstrumentHandlerDuration的示例。\nfunc InstrumentHandlerResponseSize 1  func InstrumentHandlerResponseSize(obs prometheus.ObserverVec, next http.Handler) http.Handler   InstrumentHandlerResponseSize是一个中间件，包装了提供的http.Handler以观察提供的ObserverVec的响应大小。ObserverVec必须具有零，一或两个非const非咖喱标签。对于这些标签，唯一允许的标签名称是“code”和“method”。否则，该功能会出现问题。调用ObserverVec中的Observer的Observe方法，其响应大小以字节为单位。如果ObserverVec中存在相应的实例标签名称，则通过HTTP状态代码和/或HTTP方法进行分区。对于未分区的观察，请使用带有零标签的ObserverVec。请注意，直方图的划分是昂贵的，应谨慎使用。\n如果包装的Handler未设置状态码，则假定状态码为200。\n如果包装的处理程序出现紧急情况，则不会报告任何值。\n有关用法示例，请参见InstrumentHandlerDuration的示例。\nfunc InstrumentHandlerTimeToWriteHeader 1  func InstrumentHandlerTimeToWriteHeader(obs prometheus.ObserverVec, next http.Handler) http.HandlerFunc   InstrumentHandlerTimeToWriteHeader是一个中间件，包装了提供的http.Handler，以使用提供的ObserverVec观察请求持续时间，直到写入响应标头为止。ObserverVec必须具有零，一或两个非const非咖喱标签。对于这些标签，唯一允许的标签名称是“code”和“method”。否则，该功能会出现问题。调用ObserverVec中的Observer的Observe方法时，请求持续时间以秒为单位。如果ObserverVec中存在相应的实例标签名称，则通过HTTP状态代码和/或HTTP方法进行分区。对于未分区的观察，请使用带有零标签的ObserverVec。请注意，直方图的划分是昂贵的，应谨慎使用。\n如果包装的Handler在调用WriteHeader之前发生了混乱，则不会报告任何值。\n请注意，只有与Go1.9 +一起使用时，才能保证此方法永远不会观察到负持续时间。\n有关用法示例，请参见InstrumentHandlerDuration的示例。\nfunc InstrumentMetricHandler 1  func InstrumentMetricHandler(reg prometheus.Registerer, handler http.Handler) http.Handler   InstrumentMetricHandler通常与HandlerFor函数返回的http.Handler一起使用。它使用两个度量为提供的http.Handler进行检测：一个计数器向量“promhttp_metric_handler_requests_total”对按HTTP状态码划分的scrapes进行计数，而量规“promhttp_metric_handler_requests_in_flight”则用于跟踪同时进行的scrapes数量。此功能使用提供的注册器为两个指标均等地注册收集器。如果注册失败，它将感到恐慌。所提供的度量标准对于查看有多少scrapes被监视目标（可能来自不同的Prometheus服务器或其他scrapes），以及它们重叠的频率（将导致同时有多个scrapes在飞行中）非常有用。请注意，飞行中的刮擦量具将包含其暴露的刮擦，而刮擦计数器仅在刮擦完成后才会递增（因为只有这样才能知道状态码）。要跟踪刮擦时间，请使用Prometheus服务器在每次scrape时创建的“ scrape_duration_seconds”量规。\ntype HandlerErrorHandling 1  type HandlerErrorHandling int   HandlerErrorHandling定义处理程序服务指标如何处理错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  const ( // Serve an HTTP status code 500 upon the first error \t// encountered. Report the error message in the body. Note that HTTP \t// errors cannot be served anymore once the beginning of a regular \t// payload has been sent. Thus, in the (unlikely) case that encoding the \t// payload into the negotiated wire format fails, serving the response \t// will simply be aborted. Set an ErrorLog in HandlerOpts to detect \t// those errors. \tHTTPErrorOnError HandlerErrorHandling = iota // Ignore errors and try to serve as many metrics as possible. However, \t// if no metrics can be served, serve an HTTP status code 500 and the \t// last error message in the body. Only use this in deliberate \"best \t// effort\" metrics collection scenarios. In this case, it is highly \t// recommended to provide other means of detecting errors: By setting an \t// ErrorLog in HandlerOpts, the errors are logged. By providing a \t// Registry in HandlerOpts, the exposed metrics include an error counter \t// \"promhttp_metric_handler_errors_total\", which can be used for \t// alerts. \tContinueOnError // Panic upon the first error encountered (useful for \"crash only\" apps). \tPanicOnError )   如果遇到错误，这些常量将导致服务度量标准的处理程序行为如所述。\ntype HandlerOpts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  type HandlerOpts struct { // ErrorLog specifies an optional logger for errors collecting and \t// serving metrics. If nil, errors are not logged at all. \tErrorLog Logger // ErrorHandling defines how errors are handled. Note that errors are \t// logged regardless of the configured ErrorHandling provided ErrorLog \t// is not nil. \tErrorHandling HandlerErrorHandling // If Registry is not nil, it is used to register a metric \t// \"promhttp_metric_handler_errors_total\", partitioned by \"cause\". A \t// failed registration causes a panic. Note that this error counter is \t// different from the instrumentation you get from the various \t// InstrumentHandler... helpers. It counts errors that don't necessarily \t// result in a non-2xx HTTP status code. There are two typical cases: \t// (1) Encoding errors that only happen after streaming of the HTTP body \t// has already started (and the status code 200 has been sent). This \t// should only happen with custom collectors. (2) Collection errors with \t// no effect on the HTTP status code because ErrorHandling is set to \t// ContinueOnError. \tRegistry prometheus.Registerer // If DisableCompression is true, the handler will never compress the \t// response, even if requested by the client. \tDisableCompression bool // The number of concurrent HTTP requests is limited to \t// MaxRequestsInFlight. Additional requests are responded to with 503 \t// Service Unavailable and a suitable message in the body. If \t// MaxRequestsInFlight is 0 or negative, no limit is applied. \tMaxRequestsInFlight int // If handling a request takes longer than Timeout, it is responded to \t// with 503 ServiceUnavailable and a suitable Message. No timeout is \t// applied if Timeout is 0 or negative. Note that with the current \t// implementation, reaching the timeout simply ends the HTTP requests as \t// described above (and even that only if sending of the body hasn't \t// started yet), while the bulk work of gathering all the metrics keeps \t// running in the background (with the eventual result to be thrown \t// away). Until the implementation is improved, it is recommended to \t// implement a separate timeout in potentially slow Collectors. \tTimeout time.Duration // If true, the experimental OpenMetrics encoding is added to the \t// possible options during content negotiation. Note that Prometheus \t// 2.5.0+ will negotiate OpenMetrics as first priority. OpenMetrics is \t// the only way to transmit exemplars. However, the move to OpenMetrics \t// is not completely transparent. Most notably, the values of \"quantile\" \t// labels of Summaries and \"le\" labels of Histograms are formatted with \t// a trailing \".0\" if they would otherwise look like integer numbers \t// (which changes the identity of the resulting series on the Prometheus \t// server). \tEnableOpenMetrics bool }   HandlerOpts指定如何通过http.Handler提供指标的选项。HandlerOpts的零值为合理的默认值。\ntype InstrumentTrace 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  type InstrumentTrace struct { GotConn func(float64) PutIdleConn func(float64) GotFirstResponseByte func(float64) Got100Continue func(float64) DNSStart func(float64) DNSDone func(float64) ConnectStart func(float64) ConnectDone func(float64) TLSHandshakeStart func(float64) TLSHandshakeDone func(float64) WroteHeaders func(float64) Wait100Continue func(float64) WroteRequest func(float64) }   InstrumentTrace用于在检测可用的httptrace.ClientTrace挂钩函数时提供灵活性。每个函数都传递了一个float64，表示自http请求开始以来的时间（以秒为单位）。用户可以选择单独使用存储桶直方图，也可以基于每个功能实现自定义实例标签。\ntype Logger 1 2 3  type Logger interface { Println(v ...interface{}) }   记录器是HandlerOpts记录所需的最小接口。请注意，标准库中的log.Logger实现了此接口，并且自定义记录器无论如何还很容易实现。\ntype RoundTripperFunc 1  type RoundTripperFunc func(req *http.Request) (*http.Response, error)   RoundTripperFunc类型是一个适配器，允许将常规功能用作RoundTrippers。如果f是具有适当签名的函数，则RountTripperFunc（f）是调用f的RoundTripper。\nfunc InstrumentRoundTripperCounter 1  func InstrumentRoundTripperCounter(counter *prometheus.CounterVec, next http.RoundTripper) RoundTripperFunc   InstrumentRoundTripperCounter是一个中间件，包装了提供的http.RoundTripper来观察提供的CounterVec的请求结果。CounterVec必须具有零，一或两个非const非咖喱标签。对于这些标签，唯一允许的标签名称是“code”和“method”。否则，该功能会出现问题。如果CounterVec中存在相应的实例标签名称，则可以通过HTTP状态代码和/或HTTP方法对CounterVec进行分区。对于未分区的计数，请使用带有零标签的CounterVec。\n如果包装的RoundTripper出现紧急情况或返回非nil错误，则计数器不会递增。\n有关示例用法，请参见ExampleInstrumentRoundTripperDuration的示例。\nfunc InstrumentRoundTripperDuration 1  func InstrumentRoundTripperDuration(obs prometheus.ObserverVec, next http.RoundTripper) RoundTripperFunc   InstrumentRoundTripperDuration是一个中间件，包装了提供的http.RoundTripper来观察提供的ObserverVec的请求持续时间。ObserverVec必须具有零，一或两个非const非咖喱标签。对于这些标签，唯一允许的标签名称是“code”和“method”。否则，该功能会出现问题。调用ObserverVec中的Observer的Observe方法时，请求持续时间以秒为单位。如果ObserverVec中存在相应的实例标签名称，则通过HTTP状态代码和/或HTTP方法进行分区。对于未分区的观察，请使用带有零标签的ObserverVec。请注意，直方图的划分是昂贵的，应谨慎使用。\n如果包装的RoundTripper出现紧急情况或返回非nil错误，则不会报告任何值。\n请注意，只有与Go1.9 +一起使用时，才能保证此方法永远不会观察到负持续时间。\n例子\nCode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89  client := http.DefaultClient client.Timeout = 1 * time.Second inFlightGauge := prometheus.NewGauge(prometheus.GaugeOpts{ Name: \"client_in_flight_requests\", Help: \"A gauge of in-flight requests for the wrapped client.\", }) counter := prometheus.NewCounterVec( prometheus.CounterOpts{ Name: \"client_api_requests_total\", Help: \"A counter for requests from the wrapped client.\", }, []string{\"code\", \"method\"}, ) // dnsLatencyVec uses custom buckets based on expected dns durations. // It has an instance label \"event\", which is set in the // DNSStart and DNSDonehook functions defined in the // InstrumentTrace struct below. dnsLatencyVec := prometheus.NewHistogramVec( prometheus.HistogramOpts{ Name: \"dns_duration_seconds\", Help: \"Trace dns latency histogram.\", Buckets: []float64{.005, .01, .025, .05}, }, []string{\"event\"}, ) // tlsLatencyVec uses custom buckets based on expected tls durations. // It has an instance label \"event\", which is set in the // TLSHandshakeStart and TLSHandshakeDone hook functions defined in the // InstrumentTrace struct below. tlsLatencyVec := prometheus.NewHistogramVec( prometheus.HistogramOpts{ Name: \"tls_duration_seconds\", Help: \"Trace tls latency histogram.\", Buckets: []float64{.05, .1, .25, .5}, }, []string{\"event\"}, ) // histVec has no labels, making it a zero-dimensional ObserverVec. histVec := prometheus.NewHistogramVec( prometheus.HistogramOpts{ Name: \"request_duration_seconds\", Help: \"A histogram of request latencies.\", Buckets: prometheus.DefBuckets, }, []string{}, ) // Register all of the metrics in the standard registry. prometheus.MustRegister(counter, tlsLatencyVec, dnsLatencyVec, histVec, inFlightGauge) // Define functions for the available httptrace.ClientTrace hook // functions that we want to instrument. trace := \u0026InstrumentTrace{ DNSStart: func(t float64) { dnsLatencyVec.WithLabelValues(\"dns_start\").Observe(t) }, DNSDone: func(t float64) { dnsLatencyVec.WithLabelValues(\"dns_done\").Observe(t) }, TLSHandshakeStart: func(t float64) { tlsLatencyVec.WithLabelValues(\"tls_handshake_start\").Observe(t) }, TLSHandshakeDone: func(t float64) { tlsLatencyVec.WithLabelValues(\"tls_handshake_done\").Observe(t) }, } // Wrap the default RoundTripper with middleware. roundTripper := InstrumentRoundTripperInFlight(inFlightGauge, InstrumentRoundTripperCounter(counter, InstrumentRoundTripperTrace(trace, InstrumentRoundTripperDuration(histVec, http.DefaultTransport), ), ), ) // Set the RoundTripper on our client. client.Transport = roundTripper resp, err := client.Get(\"http://google.com\") if err != nil { log.Printf(\"error: %v\", err) } defer resp.Body.Close()   func InstrumentRoundTripperInFlight 1  func InstrumentRoundTripperInFlight(gauge prometheus.Gauge, next http.RoundTripper) RoundTripperFunc   InstrumentRoundTripperInFlight是包装提供的http.RoundTripper的中间件。它将提供的prometheus.Gauge设置为当前由包装的http.RoundTripper处理的请求数。\n有关示例用法，请参见ExampleInstrumentRoundTripperDuration的示例。\nfunc InstrumentRoundTripperTrace 1  func InstrumentRoundTripperTrace(it *InstrumentTrace, next http.RoundTripper) RoundTripperFunc   InstrumentRoundTripperTrace是一个中间件，包装了提供的RoundTripper并报告了InstrumentTrace结构中提供的挂钩函数的时间。提供的InstrumentTrace结构中不存在的挂钩函数将被忽略。向挂钩函数报告的时间是自请求开始以来的时间。只有使用Go1.9 +，这些时间才能保证永远不会为负。（早期的Go版本不使用单调时钟。）请注意，直方图的划分是昂贵的，应谨慎使用。\n对于将错误作为参数接收的钩子函数，如果非零错误值，则不会进行观察。\n有关示例用法，请参见ExampleInstrumentRoundTripperDuration的示例。\nfunc (RoundTripperFunc) RoundTrip 1  func (rt RoundTripperFunc) RoundTrip(r *http.Request) (*http.Response, error)   RoundTrip实现RoundTripper接口。\npromauto包 概述 软件包promauto为基本的Prometheus度量标准类型及其…Vec和…Func变体提供了替代构造函数。与prometheus程序包中的对应程序不同的是，promauto构造函数返回已在注册表中注册的Collector。有两组构造函数。第一组中的构造函数是顶级函数，而另一组中的构造函数是Factory类型的方法。顶级函数返回在全局注册表（prometheus.DefaultRegisterer）中注册的Collector，而方法返回在构造工厂的注册表中注册的Collector。如果注册失败，所有构造函数都会感到恐慌。\n以下示例是一个完整的程序，可从math / rand程序包中创建正态分布的随机数直方图：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  package main import ( \"math/rand\" \"net/http\" \"github.com/prometheus/client_golang/prometheus\" \"github.com/prometheus/client_golang/prometheus/promauto\" \"github.com/prometheus/client_golang/prometheus/promhttp\" ) var histogram = promauto.NewHistogram(prometheus.HistogramOpts{ Name: \"random_numbers\", Help: \"A histogram of normally distributed random numbers.\", Buckets: prometheus.LinearBuckets(-3, .1, 61), }) func Random() { for { histogram.Observe(rand.NormFloat64()) } } func main() { go Random() http.Handle(\"/metrics\", promhttp.Handler()) http.ListenAndServe(\":1971\", nil) }   Prometheus的最小hello-world程序版本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  package main import ( \"fmt\" \"net/http\" \"github.com/prometheus/client_golang/prometheus\" \"github.com/prometheus/client_golang/prometheus/promauto\" \"github.com/prometheus/client_golang/prometheus/promhttp\" ) func main() { http.Handle(\"/\", promhttp.InstrumentHandlerCounter( promauto.NewCounterVec( prometheus.CounterOpts{ Name: \"hello_requests_total\", Help: \"Total number of hello-world requests by HTTP code.\", }, []string{\"code\"}, ), http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, \"Hello, world!\") }), )) http.Handle(\"/metrics\", promhttp.Handler()) http.ListenAndServe(\":1971\", nil) }   使用With（prometheus.Registerer）函数创建一个Factory，该函数启用两种使用模式。With（prometheus.Registerer）可以每行调用一次：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  var ( reg = prometheus.NewRegistry() randomNumbers = promauto.With(reg).NewHistogram(prometheus.HistogramOpts{ Name: \"random_numbers\", Help: \"A histogram of normally distributed random numbers.\", Buckets: prometheus.LinearBuckets(-3, .1, 61), }) requestCount = promauto.With(reg).NewCounterVec( prometheus.CounterOpts{ Name: \"http_requests_total\", Help: \"Total number of HTTP requests by status code and method.\", }, []string{\"code\", \"method\"}, ) )   或者，它可以用于一次创建一个Factory，以便多次使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  var ( reg = prometheus.NewRegistry() factory = promauto.With(reg) randomNumbers = factory.NewHistogram(prometheus.HistogramOpts{ Name: \"random_numbers\", Help: \"A histogram of normally distributed random numbers.\", Buckets: prometheus.LinearBuckets(-3, .1, 61), }) requestCount = factory.NewCounterVec( prometheus.CounterOpts{ Name: \"http_requests_total\", Help: \"Total number of HTTP requests by status code and method.\", }, []string{\"code\", \"method\"}, ) )   这看起来非常方便。那么，为什么将这些构造函数锁定在单独的程序包中呢？\n主要问题是注册可能会失败，例如，如果已经注册了与新注册或注册的不一致或相等的度量标准。因此，prometheus.Registerer接口中的Register方法返回错误，顶级全局prometheus.Register函数向全局注册表进行注册的情况也是如此。prometheus软件包还提供了两者的MustRegister版本。如果注册失败，他们会感到恐慌，并且他们使用Must…惯用语清楚地指出了这一点。在这种情况下，恐慌是有问题的，因为它不仅会发生在调用方提供的输入本身就无效的情况下。这里的情况更加微妙：度量标准的创建和注册往往在代码库中广泛分布。很容易将不兼容的指标添加到代码的不相关部分，突然之间，曾经可以正常工作的代码开始出现恐慌（前提是新添加的度量标准的注册发生在先前存在的度量标准的注册之前）。对于全局注册表，这可能会带来更大的惊喜，在全局注册表中，简单地导入另一个程序包可能会引发恐慌（如果新导入的程序包在其init函数中注册了指标）。至少在普罗米修斯软件包中，指标和其他收集器的创建与注册是分开的。首先创建度量标准，然后明确决定是否要在本地或全局注册表中注册该度量标准，以及是否要处理该错误或可能出现恐慌。使用promauto软件包中的构造函数时，注册是自动的，并且如果注册失败，则总是会出现紧急情况。此外，\n单独的软件包允许保守的用户完全忽略它。任何想要使用它的人都将明确使用它，并有机会阅读此警告。\n负责任地享受promauto！\nfunc NewCounter 1  func NewCounter(opts prometheus.CounterOpts) prometheus.Counter   NewCounter的工作原理与prometheus软件包中的同名功能相同，但它会自动向prometheus.DefaultRegisterer注册Counter。如果注册失败，NewCounter会慌张。\nfunc NewCounterFunc 1  func NewCounterFunc(opts prometheus.CounterOpts, function func() float64) prometheus.CounterFunc   NewCounterFunc的工作原理与prometheus软件包中的同名功能相同，但是它会自动将CounterFunc注册到prometheus.DefaultRegisterer中。如果注册失败，NewCounterFunc会发生故障。\nfunc NewCounterVec 1  func NewCounterVec(opts prometheus.CounterOpts, labelNames []string) *prometheus.CounterVec   NewCounterVec的工作方式与prometheus软件包中的同名功能相同，但是它会自动将CounterVec注册到prometheus.DefaultRegisterer中。如果注册失败，NewCounterVec会发生故障。\nfunc NewGauge 1  func NewGauge(opts prometheus.GaugeOpts) prometheus.Gauge   NewGauge的工作原理与prometheus软件包中的同名功能相同，但是它会自动将pro-proeueus.DefaultRegisterer注册到Gauge。如果注册失败，NewGauge会慌张。\nfunc NewGaugeFunc 1  func NewGaugeFunc(opts prometheus.GaugeOpts, function func() float64) prometheus.GaugeFunc   NewGaugeFunc的工作原理与prometheus软件包中的同名函数相同，但它会自动将GaugeFunc注册到prometheus.DefaultRegisterer中。如果注册失败，NewGaugeFunc会发生故障。\nfunc NewGaugeVec 1  func NewGaugeVec(opts prometheus.GaugeOpts, labelNames []string) *prometheus.GaugeVec   NewGaugeVec的工作方式与prometheus软件包中的同名功能相同，但它会自动将GaugeVec注册到prometheus.DefaultRegisterer中。如果注册失败，NewGaugeVec会发生故障。\nfunc NewHistogram 1  func NewHistogram(opts prometheus.HistogramOpts) prometheus.Histogram   NewHistogram的工作原理与prometheus软件包中的同名功能相同，但它会自动将prohisteus.DefaultRegisterer注册直方图。如果注册失败，NewHistogram会出现紧急情况。\nfunc NewHistogramVec 1  func NewHistogramVec(opts prometheus.HistogramOpts, labelNames []string) *prometheus.HistogramVec   NewHistogramVec的工作原理与prometheus软件包中的同名功能相同，但它会自动向prometheus.DefaultRegisterer注册HistogramVec。如果注册失败，则NewHistogramVec会发生故障。\nfunc NewSummary 1  func NewSummary(opts prometheus.SummaryOpts) prometheus.Summary   NewSummary的工作方式与prometheus软件包中的同名功能相同，但是它会自动将摘要摘要注册到prometheus.DefaultRegisterer中。如果注册失败，NewSummary会感到恐慌。\nfunc NewSummaryVec 1  func NewSummaryVec(opts prometheus.SummaryOpts, labelNames []string) *prometheus.SummaryVec   NewSummaryVec的工作方式与prometheus程序包中的同名功能相同，但它会自动向prometheus.DefaultRegisterer注册SummaryVec。如果注册失败，NewSummaryVec会发生故障。\nfunc NewSummaryVec 1  func NewSummaryVec(opts prometheus.SummaryOpts, labelNames []string) *prometheus.SummaryVec   NewUntypedFunc的工作原理与prometheus包中的同名函数相同，但是会自动将untypedFunc注册到prometheus.DefaultRegisterer中。如果注册失败，则NewUntypedFunc会发生故障。\ntype Factory 1 2 3  type Factory struct { // contains filtered or unexported fields }   Factory提供了工厂方法来创建自动在注册器中注册的收集器。使用With功能创建Factory，提供注册器以自动注册创建的收集器。Factory的零值会创建未在任何注册器中注册的收集器。如果注册失败，则工厂将惊慌的所有方法。\nfunc With 1  func With(r prometheus.Registerer) Factory   With使用提供的注册器创建工厂，用于注册创建的收集器。如果提供的注册器为nil，则返回的工厂将创建未在任何注册器中注册的收集器。\nfunc (Factory) NewCounter 1  func (f Factory) NewCounter(opts prometheus.CounterOpts) prometheus.Counter   NewCounter的工作方式与prometheus软件包中的同名功能相同，但是它会自动将计数器注册到工厂的注册器中。\nfunc (Factory) NewCounterFunc 1  func (f Factory) NewCounterFunc(opts prometheus.CounterOpts, function func() float64) prometheus.CounterFunc   NewCounterFunc的工作原理与prometheus软件包中的同名功能类似，但是它会自动将CounterFunc注册到Factory的Registerer。\nfunc (Factory) NewCounterVec 1  func (f Factory) NewCounterVec(opts prometheus.CounterOpts, labelNames []string) *prometheus.CounterVec   NewCounterVec的工作方式与prometheus软件包中的同名功能相同，但是它会自动将CounterVec注册到工厂的注册器中。\nfunc (Factory) NewGauge 1  func (f Factory) NewGauge(opts prometheus.GaugeOpts) prometheus.Gauge   NewGauge的工作方式与prometheus软件包中的同名功能相同，但它会自动将Gauge登记到Factory的Registerer。\nfunc (Factory) NewGaugeFunc 1  func (f Factory) NewGaugeFunc(opts prometheus.GaugeOpts, function func() float64) prometheus.GaugeFunc   NewGaugeFunc的工作原理与prometheus软件包中的同名功能相同，但是它会自动将GaugeFunc注册到工厂的注册器。\nfunc (Factory) NewGaugeVec 1  func (f Factory) NewGaugeVec(opts prometheus.GaugeOpts, labelNames []string) *prometheus.GaugeVec   NewGaugeVec的工作方式与prometheus软件包中的同名功能相同，但它会自动将GaugeVec注册到工厂的注册器。\nfunc (Factory) NewHistogram 1  func (f Factory) NewHistogram(opts prometheus.HistogramOpts) prometheus.Histogram   NewHistogram的工作方式与Prometheus软件包中的同名功能相同，但它会自动将Histogram注册到Factory的Registerer中。\nfunc (Factory) NewHistogramVec 1  func (f Factory) NewHistogramVec(opts prometheus.HistogramOpts, labelNames []string) *prometheus.HistogramVec   NewHistogramVec的工作方式与prometheus软件包中的同名功能相同，但是它会自动将HistogramVec注册到Factory的Registerer。\nfunc (Factory) NewSummary 1  func (f Factory) NewSummary(opts prometheus.SummaryOpts) prometheus.Summary   NewSummary的工作方式与prometheus软件包中的同名功能相同，但它会自动向工厂的注册器注册摘要。\nfunc (Factory) NewSummaryVec 1  func (f Factory) NewSummaryVec(opts prometheus.SummaryOpts, labelNames []string) *prometheus.SummaryVec   NewSummaryVec的工作方式与prometheus程序包中的同名功能相同，但它会自动向工厂的注册器注册SummaryVec。\nfunc (Factory) NewUntypedFunc 1  func (f Factory) NewUntypedFunc(opts prometheus.UntypedOpts, function func() float64) prometheus.UntypedFunc   NewUntypedFunc的工作方式与prometheus包中的同名功能相同，但是它会自动将UntypedFunc注册到工厂的注册器中。\n",
  "wordCount" : "42777",
  "inLanguage": "zh-cn",
  "datePublished": "2020-07-14T17:21:00Z",
  "dateModified": "2020-07-14T17:21:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/prometheus%E7%9A%84client_golang/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Prometheus的client_golang
    </h1>
    <div class="post-meta">July 14, 2020
</div>
  </header> 
  <div class="post-content"><h1 id="prometheus包">prometheus包<a hidden class="anchor" aria-hidden="true" href="#prometheus包">#</a></h1>
<h2 id="概述">概述<a hidden class="anchor" aria-hidden="true" href="#概述">#</a></h2>
<p>普罗米修斯软件包是仪器仪表的核心。它为度量代码提供度量原语以进行监视。它还提供了Metric注册表。子包允许通过HTTP（包promhttp）公开已注册的指标，或将其推送到Pushgateway（包推送）。还有一个子包promauto，它为Metric构造函数提供自动注册。</p>
<p>除非另有说明，否则所有导出的函数和方法都可以安全地并发使用。</p>
<h2 id="一个基本的例子">一个基本的例子<a hidden class="anchor" aria-hidden="true" href="#一个基本的例子">#</a></h2>
<p>首先，给出一个非常基本的用法示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/prometheus/client_golang/prometheus&#34;</span>
	<span class="s">&#34;github.com/prometheus/client_golang/prometheus/promhttp&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">cpuTemp</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewGauge</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;cpu_temperature_celsius&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span> <span class="s">&#34;Current temperature of the CPU.&#34;</span><span class="p">,</span>
	<span class="p">})</span>
	<span class="nx">hdFailures</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewCounterVec</span><span class="p">(</span>
		<span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">{</span>
			<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;hd_errors_total&#34;</span><span class="p">,</span>
			<span class="nx">Help</span><span class="p">:</span> <span class="s">&#34;Number of hard-disk errors.&#34;</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;device&#34;</span><span class="p">},</span>
	<span class="p">)</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Metrics have to be registered to be exposed:
</span><span class="c1"></span>	<span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">cpuTemp</span><span class="p">)</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">hdFailures</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">cpuTemp</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="mf">65.3</span><span class="p">)</span>
	<span class="nx">hdFailures</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;device&#34;</span><span class="p">:</span><span class="s">&#34;/dev/sda&#34;</span><span class="p">}).</span><span class="nf">Inc</span><span class="p">()</span>

	<span class="c1">// The Handler function provides a default handler to expose metrics
</span><span class="c1"></span>	<span class="c1">// via an HTTP server. &#34;/metrics&#34; is the usual endpoint for that.
</span><span class="c1"></span>	<span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/metrics&#34;</span><span class="p">,</span> <span class="nx">promhttp</span><span class="p">.</span><span class="nf">Handler</span><span class="p">())</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这是一个完整的程序，可以导出两个指标，一个量规和一个计数器，后者带有标签，可以将其转换为（一维）向量。</p>
<h2 id="指标">指标<a hidden class="anchor" aria-hidden="true" href="#指标">#</a></h2>
<p>该软件包中导出的标识符的数量可能看起来有点不堪重负。但是，除了上面示例中显示的基本管道外，您仅需要了解不同的Metric类型及其向量版本即可基本使用。此外，如果您不关心何时以及如何在注册表中注册度量的精细控制，请查看promauto软件包，该软件包将有效地使您在简单情况下完全忽略注册。</p>
<p>在上方，您已经触摸了计数器和仪表。有两种更高级的Metric类型：“摘要”和“直方图”。可以在Prometheus docs中找到对这四种Metric类型的更详尽的描述：<a href="https://prometheus.io/docs/concepts/metric_types/">https://prometheus.io/docs/concepts/metric_types/</a></p>
<p>除了基本的Metric类型“量规”，“计数器”，“摘要”和“直方图”之外，Prometheus数据模型的一个非常重要的部分是沿称为标签的维度对样本进行划分，这将导致度量向量。基本类型是GaugeVec，CounterVec，SummaryVec和HistogramVec。</p>
<p>虽然仅基本Metric类型实现Metric接口，但Metric及其向量版本均实现了Collector接口。收集器管理许多Metric的收集，但为方便起见，Metric也可以“自行收集”。注意，Gauge，Counter，Summary和Histogram本身是接口，而GaugeVec，CounterVec，SummaryVec和HistogramVec不是接口。</p>
<p>要创建Metric及其向量版本的实例，您需要一个合适的…Opts结构，即GaugeOpts，CounterOpts，SummaryOpts或HistogramOpts。</p>
<h2 id="自定义收集器和常量指标">自定义收集器和常量指标<a hidden class="anchor" aria-hidden="true" href="#自定义收集器和常量指标">#</a></h2>
<p>尽管您可以创建自己的Metric实现，但很可能仅会自己实现Collector接口。乍一看，自定义收集器似乎很方便将Metric捆绑在一起以进行通用注册（以上述不同Metric向量的主要示例为例，该Metric捆绑了所有相同名称但具有不同标签的Metric）。</p>
<p>还有一个更复杂的用例：如果您已经有在Prometheus上下文之外创建的度量，则不需要各种Metric类型的接口。本质上，您希望在收集过程中将现有数字镜像到PrometheusMetric中。收集器接口的自己实现非常适合此操作。您可以使用NewConstMetric，NewConstHistogram和NewConstSummary（以及它们各自的Must…版本）“动态”创建Metric实例。 NewConstMetric用于仅以float64作为其值的所有Metric类型：Counter，Gauge和称为Untyped的特殊“类型”。如果不确定镜像指标是计数器还是量表，请使用后者。 Metric实例的创建在Collect方法中进行。 Describe方法必须返回单独的Desc实例，以代表稍后将创建的“丢弃”Metric。 NewDesc可以方便地创建这些Desc实例。或者，您可以根本不返回任何Desc，这会将收集器标记为“未选中”。在注册时不会执行任何检查，但是在刮刮时仍将确保Metric一致性，即任何不一致都会导致刮刮错误。因此，对于未经检查的收集器，不收集导致总刮除结果不一致的度量的责任在于收集器的实施者。虽然这不是理想的状态，但有时是必需的。典型的用例是在注册时无法预测要由收集器返回的确切度量的情况，但是实现者对整个系统有足够的知识以保证度量的一致性。</p>
<p>收集器示例说明了用例。您还可以查看processCollector（镜像流程指标），goCollector（镜像Go指标）或expvarCollector（镜像expvar指标）的源代码，作为在此包本身中使用的示例。</p>
<p>如果只需要调用一个函数来获取单个浮点值以作为度量收集，GaugeFunc，CounterFunc或UntypedFunc可能是有趣的快捷方式。</p>
<h2 id="注册表的高级用法">注册表的高级用法<a hidden class="anchor" aria-hidden="true" href="#注册表的高级用法">#</a></h2>
<p>虽然MustRegister是注册收集器的最常用方法，但有时您可能希望处理注册可能导致的错误。顾名思义，如果发生错误，MustRegister会出现混乱。使用Register方法，可以返回错误并可以处理。</p>
<p>如果注册的收集器与已注册的Metric不兼容或不一致，则返回错误。该注册表旨在根据Prometheus数据模型来确保所收集指标的一致性。理想情况下，在注册时而不是在收集时检测到不一致。通常，前者通常在程序启动时被检测到，而后者只会在抓取时发生，如果不一致仅在以后变得很重要，则可能甚至不会在第一次抓取时发生。这就是收集器和Metric必须向注册表描述自己的主要原因。</p>
<p>到目前为止，我们所做的一切都在所谓的默认注册表上进行，因为可以在全局DefaultRegisterer变量中找到它。使用NewRegistry，您可以创建自定义注册表，甚至可以自己实现Registerer或Gatherer接口。注册和注销方法在自定义注册表上的工作方式与默认注册表上的全局函数注册和注销的工作方式相同。</p>
<p>自定义注册表有多种用途：您可以使用具有特殊属性的注册表，请参阅NewPedanticRegistry。您可以避免由DefaultRegisterer施加的全局状态。您可以同时使用多个注册表，以不同的方式公开不同的指标。您可以将单独的注册表用于测试目的。</p>
<p>还请注意，DefaultRegisterer已注册了Go运行时Metric的收集器（通过NewGoCollector）和过程度量的收集器（通过NewProcessCollector）。使用自定义注册表，您可以控制并自行决定要注册的收集器。</p>
<h2 id="http解释">HTTP解释<a hidden class="anchor" aria-hidden="true" href="#http解释">#</a></h2>
<p>注册表实现了Gatherer接口。然后，Gather方法的调用者可以以某种方式公开收集的指标。通常，度量是通过/metrics端点上的HTTP提供的。在上面的示例中就是这种情况。通过HTTP公开指标的工具位于promhttp子软件包中。</p>
<h2 id="推到pushgateway">推到Pushgateway<a hidden class="anchor" aria-hidden="true" href="#推到pushgateway">#</a></h2>
<p>在push子包中可以找到用于推送到Pushgateway的功能。</p>
<h2 id="graphite-bridge">Graphite Bridge<a hidden class="anchor" aria-hidden="true" href="#graphite-bridge">#</a></h2>
<p>在Graphite Bridge子包中可以找到将度量从采集器推向Graphite的函数和示例。</p>
<p>通过遵循现有实现的方法，可以轻松添加更多公开指标的方法。</p>
<h2 id="常量">常量<a hidden class="anchor" aria-hidden="true" href="#常量">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="c1">// DefMaxAge is the default duration for which observations stay
</span><span class="c1"></span>	<span class="c1">// relevant.
</span><span class="c1"></span>	<span class="nx">DefMaxAge</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span>
	<span class="c1">// DefAgeBuckets is the default number of buckets used to calculate the
</span><span class="c1"></span>	<span class="c1">// age of observations.
</span><span class="c1"></span>	<span class="nx">DefAgeBuckets</span> <span class="p">=</span> <span class="mi">5</span>
	<span class="c1">// DefBufCap is the standard buffer size for collecting Summary observations.
</span><span class="c1"></span>	<span class="nx">DefBufCap</span> <span class="p">=</span> <span class="mi">500</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>SummaryOpts的默认值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">ExemplarMaxRunes</span> <span class="p">=</span> <span class="mi">64</span>
</code></pre></td></tr></table>
</div>
</div><p>ExemplarMaxRunes是示例标签中允许的最大符文总数。</p>
<h2 id="变量">变量<a hidden class="anchor" aria-hidden="true" href="#变量">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">DefaultRegisterer</span> <span class="nx">Registerer</span> <span class="p">=</span> <span class="nx">defaultRegistry</span>
	<span class="nx">DefaultGatherer</span>   <span class="nx">Gatherer</span>   <span class="p">=</span> <span class="nx">defaultRegistry</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>DefaultRegisterer和DefaultGatherer是Registerer和Gatherer接口的实现，此包中的许多便捷功能都作用于该接口。最初，这两个变量都指向同一个注册表，该注册表具有一个进程收集器（当前仅在Linux上，请参阅NewProcessCollector）和一个Go收集器（请参阅NewGoCollector，尤其是有关1.9之前的Go版本的停止世界的注释）已经登记了。这种将默认实例保持为全局状态的方法反映了Go标准库中其他软件包的方法。请注意，有一些警告。仅当您了解后果后，才应谨慎更改变量。希望完全避免全局状态的用户不应使用便捷功能，而应对自定义实例进行操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">DefBuckets</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">float64</span><span class="p">{</span><span class="mf">.005</span><span class="p">,</span> <span class="mf">.01</span><span class="p">,</span> <span class="mf">.025</span><span class="p">,</span> <span class="mf">.05</span><span class="p">,</span> <span class="mf">.1</span><span class="p">,</span> <span class="mf">.25</span><span class="p">,</span> <span class="mf">.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">}</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>DefBuckets是默认的直方图存储桶。定制了默认存储桶，以广泛地衡量网络服务的响应时间（以秒为单位）。但是，很可能需要您定义针对用例定制的存储桶。</p>
<h2 id="func-buildfqname">func BuildFQName<a hidden class="anchor" aria-hidden="true" href="#func-buildfqname">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BuildFQName</span><span class="p">(</span><span class="nx">namespace</span><span class="p">,</span> <span class="nx">subsystem</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><p>BuildFQName通过“_”连接给定的三个名称组件。空名称组件将被忽略。如果name参数本身为空，则无论如何都将返回一个空字符串。该库中包含的Metric实现在内部使用此函数从其Opts中的名称组件生成完全限定的Metric名称。库的用户仅在实现自己的Metric或直接实例化Desc（使用NewDesc）时才需要此功能。</p>
<h2 id="func-describebycollect">func DescribeByCollect<a hidden class="anchor" aria-hidden="true" href="#func-describebycollect">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">DescribeByCollect</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Collector</span><span class="p">,</span> <span class="nx">descs</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>DescribeByCollect是实现自定义收集器的Describe方法的助手。它从提供的收集器收集度量，并将其描述符发送到提供的通道。</p>
<p>如果收集器在其整个生命周期内收集相同的指标，则其Describe方法可以简单地实现为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">customCollector</span><span class="p">)</span> <span class="nf">Describe</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">DescribeByCollect</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">ch</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>但是，如果收集的指标在收集器的整个生命周期中以其描述符组合的集合也发生变化的方式动态变化，则这将不起作用。然后，快捷方式实现将违反Describe方法的约定。如果收集器有时根本不收集任何指标（例如，CounterVec，GaugeVec等向量，它们仅在访问具有完全指定的标签集的指标后才收集指标），它甚至可能注册为未经检查的收集器（参见。Registerer接口的Register方法）。因此，如果您确定要履行合同，请仅使用Describe的此快捷方式实现。</p>
<p>收集器示例演示了DescribeByCollect的用法。</p>
<h2 id="func-exponentialbuckets">func ExponentialBuckets<a hidden class="anchor" aria-hidden="true" href="#func-exponentialbuckets">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ExponentialBuckets</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">factor</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">float64</span>
</code></pre></td></tr></table>
</div>
</div><p>ExponentialBuckets创建“计数”存储桶，其中最低存储桶的上限为“start”，随后每个存储桶的上限为“factor”乘以上一个存储桶的上限。最终的+ Inf存储桶不计算在内，也不包含在返回的切片中。返回的切片应用于HistogramOpts的Buckets字段。</p>
<p>如果&rsquo;count&rsquo;为0或负数，如果&rsquo;start&rsquo;为0或负数，或者&rsquo;factor&rsquo;小于或等于1，则函数将发生错误。</p>
<h2 id="func-linearbuckets">func LinearBuckets<a hidden class="anchor" aria-hidden="true" href="#func-linearbuckets">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">LinearBuckets</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">width</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">float64</span>
</code></pre></td></tr></table>
</div>
</div><p>LinearBuckets创建“计数”存储区，每个“宽度”宽，其中最低存储区的上限为“start”。最终的+ Inf存储桶不计算在内，也不包含在返回的切片中。返回的切片应用于HistogramOpts的Buckets字段。</p>
<p>如果“count”为零或负数，该函数将出现panic。</p>
<h2 id="func-mustregister">func MustRegister<a hidden class="anchor" aria-hidden="true" href="#func-mustregister">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">MustRegister</span><span class="p">(</span><span class="nx">cs</span> <span class="o">...</span><span class="nx">Collector</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>MustRegister会使用DefaultRegisterer注册提供的收集器，如果发生任何错误，则会出现恐慌。</p>
<p>MustRegister是DefaultRegisterer.MustRegister（cs &hellip;）的快捷方式。请参阅此处以获取更多详细信息。</p>
<p>func Register</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Register</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Collector</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>Register向DefaultRegisterer注册提供的收集器。</p>
<p>Register是DefaultRegisterer.Register(c)的快捷方式。</p>
<p>例子</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Imagine you have a worker pool and want to count the tasks completed.
</span><span class="c1"></span><span class="nx">taskCounter</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewCounter</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">{</span>
	<span class="nx">Subsystem</span><span class="p">:</span> <span class="s">&#34;worker_pool&#34;</span><span class="p">,</span>
	<span class="nx">Name</span><span class="p">:</span>      <span class="s">&#34;completed_tasks_total&#34;</span><span class="p">,</span>
	<span class="nx">Help</span><span class="p">:</span>      <span class="s">&#34;Total number of tasks completed.&#34;</span><span class="p">,</span>
<span class="p">})</span>
<span class="c1">// This will register fine.
</span><span class="c1"></span><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">taskCounter</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounter registered.&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Don&#39;t forget to tell the HTTP server about the Prometheus handler.
</span><span class="c1">// (In a real program, you still need to start the HTTP server...)
</span><span class="c1"></span><span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/metrics&#34;</span><span class="p">,</span> <span class="nx">promhttp</span><span class="p">.</span><span class="nf">Handler</span><span class="p">())</span>

<span class="c1">// Now you can start workers and give every one of them a pointer to
</span><span class="c1">// taskCounter and let it increment it whenever it completes a task.
</span><span class="c1"></span><span class="nx">taskCounter</span><span class="p">.</span><span class="nf">Inc</span><span class="p">()</span> <span class="c1">// This has to happen somewhere in the worker code.
</span><span class="c1"></span>
<span class="c1">// But wait, you want to see how individual workers perform. So you need
</span><span class="c1">// a vector of counters, with one element for each worker.
</span><span class="c1"></span><span class="nx">taskCounterVec</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewCounterVec</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">{</span>
		<span class="nx">Subsystem</span><span class="p">:</span> <span class="s">&#34;worker_pool&#34;</span><span class="p">,</span>
		<span class="nx">Name</span><span class="p">:</span>      <span class="s">&#34;completed_tasks_total&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>      <span class="s">&#34;Total number of tasks completed.&#34;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;worker_id&#34;</span><span class="p">},</span>
<span class="p">)</span>

<span class="c1">// Registering will fail because we already have a metric of that name.
</span><span class="c1"></span><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">taskCounterVec</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounterVec not registered:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounterVec registered.&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// To fix, first unregister the old taskCounter.
</span><span class="c1"></span><span class="k">if</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">Unregister</span><span class="p">(</span><span class="nx">taskCounter</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounter unregistered.&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Try registering taskCounterVec again.
</span><span class="c1"></span><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">taskCounterVec</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounterVec not registered:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounterVec registered.&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Bummer! Still doesn&#39;t work.
</span><span class="c1"></span>
<span class="c1">// Prometheus will not allow you to ever export metrics with
</span><span class="c1">// inconsistent help strings or label names. After unregistering, the
</span><span class="c1">// unregistered metrics will cease to show up in the /metrics HTTP
</span><span class="c1">// response, but the registry still remembers that those metrics had
</span><span class="c1">// been exported before. For this example, we will now choose a
</span><span class="c1">// different name. (In a real program, you would obviously not export
</span><span class="c1">// the obsolete metric in the first place.)
</span><span class="c1"></span><span class="nx">taskCounterVec</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewCounterVec</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">{</span>
		<span class="nx">Subsystem</span><span class="p">:</span> <span class="s">&#34;worker_pool&#34;</span><span class="p">,</span>
		<span class="nx">Name</span><span class="p">:</span>      <span class="s">&#34;completed_tasks_by_id&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>      <span class="s">&#34;Total number of tasks completed.&#34;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;worker_id&#34;</span><span class="p">},</span>
<span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">taskCounterVec</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounterVec not registered:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounterVec registered.&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Finally it worked!
</span><span class="c1"></span>
<span class="c1">// The workers have to tell taskCounterVec their id to increment the
</span><span class="c1">// right element in the metric vector.
</span><span class="c1"></span><span class="nx">taskCounterVec</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;42&#34;</span><span class="p">).</span><span class="nf">Inc</span><span class="p">()</span> <span class="c1">// Code from worker 42.
</span><span class="c1"></span>
<span class="c1">// Each worker could also keep a reference to their own counter element
</span><span class="c1">// around. Pick the counter at initialization time of the worker.
</span><span class="c1"></span><span class="nx">myCounter</span> <span class="o">:=</span> <span class="nx">taskCounterVec</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;42&#34;</span><span class="p">)</span> <span class="c1">// From worker 42 initialization code.
</span><span class="c1"></span><span class="nx">myCounter</span><span class="p">.</span><span class="nf">Inc</span><span class="p">()</span>                                   <span class="c1">// Somewhere in the code of that worker.
</span><span class="c1"></span>
<span class="c1">// Note that something like WithLabelValues(&#34;42&#34;, &#34;spurious arg&#34;) would
</span><span class="c1">// panic (because you have provided too many label values). If you want
</span><span class="c1">// to get an error instead, use GetMetricWithLabelValues(...) instead.
</span><span class="c1"></span><span class="nx">notMyCounter</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">taskCounterVec</span><span class="p">.</span><span class="nf">GetMetricWithLabelValues</span><span class="p">(</span><span class="s">&#34;42&#34;</span><span class="p">,</span> <span class="s">&#34;spurious arg&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Worker initialization failed:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">if</span> <span class="nx">notMyCounter</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;notMyCounter is nil.&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// A different (and somewhat tricky) approach is to use
</span><span class="c1">// ConstLabels. ConstLabels are pairs of label names and label values
</span><span class="c1">// that never change. Each worker creates and registers an own Counter
</span><span class="c1">// instance where the only difference is in the value of the
</span><span class="c1">// ConstLabels. Those Counters can all be registered because the
</span><span class="c1">// different ConstLabel values guarantee that each worker will increment
</span><span class="c1">// a different Counter metric.
</span><span class="c1"></span><span class="nx">counterOpts</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">{</span>
	<span class="nx">Subsystem</span><span class="p">:</span>   <span class="s">&#34;worker_pool&#34;</span><span class="p">,</span>
	<span class="nx">Name</span><span class="p">:</span>        <span class="s">&#34;completed_tasks&#34;</span><span class="p">,</span>
	<span class="nx">Help</span><span class="p">:</span>        <span class="s">&#34;Total number of tasks completed.&#34;</span><span class="p">,</span>
	<span class="nx">ConstLabels</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;worker_id&#34;</span><span class="p">:</span> <span class="s">&#34;42&#34;</span><span class="p">},</span>
<span class="p">}</span>
<span class="nx">taskCounterForWorker42</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewCounter</span><span class="p">(</span><span class="nx">counterOpts</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">taskCounterForWorker42</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounterVForWorker42 not registered:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounterForWorker42 registered.&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Obviously, in real code, taskCounterForWorker42 would be a member
</span><span class="c1">// variable of a worker struct, and the &#34;42&#34; would be retrieved with a
</span><span class="c1">// GetId() method or something. The Counter would be created and
</span><span class="c1">// registered in the initialization code of the worker.
</span><span class="c1"></span>
<span class="c1">// For the creation of the next Counter, we can recycle
</span><span class="c1">// counterOpts. Just change the ConstLabels.
</span><span class="c1"></span><span class="nx">counterOpts</span><span class="p">.</span><span class="nx">ConstLabels</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;worker_id&#34;</span><span class="p">:</span> <span class="s">&#34;2001&#34;</span><span class="p">}</span>
<span class="nx">taskCounterForWorker2001</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewCounter</span><span class="p">(</span><span class="nx">counterOpts</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">taskCounterForWorker2001</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounterVForWorker2001 not registered:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounterForWorker2001 registered.&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">taskCounterForWorker2001</span><span class="p">.</span><span class="nf">Inc</span><span class="p">()</span>
<span class="nx">taskCounterForWorker42</span><span class="p">.</span><span class="nf">Inc</span><span class="p">()</span>
<span class="nx">taskCounterForWorker2001</span><span class="p">.</span><span class="nf">Inc</span><span class="p">()</span>

<span class="c1">// Yet another approach would be to turn the workers themselves into
</span><span class="c1">// Collectors and register them. See the Collector example for details.
</span></code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">taskCounter</span> <span class="nx">registered</span><span class="p">.</span>
<span class="nx">taskCounterVec</span> <span class="nx">not</span> <span class="nx">registered</span><span class="p">:</span> <span class="nx">a</span> <span class="nx">previously</span> <span class="nx">registered</span> <span class="nx">descriptor</span> <span class="nx">with</span> <span class="nx">the</span> <span class="nx">same</span> <span class="nx">fully</span><span class="o">-</span><span class="nx">qualified</span> <span class="nx">name</span> <span class="nx">as</span> <span class="nx">Desc</span><span class="p">{</span><span class="nx">fqName</span><span class="p">:</span> <span class="s">&#34;worker_pool_completed_tasks_total&#34;</span><span class="p">,</span> <span class="nx">help</span><span class="p">:</span> <span class="s">&#34;Total number of tasks completed.&#34;</span><span class="p">,</span> <span class="nx">constLabels</span><span class="p">:</span> <span class="p">{},</span> <span class="nx">variableLabels</span><span class="p">:</span> <span class="p">[</span><span class="nx">worker_id</span><span class="p">]}</span> <span class="nx">has</span> <span class="nx">different</span> <span class="nx">label</span> <span class="nx">names</span> <span class="nx">or</span> <span class="nx">a</span> <span class="nx">different</span> <span class="nx">help</span> <span class="kt">string</span>
<span class="nx">taskCounter</span> <span class="nx">unregistered</span><span class="p">.</span>
<span class="nx">taskCounterVec</span> <span class="nx">not</span> <span class="nx">registered</span><span class="p">:</span> <span class="nx">a</span> <span class="nx">previously</span> <span class="nx">registered</span> <span class="nx">descriptor</span> <span class="nx">with</span> <span class="nx">the</span> <span class="nx">same</span> <span class="nx">fully</span><span class="o">-</span><span class="nx">qualified</span> <span class="nx">name</span> <span class="nx">as</span> <span class="nx">Desc</span><span class="p">{</span><span class="nx">fqName</span><span class="p">:</span> <span class="s">&#34;worker_pool_completed_tasks_total&#34;</span><span class="p">,</span> <span class="nx">help</span><span class="p">:</span> <span class="s">&#34;Total number of tasks completed.&#34;</span><span class="p">,</span> <span class="nx">constLabels</span><span class="p">:</span> <span class="p">{},</span> <span class="nx">variableLabels</span><span class="p">:</span> <span class="p">[</span><span class="nx">worker_id</span><span class="p">]}</span> <span class="nx">has</span> <span class="nx">different</span> <span class="nx">label</span> <span class="nx">names</span> <span class="nx">or</span> <span class="nx">a</span> <span class="nx">different</span> <span class="nx">help</span> <span class="kt">string</span>
<span class="nx">taskCounterVec</span> <span class="nx">registered</span><span class="p">.</span>
<span class="nx">Worker</span> <span class="nx">initialization</span> <span class="nx">failed</span><span class="p">:</span> <span class="nx">inconsistent</span> <span class="nx">label</span> <span class="nx">cardinality</span><span class="p">:</span> <span class="nx">expected</span> <span class="mi">1</span> <span class="nx">label</span> <span class="nx">values</span> <span class="nx">but</span> <span class="nx">got</span> <span class="mi">2</span> <span class="nx">in</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;42&#34;</span><span class="p">,</span> <span class="s">&#34;spurious arg&#34;</span><span class="p">}</span>
<span class="nx">notMyCounter</span> <span class="nx">is</span> <span class="kc">nil</span><span class="p">.</span>
<span class="nx">taskCounterForWorker42</span> <span class="nx">registered</span><span class="p">.</span>
<span class="nx">taskCounterForWorker2001</span> <span class="nx">registered</span><span class="p">.</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-unregister">func Unregister<a hidden class="anchor" aria-hidden="true" href="#func-unregister">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Unregister</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Collector</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>Unregister将从DefaultRegisterer中删除提供的收集器的注册。</p>
<p>Unregister是DefaultRegisterer.Unregister(c)的快捷方式。</p>
<h2 id="func-writetotextfile">func WriteToTextfile<a hidden class="anchor" aria-hidden="true" href="#func-writetotextfile">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WriteToTextfile</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">g</span> <span class="nx">Gatherer</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>WriteToTextfile在提供的Gatherer上调用Gather，将结果编码为Prometheus文本格式，并将其写入临时文件。成功后，临时文件将重命名为提供的文件名。</p>
<p>这旨在与节点导出器的文本文件收集器一起使用。请注意，节点导出器期望文件名后缀为“ .prom”。</p>
<h2 id="type-alreadyregisterederror">type AlreadyRegisteredError<a hidden class="anchor" aria-hidden="true" href="#type-alreadyregisterederror">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">AlreadyRegisteredError</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ExistingCollector</span><span class="p">,</span> <span class="nx">NewCollector</span> <span class="nx">Collector</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果以前已经注册了要注册的收集器，或者之前已经注册了收集相同度量的其他收集器，则Register方法将返回AlreadyRegisteredError。在这种情况下，注册失败，但是您可以从错误类型中检测出发生了什么。该错误包含现有收集器和与现有收集器相等的（被拒绝）新收集器的字段。如示例所示，这可用于查找是否已注册了相等的收集器，然后切换到使用旧的收集器。</p>
<p>例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">reqCounter</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewCounter</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">{</span>
	<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;requests_total&#34;</span><span class="p">,</span>
	<span class="nx">Help</span><span class="p">:</span> <span class="s">&#34;The total number of requests served.&#34;</span><span class="p">,</span>
<span class="p">})</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">reqCounter</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">are</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">AlreadyRegisteredError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="c1">// A counter for that metric has been registered before.
</span><span class="c1"></span>		<span class="c1">// Use the old counter from now on.
</span><span class="c1"></span>		<span class="nx">reqCounter</span> <span class="p">=</span> <span class="nx">are</span><span class="p">.</span><span class="nx">ExistingCollector</span><span class="p">.(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Counter</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// Something else went wrong!
</span><span class="c1"></span>		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="nx">reqCounter</span><span class="p">.</span><span class="nf">Inc</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="func-alreadyregisterederror-error">func (AlreadyRegisteredError) Error<a hidden class="anchor" aria-hidden="true" href="#func-alreadyregisterederror-error">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">err</span> <span class="nx">AlreadyRegisteredError</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="type-collector">type Collector<a hidden class="anchor" aria-hidden="true" href="#type-collector">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Collector</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Describe sends the super-set of all possible descriptors of metrics
</span><span class="c1"></span>	<span class="c1">// collected by this Collector to the provided channel and returns once
</span><span class="c1"></span>	<span class="c1">// the last descriptor has been sent. The sent descriptors fulfill the
</span><span class="c1"></span>	<span class="c1">// consistency and uniqueness requirements described in the Desc
</span><span class="c1"></span>	<span class="c1">// documentation.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// It is valid if one and the same Collector sends duplicate
</span><span class="c1"></span>	<span class="c1">// descriptors. Those duplicates are simply ignored. However, two
</span><span class="c1"></span>	<span class="c1">// different Collectors must not send duplicate descriptors.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Sending no descriptor at all marks the Collector as “unchecked”,
</span><span class="c1"></span>	<span class="c1">// i.e. no checks will be performed at registration time, and the
</span><span class="c1"></span>	<span class="c1">// Collector may yield any Metric it sees fit in its Collect method.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This method idempotently sends the same descriptors throughout the
</span><span class="c1"></span>	<span class="c1">// lifetime of the Collector. It may be called concurrently and
</span><span class="c1"></span>	<span class="c1">// therefore must be implemented in a concurrency safe way.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If a Collector encounters an error while executing this method, it
</span><span class="c1"></span>	<span class="c1">// must send an invalid descriptor (created with NewInvalidDesc) to
</span><span class="c1"></span>	<span class="c1">// signal the error to the registry.
</span><span class="c1"></span>	<span class="nf">Describe</span><span class="p">(</span><span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">)</span>
	<span class="c1">// Collect is called by the Prometheus registry when collecting
</span><span class="c1"></span>	<span class="c1">// metrics. The implementation sends each collected metric via the
</span><span class="c1"></span>	<span class="c1">// provided channel and returns once the last metric has been sent. The
</span><span class="c1"></span>	<span class="c1">// descriptor of each sent metric is one of those returned by Describe
</span><span class="c1"></span>	<span class="c1">// (unless the Collector is unchecked, see above). Returned metrics that
</span><span class="c1"></span>	<span class="c1">// share the same descriptor must differ in their variable label
</span><span class="c1"></span>	<span class="c1">// values.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This method may be called concurrently and must therefore be
</span><span class="c1"></span>	<span class="c1">// implemented in a concurrency safe way. Blocking occurs at the expense
</span><span class="c1"></span>	<span class="c1">// of total performance of rendering all registered metrics. Ideally,
</span><span class="c1"></span>	<span class="c1">// Collector implementations support concurrent readers.
</span><span class="c1"></span>	<span class="nf">Collect</span><span class="p">(</span><span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">Metric</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>收集器是由Prometheus可以用来收集Metric的任何东西实现的接口。必须为收集器注册收集器。请参阅Registerer.Register。</p>
<p>此程序包提供的库存指标（量规，计数器，汇总，直方图，无类型）也是收集器（仅收集一个指标，即本身）。但是，收集器的实现者可以以协调的方式收集多个指标和/或即时创建指标。已经在该库中实现的收集器的示例是度量向量（即，同一Metric但具有不同标签值的多个实例的集合），例如GaugeVec或SummaryVec，以及ExpvarCollector。</p>
<p>例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">prometheus_test</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/prometheus/client_golang/prometheus&#34;</span>
	<span class="s">&#34;github.com/prometheus/client_golang/prometheus/promhttp&#34;</span>
<span class="p">)</span>

<span class="c1">// ClusterManager is an example for a system that might have been built without
</span><span class="c1">// Prometheus in mind. It models a central manager of jobs running in a
</span><span class="c1">// cluster. Thus, we implement a custom Collector called
</span><span class="c1">// ClusterManagerCollector, which collects information from a ClusterManager
</span><span class="c1">// using its provided methods and turns them into Prometheus Metrics for
</span><span class="c1">// collection.
</span><span class="c1">//
</span><span class="c1">// An additional challenge is that multiple instances of the ClusterManager are
</span><span class="c1">// run within the same binary, each in charge of a different zone. We need to
</span><span class="c1">// make use of wrapping Registerers to be able to register each
</span><span class="c1">// ClusterManagerCollector instance with Prometheus.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ClusterManager</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Zone</span> <span class="kt">string</span>
	<span class="c1">// Contains many more fields not listed in this example.
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// ReallyExpensiveAssessmentOfTheSystemState is a mock for the data gathering a
</span><span class="c1">// real cluster manager would have to do. Since it may actually be really
</span><span class="c1">// expensive, it must only be called once per collection. This implementation,
</span><span class="c1">// obviously, only returns some made-up data.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ClusterManager</span><span class="p">)</span> <span class="nf">ReallyExpensiveAssessmentOfTheSystemState</span><span class="p">()</span> <span class="p">(</span>
	<span class="nx">oomCountByHost</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">ramUsageByHost</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">float64</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Just example fake data.
</span><span class="c1"></span>	<span class="nx">oomCountByHost</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
		<span class="s">&#34;foo.example.org&#34;</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span>
		<span class="s">&#34;bar.example.org&#34;</span><span class="p">:</span> <span class="mi">2001</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">ramUsageByHost</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">float64</span><span class="p">{</span>
		<span class="s">&#34;foo.example.org&#34;</span><span class="p">:</span> <span class="mf">6.023e23</span><span class="p">,</span>
		<span class="s">&#34;bar.example.org&#34;</span><span class="p">:</span> <span class="mf">3.14</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// ClusterManagerCollector implements the Collector interface.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ClusterManagerCollector</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ClusterManager</span> <span class="o">*</span><span class="nx">ClusterManager</span>
<span class="p">}</span>

<span class="c1">// Descriptors used by the ClusterManagerCollector below.
</span><span class="c1"></span><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">oomCountDesc</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewDesc</span><span class="p">(</span>
		<span class="s">&#34;clustermanager_oom_crashes_total&#34;</span><span class="p">,</span>
		<span class="s">&#34;Number of OOM crashes.&#34;</span><span class="p">,</span>
		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;host&#34;</span><span class="p">},</span> <span class="kc">nil</span><span class="p">,</span>
	<span class="p">)</span>
	<span class="nx">ramUsageDesc</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewDesc</span><span class="p">(</span>
		<span class="s">&#34;clustermanager_ram_usage_bytes&#34;</span><span class="p">,</span>
		<span class="s">&#34;RAM usage as reported to the cluster manager.&#34;</span><span class="p">,</span>
		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;host&#34;</span><span class="p">},</span> <span class="kc">nil</span><span class="p">,</span>
	<span class="p">)</span>
<span class="p">)</span>

<span class="c1">// Describe is implemented with DescribeByCollect. That&#39;s possible because the
</span><span class="c1">// Collect method will always return the same two metrics with the same two
</span><span class="c1">// descriptors.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="nx">ClusterManagerCollector</span><span class="p">)</span> <span class="nf">Describe</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Desc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nf">DescribeByCollect</span><span class="p">(</span><span class="nx">cc</span><span class="p">,</span> <span class="nx">ch</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Collect first triggers the ReallyExpensiveAssessmentOfTheSystemState. Then it
</span><span class="c1">// creates constant metrics for each host on the fly based on the returned data.
</span><span class="c1">//
</span><span class="c1">// Note that Collect could be called concurrently, so we depend on
</span><span class="c1">// ReallyExpensiveAssessmentOfTheSystemState to be concurrency-safe.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="nx">ClusterManagerCollector</span><span class="p">)</span> <span class="nf">Collect</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Metric</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">oomCountByHost</span><span class="p">,</span> <span class="nx">ramUsageByHost</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">ClusterManager</span><span class="p">.</span><span class="nf">ReallyExpensiveAssessmentOfTheSystemState</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">host</span><span class="p">,</span> <span class="nx">oomCount</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">oomCountByHost</span> <span class="p">{</span>
		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustNewConstMetric</span><span class="p">(</span>
			<span class="nx">oomCountDesc</span><span class="p">,</span>
			<span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterValue</span><span class="p">,</span>
			<span class="nb">float64</span><span class="p">(</span><span class="nx">oomCount</span><span class="p">),</span>
			<span class="nx">host</span><span class="p">,</span>
		<span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">host</span><span class="p">,</span> <span class="nx">ramUsage</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ramUsageByHost</span> <span class="p">{</span>
		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustNewConstMetric</span><span class="p">(</span>
			<span class="nx">ramUsageDesc</span><span class="p">,</span>
			<span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeValue</span><span class="p">,</span>
			<span class="nx">ramUsage</span><span class="p">,</span>
			<span class="nx">host</span><span class="p">,</span>
		<span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// NewClusterManager first creates a Prometheus-ignorant ClusterManager
</span><span class="c1">// instance. Then, it creates a ClusterManagerCollector for the just created
</span><span class="c1">// ClusterManager. Finally, it registers the ClusterManagerCollector with a
</span><span class="c1">// wrapping Registerer that adds the zone as a label. In this way, the metrics
</span><span class="c1">// collected by different ClusterManagerCollectors do not collide.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewClusterManager</span><span class="p">(</span><span class="nx">zone</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">reg</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Registerer</span><span class="p">)</span> <span class="o">*</span><span class="nx">ClusterManager</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ClusterManager</span><span class="p">{</span>
		<span class="nx">Zone</span><span class="p">:</span> <span class="nx">zone</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">cc</span> <span class="o">:=</span> <span class="nx">ClusterManagerCollector</span><span class="p">{</span><span class="nx">ClusterManager</span><span class="p">:</span> <span class="nx">c</span><span class="p">}</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nf">WrapRegistererWith</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;zone&#34;</span><span class="p">:</span> <span class="nx">zone</span><span class="p">},</span> <span class="nx">reg</span><span class="p">).</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">cc</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ExampleCollector</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Since we are dealing with custom Collector implementations, it might
</span><span class="c1"></span>	<span class="c1">// be a good idea to try it out with a pedantic registry.
</span><span class="c1"></span>	<span class="nx">reg</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewPedanticRegistry</span><span class="p">()</span>

	<span class="c1">// Construct cluster managers. In real code, we would assign them to
</span><span class="c1"></span>	<span class="c1">// variables to then do something with them.
</span><span class="c1"></span>	<span class="nf">NewClusterManager</span><span class="p">(</span><span class="s">&#34;db&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">)</span>
	<span class="nf">NewClusterManager</span><span class="p">(</span><span class="s">&#34;ca&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">)</span>

	<span class="c1">// Add the standard process and Go metrics to the custom registry.
</span><span class="c1"></span>	<span class="nx">reg</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span>
		<span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewProcessCollector</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">ProcessCollectorOpts</span><span class="p">{}),</span>
		<span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewGoCollector</span><span class="p">(),</span>
	<span class="p">)</span>

	<span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/metrics&#34;</span><span class="p">,</span> <span class="nx">promhttp</span><span class="p">.</span><span class="nf">HandlerFor</span><span class="p">(</span><span class="nx">reg</span><span class="p">,</span> <span class="nx">promhttp</span><span class="p">.</span><span class="nx">HandlerOpts</span><span class="p">{}))</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="func-newbuildinfocollector">func NewBuildInfoCollector<a hidden class="anchor" aria-hidden="true" href="#func-newbuildinfocollector">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewBuildInfoCollector</span><span class="p">()</span> <span class="nx">Collector</span>
</code></pre></td></tr></table>
</div>
</div><p>NewBuildInfoCollector返回一个收集器，该收集器收集具有恒定值1和三个标签“ path”，“version”和“checksum”的单个度量“ go_build_info”。它们的标签值分别包含主模块路径，版本和校验和。如果二进制文件是通过Go模块支持并从从源存储库（而不是本地文件系统）检索的源代码构建的，则标签将只有有意义的值。通常，这可以通过从GOPATH外部进行构建来完成，并指定主软件包的完整地址，例如“ GO111MODULE = on go run github.com/prometheus/client_golang/examples/random”。如果构建时不支持Go模块，则所有标签值将为“未知”。如果使用Go模块支持构建，但使用本地文件系统的源代码，“path”将被适当设置，但“checksum”将为空，“version”将为“（devel）”。</p>
<p>该收集器仅将构建信息用于主模块。有关模块依赖项的收集器示例，请参见 <a href="https://github.com/povilasv/prommod">https://github.com/povilasv/prommod</a>。</p>
<h3 id="func-newexpvarcollector">func NewExpvarCollector<a hidden class="anchor" aria-hidden="true" href="#func-newexpvarcollector">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewExpvarCollector</span><span class="p">(</span><span class="nx">exports</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">Desc</span><span class="p">)</span> <span class="nx">Collector</span>
</code></pre></td></tr></table>
</div>
</div><p>NewExpvarCollector返回一个新分配的expvar收集器，该收集器仍必须在Prometheus注册表中进行注册。</p>
<p>expvar收集器从expvar接口收集指标。它提供了一种快速的方法来公开已经通过expvar导出为Prometheus指标的数值。请注意，expvar和Prometheus的数据模型本质上是不同的，并且expvar Collector本质上比本地Prometheus指标慢。因此，expvar Collector可能非常适合进行实验和原型制作，但是您应该认真考虑更直接地实现PrometheusMetric以监视生产系统。</p>
<p>exports map具有以下含义：</p>
<p>映射中的键对应于expvar键，即对于要导出为PrometheusMetric的每个expvar键，在导出映射中都需要一个条目。映射到每个键的描述符描述了如何导出expvar值。它定义PrometheusMetric的名称和帮助字符串，以替代expvar值。该类型将始终为“无类型”。</p>
<p>对于没有变量标签的描述符，expvar值必须是数字或布尔值。然后将数字直接导出为Prometheus样本值。（对于布尔值，“false”表示0，“ true”表示1）。不是数字或布尔值的Expvar值将被静默忽略。</p>
<p>如果描述符具有一个变量标签，则expvar值必须是一个expvar映射。expvar映射中的键成为一个Prometheus标签的各种值。如上所述，expvar映射中的值必须再次为数字或布尔值。</p>
<p>对于具有多个变量标签的描述符，expvar必须是嵌套的expvar映射，即，最顶部映射的值再次是映射等，直到达到与标签数量相对应的深度。该结构的叶子必须是上面的数字或布尔值，才能用作样本值。</p>
<p>任何不适合上述方案的内容都会被忽略。</p>
<p>例子</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">expvarCollector</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewExpvarCollector</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Desc</span><span class="p">{</span>
	<span class="s">&#34;memstats&#34;</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewDesc</span><span class="p">(</span>
		<span class="s">&#34;expvar_memstats&#34;</span><span class="p">,</span>
		<span class="s">&#34;All numeric memstats as one metric family. Not a good role-model, actually... ;-)&#34;</span><span class="p">,</span>
		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;type&#34;</span><span class="p">},</span> <span class="kc">nil</span><span class="p">,</span>
	<span class="p">),</span>
	<span class="s">&#34;lone-int&#34;</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewDesc</span><span class="p">(</span>
		<span class="s">&#34;expvar_lone_int&#34;</span><span class="p">,</span>
		<span class="s">&#34;Just an expvar int as an example.&#34;</span><span class="p">,</span>
		<span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span>
	<span class="p">),</span>
	<span class="s">&#34;http-request-map&#34;</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewDesc</span><span class="p">(</span>
		<span class="s">&#34;expvar_http_request_total&#34;</span><span class="p">,</span>
		<span class="s">&#34;How many http requests processed, partitioned by status code and http method.&#34;</span><span class="p">,</span>
		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;code&#34;</span><span class="p">,</span> <span class="s">&#34;method&#34;</span><span class="p">},</span> <span class="kc">nil</span><span class="p">,</span>
	<span class="p">),</span>
<span class="p">})</span>
<span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">expvarCollector</span><span class="p">)</span>

<span class="c1">// The Prometheus part is done here. But to show that this example is
</span><span class="c1">// doing anything, we have to manually export something via expvar.  In
</span><span class="c1">// real-life use-cases, some library would already have exported via
</span><span class="c1">// expvar what we want to re-export as Prometheus metrics.
</span><span class="c1"></span><span class="nx">expvar</span><span class="p">.</span><span class="nf">NewInt</span><span class="p">(</span><span class="s">&#34;lone-int&#34;</span><span class="p">).</span><span class="nf">Set</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="nx">expvarMap</span> <span class="o">:=</span> <span class="nx">expvar</span><span class="p">.</span><span class="nf">NewMap</span><span class="p">(</span><span class="s">&#34;http-request-map&#34;</span><span class="p">)</span>
<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">expvarMap1</span><span class="p">,</span> <span class="nx">expvarMap2</span>                             <span class="nx">expvar</span><span class="p">.</span><span class="nx">Map</span>
	<span class="nx">expvarInt11</span><span class="p">,</span> <span class="nx">expvarInt12</span><span class="p">,</span> <span class="nx">expvarInt21</span><span class="p">,</span> <span class="nx">expvarInt22</span> <span class="nx">expvar</span><span class="p">.</span><span class="nx">Int</span>
<span class="p">)</span>
<span class="nx">expvarMap1</span><span class="p">.</span><span class="nf">Init</span><span class="p">()</span>
<span class="nx">expvarMap2</span><span class="p">.</span><span class="nf">Init</span><span class="p">()</span>
<span class="nx">expvarInt11</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="nx">expvarInt12</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>
<span class="nx">expvarInt21</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
<span class="nx">expvarInt22</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="mi">212</span><span class="p">)</span>
<span class="nx">expvarMap1</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;POST&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">expvarInt11</span><span class="p">)</span>
<span class="nx">expvarMap1</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">expvarInt12</span><span class="p">)</span>
<span class="nx">expvarMap2</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;POST&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">expvarInt21</span><span class="p">)</span>
<span class="nx">expvarMap2</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">expvarInt22</span><span class="p">)</span>
<span class="nx">expvarMap</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;404&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">expvarMap1</span><span class="p">)</span>
<span class="nx">expvarMap</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;200&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">expvarMap2</span><span class="p">)</span>
<span class="c1">// Results in the following expvar map:
</span><span class="c1">// &#34;http-request-count&#34;: {&#34;200&#34;: {&#34;POST&#34;: 11, &#34;GET&#34;: 212}, &#34;404&#34;: {&#34;POST&#34;: 3, &#34;GET&#34;: 13}}
</span><span class="c1"></span>
<span class="c1">// Let&#39;s see what the scrape would yield, but exclude the memstats metrics.
</span><span class="c1"></span><span class="nx">metricStrings</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
<span class="nx">metric</span> <span class="o">:=</span> <span class="nx">dto</span><span class="p">.</span><span class="nx">Metric</span><span class="p">{}</span>
<span class="nx">metricChan</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Metric</span><span class="p">)</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">expvarCollector</span><span class="p">.</span><span class="nf">Collect</span><span class="p">(</span><span class="nx">metricChan</span><span class="p">)</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">metricChan</span><span class="p">)</span>
<span class="p">}()</span>
<span class="k">for</span> <span class="nx">m</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">metricChan</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nf">Desc</span><span class="p">().</span><span class="nf">String</span><span class="p">(),</span> <span class="s">&#34;expvar_memstats&#34;</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">metric</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
		<span class="nx">m</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">metric</span><span class="p">)</span>
		<span class="nx">metricStrings</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">metricStrings</span><span class="p">,</span> <span class="nx">metric</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="nx">sort</span><span class="p">.</span><span class="nf">Strings</span><span class="p">(</span><span class="nx">metricStrings</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">s</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">metricStrings</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">TrimRight</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">label</span><span class="p">:&lt;</span><span class="nx">name</span><span class="p">:</span><span class="s">&#34;code&#34;</span> <span class="nx">value</span><span class="p">:</span><span class="s">&#34;200&#34;</span> <span class="p">&gt;</span> <span class="nx">label</span><span class="p">:&lt;</span><span class="nx">name</span><span class="p">:</span><span class="s">&#34;method&#34;</span> <span class="nx">value</span><span class="p">:</span><span class="s">&#34;GET&#34;</span> <span class="p">&gt;</span> <span class="nx">untyped</span><span class="p">:&lt;</span><span class="nx">value</span><span class="p">:</span><span class="mi">212</span> <span class="p">&gt;</span>
<span class="nx">label</span><span class="p">:&lt;</span><span class="nx">name</span><span class="p">:</span><span class="s">&#34;code&#34;</span> <span class="nx">value</span><span class="p">:</span><span class="s">&#34;200&#34;</span> <span class="p">&gt;</span> <span class="nx">label</span><span class="p">:&lt;</span><span class="nx">name</span><span class="p">:</span><span class="s">&#34;method&#34;</span> <span class="nx">value</span><span class="p">:</span><span class="s">&#34;POST&#34;</span> <span class="p">&gt;</span> <span class="nx">untyped</span><span class="p">:&lt;</span><span class="nx">value</span><span class="p">:</span><span class="mi">11</span> <span class="p">&gt;</span>
<span class="nx">label</span><span class="p">:&lt;</span><span class="nx">name</span><span class="p">:</span><span class="s">&#34;code&#34;</span> <span class="nx">value</span><span class="p">:</span><span class="s">&#34;404&#34;</span> <span class="p">&gt;</span> <span class="nx">label</span><span class="p">:&lt;</span><span class="nx">name</span><span class="p">:</span><span class="s">&#34;method&#34;</span> <span class="nx">value</span><span class="p">:</span><span class="s">&#34;GET&#34;</span> <span class="p">&gt;</span> <span class="nx">untyped</span><span class="p">:&lt;</span><span class="nx">value</span><span class="p">:</span><span class="mi">13</span> <span class="p">&gt;</span>
<span class="nx">label</span><span class="p">:&lt;</span><span class="nx">name</span><span class="p">:</span><span class="s">&#34;code&#34;</span> <span class="nx">value</span><span class="p">:</span><span class="s">&#34;404&#34;</span> <span class="p">&gt;</span> <span class="nx">label</span><span class="p">:&lt;</span><span class="nx">name</span><span class="p">:</span><span class="s">&#34;method&#34;</span> <span class="nx">value</span><span class="p">:</span><span class="s">&#34;POST&#34;</span> <span class="p">&gt;</span> <span class="nx">untyped</span><span class="p">:&lt;</span><span class="nx">value</span><span class="p">:</span><span class="mi">3</span> <span class="p">&gt;</span>
<span class="nx">untyped</span><span class="p">:&lt;</span><span class="nx">value</span><span class="p">:</span><span class="mi">42</span> <span class="p">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="func-newgocollector">func NewGoCollector<a hidden class="anchor" aria-hidden="true" href="#func-newgocollector">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewGoCollector</span><span class="p">()</span> <span class="nx">Collector</span>
</code></pre></td></tr></table>
</div>
</div><p>NewGoCollector返回一个收集器，该收集器导出有关当前Go流程的指标。这包括内存统计信息。要收集这些内容，将调用runtime.ReadMemStats。这需要“停止世界”，通常仅在垃圾回收（GC）中发生。在决定是否使用Go收集器时，请考虑以下含义：</p>
<p>1.停止世界对性能的影响越重要，收集指标的频率就越高。但是，使用Go1.9或更高版本时，每个指标收集的世界停止时间非常短（〜25µs），因此对性能的影响仅在极少数情况下才重要。但是，对于较旧的Go版本，“停下世界”的持续时间取决于堆的大小，并且可能相当长（根据<a href="https://go-review.googlesource.com/c/go/+/%EF%BC%8C%E7%BA%A6%E4%B8%BA1.7">https://go-review.googlesource.com/c/go/+/，约为1.7</a> ms / GiB 34937）。</p>
<p>2.在进行中的GC期间，没有其他事情可以阻止世界。因此，如果指标收集恰好与GC一致，则只有在GC完成后才能完成。通常，GC足够快，不会引起问题。但是，对于非常大的堆，GC可能需要花费几秒钟的时间，这足以在常规设置中引起scrape超时。为避免此问题，如果runtime.ReadMemStats花费的时间超过1s，则Go收集器将使用先前集合中的memstats。但是，如果以前没有收集过memstats，或者它们的收集时间超过5m，则收集将阻塞，直到runtime.ReadMemStats成功。（该问题可能会在Go1.13中解决，有关相关的Go问题，请参见<a href="https://github.com/golang/go/issues/19812">https://github.com/golang/go/issues/19812</a>。）</p>
<h3 id="func-newprocesscollector">func NewProcessCollector<a hidden class="anchor" aria-hidden="true" href="#func-newprocesscollector">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewProcessCollector</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">ProcessCollectorOpts</span><span class="p">)</span> <span class="nx">Collector</span>
</code></pre></td></tr></table>
</div>
</div><p>NewProcessCollector返回一个收集器，该收集器导出过程度量的当前状态，包括CPU，内存和文件描述符的使用情况以及过程开始时间。详细行为由提供的ProcessCollectorOpts定义。ProcessCollectorOpts的零值将为当前进程创建一个收集器，该收集器具有空的名称空间字符串，并且没有错误报告。</p>
<p>收集器仅适用于具有Linux样式proc文件系统的操作系统以及Microsoft Windows。在其他操作系统上，它将不收集任何指标。</p>
<h2 id="type-counter">type Counter<a hidden class="anchor" aria-hidden="true" href="#type-counter">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Counter</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Metric</span>
	<span class="nx">Collector</span>

	<span class="c1">// Inc increments the counter by 1. Use Add to increment it by arbitrary
</span><span class="c1"></span>	<span class="c1">// non-negative values.
</span><span class="c1"></span>	<span class="nf">Inc</span><span class="p">()</span>
	<span class="c1">// Add adds the given value to the counter. It panics if the value is &lt;
</span><span class="c1"></span>	<span class="c1">// 0.
</span><span class="c1"></span>	<span class="nf">Add</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>计数器是一种Metric，它表示只会递增的单个数值。这意味着它不能用于计数数量也可能下降的项目，例如当前正在运行的goroutines的数量。这些“计数器”由量规代表。</p>
<p>计数器通常用于对服务的请求，完成的任务，发生的错误等进行计数。</p>
<p>若要创建Counter实例，请使用NewCounter。</p>
<h3 id="func-newcounter">func NewCounter<a hidden class="anchor" aria-hidden="true" href="#func-newcounter">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewCounter</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">CounterOpts</span><span class="p">)</span> <span class="nx">Counter</span>
</code></pre></td></tr></table>
</div>
</div><p>NewCounter基于提供的CounterOpts创建一个新的Counter。</p>
<p>返回的实现还实现ExemplarAdder。执行相应的类型声明是安全的。</p>
<p>返回的实现在两个单独的变量float64和uint64中跟踪计数器值。后者用于跟踪Inc方法的调用和具有可以表示为uint64的值的Add方法的调用。这使得计数器的原子增量具有最佳性能。（通常在非常热的执行路径中进行Inc调用。）这两个内部跟踪值都在Write方法中相加。当涉及到精度和溢出行为时，必须考虑到这一点。</p>
<h3 id="type-counterfunc">type CounterFunc<a hidden class="anchor" aria-hidden="true" href="#type-counterfunc">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">CounterFunc</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Metric</span>
	<span class="nx">Collector</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>CounterFunc是一个Counter，其值在收集时通过调用提供的函数确定。</p>
<p>若要创建CounterFunc实例，请使用NewCounterFunc。</p>
<h3 id="func-newcounterfunc">func NewCounterFunc<a hidden class="anchor" aria-hidden="true" href="#func-newcounterfunc">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewCounterFunc</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">CounterOpts</span><span class="p">,</span> <span class="nx">function</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">float64</span><span class="p">)</span> <span class="nx">CounterFunc</span>
</code></pre></td></tr></table>
</div>
</div><p>NewCounterFunc基于提供的CounterOpts创建一个新的CounterFunc。报告的值是通过在Write方法中调用给定的函数确定的。考虑到指标收集可能会同时发生。如果这导致对Write的并发调用，例如将CounterFunc直接注册到Prometheus的情况，则提供的函数必须是并发安全的。该功能还应遵守计数器合同（值只会上升，不会下降），但不会检查合规性。</p>
<p>查看类似的GaugeFunc的ExampleGaugeFunc示例。</p>
<h2 id="type-counteropts">type CounterOpts<a hidden class="anchor" aria-hidden="true" href="#type-counteropts">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">CounterOpts</span> <span class="nx">Opts</span>
</code></pre></td></tr></table>
</div>
</div><p>CounterOpts是Opts的别名。请参阅此处以获取文档注释。</p>
<h2 id="type-countervec">type CounterVec<a hidden class="anchor" aria-hidden="true" href="#type-countervec">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">CounterVec</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>CounterVec是一个收集器，捆绑了一组共享相同Desc，但其变量标签具有不同值的Counter。如果您要计算按不同维度划分的同一事物（例如，HTTP请求的数量，按响应代码和方法划分的），则使用此方法。使用NewCounterVec创建实例。</p>
<p>例子</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">httpReqs</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewCounterVec</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;http_requests_total&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span> <span class="s">&#34;How many HTTP requests processed, partitioned by status code and HTTP method.&#34;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;code&#34;</span><span class="p">,</span> <span class="s">&#34;method&#34;</span><span class="p">},</span>
<span class="p">)</span>
<span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">httpReqs</span><span class="p">)</span>

<span class="nx">httpReqs</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;404&#34;</span><span class="p">,</span> <span class="s">&#34;POST&#34;</span><span class="p">).</span><span class="nf">Add</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="c1">// If you have to access the same set of labels very frequently, it
</span><span class="c1">// might be good to retrieve the metric only once and keep a handle to
</span><span class="c1">// it. But beware of deletion of that metric, see below!
</span><span class="c1"></span><span class="nx">m</span> <span class="o">:=</span> <span class="nx">httpReqs</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;200&#34;</span><span class="p">,</span> <span class="s">&#34;GET&#34;</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">.</span><span class="nf">Inc</span><span class="p">()</span>
<span class="p">}</span>
<span class="c1">// Delete a metric from the vector. If you have previously kept a handle
</span><span class="c1">// to that metric (as above), future updates via that handle will go
</span><span class="c1">// unseen (even if you re-create a metric with the same label set
</span><span class="c1">// later).
</span><span class="c1"></span><span class="nx">httpReqs</span><span class="p">.</span><span class="nf">DeleteLabelValues</span><span class="p">(</span><span class="s">&#34;200&#34;</span><span class="p">,</span> <span class="s">&#34;GET&#34;</span><span class="p">)</span>
<span class="c1">// Same thing with the more verbose Labels syntax.
</span><span class="c1"></span><span class="nx">httpReqs</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;method&#34;</span><span class="p">:</span> <span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;code&#34;</span><span class="p">:</span> <span class="s">&#34;200&#34;</span><span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="func-newcountervec">func NewCounterVec<a hidden class="anchor" aria-hidden="true" href="#func-newcountervec">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewCounterVec</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">CounterOpts</span><span class="p">,</span> <span class="nx">labelNames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">CounterVec</span>
</code></pre></td></tr></table>
</div>
</div><p>NewCounterVec基于提供的CounterOpts创建新的CounterVec，并按给定的标签名称进行分区。</p>
<h3 id="func-countervec-collect">func (CounterVec) Collect<a hidden class="anchor" aria-hidden="true" href="#func-countervec-collect">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">CounterVec</span><span class="p">)</span> <span class="nf">Collect</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">Metric</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Collect 实现 Collector.</p>
<h3 id="func-countervec-currywith">func (*CounterVec) CurryWith<a hidden class="anchor" aria-hidden="true" href="#func-countervec-currywith">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">CounterVec</span><span class="p">)</span> <span class="nf">CurryWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">CounterVec</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>CurryWith返回使用提供的标签进行咖喱处理的向量，即返回的向量具有针对其执行的所有标记操作预先设置的那些标签。相应地减小了咖喱矢量的基数。其余标签的顺序保持不变（只是将咖喱标签从序列中取出，这与（GetMetric）WithLabelValues方法有关）。可以咖喱咖喱的矢量，但只能使用之前尚未用于咖喱的标签。</p>
<p>CounterVec中包含的度量在已管理和未已管理向量之间共享。只是以不同的方式访问它们。在集合方面，咖喱和非咖喱向量的行为相同。必须在给定的注册表中注册一个（通常是未更新的版本）。即使对当前向量调用了Reset方法，Reset方法也会删除所有指标。</p>
<h3 id="func-countervec-delete">func (CounterVec) Delete<a hidden class="anchor" aria-hidden="true" href="#func-countervec-delete">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">CounterVec</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>Delete会删除指标，其中变量标签与作为标签传入的标签相同。如果删除了指标，则返回true。</p>
<p>如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致，则不是错误。但是，此类不一致的标签永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。</p>
<p>此方法与DeleteLabelValues（&hellip; string）的用途相同。有关两种方法的优缺点，请参见此处。</p>
<h3 id="func-countervec-deletelabelvalues">func (CounterVec) DeleteLabelValues<a hidden class="anchor" aria-hidden="true" href="#func-countervec-deletelabelvalues">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">CounterVec</span><span class="p">)</span> <span class="nf">DeleteLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>DeleteLabelValues删除Metric，其中变量标签与作为标签传入的变量相同（与Desc中的VariableLabel顺序相同）。如果删除了指标，则返回true。</p>
<p>如果标签值的数量与Desc中的VariableLabels的数量不同，这不是错误。但是，这种不一致的标签计数永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。</p>
<p>请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用Delete（Labels）来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。另请参见CounterVec示例。</p>
<h3 id="func-countervec-describe">func (CounterVec) Describe<a hidden class="anchor" aria-hidden="true" href="#func-countervec-describe">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">CounterVec</span><span class="p">)</span> <span class="nf">Describe</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Describe 实现 Collector.</p>
<h3 id="func-countervec-getmetricwith">func (*CounterVec) GetMetricWith<a hidden class="anchor" aria-hidden="true" href="#func-countervec-getmetricwith">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">CounterVec</span><span class="p">)</span> <span class="nf">GetMetricWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="nx">Counter</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>GetMetricWith返回给定Labels映射的Counter（标签名称必须与Desc中的VariableLabels的名称匹配）。如果是第一次访问该标签映射，则会创建一个新的计数器。不使用计数器创建计数器并保留该计数器供以后使用的含义与GetMetricWithLabelValues相同。</p>
<p>如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致（减去任何已处理的标签），则会返回错误。</p>
<p>此方法与GetMetricWithLabelValues（&hellip; string）的用途相同。有关两种方法的优缺点，请参见此处。</p>
<h3 id="func-countervec-getmetricwithlabelvalues">func (*CounterVec) GetMetricWithLabelValues<a hidden class="anchor" aria-hidden="true" href="#func-countervec-getmetricwithlabelvalues">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">CounterVec</span><span class="p">)</span> <span class="nf">GetMetricWithLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Counter</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>GetMetricWithLabelValues返回给定标签值切片的计数器（与Desc中的VariableLabels顺序相同）。如果是第一次访问标签值的组合，则会创建一个新的计数器。</p>
<p>可以调用此方法而无需使用返回的Counter来仅创建新的Counter，而将其保留为起始值0。另请参见SummaryVec示例。</p>
<p>可以保留Counter以便以后使用（如果性能至关重要，则应考虑使用），但是请记住，可以使用Reset，DeleteLabelValues和Delete从CounterVec删除Counter。在这种情况下，即使以后创建具有相同标签值的计数器，该计数器仍将存在，但不再导出。</p>
<p>如果标签值的数量与Desc中的VariableLabels的数量（减去任何已固化的标签）不同，则返回错误。</p>
<p>请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用GetMetricWith（Labels）作为替代方案来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。另请参见GaugeVec示例。</p>
<h3 id="func-countervec-mustcurrywith">func (*CounterVec) MustCurryWith<a hidden class="anchor" aria-hidden="true" href="#func-countervec-mustcurrywith">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">CounterVec</span><span class="p">)</span> <span class="nf">MustCurryWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="o">*</span><span class="nx">CounterVec</span>
</code></pre></td></tr></table>
</div>
</div><p>MustCurryWith可以作为CurryWith使用，但在CurryWith会返回错误的情况下会出现panic。</p>
<h3 id="func-countervec-reset">func (CounterVec) Reset<a hidden class="anchor" aria-hidden="true" href="#func-countervec-reset">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">CounterVec</span><span class="p">)</span> <span class="nf">Reset</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>重置将删除此向量中的所有指标。</p>
<h3 id="func-countervec-with">func (*CounterVec) With<a hidden class="anchor" aria-hidden="true" href="#func-countervec-with">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">CounterVec</span><span class="p">)</span> <span class="nf">With</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="nx">Counter</span>
</code></pre></td></tr></table>
</div>
</div><p>With与GetMetricWith一样工作，但在GetMetricWithLabels会返回错误的地方感到慌张。不返回错误允许使用以下快捷方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">myVec</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;404&#34;</span><span class="p">,</span> <span class="s">&#34;GET&#34;</span><span class="p">).</span><span class="nf">Add</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="func-countervec-withlabelvalues">func (*CounterVec) WithLabelValues<a hidden class="anchor" aria-hidden="true" href="#func-countervec-withlabelvalues">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">CounterVec</span><span class="p">)</span> <span class="nf">WithLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="nx">Counter</span>
</code></pre></td></tr></table>
</div>
</div><p>WithLabelValues可以用作GetMetricWithLabelValues，但是在GetMetricWithLabelValues会返回错误的地方出现混乱。不返回错误允许使用以下快捷方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">myVec</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;404&#34;</span><span class="p">,</span> <span class="s">&#34;GET&#34;</span><span class="p">).</span><span class="nf">Add</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="type-gauge">type Gauge<a hidden class="anchor" aria-hidden="true" href="#type-gauge">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Gauge</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Metric</span>
	<span class="nx">Collector</span>

	<span class="c1">// Set sets the Gauge to an arbitrary value.
</span><span class="c1"></span>	<span class="nf">Set</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
	<span class="c1">// Inc increments the Gauge by 1. Use Add to increment it by arbitrary
</span><span class="c1"></span>	<span class="c1">// values.
</span><span class="c1"></span>	<span class="nf">Inc</span><span class="p">()</span>
	<span class="c1">// Dec decrements the Gauge by 1. Use Sub to decrement it by arbitrary
</span><span class="c1"></span>	<span class="c1">// values.
</span><span class="c1"></span>	<span class="nf">Dec</span><span class="p">()</span>
	<span class="c1">// Add adds the given value to the Gauge. (The value can be negative,
</span><span class="c1"></span>	<span class="c1">// resulting in a decrease of the Gauge.)
</span><span class="c1"></span>	<span class="nf">Add</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
	<span class="c1">// Sub subtracts the given value from the Gauge. (The value can be
</span><span class="c1"></span>	<span class="c1">// negative, resulting in an increase of the Gauge.)
</span><span class="c1"></span>	<span class="nf">Sub</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>

	<span class="c1">// SetToCurrentTime sets the Gauge to the current Unix time in seconds.
</span><span class="c1"></span>	<span class="nf">SetToCurrentTime</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Gauge是一种Metric，代表可以任意增加和减少的单个数值。</p>
<p>仪表通常用于测量值，例如温度或当前的内存使用情况，还用于可能上升和下降的“计数”，例如正在运行的goroutine的数量。</p>
<p>要创建仪表实例，请使用NewGauge。</p>
<p>例子</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">opsQueued</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewGauge</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">{</span>
	<span class="nx">Namespace</span><span class="p">:</span> <span class="s">&#34;our_company&#34;</span><span class="p">,</span>
	<span class="nx">Subsystem</span><span class="p">:</span> <span class="s">&#34;blob_storage&#34;</span><span class="p">,</span>
	<span class="nx">Name</span><span class="p">:</span>      <span class="s">&#34;ops_queued&#34;</span><span class="p">,</span>
	<span class="nx">Help</span><span class="p">:</span>      <span class="s">&#34;Number of blob storage operations waiting to be processed.&#34;</span><span class="p">,</span>
<span class="p">})</span>
<span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">opsQueued</span><span class="p">)</span>

<span class="c1">// 10 operations queued by the goroutine managing incoming requests.
</span><span class="c1"></span><span class="nx">opsQueued</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="c1">// A worker goroutine has picked up a waiting operation.
</span><span class="c1"></span><span class="nx">opsQueued</span><span class="p">.</span><span class="nf">Dec</span><span class="p">()</span>
<span class="c1">// And once more...
</span><span class="c1"></span><span class="nx">opsQueued</span><span class="p">.</span><span class="nf">Dec</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="func-newgauge">func NewGauge<a hidden class="anchor" aria-hidden="true" href="#func-newgauge">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewGauge</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">GaugeOpts</span><span class="p">)</span> <span class="nx">Gauge</span>
</code></pre></td></tr></table>
</div>
</div><p>NewGauge根据提供的GaugeOpts创建一个新的Gauge。</p>
<p>返回的实现针对快速Set方法进行了优化。如果您可以选择通过Set vs.Inc/Dec/Add/Sub来管理仪表的值，请选择前者。例如，返回的仪表的Inc方法比NewCounter返回的Counter的Inc方法慢。这与“Gauges”和“Counters”的典型方案相符，前者倾向于“重置类重载”，而后者倾向于“增加类重载”。</p>
<h3 id="type-gaugefunc">type GaugeFunc<a hidden class="anchor" aria-hidden="true" href="#type-gaugefunc">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">GaugeFunc</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Metric</span>
	<span class="nx">Collector</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>GaugeFunc是一个Gauge，其值是在收集时通过调用提供的函数确定的。</p>
<p>要创建GaugeFunc实例，请使用NewGaugeFunc。</p>
<p>示例（ConstLabels）</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// primaryDB and secondaryDB represent two example *sql.DB connections we want to instrument.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">primaryDB</span><span class="p">,</span> <span class="nx">secondaryDB</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Stats</span><span class="p">()</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">OpenConnections</span> <span class="kt">int</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewGaugeFunc</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">{</span>
		<span class="nx">Namespace</span><span class="p">:</span>   <span class="s">&#34;mysql&#34;</span><span class="p">,</span>
		<span class="nx">Name</span><span class="p">:</span>        <span class="s">&#34;connections_open&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>        <span class="s">&#34;Number of mysql connections open.&#34;</span><span class="p">,</span>
		<span class="nx">ConstLabels</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;destination&#34;</span><span class="p">:</span> <span class="s">&#34;primary&#34;</span><span class="p">},</span>
	<span class="p">},</span>
	<span class="kd">func</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">primaryDB</span><span class="p">.</span><span class="nf">Stats</span><span class="p">().</span><span class="nx">OpenConnections</span><span class="p">)</span> <span class="p">},</span>
<span class="p">));</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">`GaugeFunc &#39;connections_open&#39; for primary DB connection registered with labels {destination=&#34;primary&#34;}`</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewGaugeFunc</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">{</span>
		<span class="nx">Namespace</span><span class="p">:</span>   <span class="s">&#34;mysql&#34;</span><span class="p">,</span>
		<span class="nx">Name</span><span class="p">:</span>        <span class="s">&#34;connections_open&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>        <span class="s">&#34;Number of mysql connections open.&#34;</span><span class="p">,</span>
		<span class="nx">ConstLabels</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;destination&#34;</span><span class="p">:</span> <span class="s">&#34;secondary&#34;</span><span class="p">},</span>
	<span class="p">},</span>
	<span class="kd">func</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">secondaryDB</span><span class="p">.</span><span class="nf">Stats</span><span class="p">().</span><span class="nx">OpenConnections</span><span class="p">)</span> <span class="p">},</span>
<span class="p">));</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">`GaugeFunc &#39;connections_open&#39; for secondary DB connection registered with labels {destination=&#34;secondary&#34;}`</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Note that we can register more than once GaugeFunc with same metric name
</span><span class="c1">// as long as their const labels are consistent.
</span></code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">GaugeFunc &#39;connections_open&#39; for primary DB connection registered with labels {destination=&#34;primary&#34;}
GaugeFunc &#39;connections_open&#39; for secondary DB connection registered with labels {destination=&#34;secondary&#34;}
</code></pre></td></tr></table>
</div>
</div><p>示例（简单）</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewGaugeFunc</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">{</span>
		<span class="nx">Subsystem</span><span class="p">:</span> <span class="s">&#34;runtime&#34;</span><span class="p">,</span>
		<span class="nx">Name</span><span class="p">:</span>      <span class="s">&#34;goroutines_count&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>      <span class="s">&#34;Number of goroutines that currently exist.&#34;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="kd">func</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">NumGoroutine</span><span class="p">())</span> <span class="p">},</span>
<span class="p">));</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;GaugeFunc &#39;goroutines_count&#39; registered.&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Note that the count of goroutines is a gauge (and not a counter) as
</span><span class="c1">// it can go up and down.
</span></code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">GaugeFunc &#39;goroutines_count&#39; registered.
</code></pre></td></tr></table>
</div>
</div><h3 id="func-newgaugefunc">func NewGaugeFunc<a hidden class="anchor" aria-hidden="true" href="#func-newgaugefunc">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewGaugeFunc</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">GaugeOpts</span><span class="p">,</span> <span class="nx">function</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">float64</span><span class="p">)</span> <span class="nx">GaugeFunc</span>
</code></pre></td></tr></table>
</div>
</div><p>NewGaugeFunc基于提供的GaugeOpts创建一个新的GaugeFunc。报告的值是通过在Write方法中调用给定的函数确定的。考虑到指标收集可能会同时发生。因此，必须安全地同时调用提供的函数。</p>
<p>NewGaugeFunc是创建常量值为1的“信息”风格指标的好方法。示例：<a href="https://github.com/prometheus/common/blob/8558a5b7db3c84fa38b4766966059a7bd5bfa2ee/version/info.go#L36-L56">https://github.com/prometheus/common/blob/8558a5b7db3c84fa38b4766966059a7bd5bfa2ee/version/info.go#L36-L56</a></p>
<h2 id="type-gaugeopts">type GaugeOpts<a hidden class="anchor" aria-hidden="true" href="#type-gaugeopts">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">GaugeOpts</span> <span class="nx">Opts</span>
</code></pre></td></tr></table>
</div>
</div><p>GaugeOpts是Opts的别名。请参阅此处以获取文档注释。</p>
<h2 id="type-gaugevec">type GaugeVec<a hidden class="anchor" aria-hidden="true" href="#type-gaugevec">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">GaugeVec</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>GaugeVec是一个收集器，它捆绑了一组共享相同Desc，但其变量标签具有不同值的Gauge。如果要统计按不同维度划分的同一事物（例如，排队的操作数，按用户和操作类型划分的分区），则使用此方法。使用NewGaugeVec创建实例。</p>
<p>例子</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">opsQueued</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewGaugeVec</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">{</span>
		<span class="nx">Namespace</span><span class="p">:</span> <span class="s">&#34;our_company&#34;</span><span class="p">,</span>
		<span class="nx">Subsystem</span><span class="p">:</span> <span class="s">&#34;blob_storage&#34;</span><span class="p">,</span>
		<span class="nx">Name</span><span class="p">:</span>      <span class="s">&#34;ops_queued&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>      <span class="s">&#34;Number of blob storage operations waiting to be processed, partitioned by user and type.&#34;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
		<span class="c1">// Which user has requested the operation?
</span><span class="c1"></span>		<span class="s">&#34;user&#34;</span><span class="p">,</span>
		<span class="c1">// Of what type is the operation?
</span><span class="c1"></span>		<span class="s">&#34;type&#34;</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">)</span>
<span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">opsQueued</span><span class="p">)</span>

<span class="c1">// Increase a value using compact (but order-sensitive!) WithLabelValues().
</span><span class="c1"></span><span class="nx">opsQueued</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;bob&#34;</span><span class="p">,</span> <span class="s">&#34;put&#34;</span><span class="p">).</span><span class="nf">Add</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="c1">// Increase a value with a map using WithLabels. More verbose, but order
</span><span class="c1">// doesn&#39;t matter anymore.
</span><span class="c1"></span><span class="nx">opsQueued</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;type&#34;</span><span class="p">:</span> <span class="s">&#34;delete&#34;</span><span class="p">,</span> <span class="s">&#34;user&#34;</span><span class="p">:</span> <span class="s">&#34;alice&#34;</span><span class="p">}).</span><span class="nf">Inc</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-newgaugevec">func NewGaugeVec<a hidden class="anchor" aria-hidden="true" href="#func-newgaugevec">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewGaugeVec</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">GaugeOpts</span><span class="p">,</span> <span class="nx">labelNames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">GaugeVec</span>
</code></pre></td></tr></table>
</div>
</div><p>NewGaugeVec基于提供的GaugeOpts创建新的GaugeVec，并按给定的标签名称进行分区。</p>
<h3 id="func-gaugevec-collect">func (GaugeVec) Collect<a hidden class="anchor" aria-hidden="true" href="#func-gaugevec-collect">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">GaugeVec</span><span class="p">)</span> <span class="nf">Collect</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">Metric</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Collect 实现 Collector.</p>
<h3 id="func-gaugevec-currywith">func (*GaugeVec) CurryWith<a hidden class="anchor" aria-hidden="true" href="#func-gaugevec-currywith">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">GaugeVec</span><span class="p">)</span> <span class="nf">CurryWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">GaugeVec</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>CurryWith返回使用提供的标签进行咖喱处理的向量，即返回的向量具有针对其执行的所有标记操作预先设置的那些标签。相应地减小了咖喱矢量的基数。其余标签的顺序保持不变（只是将咖喱标签从序列中取出，这与（GetMetric）WithLabelValues方法有关）。可以咖喱咖喱的矢量，但只能使用之前尚未用于咖喱的标签。</p>
<p>GaugeVec中包含的Metric在已固化和未固化向量之间共享。只是以不同的方式访问它们。在集合方面，咖喱和非咖喱向量的行为相同。必须在给定的注册表中注册一个（通常是未更新的版本）。即使对当前向量调用了Reset方法，Reset方法也会删除所有指标。</p>
<h3 id="func-gaugevec-delete">func (GaugeVec) Delete<a hidden class="anchor" aria-hidden="true" href="#func-gaugevec-delete">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">GaugeVec</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>删除会删除指标，其中变量标签与作为标签传入的标签相同。如果删除了指标，则返回true。</p>
<p>如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致，则不是错误。但是，此类不一致的标签永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。</p>
<p>此方法与DeleteLabelValues（&hellip; string）的用途相同。有关两种方法的优缺点，请参见此处。</p>
<h3 id="func-gaugevec-deletelabelvalues">func (GaugeVec) DeleteLabelValues<a hidden class="anchor" aria-hidden="true" href="#func-gaugevec-deletelabelvalues">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">GaugeVec</span><span class="p">)</span> <span class="nf">DeleteLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>DeleteLabelValues删除Metric，其中变量标签与作为标签传入的变量相同（与Desc中的VariableLabel顺序相同）。如果删除了指标，则返回true。</p>
<p>如果标签值的数量与Desc中的VariableLabels的数量不同，这不是错误。但是，这种不一致的标签计数永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。</p>
<p>请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用Delete（Labels）来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。另请参见CounterVec示例。</p>
<h3 id="func-gaugevec-describe">func (GaugeVec) Describe<a hidden class="anchor" aria-hidden="true" href="#func-gaugevec-describe">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">GaugeVec</span><span class="p">)</span> <span class="nf">Describe</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">Desc</span>
</code></pre></td></tr></table>
</div>
</div><p>Describe 实现 Collector.</p>
<h3 id="func-gaugevec-getmetricwith">func (*GaugeVec) GetMetricWith<a hidden class="anchor" aria-hidden="true" href="#func-gaugevec-getmetricwith">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">GaugeVec</span><span class="p">)</span> <span class="nf">GetMetricWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="nx">Gauge</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>GetMetricWith返回给定Labels映射的Gauge（标签名称必须与Desc中的VariableLabels的名称匹配）。如果是第一次访问该标签图，则会创建一个新的Gauge。不使用仪表创建仪表并保留仪表以备后用的含义与GetMetricWithLabelValues相同。</p>
<p>如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致（减去任何已处理的标签），则会返回错误。</p>
<p>此方法与GetMetricWithLabelValues（&hellip; string）的用途相同。有关两种方法的优缺点，请参见此处。</p>
<h3 id="func-gaugevec-getmetricwithlabelvalues">func (*GaugeVec) GetMetricWithLabelValues<a hidden class="anchor" aria-hidden="true" href="#func-gaugevec-getmetricwithlabelvalues">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">GaugeVec</span><span class="p">)</span> <span class="nf">GetMetricWithLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Gauge</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>GetMetricWithLabelValues返回给定标签值切片的量规（与Desc中的VariableLabels顺序相同）。如果是第一次访问标签值的组合，则会创建一个新的仪表。</p>
<p>可以在不使用返回的Gauge的情况下调用此方法，仅创建新的Gauge，而将其保留为初始值0。另请参见SummaryVec示例。</p>
<p>可以保留仪表以备后用（如果性能至关重要，则应考虑使用），但请记住，可以使用Reset，DeleteLabelValues和Delete从GaugeVec删除仪表。在这种情况下，即使以后创建具有相同标签值的仪表，该仪表仍将存在，但将不再导出。另请参见CounterVec示例。</p>
<p>如果标签值的数量与Desc中的VariableLabels的数量（减去任何已固化的标签）不同，则返回错误。</p>
<p>请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用GetMetricWith（Labels）作为替代方案来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。</p>
<h3 id="func-gaugevec-mustcurrywith">func (*GaugeVec) MustCurryWith<a hidden class="anchor" aria-hidden="true" href="#func-gaugevec-mustcurrywith">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">GaugeVec</span><span class="p">)</span> <span class="nf">MustCurryWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="o">*</span><span class="nx">GaugeVec</span>
</code></pre></td></tr></table>
</div>
</div><p>MustCurryWith可以作为CurryWith使用，但在CurryWith会返回错误的情况下会出现混乱。</p>
<h3 id="func-gaugevec-reset">func (GaugeVec) Reset<a hidden class="anchor" aria-hidden="true" href="#func-gaugevec-reset">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">GaugeVec</span><span class="p">)</span> <span class="nf">Reset</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>重置将删除此向量中的所有指标。</p>
<h3 id="func-gaugevec-with">func (*GaugeVec) With<a hidden class="anchor" aria-hidden="true" href="#func-gaugevec-with">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">GaugeVec</span><span class="p">)</span> <span class="nf">With</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="nx">Gauge</span>
</code></pre></td></tr></table>
</div>
</div><p>With与GetMetricWith一样工作，但在GetMetricWithLabels会返回错误的地方感到慌张。不返回错误允许使用以下快捷方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">myVec</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;code&#34;</span><span class="p">:</span> <span class="s">&#34;404&#34;</span><span class="p">,</span> <span class="s">&#34;method&#34;</span><span class="p">:</span> <span class="s">&#34;GET&#34;</span><span class="p">}).</span><span class="nf">Add</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="func-gaugevec-withlabelvalues">func (*GaugeVec) WithLabelValues<a hidden class="anchor" aria-hidden="true" href="#func-gaugevec-withlabelvalues">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">GaugeVec</span><span class="p">)</span> <span class="nf">WithLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="nx">Gauge</span>
</code></pre></td></tr></table>
</div>
</div><p>WithLabelValues可以用作GetMetricWithLabelValues，但是在GetMetricWithLabelValues会返回错误的地方出现混乱。不返回错误允许使用以下快捷方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">myVec</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;404&#34;</span><span class="p">,</span> <span class="s">&#34;GET&#34;</span><span class="p">).</span><span class="nf">Add</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="type-histogram">type Histogram<a hidden class="anchor" aria-hidden="true" href="#type-histogram">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Histogram</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Metric</span>
	<span class="nx">Collector</span>

	<span class="c1">// Observe adds a single observation to the histogram.
</span><span class="c1"></span>	<span class="nf">Observe</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>直方图计算来自事件或样本流的可配置存储桶中的单个观察值。与摘要类似，它也提供观察值的总和和观察值。</p>
<p>在Prometheus服务器上，可以使用查询语言中的histogram_quantile函数从直方图计算分位数。</p>
<p>请注意，与摘要相比，直方图可以与Prometheus查询语言进行汇总（有关详细过程，请参见文档）。但是，直方图要求用户预先定义合适的bucket，并且通常精度较低。与摘要的Observe方法相比，直方图的Observe方法具有非常低的性能开销。</p>
<p>要创建直方图实例，请使用NewHistogram。</p>
<p>例子</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">temps</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewHistogram</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramOpts</span><span class="p">{</span>
	<span class="nx">Name</span><span class="p">:</span>    <span class="s">&#34;pond_temperature_celsius&#34;</span><span class="p">,</span>
	<span class="nx">Help</span><span class="p">:</span>    <span class="s">&#34;The temperature of the frog pond.&#34;</span><span class="p">,</span> <span class="c1">// Sorry, we can&#39;t measure how badly it smells.
</span><span class="c1"></span>	<span class="nx">Buckets</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">LinearBuckets</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>  <span class="c1">// 5 buckets, each 5 centigrade wide.
</span><span class="c1"></span><span class="p">})</span>

<span class="c1">// Simulate some observations.
</span><span class="c1"></span><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="nx">temps</span><span class="p">.</span><span class="nf">Observe</span><span class="p">(</span><span class="mi">30</span> <span class="o">+</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="mi">120</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">))</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Just for demonstration, let&#39;s check the state of the histogram by
</span><span class="c1">// (ab)using its Write method (which is usually only used by Prometheus
</span><span class="c1">// internally).
</span><span class="c1"></span><span class="nx">metric</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">dto</span><span class="p">.</span><span class="nx">Metric</span><span class="p">{}</span>
<span class="nx">temps</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">metric</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">proto</span><span class="p">.</span><span class="nf">MarshalTextString</span><span class="p">(</span><span class="nx">metric</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">histogram: &lt;
  sample_count: 1000
  sample_sum: 29969.50000000001
  bucket: &lt;
    cumulative_count: 192
    upper_bound: 20
  &gt;
  bucket: &lt;
    cumulative_count: 366
    upper_bound: 25
  &gt;
  bucket: &lt;
    cumulative_count: 501
    upper_bound: 30
  &gt;
  bucket: &lt;
    cumulative_count: 638
    upper_bound: 35
  &gt;
  bucket: &lt;
    cumulative_count: 816
    upper_bound: 40
  &gt;
&gt;
</code></pre></td></tr></table>
</div>
</div><h3 id="func-newhistogram">func NewHistogram<a hidden class="anchor" aria-hidden="true" href="#func-newhistogram">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewHistogram</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">HistogramOpts</span><span class="p">)</span> <span class="nx">Histogram</span>
</code></pre></td></tr></table>
</div>
</div><p>NewHistogram基于提供的HistogramOpts创建新的直方图。如果HistogramOpts中的存储桶未严格按升序排序，则会感到恐慌。</p>
<p>返回的实现还实现ExemplarObserver。执行相应的类型声明是安全的。分别跟踪每个存储桶的示例。</p>
<h2 id="type-histogramopts">type HistogramOpts<a hidden class="anchor" aria-hidden="true" href="#type-histogramopts">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">HistogramOpts</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Namespace, Subsystem, and Name are components of the fully-qualified
</span><span class="c1"></span>	<span class="c1">// name of the Histogram (created by joining these components with
</span><span class="c1"></span>	<span class="c1">// &#34;_&#34;). Only Name is mandatory, the others merely help structuring the
</span><span class="c1"></span>	<span class="c1">// name. Note that the fully-qualified name of the Histogram must be a
</span><span class="c1"></span>	<span class="c1">// valid Prometheus metric name.
</span><span class="c1"></span>	<span class="nx">Namespace</span> <span class="kt">string</span>
	<span class="nx">Subsystem</span> <span class="kt">string</span>
	<span class="nx">Name</span>      <span class="kt">string</span>

	<span class="c1">// Help provides information about this Histogram.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Metrics with the same fully-qualified name must have the same Help
</span><span class="c1"></span>	<span class="c1">// string.
</span><span class="c1"></span>	<span class="nx">Help</span> <span class="kt">string</span>

	<span class="c1">// ConstLabels are used to attach fixed labels to this metric. Metrics
</span><span class="c1"></span>	<span class="c1">// with the same fully-qualified name must have the same label names in
</span><span class="c1"></span>	<span class="c1">// their ConstLabels.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// ConstLabels are only used rarely. In particular, do not use them to
</span><span class="c1"></span>	<span class="c1">// attach the same labels to all your metrics. Those use cases are
</span><span class="c1"></span>	<span class="c1">// better covered by target labels set by the scraping Prometheus
</span><span class="c1"></span>	<span class="c1">// server, or by one specific metric (e.g. a build_info or a
</span><span class="c1"></span>	<span class="c1">// machine_role metric). See also
</span><span class="c1"></span>	<span class="c1">// https://prometheus.io/docs/instrumenting/writing_exporters/#target-labels-not-static-scraped-labels
</span><span class="c1"></span>	<span class="nx">ConstLabels</span> <span class="nx">Labels</span>

	<span class="c1">// Buckets defines the buckets into which observations are counted. Each
</span><span class="c1"></span>	<span class="c1">// element in the slice is the upper inclusive bound of a bucket. The
</span><span class="c1"></span>	<span class="c1">// values must be sorted in strictly increasing order. There is no need
</span><span class="c1"></span>	<span class="c1">// to add a highest bucket with +Inf bound, it will be added
</span><span class="c1"></span>	<span class="c1">// implicitly. The default value is DefBuckets.
</span><span class="c1"></span>	<span class="nx">Buckets</span> <span class="p">[]</span><span class="kt">float64</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>HistogramOpts捆绑了用于创建直方图度量的选项。必须将Name设置为非空字符串。尽管强烈建议您设置帮助字符串，但所有其他字段都是可选的，可以安全地保留其零值。</p>
<h2 id="type-histogramvec">type HistogramVec<a hidden class="anchor" aria-hidden="true" href="#type-histogramvec">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">HistogramVec</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>HistogramVec是一个收集器，它捆绑一组直方图，这些直方图共享相同的Desc，但是其变量标签具有不同的值。如果要计算按不同维度划分的同一事物（例如，HTTP请求等待时间，按状态代码和方法划分的分区），则使用此方法。使用NewHistogramVec创建实例。</p>
<h3 id="func-newhistogramvec">func NewHistogramVec<a hidden class="anchor" aria-hidden="true" href="#func-newhistogramvec">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewHistogramVec</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">HistogramOpts</span><span class="p">,</span> <span class="nx">labelNames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">HistogramVec</span>
</code></pre></td></tr></table>
</div>
</div><p>NewHistogramVec基于提供的HistogramOpts创建一个新的HistogramVec，并按给定的标签名称进行分区。</p>
<h3 id="func-histogramvec-collect">func (HistogramVec) Collect<a hidden class="anchor" aria-hidden="true" href="#func-histogramvec-collect">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">HistogramVec</span><span class="p">)</span> <span class="nf">Collect</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">Metric</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Collect 实现 Collector.</p>
<h3 id="func-histogramvec-currywith">func (*HistogramVec) CurryWith<a hidden class="anchor" aria-hidden="true" href="#func-histogramvec-currywith">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">HistogramVec</span><span class="p">)</span> <span class="nf">CurryWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="nx">ObserverVec</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>CurryWith返回使用提供的标签进行咖喱处理的向量，即返回的向量具有针对其执行的所有标记操作预先设置的那些标签。相应地减小了咖喱矢量的基数。其余标签的顺序保持不变（只是将咖喱标签从序列中取出，这与（GetMetric）WithLabelValues方法有关）。可以咖喱咖喱的矢量，但只能使用之前尚未用于咖喱的标签。</p>
<p>HistogramVec中包含的度量在已固化和未固化向量之间共享。只是以不同的方式访问它们。在集合方面，咖喱和非咖喱向量的行为相同。必须在给定的注册表中注册一个（通常是未更新的版本）。即使对当前向量调用了Reset方法，Reset方法也会删除所有指标。</p>
<h3 id="func-histogramvec-delete">func (HistogramVec) Delete<a hidden class="anchor" aria-hidden="true" href="#func-histogramvec-delete">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">HistogramVec</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>删除会删除指标，其中变量标签与作为标签传入的标签相同。如果删除了指标，则返回true。</p>
<p>如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致，则不是错误。但是，此类不一致的标签永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。</p>
<p>此方法与DeleteLabelValues（&hellip; string）的用途相同。有关两种方法的优缺点，请参见此处。</p>
<h3 id="func-histogramvec-deletelabelvalues">func (HistogramVec) DeleteLabelValues<a hidden class="anchor" aria-hidden="true" href="#func-histogramvec-deletelabelvalues">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">HistogramVec</span><span class="p">)</span> <span class="nf">DeleteLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>DeleteLabelValues删除Metric，其中变量标签与作为标签传入的变量相同（与Desc中的VariableLabel顺序相同）。如果删除了指标，则返回true。</p>
<p>如果标签值的数量与Desc中的VariableLabels的数量不同，这不是错误。但是，这种不一致的标签计数永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。</p>
<p>请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用Delete（Labels）来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。另请参见CounterVec示例。</p>
<h3 id="func-histogramvec-describe">func (HistogramVec) Describe<a hidden class="anchor" aria-hidden="true" href="#func-histogramvec-describe">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">HistogramVec</span><span class="p">)</span> <span class="nf">Describe</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Describe 实现 Collector.</p>
<h3 id="func-histogramvec-getmetricwith">func (*HistogramVec) GetMetricWith<a hidden class="anchor" aria-hidden="true" href="#func-histogramvec-getmetricwith">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">HistogramVec</span><span class="p">)</span> <span class="nf">GetMetricWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="nx">Observer</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>GetMetricWith返回给定Labels映射的直方图（标签名称必须与Desc中的VariableLabel的名称匹配）。如果是第一次访问该标签图，则会创建一个新的直方图。不使用直方图创建直方图并保留直方图供以后使用的含义与GetMetricWithLabelValues相同。</p>
<p>如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致（减去任何已处理的标签），则会返回错误。</p>
<p>此方法与GetMetricWithLabelValues（&hellip; string）的用途相同。有关两种方法的优缺点，请参见此处。</p>
<h3 id="func-histogramvec-getmetricwithlabelvalues">func (*HistogramVec) GetMetricWithLabelValues<a hidden class="anchor" aria-hidden="true" href="#func-histogramvec-getmetricwithlabelvalues">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">HistogramVec</span><span class="p">)</span> <span class="nf">GetMetricWithLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Observer</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>GetMetricWithLabelValues返回给定标签值切片的直方图（与Desc中的VariableLabels顺序相同）。如果第一次访问标签值的组合，则会创建一个新的直方图。</p>
<p>可以在不使用返回的直方图的情况下调用此方法，仅创建新的直方图，而将其保留为初始值，即没有任何观察值的直方图。</p>
<p>可以保留直方图供以后使用（如果性能至关重要，则应考虑使用），但请记住，可以使用Reset，DeleteLabelValues和Delete从HistogramVec中删除直方图。在这种情况下，即使以后创建具有相同标签值的直方图，直方图仍将存在，但将不再导出。另请参见CounterVec示例。</p>
<p>如果标签值的数量与Desc中的VariableLabels的数量（减去任何已固化的标签）不同，则返回错误。</p>
<p>请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用GetMetricWith（Labels）作为替代方案来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。另请参见GaugeVec示例。</p>
<h3 id="func-histogramvec-mustcurrywith">func (*HistogramVec) MustCurryWith<a hidden class="anchor" aria-hidden="true" href="#func-histogramvec-mustcurrywith">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">HistogramVec</span><span class="p">)</span> <span class="nf">MustCurryWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="nx">ObserverVec</span>
</code></pre></td></tr></table>
</div>
</div><p>MustCurryWith可以作为CurryWith使用，但在CurryWith会返回错误的情况下会出现混乱。</p>
<h3 id="func-histogramvec-reset">func (HistogramVec) Reset<a hidden class="anchor" aria-hidden="true" href="#func-histogramvec-reset">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">HistogramVec</span><span class="p">)</span> <span class="nf">Reset</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>重置将删除此向量中的所有指标。</p>
<h3 id="func-histogramvec-with">func (*HistogramVec) With<a hidden class="anchor" aria-hidden="true" href="#func-histogramvec-with">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">HistogramVec</span><span class="p">)</span> <span class="nf">With</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="nx">Observer</span>
</code></pre></td></tr></table>
</div>
</div><p>With与GetMetricWith一样工作，但在GetMetricWithLabels会返回错误的地方感到慌张。不返回错误允许使用以下快捷方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">myVec</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;code&#34;</span><span class="p">:</span> <span class="s">&#34;404&#34;</span><span class="p">,</span> <span class="s">&#34;method&#34;</span><span class="p">:</span> <span class="s">&#34;GET&#34;</span><span class="p">}).</span><span class="nf">Observe</span><span class="p">(</span><span class="mf">42.21</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="func-histogramvec-withlabelvalues">func (*HistogramVec) WithLabelValues<a hidden class="anchor" aria-hidden="true" href="#func-histogramvec-withlabelvalues">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">HistogramVec</span><span class="p">)</span> <span class="nf">WithLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="nx">Observer</span>
</code></pre></td></tr></table>
</div>
</div><p>WithLabelValues可以用作GetMetricWithLabelValues，但是在GetMetricWithLabelValues会返回错误的地方出现混乱。不返回错误允许使用以下快捷方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">myVec</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;404&#34;</span><span class="p">,</span> <span class="s">&#34;GET&#34;</span><span class="p">).</span><span class="nf">Observe</span><span class="p">(</span><span class="mf">42.21</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="type-summary">type Summary<a hidden class="anchor" aria-hidden="true" href="#type-summary">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Summary</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Metric</span>
	<span class="nx">Collector</span>

	<span class="c1">// Observe adds a single observation to the summary.
</span><span class="c1"></span>	<span class="nf">Observe</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>摘要可从事件或样本流中捕获单个观察值，并以类似于传统摘要统计的方式对其进行摘要：1.观察值总和，2。观察值，3。排名估计。</p>
<p>一个典型的用例是观察请求延迟。默认情况下，摘要提供延迟的中位数，第90％和第99％作为等级估计。但是，默认行为将在即将发布的库v1.0.0中更改。默认情况下，将不会有任何排名估计。对于合理的过渡，建议明确设置所需的排名估计。</p>
<p>请注意，排名估计不能使用Prometheus查询语言以有意义的方式进行汇总（即，您不能对它们进行平均或相加）。如果您需要可汇总的分位数（例如，您希望跨服务的所有实例进行的所有查询的第99个百分位数的延迟），请考虑直方图度量类型。有关更多详细信息，请参见Prometheus文档。</p>
<p>若要创建摘要实例，请使用NewSummary。</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">temps</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewSummary</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">SummaryOpts</span><span class="p">{</span>
	<span class="nx">Name</span><span class="p">:</span>       <span class="s">&#34;pond_temperature_celsius&#34;</span><span class="p">,</span>
	<span class="nx">Help</span><span class="p">:</span>       <span class="s">&#34;The temperature of the frog pond.&#34;</span><span class="p">,</span>
	<span class="nx">Objectives</span><span class="p">:</span> <span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">float64</span><span class="p">{</span><span class="mf">0.5</span><span class="p">:</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">:</span> <span class="mf">0.001</span><span class="p">},</span>
<span class="p">})</span>

<span class="c1">// Simulate some observations.
</span><span class="c1"></span><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="nx">temps</span><span class="p">.</span><span class="nf">Observe</span><span class="p">(</span><span class="mi">30</span> <span class="o">+</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="mi">120</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">))</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Just for demonstration, let&#39;s check the state of the summary by
</span><span class="c1">// (ab)using its Write method (which is usually only used by Prometheus
</span><span class="c1">// internally).
</span><span class="c1"></span><span class="nx">metric</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">dto</span><span class="p">.</span><span class="nx">Metric</span><span class="p">{}</span>
<span class="nx">temps</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">metric</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">proto</span><span class="p">.</span><span class="nf">MarshalTextString</span><span class="p">(</span><span class="nx">metric</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">summary: &lt;
  sample_count: 1000
  sample_sum: 29969.50000000001
  quantile: &lt;
    quantile: 0.5
    value: 31.1
  &gt;
  quantile: &lt;
    quantile: 0.9
    value: 41.3
  &gt;
  quantile: &lt;
    quantile: 0.99
    value: 41.9
  &gt;
</code></pre></td></tr></table>
</div>
</div><h3 id="func-newsummary">func NewSummary<a hidden class="anchor" aria-hidden="true" href="#func-newsummary">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewSummary</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">SummaryOpts</span><span class="p">)</span> <span class="nx">Summary</span>
</code></pre></td></tr></table>
</div>
</div><p>NewSummary基于提供的SummaryOpts创建一个新的Summary。</p>
<h2 id="type-summaryopts">type SummaryOpts<a hidden class="anchor" aria-hidden="true" href="#type-summaryopts">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SummaryOpts</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Namespace, Subsystem, and Name are components of the fully-qualified
</span><span class="c1"></span>	<span class="c1">// name of the Summary (created by joining these components with
</span><span class="c1"></span>	<span class="c1">// &#34;_&#34;). Only Name is mandatory, the others merely help structuring the
</span><span class="c1"></span>	<span class="c1">// name. Note that the fully-qualified name of the Summary must be a
</span><span class="c1"></span>	<span class="c1">// valid Prometheus metric name.
</span><span class="c1"></span>	<span class="nx">Namespace</span> <span class="kt">string</span>
	<span class="nx">Subsystem</span> <span class="kt">string</span>
	<span class="nx">Name</span>      <span class="kt">string</span>

	<span class="c1">// Help provides information about this Summary.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Metrics with the same fully-qualified name must have the same Help
</span><span class="c1"></span>	<span class="c1">// string.
</span><span class="c1"></span>	<span class="nx">Help</span> <span class="kt">string</span>

	<span class="c1">// ConstLabels are used to attach fixed labels to this metric. Metrics
</span><span class="c1"></span>	<span class="c1">// with the same fully-qualified name must have the same label names in
</span><span class="c1"></span>	<span class="c1">// their ConstLabels.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Due to the way a Summary is represented in the Prometheus text format
</span><span class="c1"></span>	<span class="c1">// and how it is handled by the Prometheus server internally, “quantile”
</span><span class="c1"></span>	<span class="c1">// is an illegal label name. Construction of a Summary or SummaryVec
</span><span class="c1"></span>	<span class="c1">// will panic if this label name is used in ConstLabels.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// ConstLabels are only used rarely. In particular, do not use them to
</span><span class="c1"></span>	<span class="c1">// attach the same labels to all your metrics. Those use cases are
</span><span class="c1"></span>	<span class="c1">// better covered by target labels set by the scraping Prometheus
</span><span class="c1"></span>	<span class="c1">// server, or by one specific metric (e.g. a build_info or a
</span><span class="c1"></span>	<span class="c1">// machine_role metric). See also
</span><span class="c1"></span>	<span class="c1">// https://prometheus.io/docs/instrumenting/writing_exporters/#target-labels,-not-static-scraped-labels
</span><span class="c1"></span>	<span class="nx">ConstLabels</span> <span class="nx">Labels</span>

	<span class="c1">// Objectives defines the quantile rank estimates with their respective
</span><span class="c1"></span>	<span class="c1">// absolute error. If Objectives[q] = e, then the value reported for q
</span><span class="c1"></span>	<span class="c1">// will be the φ-quantile value for some φ between q-e and q+e.  The
</span><span class="c1"></span>	<span class="c1">// default value is an empty map, resulting in a summary without
</span><span class="c1"></span>	<span class="c1">// quantiles.
</span><span class="c1"></span>	<span class="nx">Objectives</span> <span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">float64</span>

	<span class="c1">// MaxAge defines the duration for which an observation stays relevant
</span><span class="c1"></span>	<span class="c1">// for the summary. Must be positive. The default value is DefMaxAge.
</span><span class="c1"></span>	<span class="nx">MaxAge</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>

	<span class="c1">// AgeBuckets is the number of buckets used to exclude observations that
</span><span class="c1"></span>	<span class="c1">// are older than MaxAge from the summary. A higher number has a
</span><span class="c1"></span>	<span class="c1">// resource penalty, so only increase it if the higher resolution is
</span><span class="c1"></span>	<span class="c1">// really required. For very high observation rates, you might want to
</span><span class="c1"></span>	<span class="c1">// reduce the number of age buckets. With only one age bucket, you will
</span><span class="c1"></span>	<span class="c1">// effectively see a complete reset of the summary each time MaxAge has
</span><span class="c1"></span>	<span class="c1">// passed. The default value is DefAgeBuckets.
</span><span class="c1"></span>	<span class="nx">AgeBuckets</span> <span class="kt">uint32</span>

	<span class="c1">// BufCap defines the default sample stream buffer size.  The default
</span><span class="c1"></span>	<span class="c1">// value of DefBufCap should suffice for most uses. If there is a need
</span><span class="c1"></span>	<span class="c1">// to increase the value, a multiple of 500 is recommended (because that
</span><span class="c1"></span>	<span class="c1">// is the internal buffer size of the underlying package
</span><span class="c1"></span>	<span class="c1">// &#34;github.com/bmizerany/perks/quantile&#34;).
</span><span class="c1"></span>	<span class="nx">BufCap</span> <span class="kt">uint32</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>SummaryOpts捆绑了用于创建“摘要”指标的选项。必须将Name设置为非空字符串。尽管所有其他字段都是可选的，并且可以安全地保留为零值，但是建议设置帮助字符串并将“ Objectives”字段明确设置为所需值，因为默认值将在库的即将发布的v1.0.0中更改。</p>
<h2 id="type-summaryvec">type SummaryVec<a hidden class="anchor" aria-hidden="true" href="#type-summaryvec">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SummaryVec</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>SummaryVec是一个收集器，捆绑了一组共享相同的Desc，但其变量标签具有不同值的摘要。如果要计算按不同维度划分的同一事物（例如，HTTP请求等待时间，按状态代码和方法划分的分区），则使用此方法。使用NewSummaryVec创建实例。</p>
<p>例子</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">temps</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewSummaryVec</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">SummaryOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>       <span class="s">&#34;pond_temperature_celsius&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>       <span class="s">&#34;The temperature of the frog pond.&#34;</span><span class="p">,</span>
		<span class="nx">Objectives</span><span class="p">:</span> <span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">float64</span><span class="p">{</span><span class="mf">0.5</span><span class="p">:</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">:</span> <span class="mf">0.001</span><span class="p">},</span>
	<span class="p">},</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;species&#34;</span><span class="p">},</span>
<span class="p">)</span>

<span class="c1">// Simulate some observations.
</span><span class="c1"></span><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="nx">temps</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;litoria-caerulea&#34;</span><span class="p">).</span><span class="nf">Observe</span><span class="p">(</span><span class="mi">30</span> <span class="o">+</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="mi">120</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">))</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
	<span class="nx">temps</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;lithobates-catesbeianus&#34;</span><span class="p">).</span><span class="nf">Observe</span><span class="p">(</span><span class="mi">32</span> <span class="o">+</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nf">Cos</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">*</span><span class="mf">0.11</span><span class="p">))</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Create a Summary without any observations.
</span><span class="c1"></span><span class="nx">temps</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;leiopelma-hochstetteri&#34;</span><span class="p">)</span>

<span class="c1">// Just for demonstration, let&#39;s check the state of the summary vector
</span><span class="c1">// by registering it with a custom registry and then let it collect the
</span><span class="c1">// metrics.
</span><span class="c1"></span><span class="nx">reg</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewRegistry</span><span class="p">()</span>
<span class="nx">reg</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">temps</span><span class="p">)</span>

<span class="nx">metricFamilies</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">Gather</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="nx">metricFamilies</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;unexpected behavior of custom test registry&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">proto</span><span class="p">.</span><span class="nf">MarshalTextString</span><span class="p">(</span><span class="nx">metricFamilies</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">name: &#34;pond_temperature_celsius&#34;
help: &#34;The temperature of the frog pond.&#34;
type: SUMMARY
metric: &lt;
  label: &lt;
    name: &#34;species&#34;
    value: &#34;leiopelma-hochstetteri&#34;
  &gt;
  summary: &lt;
    sample_count: 0
    sample_sum: 0
    quantile: &lt;
      quantile: 0.5
      value: nan
    &gt;
    quantile: &lt;
      quantile: 0.9
      value: nan
    &gt;
    quantile: &lt;
      quantile: 0.99
      value: nan
    &gt;
  &gt;
&gt;
metric: &lt;
  label: &lt;
    name: &#34;species&#34;
    value: &#34;lithobates-catesbeianus&#34;
  &gt;
  summary: &lt;
    sample_count: 1000
    sample_sum: 31956.100000000017
    quantile: &lt;
      quantile: 0.5
      value: 32.4
    &gt;
    quantile: &lt;
      quantile: 0.9
      value: 41.4
    &gt;
    quantile: &lt;
      quantile: 0.99
      value: 41.9
    &gt;
  &gt;
&gt;
metric: &lt;
  label: &lt;
    name: &#34;species&#34;
    value: &#34;litoria-caerulea&#34;
  &gt;
  summary: &lt;
    sample_count: 1000
    sample_sum: 29969.50000000001
    quantile: &lt;
      quantile: 0.5
      value: 31.1
    &gt;
    quantile: &lt;
      quantile: 0.9
      value: 41.3
    &gt;
    quantile: &lt;
      quantile: 0.99
      value: 41.9
    &gt;
  &gt;
&gt;
</code></pre></td></tr></table>
</div>
</div><h3 id="func-newsummaryvec">func NewSummaryVec<a hidden class="anchor" aria-hidden="true" href="#func-newsummaryvec">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewSummaryVec</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">SummaryOpts</span><span class="p">,</span> <span class="nx">labelNames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">SummaryVec</span>
</code></pre></td></tr></table>
</div>
</div><p>NewSummaryVec基于提供的SummaryOpts创建一个新的SummaryVec，并按给定的标签名称进行分区。</p>
<p>由于摘要以Prometheus文本格式表示的方式以及Prometheus服务器在内部如何处理摘要，因此“quantile”是非法的标签名称。如果使用此标签名称，NewSummaryVec将惊慌。</p>
<h3 id="func-summaryvec-collect">func (SummaryVec) Collect<a hidden class="anchor" aria-hidden="true" href="#func-summaryvec-collect">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">SummaryVec</span><span class="p">)</span> <span class="nf">Collect</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">Metric</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>收集器收集器。</p>
<h3 id="func-summaryvec-currywith">func (*SummaryVec) CurryWith<a hidden class="anchor" aria-hidden="true" href="#func-summaryvec-currywith">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">SummaryVec</span><span class="p">)</span> <span class="nf">CurryWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="nx">ObserverVec</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>CurryWith返回使用提供的标签进行咖喱处理的向量，即返回的向量具有针对其执行的所有标记操作预先设置的那些标签。相应地减小了咖喱矢量的基数。其余标签的顺序保持不变（只是将咖喱标签从序列中取出，这与（GetMetric）WithLabelValues方法有关）。可以咖喱咖喱的矢量，但只能使用之前尚未用于咖喱的标签。</p>
<p>SummaryVec中包含的度量在已管理和未已管理向量之间共享。只是以不同的方式访问它们。在集合方面，咖喱和非咖喱向量的行为相同。必须在给定的注册表中注册一个（通常是未更新的版本）。即使对当前向量调用了Reset方法，Reset方法也会删除所有指标。</p>
<h3 id="func-summaryvec-delete">func (SummaryVec) Delete<a hidden class="anchor" aria-hidden="true" href="#func-summaryvec-delete">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">SummaryVec</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>删除会删除指标，其中变量标签与作为标签传入的标签相同。如果删除了指标，则返回true。</p>
<p>如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致，则不是错误。但是，此类不一致的标签永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。</p>
<p>此方法与DeleteLabelValues（&hellip; string）的用途相同。有关两种方法的优缺点，请参见此处。</p>
<h3 id="func-summaryvec-deletelabelvalues">func (SummaryVec) DeleteLabelValues<a hidden class="anchor" aria-hidden="true" href="#func-summaryvec-deletelabelvalues">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">SummaryVec</span><span class="p">)</span> <span class="nf">DeleteLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>DeleteLabelValues删除Metric，其中变量标签与作为标签传入的变量相同（与Desc中的VariableLabel顺序相同）。如果删除了指标，则返回true。</p>
<p>如果标签值的数量与Desc中的VariableLabels的数量不同，这不是错误。但是，这种不一致的标签计数永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。</p>
<p>请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用Delete（Labels）来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。另请参见CounterVec示例。</p>
<h3 id="func-summaryvec-describe">func (SummaryVec) Describe<a hidden class="anchor" aria-hidden="true" href="#func-summaryvec-describe">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">SummaryVec</span><span class="p">)</span> <span class="nf">Describe</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>描述工具收集器。</p>
<h3 id="func-summaryvec-getmetricwith">func (*SummaryVec) GetMetricWith<a hidden class="anchor" aria-hidden="true" href="#func-summaryvec-getmetricwith">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">SummaryVec</span><span class="p">)</span> <span class="nf">GetMetricWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="nx">Observer</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>GetMetricWith返回给定标签映射的摘要（标签名称必须与Desc中的VariableLabel的名称匹配）。如果是第一次访问该标签图，则会创建一个新的摘要。不使用摘要创建摘要并保留摘要供以后使用的含义与GetMetricWithLabelValues相同。</p>
<p>如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致（减去任何已处理的标签），则会返回错误。</p>
<p>此方法与GetMetricWithLabelValues（&hellip; string）的用途相同。有关两种方法的优缺点，请参见此处。</p>
<h3 id="func-summaryvec-getmetricwithlabelvalues">func (*SummaryVec) GetMetricWithLabelValues<a hidden class="anchor" aria-hidden="true" href="#func-summaryvec-getmetricwithlabelvalues">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">SummaryVec</span><span class="p">)</span> <span class="nf">GetMetricWithLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Observer</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>GetMetricWithLabelValues返回给定标签值切片的摘要（与Desc中的VariableLabels顺序相同）。如果是第一次访问标签值的组合，则会创建一个新的摘要。</p>
<p>可以在不使用返回的Summary的情况下调用此方法，仅创建新的Summary，而将其保留为初始值，即没有任何观察值的Summary。</p>
<p>保留摘要以备后用是可能的（如果性能至关重要，则应考虑使用），但请记住，可以使用Reset，DeleteLabelValues和Delete从SummaryVec中删除摘要。在这种情况下，即使稍后创建具有相同标签值的摘要，摘要仍将存在，但不再导出。另请参见CounterVec示例。</p>
<p>如果标签值的数量与Desc中的VariableLabels的数量（减去任何已固化的标签）不同，则返回错误。</p>
<p>请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用GetMetricWith（Labels）作为替代方案来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。另请参见GaugeVec示例。</p>
<h3 id="func-summaryvec-mustcurrywith">func (*SummaryVec) MustCurryWith<a hidden class="anchor" aria-hidden="true" href="#func-summaryvec-mustcurrywith">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">SummaryVec</span><span class="p">)</span> <span class="nf">MustCurryWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="nx">ObserverVec</span>
</code></pre></td></tr></table>
</div>
</div><p>MustCurryWith可以作为CurryWith使用，但在CurryWith会返回错误的情况下会出现混乱。</p>
<h3 id="func-summaryvec-reset">func (SummaryVec) Reset<a hidden class="anchor" aria-hidden="true" href="#func-summaryvec-reset">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">SummaryVec</span><span class="p">)</span> <span class="nf">Reset</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>重置将删除此向量中的所有指标。</p>
<h3 id="func-summaryvec-with">func (*SummaryVec) With<a hidden class="anchor" aria-hidden="true" href="#func-summaryvec-with">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">SummaryVec</span><span class="p">)</span> <span class="nf">With</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="nx">Observer</span>
</code></pre></td></tr></table>
</div>
</div><p>With与GetMetricWith一样工作，但在GetMetricWithLabels会返回错误的地方感到慌张。不返回错误允许使用以下快捷方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">myVec</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;code&#34;</span><span class="p">:</span> <span class="s">&#34;404&#34;</span><span class="p">,</span> <span class="s">&#34;method&#34;</span><span class="p">:</span> <span class="s">&#34;GET&#34;</span><span class="p">}).</span><span class="nf">Observe</span><span class="p">(</span><span class="mf">42.21</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="func-summaryvec-withlabelvalues">func (*SummaryVec) WithLabelValues<a hidden class="anchor" aria-hidden="true" href="#func-summaryvec-withlabelvalues">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">SummaryVec</span><span class="p">)</span> <span class="nf">WithLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="nx">Observer</span>
</code></pre></td></tr></table>
</div>
</div><p>WithLabelValues可以用作GetMetricWithLabelValues，但是在GetMetricWithLabelValues会返回错误的地方出现混乱。不返回错误允许使用以下快捷方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">myVec</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;404&#34;</span><span class="p">,</span> <span class="s">&#34;GET&#34;</span><span class="p">).</span><span class="nf">Observe</span><span class="p">(</span><span class="mf">42.21</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="type-desc">type Desc<a hidden class="anchor" aria-hidden="true" href="#type-desc">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Desc</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Desc是每个Prometheus指标使用的描述符。它本质上是Metric的不可变元数据。此程序包中包含的常规Metric实现在后台管理其Desc。如果用户使用诸​​如ExpvarCollector或自定义收集器和Metric之类的高级功能，则仅需处理Desc。</p>
<p>如果在相同的注册表中注册的描述符共享相同的完全限定名称，则它们必须满足某些一致性和唯一性条件：constLabels和variableLabels的描述符必须具有相同的帮助字符串和相同的标签名称（即标签尺寸），但是constLabels的值必须不同。</p>
<p>共享相同常量名称和constLabel相同标签值的描述符被视为相等。</p>
<p>使用NewDesc创建新的Desc实例。</p>
<h3 id="func-newdesc">func NewDesc<a hidden class="anchor" aria-hidden="true" href="#func-newdesc">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewDesc</span><span class="p">(</span><span class="nx">fqName</span><span class="p">,</span> <span class="nx">help</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">variableLabels</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">constLabels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="o">*</span><span class="nx">Desc</span>
</code></pre></td></tr></table>
</div>
</div><p>NewDesc分配并初始化新的Desc。错误记录在Desc中，并将在注册时间报告。如果不应该设置这样的标签，variableLabels和constLabels可以为nil。fqName不能为空。</p>
<p>variableLabels仅包含标签名称。它们的标签值是可变的，因此不是Desc的一部分。（它们在Metric内管理。）</p>
<p>对于constLabels，标签值是恒定的。因此，它们在“描述”中已完全指定。有关用法模式，请参见收集器示例。</p>
<h3 id="func-newinvaliddesc">func NewInvalidDesc<a hidden class="anchor" aria-hidden="true" href="#func-newinvaliddesc">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewInvalidDesc</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="o">*</span><span class="nx">Desc</span>
</code></pre></td></tr></table>
</div>
</div><p>NewInvalidDesc返回无效的描述符，即具有提供的错误集的描述符。如果注册了返回此类描述符的收集器，则注册将失败，并显示所提供的错误。收集器可以使用NewInvalidDesc来表示无法描述自己。</p>
<h3 id="func-desc-string">func (*Desc) String<a hidden class="anchor" aria-hidden="true" href="#func-desc-string">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="type-exemplaradder">type ExemplarAdder<a hidden class="anchor" aria-hidden="true" href="#type-exemplaradder">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ExemplarAdder</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">AddWithExemplar</span><span class="p">(</span><span class="nx">value</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">exemplar</span> <span class="nx">Labels</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ExemplarAdder由Counters实现，Counter提供了与示例一起向Counter添加值的选项。它的AddWithExemplar方法的工作方式与Counter接口的Add方法类似，但是也用新的（由提供的值，当前时间作为时间戳记和提供的标签）创建的新示例替换了当前保存的示例（如果有）。空标签将导致有效的（无标签）示例。但是，如果Labels为nil，则当前示例保留不变。如果值&lt;0，提供的任何标签无效或提供的标签总共包含64个以上符文，则AddWithExemplar会发生混乱。</p>
<h2 id="type-exemplarobserver">type ExemplarObserver<a hidden class="anchor" aria-hidden="true" href="#type-exemplarobserver">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ExemplarObserver</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">ObserveWithExemplar</span><span class="p">(</span><span class="nx">value</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">exemplar</span> <span class="nx">Labels</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ExemplarObserver由观察者实现，该观察者提供了与示例一起观察值的选项。它的ObserveWithExemplar方法的工作方式类似于Observer的Observe方法，但也用新的（由提供的值，当前时间作为时间戳记和提供的Label）创建的新示例替换了当前保存的示例（如果有）。空标签将导致有效的（无标签）示例。但是，如果Labels为nil，则当前示例保留不变。如果提供的任何标签无效或提供的标签总共包含64个以上符文，则ObserveWithExemplar会发生混乱。</p>
<h2 id="type-gatherer">type Gatherer<a hidden class="anchor" aria-hidden="true" href="#type-gatherer">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Gatherer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Gather calls the Collect method of the registered Collectors and then
</span><span class="c1"></span>	<span class="c1">// gathers the collected metrics into a lexicographically sorted slice
</span><span class="c1"></span>	<span class="c1">// of uniquely named MetricFamily protobufs. Gather ensures that the
</span><span class="c1"></span>	<span class="c1">// returned slice is valid and self-consistent so that it can be used
</span><span class="c1"></span>	<span class="c1">// for valid exposition. As an exception to the strict consistency
</span><span class="c1"></span>	<span class="c1">// requirements described for metric.Desc, Gather will tolerate
</span><span class="c1"></span>	<span class="c1">// different sets of label names for metrics of the same metric family.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Even if an error occurs, Gather attempts to gather as many metrics as
</span><span class="c1"></span>	<span class="c1">// possible. Hence, if a non-nil error is returned, the returned
</span><span class="c1"></span>	<span class="c1">// MetricFamily slice could be nil (in case of a fatal error that
</span><span class="c1"></span>	<span class="c1">// prevented any meaningful metric collection) or contain a number of
</span><span class="c1"></span>	<span class="c1">// MetricFamily protobufs, some of which might be incomplete, and some
</span><span class="c1"></span>	<span class="c1">// might be missing altogether. The returned error (which might be a
</span><span class="c1"></span>	<span class="c1">// MultiError) explains the details. Note that this is mostly useful for
</span><span class="c1"></span>	<span class="c1">// debugging purposes. If the gathered protobufs are to be used for
</span><span class="c1"></span>	<span class="c1">// exposition in actual monitoring, it is almost always better to not
</span><span class="c1"></span>	<span class="c1">// expose an incomplete result and instead disregard the returned
</span><span class="c1"></span>	<span class="c1">// MetricFamily protobufs in case the returned error is non-nil.
</span><span class="c1"></span>	<span class="nf">Gather</span><span class="p">()</span> <span class="p">([]</span><span class="o">*</span><span class="nx">dto</span><span class="p">.</span><span class="nx">MetricFamily</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Gatherer是注册表的一部分，负责将收集的指标收集到许多MetricFamilies中。Gatherer interface具有与Registerer interface 相同的一般含义。</p>
<h3 id="type-gathererfunc">type GathererFunc<a hidden class="anchor" aria-hidden="true" href="#type-gathererfunc">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">GathererFunc</span> <span class="kd">func</span><span class="p">()</span> <span class="p">([]</span><span class="o">*</span><span class="nx">dto</span><span class="p">.</span><span class="nx">MetricFamily</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>GathererFunc将功能转换为Gatherer。</p>
<h3 id="func-gathererfunc-gather">func (GathererFunc) Gather<a hidden class="anchor" aria-hidden="true" href="#func-gathererfunc-gather">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">gf</span> <span class="nx">GathererFunc</span><span class="p">)</span> <span class="nf">Gather</span><span class="p">()</span> <span class="p">([]</span><span class="o">*</span><span class="nx">dto</span><span class="p">.</span><span class="nx">MetricFamily</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Gather实现Gatherer。</p>
<h2 id="type-gatherers">type Gatherers<a hidden class="anchor" aria-hidden="true" href="#type-gatherers">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Gatherers</span> <span class="p">[]</span><span class="nx">Gatherer</span>
</code></pre></td></tr></table>
</div>
</div><p>Gatherers是实现Gatherer接口本身的Gatherer实例的一部分。它的Gather方法按顺序在切片中的所有Gatherer上调用Gather并返回合并的结果。从Gather调用返回的错误全部以扁平化的MultiError返回。跳过重复和不一致的Metric（以分片顺序获胜的方式首次出现），并在返回的错误中报告。</p>
<p>收集器可用于合并来自多个注册表的收集结果。它还提供了一种通过使用Gather方法创建自定义Gatherer的方法，将现有的MetricFamily原型直接注入到集合中，该方法仅返回现有的MetricFamily原型。请注意，不涉及注册（与收集器注册相反），因此显然无法进行注册时检查。收集的MetricFamilies之间的任何不一致都会通过Gather方法报告为错误，并且会删除不一致的Metric。MetricFamilies的无效部分（例如，语法上无效的Metric或标签名称）将不会被检测到。</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">reg</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewRegistry</span><span class="p">()</span>
<span class="nx">temp</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewGaugeVec</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;temperature_kelvin&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span> <span class="s">&#34;Temperature in Kelvin.&#34;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;location&#34;</span><span class="p">},</span>
<span class="p">)</span>
<span class="nx">reg</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">temp</span><span class="p">)</span>
<span class="nx">temp</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;outside&#34;</span><span class="p">).</span><span class="nf">Set</span><span class="p">(</span><span class="mf">273.14</span><span class="p">)</span>
<span class="nx">temp</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;inside&#34;</span><span class="p">).</span><span class="nf">Set</span><span class="p">(</span><span class="mf">298.44</span><span class="p">)</span>

<span class="kd">var</span> <span class="nx">parser</span> <span class="nx">expfmt</span><span class="p">.</span><span class="nx">TextParser</span>

<span class="nx">text</span> <span class="o">:=</span> <span class="s">`
</span><span class="s">## TYPE humidity_percent gauge
</span><span class="s">## HELP humidity_percent Humidity in %.
</span><span class="s">humidity_percent{location=&#34;outside&#34;} 45.4
</span><span class="s">humidity_percent{location=&#34;inside&#34;} 33.2
</span><span class="s">## TYPE temperature_kelvin gauge
</span><span class="s">## HELP temperature_kelvin Temperature in Kelvin.
</span><span class="s">temperature_kelvin{location=&#34;somewhere else&#34;} 4.5
</span><span class="s">`</span>

<span class="nx">parseText</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">([]</span><span class="o">*</span><span class="nx">dto</span><span class="p">.</span><span class="nx">MetricFamily</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">parsed</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">parser</span><span class="p">.</span><span class="nf">TextToMetricFamilies</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">text</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="o">*</span><span class="nx">dto</span><span class="p">.</span><span class="nx">MetricFamily</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">mf</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">parsed</span> <span class="p">{</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">mf</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="nx">gatherers</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Gatherers</span><span class="p">{</span>
	<span class="nx">reg</span><span class="p">,</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nf">GathererFunc</span><span class="p">(</span><span class="nx">parseText</span><span class="p">),</span>
<span class="p">}</span>

<span class="nx">gathering</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">gatherers</span><span class="p">.</span><span class="nf">Gather</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">out</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">{}</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">mf</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">gathering</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">expfmt</span><span class="p">.</span><span class="nf">MetricFamilyToText</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">mf</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="nx">out</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;----------&#34;</span><span class="p">)</span>

<span class="c1">// Note how the temperature_kelvin metric family has been merged from
</span><span class="c1">// different sources. Now try
</span><span class="c1"></span><span class="nx">text</span> <span class="p">=</span> <span class="s">`
</span><span class="s">## TYPE humidity_percent gauge
</span><span class="s">## HELP humidity_percent Humidity in %.
</span><span class="s">humidity_percent{location=&#34;outside&#34;} 45.4
</span><span class="s">humidity_percent{location=&#34;inside&#34;} 33.2
</span><span class="s">## TYPE temperature_kelvin gauge
</span><span class="s">## HELP temperature_kelvin Temperature in Kelvin.
</span><span class="s">## Duplicate metric:
</span><span class="s">temperature_kelvin{location=&#34;outside&#34;} 265.3
</span><span class="s"> ## Missing location label (note that this is undesirable but valid):
</span><span class="s">temperature_kelvin 4.5
</span><span class="s">`</span>

<span class="nx">gathering</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">gatherers</span><span class="p">.</span><span class="nf">Gather</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Note that still as many metrics as possible are returned:
</span><span class="c1"></span><span class="nx">out</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">mf</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">gathering</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">expfmt</span><span class="p">.</span><span class="nf">MetricFamilyToText</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">mf</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="nx">out</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span>
</code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">## HELP humidity_percent Humidity in %.
## TYPE humidity_percent gauge
humidity_percent{location=&#34;inside&#34;} 33.2
humidity_percent{location=&#34;outside&#34;} 45.4
## HELP temperature_kelvin Temperature in Kelvin.
## TYPE temperature_kelvin gauge
temperature_kelvin{location=&#34;inside&#34;} 298.44
temperature_kelvin{location=&#34;outside&#34;} 273.14
temperature_kelvin{location=&#34;somewhere else&#34;} 4.5
----------
collected metric &#34;temperature_kelvin&#34; { label:&lt;name:&#34;location&#34; value:&#34;outside&#34; &gt; gauge:&lt;value:265.3 &gt; } was collected before with the same name and label values
## HELP humidity_percent Humidity in %.
## TYPE humidity_percent gauge
humidity_percent{location=&#34;inside&#34;} 33.2
humidity_percent{location=&#34;outside&#34;} 45.4
## HELP temperature_kelvin Temperature in Kelvin.
## TYPE temperature_kelvin gauge
temperature_kelvin 4.5
temperature_kelvin{location=&#34;inside&#34;} 298.44
temperature_kelvin{location=&#34;outside&#34;} 273.14
</code></pre></td></tr></table>
</div>
</div><h3 id="func-gatherers-gather">func (Gatherers) Gather<a hidden class="anchor" aria-hidden="true" href="#func-gatherers-gather">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">gs</span> <span class="nx">Gatherers</span><span class="p">)</span> <span class="nf">Gather</span><span class="p">()</span> <span class="p">([]</span><span class="o">*</span><span class="nx">dto</span><span class="p">.</span><span class="nx">MetricFamily</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="type-labels">type Labels<a hidden class="anchor" aria-hidden="true" href="#type-labels">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Labels</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><p>标签代表标签名称-&gt;值映射的集合。此类型通常与度量矢量收集器的With（Labels）和GetMetricWith（Labels）方法一起使用，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">myVec</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;code&#34;</span><span class="p">:</span> <span class="s">&#34;404&#34;</span><span class="p">,</span> <span class="s">&#34;method&#34;</span><span class="p">:</span> <span class="s">&#34;GET&#34;</span><span class="p">}).</span><span class="nf">Add</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>另一个用例是在Opts中或创建Desc中指定常量标签对。</p>
<h2 id="type-metric">type Metric<a hidden class="anchor" aria-hidden="true" href="#type-metric">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Metric</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Desc returns the descriptor for the Metric. This method idempotently
</span><span class="c1"></span>	<span class="c1">// returns the same descriptor throughout the lifetime of the
</span><span class="c1"></span>	<span class="c1">// Metric. The returned descriptor is immutable by contract. A Metric
</span><span class="c1"></span>	<span class="c1">// unable to describe itself must return an invalid descriptor (created
</span><span class="c1"></span>	<span class="c1">// with NewInvalidDesc).
</span><span class="c1"></span>	<span class="nf">Desc</span><span class="p">()</span> <span class="o">*</span><span class="nx">Desc</span>
	<span class="c1">// Write encodes the Metric into a &#34;Metric&#34; Protocol Buffer data
</span><span class="c1"></span>	<span class="c1">// transmission object.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Metric implementations must observe concurrency safety as reads of
</span><span class="c1"></span>	<span class="c1">// this metric may occur at any time, and any blocking occurs at the
</span><span class="c1"></span>	<span class="c1">// expense of total performance of rendering all registered
</span><span class="c1"></span>	<span class="c1">// metrics. Ideally, Metric implementations should support concurrent
</span><span class="c1"></span>	<span class="c1">// readers.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// While populating dto.Metric, it is the responsibility of the
</span><span class="c1"></span>	<span class="c1">// implementation to ensure validity of the Metric protobuf (like valid
</span><span class="c1"></span>	<span class="c1">// UTF-8 strings or syntactically valid metric and label names). It is
</span><span class="c1"></span>	<span class="c1">// recommended to sort labels lexicographically. Callers of Write should
</span><span class="c1"></span>	<span class="c1">// still make sure of sorting if they depend on it.
</span><span class="c1"></span>	<span class="nf">Write</span><span class="p">(</span><span class="o">*</span><span class="nx">dto</span><span class="p">.</span><span class="nx">Metric</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Metric将单个样本值建模，并将其元数据导出到Prometheus。此程序包中Metric的实现是仪表，计数器，直方图，摘要和无类型的。</p>
<h3 id="func-mustnewconsthistogram">func MustNewConstHistogram<a hidden class="anchor" aria-hidden="true" href="#func-mustnewconsthistogram">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">MustNewConstHistogram</span><span class="p">(</span>
	<span class="nx">desc</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">,</span>
	<span class="nx">count</span> <span class="kt">uint64</span><span class="p">,</span>
	<span class="nx">sum</span> <span class="kt">float64</span><span class="p">,</span>
	<span class="nx">buckets</span> <span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">uint64</span><span class="p">,</span>
	<span class="nx">labelValues</span> <span class="o">...</span><span class="kt">string</span><span class="p">,</span>
<span class="p">)</span> <span class="nx">Metric</span>
</code></pre></td></tr></table>
</div>
</div><p>MustNewConstHistogram是NewConstHistogram的一个版本，它会惊慌于NewConstHistogram返回错误的地方。</p>
<h3 id="func-mustnewconstmetric">func MustNewConstMetric<a hidden class="anchor" aria-hidden="true" href="#func-mustnewconstmetric">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">MustNewConstMetric</span><span class="p">(</span><span class="nx">desc</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">,</span> <span class="nx">valueType</span> <span class="nx">ValueType</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">labelValues</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="nx">Metric</span>
</code></pre></td></tr></table>
</div>
</div><p>MustNewConstMetric是NewConstMetric的一个版本，它会惊慌于NewConstMetric返回错误的地方。</p>
<h3 id="func-mustnewconstsummary">func MustNewConstSummary<a hidden class="anchor" aria-hidden="true" href="#func-mustnewconstsummary">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">MustNewConstSummary</span><span class="p">(</span>
	<span class="nx">desc</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">,</span>
	<span class="nx">count</span> <span class="kt">uint64</span><span class="p">,</span>
	<span class="nx">sum</span> <span class="kt">float64</span><span class="p">,</span>
	<span class="nx">quantiles</span> <span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">float64</span><span class="p">,</span>
	<span class="nx">labelValues</span> <span class="o">...</span><span class="kt">string</span><span class="p">,</span>
<span class="p">)</span> <span class="nx">Metric</span>
</code></pre></td></tr></table>
</div>
</div><p>MustNewConstSummary是NewConstSummary的一个版本，它会惊慌，NewConstMetric将返回错误。</p>
<h3 id="func-newconsthistogram">func NewConstHistogram<a hidden class="anchor" aria-hidden="true" href="#func-newconsthistogram">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewConstHistogram</span><span class="p">(</span>
	<span class="nx">desc</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">,</span>
	<span class="nx">count</span> <span class="kt">uint64</span><span class="p">,</span>
	<span class="nx">sum</span> <span class="kt">float64</span><span class="p">,</span>
	<span class="nx">buckets</span> <span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">uint64</span><span class="p">,</span>
	<span class="nx">labelValues</span> <span class="o">...</span><span class="kt">string</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">Metric</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>NewConstHistogram返回一个表示Prometheus直方图的度量，该度量具有用于计数，总和和存储桶计数的固定值。由于无法更改这些参数，因此返回的值不会实现直方图接口（而只能实现公制接口）。使用此软件包的用户在常规操作中将不会使用太多。但是，在实现自定义收集器时，它是一种即用即弃的Metric，可以即时生成以用Collect方法将其发送给Prometheus。</p>
<p>buckets是上限到累积计数的映射，不包括+ Inf buckets。</p>
<p>如果labelValues的长度与Desc中的变量标签不一致，或者Desc无效，则NewConstHistogram返回错误。</p>
<p>例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">desc</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewDesc</span><span class="p">(</span>
	<span class="s">&#34;http_request_duration_seconds&#34;</span><span class="p">,</span>
	<span class="s">&#34;A histogram of the HTTP request durations.&#34;</span><span class="p">,</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;code&#34;</span><span class="p">,</span> <span class="s">&#34;method&#34;</span><span class="p">},</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;owner&#34;</span><span class="p">:</span> <span class="s">&#34;example&#34;</span><span class="p">},</span>
<span class="p">)</span>

<span class="c1">// Create a constant histogram from values we got from a 3rd party telemetry system.
</span><span class="c1"></span><span class="nx">h</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustNewConstHistogram</span><span class="p">(</span>
	<span class="nx">desc</span><span class="p">,</span>
	<span class="mi">4711</span><span class="p">,</span> <span class="mf">403.34</span><span class="p">,</span>
	<span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">uint64</span><span class="p">{</span><span class="mi">25</span><span class="p">:</span> <span class="mi">121</span><span class="p">,</span> <span class="mi">50</span><span class="p">:</span> <span class="mi">2403</span><span class="p">,</span> <span class="mi">100</span><span class="p">:</span> <span class="mi">3221</span><span class="p">,</span> <span class="mi">200</span><span class="p">:</span> <span class="mi">4233</span><span class="p">},</span>
	<span class="s">&#34;200&#34;</span><span class="p">,</span> <span class="s">&#34;get&#34;</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1">// Just for demonstration, let&#39;s check the state of the histogram by
</span><span class="c1">// (ab)using its Write method (which is usually only used by Prometheus
</span><span class="c1">// internally).
</span><span class="c1"></span><span class="nx">metric</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">dto</span><span class="p">.</span><span class="nx">Metric</span><span class="p">{}</span>
<span class="nx">h</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">metric</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">proto</span><span class="p">.</span><span class="nf">MarshalTextString</span><span class="p">(</span><span class="nx">metric</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">label: &lt;
  name: &#34;code&#34;
  value: &#34;200&#34;
&gt;
label: &lt;
  name: &#34;method&#34;
  value: &#34;get&#34;
&gt;
label: &lt;
  name: &#34;owner&#34;
  value: &#34;example&#34;
&gt;
histogram: &lt;
  sample_count: 4711
  sample_sum: 403.34
  bucket: &lt;
    cumulative_count: 121
    upper_bound: 25
  &gt;
  bucket: &lt;
    cumulative_count: 2403
    upper_bound: 50
  &gt;
  bucket: &lt;
    cumulative_count: 3221
    upper_bound: 100
  &gt;
  bucket: &lt;
    cumulative_count: 4233
    upper_bound: 200
  &gt;
&gt;
</code></pre></td></tr></table>
</div>
</div><h3 id="func-newconstmetric">func NewConstMetric<a hidden class="anchor" aria-hidden="true" href="#func-newconstmetric">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewConstMetric</span><span class="p">(</span><span class="nx">desc</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">,</span> <span class="nx">valueType</span> <span class="nx">ValueType</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">labelValues</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Metric</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>NewConstMetric返回具有一个固定值且无法更改的度量。使用此软件包的用户在常规操作中将不会使用太多。但是，在实现自定义收集器时，它是一种即时生成的一次性指标，可以通过Collect方法将其发送给Prometheus。如果labelValues的长度与Desc中的变量标签不一致，或者Desc无效，则NewConstMetric返回错误。</p>
<h3 id="func-newconstsummary">func NewConstSummary<a hidden class="anchor" aria-hidden="true" href="#func-newconstsummary">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewConstSummary</span><span class="p">(</span>
	<span class="nx">desc</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">,</span>
	<span class="nx">count</span> <span class="kt">uint64</span><span class="p">,</span>
	<span class="nx">sum</span> <span class="kt">float64</span><span class="p">,</span>
	<span class="nx">quantiles</span> <span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">float64</span><span class="p">,</span>
	<span class="nx">labelValues</span> <span class="o">...</span><span class="kt">string</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">Metric</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>NewConstSummary返回一个Metric，该Metric表示Prometheus摘要，其计数，总和和分位数具有固定值。由于无法更改这些参数，因此返回的值不会实现Summary接口（而只能实现Metric接口）。使用此软件包的用户在常规操作中将不会使用太多。但是，在实现自定义收集器时，它是一种即时生成的一次性指标，可以通过Collect方法将其发送给Prometheus。</p>
<p>分位数图将等级排名为分位数。例如，中值等待时间为0.23s，第99个百分位等待时间为0.56s表示为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">float64</span><span class="p">{</span><span class="mf">0.5</span><span class="p">:</span> <span class="mf">0.23</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">:</span> <span class="mf">0.56</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果labelValues的长度与Desc中的变量标签不一致，或者Desc无效，则NewConstSummary返回错误。</p>
<p>例子</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">desc</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewDesc</span><span class="p">(</span>
	<span class="s">&#34;http_request_duration_seconds&#34;</span><span class="p">,</span>
	<span class="s">&#34;A summary of the HTTP request durations.&#34;</span><span class="p">,</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;code&#34;</span><span class="p">,</span> <span class="s">&#34;method&#34;</span><span class="p">},</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;owner&#34;</span><span class="p">:</span> <span class="s">&#34;example&#34;</span><span class="p">},</span>
<span class="p">)</span>

<span class="c1">// Create a constant summary from values we got from a 3rd party telemetry system.
</span><span class="c1"></span><span class="nx">s</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustNewConstSummary</span><span class="p">(</span>
	<span class="nx">desc</span><span class="p">,</span>
	<span class="mi">4711</span><span class="p">,</span> <span class="mf">403.34</span><span class="p">,</span>
	<span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">float64</span><span class="p">{</span><span class="mf">0.5</span><span class="p">:</span> <span class="mf">42.3</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">:</span> <span class="mf">323.3</span><span class="p">},</span>
	<span class="s">&#34;200&#34;</span><span class="p">,</span> <span class="s">&#34;get&#34;</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1">// Just for demonstration, let&#39;s check the state of the summary by
</span><span class="c1">// (ab)using its Write method (which is usually only used by Prometheus
</span><span class="c1">// internally).
</span><span class="c1"></span><span class="nx">metric</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">dto</span><span class="p">.</span><span class="nx">Metric</span><span class="p">{}</span>
<span class="nx">s</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">metric</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">proto</span><span class="p">.</span><span class="nf">MarshalTextString</span><span class="p">(</span><span class="nx">metric</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">label: &lt;
  name: &#34;code&#34;
  value: &#34;200&#34;
&gt;
label: &lt;
  name: &#34;method&#34;
  value: &#34;get&#34;
&gt;
label: &lt;
  name: &#34;owner&#34;
  value: &#34;example&#34;
&gt;
summary: &lt;
  sample_count: 4711
  sample_sum: 403.34
  quantile: &lt;
    quantile: 0.5
    value: 42.3
  &gt;
  quantile: &lt;
    quantile: 0.9
    value: 323.3
  &gt;
&gt;
</code></pre></td></tr></table>
</div>
</div><h3 id="func-newinvalidmetric">func NewInvalidMetric<a hidden class="anchor" aria-hidden="true" href="#func-newinvalidmetric">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewInvalidMetric</span><span class="p">(</span><span class="nx">desc</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="nx">Metric</span>
</code></pre></td></tr></table>
</div>
</div><p>NewInvalidMetric返回一个指标，该指标的Write方法始终返回提供的错误。如果收集器发现自己无法收集Metric并希望向注册表报告错误，这将很有用。</p>
<h3 id="func-newmetricwithtimestamp">func NewMetricWithTimestamp<a hidden class="anchor" aria-hidden="true" href="#func-newmetricwithtimestamp">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewMetricWithTimestamp</span><span class="p">(</span><span class="nx">t</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">m</span> <span class="nx">Metric</span><span class="p">)</span> <span class="nx">Metric</span>
</code></pre></td></tr></table>
</div>
</div><p>NewMetricWithTimestamp返回一个新的Metric，该Metric以将显式时间戳记设置为所提供的Time的方式包装所提供的Metric。这仅在极少数情况下有用，因为PrometheusMetric的时间戳通常应由Prometheus服务器在抓取期间设置。例外情况包括具有来自其他Metric来源的给定时间戳的镜像Metric。</p>
<p>NewMetricWithTimestamp与MustNewConstMetric，MustNewConstHistogram和MustNewConstSummary一起使用效果最佳，请参见示例。</p>
<p>当前，Prometheus使用的展示格式仅限于毫秒分辨率。因此，提供的时间将舍入到下一个完整的毫秒值。</p>
<p>例子</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">desc</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewDesc</span><span class="p">(</span>
	<span class="s">&#34;temperature_kelvin&#34;</span><span class="p">,</span>
	<span class="s">&#34;Current temperature in Kelvin.&#34;</span><span class="p">,</span>
	<span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1">// Create a constant gauge from values we got from an external
</span><span class="c1">// temperature reporting system. Those values are reported with a slight
</span><span class="c1">// delay, so we want to add the timestamp of the actual measurement.
</span><span class="c1"></span><span class="nx">temperatureReportedByExternalSystem</span> <span class="o">:=</span> <span class="mf">298.15</span>
<span class="nx">timeReportedByExternalSystem</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Date</span><span class="p">(</span><span class="mi">2009</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">November</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">12345678</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">UTC</span><span class="p">)</span>
<span class="nx">s</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewMetricWithTimestamp</span><span class="p">(</span>
	<span class="nx">timeReportedByExternalSystem</span><span class="p">,</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustNewConstMetric</span><span class="p">(</span>
		<span class="nx">desc</span><span class="p">,</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeValue</span><span class="p">,</span> <span class="nx">temperatureReportedByExternalSystem</span><span class="p">,</span>
	<span class="p">),</span>
<span class="p">)</span>

<span class="c1">// Just for demonstration, let&#39;s check the state of the gauge by
</span><span class="c1">// (ab)using its Write method (which is usually only used by Prometheus
</span><span class="c1">// internally).
</span><span class="c1"></span><span class="nx">metric</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">dto</span><span class="p">.</span><span class="nx">Metric</span><span class="p">{}</span>
<span class="nx">s</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">metric</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">proto</span><span class="p">.</span><span class="nf">MarshalTextString</span><span class="p">(</span><span class="nx">metric</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">gauge: &lt;
  value: 298.15
&gt;
timestamp_ms: 1257894000012
</code></pre></td></tr></table>
</div>
</div><h2 id="type-multierror">type MultiError<a hidden class="anchor" aria-hidden="true" href="#type-multierror">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MultiError</span> <span class="p">[]</span><span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>MultiError是实现错误接口的错误片段。收集器使用它来报告MetricFamily收集期间的多个错误。</p>
<h3 id="func-multierror-append">func (*MultiError) Append<a hidden class="anchor" aria-hidden="true" href="#func-multierror-append">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">errs</span> <span class="o">*</span><span class="nx">MultiError</span><span class="p">)</span> <span class="nf">Append</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如果错误不是nil，则追加会附加提供的错误。</p>
<h3 id="func-multierror-error">func (MultiError) Error<a hidden class="anchor" aria-hidden="true" href="#func-multierror-error">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">errs</span> <span class="nx">MultiError</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="func-multierror-maybeunwrap">func (MultiError) MaybeUnwrap<a hidden class="anchor" aria-hidden="true" href="#func-multierror-maybeunwrap">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">errs</span> <span class="nx">MultiError</span><span class="p">)</span> <span class="nf">MaybeUnwrap</span><span class="p">()</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>如果len（errs）为0，则MaybeUnwrap返回nil。如果len（errs）为1，则返回第一个且仅包含错误的错误。在所有其他情况下，它直接返回MultiError。这对于以仅在需要时使用MultiError的方式返回MultiError很有帮助。</p>
<h2 id="type-observer">type Observer<a hidden class="anchor" aria-hidden="true" href="#type-observer">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Observer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Observe</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Observer是包装Observe方法的接口，直方图和摘要用于添加观察值。</p>
<h3 id="type-observerfunc">type ObserverFunc<a hidden class="anchor" aria-hidden="true" href="#type-observerfunc">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ObserverFunc</span> <span class="kd">func</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>ObserverFunc类型是一个适配器，允许将普通功能用作Observers。如果f是具有适当签名的函数，则ObserverFunc（f）是调用f的Observer。</p>
<p>此适配器通常与Timer类型结合使用，并且有两种常规使用情况：</p>
<p>最常见的一种是将仪表用作计时器的观察器。请参见“仪表”计时器示例。</p>
<p>更高级的用例是创建一个功能，该功能可动态决定使用哪个观察者来观察持续时间。请参见“复杂”计时器示例。</p>
<h3 id="func-observerfunc-observe">func (ObserverFunc) Observe<a hidden class="anchor" aria-hidden="true" href="#func-observerfunc-observe">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">ObserverFunc</span><span class="p">)</span> <span class="nf">Observe</span><span class="p">(</span><span class="nx">value</span> <span class="kt">float64</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Observe 调用 f(value)。它实现了observer。</p>
<h2 id="type-observervec">type ObserverVec<a hidden class="anchor" aria-hidden="true" href="#type-observervec">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ObserverVec</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">GetMetricWith</span><span class="p">(</span><span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="nx">Observer</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="nf">GetMetricWithLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Observer</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="nf">With</span><span class="p">(</span><span class="nx">Labels</span><span class="p">)</span> <span class="nx">Observer</span>
	<span class="nf">WithLabelValues</span><span class="p">(</span><span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="nx">Observer</span>
	<span class="nf">CurryWith</span><span class="p">(</span><span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="nx">ObserverVec</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="nf">MustCurryWith</span><span class="p">(</span><span class="nx">Labels</span><span class="p">)</span> <span class="nx">ObserverVec</span>

	<span class="nx">Collector</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ObserverVec是由“HistogramVec”和“SummaryVec”实现的接口。</p>
<h2 id="type-opts">type Opts<a hidden class="anchor" aria-hidden="true" href="#type-opts">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Opts</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Namespace, Subsystem, and Name are components of the fully-qualified
</span><span class="c1"></span>	<span class="c1">// name of the Metric (created by joining these components with
</span><span class="c1"></span>	<span class="c1">// &#34;_&#34;). Only Name is mandatory, the others merely help structuring the
</span><span class="c1"></span>	<span class="c1">// name. Note that the fully-qualified name of the metric must be a
</span><span class="c1"></span>	<span class="c1">// valid Prometheus metric name.
</span><span class="c1"></span>	<span class="nx">Namespace</span> <span class="kt">string</span>
	<span class="nx">Subsystem</span> <span class="kt">string</span>
	<span class="nx">Name</span>      <span class="kt">string</span>

	<span class="c1">// Help provides information about this metric.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Metrics with the same fully-qualified name must have the same Help
</span><span class="c1"></span>	<span class="c1">// string.
</span><span class="c1"></span>	<span class="nx">Help</span> <span class="kt">string</span>

	<span class="c1">// ConstLabels are used to attach fixed labels to this metric. Metrics
</span><span class="c1"></span>	<span class="c1">// with the same fully-qualified name must have the same label names in
</span><span class="c1"></span>	<span class="c1">// their ConstLabels.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// ConstLabels are only used rarely. In particular, do not use them to
</span><span class="c1"></span>	<span class="c1">// attach the same labels to all your metrics. Those use cases are
</span><span class="c1"></span>	<span class="c1">// better covered by target labels set by the scraping Prometheus
</span><span class="c1"></span>	<span class="c1">// server, or by one specific metric (e.g. a build_info or a
</span><span class="c1"></span>	<span class="c1">// machine_role metric). See also
</span><span class="c1"></span>	<span class="c1">// https://prometheus.io/docs/instrumenting/writing_exporters/#target-labels,-not-static-scraped-labels
</span><span class="c1"></span>	<span class="nx">ConstLabels</span> <span class="nx">Labels</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Opts捆绑了用于创建大多数指标类型的选项。每个度量实现XXX都有其自己的XXXOpts类型，但在大多数情况下，它只是该类型的别名（可能在需求出现时更改）。</p>
<p>必须将Name设置为非空字符串。尽管强烈建议您设置帮助字符串，但所有其他字段都是可选的，可以安全地保留其零值。</p>
<h2 id="type-processcollectoropts">type ProcessCollectorOpts<a hidden class="anchor" aria-hidden="true" href="#type-processcollectoropts">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ProcessCollectorOpts</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// PidFn returns the PID of the process the collector collects metrics
</span><span class="c1"></span>	<span class="c1">// for. It is called upon each collection. By default, the PID of the
</span><span class="c1"></span>	<span class="c1">// current process is used, as determined on construction time by
</span><span class="c1"></span>	<span class="c1">// calling os.Getpid().
</span><span class="c1"></span>	<span class="nx">PidFn</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="c1">// If non-empty, each of the collected metrics is prefixed by the
</span><span class="c1"></span>	<span class="c1">// provided string and an underscore (&#34;_&#34;).
</span><span class="c1"></span>	<span class="nx">Namespace</span> <span class="kt">string</span>
	<span class="c1">// If true, any error encountered during collection is reported as an
</span><span class="c1"></span>	<span class="c1">// invalid metric (see NewInvalidMetric). Otherwise, errors are ignored
</span><span class="c1"></span>	<span class="c1">// and the collected metrics will be incomplete. (Possibly, no metrics
</span><span class="c1"></span>	<span class="c1">// will be collected at all.) While that&#39;s usually not desired, it is
</span><span class="c1"></span>	<span class="c1">// appropriate for the common &#34;mix-in&#34; of process metrics, where process
</span><span class="c1"></span>	<span class="c1">// metrics are nice to have, but failing to collect them should not
</span><span class="c1"></span>	<span class="c1">// disrupt the collection of the remaining metrics.
</span><span class="c1"></span>	<span class="nx">ReportErrors</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ProcessCollectorOpts定义使用NewProcessCollector创建的过程指标收集器的行为。</p>
<h2 id="type-registerer">type Registerer<a hidden class="anchor" aria-hidden="true" href="#type-registerer">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Registerer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Register registers a new Collector to be included in metrics
</span><span class="c1"></span>	<span class="c1">// collection. It returns an error if the descriptors provided by the
</span><span class="c1"></span>	<span class="c1">// Collector are invalid or if they — in combination with descriptors of
</span><span class="c1"></span>	<span class="c1">// already registered Collectors — do not fulfill the consistency and
</span><span class="c1"></span>	<span class="c1">// uniqueness criteria described in the documentation of metric.Desc.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If the provided Collector is equal to a Collector already registered
</span><span class="c1"></span>	<span class="c1">// (which includes the case of re-registering the same Collector), the
</span><span class="c1"></span>	<span class="c1">// returned error is an instance of AlreadyRegisteredError, which
</span><span class="c1"></span>	<span class="c1">// contains the previously registered Collector.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// A Collector whose Describe method does not yield any Desc is treated
</span><span class="c1"></span>	<span class="c1">// as unchecked. Registration will always succeed. No check for
</span><span class="c1"></span>	<span class="c1">// re-registering (see previous paragraph) is performed. Thus, the
</span><span class="c1"></span>	<span class="c1">// caller is responsible for not double-registering the same unchecked
</span><span class="c1"></span>	<span class="c1">// Collector, and for providing a Collector that will not cause
</span><span class="c1"></span>	<span class="c1">// inconsistent metrics on collection. (This would lead to scrape
</span><span class="c1"></span>	<span class="c1">// errors.)
</span><span class="c1"></span>	<span class="nf">Register</span><span class="p">(</span><span class="nx">Collector</span><span class="p">)</span> <span class="kt">error</span>
	<span class="c1">// MustRegister works like Register but registers any number of
</span><span class="c1"></span>	<span class="c1">// Collectors and panics upon the first registration that causes an
</span><span class="c1"></span>	<span class="c1">// error.
</span><span class="c1"></span>	<span class="nf">MustRegister</span><span class="p">(</span><span class="o">...</span><span class="nx">Collector</span><span class="p">)</span>
	<span class="c1">// Unregister unregisters the Collector that equals the Collector passed
</span><span class="c1"></span>	<span class="c1">// in as an argument.  (Two Collectors are considered equal if their
</span><span class="c1"></span>	<span class="c1">// Describe method yields the same set of descriptors.) The function
</span><span class="c1"></span>	<span class="c1">// returns whether a Collector was unregistered. Note that an unchecked
</span><span class="c1"></span>	<span class="c1">// Collector cannot be unregistered (as its Describe method does not
</span><span class="c1"></span>	<span class="c1">// yield any descriptor).
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Note that even after unregistering, it will not be possible to
</span><span class="c1"></span>	<span class="c1">// register a new Collector that is inconsistent with the unregistered
</span><span class="c1"></span>	<span class="c1">// Collector, e.g. a Collector collecting metrics with the same name but
</span><span class="c1"></span>	<span class="c1">// a different help string. The rationale here is that the same registry
</span><span class="c1"></span>	<span class="c1">// instance must only collect consistent metrics throughout its
</span><span class="c1"></span>	<span class="c1">// lifetime.
</span><span class="c1"></span>	<span class="nf">Unregister</span><span class="p">(</span><span class="nx">Collector</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注册器是注册表中负责注册和注销的部分的接口。定制注册表的用户应将Registerer用作注册的类型（而不是直接使用Registry类型）。这样，他们可以自由使用自定义的Registerer实现（例如，出于测试目的）。</p>
<h3 id="func-wrapregistererwith">func WrapRegistererWith<a hidden class="anchor" aria-hidden="true" href="#func-wrapregistererwith">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WrapRegistererWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">,</span> <span class="nx">reg</span> <span class="nx">Registerer</span><span class="p">)</span> <span class="nx">Registerer</span>
</code></pre></td></tr></table>
</div>
</div><p>WrapRegistererWith返回包装提供的注册器的注册器。在返回的注册器中注册的收集器将以修改后的方式在包装的注册器中注册。修改后的收集器会将提供的标签添加到它收集的所有Metric中（作为ConstLabels）。未经修改的收集器收集的Metric不得重复任何这些标签。包装一个nil值是有效的，导致没有操作的register。</p>
<p>WrapRegistererWith提供了一种向收集器的子集添加固定标签的方法。不应将其用于向所有公开的指标添加固定标签。</p>
<p>仍将检测到通过原始注册器注册的收集器与通过包装注册器注册的收集器之间的冲突。由任一注册器的Register方法返回的任何AlreadyRegisteredError都将包含ExistingCollector，其形式已提供给相应的注册表。</p>
<p>收集器示例演示了WrapRegistererWith的用法。</p>
<h3 id="func-wrapregistererwithprefix">func WrapRegistererWithPrefix<a hidden class="anchor" aria-hidden="true" href="#func-wrapregistererwithprefix">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WrapRegistererWithPrefix</span><span class="p">(</span><span class="nx">prefix</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">reg</span> <span class="nx">Registerer</span><span class="p">)</span> <span class="nx">Registerer</span>
</code></pre></td></tr></table>
</div>
</div><p>WrapRegistererWithPrefix返回包装提供的注册器的注册器。在返回的注册器中注册的收集器将以修改后的方式在包装的注册器中注册。修改后的收集器会将提供的前缀添加到它收集的所有Metric的名称中。包装一个nil值是有效的，导致没有操作寄存器。</p>
<p>WrapRegistererWithPrefix对于在一个子系统前面放置所有度量的前缀很有用。为此，请使用WrapRegistererWithPrefix返回的包装注册器注册子系统的度量。对于所有公开的指标，使用相同的前缀很少有用。特别是，不要在跨应用程序标准化的Metric名称前添加前缀，因为这会破坏水平监视，例如Go收集器（请参阅NewGoCollector）和流程收集器（请参阅NewProcessCollector）提供的Metric。（实际上，这些指标已经分别以“ go_”或“ process_”为前缀。）</p>
<p>仍将检测到通过原始注册器注册的收集器与通过包装注册器注册的收集器之间的冲突。由任一注册器的Register方法返回的任何AlreadyRegisteredError都将包含ExistingCollector，其形式已提供给相应的注册表。</p>
<h2 id="type-registry">type Registry<a hidden class="anchor" aria-hidden="true" href="#type-registry">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Registry</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注册表注册Prometheus收集器，收集其度量，然后将其收集到MetricFamilies中进行说明。它同时实现了Registerer和Gatherer。零值不可用。使用NewRegistry或NewPedanticRegistry创建实例。</p>
<h3 id="func-newpedanticregistry">func NewPedanticRegistry<a hidden class="anchor" aria-hidden="true" href="#func-newpedanticregistry">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewPedanticRegistry</span><span class="p">()</span> <span class="o">*</span><span class="nx">Registry</span>
</code></pre></td></tr></table>
</div>
</div><p>NewPedanticRegistry返回一个注册表，该注册表在收集期间检查每个收集的指标是否与其报告的Desc一致，以及Desc是否实际上已在注册表中注册。未检查的收集器（其Describe方法不产生任何描述符的收集器）从检查中排除。</p>
<p>通常，只要所有收集的Metric的并集一致且有效，即使某些Metric与其自己的Desc或由其注册收集者提供的Desc不一致，注册管理机构也会很高兴。行为良好的收集器和指标只会提供一致的描述。该注册表对于测试收集器和Metric的实现很有用。</p>
<h3 id="func-newregistry">func NewRegistry<a hidden class="anchor" aria-hidden="true" href="#func-newregistry">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewRegistry</span><span class="p">()</span> <span class="o">*</span><span class="nx">Registry</span>
</code></pre></td></tr></table>
</div>
</div><p>NewRegistry会创建一个新的普通注册表，而无需预先注册任何收集器。</p>
<h3 id="func-registry-gather">func (*Registry) Gather<a hidden class="anchor" aria-hidden="true" href="#func-registry-gather">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Registry</span><span class="p">)</span> <span class="nf">Gather</span><span class="p">()</span> <span class="p">([]</span><span class="o">*</span><span class="nx">dto</span><span class="p">.</span><span class="nx">MetricFamily</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Gather实现Gatherer。</p>
<h3 id="func-registry-mustregister">func (*Registry) MustRegister<a hidden class="anchor" aria-hidden="true" href="#func-registry-mustregister">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Registry</span><span class="p">)</span> <span class="nf">MustRegister</span><span class="p">(</span><span class="nx">cs</span> <span class="o">...</span><span class="nx">Collector</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>MustRegister实现Registerer。</p>
<h3 id="func-registry-register">func (*Registry) Register<a hidden class="anchor" aria-hidden="true" href="#func-registry-register">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Registry</span><span class="p">)</span> <span class="nf">Register</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Collector</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>Register实现Registerer。</p>
<h3 id="func-registry-unregister">func (*Registry) Unregister<a hidden class="anchor" aria-hidden="true" href="#func-registry-unregister">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Registry</span><span class="p">)</span> <span class="nf">Unregister</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Collector</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>Unregister 实现 Registerer.</p>
<h2 id="type-timer">type Timer<a hidden class="anchor" aria-hidden="true" href="#type-timer">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Timer</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>计时器是计时功能的辅助类型。使用NewTimer创建新实例。</p>
<p>例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">Code</span><span class="p">:</span>

<span class="kn">package</span> <span class="nx">prometheus_test</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;math/rand&#34;</span>
	<span class="s">&#34;time&#34;</span>

	<span class="s">&#34;github.com/prometheus/client_golang/prometheus&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">requestDuration</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewHistogram</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>    <span class="s">&#34;example_request_duration_seconds&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>    <span class="s">&#34;Histogram for the runtime of a simple example function.&#34;</span><span class="p">,</span>
		<span class="nx">Buckets</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">LinearBuckets</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
	<span class="p">})</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">ExampleTimer</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// timer times this example function. It uses a Histogram, but a Summary
</span><span class="c1"></span>	<span class="c1">// would also work, as both implement Observer. Check out
</span><span class="c1"></span>	<span class="c1">// https://prometheus.io/docs/practices/histograms/ for differences.
</span><span class="c1"></span>	<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">requestDuration</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">timer</span><span class="p">.</span><span class="nf">ObserveDuration</span><span class="p">()</span>

	<span class="c1">// Do something here that takes time.
</span><span class="c1"></span>	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">NormFloat64</span><span class="p">()</span><span class="o">*</span><span class="mi">10000</span><span class="o">+</span><span class="mi">50000</span><span class="p">)</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Microsecond</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>示例（复杂）</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">prometheus_test</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/prometheus/client_golang/prometheus&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="c1">// apiRequestDuration tracks the duration separate for each HTTP status
</span><span class="c1"></span>	<span class="c1">// class (1xx, 2xx, ...). This creates a fair amount of time series on
</span><span class="c1"></span>	<span class="c1">// the Prometheus server. Usually, you would track the duration of
</span><span class="c1"></span>	<span class="c1">// serving HTTP request without partitioning by outcome. Do something
</span><span class="c1"></span>	<span class="c1">// like this only if needed. Also note how only status classes are
</span><span class="c1"></span>	<span class="c1">// tracked, not every single status code. The latter would create an
</span><span class="c1"></span>	<span class="c1">// even larger amount of time series. Request counters partitioned by
</span><span class="c1"></span>	<span class="c1">// status code are usually OK as each counter only creates one time
</span><span class="c1"></span>	<span class="c1">// series. Histograms are way more expensive, so partition with care and
</span><span class="c1"></span>	<span class="c1">// only where you really need separate latency tracking. Partitioning by
</span><span class="c1"></span>	<span class="c1">// status class is only an example. In concrete cases, other partitions
</span><span class="c1"></span>	<span class="c1">// might make more sense.
</span><span class="c1"></span>	<span class="nx">apiRequestDuration</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewHistogramVec</span><span class="p">(</span>
		<span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramOpts</span><span class="p">{</span>
			<span class="nx">Name</span><span class="p">:</span>    <span class="s">&#34;api_request_duration_seconds&#34;</span><span class="p">,</span>
			<span class="nx">Help</span><span class="p">:</span>    <span class="s">&#34;Histogram for the request duration of the public API, partitioned by status class.&#34;</span><span class="p">,</span>
			<span class="nx">Buckets</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">ExponentialBuckets</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
		<span class="p">},</span>
		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;status_class&#34;</span><span class="p">},</span>
	<span class="p">)</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">handler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">status</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span>
	<span class="c1">// The ObserverFunc gets called by the deferred ObserveDuration and
</span><span class="c1"></span>	<span class="c1">// decides which Histogram&#39;s Observe method is called.
</span><span class="c1"></span>	<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nf">ObserverFunc</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">v</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">status</span> <span class="o">&gt;=</span> <span class="mi">500</span><span class="p">:</span> <span class="c1">// Server error.
</span><span class="c1"></span>			<span class="nx">apiRequestDuration</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;5xx&#34;</span><span class="p">).</span><span class="nf">Observe</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">status</span> <span class="o">&gt;=</span> <span class="mi">400</span><span class="p">:</span> <span class="c1">// Client error.
</span><span class="c1"></span>			<span class="nx">apiRequestDuration</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;4xx&#34;</span><span class="p">).</span><span class="nf">Observe</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">status</span> <span class="o">&gt;=</span> <span class="mi">300</span><span class="p">:</span> <span class="c1">// Redirection.
</span><span class="c1"></span>			<span class="nx">apiRequestDuration</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;3xx&#34;</span><span class="p">).</span><span class="nf">Observe</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">status</span> <span class="o">&gt;=</span> <span class="mi">200</span><span class="p">:</span> <span class="c1">// Success.
</span><span class="c1"></span>			<span class="nx">apiRequestDuration</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;2xx&#34;</span><span class="p">).</span><span class="nf">Observe</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
		<span class="k">default</span><span class="p">:</span> <span class="c1">// Informational.
</span><span class="c1"></span>			<span class="nx">apiRequestDuration</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;1xx&#34;</span><span class="p">).</span><span class="nf">Observe</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}))</span>
	<span class="k">defer</span> <span class="nx">timer</span><span class="p">.</span><span class="nf">ObserveDuration</span><span class="p">()</span>

	<span class="c1">// Handle the request. Set status accordingly.
</span><span class="c1"></span>	<span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">ExampleTimer_complex</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/api&#34;</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>示例（量规）</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">prometheus_test</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;os&#34;</span>

	<span class="s">&#34;github.com/prometheus/client_golang/prometheus&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="c1">// If a function is called rarely (i.e. not more often than scrapes
</span><span class="c1"></span>	<span class="c1">// happen) or ideally only once (like in a batch job), it can make sense
</span><span class="c1"></span>	<span class="c1">// to use a Gauge for timing the function call. For timing a batch job
</span><span class="c1"></span>	<span class="c1">// and pushing the result to a Pushgateway, see also the comprehensive
</span><span class="c1"></span>	<span class="c1">// example in the push package.
</span><span class="c1"></span>	<span class="nx">funcDuration</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewGauge</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;example_function_duration_seconds&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span> <span class="s">&#34;Duration of the last call of an example function.&#34;</span><span class="p">,</span>
	<span class="p">})</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">// The Set method of the Gauge is used to observe the duration.
</span><span class="c1"></span>	<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nf">ObserverFunc</span><span class="p">(</span><span class="nx">funcDuration</span><span class="p">.</span><span class="nx">Set</span><span class="p">))</span>
	<span class="k">defer</span> <span class="nx">timer</span><span class="p">.</span><span class="nf">ObserveDuration</span><span class="p">()</span>

	<span class="c1">// Do something. Return errors as encountered. The use of &#39;defer&#39; above
</span><span class="c1"></span>	<span class="c1">// makes sure the function is still timed properly.
</span><span class="c1"></span>	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ExampleTimer_gauge</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">run</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="func-newtimer">func NewTimer<a hidden class="anchor" aria-hidden="true" href="#func-newtimer">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewTimer</span><span class="p">(</span><span class="nx">o</span> <span class="nx">Observer</span><span class="p">)</span> <span class="o">*</span><span class="nx">Timer</span>
</code></pre></td></tr></table>
</div>
</div><p>NewTimer创建一个新的计时器。提供的观察者用于观察持续时间（以秒为单位）。计时器通常用于通过以下方式为函数调用计时：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TimeMe</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">timer</span> <span class="o">:=</span> <span class="nf">NewTimer</span><span class="p">(</span><span class="nx">myHistogram</span><span class="p">)</span>
    <span class="k">defer</span> <span class="nx">timer</span><span class="p">.</span><span class="nf">ObserveDuration</span><span class="p">()</span>
    <span class="c1">// Do actual work.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="func-timer-observeduration">func (*Timer) ObserveDuration<a hidden class="anchor" aria-hidden="true" href="#func-timer-observeduration">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Timer</span><span class="p">)</span> <span class="nf">ObserveDuration</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
</code></pre></td></tr></table>
</div>
</div><p>ObserveDuration记录自使用NewTimer创建计时器以来经过的持续时间。它调用构造期间提供的Observer的Observe方法，以持续时间（以秒为单位）作为参数。观察到的持续时间也将返回。通常使用defer语句调用ObserveDuration。</p>
<p>请注意，只有与Go1.9+一起使用时，才能保证此方法永远不会观察到负持续时间。</p>
<h2 id="type-untypedfunc">type UntypedFunc<a hidden class="anchor" aria-hidden="true" href="#type-untypedfunc">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">UntypedFunc</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Metric</span>
	<span class="nx">Collector</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>UntypedFunc的作用类似于GaugeFunc，但收集的指标类型为“Untyped”。UntypedFunc可用于镜像未知类型的外部指标。</p>
<p>要创建UntypedFunc实例，请使用NewUntypedFunc。</p>
<h3 id="func-newuntypedfunc">func NewUntypedFunc<a hidden class="anchor" aria-hidden="true" href="#func-newuntypedfunc">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewUntypedFunc</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">UntypedOpts</span><span class="p">,</span> <span class="nx">function</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">float64</span><span class="p">)</span> <span class="nx">UntypedFunc</span>
</code></pre></td></tr></table>
</div>
</div><p>NewUntypedFunc基于提供的UntypedOpts创建一个新的UntypedFunc。报告的值是通过在Write方法中调用给定的函数确定的。考虑到指标收集可能会同时发生。如果这导致对Write的并发调用，例如在UntypedFunc直接向Prometheus注册的情况下，则提供的函数必须是并发安全的。</p>
<pre><code>type UntypedOpts
</code></pre>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">UntypedOpts</span> <span class="nx">Opts</span>
</code></pre></td></tr></table>
</div>
</div><p>UntypedOpts是Opts的别名。请参阅此处以获取文档注释。</p>
<h2 id="type-valuetype">type ValueType<a hidden class="anchor" aria-hidden="true" href="#type-valuetype">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ValueType</span> <span class="kt">int</span>
</code></pre></td></tr></table>
</div>
</div><p>ValueType是代表简单值的指标类型的枚举。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">CounterValue</span> <span class="nx">ValueType</span>
	<span class="nx">GaugeValue</span>
	<span class="nx">UntypedValue</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>ValueType枚举的可能值。使用UntypedValue可以将指标标记为未知类型。</p>
<h1 id="promhttp包">promhttp包<a hidden class="anchor" aria-hidden="true" href="#promhttp包">#</a></h1>
<h2 id="概述-1">概述<a hidden class="anchor" aria-hidden="true" href="#概述-1">#</a></h2>
<p>软件包promhttp提供了围绕HTTP服务器和客户端的工具。</p>
<p>首先，该包允许创建http.Handler实例以通过HTTP公开Prometheus指标。promhttp.Handler作用于prometheus.DefaultGatherer。使用HandlerFor，您可以为自定义注册表或实现Gatherer接口的任何内容创建处理程序。它还允许创建对错误采取不同行动或允许记录错误的处理程序。</p>
<p>其次，该软件包提供了通过中间件来检测http.Handler实例的工具。中间件包装器遵循命名方案InstrumentHandlerX，其中X描述了中间件的预期用途。有关详细信息，请参见每个函数的文档注释。</p>
<p>最后，该程序包允许通过中间件检测http.RoundTripper。中间件包装器遵循InstrumentRoundTripperX的命名方案，其中X描述了中间件的预期用途。有关详细信息，请参见每个函数的文档注释。</p>
<h2 id="func-handler">func Handler<a hidden class="anchor" aria-hidden="true" href="#func-handler">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Handler</span><span class="p">()</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span>
</code></pre></td></tr></table>
</div>
</div><p>处理程序使用默认的HandlerOpts返回prometheus.DefaultGatherer的http.Handler，即，它将第一个错误报告为HTTP错误，没有错误日志记录，并且如果客户端请求，则应用压缩。</p>
<p>返回的http.Handler已经使用InstrumentMetricHandler函数和prometheus.DefaultRegisterer进行了检测。如果通过分别调用Handler函数创建多个http.Handlers，则用于检测的度量将在它们之间共享，从而提供全局的scrape计数。</p>
<p>此func旨在涵盖大部分基本用例。如果您要执行需要更多自定义的操作（包括使用非默认的Gatherer，不同的instrumentation和非默认的HandlerOpts），请使用HandlerFor函数。有关详细信息，请参见此处。</p>
<h2 id="func-handlerfor">func HandlerFor<a hidden class="anchor" aria-hidden="true" href="#func-handlerfor">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">HandlerFor</span><span class="p">(</span><span class="nx">reg</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Gatherer</span><span class="p">,</span> <span class="nx">opts</span> <span class="nx">HandlerOpts</span><span class="p">)</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span>
</code></pre></td></tr></table>
</div>
</div><p>HandlerFor为提供的Gatherer返回一个非instrumentation化的http.Handler。处理程序的行为由提供的HandlerOpts定义。因此，HandlerFor对于使用非默认HandlerOpts和/或使用自定义（或没有自定义）instrumentation的自定义收集器创建http.Handlers很有用。使用InstrumentMetricHandler函数可以应用与Handler函数所使用的相同类型的检测。</p>
<h2 id="func-instrumenthandlercounter">func InstrumentHandlerCounter<a hidden class="anchor" aria-hidden="true" href="#func-instrumenthandlercounter">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">InstrumentHandlerCounter</span><span class="p">(</span><span class="nx">counter</span> <span class="o">*</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterVec</span><span class="p">,</span> <span class="nx">next</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span><span class="p">)</span> <span class="nx">http</span><span class="p">.</span><span class="nx">HandlerFunc</span>
</code></pre></td></tr></table>
</div>
</div><p>InstrumentHandlerCounter是一个中间件，包装了提供的http.Handler以使用提供的CounterVec观察请求结果。CounterVec必须具有零，一或两个非const非咖喱标签。对于这些标签，唯一允许的标签名称是“代码”和“方法”。否则，该功能会出现问题。如果CounterVec中存在相应的实例标签名称，则可以通过HTTP状态代码和/或HTTP方法对CounterVec进行分区。对于未分区的计数，请使用带有零标签的CounterVec。</p>
<p>如果包装的Handler未设置状态码，则假定状态码为200。</p>
<p>如果包装的处理程序出现紧急情况，则计数器不会增加。</p>
<p>有关用法示例，请参见InstrumentHandlerDuration的示例。</p>
<h2 id="func-instrumenthandlerduration">func InstrumentHandlerDuration<a hidden class="anchor" aria-hidden="true" href="#func-instrumenthandlerduration">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">InstrumentHandlerDuration</span><span class="p">(</span><span class="nx">obs</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">ObserverVec</span><span class="p">,</span> <span class="nx">next</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span><span class="p">)</span> <span class="nx">http</span><span class="p">.</span><span class="nx">HandlerFunc</span>
</code></pre></td></tr></table>
</div>
</div><p>InstrumentHandlerDuration是一个中间件，该中间件包装提供的http.Handler以观察提供的ObserverVec的请求持续时间。ObserverVec必须具有零，一或两个非const非咖喱标签。对于这些标签，唯一允许的标签名称是“code”和“method”。否则，该功能会出现问题。调用ObserverVec中的Observer的Observe方法时，请求持续时间以秒为单位。如果ObserverVec中存在相应的实例标签名称，则通过HTTP状态代码和/或HTTP方法进行分区。对于未分区的观察，请使用带有零标签的ObserverVec。请注意，直方图的划分是昂贵的，应谨慎使用。</p>
<p>如果包装的Handler未设置状态码，则假定状态码为200。</p>
<p>如果包装的处理程序出现紧急情况，则不会报告任何值。</p>
<p>请注意，只有与Go1.9 +一起使用时，才能保证此方法永远不会观察到负持续时间。</p>
<p>例子</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">inFlightGauge</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewGauge</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">{</span>
	<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;in_flight_requests&#34;</span><span class="p">,</span>
	<span class="nx">Help</span><span class="p">:</span> <span class="s">&#34;A gauge of requests currently being served by the wrapped handler.&#34;</span><span class="p">,</span>
<span class="p">})</span>

<span class="nx">counter</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewCounterVec</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;api_requests_total&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span> <span class="s">&#34;A counter for requests to the wrapped handler.&#34;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;code&#34;</span><span class="p">,</span> <span class="s">&#34;method&#34;</span><span class="p">},</span>
<span class="p">)</span>

<span class="c1">// duration is partitioned by the HTTP method and handler. It uses custom
</span><span class="c1">// buckets based on the expected request duration.
</span><span class="c1"></span><span class="nx">duration</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewHistogramVec</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>    <span class="s">&#34;request_duration_seconds&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>    <span class="s">&#34;A histogram of latencies for requests.&#34;</span><span class="p">,</span>
		<span class="nx">Buckets</span><span class="p">:</span> <span class="p">[]</span><span class="kt">float64</span><span class="p">{</span><span class="mf">.25</span><span class="p">,</span> <span class="mf">.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">},</span>
	<span class="p">},</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;handler&#34;</span><span class="p">,</span> <span class="s">&#34;method&#34;</span><span class="p">},</span>
<span class="p">)</span>

<span class="c1">// responseSize has no labels, making it a zero-dimensional
</span><span class="c1">// ObserverVec.
</span><span class="c1"></span><span class="nx">responseSize</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewHistogramVec</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>    <span class="s">&#34;response_size_bytes&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>    <span class="s">&#34;A histogram of response sizes for requests.&#34;</span><span class="p">,</span>
		<span class="nx">Buckets</span><span class="p">:</span> <span class="p">[]</span><span class="kt">float64</span><span class="p">{</span><span class="mi">200</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">900</span><span class="p">,</span> <span class="mi">1500</span><span class="p">},</span>
	<span class="p">},</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{},</span>
<span class="p">)</span>

<span class="c1">// Create the handlers that will be wrapped by the middleware.
</span><span class="c1"></span><span class="nx">pushHandler</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">HandlerFunc</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;Push&#34;</span><span class="p">))</span>
<span class="p">})</span>
<span class="nx">pullHandler</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">HandlerFunc</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;Pull&#34;</span><span class="p">))</span>
<span class="p">})</span>

<span class="c1">// Register all of the metrics in the standard registry.
</span><span class="c1"></span><span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">inFlightGauge</span><span class="p">,</span> <span class="nx">counter</span><span class="p">,</span> <span class="nx">duration</span><span class="p">,</span> <span class="nx">responseSize</span><span class="p">)</span>

<span class="c1">// Instrument the handlers with all the metrics, injecting the &#34;handler&#34;
</span><span class="c1">// label by currying.
</span><span class="c1"></span><span class="nx">pushChain</span> <span class="o">:=</span> <span class="nf">InstrumentHandlerInFlight</span><span class="p">(</span><span class="nx">inFlightGauge</span><span class="p">,</span>
	<span class="nf">InstrumentHandlerDuration</span><span class="p">(</span><span class="nx">duration</span><span class="p">.</span><span class="nf">MustCurryWith</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;handler&#34;</span><span class="p">:</span> <span class="s">&#34;push&#34;</span><span class="p">}),</span>
		<span class="nf">InstrumentHandlerCounter</span><span class="p">(</span><span class="nx">counter</span><span class="p">,</span>
			<span class="nf">InstrumentHandlerResponseSize</span><span class="p">(</span><span class="nx">responseSize</span><span class="p">,</span> <span class="nx">pushHandler</span><span class="p">),</span>
		<span class="p">),</span>
	<span class="p">),</span>
<span class="p">)</span>
<span class="nx">pullChain</span> <span class="o">:=</span> <span class="nf">InstrumentHandlerInFlight</span><span class="p">(</span><span class="nx">inFlightGauge</span><span class="p">,</span>
	<span class="nf">InstrumentHandlerDuration</span><span class="p">(</span><span class="nx">duration</span><span class="p">.</span><span class="nf">MustCurryWith</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;handler&#34;</span><span class="p">:</span> <span class="s">&#34;pull&#34;</span><span class="p">}),</span>
		<span class="nf">InstrumentHandlerCounter</span><span class="p">(</span><span class="nx">counter</span><span class="p">,</span>
			<span class="nf">InstrumentHandlerResponseSize</span><span class="p">(</span><span class="nx">responseSize</span><span class="p">,</span> <span class="nx">pullHandler</span><span class="p">),</span>
		<span class="p">),</span>
	<span class="p">),</span>
<span class="p">)</span>

<span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/metrics&#34;</span><span class="p">,</span> <span class="nf">Handler</span><span class="p">())</span>
<span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/push&#34;</span><span class="p">,</span> <span class="nx">pushChain</span><span class="p">)</span>
<span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/pull&#34;</span><span class="p">,</span> <span class="nx">pullChain</span><span class="p">)</span>

<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:3000&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-instrumenthandlerinflight">func InstrumentHandlerInFlight<a hidden class="anchor" aria-hidden="true" href="#func-instrumenthandlerinflight">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">InstrumentHandlerInFlight</span><span class="p">(</span><span class="nx">g</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Gauge</span><span class="p">,</span> <span class="nx">next</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span><span class="p">)</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span>
</code></pre></td></tr></table>
</div>
</div><p>InstrumentHandlerInFlight是包装提供的http.Handler的中间件。它将提供的prometheus.Gauge设置为当前由包装的http.Handler处理的请求数。</p>
<p>有关用法示例，请参见InstrumentHandlerDuration的示例。</p>
<h2 id="func-instrumenthandlerrequestsize">func InstrumentHandlerRequestSize<a hidden class="anchor" aria-hidden="true" href="#func-instrumenthandlerrequestsize">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">InstrumentHandlerRequestSize</span><span class="p">(</span><span class="nx">obs</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">ObserverVec</span><span class="p">,</span> <span class="nx">next</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span><span class="p">)</span> <span class="nx">http</span><span class="p">.</span><span class="nx">HandlerFunc</span>
</code></pre></td></tr></table>
</div>
</div><p>InstrumentHandlerRequestSize是一个中间件，该中间件包装提供的http.Handler以观察提供的ObserverVec的请求大小。ObserverVec必须具有零，一或两个非const非咖喱标签。对于这些标签，唯一允许的标签名称是“code”和“method”。否则，该功能会出现问题。调用ObserverVec中的Observer的Observe方法时，请求大小以字节为单位。如果ObserverVec中存在相应的实例标签名称，则通过HTTP状态代码和/或HTTP方法进行分区。对于未分区的观察，请使用带有零标签的ObserverVec。请注意，直方图的划分是昂贵的，应谨慎使用。</p>
<p>如果包装的Handler未设置状态码，则假定状态码为200。</p>
<p>如果包装的处理程序出现紧急情况，则不会报告任何值。</p>
<p>有关用法示例，请参见InstrumentHandlerDuration的示例。</p>
<h2 id="func-instrumenthandlerresponsesize">func InstrumentHandlerResponseSize<a hidden class="anchor" aria-hidden="true" href="#func-instrumenthandlerresponsesize">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">InstrumentHandlerResponseSize</span><span class="p">(</span><span class="nx">obs</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">ObserverVec</span><span class="p">,</span> <span class="nx">next</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span><span class="p">)</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span>
</code></pre></td></tr></table>
</div>
</div><p>InstrumentHandlerResponseSize是一个中间件，包装了提供的http.Handler以观察提供的ObserverVec的响应大小。ObserverVec必须具有零，一或两个非const非咖喱标签。对于这些标签，唯一允许的标签名称是“code”和“method”。否则，该功能会出现问题。调用ObserverVec中的Observer的Observe方法，其响应大小以字节为单位。如果ObserverVec中存在相应的实例标签名称，则通过HTTP状态代码和/或HTTP方法进行分区。对于未分区的观察，请使用带有零标签的ObserverVec。请注意，直方图的划分是昂贵的，应谨慎使用。</p>
<p>如果包装的Handler未设置状态码，则假定状态码为200。</p>
<p>如果包装的处理程序出现紧急情况，则不会报告任何值。</p>
<p>有关用法示例，请参见InstrumentHandlerDuration的示例。</p>
<h2 id="func-instrumenthandlertimetowriteheader">func InstrumentHandlerTimeToWriteHeader<a hidden class="anchor" aria-hidden="true" href="#func-instrumenthandlertimetowriteheader">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">InstrumentHandlerTimeToWriteHeader</span><span class="p">(</span><span class="nx">obs</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">ObserverVec</span><span class="p">,</span> <span class="nx">next</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span><span class="p">)</span> <span class="nx">http</span><span class="p">.</span><span class="nx">HandlerFunc</span>
</code></pre></td></tr></table>
</div>
</div><p>InstrumentHandlerTimeToWriteHeader是一个中间件，包装了提供的http.Handler，以使用提供的ObserverVec观察请求持续时间，直到写入响应标头为止。ObserverVec必须具有零，一或两个非const非咖喱标签。对于这些标签，唯一允许的标签名称是“code”和“method”。否则，该功能会出现问题。调用ObserverVec中的Observer的Observe方法时，请求持续时间以秒为单位。如果ObserverVec中存在相应的实例标签名称，则通过HTTP状态代码和/或HTTP方法进行分区。对于未分区的观察，请使用带有零标签的ObserverVec。请注意，直方图的划分是昂贵的，应谨慎使用。</p>
<p>如果包装的Handler在调用WriteHeader之前发生了混乱，则不会报告任何值。</p>
<p>请注意，只有与Go1.9 +一起使用时，才能保证此方法永远不会观察到负持续时间。</p>
<p>有关用法示例，请参见InstrumentHandlerDuration的示例。</p>
<h2 id="func-instrumentmetrichandler">func InstrumentMetricHandler<a hidden class="anchor" aria-hidden="true" href="#func-instrumentmetrichandler">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">InstrumentMetricHandler</span><span class="p">(</span><span class="nx">reg</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Registerer</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span><span class="p">)</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span>
</code></pre></td></tr></table>
</div>
</div><p>InstrumentMetricHandler通常与HandlerFor函数返回的http.Handler一起使用。它使用两个度量为提供的http.Handler进行检测：一个计数器向量“promhttp_metric_handler_requests_total”对按HTTP状态码划分的scrapes进行计数，而量规“promhttp_metric_handler_requests_in_flight”则用于跟踪同时进行的scrapes数量。此功能使用提供的注册器为两个指标均等地注册收集器。如果注册失败，它将感到恐慌。所提供的度量标准对于查看有多少scrapes被监视目标（可能来自不同的Prometheus服务器或其他scrapes），以及它们重叠的频率（将导致同时有多个scrapes在飞行中）非常有用。请注意，飞行中的刮擦量具将包含其暴露的刮擦，而刮擦计数器仅在刮擦完成后才会递增（因为只有这样才能知道状态码）。要跟踪刮擦时间，请使用Prometheus服务器在每次scrape时创建的“ scrape_duration_seconds”量规。</p>
<h2 id="type-handlererrorhandling">type HandlerErrorHandling<a hidden class="anchor" aria-hidden="true" href="#type-handlererrorhandling">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">HandlerErrorHandling</span> <span class="kt">int</span>
</code></pre></td></tr></table>
</div>
</div><p>HandlerErrorHandling定义处理程序服务指标如何处理错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="c1">// Serve an HTTP status code 500 upon the first error
</span><span class="c1"></span>	<span class="c1">// encountered. Report the error message in the body. Note that HTTP
</span><span class="c1"></span>	<span class="c1">// errors cannot be served anymore once the beginning of a regular
</span><span class="c1"></span>	<span class="c1">// payload has been sent. Thus, in the (unlikely) case that encoding the
</span><span class="c1"></span>	<span class="c1">// payload into the negotiated wire format fails, serving the response
</span><span class="c1"></span>	<span class="c1">// will simply be aborted. Set an ErrorLog in HandlerOpts to detect
</span><span class="c1"></span>	<span class="c1">// those errors.
</span><span class="c1"></span>	<span class="nx">HTTPErrorOnError</span> <span class="nx">HandlerErrorHandling</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="c1">// Ignore errors and try to serve as many metrics as possible.  However,
</span><span class="c1"></span>	<span class="c1">// if no metrics can be served, serve an HTTP status code 500 and the
</span><span class="c1"></span>	<span class="c1">// last error message in the body. Only use this in deliberate &#34;best
</span><span class="c1"></span>	<span class="c1">// effort&#34; metrics collection scenarios. In this case, it is highly
</span><span class="c1"></span>	<span class="c1">// recommended to provide other means of detecting errors: By setting an
</span><span class="c1"></span>	<span class="c1">// ErrorLog in HandlerOpts, the errors are logged. By providing a
</span><span class="c1"></span>	<span class="c1">// Registry in HandlerOpts, the exposed metrics include an error counter
</span><span class="c1"></span>	<span class="c1">// &#34;promhttp_metric_handler_errors_total&#34;, which can be used for
</span><span class="c1"></span>	<span class="c1">// alerts.
</span><span class="c1"></span>	<span class="nx">ContinueOnError</span>
	<span class="c1">// Panic upon the first error encountered (useful for &#34;crash only&#34; apps).
</span><span class="c1"></span>	<span class="nx">PanicOnError</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如果遇到错误，这些常量将导致服务度量标准的处理程序行为如所述。</p>
<h2 id="type-handleropts">type HandlerOpts<a hidden class="anchor" aria-hidden="true" href="#type-handleropts">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">HandlerOpts</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// ErrorLog specifies an optional logger for errors collecting and
</span><span class="c1"></span>	<span class="c1">// serving metrics. If nil, errors are not logged at all.
</span><span class="c1"></span>	<span class="nx">ErrorLog</span> <span class="nx">Logger</span>
	<span class="c1">// ErrorHandling defines how errors are handled. Note that errors are
</span><span class="c1"></span>	<span class="c1">// logged regardless of the configured ErrorHandling provided ErrorLog
</span><span class="c1"></span>	<span class="c1">// is not nil.
</span><span class="c1"></span>	<span class="nx">ErrorHandling</span> <span class="nx">HandlerErrorHandling</span>
	<span class="c1">// If Registry is not nil, it is used to register a metric
</span><span class="c1"></span>	<span class="c1">// &#34;promhttp_metric_handler_errors_total&#34;, partitioned by &#34;cause&#34;. A
</span><span class="c1"></span>	<span class="c1">// failed registration causes a panic. Note that this error counter is
</span><span class="c1"></span>	<span class="c1">// different from the instrumentation you get from the various
</span><span class="c1"></span>	<span class="c1">// InstrumentHandler... helpers. It counts errors that don&#39;t necessarily
</span><span class="c1"></span>	<span class="c1">// result in a non-2xx HTTP status code. There are two typical cases:
</span><span class="c1"></span>	<span class="c1">// (1) Encoding errors that only happen after streaming of the HTTP body
</span><span class="c1"></span>	<span class="c1">// has already started (and the status code 200 has been sent). This
</span><span class="c1"></span>	<span class="c1">// should only happen with custom collectors. (2) Collection errors with
</span><span class="c1"></span>	<span class="c1">// no effect on the HTTP status code because ErrorHandling is set to
</span><span class="c1"></span>	<span class="c1">// ContinueOnError.
</span><span class="c1"></span>	<span class="nx">Registry</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Registerer</span>
	<span class="c1">// If DisableCompression is true, the handler will never compress the
</span><span class="c1"></span>	<span class="c1">// response, even if requested by the client.
</span><span class="c1"></span>	<span class="nx">DisableCompression</span> <span class="kt">bool</span>
	<span class="c1">// The number of concurrent HTTP requests is limited to
</span><span class="c1"></span>	<span class="c1">// MaxRequestsInFlight. Additional requests are responded to with 503
</span><span class="c1"></span>	<span class="c1">// Service Unavailable and a suitable message in the body. If
</span><span class="c1"></span>	<span class="c1">// MaxRequestsInFlight is 0 or negative, no limit is applied.
</span><span class="c1"></span>	<span class="nx">MaxRequestsInFlight</span> <span class="kt">int</span>
	<span class="c1">// If handling a request takes longer than Timeout, it is responded to
</span><span class="c1"></span>	<span class="c1">// with 503 ServiceUnavailable and a suitable Message. No timeout is
</span><span class="c1"></span>	<span class="c1">// applied if Timeout is 0 or negative. Note that with the current
</span><span class="c1"></span>	<span class="c1">// implementation, reaching the timeout simply ends the HTTP requests as
</span><span class="c1"></span>	<span class="c1">// described above (and even that only if sending of the body hasn&#39;t
</span><span class="c1"></span>	<span class="c1">// started yet), while the bulk work of gathering all the metrics keeps
</span><span class="c1"></span>	<span class="c1">// running in the background (with the eventual result to be thrown
</span><span class="c1"></span>	<span class="c1">// away). Until the implementation is improved, it is recommended to
</span><span class="c1"></span>	<span class="c1">// implement a separate timeout in potentially slow Collectors.
</span><span class="c1"></span>	<span class="nx">Timeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
	<span class="c1">// If true, the experimental OpenMetrics encoding is added to the
</span><span class="c1"></span>	<span class="c1">// possible options during content negotiation. Note that Prometheus
</span><span class="c1"></span>	<span class="c1">// 2.5.0+ will negotiate OpenMetrics as first priority. OpenMetrics is
</span><span class="c1"></span>	<span class="c1">// the only way to transmit exemplars. However, the move to OpenMetrics
</span><span class="c1"></span>	<span class="c1">// is not completely transparent. Most notably, the values of &#34;quantile&#34;
</span><span class="c1"></span>	<span class="c1">// labels of Summaries and &#34;le&#34; labels of Histograms are formatted with
</span><span class="c1"></span>	<span class="c1">// a trailing &#34;.0&#34; if they would otherwise look like integer numbers
</span><span class="c1"></span>	<span class="c1">// (which changes the identity of the resulting series on the Prometheus
</span><span class="c1"></span>	<span class="c1">// server).
</span><span class="c1"></span>	<span class="nx">EnableOpenMetrics</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>HandlerOpts指定如何通过http.Handler提供指标的选项。HandlerOpts的零值为合理的默认值。</p>
<h2 id="type-instrumenttrace">type InstrumentTrace<a hidden class="anchor" aria-hidden="true" href="#type-instrumenttrace">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">InstrumentTrace</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">GotConn</span>              <span class="kd">func</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
	<span class="nx">PutIdleConn</span>          <span class="kd">func</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
	<span class="nx">GotFirstResponseByte</span> <span class="kd">func</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
	<span class="nx">Got100Continue</span>       <span class="kd">func</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
	<span class="nx">DNSStart</span>             <span class="kd">func</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
	<span class="nx">DNSDone</span>              <span class="kd">func</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
	<span class="nx">ConnectStart</span>         <span class="kd">func</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
	<span class="nx">ConnectDone</span>          <span class="kd">func</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
	<span class="nx">TLSHandshakeStart</span>    <span class="kd">func</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
	<span class="nx">TLSHandshakeDone</span>     <span class="kd">func</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
	<span class="nx">WroteHeaders</span>         <span class="kd">func</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
	<span class="nx">Wait100Continue</span>      <span class="kd">func</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
	<span class="nx">WroteRequest</span>         <span class="kd">func</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>InstrumentTrace用于在检测可用的httptrace.ClientTrace挂钩函数时提供灵活性。每个函数都传递了一个float64，表示自http请求开始以来的时间（以秒为单位）。用户可以选择单独使用存储桶直方图，也可以基于每个功能实现自定义实例标签。</p>
<h2 id="type-logger">type Logger<a hidden class="anchor" aria-hidden="true" href="#type-logger">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Logger</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Println</span><span class="p">(</span><span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>记录器是HandlerOpts记录所需的最小接口。请注意，标准库中的log.Logger实现了此接口，并且自定义记录器无论如何还很容易实现。</p>
<h2 id="type-roundtripperfunc">type RoundTripperFunc<a hidden class="anchor" aria-hidden="true" href="#type-roundtripperfunc">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">RoundTripperFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Response</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>RoundTripperFunc类型是一个适配器，允许将常规功能用作RoundTrippers。如果f是具有适当签名的函数，则RountTripperFunc（f）是调用f的RoundTripper。</p>
<h2 id="func-instrumentroundtrippercounter">func InstrumentRoundTripperCounter<a hidden class="anchor" aria-hidden="true" href="#func-instrumentroundtrippercounter">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">InstrumentRoundTripperCounter</span><span class="p">(</span><span class="nx">counter</span> <span class="o">*</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterVec</span><span class="p">,</span> <span class="nx">next</span> <span class="nx">http</span><span class="p">.</span><span class="nx">RoundTripper</span><span class="p">)</span> <span class="nx">RoundTripperFunc</span>
</code></pre></td></tr></table>
</div>
</div><p>InstrumentRoundTripperCounter是一个中间件，包装了提供的http.RoundTripper来观察提供的CounterVec的请求结果。CounterVec必须具有零，一或两个非const非咖喱标签。对于这些标签，唯一允许的标签名称是“code”和“method”。否则，该功能会出现问题。如果CounterVec中存在相应的实例标签名称，则可以通过HTTP状态代码和/或HTTP方法对CounterVec进行分区。对于未分区的计数，请使用带有零标签的CounterVec。</p>
<p>如果包装的RoundTripper出现紧急情况或返回非nil错误，则计数器不会递增。</p>
<p>有关示例用法，请参见ExampleInstrumentRoundTripperDuration的示例。</p>
<h2 id="func-instrumentroundtripperduration">func InstrumentRoundTripperDuration<a hidden class="anchor" aria-hidden="true" href="#func-instrumentroundtripperduration">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">InstrumentRoundTripperDuration</span><span class="p">(</span><span class="nx">obs</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">ObserverVec</span><span class="p">,</span> <span class="nx">next</span> <span class="nx">http</span><span class="p">.</span><span class="nx">RoundTripper</span><span class="p">)</span> <span class="nx">RoundTripperFunc</span>
</code></pre></td></tr></table>
</div>
</div><p>InstrumentRoundTripperDuration是一个中间件，包装了提供的http.RoundTripper来观察提供的ObserverVec的请求持续时间。ObserverVec必须具有零，一或两个非const非咖喱标签。对于这些标签，唯一允许的标签名称是“code”和“method”。否则，该功能会出现问题。调用ObserverVec中的Observer的Observe方法时，请求持续时间以秒为单位。如果ObserverVec中存在相应的实例标签名称，则通过HTTP状态代码和/或HTTP方法进行分区。对于未分区的观察，请使用带有零标签的ObserverVec。请注意，直方图的划分是昂贵的，应谨慎使用。</p>
<p>如果包装的RoundTripper出现紧急情况或返回非nil错误，则不会报告任何值。</p>
<p>请注意，只有与Go1.9 +一起使用时，才能保证此方法永远不会观察到负持续时间。</p>
<p>例子</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">client</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">DefaultClient</span>
<span class="nx">client</span><span class="p">.</span><span class="nx">Timeout</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span>

<span class="nx">inFlightGauge</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewGauge</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">{</span>
	<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;client_in_flight_requests&#34;</span><span class="p">,</span>
	<span class="nx">Help</span><span class="p">:</span> <span class="s">&#34;A gauge of in-flight requests for the wrapped client.&#34;</span><span class="p">,</span>
<span class="p">})</span>

<span class="nx">counter</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewCounterVec</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;client_api_requests_total&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span> <span class="s">&#34;A counter for requests from the wrapped client.&#34;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;code&#34;</span><span class="p">,</span> <span class="s">&#34;method&#34;</span><span class="p">},</span>
<span class="p">)</span>

<span class="c1">// dnsLatencyVec uses custom buckets based on expected dns durations.
</span><span class="c1">// It has an instance label &#34;event&#34;, which is set in the
</span><span class="c1">// DNSStart and DNSDonehook functions defined in the
</span><span class="c1">// InstrumentTrace struct below.
</span><span class="c1"></span><span class="nx">dnsLatencyVec</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewHistogramVec</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>    <span class="s">&#34;dns_duration_seconds&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>    <span class="s">&#34;Trace dns latency histogram.&#34;</span><span class="p">,</span>
		<span class="nx">Buckets</span><span class="p">:</span> <span class="p">[]</span><span class="kt">float64</span><span class="p">{</span><span class="mf">.005</span><span class="p">,</span> <span class="mf">.01</span><span class="p">,</span> <span class="mf">.025</span><span class="p">,</span> <span class="mf">.05</span><span class="p">},</span>
	<span class="p">},</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;event&#34;</span><span class="p">},</span>
<span class="p">)</span>

<span class="c1">// tlsLatencyVec uses custom buckets based on expected tls durations.
</span><span class="c1">// It has an instance label &#34;event&#34;, which is set in the
</span><span class="c1">// TLSHandshakeStart and TLSHandshakeDone hook functions defined in the
</span><span class="c1">// InstrumentTrace struct below.
</span><span class="c1"></span><span class="nx">tlsLatencyVec</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewHistogramVec</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>    <span class="s">&#34;tls_duration_seconds&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>    <span class="s">&#34;Trace tls latency histogram.&#34;</span><span class="p">,</span>
		<span class="nx">Buckets</span><span class="p">:</span> <span class="p">[]</span><span class="kt">float64</span><span class="p">{</span><span class="mf">.05</span><span class="p">,</span> <span class="mf">.1</span><span class="p">,</span> <span class="mf">.25</span><span class="p">,</span> <span class="mf">.5</span><span class="p">},</span>
	<span class="p">},</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;event&#34;</span><span class="p">},</span>
<span class="p">)</span>

<span class="c1">// histVec has no labels, making it a zero-dimensional ObserverVec.
</span><span class="c1"></span><span class="nx">histVec</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewHistogramVec</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>    <span class="s">&#34;request_duration_seconds&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>    <span class="s">&#34;A histogram of request latencies.&#34;</span><span class="p">,</span>
		<span class="nx">Buckets</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">DefBuckets</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{},</span>
<span class="p">)</span>

<span class="c1">// Register all of the metrics in the standard registry.
</span><span class="c1"></span><span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">counter</span><span class="p">,</span> <span class="nx">tlsLatencyVec</span><span class="p">,</span> <span class="nx">dnsLatencyVec</span><span class="p">,</span> <span class="nx">histVec</span><span class="p">,</span> <span class="nx">inFlightGauge</span><span class="p">)</span>

<span class="c1">// Define functions for the available httptrace.ClientTrace hook
</span><span class="c1">// functions that we want to instrument.
</span><span class="c1"></span><span class="nx">trace</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">InstrumentTrace</span><span class="p">{</span>
	<span class="nx">DNSStart</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">dnsLatencyVec</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;dns_start&#34;</span><span class="p">).</span><span class="nf">Observe</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="p">},</span>
	<span class="nx">DNSDone</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">dnsLatencyVec</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;dns_done&#34;</span><span class="p">).</span><span class="nf">Observe</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="p">},</span>
	<span class="nx">TLSHandshakeStart</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">tlsLatencyVec</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;tls_handshake_start&#34;</span><span class="p">).</span><span class="nf">Observe</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="p">},</span>
	<span class="nx">TLSHandshakeDone</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">tlsLatencyVec</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;tls_handshake_done&#34;</span><span class="p">).</span><span class="nf">Observe</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="p">},</span>
<span class="p">}</span>

<span class="c1">// Wrap the default RoundTripper with middleware.
</span><span class="c1"></span><span class="nx">roundTripper</span> <span class="o">:=</span> <span class="nf">InstrumentRoundTripperInFlight</span><span class="p">(</span><span class="nx">inFlightGauge</span><span class="p">,</span>
	<span class="nf">InstrumentRoundTripperCounter</span><span class="p">(</span><span class="nx">counter</span><span class="p">,</span>
		<span class="nf">InstrumentRoundTripperTrace</span><span class="p">(</span><span class="nx">trace</span><span class="p">,</span>
			<span class="nf">InstrumentRoundTripperDuration</span><span class="p">(</span><span class="nx">histVec</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nx">DefaultTransport</span><span class="p">),</span>
		<span class="p">),</span>
	<span class="p">),</span>
<span class="p">)</span>

<span class="c1">// Set the RoundTripper on our client.
</span><span class="c1"></span><span class="nx">client</span><span class="p">.</span><span class="nx">Transport</span> <span class="p">=</span> <span class="nx">roundTripper</span>

<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;http://google.com&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;error: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-instrumentroundtripperinflight">func InstrumentRoundTripperInFlight<a hidden class="anchor" aria-hidden="true" href="#func-instrumentroundtripperinflight">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">InstrumentRoundTripperInFlight</span><span class="p">(</span><span class="nx">gauge</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Gauge</span><span class="p">,</span> <span class="nx">next</span> <span class="nx">http</span><span class="p">.</span><span class="nx">RoundTripper</span><span class="p">)</span> <span class="nx">RoundTripperFunc</span>
</code></pre></td></tr></table>
</div>
</div><p>InstrumentRoundTripperInFlight是包装提供的http.RoundTripper的中间件。它将提供的prometheus.Gauge设置为当前由包装的http.RoundTripper处理的请求数。</p>
<p>有关示例用法，请参见ExampleInstrumentRoundTripperDuration的示例。</p>
<h2 id="func-instrumentroundtrippertrace">func InstrumentRoundTripperTrace<a hidden class="anchor" aria-hidden="true" href="#func-instrumentroundtrippertrace">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">InstrumentRoundTripperTrace</span><span class="p">(</span><span class="nx">it</span> <span class="o">*</span><span class="nx">InstrumentTrace</span><span class="p">,</span> <span class="nx">next</span> <span class="nx">http</span><span class="p">.</span><span class="nx">RoundTripper</span><span class="p">)</span> <span class="nx">RoundTripperFunc</span>
</code></pre></td></tr></table>
</div>
</div><p>InstrumentRoundTripperTrace是一个中间件，包装了提供的RoundTripper并报告了InstrumentTrace结构中提供的挂钩函数的时间。提供的InstrumentTrace结构中不存在的挂钩函数将被忽略。向挂钩函数报告的时间是自请求开始以来的时间。只有使用Go1.9 +，这些时间才能保证永远不会为负。（早期的Go版本不使用单调时钟。）请注意，直方图的划分是昂贵的，应谨慎使用。</p>
<p>对于将错误作为参数接收的钩子函数，如果非零错误值，则不会进行观察。</p>
<p>有关示例用法，请参见ExampleInstrumentRoundTripperDuration的示例。</p>
<h2 id="func-roundtripperfunc-roundtrip">func (RoundTripperFunc) RoundTrip<a hidden class="anchor" aria-hidden="true" href="#func-roundtripperfunc-roundtrip">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="nx">RoundTripperFunc</span><span class="p">)</span> <span class="nf">RoundTrip</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Response</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>RoundTrip实现RoundTripper接口。</p>
<h1 id="promauto包">promauto包<a hidden class="anchor" aria-hidden="true" href="#promauto包">#</a></h1>
<h2 id="概述-2">概述<a hidden class="anchor" aria-hidden="true" href="#概述-2">#</a></h2>
<p>软件包promauto为基本的Prometheus度量标准类型及其…Vec和…Func变体提供了替代构造函数。与prometheus程序包中的对应程序不同的是，promauto构造函数返回已在注册表中注册的Collector。有两组构造函数。第一组中的构造函数是顶级函数，而另一组中的构造函数是Factory类型的方法。顶级函数返回在全局注册表（prometheus.DefaultRegisterer）中注册的Collector，而方法返回在构造工厂的注册表中注册的Collector。如果注册失败，所有构造函数都会感到恐慌。</p>
<p>以下示例是一个完整的程序，可从math / rand程序包中创建正态分布的随机数直方图：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
        <span class="s">&#34;math/rand&#34;</span>
        <span class="s">&#34;net/http&#34;</span>

        <span class="s">&#34;github.com/prometheus/client_golang/prometheus&#34;</span>
        <span class="s">&#34;github.com/prometheus/client_golang/prometheus/promauto&#34;</span>
        <span class="s">&#34;github.com/prometheus/client_golang/prometheus/promhttp&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">histogram</span> <span class="p">=</span> <span class="nx">promauto</span><span class="p">.</span><span class="nf">NewHistogram</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramOpts</span><span class="p">{</span>
        <span class="nx">Name</span><span class="p">:</span>    <span class="s">&#34;random_numbers&#34;</span><span class="p">,</span>
        <span class="nx">Help</span><span class="p">:</span>    <span class="s">&#34;A histogram of normally distributed random numbers.&#34;</span><span class="p">,</span>
        <span class="nx">Buckets</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">LinearBuckets</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mf">.1</span><span class="p">,</span> <span class="mi">61</span><span class="p">),</span>
<span class="p">})</span>

<span class="kd">func</span> <span class="nf">Random</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">{</span>
                <span class="nx">histogram</span><span class="p">.</span><span class="nf">Observe</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">NormFloat64</span><span class="p">())</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">go</span> <span class="nf">Random</span><span class="p">()</span>
        <span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/metrics&#34;</span><span class="p">,</span> <span class="nx">promhttp</span><span class="p">.</span><span class="nf">Handler</span><span class="p">())</span>
        <span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:1971&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Prometheus的最小hello-world程序版本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/prometheus/client_golang/prometheus&#34;</span>
	<span class="s">&#34;github.com/prometheus/client_golang/prometheus/promauto&#34;</span>
	<span class="s">&#34;github.com/prometheus/client_golang/prometheus/promhttp&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">promhttp</span><span class="p">.</span><span class="nf">InstrumentHandlerCounter</span><span class="p">(</span>
		<span class="nx">promauto</span><span class="p">.</span><span class="nf">NewCounterVec</span><span class="p">(</span>
			<span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">{</span>
				<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;hello_requests_total&#34;</span><span class="p">,</span>
				<span class="nx">Help</span><span class="p">:</span> <span class="s">&#34;Total number of hello-world requests by HTTP code.&#34;</span><span class="p">,</span>
			<span class="p">},</span>
			<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;code&#34;</span><span class="p">},</span>
		<span class="p">),</span>
		<span class="nx">http</span><span class="p">.</span><span class="nf">HandlerFunc</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;Hello, world!&#34;</span><span class="p">)</span>
		<span class="p">}),</span>
	<span class="p">))</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/metrics&#34;</span><span class="p">,</span> <span class="nx">promhttp</span><span class="p">.</span><span class="nf">Handler</span><span class="p">())</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:1971&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>使用With（prometheus.Registerer）函数创建一个Factory，该函数启用两种使用模式。With（prometheus.Registerer）可以每行调用一次：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">reg</span>           <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewRegistry</span><span class="p">()</span>
	<span class="nx">randomNumbers</span> <span class="p">=</span> <span class="nx">promauto</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">reg</span><span class="p">).</span><span class="nf">NewHistogram</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>    <span class="s">&#34;random_numbers&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>    <span class="s">&#34;A histogram of normally distributed random numbers.&#34;</span><span class="p">,</span>
		<span class="nx">Buckets</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">LinearBuckets</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mf">.1</span><span class="p">,</span> <span class="mi">61</span><span class="p">),</span>
	<span class="p">})</span>
	<span class="nx">requestCount</span> <span class="p">=</span> <span class="nx">promauto</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">reg</span><span class="p">).</span><span class="nf">NewCounterVec</span><span class="p">(</span>
		<span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">{</span>
			<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;http_requests_total&#34;</span><span class="p">,</span>
			<span class="nx">Help</span><span class="p">:</span> <span class="s">&#34;Total number of HTTP requests by status code and method.&#34;</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;code&#34;</span><span class="p">,</span> <span class="s">&#34;method&#34;</span><span class="p">},</span>
	<span class="p">)</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>或者，它可以用于一次创建一个Factory，以便多次使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">reg</span>           <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewRegistry</span><span class="p">()</span>
	<span class="nx">factory</span>       <span class="p">=</span> <span class="nx">promauto</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">reg</span><span class="p">)</span>
	<span class="nx">randomNumbers</span> <span class="p">=</span> <span class="nx">factory</span><span class="p">.</span><span class="nf">NewHistogram</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>    <span class="s">&#34;random_numbers&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>    <span class="s">&#34;A histogram of normally distributed random numbers.&#34;</span><span class="p">,</span>
		<span class="nx">Buckets</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">LinearBuckets</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mf">.1</span><span class="p">,</span> <span class="mi">61</span><span class="p">),</span>
	<span class="p">})</span>
	<span class="nx">requestCount</span> <span class="p">=</span> <span class="nx">factory</span><span class="p">.</span><span class="nf">NewCounterVec</span><span class="p">(</span>
		<span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">{</span>
			<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;http_requests_total&#34;</span><span class="p">,</span>
			<span class="nx">Help</span><span class="p">:</span> <span class="s">&#34;Total number of HTTP requests by status code and method.&#34;</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;code&#34;</span><span class="p">,</span> <span class="s">&#34;method&#34;</span><span class="p">},</span>
	<span class="p">)</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这看起来非常方便。那么，为什么将这些构造函数锁定在单独的程序包中呢？</p>
<p>主要问题是注册可能会失败，例如，如果已经注册了与新注册或注册的不一致或相等的度量标准。因此，prometheus.Registerer接口中的Register方法返回错误，顶级全局prometheus.Register函数向全局注册表进行注册的情况也是如此。prometheus软件包还提供了两者的MustRegister版本。如果注册失败，他们会感到恐慌，并且他们使用Must…惯用语清楚地指出了这一点。在这种情况下，恐慌是有问题的，因为它不仅会发生在调用方提供的输入本身就无效的情况下。这里的情况更加微妙：度量标准的创建和注册往往在代码库中广泛分布。很容易将不兼容的指标添加到代码的不相关部分，突然之间，曾经可以正常工作的代码开始出现恐慌（前提是新添加的度量标准的注册发生在先前存在的度量标准的注册之前）。对于全局注册表，这可能会带来更大的惊喜，在全局注册表中，简单地导入另一个程序包可能会引发恐慌（如果新导入的程序包在其init函数中注册了指标）。至少在普罗米修斯软件包中，指标和其他收集器的创建与注册是分开的。首先创建度量标准，然后明确决定是否要在本地或全局注册表中注册该度量标准，以及是否要处理该错误或可能出现恐慌。使用promauto软件包中的构造函数时，注册是自动的，并且如果注册失败，则总是会出现紧急情况。此外，</p>
<p>单独的软件包允许保守的用户完全忽略它。任何想要使用它的人都将明确使用它，并有机会阅读此警告。</p>
<p>负责任地享受promauto！</p>
<h2 id="func-newcounter-1">func NewCounter<a hidden class="anchor" aria-hidden="true" href="#func-newcounter-1">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewCounter</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">)</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Counter</span>
</code></pre></td></tr></table>
</div>
</div><p>NewCounter的工作原理与prometheus软件包中的同名功能相同，但它会自动向prometheus.DefaultRegisterer注册Counter。如果注册失败，NewCounter会慌张。</p>
<h2 id="func-newcounterfunc-1">func NewCounterFunc<a hidden class="anchor" aria-hidden="true" href="#func-newcounterfunc-1">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewCounterFunc</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">,</span> <span class="nx">function</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">float64</span><span class="p">)</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterFunc</span>
</code></pre></td></tr></table>
</div>
</div><p>NewCounterFunc的工作原理与prometheus软件包中的同名功能相同，但是它会自动将CounterFunc注册到prometheus.DefaultRegisterer中。如果注册失败，NewCounterFunc会发生故障。</p>
<h2 id="func-newcountervec-1">func NewCounterVec<a hidden class="anchor" aria-hidden="true" href="#func-newcountervec-1">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewCounterVec</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">,</span> <span class="nx">labelNames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterVec</span>
</code></pre></td></tr></table>
</div>
</div><p>NewCounterVec的工作方式与prometheus软件包中的同名功能相同，但是它会自动将CounterVec注册到prometheus.DefaultRegisterer中。如果注册失败，NewCounterVec会发生故障。</p>
<h2 id="func-newgauge-1">func NewGauge<a hidden class="anchor" aria-hidden="true" href="#func-newgauge-1">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewGauge</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">)</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Gauge</span>
</code></pre></td></tr></table>
</div>
</div><p>NewGauge的工作原理与prometheus软件包中的同名功能相同，但是它会自动将pro-proeueus.DefaultRegisterer注册到Gauge。如果注册失败，NewGauge会慌张。</p>
<h2 id="func-newgaugefunc-1">func NewGaugeFunc<a hidden class="anchor" aria-hidden="true" href="#func-newgaugefunc-1">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewGaugeFunc</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">,</span> <span class="nx">function</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">float64</span><span class="p">)</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeFunc</span>
</code></pre></td></tr></table>
</div>
</div><p>NewGaugeFunc的工作原理与prometheus软件包中的同名函数相同，但它会自动将GaugeFunc注册到prometheus.DefaultRegisterer中。如果注册失败，NewGaugeFunc会发生故障。</p>
<h2 id="func-newgaugevec-1">func NewGaugeVec<a hidden class="anchor" aria-hidden="true" href="#func-newgaugevec-1">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewGaugeVec</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">,</span> <span class="nx">labelNames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeVec</span>
</code></pre></td></tr></table>
</div>
</div><p>NewGaugeVec的工作方式与prometheus软件包中的同名功能相同，但它会自动将GaugeVec注册到prometheus.DefaultRegisterer中。如果注册失败，NewGaugeVec会发生故障。</p>
<h2 id="func-newhistogram-1">func NewHistogram<a hidden class="anchor" aria-hidden="true" href="#func-newhistogram-1">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewHistogram</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramOpts</span><span class="p">)</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Histogram</span>
</code></pre></td></tr></table>
</div>
</div><p>NewHistogram的工作原理与prometheus软件包中的同名功能相同，但它会自动将prohisteus.DefaultRegisterer注册直方图。如果注册失败，NewHistogram会出现紧急情况。</p>
<h2 id="func-newhistogramvec-1">func NewHistogramVec<a hidden class="anchor" aria-hidden="true" href="#func-newhistogramvec-1">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewHistogramVec</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramOpts</span><span class="p">,</span> <span class="nx">labelNames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramVec</span>
</code></pre></td></tr></table>
</div>
</div><p>NewHistogramVec的工作原理与prometheus软件包中的同名功能相同，但它会自动向prometheus.DefaultRegisterer注册HistogramVec。如果注册失败，则NewHistogramVec会发生故障。</p>
<h2 id="func-newsummary-1">func NewSummary<a hidden class="anchor" aria-hidden="true" href="#func-newsummary-1">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewSummary</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">SummaryOpts</span><span class="p">)</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Summary</span>
</code></pre></td></tr></table>
</div>
</div><p>NewSummary的工作方式与prometheus软件包中的同名功能相同，但是它会自动将摘要摘要注册到prometheus.DefaultRegisterer中。如果注册失败，NewSummary会感到恐慌。</p>
<h2 id="func-newsummaryvec-1">func NewSummaryVec<a hidden class="anchor" aria-hidden="true" href="#func-newsummaryvec-1">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewSummaryVec</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">SummaryOpts</span><span class="p">,</span> <span class="nx">labelNames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">SummaryVec</span>
</code></pre></td></tr></table>
</div>
</div><p>NewSummaryVec的工作方式与prometheus程序包中的同名功能相同，但它会自动向prometheus.DefaultRegisterer注册SummaryVec。如果注册失败，NewSummaryVec会发生故障。</p>
<h2 id="func-newsummaryvec-2">func NewSummaryVec<a hidden class="anchor" aria-hidden="true" href="#func-newsummaryvec-2">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewSummaryVec</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">SummaryOpts</span><span class="p">,</span> <span class="nx">labelNames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">SummaryVec</span>
</code></pre></td></tr></table>
</div>
</div><p>NewUntypedFunc的工作原理与prometheus包中的同名函数相同，但是会自动将untypedFunc注册到prometheus.DefaultRegisterer中。如果注册失败，则NewUntypedFunc会发生故障。</p>
<h2 id="type-factory">type Factory<a hidden class="anchor" aria-hidden="true" href="#type-factory">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Factory</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Factory提供了工厂方法来创建自动在注册器中注册的收集器。使用With功能创建Factory，提供注册器以自动注册创建的收集器。Factory的零值会创建未在任何注册器中注册的收集器。如果注册失败，则工厂将惊慌的所有方法。</p>
<h2 id="func-with">func With<a hidden class="anchor" aria-hidden="true" href="#func-with">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">With</span><span class="p">(</span><span class="nx">r</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Registerer</span><span class="p">)</span> <span class="nx">Factory</span>
</code></pre></td></tr></table>
</div>
</div><p>With使用提供的注册器创建工厂，用于注册创建的收集器。如果提供的注册器为nil，则返回的工厂将创建未在任何注册器中注册的收集器。</p>
<h2 id="func-factory-newcounter">func (Factory) NewCounter<a hidden class="anchor" aria-hidden="true" href="#func-factory-newcounter">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Factory</span><span class="p">)</span> <span class="nf">NewCounter</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">)</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Counter</span>
</code></pre></td></tr></table>
</div>
</div><p>NewCounter的工作方式与prometheus软件包中的同名功能相同，但是它会自动将计数器注册到工厂的注册器中。</p>
<h2 id="func-factory-newcounterfunc">func (Factory) NewCounterFunc<a hidden class="anchor" aria-hidden="true" href="#func-factory-newcounterfunc">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Factory</span><span class="p">)</span> <span class="nf">NewCounterFunc</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">,</span> <span class="nx">function</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">float64</span><span class="p">)</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterFunc</span>
</code></pre></td></tr></table>
</div>
</div><p>NewCounterFunc的工作原理与prometheus软件包中的同名功能类似，但是它会自动将CounterFunc注册到Factory的Registerer。</p>
<h2 id="func-factory-newcountervec">func (Factory) NewCounterVec<a hidden class="anchor" aria-hidden="true" href="#func-factory-newcountervec">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Factory</span><span class="p">)</span> <span class="nf">NewCounterVec</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">,</span> <span class="nx">labelNames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterVec</span>
</code></pre></td></tr></table>
</div>
</div><p>NewCounterVec的工作方式与prometheus软件包中的同名功能相同，但是它会自动将CounterVec注册到工厂的注册器中。</p>
<h2 id="func-factory-newgauge">func (Factory) NewGauge<a hidden class="anchor" aria-hidden="true" href="#func-factory-newgauge">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Factory</span><span class="p">)</span> <span class="nf">NewGauge</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">)</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Gauge</span>
</code></pre></td></tr></table>
</div>
</div><p>NewGauge的工作方式与prometheus软件包中的同名功能相同，但它会自动将Gauge登记到Factory的Registerer。</p>
<h2 id="func-factory-newgaugefunc">func (Factory) NewGaugeFunc<a hidden class="anchor" aria-hidden="true" href="#func-factory-newgaugefunc">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Factory</span><span class="p">)</span> <span class="nf">NewGaugeFunc</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">,</span> <span class="nx">function</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">float64</span><span class="p">)</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeFunc</span>
</code></pre></td></tr></table>
</div>
</div><p>NewGaugeFunc的工作原理与prometheus软件包中的同名功能相同，但是它会自动将GaugeFunc注册到工厂的注册器。</p>
<h2 id="func-factory-newgaugevec">func (Factory) NewGaugeVec<a hidden class="anchor" aria-hidden="true" href="#func-factory-newgaugevec">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Factory</span><span class="p">)</span> <span class="nf">NewGaugeVec</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">,</span> <span class="nx">labelNames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeVec</span>
</code></pre></td></tr></table>
</div>
</div><p>NewGaugeVec的工作方式与prometheus软件包中的同名功能相同，但它会自动将GaugeVec注册到工厂的注册器。</p>
<h2 id="func-factory-newhistogram">func (Factory) NewHistogram<a hidden class="anchor" aria-hidden="true" href="#func-factory-newhistogram">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Factory</span><span class="p">)</span> <span class="nf">NewHistogram</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramOpts</span><span class="p">)</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Histogram</span>
</code></pre></td></tr></table>
</div>
</div><p>NewHistogram的工作方式与Prometheus软件包中的同名功能相同，但它会自动将Histogram注册到Factory的Registerer中。</p>
<h2 id="func-factory-newhistogramvec">func (Factory) NewHistogramVec<a hidden class="anchor" aria-hidden="true" href="#func-factory-newhistogramvec">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Factory</span><span class="p">)</span> <span class="nf">NewHistogramVec</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramOpts</span><span class="p">,</span> <span class="nx">labelNames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramVec</span>
</code></pre></td></tr></table>
</div>
</div><p>NewHistogramVec的工作方式与prometheus软件包中的同名功能相同，但是它会自动将HistogramVec注册到Factory的Registerer。</p>
<h2 id="func-factory-newsummary">func (Factory) NewSummary<a hidden class="anchor" aria-hidden="true" href="#func-factory-newsummary">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Factory</span><span class="p">)</span> <span class="nf">NewSummary</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">SummaryOpts</span><span class="p">)</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Summary</span>
</code></pre></td></tr></table>
</div>
</div><p>NewSummary的工作方式与prometheus软件包中的同名功能相同，但它会自动向工厂的注册器注册摘要。</p>
<h2 id="func-factory-newsummaryvec">func (Factory) NewSummaryVec<a hidden class="anchor" aria-hidden="true" href="#func-factory-newsummaryvec">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Factory</span><span class="p">)</span> <span class="nf">NewSummaryVec</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">SummaryOpts</span><span class="p">,</span> <span class="nx">labelNames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">SummaryVec</span>
</code></pre></td></tr></table>
</div>
</div><p>NewSummaryVec的工作方式与prometheus程序包中的同名功能相同，但它会自动向工厂的注册器注册SummaryVec。</p>
<h2 id="func-factory-newuntypedfunc">func (Factory) NewUntypedFunc<a hidden class="anchor" aria-hidden="true" href="#func-factory-newuntypedfunc">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Factory</span><span class="p">)</span> <span class="nf">NewUntypedFunc</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">UntypedOpts</span><span class="p">,</span> <span class="nx">function</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">float64</span><span class="p">)</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">UntypedFunc</span>
</code></pre></td></tr></table>
</div>
</div><p>NewUntypedFunc的工作方式与prometheus包中的同名功能相同，但是它会自动将UntypedFunc注册到工厂的注册器中。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/prometheus/">Prometheus</a></li>
      <li><a href="/tags/go/">Go</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
